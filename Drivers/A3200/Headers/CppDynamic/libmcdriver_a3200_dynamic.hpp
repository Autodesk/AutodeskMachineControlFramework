/*++

Copyright (C) 2023 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver A3200

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_A3200_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_A3200_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_a3200_types.hpp"
#include "libmcdriver_a3200_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_A3200 {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CDriver_A3200;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_A3200Wrapper;
typedef CBase CLibMCDriver_A3200Base;
typedef CDriver CLibMCDriver_A3200Driver;
typedef CDriver_A3200 CLibMCDriver_A3200Driver_A3200;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CDriver_A3200> PDriver_A3200;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_A3200Wrapper;
typedef PBase PLibMCDriver_A3200Base;
typedef PDriver PLibMCDriver_A3200Driver;
typedef PDriver_A3200 PLibMCDriver_A3200Driver_A3200;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_A3200Handle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_A3200Exception 
**************************************************************************************************************************/
class ELibMCDriver_A3200Exception : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_A3200Result m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_A3200Exception(LibMCDriver_A3200Result errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_A3200Result getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_A3200_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_A3200_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_A3200_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_A3200_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_A3200_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_A3200_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_A3200_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_A3200_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_A3200_ERROR_DRIVERERROR: return "DRIVERERROR";
			case LIBMCDRIVER_A3200_ERROR_DRIVERNOTINITIALISED: return "DRIVERNOTINITIALISED";
			case LIBMCDRIVER_A3200_ERROR_DRIVERNOTCONNECTED: return "DRIVERNOTCONNECTED";
			case LIBMCDRIVER_A3200_ERROR_INVALIDDRIVERPROTOCOL: return "INVALIDDRIVERPROTOCOL";
			case LIBMCDRIVER_A3200_ERROR_COULDNOTPARSEDRIVERPROTOCOL: return "COULDNOTPARSEDRIVERPROTOCOL";
			case LIBMCDRIVER_A3200_ERROR_NOWORKINGDIRECTORY: return "NOWORKINGDIRECTORY";
			case LIBMCDRIVER_A3200_ERROR_INVALIDTASKID: return "INVALIDTASKID";
			case LIBMCDRIVER_A3200_ERROR_VERSIONMISMATCH: return "VERSIONMISMATCH";
			case LIBMCDRIVER_A3200_ERROR_FEATURELOCKED: return "FEATURELOCKED";
			case LIBMCDRIVER_A3200_ERROR_UNSUPPORTEDHARDWARE: return "UNSUPPORTEDHARDWARE";
			case LIBMCDRIVER_A3200_ERROR_RESETTIMEOUT: return "RESETTIMEOUT";
			case LIBMCDRIVER_A3200_ERROR_ALLOCATIONFAILED: return "ALLOCATIONFAILED";
			case LIBMCDRIVER_A3200_ERROR_NOTCONNECTED: return "NOTCONNECTED";
			case LIBMCDRIVER_A3200_ERROR_INVALIDAXISINDEX: return "INVALIDAXISINDEX";
			case LIBMCDRIVER_A3200_ERROR_TOOLTABLEERROR: return "TOOLTABLEERROR";
			case LIBMCDRIVER_A3200_ERROR_DRIVECOMMANDLOST: return "DRIVECOMMANDLOST";
			case LIBMCDRIVER_A3200_ERROR_DRIVECOMMANDRESPONSE: return "DRIVECOMMANDRESPONSE";
			case LIBMCDRIVER_A3200_ERROR_FIREWIREISONCHRONOUSERROR: return "FIREWIREISONCHRONOUSERROR";
			case LIBMCDRIVER_A3200_ERROR_FIREWIREASYNCHRONOUSERROR: return "FIREWIREASYNCHRONOUSERROR";
			case LIBMCDRIVER_A3200_ERROR_PCMODBUSERROR: return "PCMODBUSERROR";
			case LIBMCDRIVER_A3200_ERROR_COMMUNICATIONLOST: return "COMMUNICATIONLOST";
			case LIBMCDRIVER_A3200_ERROR_ETHERNETCOMMUNICATIONLOST: return "ETHERNETCOMMUNICATIONLOST";
			case LIBMCDRIVER_A3200_ERROR_SERVICECOMMUNICATIONLOST: return "SERVICECOMMUNICATIONLOST";
			case LIBMCDRIVER_A3200_ERROR_FIREWIRECARDCONFIGURATION: return "FIREWIRECARDCONFIGURATION";
			case LIBMCDRIVER_A3200_ERROR_PCICARDERROR: return "PCICARDERROR";
			case LIBMCDRIVER_A3200_ERROR_AXISMISMATCH: return "AXISMISMATCH";
			case LIBMCDRIVER_A3200_ERROR_TASKMISMATCH: return "TASKMISMATCH";
			case LIBMCDRIVER_A3200_ERROR_INVALIDCOMMANDLINE: return "INVALIDCOMMANDLINE";
			case LIBMCDRIVER_A3200_ERROR_MACHINECONFIGURATION: return "MACHINECONFIGURATION";
			case LIBMCDRIVER_A3200_ERROR_FIREWIRECONFIGURATION: return "FIREWIRECONFIGURATION";
			case LIBMCDRIVER_A3200_ERROR_GANTRYCONFIGURATION: return "GANTRYCONFIGURATION";
			case LIBMCDRIVER_A3200_ERROR_CALLBACKTIMEOUT: return "CALLBACKTIMEOUT";
			case LIBMCDRIVER_A3200_ERROR_CALLBACKERROR: return "CALLBACKERROR";
			case LIBMCDRIVER_A3200_ERROR_TOOMANYSTATUSITEMS: return "TOOMANYSTATUSITEMS";
			case LIBMCDRIVER_A3200_ERROR_PROGRAMERROR: return "PROGRAMERROR";
			case LIBMCDRIVER_A3200_ERROR_STRINGOVERFLOW: return "STRINGOVERFLOW";
			case LIBMCDRIVER_A3200_ERROR_DIVIDEBYZERO: return "DIVIDEBYZERO";
			case LIBMCDRIVER_A3200_ERROR_PROGRAMTIMEOUT: return "PROGRAMTIMEOUT";
			case LIBMCDRIVER_A3200_ERROR_PROFILEQUEUEERROR: return "PROFILEQUEUEERROR";
			case LIBMCDRIVER_A3200_ERROR_INVALIDARGUMENT: return "INVALIDARGUMENT";
			case LIBMCDRIVER_A3200_ERROR_PARAMETERNOTPASSED: return "PARAMETERNOTPASSED";
			case LIBMCDRIVER_A3200_ERROR_QUEUEBUFFERFULL: return "QUEUEBUFFERFULL";
			case LIBMCDRIVER_A3200_ERROR_NULLPROGRAMLINE: return "NULLPROGRAMLINE";
			case LIBMCDRIVER_A3200_ERROR_PROGRAMNUMBEROUTOFBOUNDS: return "PROGRAMNUMBEROUTOFBOUNDS";
			case LIBMCDRIVER_A3200_ERROR_CANNEDFUNCTIONERROR: return "CANNEDFUNCTIONERROR";
			case LIBMCDRIVER_A3200_ERROR_ZEROSPEED: return "ZEROSPEED";
			case LIBMCDRIVER_A3200_ERROR_STACKERROR: return "STACKERROR";
			case LIBMCDRIVER_A3200_ERROR_SLICEERROR: return "SLICEERROR";
			case LIBMCDRIVER_A3200_ERROR_LOOKAHEADERROR: return "LOOKAHEADERROR";
			case LIBMCDRIVER_A3200_ERROR_RETRACEERROR: return "RETRACEERROR";
			case LIBMCDRIVER_A3200_ERROR_AXISINFAULT: return "AXISINFAULT";
			case LIBMCDRIVER_A3200_ERROR_AXISNOTENABLED: return "AXISNOTENABLED";
			case LIBMCDRIVER_A3200_ERROR_MOTIONERROR: return "MOTIONERROR";
			case LIBMCDRIVER_A3200_ERROR_GANTRYMOTIONERROR: return "GANTRYMOTIONERROR";
			case LIBMCDRIVER_A3200_ERROR_CUTTERCOMPENSATIONERROR: return "CUTTERCOMPENSATIONERROR";
			case LIBMCDRIVER_A3200_ERROR_CIRCULARMOTIONERROR: return "CIRCULARMOTIONERROR";
			case LIBMCDRIVER_A3200_ERROR_CIRCULARRADIUSERROR: return "CIRCULARRADIUSERROR";
			case LIBMCDRIVER_A3200_ERROR_NORMALCYERROR: return "NORMALCYERROR";
			case LIBMCDRIVER_A3200_ERROR_MOTIONTYPEMISMATCH: return "MOTIONTYPEMISMATCH";
			case LIBMCDRIVER_A3200_ERROR_SPINDLENUMBERNOTASSIGNED: return "SPINDLENUMBERNOTASSIGNED";
			case LIBMCDRIVER_A3200_ERROR_ELLIPTICALMOTIONERROR: return "ELLIPTICALMOTIONERROR";
			case LIBMCDRIVER_A3200_ERROR_MOTIONACTIVE: return "MOTIONACTIVE";
			case LIBMCDRIVER_A3200_ERROR_AXISNOTDEPENDENT: return "AXISNOTDEPENDENT";
			case LIBMCDRIVER_A3200_ERROR_AXISNOTDOMINANT: return "AXISNOTDOMINANT";
			case LIBMCDRIVER_A3200_ERROR_NOJOYSTICKGROUPS: return "NOJOYSTICKGROUPS";
			case LIBMCDRIVER_A3200_ERROR_TRANSFORMATIONERROR: return "TRANSFORMATIONERROR";
			case LIBMCDRIVER_A3200_ERROR_CALIBRATIONTABLEERROR: return "CALIBRATIONTABLEERROR";
			case LIBMCDRIVER_A3200_ERROR_CAMTABLEERROR: return "CAMTABLEERROR";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_A3200_SUCCESS: return "success";
			case LIBMCDRIVER_A3200_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_A3200_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_A3200_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_A3200_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_A3200_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_A3200_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_A3200_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_A3200_ERROR_DRIVERERROR: return "a driver error occured";
			case LIBMCDRIVER_A3200_ERROR_DRIVERNOTINITIALISED: return "the driver is not initialised";
			case LIBMCDRIVER_A3200_ERROR_DRIVERNOTCONNECTED: return "the driver is not connected";
			case LIBMCDRIVER_A3200_ERROR_INVALIDDRIVERPROTOCOL: return "invalid driver protocol definition";
			case LIBMCDRIVER_A3200_ERROR_COULDNOTPARSEDRIVERPROTOCOL: return "could not parse driver protocol";
			case LIBMCDRIVER_A3200_ERROR_NOWORKINGDIRECTORY: return "No working directory";
			case LIBMCDRIVER_A3200_ERROR_INVALIDTASKID: return "Invalid task ID";
			case LIBMCDRIVER_A3200_ERROR_VERSIONMISMATCH: return "An incompatible version was detected";
			case LIBMCDRIVER_A3200_ERROR_FEATURELOCKED: return "A license error occurred";
			case LIBMCDRIVER_A3200_ERROR_UNSUPPORTEDHARDWARE: return "A connected hardware type is no longer supported";
			case LIBMCDRIVER_A3200_ERROR_RESETTIMEOUT: return "A timeout occurred while waiting for the controller reset to finish.";
			case LIBMCDRIVER_A3200_ERROR_ALLOCATIONFAILED: return "An attempt to allocate memory on the SMC failed";
			case LIBMCDRIVER_A3200_ERROR_NOTCONNECTED: return "The specified controller handle is invalid";
			case LIBMCDRIVER_A3200_ERROR_INVALIDAXISINDEX: return "The specified axis index is invalid.";
			case LIBMCDRIVER_A3200_ERROR_TOOLTABLEERROR: return "A problem occurred with a tool table";
			case LIBMCDRIVER_A3200_ERROR_DRIVECOMMANDLOST: return "A drive command was overwritten and lost.";
			case LIBMCDRIVER_A3200_ERROR_DRIVECOMMANDRESPONSE: return "A timeout occurred while waiting for a drive response";
			case LIBMCDRIVER_A3200_ERROR_FIREWIREISONCHRONOUSERROR: return "An error occurred with isochronous communication";
			case LIBMCDRIVER_A3200_ERROR_FIREWIREASYNCHRONOUSERROR: return "An error occurred during an asynchronous communication";
			case LIBMCDRIVER_A3200_ERROR_PCMODBUSERROR: return "An error occurred with PC Modbus communication";
			case LIBMCDRIVER_A3200_ERROR_COMMUNICATIONLOST: return "FireWire communications were interrupted.";
			case LIBMCDRIVER_A3200_ERROR_ETHERNETCOMMUNICATIONLOST: return "Ethernet communications were interrupted.";
			case LIBMCDRIVER_A3200_ERROR_SERVICECOMMUNICATIONLOST: return "Communication Service communications were interrupted.";
			case LIBMCDRIVER_A3200_ERROR_FIREWIRECARDCONFIGURATION: return "The FireWire card configuration is invalid.";
			case LIBMCDRIVER_A3200_ERROR_PCICARDERROR: return "A problem exists with PCI card configuration.";
			case LIBMCDRIVER_A3200_ERROR_AXISMISMATCH: return "An incorrect number of axes are attached.";
			case LIBMCDRIVER_A3200_ERROR_TASKMISMATCH: return "An insufficient number of tasks are enabled.";
			case LIBMCDRIVER_A3200_ERROR_INVALIDCOMMANDLINE: return "An invalid SMC command line argument was specified.";
			case LIBMCDRIVER_A3200_ERROR_MACHINECONFIGURATION: return "An error occurred while accessing the machine configuration.";
			case LIBMCDRIVER_A3200_ERROR_FIREWIRECONFIGURATION: return "An error was detected in the FireWire configuration.";
			case LIBMCDRIVER_A3200_ERROR_GANTRYCONFIGURATION: return "An error gantry configuration was detected.";
			case LIBMCDRIVER_A3200_ERROR_CALLBACKTIMEOUT: return "A timeout occurred while responding to a callback.";
			case LIBMCDRIVER_A3200_ERROR_CALLBACKERROR: return "A timeout occurred while responding to a callback.";
			case LIBMCDRIVER_A3200_ERROR_TOOMANYSTATUSITEMS: return "The maximum number of status items was exceeded.";
			case LIBMCDRIVER_A3200_ERROR_PROGRAMERROR: return "An error occurred in program execution.";
			case LIBMCDRIVER_A3200_ERROR_STRINGOVERFLOW: return "The maximum string length was exceeded.";
			case LIBMCDRIVER_A3200_ERROR_DIVIDEBYZERO: return "A divide-by-zero was detected.";
			case LIBMCDRIVER_A3200_ERROR_PROGRAMTIMEOUT: return "A program timeout occurred.";
			case LIBMCDRIVER_A3200_ERROR_PROFILEQUEUEERROR: return "An error occurred in the execution queue";
			case LIBMCDRIVER_A3200_ERROR_INVALIDARGUMENT: return "An invalid argument was specified.";
			case LIBMCDRIVER_A3200_ERROR_PARAMETERNOTPASSED: return "A callstack argument was not passed to a subroutine.";
			case LIBMCDRIVER_A3200_ERROR_QUEUEBUFFERFULL: return "The buffered program queue is full.";
			case LIBMCDRIVER_A3200_ERROR_NULLPROGRAMLINE: return "A NULL code line pointer was specified.";
			case LIBMCDRIVER_A3200_ERROR_PROGRAMNUMBEROUTOFBOUNDS: return "The specified program number is outside of the valid range of values.";
			case LIBMCDRIVER_A3200_ERROR_CANNEDFUNCTIONERROR: return "An error occurred with a canned function.";
			case LIBMCDRIVER_A3200_ERROR_ZEROSPEED: return "The move speed is zero.";
			case LIBMCDRIVER_A3200_ERROR_STACKERROR: return "A stack error occurred.";
			case LIBMCDRIVER_A3200_ERROR_SLICEERROR: return "An error occurred while executing the SLICE command.";
			case LIBMCDRIVER_A3200_ERROR_LOOKAHEADERROR: return "A error occurred while performing lookahead.";
			case LIBMCDRIVER_A3200_ERROR_RETRACEERROR: return "An error occurred while doing retrace.";
			case LIBMCDRIVER_A3200_ERROR_AXISINFAULT: return "An axis fault occurred.";
			case LIBMCDRIVER_A3200_ERROR_AXISNOTENABLED: return "The axis is not enabled.";
			case LIBMCDRIVER_A3200_ERROR_MOTIONERROR: return "An error occurred with a motion command.";
			case LIBMCDRIVER_A3200_ERROR_GANTRYMOTIONERROR: return "An error occurred while performing gantry motion.";
			case LIBMCDRIVER_A3200_ERROR_CUTTERCOMPENSATIONERROR: return "An error occurred while peforming cutter compensation.";
			case LIBMCDRIVER_A3200_ERROR_CIRCULARMOTIONERROR: return "An error occurred while performing circular motion.";
			case LIBMCDRIVER_A3200_ERROR_CIRCULARRADIUSERROR: return "A circular radius error occurred.";
			case LIBMCDRIVER_A3200_ERROR_NORMALCYERROR: return "An error occurred while performing normalcy.";
			case LIBMCDRIVER_A3200_ERROR_MOTIONTYPEMISMATCH: return "A LINEAR move is required to execute this command.";
			case LIBMCDRIVER_A3200_ERROR_SPINDLENUMBERNOTASSIGNED: return "The specified spindle is not assigned to an axis.";
			case LIBMCDRIVER_A3200_ERROR_ELLIPTICALMOTIONERROR: return "An error occurred while performing elliptical motion.";
			case LIBMCDRIVER_A3200_ERROR_MOTIONACTIVE: return "Motion is already active.";
			case LIBMCDRIVER_A3200_ERROR_AXISNOTDEPENDENT: return "This feature is only available on dependent axes.";
			case LIBMCDRIVER_A3200_ERROR_AXISNOTDOMINANT: return "This feature is only available on dominant axes.";
			case LIBMCDRIVER_A3200_ERROR_NOJOYSTICKGROUPS: return "No joystick groups have been specified.";
			case LIBMCDRIVER_A3200_ERROR_TRANSFORMATIONERROR: return "An error occurred performing a transformation.";
			case LIBMCDRIVER_A3200_ERROR_CALIBRATIONTABLEERROR: return "An error occurred with a calibration table.";
			case LIBMCDRIVER_A3200_ERROR_CAMTABLEERROR: return "An error occurred with a cam table command.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_A3200InputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_A3200Result nResult);

	inline void GetVersion(LibMCDriver_A3200_uint32 & nMajor, LibMCDriver_A3200_uint32 & nMinor, LibMCDriver_A3200_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_A3200_pvoid pSymbolAddressMethod);
	inline LibMCDriver_A3200_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_A3200DynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_A3200Result checkBinaryVersion()
	{
		LibMCDriver_A3200_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_A3200_VERSION_MAJOR) {
			return LIBMCDRIVER_A3200_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_A3200_SUCCESS;
	}
	LibMCDriver_A3200Result initWrapperTable(sLibMCDriver_A3200DynamicWrapperTable * pWrapperTable);
	LibMCDriver_A3200Result releaseWrapperTable(sLibMCDriver_A3200DynamicWrapperTable * pWrapperTable);
	LibMCDriver_A3200Result loadWrapperTable(sLibMCDriver_A3200DynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_A3200Result loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_A3200DynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CDriver_A3200;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_A3200Handle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_A3200Result nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_A3200Handle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_A3200Handle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_A3200Handle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_A3200_uint32 & nMajor, LibMCDriver_A3200_uint32 & nMinor, LibMCDriver_A3200_uint32 & nMicro, std::string & sBuild);
	inline void QueryParameters();
	inline void QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance);
};
	
/*************************************************************************************************************************
 Class CDriver_A3200 
**************************************************************************************************************************/
class CDriver_A3200 : public CDriver {
public:
	
	/**
	* CDriver_A3200::CDriver_A3200 - Constructor for Driver_A3200 class.
	*/
	CDriver_A3200(CWrapper* pWrapper, LibMCDriver_A3200Handle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline void SetToSimulationMode();
	inline bool IsSimulationMode();
	inline void SetCustomSDKResource(const std::string & sCoreResourceName, const std::string & sSystemResourceName, const std::string & sCompilerResourceName, const std::string & sUtilitiesResourceName, const std::string & sLicenseDecoderResourceName);
	inline void SetCustomSDK(const CInputVector<LibMCDriver_A3200_uint8> & CoreSDKBufferBuffer, const CInputVector<LibMCDriver_A3200_uint8> & SystemSDKBufferBuffer, const CInputVector<LibMCDriver_A3200_uint8> & CompilerSDKBufferBuffer, const CInputVector<LibMCDriver_A3200_uint8> & UtilitiesSDKBufferBuffer, const CInputVector<LibMCDriver_A3200_uint8> & LicenseDecoderSDKBufferBuffer);
	inline void Connect();
	inline void Disconnect();
	inline void RunScript(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sScript);
	inline void RunCommand(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sCommand);
	inline void StopProgram(const LibMCDriver_A3200_uint32 nTaskID, const LibMCDriver_A3200_uint32 nTimeout);
	inline LibMCDriver_A3200_double ReadGlobalNumberVariable(const std::string & sName);
	inline void WriteGlobalNumberVariable(const std::string & sName, const LibMCDriver_A3200_double dValue);
	inline std::string ReadGlobalStringVariable(const std::string & sName);
	inline void WriteGlobalStringVariable(const std::string & sName, const std::string & sValue);
	inline LibMCDriver_A3200_double ReadTaskNumberVariable(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sName);
	inline void WriteTaskNumberVariable(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sName, const LibMCDriver_A3200_double dValue);
	inline std::string ReadTaskStringVariable(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sName);
	inline void WriteTaskStringVariable(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sName, const std::string & sValue);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_A3200_uint32 & nMajor, LibMCDriver_A3200_uint32 & nMinor, LibMCDriver_A3200_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_A3200Handle hInstance = pInstance.GetHandle();
		LibMCDriver_A3200_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_A3200_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_A3200Handle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_A3200Handle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_A3200_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_A3200Exception(LIBMCDRIVER_A3200_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_A3200Exception(LIBMCDRIVER_A3200_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_A3200_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_A3200_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_A3200Handle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (hInstance) {
			return std::make_shared<CDriver>(this, hInstance);
		} else {
			return nullptr;
		}
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_A3200Result nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_A3200Exception(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_A3200Result CWrapper::initWrapperTable(sLibMCDriver_A3200DynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_Driver_QueryParametersEx = nullptr;
		pWrapperTable->m_Driver_A3200_SetToSimulationMode = nullptr;
		pWrapperTable->m_Driver_A3200_IsSimulationMode = nullptr;
		pWrapperTable->m_Driver_A3200_SetCustomSDKResource = nullptr;
		pWrapperTable->m_Driver_A3200_SetCustomSDK = nullptr;
		pWrapperTable->m_Driver_A3200_Connect = nullptr;
		pWrapperTable->m_Driver_A3200_Disconnect = nullptr;
		pWrapperTable->m_Driver_A3200_RunScript = nullptr;
		pWrapperTable->m_Driver_A3200_RunCommand = nullptr;
		pWrapperTable->m_Driver_A3200_StopProgram = nullptr;
		pWrapperTable->m_Driver_A3200_ReadGlobalNumberVariable = nullptr;
		pWrapperTable->m_Driver_A3200_WriteGlobalNumberVariable = nullptr;
		pWrapperTable->m_Driver_A3200_ReadGlobalStringVariable = nullptr;
		pWrapperTable->m_Driver_A3200_WriteGlobalStringVariable = nullptr;
		pWrapperTable->m_Driver_A3200_ReadTaskNumberVariable = nullptr;
		pWrapperTable->m_Driver_A3200_WriteTaskNumberVariable = nullptr;
		pWrapperTable->m_Driver_A3200_ReadTaskStringVariable = nullptr;
		pWrapperTable->m_Driver_A3200_WriteTaskStringVariable = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_A3200_SUCCESS;
	}

	inline LibMCDriver_A3200Result CWrapper::releaseWrapperTable(sLibMCDriver_A3200DynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_A3200_SUCCESS;
	}

	inline LibMCDriver_A3200Result CWrapper::loadWrapperTable(sLibMCDriver_A3200DynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_A3200_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_A3200_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_A3200_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_A3200Driver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_A3200Driver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_A3200Driver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_A3200Driver_GetNamePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_A3200Driver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_A3200Driver_GetTypePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_A3200Driver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_A3200Driver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_a3200_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_A3200Driver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_A3200Driver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_a3200_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_A3200Driver_QueryParametersExPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_queryparametersex");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_A3200Driver_QueryParametersExPtr) dlsym(hLibrary, "libmcdriver_a3200_driver_queryparametersex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParametersEx == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_SetToSimulationMode = (PLibMCDriver_A3200Driver_A3200_SetToSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_settosimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_SetToSimulationMode = (PLibMCDriver_A3200Driver_A3200_SetToSimulationModePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_settosimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_SetToSimulationMode == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_IsSimulationMode = (PLibMCDriver_A3200Driver_A3200_IsSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_issimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_IsSimulationMode = (PLibMCDriver_A3200Driver_A3200_IsSimulationModePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_issimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_IsSimulationMode == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_SetCustomSDKResource = (PLibMCDriver_A3200Driver_A3200_SetCustomSDKResourcePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_setcustomsdkresource");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_SetCustomSDKResource = (PLibMCDriver_A3200Driver_A3200_SetCustomSDKResourcePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_setcustomsdkresource");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_SetCustomSDKResource == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_SetCustomSDK = (PLibMCDriver_A3200Driver_A3200_SetCustomSDKPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_setcustomsdk");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_SetCustomSDK = (PLibMCDriver_A3200Driver_A3200_SetCustomSDKPtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_setcustomsdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_SetCustomSDK == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_Connect = (PLibMCDriver_A3200Driver_A3200_ConnectPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_connect");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_Connect = (PLibMCDriver_A3200Driver_A3200_ConnectPtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_connect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_Connect == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_Disconnect = (PLibMCDriver_A3200Driver_A3200_DisconnectPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_disconnect");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_Disconnect = (PLibMCDriver_A3200Driver_A3200_DisconnectPtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_disconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_Disconnect == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_RunScript = (PLibMCDriver_A3200Driver_A3200_RunScriptPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_runscript");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_RunScript = (PLibMCDriver_A3200Driver_A3200_RunScriptPtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_runscript");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_RunScript == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_RunCommand = (PLibMCDriver_A3200Driver_A3200_RunCommandPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_runcommand");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_RunCommand = (PLibMCDriver_A3200Driver_A3200_RunCommandPtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_runcommand");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_RunCommand == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_StopProgram = (PLibMCDriver_A3200Driver_A3200_StopProgramPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_stopprogram");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_StopProgram = (PLibMCDriver_A3200Driver_A3200_StopProgramPtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_stopprogram");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_StopProgram == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_ReadGlobalNumberVariable = (PLibMCDriver_A3200Driver_A3200_ReadGlobalNumberVariablePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_readglobalnumbervariable");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_ReadGlobalNumberVariable = (PLibMCDriver_A3200Driver_A3200_ReadGlobalNumberVariablePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_readglobalnumbervariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_ReadGlobalNumberVariable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_WriteGlobalNumberVariable = (PLibMCDriver_A3200Driver_A3200_WriteGlobalNumberVariablePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_writeglobalnumbervariable");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_WriteGlobalNumberVariable = (PLibMCDriver_A3200Driver_A3200_WriteGlobalNumberVariablePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_writeglobalnumbervariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_WriteGlobalNumberVariable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_ReadGlobalStringVariable = (PLibMCDriver_A3200Driver_A3200_ReadGlobalStringVariablePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_readglobalstringvariable");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_ReadGlobalStringVariable = (PLibMCDriver_A3200Driver_A3200_ReadGlobalStringVariablePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_readglobalstringvariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_ReadGlobalStringVariable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_WriteGlobalStringVariable = (PLibMCDriver_A3200Driver_A3200_WriteGlobalStringVariablePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_writeglobalstringvariable");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_WriteGlobalStringVariable = (PLibMCDriver_A3200Driver_A3200_WriteGlobalStringVariablePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_writeglobalstringvariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_WriteGlobalStringVariable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_ReadTaskNumberVariable = (PLibMCDriver_A3200Driver_A3200_ReadTaskNumberVariablePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_readtasknumbervariable");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_ReadTaskNumberVariable = (PLibMCDriver_A3200Driver_A3200_ReadTaskNumberVariablePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_readtasknumbervariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_ReadTaskNumberVariable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_WriteTaskNumberVariable = (PLibMCDriver_A3200Driver_A3200_WriteTaskNumberVariablePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_writetasknumbervariable");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_WriteTaskNumberVariable = (PLibMCDriver_A3200Driver_A3200_WriteTaskNumberVariablePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_writetasknumbervariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_WriteTaskNumberVariable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_ReadTaskStringVariable = (PLibMCDriver_A3200Driver_A3200_ReadTaskStringVariablePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_readtaskstringvariable");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_ReadTaskStringVariable = (PLibMCDriver_A3200Driver_A3200_ReadTaskStringVariablePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_readtaskstringvariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_ReadTaskStringVariable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_A3200_WriteTaskStringVariable = (PLibMCDriver_A3200Driver_A3200_WriteTaskStringVariablePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_driver_a3200_writetaskstringvariable");
		#else // _WIN32
		pWrapperTable->m_Driver_A3200_WriteTaskStringVariable = (PLibMCDriver_A3200Driver_A3200_WriteTaskStringVariablePtr) dlsym(hLibrary, "libmcdriver_a3200_driver_a3200_writetaskstringvariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_A3200_WriteTaskStringVariable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_A3200GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_A3200GetVersionPtr) dlsym(hLibrary, "libmcdriver_a3200_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_A3200GetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_A3200GetLastErrorPtr) dlsym(hLibrary, "libmcdriver_a3200_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_A3200ReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_A3200ReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_a3200_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_A3200AcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_a3200_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_A3200AcquireInstancePtr) dlsym(hLibrary, "libmcdriver_a3200_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_A3200InjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_A3200InjectComponentPtr) dlsym(hLibrary, "libmcdriver_a3200_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_A3200GetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_A3200GetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_a3200_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_A3200CreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_a3200_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_A3200CreateDriverPtr) dlsym(hLibrary, "libmcdriver_a3200_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_A3200_SUCCESS;
	}

	inline LibMCDriver_A3200Result CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_A3200DynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_A3200_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_A3200_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_A3200Result(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_A3200Result eLookupError = LIBMCDRIVER_A3200_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_queryparametersex", (void**)&(pWrapperTable->m_Driver_QueryParametersEx));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParametersEx == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_settosimulationmode", (void**)&(pWrapperTable->m_Driver_A3200_SetToSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_SetToSimulationMode == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_issimulationmode", (void**)&(pWrapperTable->m_Driver_A3200_IsSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_IsSimulationMode == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_setcustomsdkresource", (void**)&(pWrapperTable->m_Driver_A3200_SetCustomSDKResource));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_SetCustomSDKResource == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_setcustomsdk", (void**)&(pWrapperTable->m_Driver_A3200_SetCustomSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_SetCustomSDK == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_connect", (void**)&(pWrapperTable->m_Driver_A3200_Connect));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_Connect == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_disconnect", (void**)&(pWrapperTable->m_Driver_A3200_Disconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_Disconnect == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_runscript", (void**)&(pWrapperTable->m_Driver_A3200_RunScript));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_RunScript == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_runcommand", (void**)&(pWrapperTable->m_Driver_A3200_RunCommand));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_RunCommand == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_stopprogram", (void**)&(pWrapperTable->m_Driver_A3200_StopProgram));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_StopProgram == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_readglobalnumbervariable", (void**)&(pWrapperTable->m_Driver_A3200_ReadGlobalNumberVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_ReadGlobalNumberVariable == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_writeglobalnumbervariable", (void**)&(pWrapperTable->m_Driver_A3200_WriteGlobalNumberVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_WriteGlobalNumberVariable == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_readglobalstringvariable", (void**)&(pWrapperTable->m_Driver_A3200_ReadGlobalStringVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_ReadGlobalStringVariable == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_writeglobalstringvariable", (void**)&(pWrapperTable->m_Driver_A3200_WriteGlobalStringVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_WriteGlobalStringVariable == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_readtasknumbervariable", (void**)&(pWrapperTable->m_Driver_A3200_ReadTaskNumberVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_ReadTaskNumberVariable == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_writetasknumbervariable", (void**)&(pWrapperTable->m_Driver_A3200_WriteTaskNumberVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_WriteTaskNumberVariable == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_readtaskstringvariable", (void**)&(pWrapperTable->m_Driver_A3200_ReadTaskStringVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_ReadTaskStringVariable == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_driver_a3200_writetaskstringvariable", (void**)&(pWrapperTable->m_Driver_A3200_WriteTaskStringVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_A3200_WriteTaskStringVariable == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_a3200_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_A3200_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_A3200_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_A3200_uint32 bytesNeededName = 0;
		LibMCDriver_A3200_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_A3200_uint32 bytesNeededType = 0;
		LibMCDriver_A3200_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_A3200_uint32 & nMajor, LibMCDriver_A3200_uint32 & nMinor, LibMCDriver_A3200_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_A3200_uint32 bytesNeededBuild = 0;
		LibMCDriver_A3200_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::QueryParameters - Updates the driver parameters in the driver environment. Should only be called in the driver thread.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	* CDriver::QueryParametersEx - Updates the driver parameters in the driver environment. Might be called out of thread. Implementation MUST be able to handle parallel calls.
	* @param[in] pDriverUpdateInstance - Status update instance.
	*/
	void CDriver::QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance)
	{
		LibMCEnvHandle hDriverUpdateInstance = pDriverUpdateInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParametersEx(m_pHandle, hDriverUpdateInstance));
	}
	
	/**
	 * Method definitions for class CDriver_A3200
	 */
	
	/**
	* CDriver_A3200::SetToSimulationMode - Turns the driver into a simulation mode.
	*/
	void CDriver_A3200::SetToSimulationMode()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_SetToSimulationMode(m_pHandle));
	}
	
	/**
	* CDriver_A3200::IsSimulationMode - Returns if the driver is in simulation mode.
	* @return Flag if driver is in simulation mode.
	*/
	bool CDriver_A3200::IsSimulationMode()
	{
		bool resultSimulationModeEnabled = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_IsSimulationMode(m_pHandle, &resultSimulationModeEnabled));
		
		return resultSimulationModeEnabled;
	}
	
	/**
	* CDriver_A3200::SetCustomSDKResource - Sets the machine resource name of the A3200 SDK to load. MUST be called before Connect or it has no effect.
	* @param[in] sCoreResourceName - Resource name of core library DLL. Empty means standard naming a3200c64 applies.
	* @param[in] sSystemResourceName - Resource name of system library DLL. Empty means standard naming a32sys64 applies.
	* @param[in] sCompilerResourceName - Resource name of compiler library DLL. Empty means standard naming a32cmplr64 applies.
	* @param[in] sUtilitiesResourceName - Resource name of utilities library DLL. Empty means standard naming aerutilities64 applies.
	* @param[in] sLicenseDecoderResourceName - Resource name of license decoder library DLL. Empty means standard naming licensedecoder64 applies.
	*/
	void CDriver_A3200::SetCustomSDKResource(const std::string & sCoreResourceName, const std::string & sSystemResourceName, const std::string & sCompilerResourceName, const std::string & sUtilitiesResourceName, const std::string & sLicenseDecoderResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_SetCustomSDKResource(m_pHandle, sCoreResourceName.c_str(), sSystemResourceName.c_str(), sCompilerResourceName.c_str(), sUtilitiesResourceName.c_str(), sLicenseDecoderResourceName.c_str()));
	}
	
	/**
	* CDriver_A3200::SetCustomSDK - Sets the machine resource name of the A3200 SDK to load. MUST be called before Connect or it has no effect.
	* @param[in] CoreSDKBufferBuffer - Binary array of core library DLL. Empty means standard resource naming a3200c64 applies.
	* @param[in] SystemSDKBufferBuffer - Binary array of system library DLL. Empty means standard resource naming a32sys64 applies.
	* @param[in] CompilerSDKBufferBuffer - Binary array of compiler library DLL. Empty means standard resource naming a32cmplr64 applies.
	* @param[in] UtilitiesSDKBufferBuffer - Binary array of utilities library DLL. Empty means standard resource naming aerutilities64 applies.
	* @param[in] LicenseDecoderSDKBufferBuffer - Binary array of license decoder library DLL. Empty means resource standard naming licensedecoder64 applies.
	*/
	void CDriver_A3200::SetCustomSDK(const CInputVector<LibMCDriver_A3200_uint8> & CoreSDKBufferBuffer, const CInputVector<LibMCDriver_A3200_uint8> & SystemSDKBufferBuffer, const CInputVector<LibMCDriver_A3200_uint8> & CompilerSDKBufferBuffer, const CInputVector<LibMCDriver_A3200_uint8> & UtilitiesSDKBufferBuffer, const CInputVector<LibMCDriver_A3200_uint8> & LicenseDecoderSDKBufferBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_SetCustomSDK(m_pHandle, (LibMCDriver_A3200_uint64)CoreSDKBufferBuffer.size(), CoreSDKBufferBuffer.data(), (LibMCDriver_A3200_uint64)SystemSDKBufferBuffer.size(), SystemSDKBufferBuffer.data(), (LibMCDriver_A3200_uint64)CompilerSDKBufferBuffer.size(), CompilerSDKBufferBuffer.data(), (LibMCDriver_A3200_uint64)UtilitiesSDKBufferBuffer.size(), UtilitiesSDKBufferBuffer.data(), (LibMCDriver_A3200_uint64)LicenseDecoderSDKBufferBuffer.size(), LicenseDecoderSDKBufferBuffer.data()));
	}
	
	/**
	* CDriver_A3200::Connect - Connects to the A3200 PLC Controller.
	*/
	void CDriver_A3200::Connect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_Connect(m_pHandle));
	}
	
	/**
	* CDriver_A3200::Disconnect - Disconnects from the A3200 PLC Controller.
	*/
	void CDriver_A3200::Disconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_Disconnect(m_pHandle));
	}
	
	/**
	* CDriver_A3200::RunScript - Runs an AeroBasic script on a PLC task.
	* @param[in] nTaskID - TaskID to run the script on. MUST be between 1 and 31.
	* @param[in] sScript - AeroBasic script as string.
	*/
	void CDriver_A3200::RunScript(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sScript)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_RunScript(m_pHandle, nTaskID, sScript.c_str()));
	}
	
	/**
	* CDriver_A3200::RunCommand - Runs a single AeroBasic command on a PLC task.
	* @param[in] nTaskID - TaskID to run the script on. MUST be between 1 and 31.
	* @param[in] sCommand - AeroBasic command as string.
	*/
	void CDriver_A3200::RunCommand(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sCommand)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_RunCommand(m_pHandle, nTaskID, sCommand.c_str()));
	}
	
	/**
	* CDriver_A3200::StopProgram - Stops a running program on a task.
	* @param[in] nTaskID - TaskID to stop. MUST be between 1 and 31.
	* @param[in] nTimeout - Timeout in milliseconds.
	*/
	void CDriver_A3200::StopProgram(const LibMCDriver_A3200_uint32 nTaskID, const LibMCDriver_A3200_uint32 nTimeout)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_StopProgram(m_pHandle, nTaskID, nTimeout));
	}
	
	/**
	* CDriver_A3200::ReadGlobalNumberVariable - Returns a global number variable.
	* @param[in] sName - Variable to return
	* @return Value of variable
	*/
	LibMCDriver_A3200_double CDriver_A3200::ReadGlobalNumberVariable(const std::string & sName)
	{
		LibMCDriver_A3200_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_ReadGlobalNumberVariable(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CDriver_A3200::WriteGlobalNumberVariable - Sets a global number variable.
	* @param[in] sName - Variable to set
	* @param[in] dValue - Value of variable to set.
	*/
	void CDriver_A3200::WriteGlobalNumberVariable(const std::string & sName, const LibMCDriver_A3200_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_WriteGlobalNumberVariable(m_pHandle, sName.c_str(), dValue));
	}
	
	/**
	* CDriver_A3200::ReadGlobalStringVariable - Returns a global string variable.
	* @param[in] sName - Variable to return
	* @return Value of variable
	*/
	std::string CDriver_A3200::ReadGlobalStringVariable(const std::string & sName)
	{
		LibMCDriver_A3200_uint32 bytesNeededValue = 0;
		LibMCDriver_A3200_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_ReadGlobalStringVariable(m_pHandle, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_ReadGlobalStringVariable(m_pHandle, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CDriver_A3200::WriteGlobalStringVariable - Sets a global string variable.
	* @param[in] sName - Variable to set
	* @param[in] sValue - Value of variable to set.
	*/
	void CDriver_A3200::WriteGlobalStringVariable(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_WriteGlobalStringVariable(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CDriver_A3200::ReadTaskNumberVariable - Returns a task number variable.
	* @param[in] nTaskID - TaskID. MUST be between 1 and 31.
	* @param[in] sName - Variable to return
	* @return Value of variable
	*/
	LibMCDriver_A3200_double CDriver_A3200::ReadTaskNumberVariable(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sName)
	{
		LibMCDriver_A3200_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_ReadTaskNumberVariable(m_pHandle, nTaskID, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CDriver_A3200::WriteTaskNumberVariable - Sets a task number variable.
	* @param[in] nTaskID - TaskID. MUST be between 1 and 31.
	* @param[in] sName - Variable to set
	* @param[in] dValue - Value of variable to set.
	*/
	void CDriver_A3200::WriteTaskNumberVariable(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sName, const LibMCDriver_A3200_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_WriteTaskNumberVariable(m_pHandle, nTaskID, sName.c_str(), dValue));
	}
	
	/**
	* CDriver_A3200::ReadTaskStringVariable - Returns a task string variable.
	* @param[in] nTaskID - TaskID. MUST be between 1 and 31.
	* @param[in] sName - Variable to return
	* @return Value of variable
	*/
	std::string CDriver_A3200::ReadTaskStringVariable(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sName)
	{
		LibMCDriver_A3200_uint32 bytesNeededValue = 0;
		LibMCDriver_A3200_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_ReadTaskStringVariable(m_pHandle, nTaskID, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_ReadTaskStringVariable(m_pHandle, nTaskID, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CDriver_A3200::WriteTaskStringVariable - Sets a task string variable.
	* @param[in] nTaskID - TaskID. MUST be between 1 and 31.
	* @param[in] sName - Variable to set
	* @param[in] sValue - Value of variable to set.
	*/
	void CDriver_A3200::WriteTaskStringVariable(const LibMCDriver_A3200_uint32 nTaskID, const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_A3200_WriteTaskStringVariable(m_pHandle, nTaskID, sName.c_str(), sValue.c_str()));
	}

} // namespace LibMCDriver_A3200

#endif // __LIBMCDRIVER_A3200_CPPHEADER_DYNAMIC_CPP

