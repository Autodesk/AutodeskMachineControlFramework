/*++

Copyright (C) 2023 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver GRPC

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_GRPC_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_GRPC_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_grpc_types.hpp"
#include "libmcdriver_grpc_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_GRPC {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CGRPCConnection;
class CDriver_GRPC;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_GRPCWrapper;
typedef CBase CLibMCDriver_GRPCBase;
typedef CDriver CLibMCDriver_GRPCDriver;
typedef CGRPCConnection CLibMCDriver_GRPCGRPCConnection;
typedef CDriver_GRPC CLibMCDriver_GRPCDriver_GRPC;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CGRPCConnection> PGRPCConnection;
typedef std::shared_ptr<CDriver_GRPC> PDriver_GRPC;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_GRPCWrapper;
typedef PBase PLibMCDriver_GRPCBase;
typedef PDriver PLibMCDriver_GRPCDriver;
typedef PGRPCConnection PLibMCDriver_GRPCGRPCConnection;
typedef PDriver_GRPC PLibMCDriver_GRPCDriver_GRPC;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_GRPCHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_GRPCException 
**************************************************************************************************************************/
class ELibMCDriver_GRPCException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_GRPCResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_GRPCException(LibMCDriver_GRPCResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_GRPCResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_GRPC_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_GRPC_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_GRPC_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_GRPC_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_GRPC_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_GRPC_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_GRPC_ERROR_DRIVERERROR: return "DRIVERERROR";
			case LIBMCDRIVER_GRPC_ERROR_DRIVERNOTINITIALISED: return "DRIVERNOTINITIALISED";
			case LIBMCDRIVER_GRPC_ERROR_DRIVERNOTCONNECTED: return "DRIVERNOTCONNECTED";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDDRIVERPROTOCOL: return "INVALIDDRIVERPROTOCOL";
			case LIBMCDRIVER_GRPC_ERROR_COULDNOTPARSEDRIVERPROTOCOL: return "COULDNOTPARSEDRIVERPROTOCOL";
			case LIBMCDRIVER_GRPC_ERROR_NOWORKINGDIRECTORY: return "NOWORKINGDIRECTORY";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDTASKID: return "INVALIDTASKID";
			case LIBMCDRIVER_GRPC_ERROR_VERSIONMISMATCH: return "VERSIONMISMATCH";
			case LIBMCDRIVER_GRPC_ERROR_FEATURELOCKED: return "FEATURELOCKED";
			case LIBMCDRIVER_GRPC_ERROR_UNSUPPORTEDHARDWARE: return "UNSUPPORTEDHARDWARE";
			case LIBMCDRIVER_GRPC_ERROR_RESETTIMEOUT: return "RESETTIMEOUT";
			case LIBMCDRIVER_GRPC_ERROR_ALLOCATIONFAILED: return "ALLOCATIONFAILED";
			case LIBMCDRIVER_GRPC_ERROR_NOTCONNECTED: return "NOTCONNECTED";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDAXISINDEX: return "INVALIDAXISINDEX";
			case LIBMCDRIVER_GRPC_ERROR_TOOLTABLEERROR: return "TOOLTABLEERROR";
			case LIBMCDRIVER_GRPC_ERROR_DRIVECOMMANDLOST: return "DRIVECOMMANDLOST";
			case LIBMCDRIVER_GRPC_ERROR_DRIVECOMMANDRESPONSE: return "DRIVECOMMANDRESPONSE";
			case LIBMCDRIVER_GRPC_ERROR_FIREWIREISONCHRONOUSERROR: return "FIREWIREISONCHRONOUSERROR";
			case LIBMCDRIVER_GRPC_ERROR_FIREWIREASYNCHRONOUSERROR: return "FIREWIREASYNCHRONOUSERROR";
			case LIBMCDRIVER_GRPC_ERROR_PCMODBUSERROR: return "PCMODBUSERROR";
			case LIBMCDRIVER_GRPC_ERROR_COMMUNICATIONLOST: return "COMMUNICATIONLOST";
			case LIBMCDRIVER_GRPC_ERROR_ETHERNETCOMMUNICATIONLOST: return "ETHERNETCOMMUNICATIONLOST";
			case LIBMCDRIVER_GRPC_ERROR_SERVICECOMMUNICATIONLOST: return "SERVICECOMMUNICATIONLOST";
			case LIBMCDRIVER_GRPC_ERROR_FIREWIRECARDCONFIGURATION: return "FIREWIRECARDCONFIGURATION";
			case LIBMCDRIVER_GRPC_ERROR_PCICARDERROR: return "PCICARDERROR";
			case LIBMCDRIVER_GRPC_ERROR_AXISMISMATCH: return "AXISMISMATCH";
			case LIBMCDRIVER_GRPC_ERROR_TASKMISMATCH: return "TASKMISMATCH";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDCOMMANDLINE: return "INVALIDCOMMANDLINE";
			case LIBMCDRIVER_GRPC_ERROR_MACHINECONFIGURATION: return "MACHINECONFIGURATION";
			case LIBMCDRIVER_GRPC_ERROR_FIREWIRECONFIGURATION: return "FIREWIRECONFIGURATION";
			case LIBMCDRIVER_GRPC_ERROR_GANTRYCONFIGURATION: return "GANTRYCONFIGURATION";
			case LIBMCDRIVER_GRPC_ERROR_CALLBACKTIMEOUT: return "CALLBACKTIMEOUT";
			case LIBMCDRIVER_GRPC_ERROR_CALLBACKERROR: return "CALLBACKERROR";
			case LIBMCDRIVER_GRPC_ERROR_TOOMANYSTATUSITEMS: return "TOOMANYSTATUSITEMS";
			case LIBMCDRIVER_GRPC_ERROR_PROGRAMERROR: return "PROGRAMERROR";
			case LIBMCDRIVER_GRPC_ERROR_STRINGOVERFLOW: return "STRINGOVERFLOW";
			case LIBMCDRIVER_GRPC_ERROR_DIVIDEBYZERO: return "DIVIDEBYZERO";
			case LIBMCDRIVER_GRPC_ERROR_PROGRAMTIMEOUT: return "PROGRAMTIMEOUT";
			case LIBMCDRIVER_GRPC_ERROR_PROFILEQUEUEERROR: return "PROFILEQUEUEERROR";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDARGUMENT: return "INVALIDARGUMENT";
			case LIBMCDRIVER_GRPC_ERROR_PARAMETERNOTPASSED: return "PARAMETERNOTPASSED";
			case LIBMCDRIVER_GRPC_ERROR_QUEUEBUFFERFULL: return "QUEUEBUFFERFULL";
			case LIBMCDRIVER_GRPC_ERROR_NULLPROGRAMLINE: return "NULLPROGRAMLINE";
			case LIBMCDRIVER_GRPC_ERROR_PROGRAMNUMBEROUTOFBOUNDS: return "PROGRAMNUMBEROUTOFBOUNDS";
			case LIBMCDRIVER_GRPC_ERROR_CANNEDFUNCTIONERROR: return "CANNEDFUNCTIONERROR";
			case LIBMCDRIVER_GRPC_ERROR_ZEROSPEED: return "ZEROSPEED";
			case LIBMCDRIVER_GRPC_ERROR_STACKERROR: return "STACKERROR";
			case LIBMCDRIVER_GRPC_ERROR_SLICEERROR: return "SLICEERROR";
			case LIBMCDRIVER_GRPC_ERROR_LOOKAHEADERROR: return "LOOKAHEADERROR";
			case LIBMCDRIVER_GRPC_ERROR_RETRACEERROR: return "RETRACEERROR";
			case LIBMCDRIVER_GRPC_ERROR_AXISINFAULT: return "AXISINFAULT";
			case LIBMCDRIVER_GRPC_ERROR_AXISNOTENABLED: return "AXISNOTENABLED";
			case LIBMCDRIVER_GRPC_ERROR_MOTIONERROR: return "MOTIONERROR";
			case LIBMCDRIVER_GRPC_ERROR_GANTRYMOTIONERROR: return "GANTRYMOTIONERROR";
			case LIBMCDRIVER_GRPC_ERROR_CUTTERCOMPENSATIONERROR: return "CUTTERCOMPENSATIONERROR";
			case LIBMCDRIVER_GRPC_ERROR_CIRCULARMOTIONERROR: return "CIRCULARMOTIONERROR";
			case LIBMCDRIVER_GRPC_ERROR_CIRCULARRADIUSERROR: return "CIRCULARRADIUSERROR";
			case LIBMCDRIVER_GRPC_ERROR_NORMALCYERROR: return "NORMALCYERROR";
			case LIBMCDRIVER_GRPC_ERROR_MOTIONTYPEMISMATCH: return "MOTIONTYPEMISMATCH";
			case LIBMCDRIVER_GRPC_ERROR_SPINDLENUMBERNOTASSIGNED: return "SPINDLENUMBERNOTASSIGNED";
			case LIBMCDRIVER_GRPC_ERROR_ELLIPTICALMOTIONERROR: return "ELLIPTICALMOTIONERROR";
			case LIBMCDRIVER_GRPC_ERROR_MOTIONACTIVE: return "MOTIONACTIVE";
			case LIBMCDRIVER_GRPC_ERROR_AXISNOTDEPENDENT: return "AXISNOTDEPENDENT";
			case LIBMCDRIVER_GRPC_ERROR_AXISNOTDOMINANT: return "AXISNOTDOMINANT";
			case LIBMCDRIVER_GRPC_ERROR_NOJOYSTICKGROUPS: return "NOJOYSTICKGROUPS";
			case LIBMCDRIVER_GRPC_ERROR_TRANSFORMATIONERROR: return "TRANSFORMATIONERROR";
			case LIBMCDRIVER_GRPC_ERROR_CALIBRATIONTABLEERROR: return "CALIBRATIONTABLEERROR";
			case LIBMCDRIVER_GRPC_ERROR_CAMTABLEERROR: return "CAMTABLEERROR";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_GRPC_SUCCESS: return "success";
			case LIBMCDRIVER_GRPC_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_GRPC_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_GRPC_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_GRPC_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_GRPC_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_GRPC_ERROR_DRIVERERROR: return "a driver error occured";
			case LIBMCDRIVER_GRPC_ERROR_DRIVERNOTINITIALISED: return "the driver is not initialised";
			case LIBMCDRIVER_GRPC_ERROR_DRIVERNOTCONNECTED: return "the driver is not connected";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDDRIVERPROTOCOL: return "invalid driver protocol definition";
			case LIBMCDRIVER_GRPC_ERROR_COULDNOTPARSEDRIVERPROTOCOL: return "could not parse driver protocol";
			case LIBMCDRIVER_GRPC_ERROR_NOWORKINGDIRECTORY: return "No working directory";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDTASKID: return "Invalid task ID";
			case LIBMCDRIVER_GRPC_ERROR_VERSIONMISMATCH: return "An incompatible version was detected";
			case LIBMCDRIVER_GRPC_ERROR_FEATURELOCKED: return "A license error occurred";
			case LIBMCDRIVER_GRPC_ERROR_UNSUPPORTEDHARDWARE: return "A connected hardware type is no longer supported";
			case LIBMCDRIVER_GRPC_ERROR_RESETTIMEOUT: return "A timeout occurred while waiting for the controller reset to finish.";
			case LIBMCDRIVER_GRPC_ERROR_ALLOCATIONFAILED: return "An attempt to allocate memory on the SMC failed";
			case LIBMCDRIVER_GRPC_ERROR_NOTCONNECTED: return "The specified controller handle is invalid";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDAXISINDEX: return "The specified axis index is invalid.";
			case LIBMCDRIVER_GRPC_ERROR_TOOLTABLEERROR: return "A problem occurred with a tool table";
			case LIBMCDRIVER_GRPC_ERROR_DRIVECOMMANDLOST: return "A drive command was overwritten and lost.";
			case LIBMCDRIVER_GRPC_ERROR_DRIVECOMMANDRESPONSE: return "A timeout occurred while waiting for a drive response";
			case LIBMCDRIVER_GRPC_ERROR_FIREWIREISONCHRONOUSERROR: return "An error occurred with isochronous communication";
			case LIBMCDRIVER_GRPC_ERROR_FIREWIREASYNCHRONOUSERROR: return "An error occurred during an asynchronous communication";
			case LIBMCDRIVER_GRPC_ERROR_PCMODBUSERROR: return "An error occurred with PC Modbus communication";
			case LIBMCDRIVER_GRPC_ERROR_COMMUNICATIONLOST: return "FireWire communications were interrupted.";
			case LIBMCDRIVER_GRPC_ERROR_ETHERNETCOMMUNICATIONLOST: return "Ethernet communications were interrupted.";
			case LIBMCDRIVER_GRPC_ERROR_SERVICECOMMUNICATIONLOST: return "Communication Service communications were interrupted.";
			case LIBMCDRIVER_GRPC_ERROR_FIREWIRECARDCONFIGURATION: return "The FireWire card configuration is invalid.";
			case LIBMCDRIVER_GRPC_ERROR_PCICARDERROR: return "A problem exists with PCI card configuration.";
			case LIBMCDRIVER_GRPC_ERROR_AXISMISMATCH: return "An incorrect number of axes are attached.";
			case LIBMCDRIVER_GRPC_ERROR_TASKMISMATCH: return "An insufficient number of tasks are enabled.";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDCOMMANDLINE: return "An invalid SMC command line argument was specified.";
			case LIBMCDRIVER_GRPC_ERROR_MACHINECONFIGURATION: return "An error occurred while accessing the machine configuration.";
			case LIBMCDRIVER_GRPC_ERROR_FIREWIRECONFIGURATION: return "An error was detected in the FireWire configuration.";
			case LIBMCDRIVER_GRPC_ERROR_GANTRYCONFIGURATION: return "An error gantry configuration was detected.";
			case LIBMCDRIVER_GRPC_ERROR_CALLBACKTIMEOUT: return "A timeout occurred while responding to a callback.";
			case LIBMCDRIVER_GRPC_ERROR_CALLBACKERROR: return "A timeout occurred while responding to a callback.";
			case LIBMCDRIVER_GRPC_ERROR_TOOMANYSTATUSITEMS: return "The maximum number of status items was exceeded.";
			case LIBMCDRIVER_GRPC_ERROR_PROGRAMERROR: return "An error occurred in program execution.";
			case LIBMCDRIVER_GRPC_ERROR_STRINGOVERFLOW: return "The maximum string length was exceeded.";
			case LIBMCDRIVER_GRPC_ERROR_DIVIDEBYZERO: return "A divide-by-zero was detected.";
			case LIBMCDRIVER_GRPC_ERROR_PROGRAMTIMEOUT: return "A program timeout occurred.";
			case LIBMCDRIVER_GRPC_ERROR_PROFILEQUEUEERROR: return "An error occurred in the execution queue";
			case LIBMCDRIVER_GRPC_ERROR_INVALIDARGUMENT: return "An invalid argument was specified.";
			case LIBMCDRIVER_GRPC_ERROR_PARAMETERNOTPASSED: return "A callstack argument was not passed to a subroutine.";
			case LIBMCDRIVER_GRPC_ERROR_QUEUEBUFFERFULL: return "The buffered program queue is full.";
			case LIBMCDRIVER_GRPC_ERROR_NULLPROGRAMLINE: return "A NULL code line pointer was specified.";
			case LIBMCDRIVER_GRPC_ERROR_PROGRAMNUMBEROUTOFBOUNDS: return "The specified program number is outside of the valid range of values.";
			case LIBMCDRIVER_GRPC_ERROR_CANNEDFUNCTIONERROR: return "An error occurred with a canned function.";
			case LIBMCDRIVER_GRPC_ERROR_ZEROSPEED: return "The move speed is zero.";
			case LIBMCDRIVER_GRPC_ERROR_STACKERROR: return "A stack error occurred.";
			case LIBMCDRIVER_GRPC_ERROR_SLICEERROR: return "An error occurred while executing the SLICE command.";
			case LIBMCDRIVER_GRPC_ERROR_LOOKAHEADERROR: return "A error occurred while performing lookahead.";
			case LIBMCDRIVER_GRPC_ERROR_RETRACEERROR: return "An error occurred while doing retrace.";
			case LIBMCDRIVER_GRPC_ERROR_AXISINFAULT: return "An axis fault occurred.";
			case LIBMCDRIVER_GRPC_ERROR_AXISNOTENABLED: return "The axis is not enabled.";
			case LIBMCDRIVER_GRPC_ERROR_MOTIONERROR: return "An error occurred with a motion command.";
			case LIBMCDRIVER_GRPC_ERROR_GANTRYMOTIONERROR: return "An error occurred while performing gantry motion.";
			case LIBMCDRIVER_GRPC_ERROR_CUTTERCOMPENSATIONERROR: return "An error occurred while peforming cutter compensation.";
			case LIBMCDRIVER_GRPC_ERROR_CIRCULARMOTIONERROR: return "An error occurred while performing circular motion.";
			case LIBMCDRIVER_GRPC_ERROR_CIRCULARRADIUSERROR: return "A circular radius error occurred.";
			case LIBMCDRIVER_GRPC_ERROR_NORMALCYERROR: return "An error occurred while performing normalcy.";
			case LIBMCDRIVER_GRPC_ERROR_MOTIONTYPEMISMATCH: return "A LINEAR move is required to execute this command.";
			case LIBMCDRIVER_GRPC_ERROR_SPINDLENUMBERNOTASSIGNED: return "The specified spindle is not assigned to an axis.";
			case LIBMCDRIVER_GRPC_ERROR_ELLIPTICALMOTIONERROR: return "An error occurred while performing elliptical motion.";
			case LIBMCDRIVER_GRPC_ERROR_MOTIONACTIVE: return "Motion is already active.";
			case LIBMCDRIVER_GRPC_ERROR_AXISNOTDEPENDENT: return "This feature is only available on dependent axes.";
			case LIBMCDRIVER_GRPC_ERROR_AXISNOTDOMINANT: return "This feature is only available on dominant axes.";
			case LIBMCDRIVER_GRPC_ERROR_NOJOYSTICKGROUPS: return "No joystick groups have been specified.";
			case LIBMCDRIVER_GRPC_ERROR_TRANSFORMATIONERROR: return "An error occurred performing a transformation.";
			case LIBMCDRIVER_GRPC_ERROR_CALIBRATIONTABLEERROR: return "An error occurred with a calibration table.";
			case LIBMCDRIVER_GRPC_ERROR_CAMTABLEERROR: return "An error occurred with a cam table command.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_GRPCInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_GRPCResult nResult);

	inline void GetVersion(LibMCDriver_GRPC_uint32 & nMajor, LibMCDriver_GRPC_uint32 & nMinor, LibMCDriver_GRPC_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_GRPC_pvoid pSymbolAddressMethod);
	inline LibMCDriver_GRPC_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_GRPCDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_GRPCResult checkBinaryVersion()
	{
		LibMCDriver_GRPC_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_GRPC_VERSION_MAJOR) {
			return LIBMCDRIVER_GRPC_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_GRPC_SUCCESS;
	}
	LibMCDriver_GRPCResult initWrapperTable(sLibMCDriver_GRPCDynamicWrapperTable * pWrapperTable);
	LibMCDriver_GRPCResult releaseWrapperTable(sLibMCDriver_GRPCDynamicWrapperTable * pWrapperTable);
	LibMCDriver_GRPCResult loadWrapperTable(sLibMCDriver_GRPCDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_GRPCResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_GRPCDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CGRPCConnection;
	friend class CDriver_GRPC;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_GRPCHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_GRPCResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_GRPCHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_GRPCHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_GRPCHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_GRPC_uint32 & nMajor, LibMCDriver_GRPC_uint32 & nMinor, LibMCDriver_GRPC_uint32 & nMicro, std::string & sBuild);
	inline void QueryParameters();
	inline void QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance);
};
	
/*************************************************************************************************************************
 Class CGRPCConnection 
**************************************************************************************************************************/
class CGRPCConnection : public CBase {
public:
	
	/**
	* CGRPCConnection::CGRPCConnection - Constructor for GRPCConnection class.
	*/
	CGRPCConnection(CWrapper* pWrapper, LibMCDriver_GRPCHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
};
	
/*************************************************************************************************************************
 Class CDriver_GRPC 
**************************************************************************************************************************/
class CDriver_GRPC : public CDriver {
public:
	
	/**
	* CDriver_GRPC::CDriver_GRPC - Constructor for Driver_GRPC class.
	*/
	CDriver_GRPC(CWrapper* pWrapper, LibMCDriver_GRPCHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline void SetToSimulationMode();
	inline bool IsSimulationMode();
	inline void Connect();
	inline void FindConnection();
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_GRPC_uint32 & nMajor, LibMCDriver_GRPC_uint32 & nMinor, LibMCDriver_GRPC_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_GRPCHandle hInstance = pInstance.GetHandle();
		LibMCDriver_GRPC_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_GRPC_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_GRPCHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_GRPCHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_GRPC_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_GRPCException(LIBMCDRIVER_GRPC_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_GRPCException(LIBMCDRIVER_GRPC_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_GRPC_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_GRPC_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_GRPCHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (hInstance) {
			return std::make_shared<CDriver>(this, hInstance);
		} else {
			return nullptr;
		}
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_GRPCResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_GRPCException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_GRPCResult CWrapper::initWrapperTable(sLibMCDriver_GRPCDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_Driver_QueryParametersEx = nullptr;
		pWrapperTable->m_Driver_GRPC_SetToSimulationMode = nullptr;
		pWrapperTable->m_Driver_GRPC_IsSimulationMode = nullptr;
		pWrapperTable->m_Driver_GRPC_Connect = nullptr;
		pWrapperTable->m_Driver_GRPC_FindConnection = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_GRPC_SUCCESS;
	}

	inline LibMCDriver_GRPCResult CWrapper::releaseWrapperTable(sLibMCDriver_GRPCDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_GRPC_SUCCESS;
	}

	inline LibMCDriver_GRPCResult CWrapper::loadWrapperTable(sLibMCDriver_GRPCDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_GRPCDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_GRPCDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_grpc_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_GRPCDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_GRPCDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_grpc_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_GRPCDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_GRPCDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_grpc_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_GRPCDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_GRPCDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_grpc_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_GRPCDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_GRPCDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_grpc_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_GRPCDriver_QueryParametersExPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_queryparametersex");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_GRPCDriver_QueryParametersExPtr) dlsym(hLibrary, "libmcdriver_grpc_driver_queryparametersex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParametersEx == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GRPC_SetToSimulationMode = (PLibMCDriver_GRPCDriver_GRPC_SetToSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_grpc_settosimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_GRPC_SetToSimulationMode = (PLibMCDriver_GRPCDriver_GRPC_SetToSimulationModePtr) dlsym(hLibrary, "libmcdriver_grpc_driver_grpc_settosimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GRPC_SetToSimulationMode == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GRPC_IsSimulationMode = (PLibMCDriver_GRPCDriver_GRPC_IsSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_grpc_issimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_GRPC_IsSimulationMode = (PLibMCDriver_GRPCDriver_GRPC_IsSimulationModePtr) dlsym(hLibrary, "libmcdriver_grpc_driver_grpc_issimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GRPC_IsSimulationMode == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GRPC_Connect = (PLibMCDriver_GRPCDriver_GRPC_ConnectPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_grpc_connect");
		#else // _WIN32
		pWrapperTable->m_Driver_GRPC_Connect = (PLibMCDriver_GRPCDriver_GRPC_ConnectPtr) dlsym(hLibrary, "libmcdriver_grpc_driver_grpc_connect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GRPC_Connect == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GRPC_FindConnection = (PLibMCDriver_GRPCDriver_GRPC_FindConnectionPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_driver_grpc_findconnection");
		#else // _WIN32
		pWrapperTable->m_Driver_GRPC_FindConnection = (PLibMCDriver_GRPCDriver_GRPC_FindConnectionPtr) dlsym(hLibrary, "libmcdriver_grpc_driver_grpc_findconnection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GRPC_FindConnection == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_GRPCGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_GRPCGetVersionPtr) dlsym(hLibrary, "libmcdriver_grpc_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_GRPCGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_GRPCGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_grpc_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_GRPCReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_grpc_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_GRPCReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_grpc_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_GRPCAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_grpc_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_GRPCAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_grpc_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_GRPCInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_GRPCInjectComponentPtr) dlsym(hLibrary, "libmcdriver_grpc_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_GRPCGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_GRPCGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_grpc_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_GRPCCreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_grpc_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_GRPCCreateDriverPtr) dlsym(hLibrary, "libmcdriver_grpc_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_GRPC_SUCCESS;
	}

	inline LibMCDriver_GRPCResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_GRPCDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_GRPC_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_GRPCResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_GRPCResult eLookupError = LIBMCDRIVER_GRPC_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_queryparametersex", (void**)&(pWrapperTable->m_Driver_QueryParametersEx));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParametersEx == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_grpc_settosimulationmode", (void**)&(pWrapperTable->m_Driver_GRPC_SetToSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GRPC_SetToSimulationMode == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_grpc_issimulationmode", (void**)&(pWrapperTable->m_Driver_GRPC_IsSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GRPC_IsSimulationMode == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_grpc_connect", (void**)&(pWrapperTable->m_Driver_GRPC_Connect));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GRPC_Connect == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_driver_grpc_findconnection", (void**)&(pWrapperTable->m_Driver_GRPC_FindConnection));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GRPC_FindConnection == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_grpc_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_GRPC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_GRPC_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_GRPC_uint32 bytesNeededName = 0;
		LibMCDriver_GRPC_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_GRPC_uint32 bytesNeededType = 0;
		LibMCDriver_GRPC_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_GRPC_uint32 & nMajor, LibMCDriver_GRPC_uint32 & nMinor, LibMCDriver_GRPC_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_GRPC_uint32 bytesNeededBuild = 0;
		LibMCDriver_GRPC_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::QueryParameters - Updates the driver parameters in the driver environment. Should only be called in the driver thread.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	* CDriver::QueryParametersEx - Updates the driver parameters in the driver environment. Might be called out of thread. Implementation MUST be able to handle parallel calls.
	* @param[in] pDriverUpdateInstance - Status update instance.
	*/
	void CDriver::QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance)
	{
		LibMCEnvHandle hDriverUpdateInstance = pDriverUpdateInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParametersEx(m_pHandle, hDriverUpdateInstance));
	}
	
	/**
	 * Method definitions for class CGRPCConnection
	 */
	
	/**
	 * Method definitions for class CDriver_GRPC
	 */
	
	/**
	* CDriver_GRPC::SetToSimulationMode - Turns the driver into a simulation mode.
	*/
	void CDriver_GRPC::SetToSimulationMode()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GRPC_SetToSimulationMode(m_pHandle));
	}
	
	/**
	* CDriver_GRPC::IsSimulationMode - Returns if the driver is in simulation mode.
	* @return Flag if driver is in simulation mode.
	*/
	bool CDriver_GRPC::IsSimulationMode()
	{
		bool resultSimulationModeEnabled = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GRPC_IsSimulationMode(m_pHandle, &resultSimulationModeEnabled));
		
		return resultSimulationModeEnabled;
	}
	
	/**
	* CDriver_GRPC::Connect - Connects to a GRPC end point.
	*/
	void CDriver_GRPC::Connect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GRPC_Connect(m_pHandle));
	}
	
	/**
	* CDriver_GRPC::FindConnection - Finds a connection with a certain name.
	*/
	void CDriver_GRPC::FindConnection()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GRPC_FindConnection(m_pHandle));
	}

} // namespace LibMCDriver_GRPC

#endif // __LIBMCDRIVER_GRPC_CPPHEADER_DYNAMIC_CPP

