/*++

Copyright (C) 2024 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Library Wrapper for open62541 OPCUA Library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.2.0

*/

#include "libopen62541_abi.hpp"
#include "libopen62541_interfaces.hpp"
#include "libopen62541_interfaceexception.hpp"
#include "libopen62541_interfacejournal.hpp"

#include <map>

using namespace LibOpen62541::Impl;

PLibOpen62541InterfaceJournal m_GlobalJournal;

LibOpen62541Result handleLibOpen62541Exception(IBase * pIBaseClass, ELibOpen62541InterfaceException & Exception, CLibOpen62541InterfaceJournalEntry * pJournalEntry = nullptr)
{
	LibOpen62541Result errorCode = Exception.getErrorCode();

	if (pJournalEntry != nullptr)
		pJournalEntry->writeError(errorCode);

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibOpen62541Result handleStdException(IBase * pIBaseClass, std::exception & Exception, CLibOpen62541InterfaceJournalEntry * pJournalEntry = nullptr)
{
	LibOpen62541Result errorCode = LIBOPEN62541_ERROR_GENERICEXCEPTION;

	if (pJournalEntry != nullptr)
		pJournalEntry->writeError(errorCode);

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibOpen62541Result handleUnhandledException(IBase * pIBaseClass, CLibOpen62541InterfaceJournalEntry * pJournalEntry = nullptr)
{
	LibOpen62541Result errorCode = LIBOPEN62541_ERROR_GENERICEXCEPTION;

	if (pJournalEntry != nullptr)
		pJournalEntry->writeError(errorCode);

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for OPCClient
**************************************************************************************************************************/
LibOpen62541Result libopen62541_opcclient_enableencryption(LibOpen62541_OPCClient pOPCClient, const char * pLocalCertificate, const char * pPrivateKey, eLibOpen62541UASecurityMode eSecurityMode)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "EnableEncryption");
			pJournalEntry->addStringParameter("LocalCertificate", pLocalCertificate);
			pJournalEntry->addStringParameter("PrivateKey", pPrivateKey);
			pJournalEntry->addEnumParameter("SecurityMode", "UASecurityMode", (LibOpen62541_int32)(eSecurityMode));
		}
		if (pLocalCertificate == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (pPrivateKey == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		std::string sLocalCertificate(pLocalCertificate);
		std::string sPrivateKey(pPrivateKey);
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		pIOPCClient->EnableEncryption(sLocalCertificate, sPrivateKey, eSecurityMode);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_disableencryption(LibOpen62541_OPCClient pOPCClient)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "DisableEncryption");
		}
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		pIOPCClient->DisableEncryption();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_connectusername(LibOpen62541_OPCClient pOPCClient, const char * pEndPointURL, const char * pUsername, const char * pPassword, const char * pApplicationURL)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "ConnectUserName");
			pJournalEntry->addStringParameter("EndPointURL", pEndPointURL);
			pJournalEntry->addStringParameter("Username", pUsername);
			pJournalEntry->addStringParameter("Password", pPassword);
			pJournalEntry->addStringParameter("ApplicationURL", pApplicationURL);
		}
		if (pEndPointURL == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (pUsername == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (pPassword == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (pApplicationURL == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		std::string sEndPointURL(pEndPointURL);
		std::string sUsername(pUsername);
		std::string sPassword(pPassword);
		std::string sApplicationURL(pApplicationURL);
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		pIOPCClient->ConnectUserName(sEndPointURL, sUsername, sPassword, sApplicationURL);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_disconnect(LibOpen62541_OPCClient pOPCClient)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "Disconnect");
		}
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		pIOPCClient->Disconnect();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_isconnected(LibOpen62541_OPCClient pOPCClient, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "IsConnected");
		}
		if (pValue == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		*pValue = pIOPCClient->IsConnected();

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addBooleanResult("Value", *pValue);
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_readinteger(LibOpen62541_OPCClient pOPCClient, LibOpen62541_uint32 nNameSpace, const char * pNodeName, eLibOpen62541UAIntegerType eNodeType, LibOpen62541_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "ReadInteger");
			pJournalEntry->addUInt32Parameter("NameSpace", nNameSpace);
			pJournalEntry->addStringParameter("NodeName", pNodeName);
			pJournalEntry->addEnumParameter("NodeType", "UAIntegerType", (LibOpen62541_int32)(eNodeType));
		}
		if (pNodeName == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		std::string sNodeName(pNodeName);
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		*pValue = pIOPCClient->ReadInteger(nNameSpace, sNodeName, eNodeType);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addInt64Result("Value", *pValue);
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_readdouble(LibOpen62541_OPCClient pOPCClient, LibOpen62541_uint32 nNameSpace, const char * pNodeName, eLibOpen62541UADoubleType eNodeType, LibOpen62541_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "ReadDouble");
			pJournalEntry->addUInt32Parameter("NameSpace", nNameSpace);
			pJournalEntry->addStringParameter("NodeName", pNodeName);
			pJournalEntry->addEnumParameter("NodeType", "UADoubleType", (LibOpen62541_int32)(eNodeType));
		}
		if (pNodeName == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		std::string sNodeName(pNodeName);
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		*pValue = pIOPCClient->ReadDouble(nNameSpace, sNodeName, eNodeType);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addDoubleResult("Value", *pValue);
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_readstring(LibOpen62541_OPCClient pOPCClient, LibOpen62541_uint32 nNameSpace, const char * pNodeName, const LibOpen62541_uint32 nValueBufferSize, LibOpen62541_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "ReadString");
			pJournalEntry->addUInt32Parameter("NameSpace", nNameSpace);
			pJournalEntry->addStringParameter("NodeName", pNodeName);
		}
		if (pNodeName == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		std::string sNodeName(pNodeName);
		std::string sValue("");
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIOPCClient->ReadString(nNameSpace, sNodeName);

			pIOPCClient->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIOPCClient->_getCache ());
			if (cache == nullptr)
				throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIOPCClient->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibOpen62541_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("Value", sValue.c_str());
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_writeinteger(LibOpen62541_OPCClient pOPCClient, LibOpen62541_uint32 nNameSpace, const char * pNodeName, eLibOpen62541UAIntegerType eNodeType, LibOpen62541_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "WriteInteger");
			pJournalEntry->addUInt32Parameter("NameSpace", nNameSpace);
			pJournalEntry->addStringParameter("NodeName", pNodeName);
			pJournalEntry->addEnumParameter("NodeType", "UAIntegerType", (LibOpen62541_int32)(eNodeType));
			pJournalEntry->addInt64Parameter("Value", nValue);
		}
		if (pNodeName == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		std::string sNodeName(pNodeName);
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		pIOPCClient->WriteInteger(nNameSpace, sNodeName, eNodeType, nValue);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_writedouble(LibOpen62541_OPCClient pOPCClient, LibOpen62541_uint32 nNameSpace, const char * pNodeName, eLibOpen62541UADoubleType eNodeType, LibOpen62541_double dValue)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "WriteDouble");
			pJournalEntry->addUInt32Parameter("NameSpace", nNameSpace);
			pJournalEntry->addStringParameter("NodeName", pNodeName);
			pJournalEntry->addEnumParameter("NodeType", "UADoubleType", (LibOpen62541_int32)(eNodeType));
			pJournalEntry->addDoubleParameter("Value", dValue);
		}
		if (pNodeName == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		std::string sNodeName(pNodeName);
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		pIOPCClient->WriteDouble(nNameSpace, sNodeName, eNodeType, dValue);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_opcclient_writestring(LibOpen62541_OPCClient pOPCClient, LibOpen62541_uint32 nNameSpace, const char * pNodeName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pOPCClient;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginClassMethod(pOPCClient, "OPCClient", "WriteString");
			pJournalEntry->addUInt32Parameter("NameSpace", nNameSpace);
			pJournalEntry->addStringParameter("NodeName", pNodeName);
			pJournalEntry->addStringParameter("Value", pValue);
		}
		if (pNodeName == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		std::string sNodeName(pNodeName);
		std::string sValue(pValue);
		IOPCClient* pIOPCClient = dynamic_cast<IOPCClient*>(pIBaseClass);
		if (!pIOPCClient)
			throw ELibOpen62541InterfaceException(LIBOPEN62541_ERROR_INVALIDCAST);
		
		pIOPCClient->WriteString(nNameSpace, sNodeName, sValue);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibOpen62541Result LibOpen62541::Impl::LibOpen62541_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBOPEN62541_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBOPEN62541_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libopen62541_opcclient_enableencryption") 
		*ppProcAddress = (void*) &libopen62541_opcclient_enableencryption;
	if (sProcName == "libopen62541_opcclient_disableencryption") 
		*ppProcAddress = (void*) &libopen62541_opcclient_disableencryption;
	if (sProcName == "libopen62541_opcclient_connectusername") 
		*ppProcAddress = (void*) &libopen62541_opcclient_connectusername;
	if (sProcName == "libopen62541_opcclient_disconnect") 
		*ppProcAddress = (void*) &libopen62541_opcclient_disconnect;
	if (sProcName == "libopen62541_opcclient_isconnected") 
		*ppProcAddress = (void*) &libopen62541_opcclient_isconnected;
	if (sProcName == "libopen62541_opcclient_readinteger") 
		*ppProcAddress = (void*) &libopen62541_opcclient_readinteger;
	if (sProcName == "libopen62541_opcclient_readdouble") 
		*ppProcAddress = (void*) &libopen62541_opcclient_readdouble;
	if (sProcName == "libopen62541_opcclient_readstring") 
		*ppProcAddress = (void*) &libopen62541_opcclient_readstring;
	if (sProcName == "libopen62541_opcclient_writeinteger") 
		*ppProcAddress = (void*) &libopen62541_opcclient_writeinteger;
	if (sProcName == "libopen62541_opcclient_writedouble") 
		*ppProcAddress = (void*) &libopen62541_opcclient_writedouble;
	if (sProcName == "libopen62541_opcclient_writestring") 
		*ppProcAddress = (void*) &libopen62541_opcclient_writestring;
	if (sProcName == "libopen62541_getversion") 
		*ppProcAddress = (void*) &libopen62541_getversion;
	if (sProcName == "libopen62541_getlasterror") 
		*ppProcAddress = (void*) &libopen62541_getlasterror;
	if (sProcName == "libopen62541_acquireinstance") 
		*ppProcAddress = (void*) &libopen62541_acquireinstance;
	if (sProcName == "libopen62541_releaseinstance") 
		*ppProcAddress = (void*) &libopen62541_releaseinstance;
	if (sProcName == "libopen62541_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libopen62541_getsymbollookupmethod;
	if (sProcName == "libopen62541_createclient") 
		*ppProcAddress = (void*) &libopen62541_createclient;
	
	if (*ppProcAddress == nullptr) 
		return LIBOPEN62541_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBOPEN62541_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibOpen62541Result libopen62541_getversion(LibOpen62541_uint32 * pMajor, LibOpen62541_uint32 * pMinor, LibOpen62541_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetVersion");
		}
		if (!pMajor)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addUInt32Result("Major", *pMajor);
			pJournalEntry->addUInt32Result("Minor", *pMinor);
			pJournalEntry->addUInt32Result("Micro", *pMicro);
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_getlasterror(LibOpen62541_Base pInstance, const LibOpen62541_uint32 nErrorMessageBufferSize, LibOpen62541_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetLastError");
			pJournalEntry->addHandleParameter("Instance", pInstance);
		}
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibOpen62541_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addStringResult("ErrorMessage", sErrorMessage.c_str());
			pJournalEntry->addBooleanResult("HasError", *pHasError);
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_acquireinstance(LibOpen62541_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("AcquireInstance");
			pJournalEntry->addHandleParameter("Instance", pInstance);
		}
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_releaseinstance(LibOpen62541_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("ReleaseInstance");
			pJournalEntry->addHandleParameter("Instance", pInstance);
		}
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_getsymbollookupmethod(LibOpen62541_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("GetSymbolLookupMethod");
		}
		if (pSymbolLookupMethod == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibOpen62541::Impl::LibOpen62541_GetProcAddress;
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addPointerResult("SymbolLookupMethod", *pSymbolLookupMethod);
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}

LibOpen62541Result libopen62541_createclient(LibOpen62541_OPCClient * pClientInstance)
{
	IBase* pIBaseClass = nullptr;

	PLibOpen62541InterfaceJournalEntry pJournalEntry;
	try {
		if (m_GlobalJournal.get() != nullptr)  {
			pJournalEntry = m_GlobalJournal->beginStaticFunction("CreateClient");
		}
		if (pClientInstance == nullptr)
			throw ELibOpen62541InterfaceException (LIBOPEN62541_ERROR_INVALIDPARAM);
		IBase* pBaseClientInstance(nullptr);
		pBaseClientInstance = CWrapper::CreateClient();

		*pClientInstance = (IBase*)(pBaseClientInstance);
		if (pJournalEntry.get() != nullptr) {
			pJournalEntry->addHandleResult("ClientInstance", *pClientInstance);
			pJournalEntry->writeSuccess();
		}
		return LIBOPEN62541_SUCCESS;
	}
	catch (ELibOpen62541InterfaceException & Exception) {
		return handleLibOpen62541Exception(pIBaseClass, Exception, pJournalEntry.get());
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException, pJournalEntry.get());
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass, pJournalEntry.get());
	}
}


