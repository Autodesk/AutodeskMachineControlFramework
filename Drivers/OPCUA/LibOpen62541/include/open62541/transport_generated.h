/**********************************
 * Autogenerated -- do not modify *
 **********************************/

#include <open62541/types.h>

#ifndef TRANSPORT_GENERATED_H_
#define TRANSPORT_GENERATED_H_

#include "types_generated.h"

_UA_BEGIN_DECLS

/**
 * Every type is assigned an index in an array containing the type descriptions.
 * These descriptions are used during type handling (copying, deletion,
 * binary encoding, ...). */
#define UA_TRANSPORT_COUNT 9
extern UA_EXPORT UA_DataType UA_TRANSPORT[UA_TRANSPORT_COUNT];

/* MessageType: Message Type and whether the message contains an intermediate chunk */
typedef enum {
    UA_MESSAGETYPE_ACK = 0x4B4341,
    UA_MESSAGETYPE_HEL = 0x4C4548,
    UA_MESSAGETYPE_MSG = 0x47534D,
    UA_MESSAGETYPE_OPN = 0x4E504F,
    UA_MESSAGETYPE_CLO = 0x4F4C43,
    UA_MESSAGETYPE_ERR = 0x525245,
    UA_MESSAGETYPE_RHE = 0x454852,
    UA_MESSAGETYPE_INVALID = 0x0,
    __UA_MESSAGETYPE_FORCE32BIT = 0x7fffffff
} UA_MessageType;

UA_STATIC_ASSERT(sizeof(UA_MessageType) == sizeof(UA_Int32), enum_must_be_32bit);

#define UA_TRANSPORT_MESSAGETYPE 0

UA_INLINABLE( void
UA_MessageType_init(UA_MessageType *p), {
    memset(p, 0, sizeof(UA_MessageType));
})

UA_INLINABLE( UA_MessageType *
UA_MessageType_new(void), {
    return (UA_MessageType*)UA_new(&UA_TRANSPORT[UA_TRANSPORT_MESSAGETYPE]);
})

UA_INLINABLE( UA_StatusCode
UA_MessageType_copy(const UA_MessageType *src, UA_MessageType *dst), {
    return UA_copy(src, dst, &UA_TRANSPORT[UA_TRANSPORT_MESSAGETYPE]);
})

UA_INLINABLE( void
UA_MessageType_clear(UA_MessageType *p), {
    UA_clear(p, &UA_TRANSPORT[UA_TRANSPORT_MESSAGETYPE]);
})

UA_INLINABLE( void
UA_MessageType_delete(UA_MessageType *p), {
    UA_delete(p, &UA_TRANSPORT[UA_TRANSPORT_MESSAGETYPE]);
})

UA_INLINABLE( UA_Boolean
UA_MessageType_equal(const UA_MessageType *p1, const UA_MessageType *p2), {
    return (UA_order(p1, p2, &UA_TRANSPORT[UA_TRANSPORT_MESSAGETYPE]) == UA_ORDER_EQ);
})


/* ChunkType: Type of the chunk */
typedef enum {
    UA_CHUNKTYPE_FINAL = 0x46000000,
    UA_CHUNKTYPE_INTERMEDIATE = 0x43000000,
    UA_CHUNKTYPE_ABORT = 0x41000000,
    __UA_CHUNKTYPE_FORCE32BIT = 0x7fffffff
} UA_ChunkType;

UA_STATIC_ASSERT(sizeof(UA_ChunkType) == sizeof(UA_Int32), enum_must_be_32bit);

#define UA_TRANSPORT_CHUNKTYPE 1

UA_INLINABLE( void
UA_ChunkType_init(UA_ChunkType *p), {
    memset(p, 0, sizeof(UA_ChunkType));
})

UA_INLINABLE( UA_ChunkType *
UA_ChunkType_new(void), {
    return (UA_ChunkType*)UA_new(&UA_TRANSPORT[UA_TRANSPORT_CHUNKTYPE]);
})

UA_INLINABLE( UA_StatusCode
UA_ChunkType_copy(const UA_ChunkType *src, UA_ChunkType *dst), {
    return UA_copy(src, dst, &UA_TRANSPORT[UA_TRANSPORT_CHUNKTYPE]);
})

UA_INLINABLE( void
UA_ChunkType_clear(UA_ChunkType *p), {
    UA_clear(p, &UA_TRANSPORT[UA_TRANSPORT_CHUNKTYPE]);
})

UA_INLINABLE( void
UA_ChunkType_delete(UA_ChunkType *p), {
    UA_delete(p, &UA_TRANSPORT[UA_TRANSPORT_CHUNKTYPE]);
})

UA_INLINABLE( UA_Boolean
UA_ChunkType_equal(const UA_ChunkType *p1, const UA_ChunkType *p2), {
    return (UA_order(p1, p2, &UA_TRANSPORT[UA_TRANSPORT_CHUNKTYPE]) == UA_ORDER_EQ);
})


/* TcpMessageHeader: TCP Header */
typedef struct {
    UA_UInt32 messageTypeAndChunkType;
    UA_UInt32 messageSize;
} UA_TcpMessageHeader;

#define UA_TRANSPORT_TCPMESSAGEHEADER 2

UA_INLINABLE( void
UA_TcpMessageHeader_init(UA_TcpMessageHeader *p), {
    memset(p, 0, sizeof(UA_TcpMessageHeader));
})

UA_INLINABLE( UA_TcpMessageHeader *
UA_TcpMessageHeader_new(void), {
    return (UA_TcpMessageHeader*)UA_new(&UA_TRANSPORT[UA_TRANSPORT_TCPMESSAGEHEADER]);
})

UA_INLINABLE( UA_StatusCode
UA_TcpMessageHeader_copy(const UA_TcpMessageHeader *src, UA_TcpMessageHeader *dst), {
    return UA_copy(src, dst, &UA_TRANSPORT[UA_TRANSPORT_TCPMESSAGEHEADER]);
})

UA_INLINABLE( void
UA_TcpMessageHeader_clear(UA_TcpMessageHeader *p), {
    UA_clear(p, &UA_TRANSPORT[UA_TRANSPORT_TCPMESSAGEHEADER]);
})

UA_INLINABLE( void
UA_TcpMessageHeader_delete(UA_TcpMessageHeader *p), {
    UA_delete(p, &UA_TRANSPORT[UA_TRANSPORT_TCPMESSAGEHEADER]);
})

UA_INLINABLE( UA_Boolean
UA_TcpMessageHeader_equal(const UA_TcpMessageHeader *p1, const UA_TcpMessageHeader *p2), {
    return (UA_order(p1, p2, &UA_TRANSPORT[UA_TRANSPORT_TCPMESSAGEHEADER]) == UA_ORDER_EQ);
})


/* TcpHelloMessage: Hello Message */
typedef struct {
    UA_UInt32 protocolVersion;
    UA_UInt32 receiveBufferSize;
    UA_UInt32 sendBufferSize;
    UA_UInt32 maxMessageSize;
    UA_UInt32 maxChunkCount;
    UA_String endpointUrl;
} UA_TcpHelloMessage;

#define UA_TRANSPORT_TCPHELLOMESSAGE 3

UA_INLINABLE( void
UA_TcpHelloMessage_init(UA_TcpHelloMessage *p), {
    memset(p, 0, sizeof(UA_TcpHelloMessage));
})

UA_INLINABLE( UA_TcpHelloMessage *
UA_TcpHelloMessage_new(void), {
    return (UA_TcpHelloMessage*)UA_new(&UA_TRANSPORT[UA_TRANSPORT_TCPHELLOMESSAGE]);
})

UA_INLINABLE( UA_StatusCode
UA_TcpHelloMessage_copy(const UA_TcpHelloMessage *src, UA_TcpHelloMessage *dst), {
    return UA_copy(src, dst, &UA_TRANSPORT[UA_TRANSPORT_TCPHELLOMESSAGE]);
})

UA_INLINABLE( void
UA_TcpHelloMessage_clear(UA_TcpHelloMessage *p), {
    UA_clear(p, &UA_TRANSPORT[UA_TRANSPORT_TCPHELLOMESSAGE]);
})

UA_INLINABLE( void
UA_TcpHelloMessage_delete(UA_TcpHelloMessage *p), {
    UA_delete(p, &UA_TRANSPORT[UA_TRANSPORT_TCPHELLOMESSAGE]);
})

UA_INLINABLE( UA_Boolean
UA_TcpHelloMessage_equal(const UA_TcpHelloMessage *p1, const UA_TcpHelloMessage *p2), {
    return (UA_order(p1, p2, &UA_TRANSPORT[UA_TRANSPORT_TCPHELLOMESSAGE]) == UA_ORDER_EQ);
})


/* TcpReverseHelloMessage */
typedef struct {
    UA_String serverUri;
    UA_String endpointUrl;
} UA_TcpReverseHelloMessage;

#define UA_TRANSPORT_TCPREVERSEHELLOMESSAGE 4

UA_INLINABLE( void
UA_TcpReverseHelloMessage_init(UA_TcpReverseHelloMessage *p), {
    memset(p, 0, sizeof(UA_TcpReverseHelloMessage));
})

UA_INLINABLE( UA_TcpReverseHelloMessage *
UA_TcpReverseHelloMessage_new(void), {
    return (UA_TcpReverseHelloMessage*)UA_new(&UA_TRANSPORT[UA_TRANSPORT_TCPREVERSEHELLOMESSAGE]);
})

UA_INLINABLE( UA_StatusCode
UA_TcpReverseHelloMessage_copy(const UA_TcpReverseHelloMessage *src, UA_TcpReverseHelloMessage *dst), {
    return UA_copy(src, dst, &UA_TRANSPORT[UA_TRANSPORT_TCPREVERSEHELLOMESSAGE]);
})

UA_INLINABLE( void
UA_TcpReverseHelloMessage_clear(UA_TcpReverseHelloMessage *p), {
    UA_clear(p, &UA_TRANSPORT[UA_TRANSPORT_TCPREVERSEHELLOMESSAGE]);
})

UA_INLINABLE( void
UA_TcpReverseHelloMessage_delete(UA_TcpReverseHelloMessage *p), {
    UA_delete(p, &UA_TRANSPORT[UA_TRANSPORT_TCPREVERSEHELLOMESSAGE]);
})

UA_INLINABLE( UA_Boolean
UA_TcpReverseHelloMessage_equal(const UA_TcpReverseHelloMessage *p1, const UA_TcpReverseHelloMessage *p2), {
    return (UA_order(p1, p2, &UA_TRANSPORT[UA_TRANSPORT_TCPREVERSEHELLOMESSAGE]) == UA_ORDER_EQ);
})


/* TcpAcknowledgeMessage: Acknowledge Message */
typedef struct {
    UA_UInt32 protocolVersion;
    UA_UInt32 receiveBufferSize;
    UA_UInt32 sendBufferSize;
    UA_UInt32 maxMessageSize;
    UA_UInt32 maxChunkCount;
} UA_TcpAcknowledgeMessage;

#define UA_TRANSPORT_TCPACKNOWLEDGEMESSAGE 5

UA_INLINABLE( void
UA_TcpAcknowledgeMessage_init(UA_TcpAcknowledgeMessage *p), {
    memset(p, 0, sizeof(UA_TcpAcknowledgeMessage));
})

UA_INLINABLE( UA_TcpAcknowledgeMessage *
UA_TcpAcknowledgeMessage_new(void), {
    return (UA_TcpAcknowledgeMessage*)UA_new(&UA_TRANSPORT[UA_TRANSPORT_TCPACKNOWLEDGEMESSAGE]);
})

UA_INLINABLE( UA_StatusCode
UA_TcpAcknowledgeMessage_copy(const UA_TcpAcknowledgeMessage *src, UA_TcpAcknowledgeMessage *dst), {
    return UA_copy(src, dst, &UA_TRANSPORT[UA_TRANSPORT_TCPACKNOWLEDGEMESSAGE]);
})

UA_INLINABLE( void
UA_TcpAcknowledgeMessage_clear(UA_TcpAcknowledgeMessage *p), {
    UA_clear(p, &UA_TRANSPORT[UA_TRANSPORT_TCPACKNOWLEDGEMESSAGE]);
})

UA_INLINABLE( void
UA_TcpAcknowledgeMessage_delete(UA_TcpAcknowledgeMessage *p), {
    UA_delete(p, &UA_TRANSPORT[UA_TRANSPORT_TCPACKNOWLEDGEMESSAGE]);
})

UA_INLINABLE( UA_Boolean
UA_TcpAcknowledgeMessage_equal(const UA_TcpAcknowledgeMessage *p1, const UA_TcpAcknowledgeMessage *p2), {
    return (UA_order(p1, p2, &UA_TRANSPORT[UA_TRANSPORT_TCPACKNOWLEDGEMESSAGE]) == UA_ORDER_EQ);
})


/* TcpErrorMessage: Error Message */
typedef struct {
    UA_UInt32 error;
    UA_String reason;
} UA_TcpErrorMessage;

#define UA_TRANSPORT_TCPERRORMESSAGE 6

UA_INLINABLE( void
UA_TcpErrorMessage_init(UA_TcpErrorMessage *p), {
    memset(p, 0, sizeof(UA_TcpErrorMessage));
})

UA_INLINABLE( UA_TcpErrorMessage *
UA_TcpErrorMessage_new(void), {
    return (UA_TcpErrorMessage*)UA_new(&UA_TRANSPORT[UA_TRANSPORT_TCPERRORMESSAGE]);
})

UA_INLINABLE( UA_StatusCode
UA_TcpErrorMessage_copy(const UA_TcpErrorMessage *src, UA_TcpErrorMessage *dst), {
    return UA_copy(src, dst, &UA_TRANSPORT[UA_TRANSPORT_TCPERRORMESSAGE]);
})

UA_INLINABLE( void
UA_TcpErrorMessage_clear(UA_TcpErrorMessage *p), {
    UA_clear(p, &UA_TRANSPORT[UA_TRANSPORT_TCPERRORMESSAGE]);
})

UA_INLINABLE( void
UA_TcpErrorMessage_delete(UA_TcpErrorMessage *p), {
    UA_delete(p, &UA_TRANSPORT[UA_TRANSPORT_TCPERRORMESSAGE]);
})

UA_INLINABLE( UA_Boolean
UA_TcpErrorMessage_equal(const UA_TcpErrorMessage *p1, const UA_TcpErrorMessage *p2), {
    return (UA_order(p1, p2, &UA_TRANSPORT[UA_TRANSPORT_TCPERRORMESSAGE]) == UA_ORDER_EQ);
})


/* AsymmetricAlgorithmSecurityHeader: Asymmetric Security Header */
typedef struct {
    UA_String securityPolicyUri;
    UA_ByteString senderCertificate;
    UA_ByteString receiverCertificateThumbprint;
} UA_AsymmetricAlgorithmSecurityHeader;

#define UA_TRANSPORT_ASYMMETRICALGORITHMSECURITYHEADER 7

UA_INLINABLE( void
UA_AsymmetricAlgorithmSecurityHeader_init(UA_AsymmetricAlgorithmSecurityHeader *p), {
    memset(p, 0, sizeof(UA_AsymmetricAlgorithmSecurityHeader));
})

UA_INLINABLE( UA_AsymmetricAlgorithmSecurityHeader *
UA_AsymmetricAlgorithmSecurityHeader_new(void), {
    return (UA_AsymmetricAlgorithmSecurityHeader*)UA_new(&UA_TRANSPORT[UA_TRANSPORT_ASYMMETRICALGORITHMSECURITYHEADER]);
})

UA_INLINABLE( UA_StatusCode
UA_AsymmetricAlgorithmSecurityHeader_copy(const UA_AsymmetricAlgorithmSecurityHeader *src, UA_AsymmetricAlgorithmSecurityHeader *dst), {
    return UA_copy(src, dst, &UA_TRANSPORT[UA_TRANSPORT_ASYMMETRICALGORITHMSECURITYHEADER]);
})

UA_INLINABLE( void
UA_AsymmetricAlgorithmSecurityHeader_clear(UA_AsymmetricAlgorithmSecurityHeader *p), {
    UA_clear(p, &UA_TRANSPORT[UA_TRANSPORT_ASYMMETRICALGORITHMSECURITYHEADER]);
})

UA_INLINABLE( void
UA_AsymmetricAlgorithmSecurityHeader_delete(UA_AsymmetricAlgorithmSecurityHeader *p), {
    UA_delete(p, &UA_TRANSPORT[UA_TRANSPORT_ASYMMETRICALGORITHMSECURITYHEADER]);
})

UA_INLINABLE( UA_Boolean
UA_AsymmetricAlgorithmSecurityHeader_equal(const UA_AsymmetricAlgorithmSecurityHeader *p1, const UA_AsymmetricAlgorithmSecurityHeader *p2), {
    return (UA_order(p1, p2, &UA_TRANSPORT[UA_TRANSPORT_ASYMMETRICALGORITHMSECURITYHEADER]) == UA_ORDER_EQ);
})


/* SequenceHeader: Secure Layer Sequence Header */
typedef struct {
    UA_UInt32 sequenceNumber;
    UA_UInt32 requestId;
} UA_SequenceHeader;

#define UA_TRANSPORT_SEQUENCEHEADER 8

UA_INLINABLE( void
UA_SequenceHeader_init(UA_SequenceHeader *p), {
    memset(p, 0, sizeof(UA_SequenceHeader));
})

UA_INLINABLE( UA_SequenceHeader *
UA_SequenceHeader_new(void), {
    return (UA_SequenceHeader*)UA_new(&UA_TRANSPORT[UA_TRANSPORT_SEQUENCEHEADER]);
})

UA_INLINABLE( UA_StatusCode
UA_SequenceHeader_copy(const UA_SequenceHeader *src, UA_SequenceHeader *dst), {
    return UA_copy(src, dst, &UA_TRANSPORT[UA_TRANSPORT_SEQUENCEHEADER]);
})

UA_INLINABLE( void
UA_SequenceHeader_clear(UA_SequenceHeader *p), {
    UA_clear(p, &UA_TRANSPORT[UA_TRANSPORT_SEQUENCEHEADER]);
})

UA_INLINABLE( void
UA_SequenceHeader_delete(UA_SequenceHeader *p), {
    UA_delete(p, &UA_TRANSPORT[UA_TRANSPORT_SEQUENCEHEADER]);
})

UA_INLINABLE( UA_Boolean
UA_SequenceHeader_equal(const UA_SequenceHeader *p1, const UA_SequenceHeader *p2), {
    return (UA_order(p1, p2, &UA_TRANSPORT[UA_TRANSPORT_SEQUENCEHEADER]) == UA_ORDER_EQ);
})


_UA_END_DECLS

#endif /* TRANSPORT_GENERATED_H_ */
