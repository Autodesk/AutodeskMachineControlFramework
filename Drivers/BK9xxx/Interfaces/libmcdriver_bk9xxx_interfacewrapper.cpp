/*++

Copyright (C) 2023 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of MC Driver Beckhoff BK9xxx bus coupler. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmcdriver_bk9xxx_abi.hpp"
#include "libmcdriver_bk9xxx_interfaces.hpp"
#include "libmcdriver_bk9xxx_interfaceexception.hpp"

#include <map>

using namespace LibMCDriver_BK9xxx::Impl;

LibMCDriver_BK9xxxResult handleLibMCDriver_BK9xxxException(IBase * pIBaseClass, ELibMCDriver_BK9xxxInterfaceException & Exception)
{
	LibMCDriver_BK9xxxResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_BK9xxxResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDriver_BK9xxxResult errorCode = LIBMCDRIVER_BK9XXX_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_BK9xxxResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDriver_BK9xxxResult errorCode = LIBMCDRIVER_BK9XXX_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Driver
**************************************************************************************************************************/
LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_configure(LibMCDriver_BK9xxx_Driver pDriver, const char * pConfigurationString)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (pConfigurationString == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sConfigurationString(pConfigurationString);
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver->Configure(sConfigurationString);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_getname(LibMCDriver_BK9xxx_Driver pDriver, const LibMCDriver_BK9xxx_uint32 nNameBufferSize, LibMCDriver_BK9xxx_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIDriver->GetName();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCDriver_BK9xxx_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_gettype(LibMCDriver_BK9xxx_Driver pDriver, const LibMCDriver_BK9xxx_uint32 nTypeBufferSize, LibMCDriver_BK9xxx_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sType("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIDriver->GetType();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIDriver->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (LibMCDriver_BK9xxx_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_getversion(LibMCDriver_BK9xxx_Driver pDriver, LibMCDriver_BK9xxx_uint32 * pMajor, LibMCDriver_BK9xxx_uint32 * pMinor, LibMCDriver_BK9xxx_uint32 * pMicro, const LibMCDriver_BK9xxx_uint32 nBuildBufferSize, LibMCDriver_BK9xxx_uint32* pBuildNeededChars, char * pBuildBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (!pMajor)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if ( (!pBuildBuffer) && !(pBuildNeededChars) )
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sBuild("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetVersion(*pMajor, *pMinor, *pMicro, sBuild);

			pIDriver->_setCache (new ParameterCache_4<LibMCDriver_BK9xxx_uint32, LibMCDriver_BK9xxx_uint32, LibMCDriver_BK9xxx_uint32, std::string> (*pMajor, *pMinor, *pMicro, sBuild));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<LibMCDriver_BK9xxx_uint32, LibMCDriver_BK9xxx_uint32, LibMCDriver_BK9xxx_uint32, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
			cache->retrieveData (*pMajor, *pMinor, *pMicro, sBuild);
			pIDriver->_setCache (nullptr);
		}
		
		if (pBuildNeededChars)
			*pBuildNeededChars = (LibMCDriver_BK9xxx_uint32) (sBuild.size()+1);
		if (pBuildBuffer) {
			if (sBuild.size() >= nBuildBufferSize)
				throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_BUFFERTOOSMALL);
			for (size_t iBuild = 0; iBuild < sBuild.size(); iBuild++)
				pBuildBuffer[iBuild] = sBuild[iBuild];
			pBuildBuffer[sBuild.size()] = 0;
		}
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_getheaderinformation(LibMCDriver_BK9xxx_Driver pDriver, const LibMCDriver_BK9xxx_uint32 nNameSpaceBufferSize, LibMCDriver_BK9xxx_uint32* pNameSpaceNeededChars, char * pNameSpaceBuffer, const LibMCDriver_BK9xxx_uint32 nBaseNameBufferSize, LibMCDriver_BK9xxx_uint32* pBaseNameNeededChars, char * pBaseNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameSpaceBuffer) && !(pNameSpaceNeededChars) )
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if ( (!pBaseNameBuffer) && !(pBaseNameNeededChars) )
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sNameSpace("");
		std::string sBaseName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameSpaceBuffer == nullptr) || (pBaseNameBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetHeaderInformation(sNameSpace, sBaseName);

			pIDriver->_setCache (new ParameterCache_2<std::string, std::string> (sNameSpace, sBaseName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
			cache->retrieveData (sNameSpace, sBaseName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameSpaceNeededChars)
			*pNameSpaceNeededChars = (LibMCDriver_BK9xxx_uint32) (sNameSpace.size()+1);
		if (pNameSpaceBuffer) {
			if (sNameSpace.size() >= nNameSpaceBufferSize)
				throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_BUFFERTOOSMALL);
			for (size_t iNameSpace = 0; iNameSpace < sNameSpace.size(); iNameSpace++)
				pNameSpaceBuffer[iNameSpace] = sNameSpace[iNameSpace];
			pNameSpaceBuffer[sNameSpace.size()] = 0;
		}
		if (pBaseNameNeededChars)
			*pBaseNameNeededChars = (LibMCDriver_BK9xxx_uint32) (sBaseName.size()+1);
		if (pBaseNameBuffer) {
			if (sBaseName.size() >= nBaseNameBufferSize)
				throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_BUFFERTOOSMALL);
			for (size_t iBaseName = 0; iBaseName < sBaseName.size(); iBaseName++)
				pBaseNameBuffer[iBaseName] = sBaseName[iBaseName];
			pBaseNameBuffer[sBaseName.size()] = 0;
		}
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_queryparameters(LibMCDriver_BK9xxx_Driver pDriver)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver->QueryParameters();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Driver_BK9xxx
**************************************************************************************************************************/
LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_settosimulationmode(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->SetToSimulationMode();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_issimulationmode(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, bool * pSimulationModeEnabled)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pSimulationModeEnabled == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pSimulationModeEnabled = pIDriver_BK9xxx->IsSimulationMode();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_connect(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pIPAddress, LibMCDriver_BK9xxx_uint32 nPort, LibMCDriver_BK9xxx_uint32 nTimeOutInMs)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pIPAddress == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sIPAddress(pIPAddress);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->Connect(sIPAddress, nPort, nTimeOutInMs);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_getipaddress(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const LibMCDriver_BK9xxx_uint32 nIPAddressBufferSize, LibMCDriver_BK9xxx_uint32* pIPAddressNeededChars, char * pIPAddressBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if ( (!pIPAddressBuffer) && !(pIPAddressNeededChars) )
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sIPAddress("");
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIPAddressBuffer == nullptr);
		if (isCacheCall) {
			sIPAddress = pIDriver_BK9xxx->GetIPAddress();

			pIDriver_BK9xxx->_setCache (new ParameterCache_1<std::string> (sIPAddress));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver_BK9xxx->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
			cache->retrieveData (sIPAddress);
			pIDriver_BK9xxx->_setCache (nullptr);
		}
		
		if (pIPAddressNeededChars)
			*pIPAddressNeededChars = (LibMCDriver_BK9xxx_uint32) (sIPAddress.size()+1);
		if (pIPAddressBuffer) {
			if (sIPAddress.size() >= nIPAddressBufferSize)
				throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_BUFFERTOOSMALL);
			for (size_t iIPAddress = 0; iIPAddress < sIPAddress.size(); iIPAddress++)
				pIPAddressBuffer[iIPAddress] = sIPAddress[iIPAddress];
			pIPAddressBuffer[sIPAddress.size()] = 0;
		}
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_getport(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, LibMCDriver_BK9xxx_uint32 * pPort)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pPort == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pPort = pIDriver_BK9xxx->GetPort();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_gettimeout(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, LibMCDriver_BK9xxx_uint32 * pTimeOutInMs)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pTimeOutInMs == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pTimeOutInMs = pIDriver_BK9xxx->GetTimeOut();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_seterrorrecoverymode(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, LibMCDriver_BK9xxx_uint32 nReconnectionDelayInMs, LibMCDriver_BK9xxx_uint32 nReconnectionCount)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->SetErrorRecoveryMode(nReconnectionDelayInMs, nReconnectionCount);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_geterrorrecoverymode(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, LibMCDriver_BK9xxx_uint32 * pReconnectionDelayInMs, LibMCDriver_BK9xxx_uint32 nReconnectionCount)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (!pReconnectionDelayInMs)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->GetErrorRecoveryMode(*pReconnectionDelayInMs, nReconnectionCount);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_disconnect(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->Disconnect();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_resetdevice(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->ResetDevice();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_reconnect(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->Reconnect();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_isconnected(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, bool * pIsConnected)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pIsConnected == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pIsConnected = pIDriver_BK9xxx->IsConnected();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_geterrorstate(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, eLibMCDriver_BK9xxxErrorState * pErrorState)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pErrorState == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pErrorState = pIDriver_BK9xxx->GetErrorState();

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_variableexists(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pName, bool * pNameExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pNameExists == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pNameExists = pIDriver_BK9xxx->VariableExists(sName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_getvariabletype(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pName, eLibMCDriver_BK9xxxVariableType * pVariableType)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pVariableType == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pVariableType = pIDriver_BK9xxx->GetVariableType(sName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_digitalinputexists(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pName, bool * pNameExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pNameExists == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pNameExists = pIDriver_BK9xxx->DigitalInputExists(sName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_digitaloutputexists(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pName, bool * pNameExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pNameExists == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pNameExists = pIDriver_BK9xxx->DigitalOutputExists(sName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_analoginputexists(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pName, bool * pNameExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pNameExists == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pNameExists = pIDriver_BK9xxx->AnalogInputExists(sName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_analogoutputexists(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pName, bool * pNameExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pNameExists == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pNameExists = pIDriver_BK9xxx->AnalogOutputExists(sName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_getdigitalinput(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pVariableName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pVariableName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sVariableName(pVariableName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_BK9xxx->GetDigitalInput(sVariableName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_getdigitaloutput(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pVariableName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pVariableName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sVariableName(pVariableName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_BK9xxx->GetDigitalOutput(sVariableName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_getanaloginputraw(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pVariableName, LibMCDriver_BK9xxx_uint32 * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pVariableName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sVariableName(pVariableName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_BK9xxx->GetAnalogInputRaw(sVariableName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutputraw(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pVariableName, LibMCDriver_BK9xxx_uint32 * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pVariableName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sVariableName(pVariableName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_BK9xxx->GetAnalogOutputRaw(sVariableName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_getanaloginput(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pVariableName, LibMCDriver_BK9xxx_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pVariableName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sVariableName(pVariableName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_BK9xxx->GetAnalogInput(sVariableName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutput(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pVariableName, LibMCDriver_BK9xxx_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pVariableName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sVariableName(pVariableName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_BK9xxx->GetAnalogOutput(sVariableName);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_setdigitaloutput(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pVariableName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pVariableName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sVariableName(pVariableName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->SetDigitalOutput(sVariableName, bValue);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutputraw(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pVariableName, LibMCDriver_BK9xxx_uint32 nValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pVariableName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sVariableName(pVariableName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->SetAnalogOutputRaw(sVariableName, nValue);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutput(LibMCDriver_BK9xxx_Driver_BK9xxx pDriver_BK9xxx, const char * pVariableName, LibMCDriver_BK9xxx_double dValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_BK9xxx;

	try {
		if (pVariableName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sVariableName(pVariableName);
		IDriver_BK9xxx* pIDriver_BK9xxx = dynamic_cast<IDriver_BK9xxx*>(pIBaseClass);
		if (!pIDriver_BK9xxx)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		pIDriver_BK9xxx->SetAnalogOutput(sVariableName, dValue);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDriver_BK9xxxResult LibMCDriver_BK9xxx::Impl::LibMCDriver_BK9xxx_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdriver_bk9xxx_driver_configure") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_configure;
	if (sProcName == "libmcdriver_bk9xxx_driver_getname") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_getname;
	if (sProcName == "libmcdriver_bk9xxx_driver_gettype") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_gettype;
	if (sProcName == "libmcdriver_bk9xxx_driver_getversion") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_getversion;
	if (sProcName == "libmcdriver_bk9xxx_driver_getheaderinformation") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_getheaderinformation;
	if (sProcName == "libmcdriver_bk9xxx_driver_queryparameters") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_queryparameters;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_settosimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_settosimulationmode;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_issimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_issimulationmode;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_connect") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_connect;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_getipaddress") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_getipaddress;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_getport") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_getport;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_gettimeout") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_gettimeout;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_seterrorrecoverymode") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_seterrorrecoverymode;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_geterrorrecoverymode") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_geterrorrecoverymode;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_disconnect") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_disconnect;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_resetdevice") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_resetdevice;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_reconnect") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_reconnect;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_isconnected") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_isconnected;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_geterrorstate") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_geterrorstate;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_variableexists") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_variableexists;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_getvariabletype") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_getvariabletype;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_digitalinputexists") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_digitalinputexists;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_digitaloutputexists") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_digitaloutputexists;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_analoginputexists") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_analoginputexists;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_analogoutputexists") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_analogoutputexists;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_getdigitalinput") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_getdigitalinput;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_getdigitaloutput") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_getdigitaloutput;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_getanaloginputraw") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_getanaloginputraw;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutputraw") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutputraw;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_getanaloginput") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_getanaloginput;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutput") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutput;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_setdigitaloutput") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_setdigitaloutput;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutputraw") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutputraw;
	if (sProcName == "libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutput") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutput;
	if (sProcName == "libmcdriver_bk9xxx_getversion") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_getversion;
	if (sProcName == "libmcdriver_bk9xxx_getlasterror") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_getlasterror;
	if (sProcName == "libmcdriver_bk9xxx_releaseinstance") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_releaseinstance;
	if (sProcName == "libmcdriver_bk9xxx_acquireinstance") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_acquireinstance;
	if (sProcName == "libmcdriver_bk9xxx_injectcomponent") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_injectcomponent;
	if (sProcName == "libmcdriver_bk9xxx_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_getsymbollookupmethod;
	if (sProcName == "libmcdriver_bk9xxx_createdriver") 
		*ppProcAddress = (void*) &libmcdriver_bk9xxx_createdriver;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDRIVER_BK9XXX_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_getversion(LibMCDriver_BK9xxx_uint32 * pMajor, LibMCDriver_BK9xxx_uint32 * pMinor, LibMCDriver_BK9xxx_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_getlasterror(LibMCDriver_BK9xxx_Base pInstance, const LibMCDriver_BK9xxx_uint32 nErrorMessageBufferSize, LibMCDriver_BK9xxx_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCDriver_BK9xxx_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_releaseinstance(LibMCDriver_BK9xxx_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_acquireinstance(LibMCDriver_BK9xxx_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_injectcomponent(const char * pNameSpace, LibMCDriver_BK9xxx_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCEnv") {
			if (CWrapper::sPLibMCEnvWrapper.get() != nullptr) {
				throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCDriver_BK9xxxInterfaceException(LIBMCDRIVER_BK9XXX_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_getsymbollookupmethod(LibMCDriver_BK9xxx_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCDriver_BK9xxx::Impl::LibMCDriver_BK9xxx_GetProcAddress;
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_BK9xxxResult libmcdriver_bk9xxx_createdriver(const char * pName, const char * pType, LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCDriver_BK9xxx_Driver * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pType == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		if (pInstance == nullptr)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sType(pType);
		LibMCEnv::PDriverEnvironment pIDriverEnvironment = std::make_shared<LibMCEnv::CDriverEnvironment>(CWrapper::sPLibMCEnvWrapper.get(), pDriverEnvironment);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverEnvironment.get());
		if (!pIDriverEnvironment)
			throw ELibMCDriver_BK9xxxInterfaceException (LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDriver(sName, sType, pIDriverEnvironment);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	catch (ELibMCDriver_BK9xxxInterfaceException & Exception) {
		return handleLibMCDriver_BK9xxxException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


