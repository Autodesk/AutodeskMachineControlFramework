/*++

Copyright (C) 2023 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver Beckhoff BK9xxx bus coupler

Interface version: 1.0.0

*/

#ifndef __LIBMCDRIVER_BK9XXX_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_BK9XXX_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_bk9xxx_types.hpp"
#include "libmcdriver_bk9xxx_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_BK9xxx {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CDriver_BK9xxx;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_BK9xxxWrapper;
typedef CBase CLibMCDriver_BK9xxxBase;
typedef CDriver CLibMCDriver_BK9xxxDriver;
typedef CDriver_BK9xxx CLibMCDriver_BK9xxxDriver_BK9xxx;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CDriver_BK9xxx> PDriver_BK9xxx;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_BK9xxxWrapper;
typedef PBase PLibMCDriver_BK9xxxBase;
typedef PDriver PLibMCDriver_BK9xxxDriver;
typedef PDriver_BK9xxx PLibMCDriver_BK9xxxDriver_BK9xxx;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_BK9xxxHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_BK9xxxException 
**************************************************************************************************************************/
class ELibMCDriver_BK9xxxException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_BK9xxxResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_BK9xxxException(LibMCDriver_BK9xxxResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_BK9xxxResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_BK9XXX_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_BK9XXX_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_BK9XXX_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_BK9XXX_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_BK9XXX_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_BK9XXX_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_BK9XXX_ERROR_UNKNOWNEXCEPTION: return "UNKNOWNEXCEPTION";
			case LIBMCDRIVER_BK9XXX_ERROR_DRIVERERROR: return "DRIVERERROR";
			case LIBMCDRIVER_BK9XXX_ERROR_DRIVERNOTINITIALISED: return "DRIVERNOTINITIALISED";
			case LIBMCDRIVER_BK9XXX_ERROR_DRIVERNOTCONNECTED: return "DRIVERNOTCONNECTED";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDRIVERPROTOCOL: return "INVALIDDRIVERPROTOCOL";
			case LIBMCDRIVER_BK9XXX_ERROR_COULDNOTPARSEDRIVERPROTOCOL: return "COULDNOTPARSEDRIVERPROTOCOL";
			case LIBMCDRIVER_BK9XXX_ERROR_NOTCONNECTED: return "NOTCONNECTED";
			case LIBMCDRIVER_BK9XXX_ERROR_SETSIMULATIONMODEBEFORECONNECTING: return "SETSIMULATIONMODEBEFORECONNECTING";
			case LIBMCDRIVER_BK9XXX_ERROR_NOVERSIONDEFINITION: return "NOVERSIONDEFINITION";
			case LIBMCDRIVER_BK9XXX_ERROR_NOMAJORVERSION: return "NOMAJORVERSION";
			case LIBMCDRIVER_BK9XXX_ERROR_NOMINORVERSION: return "NOMINORVERSION";
			case LIBMCDRIVER_BK9XXX_ERROR_NOPATCHVERSION: return "NOPATCHVERSION";
			case LIBMCDRIVER_BK9XXX_ERROR_NOCONFIGURATIONSCHEMA: return "NOCONFIGURATIONSCHEMA";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDCONFIGURATIONSCHEMA: return "INVALIDCONFIGURATIONSCHEMA";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGDIGITALIOOFFSET: return "MISSINGDIGITALIOOFFSET";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDIGITALIOOFFSET: return "INVALIDDIGITALIOOFFSET";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGDIGITALIONAME: return "MISSINGDIGITALIONAME";
			case LIBMCDRIVER_BK9XXX_ERROR_EMPTYDIGITALIONAME: return "EMPTYDIGITALIONAME";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDIGITALIOINDEX: return "INVALIDDIGITALIOINDEX";
			case LIBMCDRIVER_BK9XXX_ERROR_DIGITALIONOTFOUND: return "DIGITALIONOTFOUND";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEDIGITALINPUT: return "DUPLICATEDIGITALINPUT";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEDIGITALOUTPUT: return "DUPLICATEDIGITALOUTPUT";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGDIGITALIOSTARTADDRESS: return "MISSINGDIGITALIOSTARTADDRESS";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDIGITALIOSTARTADDRESS: return "INVALIDDIGITALIOSTARTADDRESS";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGDIGITALIOBITCOUNT: return "MISSINGDIGITALIOBITCOUNT";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDIGITALIOBITCOUNT: return "INVALIDDIGITALIOBITCOUNT";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOOFFSET: return "MISSINGANALOGIOOFFSET";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOOFFSET: return "INVALIDANALOGIOOFFSET";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIONAME: return "MISSINGANALOGIONAME";
			case LIBMCDRIVER_BK9XXX_ERROR_EMPTYANALOGIONAME: return "EMPTYANALOGIONAME";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOINDEX: return "INVALIDANALOGIOINDEX";
			case LIBMCDRIVER_BK9XXX_ERROR_ANALOGIONOTFOUND: return "ANALOGIONOTFOUND";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEANALOGINPUT: return "DUPLICATEANALOGINPUT";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEANALOGOUTPUT: return "DUPLICATEANALOGOUTPUT";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOSTARTADDRESS: return "MISSINGANALOGIOSTARTADDRESS";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOSTARTADDRESS: return "INVALIDANALOGIOSTARTADDRESS";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOREGISTERCOUNT: return "MISSINGANALOGIOREGISTERCOUNT";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOREGISTERCOUNT: return "INVALIDANALOGIOREGISTERCOUNT";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEVARIABLENAME: return "DUPLICATEVARIABLENAME";
			case LIBMCDRIVER_BK9XXX_ERROR_VARIABLENOTFOUND: return "VARIABLENOTFOUND";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIORAWMINVALUE: return "MISSINGANALOGIORAWMINVALUE";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIORAWMAXVALUE: return "MISSINGANALOGIORAWMAXVALUE";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIORAWMINVALUE: return "INVALIDANALOGIORAWMINVALUE";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIORAWMAXVALUE: return "INVALIDANALOGIORAWMAXVALUE";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIORAWINTERVAL: return "INVALIDANALOGIORAWINTERVAL";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOSCALEDMINVALUE: return "MISSINGANALOGIOSCALEDMINVALUE";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOSCALEDMAXVALUE: return "MISSINGANALOGIOSCALEDMAXVALUE";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOSCALEDMINVALUE: return "INVALIDANALOGIOSCALEDMINVALUE";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOSCALEDMAXVALUE: return "INVALIDANALOGIOSCALEDMAXVALUE";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOSCALEDINTERVAL: return "INVALIDANALOGIOSCALEDINTERVAL";
			case LIBMCDRIVER_BK9XXX_ERROR_DIGITALIOOFFSETOUTOFRANGE: return "DIGITALIOOFFSETOUTOFRANGE";
			case LIBMCDRIVER_BK9XXX_ERROR_ANALOGIOOFFSETOUTOFRANGE: return "ANALOGIOOFFSETOUTOFRANGE";
			case LIBMCDRIVER_BK9XXX_ERROR_DIGITALIOWRITETIMEOUT: return "DIGITALIOWRITETIMEOUT";
			case LIBMCDRIVER_BK9XXX_ERROR_ANALOGIOWRITETIMEOUT: return "ANALOGIOWRITETIMEOUT";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_BK9XXX_SUCCESS: return "success";
			case LIBMCDRIVER_BK9XXX_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_BK9XXX_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_BK9XXX_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_BK9XXX_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_BK9XXX_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_BK9XXX_ERROR_UNKNOWNEXCEPTION: return "an unknown exception occurred";
			case LIBMCDRIVER_BK9XXX_ERROR_DRIVERERROR: return "a driver error occured";
			case LIBMCDRIVER_BK9XXX_ERROR_DRIVERNOTINITIALISED: return "the driver is not initialised";
			case LIBMCDRIVER_BK9XXX_ERROR_DRIVERNOTCONNECTED: return "the driver is not connected";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDRIVERPROTOCOL: return "invalid driver protocol definition";
			case LIBMCDRIVER_BK9XXX_ERROR_COULDNOTPARSEDRIVERPROTOCOL: return "could not parse driver protocol";
			case LIBMCDRIVER_BK9XXX_ERROR_NOTCONNECTED: return "Not connected";
			case LIBMCDRIVER_BK9XXX_ERROR_SETSIMULATIONMODEBEFORECONNECTING: return "Set error simulation mode before connecting.";
			case LIBMCDRIVER_BK9XXX_ERROR_NOVERSIONDEFINITION: return "no version definition";
			case LIBMCDRIVER_BK9XXX_ERROR_NOMAJORVERSION: return "no major version";
			case LIBMCDRIVER_BK9XXX_ERROR_NOMINORVERSION: return "no minor version";
			case LIBMCDRIVER_BK9XXX_ERROR_NOPATCHVERSION: return "no patch version";
			case LIBMCDRIVER_BK9XXX_ERROR_NOCONFIGURATIONSCHEMA: return "no configuration schema";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDCONFIGURATIONSCHEMA: return "invalid configuration schema";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGDIGITALIOOFFSET: return "missing digital IO offset";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDIGITALIOOFFSET: return "invalid digital IO offset";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGDIGITALIONAME: return "missing digitial IO name";
			case LIBMCDRIVER_BK9XXX_ERROR_EMPTYDIGITALIONAME: return "empty digitial IO name";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDIGITALIOINDEX: return "invalid digital IO index";
			case LIBMCDRIVER_BK9XXX_ERROR_DIGITALIONOTFOUND: return "digital IO not found";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEDIGITALINPUT: return "duplicate digital input";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEDIGITALOUTPUT: return "duplicate digital output";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGDIGITALIOSTARTADDRESS: return "missing digitial io start address";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDIGITALIOSTARTADDRESS: return "invalid digital io start address";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGDIGITALIOBITCOUNT: return "missing digital io bit count";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDDIGITALIOBITCOUNT: return "invalid digital io bit count";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOOFFSET: return "missing analog IO offset";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOOFFSET: return "invalid analog IO offset";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIONAME: return "missing analog IO name";
			case LIBMCDRIVER_BK9XXX_ERROR_EMPTYANALOGIONAME: return "empty analog IO name";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOINDEX: return "invalid analog IO index";
			case LIBMCDRIVER_BK9XXX_ERROR_ANALOGIONOTFOUND: return "analog IO not found";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEANALOGINPUT: return "duplicate analog input";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEANALOGOUTPUT: return "duplicate analog output";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOSTARTADDRESS: return "missing analog io start address";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOSTARTADDRESS: return "invalid analog io start address";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOREGISTERCOUNT: return "missing analog io register count";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOREGISTERCOUNT: return "invalid analog io register count";
			case LIBMCDRIVER_BK9XXX_ERROR_DUPLICATEVARIABLENAME: return "duplicate variable name";
			case LIBMCDRIVER_BK9XXX_ERROR_VARIABLENOTFOUND: return "variable not found";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIORAWMINVALUE: return "missing analog io raw min value";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIORAWMAXVALUE: return "missing analog io raw max value";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIORAWMINVALUE: return "invalid analog io raw min value";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIORAWMAXVALUE: return "invalid analog io raw max value";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIORAWINTERVAL: return "invalid analog io raw interval";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOSCALEDMINVALUE: return "missing analog io scaled min value";
			case LIBMCDRIVER_BK9XXX_ERROR_MISSINGANALOGIOSCALEDMAXVALUE: return "missing analog io scaled max value";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOSCALEDMINVALUE: return "invalid analog io scaled min value";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOSCALEDMAXVALUE: return "invalid analog io scaled max value";
			case LIBMCDRIVER_BK9XXX_ERROR_INVALIDANALOGIOSCALEDINTERVAL: return "invalid analog io scaled interval";
			case LIBMCDRIVER_BK9XXX_ERROR_DIGITALIOOFFSETOUTOFRANGE: return "digital io offset is out of range";
			case LIBMCDRIVER_BK9XXX_ERROR_ANALOGIOOFFSETOUTOFRANGE: return "analog io offset is out of range";
			case LIBMCDRIVER_BK9XXX_ERROR_DIGITALIOWRITETIMEOUT: return "digital io write timeout";
			case LIBMCDRIVER_BK9XXX_ERROR_ANALOGIOWRITETIMEOUT: return "analog io write timeout";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_BK9xxxInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_BK9xxxResult nResult);

	inline void GetVersion(LibMCDriver_BK9xxx_uint32 & nMajor, LibMCDriver_BK9xxx_uint32 & nMinor, LibMCDriver_BK9xxx_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_BK9xxx_pvoid pSymbolAddressMethod);
	inline LibMCDriver_BK9xxx_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_BK9xxxDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_BK9xxxResult checkBinaryVersion()
	{
		LibMCDriver_BK9xxx_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_BK9XXX_VERSION_MAJOR) {
			return LIBMCDRIVER_BK9XXX_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}
	LibMCDriver_BK9xxxResult initWrapperTable(sLibMCDriver_BK9xxxDynamicWrapperTable * pWrapperTable);
	LibMCDriver_BK9xxxResult releaseWrapperTable(sLibMCDriver_BK9xxxDynamicWrapperTable * pWrapperTable);
	LibMCDriver_BK9xxxResult loadWrapperTable(sLibMCDriver_BK9xxxDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_BK9xxxResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_BK9xxxDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CDriver_BK9xxx;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_BK9xxxHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_BK9xxxResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_BK9xxxHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_BK9xxxHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_BK9xxxHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_BK9xxx_uint32 & nMajor, LibMCDriver_BK9xxx_uint32 & nMinor, LibMCDriver_BK9xxx_uint32 & nMicro, std::string & sBuild);
	inline void GetHeaderInformation(std::string & sNameSpace, std::string & sBaseName);
	inline void QueryParameters();
};
	
/*************************************************************************************************************************
 Class CDriver_BK9xxx 
**************************************************************************************************************************/
class CDriver_BK9xxx : public CDriver {
public:
	
	/**
	* CDriver_BK9xxx::CDriver_BK9xxx - Constructor for Driver_BK9xxx class.
	*/
	CDriver_BK9xxx(CWrapper* pWrapper, LibMCDriver_BK9xxxHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline void SetToSimulationMode();
	inline bool IsSimulationMode();
	inline void Connect(const std::string & sIPAddress, const LibMCDriver_BK9xxx_uint32 nPort, const LibMCDriver_BK9xxx_uint32 nTimeOutInMs);
	inline std::string GetIPAddress();
	inline LibMCDriver_BK9xxx_uint32 GetPort();
	inline LibMCDriver_BK9xxx_uint32 GetTimeOut();
	inline void SetErrorRecoveryMode(const LibMCDriver_BK9xxx_uint32 nReconnectionDelayInMs, const LibMCDriver_BK9xxx_uint32 nReconnectionCount);
	inline void GetErrorRecoveryMode(LibMCDriver_BK9xxx_uint32 & nReconnectionDelayInMs, const LibMCDriver_BK9xxx_uint32 nReconnectionCount);
	inline void Disconnect();
	inline void ResetDevice();
	inline void Reconnect();
	inline bool IsConnected();
	inline eErrorState GetErrorState();
	inline bool VariableExists(const std::string & sName);
	inline eVariableType GetVariableType(const std::string & sName);
	inline bool DigitalInputExists(const std::string & sName);
	inline bool DigitalOutputExists(const std::string & sName);
	inline bool AnalogInputExists(const std::string & sName);
	inline bool AnalogOutputExists(const std::string & sName);
	inline bool GetDigitalInput(const std::string & sVariableName);
	inline bool GetDigitalOutput(const std::string & sVariableName);
	inline LibMCDriver_BK9xxx_uint32 GetAnalogInputRaw(const std::string & sVariableName);
	inline LibMCDriver_BK9xxx_uint32 GetAnalogOutputRaw(const std::string & sVariableName);
	inline LibMCDriver_BK9xxx_double GetAnalogInput(const std::string & sVariableName);
	inline LibMCDriver_BK9xxx_double GetAnalogOutput(const std::string & sVariableName);
	inline void SetDigitalOutput(const std::string & sVariableName, const bool bValue, const LibMCDriver_BK9xxx_uint32 nTimeOutInMs);
	inline void SetAnalogOutputRaw(const std::string & sVariableName, const LibMCDriver_BK9xxx_uint32 nValue, const LibMCDriver_BK9xxx_uint32 nTimeOutInMs);
	inline void SetAnalogOutput(const std::string & sVariableName, const LibMCDriver_BK9xxx_double dValue, const LibMCDriver_BK9xxx_uint32 nTimeOutInMs);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_BK9xxx_uint32 & nMajor, LibMCDriver_BK9xxx_uint32 & nMinor, LibMCDriver_BK9xxx_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_BK9xxxHandle hInstance = pInstance.GetHandle();
		LibMCDriver_BK9xxx_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_BK9xxx_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_BK9xxxHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_BK9xxxHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_BK9xxx_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_BK9xxxException(LIBMCDRIVER_BK9XXX_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_BK9xxxException(LIBMCDRIVER_BK9XXX_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_BK9xxx_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_BK9xxx_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_BK9xxxHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDriver>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_BK9xxxResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_BK9xxxException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_BK9xxxResult CWrapper::initWrapperTable(sLibMCDriver_BK9xxxDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_GetHeaderInformation = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_Driver_BK9xxx_SetToSimulationMode = nullptr;
		pWrapperTable->m_Driver_BK9xxx_IsSimulationMode = nullptr;
		pWrapperTable->m_Driver_BK9xxx_Connect = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetIPAddress = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetPort = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetTimeOut = nullptr;
		pWrapperTable->m_Driver_BK9xxx_SetErrorRecoveryMode = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetErrorRecoveryMode = nullptr;
		pWrapperTable->m_Driver_BK9xxx_Disconnect = nullptr;
		pWrapperTable->m_Driver_BK9xxx_ResetDevice = nullptr;
		pWrapperTable->m_Driver_BK9xxx_Reconnect = nullptr;
		pWrapperTable->m_Driver_BK9xxx_IsConnected = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetErrorState = nullptr;
		pWrapperTable->m_Driver_BK9xxx_VariableExists = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetVariableType = nullptr;
		pWrapperTable->m_Driver_BK9xxx_DigitalInputExists = nullptr;
		pWrapperTable->m_Driver_BK9xxx_DigitalOutputExists = nullptr;
		pWrapperTable->m_Driver_BK9xxx_AnalogInputExists = nullptr;
		pWrapperTable->m_Driver_BK9xxx_AnalogOutputExists = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetDigitalInput = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetDigitalOutput = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetAnalogInputRaw = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetAnalogOutputRaw = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetAnalogInput = nullptr;
		pWrapperTable->m_Driver_BK9xxx_GetAnalogOutput = nullptr;
		pWrapperTable->m_Driver_BK9xxx_SetDigitalOutput = nullptr;
		pWrapperTable->m_Driver_BK9xxx_SetAnalogOutputRaw = nullptr;
		pWrapperTable->m_Driver_BK9xxx_SetAnalogOutput = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}

	inline LibMCDriver_BK9xxxResult CWrapper::releaseWrapperTable(sLibMCDriver_BK9xxxDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}

	inline LibMCDriver_BK9xxxResult CWrapper::loadWrapperTable(sLibMCDriver_BK9xxxDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_BK9xxxDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_BK9xxxDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_BK9xxxDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_BK9xxxDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_BK9xxxDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_BK9xxxDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_BK9xxxDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_BK9xxxDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetHeaderInformation = (PLibMCDriver_BK9xxxDriver_GetHeaderInformationPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_getheaderinformation");
		#else // _WIN32
		pWrapperTable->m_Driver_GetHeaderInformation = (PLibMCDriver_BK9xxxDriver_GetHeaderInformationPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_getheaderinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetHeaderInformation == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_BK9xxxDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_BK9xxxDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetToSimulationMode = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetToSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_settosimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetToSimulationMode = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetToSimulationModePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_settosimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_SetToSimulationMode == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_IsSimulationMode = (PLibMCDriver_BK9xxxDriver_BK9xxx_IsSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_issimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_IsSimulationMode = (PLibMCDriver_BK9xxxDriver_BK9xxx_IsSimulationModePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_issimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_IsSimulationMode == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_Connect = (PLibMCDriver_BK9xxxDriver_BK9xxx_ConnectPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_connect");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_Connect = (PLibMCDriver_BK9xxxDriver_BK9xxx_ConnectPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_connect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_Connect == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetIPAddress = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetIPAddressPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getipaddress");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetIPAddress = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetIPAddressPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getipaddress");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetIPAddress == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetPort = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetPortPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getport");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetPort = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetPortPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getport");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetPort == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetTimeOut = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetTimeOutPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_gettimeout");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetTimeOut = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetTimeOutPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_gettimeout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetTimeOut == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetErrorRecoveryMode = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetErrorRecoveryModePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_seterrorrecoverymode");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetErrorRecoveryMode = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetErrorRecoveryModePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_seterrorrecoverymode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_SetErrorRecoveryMode == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetErrorRecoveryMode = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetErrorRecoveryModePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_geterrorrecoverymode");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetErrorRecoveryMode = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetErrorRecoveryModePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_geterrorrecoverymode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetErrorRecoveryMode == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_Disconnect = (PLibMCDriver_BK9xxxDriver_BK9xxx_DisconnectPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_disconnect");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_Disconnect = (PLibMCDriver_BK9xxxDriver_BK9xxx_DisconnectPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_disconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_Disconnect == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_ResetDevice = (PLibMCDriver_BK9xxxDriver_BK9xxx_ResetDevicePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_resetdevice");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_ResetDevice = (PLibMCDriver_BK9xxxDriver_BK9xxx_ResetDevicePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_resetdevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_ResetDevice == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_Reconnect = (PLibMCDriver_BK9xxxDriver_BK9xxx_ReconnectPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_reconnect");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_Reconnect = (PLibMCDriver_BK9xxxDriver_BK9xxx_ReconnectPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_reconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_Reconnect == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_IsConnected = (PLibMCDriver_BK9xxxDriver_BK9xxx_IsConnectedPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_isconnected");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_IsConnected = (PLibMCDriver_BK9xxxDriver_BK9xxx_IsConnectedPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_isconnected");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_IsConnected == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetErrorState = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetErrorStatePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_geterrorstate");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetErrorState = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetErrorStatePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_geterrorstate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetErrorState == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_VariableExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_VariableExistsPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_variableexists");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_VariableExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_VariableExistsPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_variableexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_VariableExists == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetVariableType = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetVariableTypePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getvariabletype");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetVariableType = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetVariableTypePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getvariabletype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetVariableType == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_DigitalInputExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_DigitalInputExistsPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_digitalinputexists");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_DigitalInputExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_DigitalInputExistsPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_digitalinputexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_DigitalInputExists == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_DigitalOutputExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_DigitalOutputExistsPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_digitaloutputexists");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_DigitalOutputExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_DigitalOutputExistsPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_digitaloutputexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_DigitalOutputExists == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_AnalogInputExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_AnalogInputExistsPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_analoginputexists");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_AnalogInputExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_AnalogInputExistsPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_analoginputexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_AnalogInputExists == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_AnalogOutputExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_AnalogOutputExistsPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_analogoutputexists");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_AnalogOutputExists = (PLibMCDriver_BK9xxxDriver_BK9xxx_AnalogOutputExistsPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_analogoutputexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_AnalogOutputExists == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetDigitalInput = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetDigitalInputPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getdigitalinput");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetDigitalInput = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetDigitalInputPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getdigitalinput");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetDigitalInput == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetDigitalOutput = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetDigitalOutputPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getdigitaloutput");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetDigitalOutput = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetDigitalOutputPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getdigitaloutput");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetDigitalOutput == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetAnalogInputRaw = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetAnalogInputRawPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getanaloginputraw");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetAnalogInputRaw = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetAnalogInputRawPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getanaloginputraw");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetAnalogInputRaw == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetAnalogOutputRaw = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetAnalogOutputRawPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutputraw");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetAnalogOutputRaw = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetAnalogOutputRawPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutputraw");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetAnalogOutputRaw == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetAnalogInput = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetAnalogInputPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getanaloginput");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetAnalogInput = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetAnalogInputPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getanaloginput");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetAnalogInput == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetAnalogOutput = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetAnalogOutputPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutput");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_GetAnalogOutput = (PLibMCDriver_BK9xxxDriver_BK9xxx_GetAnalogOutputPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutput");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_GetAnalogOutput == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetDigitalOutput = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetDigitalOutputPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_setdigitaloutput");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetDigitalOutput = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetDigitalOutputPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_setdigitaloutput");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_SetDigitalOutput == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetAnalogOutputRaw = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetAnalogOutputRawPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutputraw");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetAnalogOutputRaw = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetAnalogOutputRawPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutputraw");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_SetAnalogOutputRaw == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetAnalogOutput = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetAnalogOutputPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutput");
		#else // _WIN32
		pWrapperTable->m_Driver_BK9xxx_SetAnalogOutput = (PLibMCDriver_BK9xxxDriver_BK9xxx_SetAnalogOutputPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutput");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_BK9xxx_SetAnalogOutput == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_BK9xxxGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_BK9xxxGetVersionPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_BK9xxxGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_BK9xxxGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_BK9xxxReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_BK9xxxReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_BK9xxxAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_BK9xxxAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_bk9xxx_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_BK9xxxInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_BK9xxxInjectComponentPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_BK9xxxGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_BK9xxxGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_BK9xxxCreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_bk9xxx_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_BK9xxxCreateDriverPtr) dlsym(hLibrary, "libmcdriver_bk9xxx_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_BK9XXX_SUCCESS;
	}

	inline LibMCDriver_BK9xxxResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_BK9xxxDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_BK9XXX_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_BK9xxxResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_BK9xxxResult eLookupError = LIBMCDRIVER_BK9XXX_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_getheaderinformation", (void**)&(pWrapperTable->m_Driver_GetHeaderInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetHeaderInformation == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_settosimulationmode", (void**)&(pWrapperTable->m_Driver_BK9xxx_SetToSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_SetToSimulationMode == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_issimulationmode", (void**)&(pWrapperTable->m_Driver_BK9xxx_IsSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_IsSimulationMode == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_connect", (void**)&(pWrapperTable->m_Driver_BK9xxx_Connect));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_Connect == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_getipaddress", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetIPAddress));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetIPAddress == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_getport", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetPort));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetPort == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_gettimeout", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetTimeOut));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetTimeOut == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_seterrorrecoverymode", (void**)&(pWrapperTable->m_Driver_BK9xxx_SetErrorRecoveryMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_SetErrorRecoveryMode == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_geterrorrecoverymode", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetErrorRecoveryMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetErrorRecoveryMode == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_disconnect", (void**)&(pWrapperTable->m_Driver_BK9xxx_Disconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_Disconnect == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_resetdevice", (void**)&(pWrapperTable->m_Driver_BK9xxx_ResetDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_ResetDevice == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_reconnect", (void**)&(pWrapperTable->m_Driver_BK9xxx_Reconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_Reconnect == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_isconnected", (void**)&(pWrapperTable->m_Driver_BK9xxx_IsConnected));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_IsConnected == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_geterrorstate", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetErrorState));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetErrorState == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_variableexists", (void**)&(pWrapperTable->m_Driver_BK9xxx_VariableExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_VariableExists == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_getvariabletype", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetVariableType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetVariableType == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_digitalinputexists", (void**)&(pWrapperTable->m_Driver_BK9xxx_DigitalInputExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_DigitalInputExists == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_digitaloutputexists", (void**)&(pWrapperTable->m_Driver_BK9xxx_DigitalOutputExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_DigitalOutputExists == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_analoginputexists", (void**)&(pWrapperTable->m_Driver_BK9xxx_AnalogInputExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_AnalogInputExists == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_analogoutputexists", (void**)&(pWrapperTable->m_Driver_BK9xxx_AnalogOutputExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_AnalogOutputExists == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_getdigitalinput", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetDigitalInput));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetDigitalInput == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_getdigitaloutput", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetDigitalOutput));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetDigitalOutput == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_getanaloginputraw", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetAnalogInputRaw));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetAnalogInputRaw == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutputraw", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetAnalogOutputRaw));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetAnalogOutputRaw == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_getanaloginput", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetAnalogInput));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetAnalogInput == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_getanalogoutput", (void**)&(pWrapperTable->m_Driver_BK9xxx_GetAnalogOutput));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_GetAnalogOutput == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_setdigitaloutput", (void**)&(pWrapperTable->m_Driver_BK9xxx_SetDigitalOutput));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_SetDigitalOutput == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutputraw", (void**)&(pWrapperTable->m_Driver_BK9xxx_SetAnalogOutputRaw));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_SetAnalogOutputRaw == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_driver_bk9xxx_setanalogoutput", (void**)&(pWrapperTable->m_Driver_BK9xxx_SetAnalogOutput));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_BK9xxx_SetAnalogOutput == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_bk9xxx_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_BK9XXX_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_BK9XXX_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_BK9xxx_uint32 bytesNeededName = 0;
		LibMCDriver_BK9xxx_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_BK9xxx_uint32 bytesNeededType = 0;
		LibMCDriver_BK9xxx_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_BK9xxx_uint32 & nMajor, LibMCDriver_BK9xxx_uint32 & nMinor, LibMCDriver_BK9xxx_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_BK9xxx_uint32 bytesNeededBuild = 0;
		LibMCDriver_BK9xxx_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::GetHeaderInformation - returns the header information
	* @param[out] sNameSpace - NameSpace of the driver.
	* @param[out] sBaseName - BaseName of the driver.
	*/
	void CDriver::GetHeaderInformation(std::string & sNameSpace, std::string & sBaseName)
	{
		LibMCDriver_BK9xxx_uint32 bytesNeededNameSpace = 0;
		LibMCDriver_BK9xxx_uint32 bytesWrittenNameSpace = 0;
		LibMCDriver_BK9xxx_uint32 bytesNeededBaseName = 0;
		LibMCDriver_BK9xxx_uint32 bytesWrittenBaseName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetHeaderInformation(m_pHandle, 0, &bytesNeededNameSpace, nullptr, 0, &bytesNeededBaseName, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		std::vector<char> bufferBaseName(bytesNeededBaseName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetHeaderInformation(m_pHandle, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0], bytesNeededBaseName, &bytesWrittenBaseName, &bufferBaseName[0]));
		sNameSpace = std::string(&bufferNameSpace[0]);
		sBaseName = std::string(&bufferBaseName[0]);
	}
	
	/**
	* CDriver::QueryParameters - Stores the driver parameters in the driver environment.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	 * Method definitions for class CDriver_BK9xxx
	 */
	
	/**
	* CDriver_BK9xxx::SetToSimulationMode - Turns the driver into a simulation mode.
	*/
	void CDriver_BK9xxx::SetToSimulationMode()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_SetToSimulationMode(m_pHandle));
	}
	
	/**
	* CDriver_BK9xxx::IsSimulationMode - Returns if the driver is in simulation mode.
	* @return Flag if driver is in simulation mode.
	*/
	bool CDriver_BK9xxx::IsSimulationMode()
	{
		bool resultSimulationModeEnabled = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_IsSimulationMode(m_pHandle, &resultSimulationModeEnabled));
		
		return resultSimulationModeEnabled;
	}
	
	/**
	* CDriver_BK9xxx::Connect - Connects to a BK9xxx bus coupler.
	* @param[in] sIPAddress - Address of BK9xxx coupler.
	* @param[in] nPort - Modbus TCP port of BK9xxx coupler. (Usually 502).
	* @param[in] nTimeOutInMs - Connection timeout in milliseconds.
	*/
	void CDriver_BK9xxx::Connect(const std::string & sIPAddress, const LibMCDriver_BK9xxx_uint32 nPort, const LibMCDriver_BK9xxx_uint32 nTimeOutInMs)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_Connect(m_pHandle, sIPAddress.c_str(), nPort, nTimeOutInMs));
	}
	
	/**
	* CDriver_BK9xxx::GetIPAddress - Returns the IP Address of the connection.
	* @return Address of BK9xxx coupler.
	*/
	std::string CDriver_BK9xxx::GetIPAddress()
	{
		LibMCDriver_BK9xxx_uint32 bytesNeededIPAddress = 0;
		LibMCDriver_BK9xxx_uint32 bytesWrittenIPAddress = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetIPAddress(m_pHandle, 0, &bytesNeededIPAddress, nullptr));
		std::vector<char> bufferIPAddress(bytesNeededIPAddress);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetIPAddress(m_pHandle, bytesNeededIPAddress, &bytesWrittenIPAddress, &bufferIPAddress[0]));
		
		return std::string(&bufferIPAddress[0]);
	}
	
	/**
	* CDriver_BK9xxx::GetPort - Returns the Port of the connection.
	* @return Modbus TCP port of BK9xxx coupler. (Usually 502).
	*/
	LibMCDriver_BK9xxx_uint32 CDriver_BK9xxx::GetPort()
	{
		LibMCDriver_BK9xxx_uint32 resultPort = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetPort(m_pHandle, &resultPort));
		
		return resultPort;
	}
	
	/**
	* CDriver_BK9xxx::GetTimeOut - Returns the Timeout of the connection.
	* @return Connection timeout in milliseconds.
	*/
	LibMCDriver_BK9xxx_uint32 CDriver_BK9xxx::GetTimeOut()
	{
		LibMCDriver_BK9xxx_uint32 resultTimeOutInMs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetTimeOut(m_pHandle, &resultTimeOutInMs));
		
		return resultTimeOutInMs;
	}
	
	/**
	* CDriver_BK9xxx::SetErrorRecoveryMode - Sets the connection recovery mode.
	* @param[in] nReconnectionDelayInMs - If connection is lost, how much time should be waited to reconnect in Milliseconds. Default is 300.
	* @param[in] nReconnectionCount - How many times should a reconnection be attempted. Default is 3.
	*/
	void CDriver_BK9xxx::SetErrorRecoveryMode(const LibMCDriver_BK9xxx_uint32 nReconnectionDelayInMs, const LibMCDriver_BK9xxx_uint32 nReconnectionCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_SetErrorRecoveryMode(m_pHandle, nReconnectionDelayInMs, nReconnectionCount));
	}
	
	/**
	* CDriver_BK9xxx::GetErrorRecoveryMode - Gets the connection recovery mode.
	* @param[out] nReconnectionDelayInMs - If connection is lost, how much time should be waited to reconnect in Milliseconds. Default is 300.
	* @param[in] nReconnectionCount - How many times should a reconnection be attempted. Default is 3.
	*/
	void CDriver_BK9xxx::GetErrorRecoveryMode(LibMCDriver_BK9xxx_uint32 & nReconnectionDelayInMs, const LibMCDriver_BK9xxx_uint32 nReconnectionCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetErrorRecoveryMode(m_pHandle, &nReconnectionDelayInMs, nReconnectionCount));
	}
	
	/**
	* CDriver_BK9xxx::Disconnect - Disconnects from the Bus coupler.
	*/
	void CDriver_BK9xxx::Disconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_Disconnect(m_pHandle));
	}
	
	/**
	* CDriver_BK9xxx::ResetDevice - Resets the Bk9xxx bus coupler. Fails if not connected.
	*/
	void CDriver_BK9xxx::ResetDevice()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_ResetDevice(m_pHandle));
	}
	
	/**
	* CDriver_BK9xxx::Reconnect - Reconnects to the Bk9xxx bus coupler. Fails if Connect has never been called.
	*/
	void CDriver_BK9xxx::Reconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_Reconnect(m_pHandle));
	}
	
	/**
	* CDriver_BK9xxx::IsConnected - Returns if the the Bk9xxx bus coupler is connected.
	* @return Flag if BK9xxx is connected.
	*/
	bool CDriver_BK9xxx::IsConnected()
	{
		bool resultIsConnected = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_IsConnected(m_pHandle, &resultIsConnected));
		
		return resultIsConnected;
	}
	
	/**
	* CDriver_BK9xxx::GetErrorState - Returns the error state of the Bk9xxx bus coupler connection.
	* @return Error state of the connection.
	*/
	eErrorState CDriver_BK9xxx::GetErrorState()
	{
		eErrorState resultErrorState = (eErrorState) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetErrorState(m_pHandle, &resultErrorState));
		
		return resultErrorState;
	}
	
	/**
	* CDriver_BK9xxx::VariableExists - Returns if any input or output exists by this name.
	* @param[in] sName - Name of variable.
	* @return Flag if value exists.
	*/
	bool CDriver_BK9xxx::VariableExists(const std::string & sName)
	{
		bool resultNameExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_VariableExists(m_pHandle, sName.c_str(), &resultNameExists));
		
		return resultNameExists;
	}
	
	/**
	* CDriver_BK9xxx::GetVariableType - Returns type of a variable.
	* @param[in] sName - Name of variable.
	* @return Type of variable.
	*/
	eVariableType CDriver_BK9xxx::GetVariableType(const std::string & sName)
	{
		eVariableType resultVariableType = (eVariableType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetVariableType(m_pHandle, sName.c_str(), &resultVariableType));
		
		return resultVariableType;
	}
	
	/**
	* CDriver_BK9xxx::DigitalInputExists - Returns if a digital input exists.
	* @param[in] sName - Name of variable.
	* @return Flag if value exists.
	*/
	bool CDriver_BK9xxx::DigitalInputExists(const std::string & sName)
	{
		bool resultNameExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_DigitalInputExists(m_pHandle, sName.c_str(), &resultNameExists));
		
		return resultNameExists;
	}
	
	/**
	* CDriver_BK9xxx::DigitalOutputExists - Returns if a digital output exists.
	* @param[in] sName - Name of variable.
	* @return Flag if value exists.
	*/
	bool CDriver_BK9xxx::DigitalOutputExists(const std::string & sName)
	{
		bool resultNameExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_DigitalOutputExists(m_pHandle, sName.c_str(), &resultNameExists));
		
		return resultNameExists;
	}
	
	/**
	* CDriver_BK9xxx::AnalogInputExists - Returns if an analog input exists.
	* @param[in] sName - Name of variable.
	* @return Flag if value exists.
	*/
	bool CDriver_BK9xxx::AnalogInputExists(const std::string & sName)
	{
		bool resultNameExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_AnalogInputExists(m_pHandle, sName.c_str(), &resultNameExists));
		
		return resultNameExists;
	}
	
	/**
	* CDriver_BK9xxx::AnalogOutputExists - Returns if an analog output exists.
	* @param[in] sName - Name of variable.
	* @return Flag if value exists.
	*/
	bool CDriver_BK9xxx::AnalogOutputExists(const std::string & sName)
	{
		bool resultNameExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_AnalogOutputExists(m_pHandle, sName.c_str(), &resultNameExists));
		
		return resultNameExists;
	}
	
	/**
	* CDriver_BK9xxx::GetDigitalInput - Reads a value from an digital input variable. Fails if variable does not exist.
	* @param[in] sVariableName - Name of variable.
	* @return Result value.
	*/
	bool CDriver_BK9xxx::GetDigitalInput(const std::string & sVariableName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetDigitalInput(m_pHandle, sVariableName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CDriver_BK9xxx::GetDigitalOutput - Reads a value from an digital output variable. Fails if variable does not exist.
	* @param[in] sVariableName - Name of variable.
	* @return Result value.
	*/
	bool CDriver_BK9xxx::GetDigitalOutput(const std::string & sVariableName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetDigitalOutput(m_pHandle, sVariableName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CDriver_BK9xxx::GetAnalogInputRaw - Reads a raw value from an analog input variable. Fails if variable does not exist.
	* @param[in] sVariableName - Name of variable.
	* @return Result value.
	*/
	LibMCDriver_BK9xxx_uint32 CDriver_BK9xxx::GetAnalogInputRaw(const std::string & sVariableName)
	{
		LibMCDriver_BK9xxx_uint32 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetAnalogInputRaw(m_pHandle, sVariableName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CDriver_BK9xxx::GetAnalogOutputRaw - Reads a raw value from an analog output variable. Fails if variable does not exist.
	* @param[in] sVariableName - Name of variable.
	* @return Result value.
	*/
	LibMCDriver_BK9xxx_uint32 CDriver_BK9xxx::GetAnalogOutputRaw(const std::string & sVariableName)
	{
		LibMCDriver_BK9xxx_uint32 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetAnalogOutputRaw(m_pHandle, sVariableName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CDriver_BK9xxx::GetAnalogInput - Reads a scaled value from an analog input variable. Fails if variable does not exist.
	* @param[in] sVariableName - Name of variable.
	* @return Result value.
	*/
	LibMCDriver_BK9xxx_double CDriver_BK9xxx::GetAnalogInput(const std::string & sVariableName)
	{
		LibMCDriver_BK9xxx_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetAnalogInput(m_pHandle, sVariableName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CDriver_BK9xxx::GetAnalogOutput - Reads a scaled value from an analog output variable. Fails if variable does not exist.
	* @param[in] sVariableName - Name of variable.
	* @return Result value.
	*/
	LibMCDriver_BK9xxx_double CDriver_BK9xxx::GetAnalogOutput(const std::string & sVariableName)
	{
		LibMCDriver_BK9xxx_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_GetAnalogOutput(m_pHandle, sVariableName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CDriver_BK9xxx::SetDigitalOutput - Writes a value to a digital output variable. Fails if variable does not exist.
	* @param[in] sVariableName - Name of variable.
	* @param[in] bValue - Value to be set.
	* @param[in] nTimeOutInMs - If Timeout is larger than 0, the call waits until the end point has acknowledged that the new value has been set. If timeout is 0, the call returns immediately, even if the end point might not have changed the value yet.
	*/
	void CDriver_BK9xxx::SetDigitalOutput(const std::string & sVariableName, const bool bValue, const LibMCDriver_BK9xxx_uint32 nTimeOutInMs)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_SetDigitalOutput(m_pHandle, sVariableName.c_str(), bValue, nTimeOutInMs));
	}
	
	/**
	* CDriver_BK9xxx::SetAnalogOutputRaw - Writes a raw value to an analog output variable. Fails if variable does not exist.
	* @param[in] sVariableName - Name of variable.
	* @param[in] nValue - Value to be set.
	* @param[in] nTimeOutInMs - If Timeout is larger than 0, the call waits until the end point has acknowledged that the new value has been set. If timeout is 0, the call returns immediately, even if the end point might not have changed the value yet.
	*/
	void CDriver_BK9xxx::SetAnalogOutputRaw(const std::string & sVariableName, const LibMCDriver_BK9xxx_uint32 nValue, const LibMCDriver_BK9xxx_uint32 nTimeOutInMs)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_SetAnalogOutputRaw(m_pHandle, sVariableName.c_str(), nValue, nTimeOutInMs));
	}
	
	/**
	* CDriver_BK9xxx::SetAnalogOutput - Writes a scaled value to an analog output variable. Fails if variable does not exist.
	* @param[in] sVariableName - Name of variable.
	* @param[in] dValue - Value to be set.
	* @param[in] nTimeOutInMs - If Timeout is larger than 0, the call waits until the end point has acknowledged that the new value has been set. If timeout is 0, the call returns immediately, even if the end point might not have changed the value yet.
	*/
	void CDriver_BK9xxx::SetAnalogOutput(const std::string & sVariableName, const LibMCDriver_BK9xxx_double dValue, const LibMCDriver_BK9xxx_uint32 nTimeOutInMs)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_BK9xxx_SetAnalogOutput(m_pHandle, sVariableName.c_str(), dValue, nTimeOutInMs));
	}

} // namespace LibMCDriver_BK9xxx

#endif // __LIBMCDRIVER_BK9XXX_CPPHEADER_DYNAMIC_CPP

