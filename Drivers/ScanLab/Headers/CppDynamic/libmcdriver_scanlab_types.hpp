/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file with basic types in
order to allow an easy use of MC Driver ScanLab RTC

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_SCANLAB_TYPES_HEADER_CPP
#define __LIBMCDRIVER_SCANLAB_TYPES_HEADER_CPP


/*************************************************************************************************************************
 Scalar types definition
**************************************************************************************************************************/

#ifdef LIBMCDRIVER_SCANLAB_USELEGACYINTEGERTYPES

typedef unsigned char LibMCDriver_ScanLab_uint8;
typedef unsigned short LibMCDriver_ScanLab_uint16 ;
typedef unsigned int LibMCDriver_ScanLab_uint32;
typedef unsigned long long LibMCDriver_ScanLab_uint64;
typedef char LibMCDriver_ScanLab_int8;
typedef short LibMCDriver_ScanLab_int16;
typedef int LibMCDriver_ScanLab_int32;
typedef long long LibMCDriver_ScanLab_int64;

#else // LIBMCDRIVER_SCANLAB_USELEGACYINTEGERTYPES

#include <stdint.h>

typedef uint8_t LibMCDriver_ScanLab_uint8;
typedef uint16_t LibMCDriver_ScanLab_uint16;
typedef uint32_t LibMCDriver_ScanLab_uint32;
typedef uint64_t LibMCDriver_ScanLab_uint64;
typedef int8_t LibMCDriver_ScanLab_int8;
typedef int16_t LibMCDriver_ScanLab_int16;
typedef int32_t LibMCDriver_ScanLab_int32;
typedef int64_t LibMCDriver_ScanLab_int64 ;

#endif // LIBMCDRIVER_SCANLAB_USELEGACYINTEGERTYPES

typedef float LibMCDriver_ScanLab_single;
typedef double LibMCDriver_ScanLab_double;

/*************************************************************************************************************************
 General type definitions
**************************************************************************************************************************/

typedef LibMCDriver_ScanLab_int32 LibMCDriver_ScanLabResult;
typedef void * LibMCDriver_ScanLabHandle;
typedef void * LibMCDriver_ScanLab_pvoid;

/*************************************************************************************************************************
 Version for LibMCDriver_ScanLab
**************************************************************************************************************************/

#define LIBMCDRIVER_SCANLAB_VERSION_MAJOR 2
#define LIBMCDRIVER_SCANLAB_VERSION_MINOR 0
#define LIBMCDRIVER_SCANLAB_VERSION_MICRO 0
#define LIBMCDRIVER_SCANLAB_VERSION_PRERELEASEINFO ""
#define LIBMCDRIVER_SCANLAB_VERSION_BUILDINFO ""

/*************************************************************************************************************************
 Error constants for LibMCDriver_ScanLab
**************************************************************************************************************************/

#define LIBMCDRIVER_SCANLAB_SUCCESS 0
#define LIBMCDRIVER_SCANLAB_ERROR_NOTIMPLEMENTED 1 /** functionality not implemented */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM 2 /** an invalid parameter was passed */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST 3 /** a type cast failed */
#define LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL 4 /** a provided buffer is too small */
#define LIBMCDRIVER_SCANLAB_ERROR_GENERICEXCEPTION 5 /** a generic exception occurred */
#define LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY 6 /** the library could not be loaded */
#define LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT 7 /** a required exported symbol could not be found in the library */
#define LIBMCDRIVER_SCANLAB_ERROR_INCOMPATIBLEBINARYVERSION 8 /** the version of the binary interface does not match the bindings interface */
#define LIBMCDRIVER_SCANLAB_ERROR_DRIVERERROR 1000 /** a driver error occured */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_NO_PCIE_CARD_FOUND 1001 /** RTC6: No PCIE Card was found */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_ACCESS_DENIED 1002 /** RTC6: Access Denied */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_SEND_ERROR 1003 /** RTC6: Send Error */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_TIMEOUT 1004 /** RTC6: Timeout */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_PARAM_ERROR 1005 /** RTC6: Param Error */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_BUSY 1006 /** RTC6: Busy */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_REJECTED 1007 /** RTC6: Rejected */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_IGNORED 1008 /** RTC6: Ignored */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERSION_MISMATCH 1009 /** RTC6: Version Mismatch */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERIFY_ERROR 1010 /** RTC6: Verify Error */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_TYPE_REJECTED 1011 /** RTC6: Type Rejected */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_OUT_OF_MEMORY 1012 /** RTC6: Out of Memory */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_FLASH_ERROR 1013 /** RTC6: Flash Error */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_ETH_ERROR 1014 /** RTC6: Eth Error */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_CONFIG_ERROR 1015 /** RTC6: Config Error */
#define LIBMCDRIVER_SCANLAB_ERROR_RTC6_UNKNOWN_ERROR 1016 /** RTC6: Unknown Error */
#define LIBMCDRIVER_SCANLAB_ERROR_RTCOPEN_FAILED 1017 /** RTC open failed */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCPROC 1018 /** Invalid RTC proc */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDIPADDRESS 1019 /** Invalid IP Address */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDNETMASK 1020 /** Invalid NetMask */
#define LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYACQUIRED 1021 /** Card already acquired */
#define LIBMCDRIVER_SCANLAB_ERROR_CARDNOTFOUND 1022 /** Card not found */
#define LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADPROGRAMFILE 1023 /** Could not load program file */
#define LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADCORRECTIONFILE 1024 /** Could not load correction file */
#define LIBMCDRIVER_SCANLAB_ERROR_DELAYSMUSTBEMULTIPLEOF10 1025 /** Delays must be a multiple of 10 microseconds */
#define LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKNOTLOADED 1026 /** Scanlab RTC has not been loaded */
#define LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKALREADYLOADED 1027 /** Scanlab RTC has already been loaded */
#define LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYINITIALIZED 1028 /** Scanlab RTC card is already initialized */
#define LIBMCDRIVER_SCANLAB_ERROR_CARDNOTINITIALIZED 1029 /** Scanlab RTC card is not initialized */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOINTCOUNT 1030 /** Invalid point count */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDMAXLASERPOWER 1031 /** Invalid max laser power. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERDELAY 1032 /** Invalid laser delay. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERDELAY 1033 /** Invalid scanner delay. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANLABSDK 1034 /** Invalid SCANLAB SDK. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIESIGNALBUFFERARRAY 1035 /** Invalid OIE Signal buffer array. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGTIMELAG 1036 /** Invalid Skywriting Timelag. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGLASERONSHIFT 1037 /** Invalid Skywriting Laser On Shift. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPREV 1038 /** Invalid Skywriting N Prev. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPOST 1039 /** Invalid Skywriting N Post. */
#define LIBMCDRIVER_SCANLAB_ERROR_OIEHASNOTBEENINITIALIZED 1040 /** OIE has not been initialized. */
#define LIBMCDRIVER_SCANLAB_ERROR_UNSUPPORTEDOIEOPERATIONMODE 1041 /** Unsupported OIE Operation Mode. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCCORRECTIONDATA 1042 /** Invalid RTC Correction data. */
#define LIBMCDRIVER_SCANLAB_ERROR_CONFIGURATIONPRESETNOTFOUND 1043 /** Configuration preset not found. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERCOUNT 1044 /** Invalid scanner count. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERINDEX 1045 /** Invalid scanner index. */
#define LIBMCDRIVER_SCANLAB_ERROR_LASERINDEXHASNOASSIGNEDSCANNER 1046 /** Laser index has no assigned scanner. */
#define LIBMCDRIVER_SCANLAB_ERROR_LASERINDEXNOTFOUND 1047 /** Laser index not found. */
#define LIBMCDRIVER_SCANLAB_ERROR_DUPLICATELASERINDEX 1048 /** Duplicate laser index. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDCONFIGURATIONSCHEMA 1049 /** Invalid configuration schema. */
#define LIBMCDRIVER_SCANLAB_ERROR_NOVERSIONDEFINITION 1050 /** No version definition. */
#define LIBMCDRIVER_SCANLAB_ERROR_DUPLICATECONFIGURATIONPRESETNAME 1051 /** Duplicate configuration preset name. */
#define LIBMCDRIVER_SCANLAB_ERROR_OIEPIDVARIABLEOUTOFBOUNDS 1052 /** OIE PID Variable out of bounds. */
#define LIBMCDRIVER_SCANLAB_ERROR_TIMELAGMUSTBEAMULTIPLEOF10 1053 /** Timelag must be a multiple of 10 microseconds. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDENCODERSCALINGINX 1054 /** Invalid Encoder Scaling in X */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDENCODERSCALINGINY 1055 /** Invalid Encoder Scaling in Y */
#define LIBMCDRIVER_SCANLAB_ERROR_ONTHEFLYMARKINGERROR 1056 /** On the fly marking error */
#define LIBMCDRIVER_SCANLAB_ERROR_MARKONTHEFLYISDISABLED 1057 /** Mark on the fly is disabled */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERFIELDCOORDINATES 1058 /** Invalid laser field coordinates */
#define LIBMCDRIVER_SCANLAB_ERROR_NOLASERFIELDSET 1059 /** No laser field has been set. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDFREEVARIABLEINDEX 1060 /** Invalid free variable index. */
#define LIBMCDRIVER_SCANLAB_ERROR_DUPLICATELASERPOWERCALIBRATIONSETPOINT 1061 /** Duplicate laser power calibration set point. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOWERCALIBRATIONSETPOINT 1062 /** Invalid power calibration set point. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOWERCALIBRATIONOUTPUTSCALING 1063 /** Invalid power calibration output scaling. */
#define LIBMCDRIVER_SCANLAB_ERROR_POWERCALIBRATIONLOOKUPFAILED 1064 /** Power calibration lookup failed. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDMODULATIONCALLBACK 1065 /** Invalid modulation callback. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDSUBDIVISIONTHRESHOLD 1066 /** Invalid subdivision threshold. */
#define LIBMCDRIVER_SCANLAB_ERROR_MULTIPLELASERPORTSNOTCOMPATIBLEWITHPID 1067 /** Multiple laser ports are not compatible with PID control. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIEMEASUREMENTTAG 1068 /** Invalid OIE measurement tag. */
#define LIBMCDRIVER_SCANLAB_ERROR_RS232READTIMEOUT 1069 /** RS232 read timeout. */
#define LIBMCDRIVER_SCANLAB_ERROR_RS232READLINEOVERRUN 1070 /** RS232 read line overrun. */
#define LIBMCDRIVER_SCANLAB_ERROR_RS232RINGBUFFEROVERRUN 1071 /** RS232 ring buffer overrun. */
#define LIBMCDRIVER_SCANLAB_ERROR_NOSCANAHEADOPTION 1072 /** No Scanahead option. */
#define LIBMCDRIVER_SCANLAB_ERROR_NOEXCELLISCAN 1073 /** No Excelli Scan. */
#define LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADLISTISACTIVE 1074 /** Scanahead - list is active. */
#define LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADPARAMETERERROR 1075 /** Scanahead parameter error. */
#define LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADSCALINGERROR 1076 /** Scanahead scaling error. */
#define LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADMISSINGRTCRESPONSE 1077 /** Scanahead missing rtc response. */
#define LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADPCIERROR 1078 /** Scanahead PCI error. */
#define LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADUNKNOWNERROR 1079 /** Scanahead unknown error. */
#define LIBMCDRIVER_SCANLAB_ERROR_PORTNUMBERISNOTDIGITAL 1082 /** Port number is not digital. */
#define LIBMCDRIVER_SCANLAB_ERROR_PORTNUMBERISNOTANALOG 1083 /** Port number is not analog. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIECHANNELSIZE 1084 /** Invalid OIE Channel size. */
#define LIBMCDRIVER_SCANLAB_ERROR_INTERNALACQUISITIONERROR 1085 /** Internal Acquisition Error. */
#define LIBMCDRIVER_SCANLAB_ERROR_COULDNOTDETERMINESERIALNUMBER 1086 /** Could not determine serial number. */
#define LIBMCDRIVER_SCANLAB_ERROR_COULDNOTASSIGNETHERNETCARD 1087 /** Could not assign ethernet card. */
#define LIBMCDRIVER_SCANLAB_ERROR_MISSINGFIRMWAREDATA 1088 /** Missing Firmware Data. */
#define LIBMCDRIVER_SCANLAB_ERROR_MISSINGFPGADATA 1089 /** Missing FPGA Data. */
#define LIBMCDRIVER_SCANLAB_ERROR_MISSINGAUXILIARYDATA 1090 /** Missing Auxiliary Data. */
#define LIBMCDRIVER_SCANLAB_ERROR_MISSINGFIRMWAREINITIZATIONDATA 1091 /** Missing Firmware Initialisation Data. */
#define LIBMCDRIVER_SCANLAB_ERROR_NOCARDFOUNDATIPADDRESS 1092 /** No Card found at IP Address. */
#define LIBMCDRIVER_SCANLAB_ERROR_NOCARDFOUNDATINIPRANGE 1093 /** No Card found in IP Range. */
#define LIBMCDRIVER_SCANLAB_ERROR_COULDNOTINITIALISERTCCARD 1094 /** Could not initialize RTC Card. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELNAME 1095 /** Invalid Channel Name. */
#define LIBMCDRIVER_SCANLAB_ERROR_EMPTYCHANNELNAME 1096 /** Empty Channel Name. */
#define LIBMCDRIVER_SCANLAB_ERROR_CANNOTADDCHANNELDURINGRECORDING 1097 /** Cannot add channel during recording. */
#define LIBMCDRIVER_SCANLAB_ERROR_DUPLICATECHANNELNAME 1098 /** Duplicate channel name. */
#define LIBMCDRIVER_SCANLAB_ERROR_NORECORDINGCHANNELAVAILABLE 1099 /** No recording channel available. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELID 1100 /** Invalid Channel ID. */
#define LIBMCDRIVER_SCANLAB_ERROR_CHANNELTYPECANNOTBEUNDEFINED 1101 /** Channel Type cannot be undefined. */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHUNKSIZE 1102 /** Invalid Chunk Size */
#define LIBMCDRIVER_SCANLAB_ERROR_CHANNELNOTFOUND 1103 /** Channel not found */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDRECORDINDEX 1104 /** Invalid record index */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHUNKINDEX 1105 /** Invalid chunk index */
#define LIBMCDRIVER_SCANLAB_ERROR_CHUNKENTRYINDEXOUTOFBOUNDS 1106 /** Chunk entry index out of bounds */
#define LIBMCDRIVER_SCANLAB_ERROR_INVALIDDATARECORDINGINTERVAL 1107 /** Invalid data recording interval */
#define LIBMCDRIVER_SCANLAB_ERROR_DATARECORDINGOVERFLOW 1108 /** Data recording overflow */
#define LIBMCDRIVER_SCANLAB_ERROR_DATARECORDINGUNDERFLOW 1109 /** Data recording underflow */
#define LIBMCDRIVER_SCANLAB_ERROR_DATABUFFERISFULL 1110 /** Data buffer is full */
#define LIBMCDRIVER_SCANLAB_ERROR_DATABUFFERREADEMPTY 1111 /** Data buffer read empty */
#define LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDRECORDING 1112 /** Could not find recording. */

/*************************************************************************************************************************
 Error strings for LibMCDriver_ScanLab
**************************************************************************************************************************/

inline const char * LIBMCDRIVER_SCANLAB_GETERRORSTRING (LibMCDriver_ScanLabResult nErrorCode) {
  switch (nErrorCode) {
    case LIBMCDRIVER_SCANLAB_SUCCESS: return "no error";
    case LIBMCDRIVER_SCANLAB_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST: return "a type cast failed";
    case LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
    case LIBMCDRIVER_SCANLAB_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
    case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
    case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
    case LIBMCDRIVER_SCANLAB_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
    case LIBMCDRIVER_SCANLAB_ERROR_DRIVERERROR: return "a driver error occured";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_NO_PCIE_CARD_FOUND: return "RTC6: No PCIE Card was found";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ACCESS_DENIED: return "RTC6: Access Denied";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_SEND_ERROR: return "RTC6: Send Error";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TIMEOUT: return "RTC6: Timeout";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_PARAM_ERROR: return "RTC6: Param Error";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_BUSY: return "RTC6: Busy";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_REJECTED: return "RTC6: Rejected";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_IGNORED: return "RTC6: Ignored";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERSION_MISMATCH: return "RTC6: Version Mismatch";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERIFY_ERROR: return "RTC6: Verify Error";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TYPE_REJECTED: return "RTC6: Type Rejected";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_OUT_OF_MEMORY: return "RTC6: Out of Memory";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_FLASH_ERROR: return "RTC6: Flash Error";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ETH_ERROR: return "RTC6: Eth Error";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_CONFIG_ERROR: return "RTC6: Config Error";
    case LIBMCDRIVER_SCANLAB_ERROR_RTC6_UNKNOWN_ERROR: return "RTC6: Unknown Error";
    case LIBMCDRIVER_SCANLAB_ERROR_RTCOPEN_FAILED: return "RTC open failed";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCPROC: return "Invalid RTC proc";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDIPADDRESS: return "Invalid IP Address";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNETMASK: return "Invalid NetMask";
    case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYACQUIRED: return "Card already acquired";
    case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTFOUND: return "Card not found";
    case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADPROGRAMFILE: return "Could not load program file";
    case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADCORRECTIONFILE: return "Could not load correction file";
    case LIBMCDRIVER_SCANLAB_ERROR_DELAYSMUSTBEMULTIPLEOF10: return "Delays must be a multiple of 10 microseconds";
    case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKNOTLOADED: return "Scanlab RTC has not been loaded";
    case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKALREADYLOADED: return "Scanlab RTC has already been loaded";
    case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYINITIALIZED: return "Scanlab RTC card is already initialized";
    case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTINITIALIZED: return "Scanlab RTC card is not initialized";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOINTCOUNT: return "Invalid point count";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDMAXLASERPOWER: return "Invalid max laser power.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERDELAY: return "Invalid laser delay.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERDELAY: return "Invalid scanner delay.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANLABSDK: return "Invalid SCANLAB SDK.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIESIGNALBUFFERARRAY: return "Invalid OIE Signal buffer array.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGTIMELAG: return "Invalid Skywriting Timelag.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGLASERONSHIFT: return "Invalid Skywriting Laser On Shift.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPREV: return "Invalid Skywriting N Prev.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPOST: return "Invalid Skywriting N Post.";
    case LIBMCDRIVER_SCANLAB_ERROR_OIEHASNOTBEENINITIALIZED: return "OIE has not been initialized.";
    case LIBMCDRIVER_SCANLAB_ERROR_UNSUPPORTEDOIEOPERATIONMODE: return "Unsupported OIE Operation Mode.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCCORRECTIONDATA: return "Invalid RTC Correction data.";
    case LIBMCDRIVER_SCANLAB_ERROR_CONFIGURATIONPRESETNOTFOUND: return "Configuration preset not found.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERCOUNT: return "Invalid scanner count.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERINDEX: return "Invalid scanner index.";
    case LIBMCDRIVER_SCANLAB_ERROR_LASERINDEXHASNOASSIGNEDSCANNER: return "Laser index has no assigned scanner.";
    case LIBMCDRIVER_SCANLAB_ERROR_LASERINDEXNOTFOUND: return "Laser index not found.";
    case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATELASERINDEX: return "Duplicate laser index.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCONFIGURATIONSCHEMA: return "Invalid configuration schema.";
    case LIBMCDRIVER_SCANLAB_ERROR_NOVERSIONDEFINITION: return "No version definition.";
    case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATECONFIGURATIONPRESETNAME: return "Duplicate configuration preset name.";
    case LIBMCDRIVER_SCANLAB_ERROR_OIEPIDVARIABLEOUTOFBOUNDS: return "OIE PID Variable out of bounds.";
    case LIBMCDRIVER_SCANLAB_ERROR_TIMELAGMUSTBEAMULTIPLEOF10: return "Timelag must be a multiple of 10 microseconds.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDENCODERSCALINGINX: return "Invalid Encoder Scaling in X";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDENCODERSCALINGINY: return "Invalid Encoder Scaling in Y";
    case LIBMCDRIVER_SCANLAB_ERROR_ONTHEFLYMARKINGERROR: return "On the fly marking error";
    case LIBMCDRIVER_SCANLAB_ERROR_MARKONTHEFLYISDISABLED: return "Mark on the fly is disabled";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERFIELDCOORDINATES: return "Invalid laser field coordinates";
    case LIBMCDRIVER_SCANLAB_ERROR_NOLASERFIELDSET: return "No laser field has been set.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDFREEVARIABLEINDEX: return "Invalid free variable index.";
    case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATELASERPOWERCALIBRATIONSETPOINT: return "Duplicate laser power calibration set point.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOWERCALIBRATIONSETPOINT: return "Invalid power calibration set point.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOWERCALIBRATIONOUTPUTSCALING: return "Invalid power calibration output scaling.";
    case LIBMCDRIVER_SCANLAB_ERROR_POWERCALIBRATIONLOOKUPFAILED: return "Power calibration lookup failed.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDMODULATIONCALLBACK: return "Invalid modulation callback.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSUBDIVISIONTHRESHOLD: return "Invalid subdivision threshold.";
    case LIBMCDRIVER_SCANLAB_ERROR_MULTIPLELASERPORTSNOTCOMPATIBLEWITHPID: return "Multiple laser ports are not compatible with PID control.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIEMEASUREMENTTAG: return "Invalid OIE measurement tag.";
    case LIBMCDRIVER_SCANLAB_ERROR_RS232READTIMEOUT: return "RS232 read timeout.";
    case LIBMCDRIVER_SCANLAB_ERROR_RS232READLINEOVERRUN: return "RS232 read line overrun.";
    case LIBMCDRIVER_SCANLAB_ERROR_RS232RINGBUFFEROVERRUN: return "RS232 ring buffer overrun.";
    case LIBMCDRIVER_SCANLAB_ERROR_NOSCANAHEADOPTION: return "No Scanahead option.";
    case LIBMCDRIVER_SCANLAB_ERROR_NOEXCELLISCAN: return "No Excelli Scan.";
    case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADLISTISACTIVE: return "Scanahead - list is active.";
    case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADPARAMETERERROR: return "Scanahead parameter error.";
    case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADSCALINGERROR: return "Scanahead scaling error.";
    case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADMISSINGRTCRESPONSE: return "Scanahead missing rtc response.";
    case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADPCIERROR: return "Scanahead PCI error.";
    case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADUNKNOWNERROR: return "Scanahead unknown error.";
    case LIBMCDRIVER_SCANLAB_ERROR_PORTNUMBERISNOTDIGITAL: return "Port number is not digital.";
    case LIBMCDRIVER_SCANLAB_ERROR_PORTNUMBERISNOTANALOG: return "Port number is not analog.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIECHANNELSIZE: return "Invalid OIE Channel size.";
    case LIBMCDRIVER_SCANLAB_ERROR_INTERNALACQUISITIONERROR: return "Internal Acquisition Error.";
    case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTDETERMINESERIALNUMBER: return "Could not determine serial number.";
    case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTASSIGNETHERNETCARD: return "Could not assign ethernet card.";
    case LIBMCDRIVER_SCANLAB_ERROR_MISSINGFIRMWAREDATA: return "Missing Firmware Data.";
    case LIBMCDRIVER_SCANLAB_ERROR_MISSINGFPGADATA: return "Missing FPGA Data.";
    case LIBMCDRIVER_SCANLAB_ERROR_MISSINGAUXILIARYDATA: return "Missing Auxiliary Data.";
    case LIBMCDRIVER_SCANLAB_ERROR_MISSINGFIRMWAREINITIZATIONDATA: return "Missing Firmware Initialisation Data.";
    case LIBMCDRIVER_SCANLAB_ERROR_NOCARDFOUNDATIPADDRESS: return "No Card found at IP Address.";
    case LIBMCDRIVER_SCANLAB_ERROR_NOCARDFOUNDATINIPRANGE: return "No Card found in IP Range.";
    case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTINITIALISERTCCARD: return "Could not initialize RTC Card.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELNAME: return "Invalid Channel Name.";
    case LIBMCDRIVER_SCANLAB_ERROR_EMPTYCHANNELNAME: return "Empty Channel Name.";
    case LIBMCDRIVER_SCANLAB_ERROR_CANNOTADDCHANNELDURINGRECORDING: return "Cannot add channel during recording.";
    case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATECHANNELNAME: return "Duplicate channel name.";
    case LIBMCDRIVER_SCANLAB_ERROR_NORECORDINGCHANNELAVAILABLE: return "No recording channel available.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELID: return "Invalid Channel ID.";
    case LIBMCDRIVER_SCANLAB_ERROR_CHANNELTYPECANNOTBEUNDEFINED: return "Channel Type cannot be undefined.";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHUNKSIZE: return "Invalid Chunk Size";
    case LIBMCDRIVER_SCANLAB_ERROR_CHANNELNOTFOUND: return "Channel not found";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRECORDINDEX: return "Invalid record index";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHUNKINDEX: return "Invalid chunk index";
    case LIBMCDRIVER_SCANLAB_ERROR_CHUNKENTRYINDEXOUTOFBOUNDS: return "Chunk entry index out of bounds";
    case LIBMCDRIVER_SCANLAB_ERROR_INVALIDDATARECORDINGINTERVAL: return "Invalid data recording interval";
    case LIBMCDRIVER_SCANLAB_ERROR_DATARECORDINGOVERFLOW: return "Data recording overflow";
    case LIBMCDRIVER_SCANLAB_ERROR_DATARECORDINGUNDERFLOW: return "Data recording underflow";
    case LIBMCDRIVER_SCANLAB_ERROR_DATABUFFERISFULL: return "Data buffer is full";
    case LIBMCDRIVER_SCANLAB_ERROR_DATABUFFERREADEMPTY: return "Data buffer read empty";
    case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDRECORDING: return "Could not find recording.";
    default: return "unknown error";
  }
}

/*************************************************************************************************************************
 Declaration of handle classes 
**************************************************************************************************************************/

typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_Base;
typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_Driver;
typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_UARTConnection;
typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_RTCJob;
typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_RTCRecording;
typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_RTCContext;
typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_RTCSelector;
typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_Driver_ScanLab;
typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_Driver_ScanLab_RTC6;
typedef LibMCDriver_ScanLabHandle LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN;

namespace LibMCDriver_ScanLab {

  /*************************************************************************************************************************
   Declaration of enums
  **************************************************************************************************************************/
  
  enum class eLaserMode : LibMCDriver_ScanLab_int32 {
    CO2 = 0,
    YAG1 = 1,
    YAG2 = 2,
    YAG3 = 3,
    LaserMode4 = 4,
    YAG5 = 5,
    LaserMode6 = 6
  };
  
  enum class eLaserPort : LibMCDriver_ScanLab_int32 {
    Port8bitDigital = 1,
    Port16bitDigital = 2,
    Port12BitAnalog1 = 3,
    Port12BitAnalog2 = 4,
    Port12BitAnalog1andAnalog2 = 5
  };
  
  enum class eOIEOperationMode : LibMCDriver_ScanLab_int32 {
    OIENotInitialized = 0,
    OIEVersion2 = 1,
    OIEVersion3Compatibility = 2,
    OIEVersion3 = 3
  };
  
  /**
  * enum class eRTCChannelType - Channel type to record. See RTC Documentation set_trigger for details.
  */
  enum class eRTCChannelType : LibMCDriver_ScanLab_int32 {
    ChannelUndefined = 0, /** Undefined or invalid channel */
    ChannelCurrentXRaw = 1, /** Raw X Value of the Scan Head (RTC Channel 1, StatusAX) */
    ChannelCurrentYRaw = 2, /** Raw Y Value of the Scan Head (RTC Channel 2, StatusAY) */
    ChannelCurrentZRaw = 4, /** Raw Z Value of the Scan Head (RTC Channel 4, StatusBX) */
    ChannelTargetXRaw = 7, /** Target X Value of the Scan Head (RTC Channel 7, SampleX) */
    ChannelTargetYRaw = 8, /** Target Y Value of the Scan Head (RTC Channel 8, SampleY) */
    ChannelTargetZRaw = 9, /** Target Z Value of the Scan Head (RTC Channel 9, SampleZ) */
    ChannelAutoLaserControlMode = 24, /** Control Parameter of AutoLaserControl (RTC Channel 24) */
    ChannelVectorControlMode = 31, /** Control Parameter of VectorControl (RTC Channel 31) */
    ChannelDefocus = 32, /** Defocus setting (RTC Channel 32) */
    ChannelAnalogOut1 = 33, /** Analog Out 1 Signal (RTC Channel 33) */
    ChannelAnalogOut2 = 34, /** Analog Out 2 Signal (RTC Channel 34) */
    ChannelDigitalOut16Bit = 35, /** 16 Bit Digital Out Signal (RTC Channel 35) */
    ChannelDigitalOut8Bit = 36, /** 8 Bit Digital Out Signal (RTC Channel 36) */
    ChannelPulseLength = 37, /** Pulse length of laser control (RTC Channel 37) */
    ChannelHalfPeriod = 38, /** Half period of laser control (RTC Channel 38) */
    ChannelFreeVariable0 = 39, /** Free Variable 0 (RTC Channel 39) */
    ChannelFreeVariable1 = 40, /** Free Variable 1 (RTC Channel 40) */
    ChannelFreeVariable2 = 41, /** Free Variable 2 (RTC Channel 41) */
    ChannelFreeVariable3 = 42, /** Free Variable 3 (RTC Channel 42) */
    ChannelEncoder0 = 43, /** Counter value of Encoder 0 (RTC Channel 43) */
    ChannelEncoder1 = 44, /** Counter value of Encoder 1 (RTC Channel 44) */
    ChannelMarkSpeed = 45, /** Laser Mark Speed in Bits/ms (RTC Channel 45) */
    ChannelDigitalIn16Bit = 46, /** 16bit Digital In Channel of EXTENSION 1 (RTC Channel 46) */
    ChannelFreeVariable4 = 48, /** Free Variable 4 (RTC Channel 48) */
    ChannelFreeVariable5 = 49, /** Free Variable 5 (RTC Channel 49) */
    ChannelFreeVariable6 = 50, /** Free Variable 6 (RTC Channel 50) */
    ChannelFreeVariable7 = 51, /** Free Variable 7 (RTC Channel 51) */
    ChannelTimeStamp = 52, /** RTC Time Stamp (RTC Channel 52) */
    ChannelWobbleAmplitude = 53, /** Wobble Amplitude (RTC Channel 53) */
    ChannelAnalogIn = 54, /** Analog Input Value (RTC Channel 54) */
    ChannelScaledEncoderX = 55, /** Scaled Encoder Value for X Axis (RTC Channel 55) */
    ChannelScaledEncoderY = 56, /** Scaled Encoder Value for Y Axis (RTC Channel 56) */
    ChannelScaledEncoderZ = 57, /** Scaled Encoder Value for Z Axis (RTC Channel 57) */
    ChannelRS232 = 58, /** RS232 Channel Value (RTC Channel 58) */
    ChannelLaserOn = 100, /** Laser On Value (RTC Channel 0, LASERON) */
    ChannelCurrentXBacktransformed = 101, /** Current X Value of the Scan Head, Backtransformed via the correction file (RTC Channel 1, StatusAX) */
    ChannelCurrentYBacktransformed = 102, /** Current Y Value of the Scan Head, Backtransformed via the correction file (RTC Channel 2, StatusAY) */
    ChannelCurrentZBacktransformed = 104, /** Current Z Value of the Scan Head, Backtransformed via the correction file (RTC Channel 4, StatusBX) */
    ChannelTargetXBacktransformed = 107, /** Target X Value of the Scan Head, Backtransformed via the correction file (RTC Channel 7, SampleX) */
    ChannelTargetYBacktransformed = 108, /** Target Y Value of the Scan Head, Backtransformed via the correction file (RTC Channel 8, SampleY) */
    ChannelTargetZBacktransformed = 109 /** Target Z Value of the Scan Head, Backtransformed via the correction file (RTC Channel 9, SampleZ) */
  };
  
  enum class eOIERecordingMode : LibMCDriver_ScanLab_int32 {
    OIERecordingDisabled = 0, /** OIE shall not record anything. */
    OIEContinuousMeasurement = 1, /** OIE shall continuously record, even if the laser is off. OIE must be enabled before drawing a layer. */
    OIEEnableAndContinuousMeasurement = 2, /** OIE shall continuously record, even if the laser is off. OIE will be specifically enabled for the layer. */
    OIELaserActiveMeasurement = 3, /** OIE shall record when the laser is on. OIE must be enabled before drawing a layer. */
    OIEEnableAndLaserActiveMeasurement = 4 /** OIE shall record when the laser is on. OIE will be specifically enabled for the layer. */
  };
  
  /*************************************************************************************************************************
   Declaration of structs
  **************************************************************************************************************************/
  
  #pragma pack (1)
  
  typedef struct sPoint2D {
      LibMCDriver_ScanLab_single m_X;
      LibMCDriver_ScanLab_single m_Y;
  } sPoint2D;
  
  typedef struct sHatch2D {
      LibMCDriver_ScanLab_single m_X1;
      LibMCDriver_ScanLab_single m_Y1;
      LibMCDriver_ScanLab_single m_X2;
      LibMCDriver_ScanLab_single m_Y2;
  } sHatch2D;
  
  typedef struct sLaserCalibrationPoint {
      LibMCDriver_ScanLab_double m_PowerSetPointInPercent;
      LibMCDriver_ScanLab_double m_PowerOffsetInPercent;
      LibMCDriver_ScanLab_double m_PowerOutputScaling;
  } sLaserCalibrationPoint;
  
  #pragma pack ()
  
  /*************************************************************************************************************************
   Declaration of function pointers 
  **************************************************************************************************************************/
  
  /**
  * SpatialPowerModulationCallback - A callback function to modulate laser power depending on the position of the laser.
  *
  * @param[in] dStartX - The X start position of the marking in mm
  * @param[in] dStartY - The Y start position of the marking in mm
  * @param[in] dTargetX - The X target position of the marking in mm
  * @param[in] dTargetY - The Y target position of the marking in mm
  * @param[in] dLaserPowerInPercent - The nominal laser power to be used in percent.
  * @param[in] nModulationType - A type ID from the build file that specifies the modulation type to use.
  * @param[in] pUserData - Userdata that is passed to the callback function
  * @param[out] pAdjustedLaserPowerInPercent - Returns the adjusted laser power in percent.
  */
  typedef void(*SpatialPowerModulationCallback)(LibMCDriver_ScanLab_double, LibMCDriver_ScanLab_double, LibMCDriver_ScanLab_double, LibMCDriver_ScanLab_double, LibMCDriver_ScanLab_double, LibMCDriver_ScanLab_int32, LibMCDriver_ScanLab_pvoid, LibMCDriver_ScanLab_double *);
  
} // namespace LibMCDriver_ScanLab;

// define legacy C-names for enums, structs and function types
typedef LibMCDriver_ScanLab::eLaserMode eLibMCDriver_ScanLabLaserMode;
typedef LibMCDriver_ScanLab::eLaserPort eLibMCDriver_ScanLabLaserPort;
typedef LibMCDriver_ScanLab::eOIEOperationMode eLibMCDriver_ScanLabOIEOperationMode;
typedef LibMCDriver_ScanLab::eRTCChannelType eLibMCDriver_ScanLabRTCChannelType;
typedef LibMCDriver_ScanLab::eOIERecordingMode eLibMCDriver_ScanLabOIERecordingMode;
typedef LibMCDriver_ScanLab::sPoint2D sLibMCDriver_ScanLabPoint2D;
typedef LibMCDriver_ScanLab::sHatch2D sLibMCDriver_ScanLabHatch2D;
typedef LibMCDriver_ScanLab::sLaserCalibrationPoint sLibMCDriver_ScanLabLaserCalibrationPoint;
typedef LibMCDriver_ScanLab::SpatialPowerModulationCallback LibMCDriver_ScanLabSpatialPowerModulationCallback;

#endif // __LIBMCDRIVER_SCANLAB_TYPES_HEADER_CPP
