/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver ScanLab RTC

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_SCANLAB_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_SCANLAB_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_scanlab_types.hpp"
#include "libmcdriver_scanlab_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_ScanLab {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CUARTConnection;
class CRTCJob;
class CRTCRecording;
class CGPIOSequence;
class CNLightAFXProfileSelector;
class CRTCContext;
class CRTCSelector;
class CDriver_ScanLab;
class CDriver_ScanLab_RTC6;
class CDriver_ScanLab_RTC6xN;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_ScanLabWrapper;
typedef CBase CLibMCDriver_ScanLabBase;
typedef CDriver CLibMCDriver_ScanLabDriver;
typedef CUARTConnection CLibMCDriver_ScanLabUARTConnection;
typedef CRTCJob CLibMCDriver_ScanLabRTCJob;
typedef CRTCRecording CLibMCDriver_ScanLabRTCRecording;
typedef CGPIOSequence CLibMCDriver_ScanLabGPIOSequence;
typedef CNLightAFXProfileSelector CLibMCDriver_ScanLabNLightAFXProfileSelector;
typedef CRTCContext CLibMCDriver_ScanLabRTCContext;
typedef CRTCSelector CLibMCDriver_ScanLabRTCSelector;
typedef CDriver_ScanLab CLibMCDriver_ScanLabDriver_ScanLab;
typedef CDriver_ScanLab_RTC6 CLibMCDriver_ScanLabDriver_ScanLab_RTC6;
typedef CDriver_ScanLab_RTC6xN CLibMCDriver_ScanLabDriver_ScanLab_RTC6xN;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CUARTConnection> PUARTConnection;
typedef std::shared_ptr<CRTCJob> PRTCJob;
typedef std::shared_ptr<CRTCRecording> PRTCRecording;
typedef std::shared_ptr<CGPIOSequence> PGPIOSequence;
typedef std::shared_ptr<CNLightAFXProfileSelector> PNLightAFXProfileSelector;
typedef std::shared_ptr<CRTCContext> PRTCContext;
typedef std::shared_ptr<CRTCSelector> PRTCSelector;
typedef std::shared_ptr<CDriver_ScanLab> PDriver_ScanLab;
typedef std::shared_ptr<CDriver_ScanLab_RTC6> PDriver_ScanLab_RTC6;
typedef std::shared_ptr<CDriver_ScanLab_RTC6xN> PDriver_ScanLab_RTC6xN;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_ScanLabWrapper;
typedef PBase PLibMCDriver_ScanLabBase;
typedef PDriver PLibMCDriver_ScanLabDriver;
typedef PUARTConnection PLibMCDriver_ScanLabUARTConnection;
typedef PRTCJob PLibMCDriver_ScanLabRTCJob;
typedef PRTCRecording PLibMCDriver_ScanLabRTCRecording;
typedef PGPIOSequence PLibMCDriver_ScanLabGPIOSequence;
typedef PNLightAFXProfileSelector PLibMCDriver_ScanLabNLightAFXProfileSelector;
typedef PRTCContext PLibMCDriver_ScanLabRTCContext;
typedef PRTCSelector PLibMCDriver_ScanLabRTCSelector;
typedef PDriver_ScanLab PLibMCDriver_ScanLabDriver_ScanLab;
typedef PDriver_ScanLab_RTC6 PLibMCDriver_ScanLabDriver_ScanLab_RTC6;
typedef PDriver_ScanLab_RTC6xN PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_ScanLabHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_ScanLabException 
**************************************************************************************************************************/
class ELibMCDriver_ScanLabException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_ScanLabResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_ScanLabException(LibMCDriver_ScanLabResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_ScanLabResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLAB_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_SCANLAB_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_SCANLAB_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_SCANLAB_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_SCANLAB_ERROR_DRIVERERROR: return "DRIVERERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_NO_PCIE_CARD_FOUND: return "RTC6_NO_PCIE_CARD_FOUND";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ACCESS_DENIED: return "RTC6_ACCESS_DENIED";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_SEND_ERROR: return "RTC6_SEND_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TIMEOUT: return "RTC6_TIMEOUT";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_PARAM_ERROR: return "RTC6_PARAM_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_BUSY: return "RTC6_BUSY";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_REJECTED: return "RTC6_REJECTED";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_IGNORED: return "RTC6_IGNORED";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERSION_MISMATCH: return "RTC6_VERSION_MISMATCH";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERIFY_ERROR: return "RTC6_VERIFY_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TYPE_REJECTED: return "RTC6_TYPE_REJECTED";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_OUT_OF_MEMORY: return "RTC6_OUT_OF_MEMORY";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_FLASH_ERROR: return "RTC6_FLASH_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ETH_ERROR: return "RTC6_ETH_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_CONFIG_ERROR: return "RTC6_CONFIG_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_UNKNOWN_ERROR: return "RTC6_UNKNOWN_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTCOPEN_FAILED: return "RTCOPEN_FAILED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCPROC: return "INVALIDRTCPROC";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDIPADDRESS: return "INVALIDIPADDRESS";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNETMASK: return "INVALIDNETMASK";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYACQUIRED: return "CARDALREADYACQUIRED";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTFOUND: return "CARDNOTFOUND";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADPROGRAMFILE: return "COULDNOTLOADPROGRAMFILE";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADCORRECTIONFILE: return "COULDNOTLOADCORRECTIONFILE";
			case LIBMCDRIVER_SCANLAB_ERROR_DELAYSMUSTBEMULTIPLEOF10: return "DELAYSMUSTBEMULTIPLEOF10";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKNOTLOADED: return "SCANLABSDKNOTLOADED";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKALREADYLOADED: return "SCANLABSDKALREADYLOADED";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYINITIALIZED: return "CARDALREADYINITIALIZED";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTINITIALIZED: return "CARDNOTINITIALIZED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOINTCOUNT: return "INVALIDPOINTCOUNT";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDMAXLASERPOWER: return "INVALIDMAXLASERPOWER";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERDELAY: return "INVALIDLASERDELAY";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERDELAY: return "INVALIDSCANNERDELAY";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANLABSDK: return "INVALIDSCANLABSDK";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIESIGNALBUFFERARRAY: return "INVALIDOIESIGNALBUFFERARRAY";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGTIMELAG: return "INVALIDSKYWRITINGTIMELAG";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGLASERONSHIFT: return "INVALIDSKYWRITINGLASERONSHIFT";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPREV: return "INVALIDSKYWRITINGNPREV";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPOST: return "INVALIDSKYWRITINGNPOST";
			case LIBMCDRIVER_SCANLAB_ERROR_OIEHASNOTBEENINITIALIZED: return "OIEHASNOTBEENINITIALIZED";
			case LIBMCDRIVER_SCANLAB_ERROR_UNSUPPORTEDOIEOPERATIONMODE: return "UNSUPPORTEDOIEOPERATIONMODE";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCCORRECTIONDATA: return "INVALIDRTCCORRECTIONDATA";
			case LIBMCDRIVER_SCANLAB_ERROR_CONFIGURATIONPRESETNOTFOUND: return "CONFIGURATIONPRESETNOTFOUND";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERCOUNT: return "INVALIDSCANNERCOUNT";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERINDEX: return "INVALIDSCANNERINDEX";
			case LIBMCDRIVER_SCANLAB_ERROR_LASERINDEXHASNOASSIGNEDSCANNER: return "LASERINDEXHASNOASSIGNEDSCANNER";
			case LIBMCDRIVER_SCANLAB_ERROR_LASERINDEXNOTFOUND: return "LASERINDEXNOTFOUND";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATELASERINDEX: return "DUPLICATELASERINDEX";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCONFIGURATIONSCHEMA: return "INVALIDCONFIGURATIONSCHEMA";
			case LIBMCDRIVER_SCANLAB_ERROR_NOVERSIONDEFINITION: return "NOVERSIONDEFINITION";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATECONFIGURATIONPRESETNAME: return "DUPLICATECONFIGURATIONPRESETNAME";
			case LIBMCDRIVER_SCANLAB_ERROR_OIEPIDVARIABLEOUTOFBOUNDS: return "OIEPIDVARIABLEOUTOFBOUNDS";
			case LIBMCDRIVER_SCANLAB_ERROR_TIMELAGMUSTBEAMULTIPLEOF10: return "TIMELAGMUSTBEAMULTIPLEOF10";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDENCODERSCALINGINX: return "INVALIDENCODERSCALINGINX";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDENCODERSCALINGINY: return "INVALIDENCODERSCALINGINY";
			case LIBMCDRIVER_SCANLAB_ERROR_ONTHEFLYMARKINGERROR: return "ONTHEFLYMARKINGERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_MARKONTHEFLYISDISABLED: return "MARKONTHEFLYISDISABLED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERFIELDCOORDINATES: return "INVALIDLASERFIELDCOORDINATES";
			case LIBMCDRIVER_SCANLAB_ERROR_NOLASERFIELDSET: return "NOLASERFIELDSET";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDFREEVARIABLEINDEX: return "INVALIDFREEVARIABLEINDEX";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATELASERPOWERCALIBRATIONSETPOINT: return "DUPLICATELASERPOWERCALIBRATIONSETPOINT";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOWERCALIBRATIONSETPOINT: return "INVALIDPOWERCALIBRATIONSETPOINT";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOWERCALIBRATIONOUTPUTSCALING: return "INVALIDPOWERCALIBRATIONOUTPUTSCALING";
			case LIBMCDRIVER_SCANLAB_ERROR_POWERCALIBRATIONLOOKUPFAILED: return "POWERCALIBRATIONLOOKUPFAILED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDMODULATIONCALLBACK: return "INVALIDMODULATIONCALLBACK";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSUBDIVISIONTHRESHOLD: return "INVALIDSUBDIVISIONTHRESHOLD";
			case LIBMCDRIVER_SCANLAB_ERROR_MULTIPLELASERPORTSNOTCOMPATIBLEWITHPID: return "MULTIPLELASERPORTSNOTCOMPATIBLEWITHPID";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIEMEASUREMENTTAG: return "INVALIDOIEMEASUREMENTTAG";
			case LIBMCDRIVER_SCANLAB_ERROR_RS232READTIMEOUT: return "RS232READTIMEOUT";
			case LIBMCDRIVER_SCANLAB_ERROR_RS232READLINEOVERRUN: return "RS232READLINEOVERRUN";
			case LIBMCDRIVER_SCANLAB_ERROR_RS232RINGBUFFEROVERRUN: return "RS232RINGBUFFEROVERRUN";
			case LIBMCDRIVER_SCANLAB_ERROR_NOSCANAHEADOPTION: return "NOSCANAHEADOPTION";
			case LIBMCDRIVER_SCANLAB_ERROR_NOEXCELLISCAN: return "NOEXCELLISCAN";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADLISTISACTIVE: return "SCANAHEADLISTISACTIVE";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADPARAMETERERROR: return "SCANAHEADPARAMETERERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADSCALINGERROR: return "SCANAHEADSCALINGERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADMISSINGRTCRESPONSE: return "SCANAHEADMISSINGRTCRESPONSE";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADPCIERROR: return "SCANAHEADPCIERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADUNKNOWNERROR: return "SCANAHEADUNKNOWNERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_PORTNUMBERISNOTDIGITAL: return "PORTNUMBERISNOTDIGITAL";
			case LIBMCDRIVER_SCANLAB_ERROR_PORTNUMBERISNOTANALOG: return "PORTNUMBERISNOTANALOG";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIECHANNELSIZE: return "INVALIDOIECHANNELSIZE";
			case LIBMCDRIVER_SCANLAB_ERROR_INTERNALACQUISITIONERROR: return "INTERNALACQUISITIONERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTDETERMINESERIALNUMBER: return "COULDNOTDETERMINESERIALNUMBER";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTASSIGNETHERNETCARD: return "COULDNOTASSIGNETHERNETCARD";
			case LIBMCDRIVER_SCANLAB_ERROR_MISSINGFIRMWAREDATA: return "MISSINGFIRMWAREDATA";
			case LIBMCDRIVER_SCANLAB_ERROR_MISSINGFPGADATA: return "MISSINGFPGADATA";
			case LIBMCDRIVER_SCANLAB_ERROR_MISSINGAUXILIARYDATA: return "MISSINGAUXILIARYDATA";
			case LIBMCDRIVER_SCANLAB_ERROR_MISSINGFIRMWAREINITIZATIONDATA: return "MISSINGFIRMWAREINITIZATIONDATA";
			case LIBMCDRIVER_SCANLAB_ERROR_NOCARDFOUNDATIPADDRESS: return "NOCARDFOUNDATIPADDRESS";
			case LIBMCDRIVER_SCANLAB_ERROR_NOCARDFOUNDATINIPRANGE: return "NOCARDFOUNDATINIPRANGE";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTINITIALISERTCCARD: return "COULDNOTINITIALISERTCCARD";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELNAME: return "INVALIDCHANNELNAME";
			case LIBMCDRIVER_SCANLAB_ERROR_EMPTYCHANNELNAME: return "EMPTYCHANNELNAME";
			case LIBMCDRIVER_SCANLAB_ERROR_CANNOTADDCHANNELDURINGRECORDING: return "CANNOTADDCHANNELDURINGRECORDING";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATECHANNELNAME: return "DUPLICATECHANNELNAME";
			case LIBMCDRIVER_SCANLAB_ERROR_NORECORDINGCHANNELAVAILABLE: return "NORECORDINGCHANNELAVAILABLE";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELID: return "INVALIDCHANNELID";
			case LIBMCDRIVER_SCANLAB_ERROR_CHANNELTYPECANNOTBEUNDEFINED: return "CHANNELTYPECANNOTBEUNDEFINED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHUNKSIZE: return "INVALIDCHUNKSIZE";
			case LIBMCDRIVER_SCANLAB_ERROR_CHANNELNOTFOUND: return "CHANNELNOTFOUND";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRECORDINDEX: return "INVALIDRECORDINDEX";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHUNKINDEX: return "INVALIDCHUNKINDEX";
			case LIBMCDRIVER_SCANLAB_ERROR_CHUNKENTRYINDEXOUTOFBOUNDS: return "CHUNKENTRYINDEXOUTOFBOUNDS";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDDATARECORDINGINTERVAL: return "INVALIDDATARECORDINGINTERVAL";
			case LIBMCDRIVER_SCANLAB_ERROR_DATARECORDINGOVERFLOW: return "DATARECORDINGOVERFLOW";
			case LIBMCDRIVER_SCANLAB_ERROR_DATARECORDINGUNDERFLOW: return "DATARECORDINGUNDERFLOW";
			case LIBMCDRIVER_SCANLAB_ERROR_DATABUFFERISFULL: return "DATABUFFERISFULL";
			case LIBMCDRIVER_SCANLAB_ERROR_DATABUFFERREADEMPTY: return "DATABUFFERREADEMPTY";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDRECORDING: return "COULDNOTFINDRECORDING";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELTYPE: return "INVALIDCHANNELTYPE";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCRECORDINGFREQUENCY: return "INVALIDRTCRECORDINGFREQUENCY";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDDIGITALOUTPUTVALUE: return "INVALIDDIGITALOUTPUTVALUE";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDDIGITALOUTPUTMASK: return "INVALIDDIGITALOUTPUTMASK";
			case LIBMCDRIVER_SCANLAB_ERROR_CANNOTCHANGENLIGHTSETTINGSWHILEENABLED: return "CANNOTCHANGENLIGHTSETTINGSWHILEENABLED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTCONTROLPIN: return "INVALIDNLIGHTCONTROLPIN";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTSELECTIONPIN: return "INVALIDNLIGHTSELECTIONPIN";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTINPUTPIN: return "INVALIDNLIGHTINPUTPIN";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTAFXSELECTIONDELAY: return "INVALIDNLIGHTAFXSELECTIONDELAY";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTAFXACKNOWLEDGETIMEOUT: return "INVALIDNLIGHTAFXACKNOWLEDGETIMEOUT";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTAFXMODE: return "INVALIDNLIGHTAFXMODE";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSEQUENCEIDENTIFIER: return "INVALIDSEQUENCEIDENTIFIER";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATEGPIOSEQUENCEIDENTIFIER: return "DUPLICATEGPIOSEQUENCEIDENTIFIER";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDGPIOSEQUENCE: return "COULDNOTFINDGPIOSEQUENCE";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDGPIOTASKDELAY: return "INVALIDGPIOTASKDELAY";
			case LIBMCDRIVER_SCANLAB_ERROR_GPIOTASKDELAYMUSTBEMULTIPLEOF10: return "GPIOTASKDELAYMUSTBEMULTIPLEOF10";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLAB_SUCCESS: return "success";
			case LIBMCDRIVER_SCANLAB_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_SCANLAB_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_SCANLAB_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_SCANLAB_ERROR_DRIVERERROR: return "a driver error occured";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_NO_PCIE_CARD_FOUND: return "RTC6: No PCIE Card was found";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ACCESS_DENIED: return "RTC6: Access Denied";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_SEND_ERROR: return "RTC6: Send Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TIMEOUT: return "RTC6: Timeout";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_PARAM_ERROR: return "RTC6: Param Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_BUSY: return "RTC6: Busy";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_REJECTED: return "RTC6: Rejected";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_IGNORED: return "RTC6: Ignored";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERSION_MISMATCH: return "RTC6: Version Mismatch";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERIFY_ERROR: return "RTC6: Verify Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TYPE_REJECTED: return "RTC6: Type Rejected";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_OUT_OF_MEMORY: return "RTC6: Out of Memory";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_FLASH_ERROR: return "RTC6: Flash Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ETH_ERROR: return "RTC6: Eth Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_CONFIG_ERROR: return "RTC6: Config Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_UNKNOWN_ERROR: return "RTC6: Unknown Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTCOPEN_FAILED: return "RTC open failed";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCPROC: return "Invalid RTC proc";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDIPADDRESS: return "Invalid IP Address";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNETMASK: return "Invalid NetMask";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYACQUIRED: return "Card already acquired";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTFOUND: return "Card not found";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADPROGRAMFILE: return "Could not load program file";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADCORRECTIONFILE: return "Could not load correction file";
			case LIBMCDRIVER_SCANLAB_ERROR_DELAYSMUSTBEMULTIPLEOF10: return "Delays must be a multiple of 10 microseconds";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKNOTLOADED: return "Scanlab RTC has not been loaded";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKALREADYLOADED: return "Scanlab RTC has already been loaded";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYINITIALIZED: return "Scanlab RTC card is already initialized";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTINITIALIZED: return "Scanlab RTC card is not initialized";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOINTCOUNT: return "Invalid point count";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDMAXLASERPOWER: return "Invalid max laser power.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERDELAY: return "Invalid laser delay.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERDELAY: return "Invalid scanner delay.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANLABSDK: return "Invalid SCANLAB SDK.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIESIGNALBUFFERARRAY: return "Invalid OIE Signal buffer array.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGTIMELAG: return "Invalid Skywriting Timelag.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGLASERONSHIFT: return "Invalid Skywriting Laser On Shift.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPREV: return "Invalid Skywriting N Prev.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPOST: return "Invalid Skywriting N Post.";
			case LIBMCDRIVER_SCANLAB_ERROR_OIEHASNOTBEENINITIALIZED: return "OIE has not been initialized.";
			case LIBMCDRIVER_SCANLAB_ERROR_UNSUPPORTEDOIEOPERATIONMODE: return "Unsupported OIE Operation Mode.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCCORRECTIONDATA: return "Invalid RTC Correction data.";
			case LIBMCDRIVER_SCANLAB_ERROR_CONFIGURATIONPRESETNOTFOUND: return "Configuration preset not found.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERCOUNT: return "Invalid scanner count.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERINDEX: return "Invalid scanner index.";
			case LIBMCDRIVER_SCANLAB_ERROR_LASERINDEXHASNOASSIGNEDSCANNER: return "Laser index has no assigned scanner.";
			case LIBMCDRIVER_SCANLAB_ERROR_LASERINDEXNOTFOUND: return "Laser index not found.";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATELASERINDEX: return "Duplicate laser index.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCONFIGURATIONSCHEMA: return "Invalid configuration schema.";
			case LIBMCDRIVER_SCANLAB_ERROR_NOVERSIONDEFINITION: return "No version definition.";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATECONFIGURATIONPRESETNAME: return "Duplicate configuration preset name.";
			case LIBMCDRIVER_SCANLAB_ERROR_OIEPIDVARIABLEOUTOFBOUNDS: return "OIE PID Variable out of bounds.";
			case LIBMCDRIVER_SCANLAB_ERROR_TIMELAGMUSTBEAMULTIPLEOF10: return "Timelag must be a multiple of 10 microseconds.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDENCODERSCALINGINX: return "Invalid Encoder Scaling in X";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDENCODERSCALINGINY: return "Invalid Encoder Scaling in Y";
			case LIBMCDRIVER_SCANLAB_ERROR_ONTHEFLYMARKINGERROR: return "On the fly marking error";
			case LIBMCDRIVER_SCANLAB_ERROR_MARKONTHEFLYISDISABLED: return "Mark on the fly is disabled";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERFIELDCOORDINATES: return "Invalid laser field coordinates";
			case LIBMCDRIVER_SCANLAB_ERROR_NOLASERFIELDSET: return "No laser field has been set.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDFREEVARIABLEINDEX: return "Invalid free variable index.";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATELASERPOWERCALIBRATIONSETPOINT: return "Duplicate laser power calibration set point.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOWERCALIBRATIONSETPOINT: return "Invalid power calibration set point.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOWERCALIBRATIONOUTPUTSCALING: return "Invalid power calibration output scaling.";
			case LIBMCDRIVER_SCANLAB_ERROR_POWERCALIBRATIONLOOKUPFAILED: return "Power calibration lookup failed.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDMODULATIONCALLBACK: return "Invalid modulation callback.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSUBDIVISIONTHRESHOLD: return "Invalid subdivision threshold.";
			case LIBMCDRIVER_SCANLAB_ERROR_MULTIPLELASERPORTSNOTCOMPATIBLEWITHPID: return "Multiple laser ports are not compatible with PID control.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIEMEASUREMENTTAG: return "Invalid OIE measurement tag.";
			case LIBMCDRIVER_SCANLAB_ERROR_RS232READTIMEOUT: return "RS232 read timeout.";
			case LIBMCDRIVER_SCANLAB_ERROR_RS232READLINEOVERRUN: return "RS232 read line overrun.";
			case LIBMCDRIVER_SCANLAB_ERROR_RS232RINGBUFFEROVERRUN: return "RS232 ring buffer overrun.";
			case LIBMCDRIVER_SCANLAB_ERROR_NOSCANAHEADOPTION: return "No Scanahead option.";
			case LIBMCDRIVER_SCANLAB_ERROR_NOEXCELLISCAN: return "No Excelli Scan.";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADLISTISACTIVE: return "Scanahead - list is active.";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADPARAMETERERROR: return "Scanahead parameter error.";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADSCALINGERROR: return "Scanahead scaling error.";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADMISSINGRTCRESPONSE: return "Scanahead missing rtc response.";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADPCIERROR: return "Scanahead PCI error.";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANAHEADUNKNOWNERROR: return "Scanahead unknown error.";
			case LIBMCDRIVER_SCANLAB_ERROR_PORTNUMBERISNOTDIGITAL: return "Port number is not digital.";
			case LIBMCDRIVER_SCANLAB_ERROR_PORTNUMBERISNOTANALOG: return "Port number is not analog.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIECHANNELSIZE: return "Invalid OIE Channel size.";
			case LIBMCDRIVER_SCANLAB_ERROR_INTERNALACQUISITIONERROR: return "Internal Acquisition Error.";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTDETERMINESERIALNUMBER: return "Could not determine serial number.";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTASSIGNETHERNETCARD: return "Could not assign ethernet card.";
			case LIBMCDRIVER_SCANLAB_ERROR_MISSINGFIRMWAREDATA: return "Missing Firmware Data.";
			case LIBMCDRIVER_SCANLAB_ERROR_MISSINGFPGADATA: return "Missing FPGA Data.";
			case LIBMCDRIVER_SCANLAB_ERROR_MISSINGAUXILIARYDATA: return "Missing Auxiliary Data.";
			case LIBMCDRIVER_SCANLAB_ERROR_MISSINGFIRMWAREINITIZATIONDATA: return "Missing Firmware Initialisation Data.";
			case LIBMCDRIVER_SCANLAB_ERROR_NOCARDFOUNDATIPADDRESS: return "No Card found at IP Address.";
			case LIBMCDRIVER_SCANLAB_ERROR_NOCARDFOUNDATINIPRANGE: return "No Card found in IP Range.";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTINITIALISERTCCARD: return "Could not initialize RTC Card.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELNAME: return "Invalid Channel Name.";
			case LIBMCDRIVER_SCANLAB_ERROR_EMPTYCHANNELNAME: return "Empty Channel Name.";
			case LIBMCDRIVER_SCANLAB_ERROR_CANNOTADDCHANNELDURINGRECORDING: return "Cannot add channel during recording.";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATECHANNELNAME: return "Duplicate channel name.";
			case LIBMCDRIVER_SCANLAB_ERROR_NORECORDINGCHANNELAVAILABLE: return "No recording channel available.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELID: return "Invalid Channel ID.";
			case LIBMCDRIVER_SCANLAB_ERROR_CHANNELTYPECANNOTBEUNDEFINED: return "Channel Type cannot be undefined.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHUNKSIZE: return "Invalid Chunk Size";
			case LIBMCDRIVER_SCANLAB_ERROR_CHANNELNOTFOUND: return "Channel not found";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRECORDINDEX: return "Invalid record index";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHUNKINDEX: return "Invalid chunk index";
			case LIBMCDRIVER_SCANLAB_ERROR_CHUNKENTRYINDEXOUTOFBOUNDS: return "Chunk entry index out of bounds";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDDATARECORDINGINTERVAL: return "Invalid data recording interval";
			case LIBMCDRIVER_SCANLAB_ERROR_DATARECORDINGOVERFLOW: return "Data recording overflow";
			case LIBMCDRIVER_SCANLAB_ERROR_DATARECORDINGUNDERFLOW: return "Data recording underflow";
			case LIBMCDRIVER_SCANLAB_ERROR_DATABUFFERISFULL: return "Data buffer is full";
			case LIBMCDRIVER_SCANLAB_ERROR_DATABUFFERREADEMPTY: return "Data buffer read empty";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDRECORDING: return "Could not find recording.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCHANNELTYPE: return "Invalid channel type.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCRECORDINGFREQUENCY: return "Invalid RTC recording frequency.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDDIGITALOUTPUTVALUE: return "Invalid digital output value.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDDIGITALOUTPUTMASK: return "Invalid digital output mask.";
			case LIBMCDRIVER_SCANLAB_ERROR_CANNOTCHANGENLIGHTSETTINGSWHILEENABLED: return "Cannot change nLight settings while enabled.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTCONTROLPIN: return "Invalid nLight Control Pin.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTSELECTIONPIN: return "Invalid nLight Selection Pin.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTINPUTPIN: return "Invalid nLight Input Pin.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTAFXSELECTIONDELAY: return "Invalid nLight AFX Selection Delay.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTAFXACKNOWLEDGETIMEOUT: return "Invalid nLight AFX Selection Timeout.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNLIGHTAFXMODE: return "Invalid nLight AFX Mode.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSEQUENCEIDENTIFIER: return "Invalid sequence identifier.";
			case LIBMCDRIVER_SCANLAB_ERROR_DUPLICATEGPIOSEQUENCEIDENTIFIER: return "Duplicate GPIO Sequence Identifier.";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDGPIOSEQUENCE: return "Duplicate GPIO Sequence Identifier.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDGPIOTASKDELAY: return "Invalid GPIO Task Delay.";
			case LIBMCDRIVER_SCANLAB_ERROR_GPIOTASKDELAYMUSTBEMULTIPLEOF10: return "GPIO Task Delay must be a multiple of 10.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_ScanLabInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_ScanLabResult nResult);

	inline void GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLab_pvoid pSymbolAddressMethod);
	inline LibMCDriver_ScanLab_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_ScanLabDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_ScanLabResult checkBinaryVersion()
	{
		LibMCDriver_ScanLab_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_SCANLAB_VERSION_MAJOR) {
			return LIBMCDRIVER_SCANLAB_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	LibMCDriver_ScanLabResult initWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabResult releaseWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabResult loadWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_ScanLabResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CUARTConnection;
	friend class CRTCJob;
	friend class CRTCRecording;
	friend class CGPIOSequence;
	friend class CNLightAFXProfileSelector;
	friend class CRTCContext;
	friend class CRTCSelector;
	friend class CDriver_ScanLab;
	friend class CDriver_ScanLab_RTC6;
	friend class CDriver_ScanLab_RTC6xN;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_ScanLabHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_ScanLabResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_ScanLabHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro, std::string & sBuild);
	inline void QueryParameters();
	inline void QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance);
};
	
/*************************************************************************************************************************
 Class CUARTConnection 
**************************************************************************************************************************/
class CUARTConnection : public CBase {
public:
	
	/**
	* CUARTConnection::CUARTConnection - Constructor for UARTConnection class.
	*/
	CUARTConnection(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCDriver_ScanLab_uint32 GetBaudRate();
	inline LibMCDriver_ScanLab_uint32 GetConfiguredBaudRate();
	inline void ClearReceiveBuffer();
	inline LibMCDriver_ScanLab_uint32 AvailableBytes();
	inline void WriteString(const std::string & sValue);
	inline void WriteData(const CInputVector<LibMCDriver_ScanLab_uint8> & DataBuffer);
	inline void ReadData(const LibMCDriver_ScanLab_uint32 nByteCount, const LibMCDriver_ScanLab_uint32 nTimeOutInMS, std::vector<LibMCDriver_ScanLab_uint8> & DataBuffer);
	inline std::string ReadLine(const std::string & sSeparator, const LibMCDriver_ScanLab_uint32 nMaxLineLength, const LibMCDriver_ScanLab_uint32 nTimeOutInMS);
};
	
/*************************************************************************************************************************
 Class CRTCJob 
**************************************************************************************************************************/
class CRTCJob : public CBase {
public:
	
	/**
	* CRTCJob::CRTCJob - Constructor for RTCJob class.
	*/
	CRTCJob(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue);
	inline void DrawPolylineOIE(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue, const LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex);
	inline void DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue);
	inline void AddSetPower(const LibMCDriver_ScanLab_single fPowerInPercent);
	inline void AddSetAnalogOut(const eLaserPort eLaserPort, const LibMCDriver_ScanLab_single fOutputValue);
	inline void AddSetDigitalOut(const eLaserPort eLaserPort, const LibMCDriver_ScanLab_single fOutputValue);
	inline void AddSetPowerForPIDControl(const LibMCDriver_ScanLab_single fPowerInPercent);
	inline void AddSetJumpSpeed(const LibMCDriver_ScanLab_single fJumpSpeedInMMPerSecond);
	inline void AddSetMarkSpeed(const LibMCDriver_ScanLab_single fMarkSpeedInMMPerSecond);
	inline void AddJumpMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY);
	inline void AddMarkMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY);
	inline void AddTimedMarkMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY, const LibMCDriver_ScanLab_double dDurationInMicroseconds);
	inline void AddFreeVariable(const LibMCDriver_ScanLab_uint32 nVariableNo, const LibMCDriver_ScanLab_uint32 nValue);
};
	
/*************************************************************************************************************************
 Class CRTCRecording 
**************************************************************************************************************************/
class CRTCRecording : public CBase {
public:
	
	/**
	* CRTCRecording::CRTCRecording - Constructor for RTCRecording class.
	*/
	CRTCRecording(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool ScanheadConnectionCheckIsEnabled();
	inline void EnableScanheadConnectionCheck();
	inline void DisableScanheadConnectionCheck();
	inline void Clear();
	inline void AddChannel(const std::string & sChannelName, const eRTCChannelType eChannelType);
	inline void RemoveChannel(const std::string & sChannelName);
	inline bool HasChannel(const std::string & sChannelName);
	inline eRTCChannelType GetChannelType(const std::string & sChannelName);
	inline LibMCDriver_ScanLab_uint64 GetRecordCount(const std::string & sChannelName);
	inline LibMCDriver_ScanLab_int32 GetRecordEntry(const std::string & sChannelName, const LibMCDriver_ScanLab_uint64 nRecordIndex);
	inline void GetAllRecordEntries(const std::string & sChannelName, std::vector<LibMCDriver_ScanLab_int32> & ValuesBuffer);
	inline void EnableRecording(const eRTCRecordingFrequency eFrequency);
	inline void DisableRecording();
	inline void ExecuteListWithRecording();
	inline void AddRecordsToDataTable(const std::string & sChannelName, classParam<LibMCEnv::CDataTable> pDataTable, const std::string & sColumnIdentifier, const std::string & sColumnDescription);
	inline void AddScaledRecordsToDataTable(const std::string & sChannelName, classParam<LibMCEnv::CDataTable> pDataTable, const std::string & sColumnIdentifier, const std::string & sColumnDescription, const LibMCDriver_ScanLab_double dScaleFactor, const LibMCDriver_ScanLab_double dOffset);
};
	
/*************************************************************************************************************************
 Class CGPIOSequence 
**************************************************************************************************************************/
class CGPIOSequence : public CBase {
public:
	
	/**
	* CGPIOSequence::CGPIOSequence - Constructor for GPIOSequence class.
	*/
	CGPIOSequence(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetIdentifier();
	inline void Clear();
	inline void AddOutput(const LibMCDriver_ScanLab_uint32 nOutputBit, const bool bOutputValue);
	inline void AddDelay(const LibMCDriver_ScanLab_uint32 nDelayInMilliseconds);
	inline void WaitforInput(const LibMCDriver_ScanLab_uint32 nInputBit, const bool bInputValue, const LibMCDriver_ScanLab_uint32 nMaxDelayInMilliseconds);
	inline void AddLabel(const std::string & sLabelName, const LibMCDriver_ScanLab_uint32 nMaxPasses);
	inline void GoToLabel(const std::string & sLabelName);
	inline void ConditionalGoToLabel(const LibMCDriver_ScanLab_uint32 nInputBit, const bool bInputValue, const std::string & sLabelName);
	inline void EnableAutomaticSelection();
	inline void DisableAutomaticSelection();
};
	
/*************************************************************************************************************************
 Class CNLightAFXProfileSelector 
**************************************************************************************************************************/
class CNLightAFXProfileSelector : public CBase {
public:
	
	/**
	* CNLightAFXProfileSelector::CNLightAFXProfileSelector - Constructor for NLightAFXProfileSelector class.
	*/
	CNLightAFXProfileSelector(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void SetControlOutputPins(const LibMCDriver_ScanLab_uint32 nEnableDigitalOutputBit, const LibMCDriver_ScanLab_uint32 nStartDigitalOutputBit);
	inline void GetControlOutputPins(LibMCDriver_ScanLab_uint32 & nEnableDigitalOutputBit, LibMCDriver_ScanLab_uint32 & nStartDigitalOutputBit);
	inline void SetSelectionOutputPins(const LibMCDriver_ScanLab_uint32 nStartIndexSelection0OutputBit, const LibMCDriver_ScanLab_uint32 nStartIndexSelection1OutputBit, const LibMCDriver_ScanLab_uint32 nStartIndexSelection2OutputBit);
	inline void GetSelectionOutputPins(LibMCDriver_ScanLab_uint32 & nStartIndexSelection0OutputBit, LibMCDriver_ScanLab_uint32 & nStartIndexSelection1OutputBit, LibMCDriver_ScanLab_uint32 & nStartIndexSelection2OutputBit);
	inline void SetAcknowledgeInputPin(const LibMCDriver_ScanLab_uint32 nSelectionAcknowledgeInputBit);
	inline LibMCDriver_ScanLab_uint32 GetAcknowledgeInputPin();
	inline void SetSelectionDelay(const LibMCDriver_ScanLab_uint32 nSelectionDelayInMilliseconds);
	inline LibMCDriver_ScanLab_uint32 GetSelectionDelay();
	inline void SetAcknowledgeTimeout(const LibMCDriver_ScanLab_uint32 nAcknowledgeInMilliseconds);
	inline LibMCDriver_ScanLab_uint32 GetAcknowledgeTimeout();
	inline void EnableAutomaticSelection();
	inline void DisableAutomaticSelection();
	inline void AddCustomSelection(const LibMCDriver_ScanLab_uint32 nAFXModeIndex);
};
	
/*************************************************************************************************************************
 Class CRTCContext 
**************************************************************************************************************************/
class CRTCContext : public CBase {
public:
	
	/**
	* CRTCContext::CRTCContext - Constructor for RTCContext class.
	*/
	CRTCContext(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void LoadFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer);
	inline void LoadCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension);
	inline void SelectCorrectionTable(const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB);
	inline void ConfigureLists(const LibMCDriver_ScanLab_uint32 nSizeListA, const LibMCDriver_ScanLab_uint32 nSizeListB);
	inline void SetLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort);
	inline void DisableAutoLaserControl();
	inline void SetLaserControlParameters(const bool bDisableLaser, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive);
	inline void SetLaserPulsesInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength);
	inline void SetLaserPulsesInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength);
	inline void SetStandbyInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength);
	inline void SetStandbyInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength);
	inline std::string GetIPAddress();
	inline std::string GetNetmask();
	inline LibMCDriver_ScanLab_uint32 GetSerialNumber();
	inline LibMCDriver_ScanLab_uint32 GetLaserIndex();
	inline void SetLaserOrigin(const LibMCDriver_ScanLab_double dOriginX, const LibMCDriver_ScanLab_double dOriginY);
	inline void GetLaserOrigin(LibMCDriver_ScanLab_double & dOriginX, LibMCDriver_ScanLab_double & dOriginY);
	inline void SetLaserField(const LibMCDriver_ScanLab_double dMinX, const LibMCDriver_ScanLab_double dMinY, const LibMCDriver_ScanLab_double dMaxX, const LibMCDriver_ScanLab_double dMaxY);
	inline void ResetLaserField();
	inline void EnableRangeChecking();
	inline void DisableRangeChecking();
	inline bool GetLaserField(LibMCDriver_ScanLab_double & dMinX, LibMCDriver_ScanLab_double & dMinY, LibMCDriver_ScanLab_double & dMaxX, LibMCDriver_ScanLab_double & dMaxY);
	inline void SetStartList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition);
	inline void SetEndOfList();
	inline void ExecuteList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition);
	inline void SetAutoChangePos(const LibMCDriver_ScanLab_uint32 nPosition);
	inline void SetDelays(const LibMCDriver_ScanLab_uint32 nMarkDelay, const LibMCDriver_ScanLab_uint32 nJumpDelay, const LibMCDriver_ScanLab_uint32 nPolygonDelay);
	inline void SetLaserDelaysInMicroseconds(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay);
	inline void SetLaserDelaysInBits(const LibMCDriver_ScanLab_int32 nLaserOnDelay, const LibMCDriver_ScanLab_int32 nLaserOffDelay);
	inline void DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue);
	inline void DrawPolylineOIE(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue, const LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex);
	inline void DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue);
	inline void AddSetPower(const LibMCDriver_ScanLab_single fPowerInPercent);
	inline void AddSetAnalogOut(const eLaserPort eLaserPort, const LibMCDriver_ScanLab_single fOutputValue);
	inline void AddSetDigitalOut(const eLaserPort eLaserPort, const LibMCDriver_ScanLab_single fOutputValue);
	inline void AddSetPowerForPIDControl(const LibMCDriver_ScanLab_single fPowerInPercent);
	inline void AddSetJumpSpeed(const LibMCDriver_ScanLab_single fJumpSpeedInMMPerSecond);
	inline void AddSetMarkSpeed(const LibMCDriver_ScanLab_single fMarkSpeedInMMPerSecond);
	inline void AddJumpMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY);
	inline void AddMarkMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY);
	inline void AddTimedMarkMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY, const LibMCDriver_ScanLab_double dDurationInMicroseconds);
	inline void AddFreeVariable(const LibMCDriver_ScanLab_uint32 nVariableNo, const LibMCDriver_ScanLab_uint32 nValue);
	inline LibMCDriver_ScanLab_uint32 GetCurrentFreeVariable(const LibMCDriver_ScanLab_uint32 nVariableNo);
	inline LibMCDriver_ScanLab_uint32 GetTimeStamp();
	inline LibMCDriver_ScanLab_int32 GetRTCChannel(const eRTCChannelType eChannelType);
	inline LibMCDriver_ScanLab_int32 GetRTCInternalValue(const LibMCDriver_ScanLab_uint32 nInternalSignalID);
	inline void StopExecution();
	inline void DrawHatchesOIE(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue, const LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex);
	inline void AddLayerToList(classParam<LibMCEnv::CToolpathLayer> pLayer, const bool bFailIfNonAssignedDataExists);
	inline void WaitForEncoderX(const LibMCDriver_ScanLab_double dPositionInMM, const bool bInPositiveHalfPlane);
	inline void WaitForEncoderY(const LibMCDriver_ScanLab_double dPositionInMM, const bool bInPositiveHalfPlane);
	inline void WaitForEncoderXSteps(const LibMCDriver_ScanLab_int32 nPositionInSteps, const bool bInPositiveHalfPlane);
	inline void WaitForEncoderYSteps(const LibMCDriver_ScanLab_int32 nPositionInSteps, const bool bInPositiveHalfPlane);
	inline void AddCustomDelay(const LibMCDriver_ScanLab_uint32 nDelayInMicroseconds);
	inline LibMCDriver_ScanLab_double GetCorrectionFactor();
	inline void GetStatus(bool & bBusy, LibMCDriver_ScanLab_uint32 & nPosition);
	inline void GetHeadStatus(const LibMCDriver_ScanLab_uint32 nHeadNo, bool & bPositionXisOK, bool & bPositionYisOK, bool & bTemperatureisOK, bool & bPowerisOK);
	inline void GetStateValues(bool & bLaserIsOn, LibMCDriver_ScanLab_int32 & nPositionX, LibMCDriver_ScanLab_int32 & nPositionY, LibMCDriver_ScanLab_int32 & nPositionZ, LibMCDriver_ScanLab_int32 & nCorrectedPositionX, LibMCDriver_ScanLab_int32 & nCorrectedPositionY, LibMCDriver_ScanLab_int32 & nCorrectedPositionZ, LibMCDriver_ScanLab_int32 & nFocusShift, LibMCDriver_ScanLab_int32 & nMarkSpeed);
	inline LibMCDriver_ScanLab_uint32 GetInputPointer();
	inline void GetRTCVersion(LibMCDriver_ScanLab_uint32 & nRTCVersion, LibMCDriver_ScanLab_uint32 & nRTCType, LibMCDriver_ScanLab_uint32 & nDLLVersion, LibMCDriver_ScanLab_uint32 & nHEXVersion, LibMCDriver_ScanLab_uint32 & nBIOSVersion);
	inline void SetCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier);
	inline void GetCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier);
	inline void InitializeForOIE(const CInputVector<LibMCDriver_ScanLab_uint32> & SignalChannelsBuffer, const eOIEOperationMode eOperationMode);
	inline void SetLaserPinOut(const bool bLaserOut1, const bool bLaserOut2);
	inline void GetLaserPinIn(bool & bLaserOut1, bool & bLaserOut2);
	inline void AddLaserPinOutToList(const bool bLaserOut1, const bool bLaserOut2);
	inline void AddWriteDigitalIOList(const LibMCDriver_ScanLab_uint32 nDigitalOutput);
	inline void AddWriteMaskedDigitalIOList(const LibMCDriver_ScanLab_uint32 nDigitalOutput, const LibMCDriver_ScanLab_uint32 nOutputMask);
	inline void EnableOIE();
	inline void DisableOIE();
	inline PNLightAFXProfileSelector CreateNLightAFXBeamProfileSelector();
	inline PGPIOSequence AddGPIOSequence(const std::string & sIdentifier);
	inline void WriteGPIOSequenceToList(const std::string & sIdentifier);
	inline PGPIOSequence FindGPIOSequence(const std::string & sIdentifier, const bool bMustExist);
	inline void DeleteGPIOSequence(const std::string & sIdentifier);
	inline void StartOIEMeasurement();
	inline void StartOIEMeasurementEx(const bool bLaserOnTrigger);
	inline void StopOIEMeasurement();
	inline void SetOIEPIDMode(const LibMCDriver_ScanLab_uint32 nOIEPIDIndex);
	inline void EnableOIEPIDControl();
	inline void DisableOIEPIDControl();
	inline void ClearOIEMeasurementTags();
	inline void EnableOIEMeasurementTagging();
	inline void DisableOIEMeasurementTagging();
	inline LibMCDriver_ScanLab_uint32 GetOIEMaxMeasurementTag();
	inline void MapOIEMeasurementTag(const LibMCDriver_ScanLab_uint32 nMeasurementTag, LibMCDriver_ScanLab_uint32 & nPartID, LibMCDriver_ScanLab_uint32 & nProfileID, LibMCDriver_ScanLab_uint32 & nSegmentID, LibMCDriver_ScanLab_uint32 & nVectorID);
	inline void DisableSkyWriting();
	inline void EnableSkyWritingMode1(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost);
	inline void EnableSkyWritingMode2(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost);
	inline void EnableSkyWritingMode3(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost, const LibMCDriver_ScanLab_double dLimit);
	inline void EnableSkyWritingMode4(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost, const LibMCDriver_ScanLab_double dLimit);
	inline void SetTransformationAngle(const LibMCDriver_ScanLab_double dAngleInDegrees);
	inline void SetTransformationScale(const LibMCDriver_ScanLab_double dScaleFactor);
	inline void SetTransformationOffset(const LibMCDriver_ScanLab_int32 nOffsetX, const LibMCDriver_ScanLab_int32 nOffsetY);
	inline void SetTransformationMatrix(const LibMCDriver_ScanLab_double dM11, const LibMCDriver_ScanLab_double dM12, const LibMCDriver_ScanLab_double dM21, const LibMCDriver_ScanLab_double dM22);
	inline PRTCRecording PrepareRecording(const bool bKeepInMemory);
	inline bool HasRecording(const std::string & sUUID);
	inline PRTCRecording FindRecording(const std::string & sUUID);
	inline void EnableTimelagCompensation(const LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, const LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds);
	inline void DisableTimelagCompensation();
	inline void EnableMarkOnTheFly2D(const LibMCDriver_ScanLab_double dScaleXInMMperEncoderStep, const LibMCDriver_ScanLab_double dScaleYInMMperEncoderStep);
	inline void DisableMarkOnTheFly2D();
	inline bool MarkOnTheFly2DIsEnabled();
	inline void Get2DMarkOnTheFlyPosition(LibMCDriver_ScanLab_int32 & nPositionX, LibMCDriver_ScanLab_int32 & nPositionY);
	inline LibMCDriver_ScanLab_uint32 CheckOnTheFlyError(const bool bFailIfError);
	inline bool LaserPowerCalibrationIsEnabled();
	inline bool LaserPowerCalibrationIsLinear();
	inline void ClearLaserPowerCalibration();
	inline void GetLaserPowerCalibration(std::vector<sLaserCalibrationPoint> & CalibrationPointsBuffer);
	inline void SetLinearLaserPowerCalibration(const LibMCDriver_ScanLab_double dPowerOffsetInPercent, const LibMCDriver_ScanLab_double dPowerOutputScaling);
	inline void SetPiecewiseLinearLaserPowerCalibration(const CInputVector<sLaserCalibrationPoint> & CalibrationPointsBuffer);
	inline void EnableSpatialLaserPowerModulation(const SpatialPowerModulationCallback pModulationCallback, const LibMCDriver_ScanLab_pvoid pUserData);
	inline void DisablePowerModulation();
	inline void EnableLineSubdivision(const LibMCDriver_ScanLab_double dLengthThreshold);
	inline void DisableLineSubdivision();
	inline LibMCDriver_ScanLab_int32 ReadMultiMCBSP(const LibMCDriver_ScanLab_uint32 nRegisterNo);
	inline PUARTConnection CreateUARTConnection(const LibMCDriver_ScanLab_uint32 nDesiredBaudRate);
	inline void EnableScanAhead(const LibMCDriver_ScanLab_uint32 nHeadNo, const LibMCDriver_ScanLab_uint32 nTableNo);
	inline void DisableScanAhead();
	inline void ActivateScanAheadAutoDelays();
	inline void DeactivateScanAheadAutoDelays();
	inline bool ScanAheadAutoDelaysAreActivated();
	inline void SetScanAheadLaserShiftsInMicroseconds(const LibMCDriver_ScanLab_double dLaserOnShiftInMicroSeconds, const LibMCDriver_ScanLab_double dLaserOffShiftInMicroSeconds);
	inline void SetScanAheadLaserShiftsInUnits(const LibMCDriver_ScanLab_int32 nLaserOnShift, const LibMCDriver_ScanLab_int32 nLaserOffShift);
	inline void SetScanAheadLineParameters(const LibMCDriver_ScanLab_uint32 nCornerScale, const LibMCDriver_ScanLab_uint32 nEndScale, const LibMCDriver_ScanLab_uint32 nAccelerationScale);
};
	
/*************************************************************************************************************************
 Class CRTCSelector 
**************************************************************************************************************************/
class CRTCSelector : public CBase {
public:
	
	/**
	* CRTCSelector::CRTCSelector - Constructor for RTCSelector class.
	*/
	CRTCSelector(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCDriver_ScanLab_uint32 SearchCards(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout);
	inline LibMCDriver_ScanLab_uint32 SearchCardsByRange(const std::string & sStartIP, const std::string & sEndIP, const LibMCDriver_ScanLab_uint32 nTimeout);
	inline LibMCDriver_ScanLab_uint32 GetCardCount();
	inline LibMCDriver_ScanLab_uint32 GetEthernetCardCount();
	inline PRTCContext AcquireCard(const LibMCDriver_ScanLab_uint32 nNumber);
	inline PRTCContext AcquireCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber);
	inline PRTCContext AcquireEthernetCard(const LibMCDriver_ScanLab_uint32 nNumber);
	inline PRTCContext AcquireEthernetCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber);
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLab 
**************************************************************************************************************************/
class CDriver_ScanLab : public CDriver {
public:
	
	/**
	* CDriver_ScanLab::CDriver_ScanLab - Constructor for Driver_ScanLab class.
	*/
	CDriver_ScanLab(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline void LoadSDK(const std::string & sResourceName);
	inline void LoadCustomSDK(const CInputVector<LibMCDriver_ScanLab_uint8> & ScanlabDLLBuffer);
	inline PRTCSelector CreateRTCSelector();
	inline void EnableJournaling();
	inline void SetFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource);
	inline void SetCustomFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer);
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLab_RTC6 
**************************************************************************************************************************/
class CDriver_ScanLab_RTC6 : public CDriver_ScanLab {
public:
	
	/**
	* CDriver_ScanLab_RTC6::CDriver_ScanLab_RTC6 - Constructor for Driver_ScanLab_RTC6 class.
	*/
	CDriver_ScanLab_RTC6(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CDriver_ScanLab(pWrapper, pHandle)
	{
	}
	
	inline void SetToSimulationMode();
	inline bool IsSimulationMode();
	inline bool IsInitialized();
	inline void Initialise(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout, const LibMCDriver_ScanLab_uint32 nSerialNumber);
	inline void InitialiseFromConfiguration(const std::string & sPresetName);
	inline void SetCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier);
	inline std::string GetIPAddress();
	inline std::string GetNetmask();
	inline LibMCDriver_ScanLab_uint32 GetSerialNumber();
	inline PRTCContext GetContext();
	inline PRTCSelector GetSelector();
	inline void LoadFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource);
	inline void LoadCustomFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer);
	inline void SetCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension, const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB);
	inline void ConfigureLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort, const LibMCDriver_ScanLab_double dMaxLaserPower, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive);
	inline void ConfigureDelays(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay, const LibMCDriver_ScanLab_double dMarkDelay, const LibMCDriver_ScanLab_double dJumpDelay, const LibMCDriver_ScanLab_double dPolygonDelay);
	inline void SetOIERecordingMode(const eOIERecordingMode eRecordingMode);
	inline eOIERecordingMode GetOIERecordingMode();
	inline void EnableAttributeFilter(const std::string & sNameSpace, const std::string & sAttributeName, const LibMCDriver_ScanLab_int64 nAttributeValue);
	inline void DisableAttributeFilter();
	inline void DrawLayer(const std::string & sStreamUUID, const LibMCDriver_ScanLab_uint32 nLayerIndex);
	inline void GetCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier);
	inline void GetDefaultCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier);
	inline void EnableTimelagCompensation(const LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, const LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds);
	inline void DisableTimelagCompensation();
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLab_RTC6xN 
**************************************************************************************************************************/
class CDriver_ScanLab_RTC6xN : public CDriver_ScanLab {
public:
	
	/**
	* CDriver_ScanLab_RTC6xN::CDriver_ScanLab_RTC6xN - Constructor for Driver_ScanLab_RTC6xN class.
	*/
	CDriver_ScanLab_RTC6xN(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CDriver_ScanLab(pWrapper, pHandle)
	{
	}
	
	inline void SetToSimulationMode();
	inline bool IsSimulationMode();
	inline bool IsInitialized();
	inline bool ScannerIsInitialized(const LibMCDriver_ScanLab_uint32 nScannerIndex);
	inline LibMCDriver_ScanLab_uint32 GetScannerCount();
	inline void InitialiseScanner(const LibMCDriver_ScanLab_uint32 nScannerIndex, const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout, const LibMCDriver_ScanLab_uint32 nSerialNumber, const LibMCDriver_ScanLab_uint32 nLaserIndex);
	inline void InitialiseScannerFromConfiguration(const LibMCDriver_ScanLab_uint32 nScannerIndex, const std::string & sPresetName);
	inline std::string GetIPAddress(const LibMCDriver_ScanLab_uint32 nScannerIndex);
	inline std::string GetNetmask(const LibMCDriver_ScanLab_uint32 nScannerIndex);
	inline LibMCDriver_ScanLab_uint32 GetSerialNumber(const LibMCDriver_ScanLab_uint32 nScannerIndex);
	inline LibMCDriver_ScanLab_uint32 GetLaserIndex(const LibMCDriver_ScanLab_uint32 nScannerIndex);
	inline PRTCSelector GetSelector();
	inline PRTCContext GetContext(const LibMCDriver_ScanLab_uint32 nScannerIndex);
	inline void LoadFirmware(const LibMCDriver_ScanLab_uint32 nScannerIndex, const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource);
	inline void LoadCustomFirmware(const LibMCDriver_ScanLab_uint32 nScannerIndex, const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer);
	inline void SetCorrectionFile(const LibMCDriver_ScanLab_uint32 nScannerIndex, const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension, const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB);
	inline void ConfigureLaserMode(const LibMCDriver_ScanLab_uint32 nScannerIndex, const eLaserMode eLaserMode, const eLaserPort eLaserPort, const LibMCDriver_ScanLab_double dMaxLaserPower, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive);
	inline void ConfigureDelays(const LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay, const LibMCDriver_ScanLab_double dMarkDelay, const LibMCDriver_ScanLab_double dJumpDelay, const LibMCDriver_ScanLab_double dPolygonDelay);
	inline void SetOIERecordingMode(const eOIERecordingMode eRecordingMode);
	inline eOIERecordingMode GetOIERecordingMode();
	inline void EnableAttributeFilter(const std::string & sNameSpace, const std::string & sAttributeName, const LibMCDriver_ScanLab_int64 nAttributeValue);
	inline void DisableAttributeFilter();
	inline void DrawLayer(const std::string & sStreamUUID, const LibMCDriver_ScanLab_uint32 nLayerIndex, const bool bFailIfNonAssignedDataExists);
	inline void SetAllCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier);
	inline void SetCommunicationTimeouts(const LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier);
	inline void GetCommunicationTimeouts(const LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier);
	inline void GetDefaultCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier);
	inline void EnableTimelagCompensation(const LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, const LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds);
	inline void DisableTimelagCompensation(const LibMCDriver_ScanLab_uint32 nScannerIndex);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_ScanLabHandle hInstance = pInstance.GetHandle();
		LibMCDriver_ScanLab_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLab_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_ScanLabException(LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_ScanLabException(LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_ScanLab_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_ScanLab_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (hInstance) {
			return std::make_shared<CDriver>(this, hInstance);
		} else {
			return nullptr;
		}
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_ScanLabResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_ScanLabException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_ScanLabResult CWrapper::initWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_Driver_QueryParametersEx = nullptr;
		pWrapperTable->m_UARTConnection_GetBaudRate = nullptr;
		pWrapperTable->m_UARTConnection_GetConfiguredBaudRate = nullptr;
		pWrapperTable->m_UARTConnection_ClearReceiveBuffer = nullptr;
		pWrapperTable->m_UARTConnection_AvailableBytes = nullptr;
		pWrapperTable->m_UARTConnection_WriteString = nullptr;
		pWrapperTable->m_UARTConnection_WriteData = nullptr;
		pWrapperTable->m_UARTConnection_ReadData = nullptr;
		pWrapperTable->m_UARTConnection_ReadLine = nullptr;
		pWrapperTable->m_RTCJob_DrawPolyline = nullptr;
		pWrapperTable->m_RTCJob_DrawPolylineOIE = nullptr;
		pWrapperTable->m_RTCJob_DrawHatches = nullptr;
		pWrapperTable->m_RTCJob_AddSetPower = nullptr;
		pWrapperTable->m_RTCJob_AddSetAnalogOut = nullptr;
		pWrapperTable->m_RTCJob_AddSetDigitalOut = nullptr;
		pWrapperTable->m_RTCJob_AddSetPowerForPIDControl = nullptr;
		pWrapperTable->m_RTCJob_AddSetJumpSpeed = nullptr;
		pWrapperTable->m_RTCJob_AddSetMarkSpeed = nullptr;
		pWrapperTable->m_RTCJob_AddJumpMovement = nullptr;
		pWrapperTable->m_RTCJob_AddMarkMovement = nullptr;
		pWrapperTable->m_RTCJob_AddTimedMarkMovement = nullptr;
		pWrapperTable->m_RTCJob_AddFreeVariable = nullptr;
		pWrapperTable->m_RTCRecording_ScanheadConnectionCheckIsEnabled = nullptr;
		pWrapperTable->m_RTCRecording_EnableScanheadConnectionCheck = nullptr;
		pWrapperTable->m_RTCRecording_DisableScanheadConnectionCheck = nullptr;
		pWrapperTable->m_RTCRecording_Clear = nullptr;
		pWrapperTable->m_RTCRecording_AddChannel = nullptr;
		pWrapperTable->m_RTCRecording_RemoveChannel = nullptr;
		pWrapperTable->m_RTCRecording_HasChannel = nullptr;
		pWrapperTable->m_RTCRecording_GetChannelType = nullptr;
		pWrapperTable->m_RTCRecording_GetRecordCount = nullptr;
		pWrapperTable->m_RTCRecording_GetRecordEntry = nullptr;
		pWrapperTable->m_RTCRecording_GetAllRecordEntries = nullptr;
		pWrapperTable->m_RTCRecording_EnableRecording = nullptr;
		pWrapperTable->m_RTCRecording_DisableRecording = nullptr;
		pWrapperTable->m_RTCRecording_ExecuteListWithRecording = nullptr;
		pWrapperTable->m_RTCRecording_AddRecordsToDataTable = nullptr;
		pWrapperTable->m_RTCRecording_AddScaledRecordsToDataTable = nullptr;
		pWrapperTable->m_GPIOSequence_GetIdentifier = nullptr;
		pWrapperTable->m_GPIOSequence_Clear = nullptr;
		pWrapperTable->m_GPIOSequence_AddOutput = nullptr;
		pWrapperTable->m_GPIOSequence_AddDelay = nullptr;
		pWrapperTable->m_GPIOSequence_WaitforInput = nullptr;
		pWrapperTable->m_GPIOSequence_AddLabel = nullptr;
		pWrapperTable->m_GPIOSequence_GoToLabel = nullptr;
		pWrapperTable->m_GPIOSequence_ConditionalGoToLabel = nullptr;
		pWrapperTable->m_GPIOSequence_EnableAutomaticSelection = nullptr;
		pWrapperTable->m_GPIOSequence_DisableAutomaticSelection = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_SetControlOutputPins = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_GetControlOutputPins = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_SetSelectionOutputPins = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_GetSelectionOutputPins = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeInputPin = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeInputPin = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_SetSelectionDelay = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_GetSelectionDelay = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeTimeout = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeTimeout = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_EnableAutomaticSelection = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_DisableAutomaticSelection = nullptr;
		pWrapperTable->m_NLightAFXProfileSelector_AddCustomSelection = nullptr;
		pWrapperTable->m_RTCContext_LoadFirmware = nullptr;
		pWrapperTable->m_RTCContext_LoadCorrectionFile = nullptr;
		pWrapperTable->m_RTCContext_SelectCorrectionTable = nullptr;
		pWrapperTable->m_RTCContext_ConfigureLists = nullptr;
		pWrapperTable->m_RTCContext_SetLaserMode = nullptr;
		pWrapperTable->m_RTCContext_DisableAutoLaserControl = nullptr;
		pWrapperTable->m_RTCContext_SetLaserControlParameters = nullptr;
		pWrapperTable->m_RTCContext_SetLaserPulsesInBits = nullptr;
		pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds = nullptr;
		pWrapperTable->m_RTCContext_SetStandbyInBits = nullptr;
		pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds = nullptr;
		pWrapperTable->m_RTCContext_GetIPAddress = nullptr;
		pWrapperTable->m_RTCContext_GetNetmask = nullptr;
		pWrapperTable->m_RTCContext_GetSerialNumber = nullptr;
		pWrapperTable->m_RTCContext_GetLaserIndex = nullptr;
		pWrapperTable->m_RTCContext_SetLaserOrigin = nullptr;
		pWrapperTable->m_RTCContext_GetLaserOrigin = nullptr;
		pWrapperTable->m_RTCContext_SetLaserField = nullptr;
		pWrapperTable->m_RTCContext_ResetLaserField = nullptr;
		pWrapperTable->m_RTCContext_EnableRangeChecking = nullptr;
		pWrapperTable->m_RTCContext_DisableRangeChecking = nullptr;
		pWrapperTable->m_RTCContext_GetLaserField = nullptr;
		pWrapperTable->m_RTCContext_SetStartList = nullptr;
		pWrapperTable->m_RTCContext_SetEndOfList = nullptr;
		pWrapperTable->m_RTCContext_ExecuteList = nullptr;
		pWrapperTable->m_RTCContext_SetAutoChangePos = nullptr;
		pWrapperTable->m_RTCContext_SetDelays = nullptr;
		pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds = nullptr;
		pWrapperTable->m_RTCContext_SetLaserDelaysInBits = nullptr;
		pWrapperTable->m_RTCContext_DrawPolyline = nullptr;
		pWrapperTable->m_RTCContext_DrawPolylineOIE = nullptr;
		pWrapperTable->m_RTCContext_DrawHatches = nullptr;
		pWrapperTable->m_RTCContext_AddSetPower = nullptr;
		pWrapperTable->m_RTCContext_AddSetAnalogOut = nullptr;
		pWrapperTable->m_RTCContext_AddSetDigitalOut = nullptr;
		pWrapperTable->m_RTCContext_AddSetPowerForPIDControl = nullptr;
		pWrapperTable->m_RTCContext_AddSetJumpSpeed = nullptr;
		pWrapperTable->m_RTCContext_AddSetMarkSpeed = nullptr;
		pWrapperTable->m_RTCContext_AddJumpMovement = nullptr;
		pWrapperTable->m_RTCContext_AddMarkMovement = nullptr;
		pWrapperTable->m_RTCContext_AddTimedMarkMovement = nullptr;
		pWrapperTable->m_RTCContext_AddFreeVariable = nullptr;
		pWrapperTable->m_RTCContext_GetCurrentFreeVariable = nullptr;
		pWrapperTable->m_RTCContext_GetTimeStamp = nullptr;
		pWrapperTable->m_RTCContext_GetRTCChannel = nullptr;
		pWrapperTable->m_RTCContext_GetRTCInternalValue = nullptr;
		pWrapperTable->m_RTCContext_StopExecution = nullptr;
		pWrapperTable->m_RTCContext_DrawHatchesOIE = nullptr;
		pWrapperTable->m_RTCContext_AddLayerToList = nullptr;
		pWrapperTable->m_RTCContext_WaitForEncoderX = nullptr;
		pWrapperTable->m_RTCContext_WaitForEncoderY = nullptr;
		pWrapperTable->m_RTCContext_WaitForEncoderXSteps = nullptr;
		pWrapperTable->m_RTCContext_WaitForEncoderYSteps = nullptr;
		pWrapperTable->m_RTCContext_AddCustomDelay = nullptr;
		pWrapperTable->m_RTCContext_GetCorrectionFactor = nullptr;
		pWrapperTable->m_RTCContext_GetStatus = nullptr;
		pWrapperTable->m_RTCContext_GetHeadStatus = nullptr;
		pWrapperTable->m_RTCContext_GetStateValues = nullptr;
		pWrapperTable->m_RTCContext_GetInputPointer = nullptr;
		pWrapperTable->m_RTCContext_GetRTCVersion = nullptr;
		pWrapperTable->m_RTCContext_SetCommunicationTimeouts = nullptr;
		pWrapperTable->m_RTCContext_GetCommunicationTimeouts = nullptr;
		pWrapperTable->m_RTCContext_InitializeForOIE = nullptr;
		pWrapperTable->m_RTCContext_SetLaserPinOut = nullptr;
		pWrapperTable->m_RTCContext_GetLaserPinIn = nullptr;
		pWrapperTable->m_RTCContext_AddLaserPinOutToList = nullptr;
		pWrapperTable->m_RTCContext_AddWriteDigitalIOList = nullptr;
		pWrapperTable->m_RTCContext_AddWriteMaskedDigitalIOList = nullptr;
		pWrapperTable->m_RTCContext_EnableOIE = nullptr;
		pWrapperTable->m_RTCContext_DisableOIE = nullptr;
		pWrapperTable->m_RTCContext_CreateNLightAFXBeamProfileSelector = nullptr;
		pWrapperTable->m_RTCContext_AddGPIOSequence = nullptr;
		pWrapperTable->m_RTCContext_WriteGPIOSequenceToList = nullptr;
		pWrapperTable->m_RTCContext_FindGPIOSequence = nullptr;
		pWrapperTable->m_RTCContext_DeleteGPIOSequence = nullptr;
		pWrapperTable->m_RTCContext_StartOIEMeasurement = nullptr;
		pWrapperTable->m_RTCContext_StartOIEMeasurementEx = nullptr;
		pWrapperTable->m_RTCContext_StopOIEMeasurement = nullptr;
		pWrapperTable->m_RTCContext_SetOIEPIDMode = nullptr;
		pWrapperTable->m_RTCContext_EnableOIEPIDControl = nullptr;
		pWrapperTable->m_RTCContext_DisableOIEPIDControl = nullptr;
		pWrapperTable->m_RTCContext_ClearOIEMeasurementTags = nullptr;
		pWrapperTable->m_RTCContext_EnableOIEMeasurementTagging = nullptr;
		pWrapperTable->m_RTCContext_DisableOIEMeasurementTagging = nullptr;
		pWrapperTable->m_RTCContext_GetOIEMaxMeasurementTag = nullptr;
		pWrapperTable->m_RTCContext_MapOIEMeasurementTag = nullptr;
		pWrapperTable->m_RTCContext_DisableSkyWriting = nullptr;
		pWrapperTable->m_RTCContext_EnableSkyWritingMode1 = nullptr;
		pWrapperTable->m_RTCContext_EnableSkyWritingMode2 = nullptr;
		pWrapperTable->m_RTCContext_EnableSkyWritingMode3 = nullptr;
		pWrapperTable->m_RTCContext_EnableSkyWritingMode4 = nullptr;
		pWrapperTable->m_RTCContext_SetTransformationAngle = nullptr;
		pWrapperTable->m_RTCContext_SetTransformationScale = nullptr;
		pWrapperTable->m_RTCContext_SetTransformationOffset = nullptr;
		pWrapperTable->m_RTCContext_SetTransformationMatrix = nullptr;
		pWrapperTable->m_RTCContext_PrepareRecording = nullptr;
		pWrapperTable->m_RTCContext_HasRecording = nullptr;
		pWrapperTable->m_RTCContext_FindRecording = nullptr;
		pWrapperTable->m_RTCContext_EnableTimelagCompensation = nullptr;
		pWrapperTable->m_RTCContext_DisableTimelagCompensation = nullptr;
		pWrapperTable->m_RTCContext_EnableMarkOnTheFly2D = nullptr;
		pWrapperTable->m_RTCContext_DisableMarkOnTheFly2D = nullptr;
		pWrapperTable->m_RTCContext_MarkOnTheFly2DIsEnabled = nullptr;
		pWrapperTable->m_RTCContext_Get2DMarkOnTheFlyPosition = nullptr;
		pWrapperTable->m_RTCContext_CheckOnTheFlyError = nullptr;
		pWrapperTable->m_RTCContext_LaserPowerCalibrationIsEnabled = nullptr;
		pWrapperTable->m_RTCContext_LaserPowerCalibrationIsLinear = nullptr;
		pWrapperTable->m_RTCContext_ClearLaserPowerCalibration = nullptr;
		pWrapperTable->m_RTCContext_GetLaserPowerCalibration = nullptr;
		pWrapperTable->m_RTCContext_SetLinearLaserPowerCalibration = nullptr;
		pWrapperTable->m_RTCContext_SetPiecewiseLinearLaserPowerCalibration = nullptr;
		pWrapperTable->m_RTCContext_EnableSpatialLaserPowerModulation = nullptr;
		pWrapperTable->m_RTCContext_DisablePowerModulation = nullptr;
		pWrapperTable->m_RTCContext_EnableLineSubdivision = nullptr;
		pWrapperTable->m_RTCContext_DisableLineSubdivision = nullptr;
		pWrapperTable->m_RTCContext_ReadMultiMCBSP = nullptr;
		pWrapperTable->m_RTCContext_CreateUARTConnection = nullptr;
		pWrapperTable->m_RTCContext_EnableScanAhead = nullptr;
		pWrapperTable->m_RTCContext_DisableScanAhead = nullptr;
		pWrapperTable->m_RTCContext_ActivateScanAheadAutoDelays = nullptr;
		pWrapperTable->m_RTCContext_DeactivateScanAheadAutoDelays = nullptr;
		pWrapperTable->m_RTCContext_ScanAheadAutoDelaysAreActivated = nullptr;
		pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInMicroseconds = nullptr;
		pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInUnits = nullptr;
		pWrapperTable->m_RTCContext_SetScanAheadLineParameters = nullptr;
		pWrapperTable->m_RTCSelector_SearchCards = nullptr;
		pWrapperTable->m_RTCSelector_SearchCardsByRange = nullptr;
		pWrapperTable->m_RTCSelector_GetCardCount = nullptr;
		pWrapperTable->m_RTCSelector_GetEthernetCardCount = nullptr;
		pWrapperTable->m_RTCSelector_AcquireCard = nullptr;
		pWrapperTable->m_RTCSelector_AcquireCardBySerial = nullptr;
		pWrapperTable->m_RTCSelector_AcquireEthernetCard = nullptr;
		pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial = nullptr;
		pWrapperTable->m_Driver_ScanLab_LoadSDK = nullptr;
		pWrapperTable->m_Driver_ScanLab_LoadCustomSDK = nullptr;
		pWrapperTable->m_Driver_ScanLab_CreateRTCSelector = nullptr;
		pWrapperTable->m_Driver_ScanLab_EnableJournaling = nullptr;
		pWrapperTable->m_Driver_ScanLab_SetFirmware = nullptr;
		pWrapperTable->m_Driver_ScanLab_SetCustomFirmware = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_IsInitialized = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_Initialise = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_InitialiseFromConfiguration = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetIPAddress = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetNetmask = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetSerialNumber = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetContext = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_SetOIERecordingMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetOIERecordingMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_EnableAttributeFilter = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_DisableAttributeFilter = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetDefaultCommunicationTimeouts = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_EnableTimelagCompensation = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_DisableTimelagCompensation = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetToSimulationMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_IsSimulationMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_IsInitialized = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_ScannerIsInitialized = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetScannerCount = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScanner = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScannerFromConfiguration = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetIPAddress = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetNetmask = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSerialNumber = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetLaserIndex = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSelector = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetContext = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadFirmware = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadCustomFirmware = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCorrectionFile = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureLaserMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureDelays = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetOIERecordingMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetOIERecordingMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableAttributeFilter = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableAttributeFilter = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_DrawLayer = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetAllCommunicationTimeouts = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCommunicationTimeouts = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetCommunicationTimeouts = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetDefaultCommunicationTimeouts = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableTimelagCompensation = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableTimelagCompensation = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}

	inline LibMCDriver_ScanLabResult CWrapper::releaseWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}

	inline LibMCDriver_ScanLabResult CWrapper::loadWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_ScanLabDriver_QueryParametersExPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_queryparametersex");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_ScanLabDriver_QueryParametersExPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_queryparametersex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParametersEx == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UARTConnection_GetBaudRate = (PLibMCDriver_ScanLabUARTConnection_GetBaudRatePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_uartconnection_getbaudrate");
		#else // _WIN32
		pWrapperTable->m_UARTConnection_GetBaudRate = (PLibMCDriver_ScanLabUARTConnection_GetBaudRatePtr) dlsym(hLibrary, "libmcdriver_scanlab_uartconnection_getbaudrate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UARTConnection_GetBaudRate == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UARTConnection_GetConfiguredBaudRate = (PLibMCDriver_ScanLabUARTConnection_GetConfiguredBaudRatePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_uartconnection_getconfiguredbaudrate");
		#else // _WIN32
		pWrapperTable->m_UARTConnection_GetConfiguredBaudRate = (PLibMCDriver_ScanLabUARTConnection_GetConfiguredBaudRatePtr) dlsym(hLibrary, "libmcdriver_scanlab_uartconnection_getconfiguredbaudrate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UARTConnection_GetConfiguredBaudRate == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UARTConnection_ClearReceiveBuffer = (PLibMCDriver_ScanLabUARTConnection_ClearReceiveBufferPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_uartconnection_clearreceivebuffer");
		#else // _WIN32
		pWrapperTable->m_UARTConnection_ClearReceiveBuffer = (PLibMCDriver_ScanLabUARTConnection_ClearReceiveBufferPtr) dlsym(hLibrary, "libmcdriver_scanlab_uartconnection_clearreceivebuffer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UARTConnection_ClearReceiveBuffer == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UARTConnection_AvailableBytes = (PLibMCDriver_ScanLabUARTConnection_AvailableBytesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_uartconnection_availablebytes");
		#else // _WIN32
		pWrapperTable->m_UARTConnection_AvailableBytes = (PLibMCDriver_ScanLabUARTConnection_AvailableBytesPtr) dlsym(hLibrary, "libmcdriver_scanlab_uartconnection_availablebytes");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UARTConnection_AvailableBytes == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UARTConnection_WriteString = (PLibMCDriver_ScanLabUARTConnection_WriteStringPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_uartconnection_writestring");
		#else // _WIN32
		pWrapperTable->m_UARTConnection_WriteString = (PLibMCDriver_ScanLabUARTConnection_WriteStringPtr) dlsym(hLibrary, "libmcdriver_scanlab_uartconnection_writestring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UARTConnection_WriteString == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UARTConnection_WriteData = (PLibMCDriver_ScanLabUARTConnection_WriteDataPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_uartconnection_writedata");
		#else // _WIN32
		pWrapperTable->m_UARTConnection_WriteData = (PLibMCDriver_ScanLabUARTConnection_WriteDataPtr) dlsym(hLibrary, "libmcdriver_scanlab_uartconnection_writedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UARTConnection_WriteData == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UARTConnection_ReadData = (PLibMCDriver_ScanLabUARTConnection_ReadDataPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_uartconnection_readdata");
		#else // _WIN32
		pWrapperTable->m_UARTConnection_ReadData = (PLibMCDriver_ScanLabUARTConnection_ReadDataPtr) dlsym(hLibrary, "libmcdriver_scanlab_uartconnection_readdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UARTConnection_ReadData == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UARTConnection_ReadLine = (PLibMCDriver_ScanLabUARTConnection_ReadLinePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_uartconnection_readline");
		#else // _WIN32
		pWrapperTable->m_UARTConnection_ReadLine = (PLibMCDriver_ScanLabUARTConnection_ReadLinePtr) dlsym(hLibrary, "libmcdriver_scanlab_uartconnection_readline");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UARTConnection_ReadLine == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_DrawPolyline = (PLibMCDriver_ScanLabRTCJob_DrawPolylinePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_drawpolyline");
		#else // _WIN32
		pWrapperTable->m_RTCJob_DrawPolyline = (PLibMCDriver_ScanLabRTCJob_DrawPolylinePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_drawpolyline");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_DrawPolyline == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_DrawPolylineOIE = (PLibMCDriver_ScanLabRTCJob_DrawPolylineOIEPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_drawpolylineoie");
		#else // _WIN32
		pWrapperTable->m_RTCJob_DrawPolylineOIE = (PLibMCDriver_ScanLabRTCJob_DrawPolylineOIEPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_drawpolylineoie");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_DrawPolylineOIE == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_DrawHatches = (PLibMCDriver_ScanLabRTCJob_DrawHatchesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_drawhatches");
		#else // _WIN32
		pWrapperTable->m_RTCJob_DrawHatches = (PLibMCDriver_ScanLabRTCJob_DrawHatchesPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_drawhatches");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_DrawHatches == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddSetPower = (PLibMCDriver_ScanLabRTCJob_AddSetPowerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addsetpower");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddSetPower = (PLibMCDriver_ScanLabRTCJob_AddSetPowerPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addsetpower");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddSetPower == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddSetAnalogOut = (PLibMCDriver_ScanLabRTCJob_AddSetAnalogOutPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addsetanalogout");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddSetAnalogOut = (PLibMCDriver_ScanLabRTCJob_AddSetAnalogOutPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addsetanalogout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddSetAnalogOut == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddSetDigitalOut = (PLibMCDriver_ScanLabRTCJob_AddSetDigitalOutPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addsetdigitalout");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddSetDigitalOut = (PLibMCDriver_ScanLabRTCJob_AddSetDigitalOutPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addsetdigitalout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddSetDigitalOut == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddSetPowerForPIDControl = (PLibMCDriver_ScanLabRTCJob_AddSetPowerForPIDControlPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addsetpowerforpidcontrol");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddSetPowerForPIDControl = (PLibMCDriver_ScanLabRTCJob_AddSetPowerForPIDControlPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addsetpowerforpidcontrol");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddSetPowerForPIDControl == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddSetJumpSpeed = (PLibMCDriver_ScanLabRTCJob_AddSetJumpSpeedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addsetjumpspeed");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddSetJumpSpeed = (PLibMCDriver_ScanLabRTCJob_AddSetJumpSpeedPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addsetjumpspeed");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddSetJumpSpeed == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddSetMarkSpeed = (PLibMCDriver_ScanLabRTCJob_AddSetMarkSpeedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addsetmarkspeed");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddSetMarkSpeed = (PLibMCDriver_ScanLabRTCJob_AddSetMarkSpeedPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addsetmarkspeed");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddSetMarkSpeed == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddJumpMovement = (PLibMCDriver_ScanLabRTCJob_AddJumpMovementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addjumpmovement");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddJumpMovement = (PLibMCDriver_ScanLabRTCJob_AddJumpMovementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addjumpmovement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddJumpMovement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddMarkMovement = (PLibMCDriver_ScanLabRTCJob_AddMarkMovementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addmarkmovement");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddMarkMovement = (PLibMCDriver_ScanLabRTCJob_AddMarkMovementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addmarkmovement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddMarkMovement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddTimedMarkMovement = (PLibMCDriver_ScanLabRTCJob_AddTimedMarkMovementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addtimedmarkmovement");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddTimedMarkMovement = (PLibMCDriver_ScanLabRTCJob_AddTimedMarkMovementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addtimedmarkmovement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddTimedMarkMovement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCJob_AddFreeVariable = (PLibMCDriver_ScanLabRTCJob_AddFreeVariablePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcjob_addfreevariable");
		#else // _WIN32
		pWrapperTable->m_RTCJob_AddFreeVariable = (PLibMCDriver_ScanLabRTCJob_AddFreeVariablePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcjob_addfreevariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCJob_AddFreeVariable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_ScanheadConnectionCheckIsEnabled = (PLibMCDriver_ScanLabRTCRecording_ScanheadConnectionCheckIsEnabledPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_scanheadconnectioncheckisenabled");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_ScanheadConnectionCheckIsEnabled = (PLibMCDriver_ScanLabRTCRecording_ScanheadConnectionCheckIsEnabledPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_scanheadconnectioncheckisenabled");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_ScanheadConnectionCheckIsEnabled == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_EnableScanheadConnectionCheck = (PLibMCDriver_ScanLabRTCRecording_EnableScanheadConnectionCheckPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_enablescanheadconnectioncheck");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_EnableScanheadConnectionCheck = (PLibMCDriver_ScanLabRTCRecording_EnableScanheadConnectionCheckPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_enablescanheadconnectioncheck");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_EnableScanheadConnectionCheck == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_DisableScanheadConnectionCheck = (PLibMCDriver_ScanLabRTCRecording_DisableScanheadConnectionCheckPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_disablescanheadconnectioncheck");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_DisableScanheadConnectionCheck = (PLibMCDriver_ScanLabRTCRecording_DisableScanheadConnectionCheckPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_disablescanheadconnectioncheck");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_DisableScanheadConnectionCheck == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_Clear = (PLibMCDriver_ScanLabRTCRecording_ClearPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_clear");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_Clear = (PLibMCDriver_ScanLabRTCRecording_ClearPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_clear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_Clear == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_AddChannel = (PLibMCDriver_ScanLabRTCRecording_AddChannelPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_addchannel");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_AddChannel = (PLibMCDriver_ScanLabRTCRecording_AddChannelPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_addchannel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_AddChannel == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_RemoveChannel = (PLibMCDriver_ScanLabRTCRecording_RemoveChannelPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_removechannel");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_RemoveChannel = (PLibMCDriver_ScanLabRTCRecording_RemoveChannelPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_removechannel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_RemoveChannel == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_HasChannel = (PLibMCDriver_ScanLabRTCRecording_HasChannelPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_haschannel");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_HasChannel = (PLibMCDriver_ScanLabRTCRecording_HasChannelPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_haschannel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_HasChannel == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_GetChannelType = (PLibMCDriver_ScanLabRTCRecording_GetChannelTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_getchanneltype");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_GetChannelType = (PLibMCDriver_ScanLabRTCRecording_GetChannelTypePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_getchanneltype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_GetChannelType == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_GetRecordCount = (PLibMCDriver_ScanLabRTCRecording_GetRecordCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_getrecordcount");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_GetRecordCount = (PLibMCDriver_ScanLabRTCRecording_GetRecordCountPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_getrecordcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_GetRecordCount == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_GetRecordEntry = (PLibMCDriver_ScanLabRTCRecording_GetRecordEntryPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_getrecordentry");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_GetRecordEntry = (PLibMCDriver_ScanLabRTCRecording_GetRecordEntryPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_getrecordentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_GetRecordEntry == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_GetAllRecordEntries = (PLibMCDriver_ScanLabRTCRecording_GetAllRecordEntriesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_getallrecordentries");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_GetAllRecordEntries = (PLibMCDriver_ScanLabRTCRecording_GetAllRecordEntriesPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_getallrecordentries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_GetAllRecordEntries == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_EnableRecording = (PLibMCDriver_ScanLabRTCRecording_EnableRecordingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_enablerecording");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_EnableRecording = (PLibMCDriver_ScanLabRTCRecording_EnableRecordingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_enablerecording");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_EnableRecording == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_DisableRecording = (PLibMCDriver_ScanLabRTCRecording_DisableRecordingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_disablerecording");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_DisableRecording = (PLibMCDriver_ScanLabRTCRecording_DisableRecordingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_disablerecording");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_DisableRecording == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_ExecuteListWithRecording = (PLibMCDriver_ScanLabRTCRecording_ExecuteListWithRecordingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_executelistwithrecording");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_ExecuteListWithRecording = (PLibMCDriver_ScanLabRTCRecording_ExecuteListWithRecordingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_executelistwithrecording");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_ExecuteListWithRecording == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_AddRecordsToDataTable = (PLibMCDriver_ScanLabRTCRecording_AddRecordsToDataTablePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_addrecordstodatatable");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_AddRecordsToDataTable = (PLibMCDriver_ScanLabRTCRecording_AddRecordsToDataTablePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_addrecordstodatatable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_AddRecordsToDataTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCRecording_AddScaledRecordsToDataTable = (PLibMCDriver_ScanLabRTCRecording_AddScaledRecordsToDataTablePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcrecording_addscaledrecordstodatatable");
		#else // _WIN32
		pWrapperTable->m_RTCRecording_AddScaledRecordsToDataTable = (PLibMCDriver_ScanLabRTCRecording_AddScaledRecordsToDataTablePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcrecording_addscaledrecordstodatatable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCRecording_AddScaledRecordsToDataTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_GetIdentifier = (PLibMCDriver_ScanLabGPIOSequence_GetIdentifierPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_getidentifier");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_GetIdentifier = (PLibMCDriver_ScanLabGPIOSequence_GetIdentifierPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_getidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_GetIdentifier == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_Clear = (PLibMCDriver_ScanLabGPIOSequence_ClearPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_clear");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_Clear = (PLibMCDriver_ScanLabGPIOSequence_ClearPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_clear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_Clear == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_AddOutput = (PLibMCDriver_ScanLabGPIOSequence_AddOutputPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_addoutput");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_AddOutput = (PLibMCDriver_ScanLabGPIOSequence_AddOutputPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_addoutput");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_AddOutput == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_AddDelay = (PLibMCDriver_ScanLabGPIOSequence_AddDelayPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_adddelay");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_AddDelay = (PLibMCDriver_ScanLabGPIOSequence_AddDelayPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_adddelay");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_AddDelay == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_WaitforInput = (PLibMCDriver_ScanLabGPIOSequence_WaitforInputPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_waitforinput");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_WaitforInput = (PLibMCDriver_ScanLabGPIOSequence_WaitforInputPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_waitforinput");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_WaitforInput == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_AddLabel = (PLibMCDriver_ScanLabGPIOSequence_AddLabelPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_addlabel");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_AddLabel = (PLibMCDriver_ScanLabGPIOSequence_AddLabelPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_addlabel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_AddLabel == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_GoToLabel = (PLibMCDriver_ScanLabGPIOSequence_GoToLabelPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_gotolabel");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_GoToLabel = (PLibMCDriver_ScanLabGPIOSequence_GoToLabelPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_gotolabel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_GoToLabel == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_ConditionalGoToLabel = (PLibMCDriver_ScanLabGPIOSequence_ConditionalGoToLabelPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_conditionalgotolabel");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_ConditionalGoToLabel = (PLibMCDriver_ScanLabGPIOSequence_ConditionalGoToLabelPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_conditionalgotolabel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_ConditionalGoToLabel == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_EnableAutomaticSelection = (PLibMCDriver_ScanLabGPIOSequence_EnableAutomaticSelectionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_enableautomaticselection");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_EnableAutomaticSelection = (PLibMCDriver_ScanLabGPIOSequence_EnableAutomaticSelectionPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_enableautomaticselection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_EnableAutomaticSelection == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GPIOSequence_DisableAutomaticSelection = (PLibMCDriver_ScanLabGPIOSequence_DisableAutomaticSelectionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_gpiosequence_disableautomaticselection");
		#else // _WIN32
		pWrapperTable->m_GPIOSequence_DisableAutomaticSelection = (PLibMCDriver_ScanLabGPIOSequence_DisableAutomaticSelectionPtr) dlsym(hLibrary, "libmcdriver_scanlab_gpiosequence_disableautomaticselection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GPIOSequence_DisableAutomaticSelection == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetControlOutputPins = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetControlOutputPinsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setcontroloutputpins");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetControlOutputPins = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetControlOutputPinsPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setcontroloutputpins");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_SetControlOutputPins == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetControlOutputPins = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetControlOutputPinsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getcontroloutputpins");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetControlOutputPins = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetControlOutputPinsPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getcontroloutputpins");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_GetControlOutputPins == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetSelectionOutputPins = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetSelectionOutputPinsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setselectionoutputpins");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetSelectionOutputPins = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetSelectionOutputPinsPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setselectionoutputpins");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_SetSelectionOutputPins == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetSelectionOutputPins = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetSelectionOutputPinsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getselectionoutputpins");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetSelectionOutputPins = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetSelectionOutputPinsPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getselectionoutputpins");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_GetSelectionOutputPins == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeInputPin = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetAcknowledgeInputPinPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setacknowledgeinputpin");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeInputPin = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetAcknowledgeInputPinPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setacknowledgeinputpin");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeInputPin == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeInputPin = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetAcknowledgeInputPinPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getacknowledgeinputpin");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeInputPin = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetAcknowledgeInputPinPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getacknowledgeinputpin");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeInputPin == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetSelectionDelay = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetSelectionDelayPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setselectiondelay");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetSelectionDelay = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetSelectionDelayPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setselectiondelay");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_SetSelectionDelay == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetSelectionDelay = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetSelectionDelayPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getselectiondelay");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetSelectionDelay = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetSelectionDelayPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getselectiondelay");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_GetSelectionDelay == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeTimeout = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetAcknowledgeTimeoutPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setacknowledgetimeout");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeTimeout = (PLibMCDriver_ScanLabNLightAFXProfileSelector_SetAcknowledgeTimeoutPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_setacknowledgetimeout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeTimeout == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeTimeout = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetAcknowledgeTimeoutPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getacknowledgetimeout");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeTimeout = (PLibMCDriver_ScanLabNLightAFXProfileSelector_GetAcknowledgeTimeoutPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_getacknowledgetimeout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeTimeout == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_EnableAutomaticSelection = (PLibMCDriver_ScanLabNLightAFXProfileSelector_EnableAutomaticSelectionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_enableautomaticselection");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_EnableAutomaticSelection = (PLibMCDriver_ScanLabNLightAFXProfileSelector_EnableAutomaticSelectionPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_enableautomaticselection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_EnableAutomaticSelection == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_DisableAutomaticSelection = (PLibMCDriver_ScanLabNLightAFXProfileSelector_DisableAutomaticSelectionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_disableautomaticselection");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_DisableAutomaticSelection = (PLibMCDriver_ScanLabNLightAFXProfileSelector_DisableAutomaticSelectionPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_disableautomaticselection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_DisableAutomaticSelection == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_AddCustomSelection = (PLibMCDriver_ScanLabNLightAFXProfileSelector_AddCustomSelectionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_addcustomselection");
		#else // _WIN32
		pWrapperTable->m_NLightAFXProfileSelector_AddCustomSelection = (PLibMCDriver_ScanLabNLightAFXProfileSelector_AddCustomSelectionPtr) dlsym(hLibrary, "libmcdriver_scanlab_nlightafxprofileselector_addcustomselection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_NLightAFXProfileSelector_AddCustomSelection == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_LoadFirmware = (PLibMCDriver_ScanLabRTCContext_LoadFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_loadfirmware");
		#else // _WIN32
		pWrapperTable->m_RTCContext_LoadFirmware = (PLibMCDriver_ScanLabRTCContext_LoadFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_loadfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_LoadFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_LoadCorrectionFile = (PLibMCDriver_ScanLabRTCContext_LoadCorrectionFilePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_loadcorrectionfile");
		#else // _WIN32
		pWrapperTable->m_RTCContext_LoadCorrectionFile = (PLibMCDriver_ScanLabRTCContext_LoadCorrectionFilePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_loadcorrectionfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_LoadCorrectionFile == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SelectCorrectionTable = (PLibMCDriver_ScanLabRTCContext_SelectCorrectionTablePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_selectcorrectiontable");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SelectCorrectionTable = (PLibMCDriver_ScanLabRTCContext_SelectCorrectionTablePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_selectcorrectiontable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SelectCorrectionTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ConfigureLists = (PLibMCDriver_ScanLabRTCContext_ConfigureListsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_configurelists");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ConfigureLists = (PLibMCDriver_ScanLabRTCContext_ConfigureListsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_configurelists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ConfigureLists == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserMode = (PLibMCDriver_ScanLabRTCContext_SetLaserModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlasermode");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserMode = (PLibMCDriver_ScanLabRTCContext_SetLaserModePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlasermode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableAutoLaserControl = (PLibMCDriver_ScanLabRTCContext_DisableAutoLaserControlPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disableautolasercontrol");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableAutoLaserControl = (PLibMCDriver_ScanLabRTCContext_DisableAutoLaserControlPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disableautolasercontrol");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableAutoLaserControl == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserControlParameters = (PLibMCDriver_ScanLabRTCContext_SetLaserControlParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlasercontrolparameters");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserControlParameters = (PLibMCDriver_ScanLabRTCContext_SetLaserControlParametersPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlasercontrolparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserControlParameters == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInBitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinbits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInBitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinbits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserPulsesInBits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInMicroSecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInMicroSecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInBits = (PLibMCDriver_ScanLabRTCContext_SetStandbyInBitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinbits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInBits = (PLibMCDriver_ScanLabRTCContext_SetStandbyInBitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinbits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetStandbyInBits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetStandbyInMicroSecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetStandbyInMicroSecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetIPAddress = (PLibMCDriver_ScanLabRTCContext_GetIPAddressPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getipaddress");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetIPAddress = (PLibMCDriver_ScanLabRTCContext_GetIPAddressPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getipaddress");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetIPAddress == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetNetmask = (PLibMCDriver_ScanLabRTCContext_GetNetmaskPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getnetmask");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetNetmask = (PLibMCDriver_ScanLabRTCContext_GetNetmaskPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getnetmask");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetNetmask == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetSerialNumber = (PLibMCDriver_ScanLabRTCContext_GetSerialNumberPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getserialnumber");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetSerialNumber = (PLibMCDriver_ScanLabRTCContext_GetSerialNumberPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getserialnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetSerialNumber == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetLaserIndex = (PLibMCDriver_ScanLabRTCContext_GetLaserIndexPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserindex");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetLaserIndex = (PLibMCDriver_ScanLabRTCContext_GetLaserIndexPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetLaserIndex == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserOrigin = (PLibMCDriver_ScanLabRTCContext_SetLaserOriginPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserorigin");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserOrigin = (PLibMCDriver_ScanLabRTCContext_SetLaserOriginPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserorigin");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserOrigin == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetLaserOrigin = (PLibMCDriver_ScanLabRTCContext_GetLaserOriginPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserorigin");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetLaserOrigin = (PLibMCDriver_ScanLabRTCContext_GetLaserOriginPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserorigin");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetLaserOrigin == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserField = (PLibMCDriver_ScanLabRTCContext_SetLaserFieldPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserfield");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserField = (PLibMCDriver_ScanLabRTCContext_SetLaserFieldPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserfield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserField == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ResetLaserField = (PLibMCDriver_ScanLabRTCContext_ResetLaserFieldPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_resetlaserfield");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ResetLaserField = (PLibMCDriver_ScanLabRTCContext_ResetLaserFieldPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_resetlaserfield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ResetLaserField == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableRangeChecking = (PLibMCDriver_ScanLabRTCContext_EnableRangeCheckingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enablerangechecking");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableRangeChecking = (PLibMCDriver_ScanLabRTCContext_EnableRangeCheckingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enablerangechecking");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableRangeChecking == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableRangeChecking = (PLibMCDriver_ScanLabRTCContext_DisableRangeCheckingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disablerangechecking");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableRangeChecking = (PLibMCDriver_ScanLabRTCContext_DisableRangeCheckingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disablerangechecking");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableRangeChecking == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetLaserField = (PLibMCDriver_ScanLabRTCContext_GetLaserFieldPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserfield");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetLaserField = (PLibMCDriver_ScanLabRTCContext_GetLaserFieldPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserfield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetLaserField == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetStartList = (PLibMCDriver_ScanLabRTCContext_SetStartListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setstartlist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetStartList = (PLibMCDriver_ScanLabRTCContext_SetStartListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setstartlist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetStartList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetEndOfList = (PLibMCDriver_ScanLabRTCContext_SetEndOfListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setendoflist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetEndOfList = (PLibMCDriver_ScanLabRTCContext_SetEndOfListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setendoflist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetEndOfList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ExecuteList = (PLibMCDriver_ScanLabRTCContext_ExecuteListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_executelist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ExecuteList = (PLibMCDriver_ScanLabRTCContext_ExecuteListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_executelist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ExecuteList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetAutoChangePos = (PLibMCDriver_ScanLabRTCContext_SetAutoChangePosPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setautochangepos");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetAutoChangePos = (PLibMCDriver_ScanLabRTCContext_SetAutoChangePosPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setautochangepos");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetAutoChangePos == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetDelays = (PLibMCDriver_ScanLabRTCContext_SetDelaysPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setdelays");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetDelays = (PLibMCDriver_ScanLabRTCContext_SetDelaysPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setdelays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetDelays == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInMicrosecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInBitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinbits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInBitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinbits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserDelaysInBits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DrawPolyline = (PLibMCDriver_ScanLabRTCContext_DrawPolylinePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_drawpolyline");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DrawPolyline = (PLibMCDriver_ScanLabRTCContext_DrawPolylinePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_drawpolyline");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DrawPolyline == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DrawPolylineOIE = (PLibMCDriver_ScanLabRTCContext_DrawPolylineOIEPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_drawpolylineoie");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DrawPolylineOIE = (PLibMCDriver_ScanLabRTCContext_DrawPolylineOIEPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_drawpolylineoie");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DrawPolylineOIE == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DrawHatches = (PLibMCDriver_ScanLabRTCContext_DrawHatchesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_drawhatches");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DrawHatches = (PLibMCDriver_ScanLabRTCContext_DrawHatchesPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_drawhatches");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DrawHatches == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddSetPower = (PLibMCDriver_ScanLabRTCContext_AddSetPowerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addsetpower");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddSetPower = (PLibMCDriver_ScanLabRTCContext_AddSetPowerPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addsetpower");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddSetPower == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddSetAnalogOut = (PLibMCDriver_ScanLabRTCContext_AddSetAnalogOutPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addsetanalogout");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddSetAnalogOut = (PLibMCDriver_ScanLabRTCContext_AddSetAnalogOutPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addsetanalogout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddSetAnalogOut == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddSetDigitalOut = (PLibMCDriver_ScanLabRTCContext_AddSetDigitalOutPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addsetdigitalout");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddSetDigitalOut = (PLibMCDriver_ScanLabRTCContext_AddSetDigitalOutPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addsetdigitalout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddSetDigitalOut == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddSetPowerForPIDControl = (PLibMCDriver_ScanLabRTCContext_AddSetPowerForPIDControlPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addsetpowerforpidcontrol");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddSetPowerForPIDControl = (PLibMCDriver_ScanLabRTCContext_AddSetPowerForPIDControlPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addsetpowerforpidcontrol");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddSetPowerForPIDControl == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddSetJumpSpeed = (PLibMCDriver_ScanLabRTCContext_AddSetJumpSpeedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addsetjumpspeed");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddSetJumpSpeed = (PLibMCDriver_ScanLabRTCContext_AddSetJumpSpeedPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addsetjumpspeed");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddSetJumpSpeed == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddSetMarkSpeed = (PLibMCDriver_ScanLabRTCContext_AddSetMarkSpeedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addsetmarkspeed");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddSetMarkSpeed = (PLibMCDriver_ScanLabRTCContext_AddSetMarkSpeedPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addsetmarkspeed");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddSetMarkSpeed == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddJumpMovement = (PLibMCDriver_ScanLabRTCContext_AddJumpMovementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addjumpmovement");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddJumpMovement = (PLibMCDriver_ScanLabRTCContext_AddJumpMovementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addjumpmovement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddJumpMovement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddMarkMovement = (PLibMCDriver_ScanLabRTCContext_AddMarkMovementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addmarkmovement");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddMarkMovement = (PLibMCDriver_ScanLabRTCContext_AddMarkMovementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addmarkmovement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddMarkMovement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddTimedMarkMovement = (PLibMCDriver_ScanLabRTCContext_AddTimedMarkMovementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addtimedmarkmovement");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddTimedMarkMovement = (PLibMCDriver_ScanLabRTCContext_AddTimedMarkMovementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addtimedmarkmovement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddTimedMarkMovement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddFreeVariable = (PLibMCDriver_ScanLabRTCContext_AddFreeVariablePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addfreevariable");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddFreeVariable = (PLibMCDriver_ScanLabRTCContext_AddFreeVariablePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addfreevariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddFreeVariable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetCurrentFreeVariable = (PLibMCDriver_ScanLabRTCContext_GetCurrentFreeVariablePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getcurrentfreevariable");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetCurrentFreeVariable = (PLibMCDriver_ScanLabRTCContext_GetCurrentFreeVariablePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getcurrentfreevariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetCurrentFreeVariable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetTimeStamp = (PLibMCDriver_ScanLabRTCContext_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetTimeStamp = (PLibMCDriver_ScanLabRTCContext_GetTimeStampPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetTimeStamp == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetRTCChannel = (PLibMCDriver_ScanLabRTCContext_GetRTCChannelPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcchannel");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetRTCChannel = (PLibMCDriver_ScanLabRTCContext_GetRTCChannelPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcchannel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetRTCChannel == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetRTCInternalValue = (PLibMCDriver_ScanLabRTCContext_GetRTCInternalValuePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcinternalvalue");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetRTCInternalValue = (PLibMCDriver_ScanLabRTCContext_GetRTCInternalValuePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcinternalvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetRTCInternalValue == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_StopExecution = (PLibMCDriver_ScanLabRTCContext_StopExecutionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_stopexecution");
		#else // _WIN32
		pWrapperTable->m_RTCContext_StopExecution = (PLibMCDriver_ScanLabRTCContext_StopExecutionPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_stopexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_StopExecution == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DrawHatchesOIE = (PLibMCDriver_ScanLabRTCContext_DrawHatchesOIEPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_drawhatchesoie");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DrawHatchesOIE = (PLibMCDriver_ScanLabRTCContext_DrawHatchesOIEPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_drawhatchesoie");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DrawHatchesOIE == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddLayerToList = (PLibMCDriver_ScanLabRTCContext_AddLayerToListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addlayertolist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddLayerToList = (PLibMCDriver_ScanLabRTCContext_AddLayerToListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addlayertolist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddLayerToList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_WaitForEncoderX = (PLibMCDriver_ScanLabRTCContext_WaitForEncoderXPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_waitforencoderx");
		#else // _WIN32
		pWrapperTable->m_RTCContext_WaitForEncoderX = (PLibMCDriver_ScanLabRTCContext_WaitForEncoderXPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_waitforencoderx");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_WaitForEncoderX == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_WaitForEncoderY = (PLibMCDriver_ScanLabRTCContext_WaitForEncoderYPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_waitforencodery");
		#else // _WIN32
		pWrapperTable->m_RTCContext_WaitForEncoderY = (PLibMCDriver_ScanLabRTCContext_WaitForEncoderYPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_waitforencodery");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_WaitForEncoderY == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_WaitForEncoderXSteps = (PLibMCDriver_ScanLabRTCContext_WaitForEncoderXStepsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_waitforencoderxsteps");
		#else // _WIN32
		pWrapperTable->m_RTCContext_WaitForEncoderXSteps = (PLibMCDriver_ScanLabRTCContext_WaitForEncoderXStepsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_waitforencoderxsteps");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_WaitForEncoderXSteps == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_WaitForEncoderYSteps = (PLibMCDriver_ScanLabRTCContext_WaitForEncoderYStepsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_waitforencoderysteps");
		#else // _WIN32
		pWrapperTable->m_RTCContext_WaitForEncoderYSteps = (PLibMCDriver_ScanLabRTCContext_WaitForEncoderYStepsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_waitforencoderysteps");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_WaitForEncoderYSteps == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddCustomDelay = (PLibMCDriver_ScanLabRTCContext_AddCustomDelayPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addcustomdelay");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddCustomDelay = (PLibMCDriver_ScanLabRTCContext_AddCustomDelayPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addcustomdelay");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddCustomDelay == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetCorrectionFactor = (PLibMCDriver_ScanLabRTCContext_GetCorrectionFactorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getcorrectionfactor");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetCorrectionFactor = (PLibMCDriver_ScanLabRTCContext_GetCorrectionFactorPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getcorrectionfactor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetCorrectionFactor == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetStatus = (PLibMCDriver_ScanLabRTCContext_GetStatusPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getstatus");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetStatus = (PLibMCDriver_ScanLabRTCContext_GetStatusPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetStatus == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetHeadStatus = (PLibMCDriver_ScanLabRTCContext_GetHeadStatusPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getheadstatus");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetHeadStatus = (PLibMCDriver_ScanLabRTCContext_GetHeadStatusPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getheadstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetHeadStatus == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetStateValues = (PLibMCDriver_ScanLabRTCContext_GetStateValuesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getstatevalues");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetStateValues = (PLibMCDriver_ScanLabRTCContext_GetStateValuesPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getstatevalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetStateValues == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetInputPointer = (PLibMCDriver_ScanLabRTCContext_GetInputPointerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getinputpointer");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetInputPointer = (PLibMCDriver_ScanLabRTCContext_GetInputPointerPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getinputpointer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetInputPointer == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetRTCVersion = (PLibMCDriver_ScanLabRTCContext_GetRTCVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcversion");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetRTCVersion = (PLibMCDriver_ScanLabRTCContext_GetRTCVersionPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetRTCVersion == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetCommunicationTimeouts = (PLibMCDriver_ScanLabRTCContext_SetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetCommunicationTimeouts = (PLibMCDriver_ScanLabRTCContext_SetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetCommunicationTimeouts = (PLibMCDriver_ScanLabRTCContext_GetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetCommunicationTimeouts = (PLibMCDriver_ScanLabRTCContext_GetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_InitializeForOIE = (PLibMCDriver_ScanLabRTCContext_InitializeForOIEPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_initializeforoie");
		#else // _WIN32
		pWrapperTable->m_RTCContext_InitializeForOIE = (PLibMCDriver_ScanLabRTCContext_InitializeForOIEPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_initializeforoie");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_InitializeForOIE == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserPinOut = (PLibMCDriver_ScanLabRTCContext_SetLaserPinOutPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpinout");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserPinOut = (PLibMCDriver_ScanLabRTCContext_SetLaserPinOutPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpinout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserPinOut == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetLaserPinIn = (PLibMCDriver_ScanLabRTCContext_GetLaserPinInPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserpinin");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetLaserPinIn = (PLibMCDriver_ScanLabRTCContext_GetLaserPinInPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserpinin");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetLaserPinIn == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddLaserPinOutToList = (PLibMCDriver_ScanLabRTCContext_AddLaserPinOutToListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addlaserpinouttolist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddLaserPinOutToList = (PLibMCDriver_ScanLabRTCContext_AddLaserPinOutToListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addlaserpinouttolist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddLaserPinOutToList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddWriteDigitalIOList = (PLibMCDriver_ScanLabRTCContext_AddWriteDigitalIOListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addwritedigitaliolist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddWriteDigitalIOList = (PLibMCDriver_ScanLabRTCContext_AddWriteDigitalIOListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addwritedigitaliolist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddWriteDigitalIOList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddWriteMaskedDigitalIOList = (PLibMCDriver_ScanLabRTCContext_AddWriteMaskedDigitalIOListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addwritemaskeddigitaliolist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddWriteMaskedDigitalIOList = (PLibMCDriver_ScanLabRTCContext_AddWriteMaskedDigitalIOListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addwritemaskeddigitaliolist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddWriteMaskedDigitalIOList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableOIE = (PLibMCDriver_ScanLabRTCContext_EnableOIEPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableoie");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableOIE = (PLibMCDriver_ScanLabRTCContext_EnableOIEPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableoie");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableOIE == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableOIE = (PLibMCDriver_ScanLabRTCContext_DisableOIEPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disableoie");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableOIE = (PLibMCDriver_ScanLabRTCContext_DisableOIEPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disableoie");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableOIE == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_CreateNLightAFXBeamProfileSelector = (PLibMCDriver_ScanLabRTCContext_CreateNLightAFXBeamProfileSelectorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_createnlightafxbeamprofileselector");
		#else // _WIN32
		pWrapperTable->m_RTCContext_CreateNLightAFXBeamProfileSelector = (PLibMCDriver_ScanLabRTCContext_CreateNLightAFXBeamProfileSelectorPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_createnlightafxbeamprofileselector");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_CreateNLightAFXBeamProfileSelector == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddGPIOSequence = (PLibMCDriver_ScanLabRTCContext_AddGPIOSequencePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addgpiosequence");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddGPIOSequence = (PLibMCDriver_ScanLabRTCContext_AddGPIOSequencePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addgpiosequence");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddGPIOSequence == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_WriteGPIOSequenceToList = (PLibMCDriver_ScanLabRTCContext_WriteGPIOSequenceToListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_writegpiosequencetolist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_WriteGPIOSequenceToList = (PLibMCDriver_ScanLabRTCContext_WriteGPIOSequenceToListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_writegpiosequencetolist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_WriteGPIOSequenceToList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_FindGPIOSequence = (PLibMCDriver_ScanLabRTCContext_FindGPIOSequencePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_findgpiosequence");
		#else // _WIN32
		pWrapperTable->m_RTCContext_FindGPIOSequence = (PLibMCDriver_ScanLabRTCContext_FindGPIOSequencePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_findgpiosequence");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_FindGPIOSequence == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DeleteGPIOSequence = (PLibMCDriver_ScanLabRTCContext_DeleteGPIOSequencePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_deletegpiosequence");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DeleteGPIOSequence = (PLibMCDriver_ScanLabRTCContext_DeleteGPIOSequencePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_deletegpiosequence");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DeleteGPIOSequence == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_StartOIEMeasurement = (PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_startoiemeasurement");
		#else // _WIN32
		pWrapperTable->m_RTCContext_StartOIEMeasurement = (PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_startoiemeasurement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_StartOIEMeasurement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_StartOIEMeasurementEx = (PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementExPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_startoiemeasurementex");
		#else // _WIN32
		pWrapperTable->m_RTCContext_StartOIEMeasurementEx = (PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementExPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_startoiemeasurementex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_StartOIEMeasurementEx == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_StopOIEMeasurement = (PLibMCDriver_ScanLabRTCContext_StopOIEMeasurementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_stopoiemeasurement");
		#else // _WIN32
		pWrapperTable->m_RTCContext_StopOIEMeasurement = (PLibMCDriver_ScanLabRTCContext_StopOIEMeasurementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_stopoiemeasurement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_StopOIEMeasurement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetOIEPIDMode = (PLibMCDriver_ScanLabRTCContext_SetOIEPIDModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setoiepidmode");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetOIEPIDMode = (PLibMCDriver_ScanLabRTCContext_SetOIEPIDModePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setoiepidmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetOIEPIDMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableOIEPIDControl = (PLibMCDriver_ScanLabRTCContext_EnableOIEPIDControlPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableoiepidcontrol");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableOIEPIDControl = (PLibMCDriver_ScanLabRTCContext_EnableOIEPIDControlPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableoiepidcontrol");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableOIEPIDControl == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableOIEPIDControl = (PLibMCDriver_ScanLabRTCContext_DisableOIEPIDControlPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disableoiepidcontrol");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableOIEPIDControl = (PLibMCDriver_ScanLabRTCContext_DisableOIEPIDControlPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disableoiepidcontrol");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableOIEPIDControl == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ClearOIEMeasurementTags = (PLibMCDriver_ScanLabRTCContext_ClearOIEMeasurementTagsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_clearoiemeasurementtags");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ClearOIEMeasurementTags = (PLibMCDriver_ScanLabRTCContext_ClearOIEMeasurementTagsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_clearoiemeasurementtags");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ClearOIEMeasurementTags == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableOIEMeasurementTagging = (PLibMCDriver_ScanLabRTCContext_EnableOIEMeasurementTaggingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableoiemeasurementtagging");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableOIEMeasurementTagging = (PLibMCDriver_ScanLabRTCContext_EnableOIEMeasurementTaggingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableoiemeasurementtagging");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableOIEMeasurementTagging == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableOIEMeasurementTagging = (PLibMCDriver_ScanLabRTCContext_DisableOIEMeasurementTaggingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disableoiemeasurementtagging");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableOIEMeasurementTagging = (PLibMCDriver_ScanLabRTCContext_DisableOIEMeasurementTaggingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disableoiemeasurementtagging");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableOIEMeasurementTagging == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetOIEMaxMeasurementTag = (PLibMCDriver_ScanLabRTCContext_GetOIEMaxMeasurementTagPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getoiemaxmeasurementtag");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetOIEMaxMeasurementTag = (PLibMCDriver_ScanLabRTCContext_GetOIEMaxMeasurementTagPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getoiemaxmeasurementtag");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetOIEMaxMeasurementTag == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_MapOIEMeasurementTag = (PLibMCDriver_ScanLabRTCContext_MapOIEMeasurementTagPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_mapoiemeasurementtag");
		#else // _WIN32
		pWrapperTable->m_RTCContext_MapOIEMeasurementTag = (PLibMCDriver_ScanLabRTCContext_MapOIEMeasurementTagPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_mapoiemeasurementtag");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_MapOIEMeasurementTag == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableSkyWriting = (PLibMCDriver_ScanLabRTCContext_DisableSkyWritingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disableskywriting");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableSkyWriting = (PLibMCDriver_ScanLabRTCContext_DisableSkyWritingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disableskywriting");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableSkyWriting == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode1 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode1Ptr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode1");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode1 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode1Ptr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode1");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableSkyWritingMode1 == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode2 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode2Ptr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode2");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode2 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode2Ptr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableSkyWritingMode2 == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode3 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode3Ptr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode3");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode3 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode3Ptr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode3");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableSkyWritingMode3 == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode4 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode4Ptr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode4");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode4 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode4Ptr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode4");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableSkyWritingMode4 == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetTransformationAngle = (PLibMCDriver_ScanLabRTCContext_SetTransformationAnglePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_settransformationangle");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetTransformationAngle = (PLibMCDriver_ScanLabRTCContext_SetTransformationAnglePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_settransformationangle");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetTransformationAngle == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetTransformationScale = (PLibMCDriver_ScanLabRTCContext_SetTransformationScalePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_settransformationscale");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetTransformationScale = (PLibMCDriver_ScanLabRTCContext_SetTransformationScalePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_settransformationscale");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetTransformationScale == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetTransformationOffset = (PLibMCDriver_ScanLabRTCContext_SetTransformationOffsetPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_settransformationoffset");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetTransformationOffset = (PLibMCDriver_ScanLabRTCContext_SetTransformationOffsetPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_settransformationoffset");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetTransformationOffset == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetTransformationMatrix = (PLibMCDriver_ScanLabRTCContext_SetTransformationMatrixPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_settransformationmatrix");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetTransformationMatrix = (PLibMCDriver_ScanLabRTCContext_SetTransformationMatrixPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_settransformationmatrix");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetTransformationMatrix == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_PrepareRecording = (PLibMCDriver_ScanLabRTCContext_PrepareRecordingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_preparerecording");
		#else // _WIN32
		pWrapperTable->m_RTCContext_PrepareRecording = (PLibMCDriver_ScanLabRTCContext_PrepareRecordingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_preparerecording");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_PrepareRecording == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_HasRecording = (PLibMCDriver_ScanLabRTCContext_HasRecordingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_hasrecording");
		#else // _WIN32
		pWrapperTable->m_RTCContext_HasRecording = (PLibMCDriver_ScanLabRTCContext_HasRecordingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_hasrecording");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_HasRecording == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_FindRecording = (PLibMCDriver_ScanLabRTCContext_FindRecordingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_findrecording");
		#else // _WIN32
		pWrapperTable->m_RTCContext_FindRecording = (PLibMCDriver_ScanLabRTCContext_FindRecordingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_findrecording");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_FindRecording == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableTimelagCompensation = (PLibMCDriver_ScanLabRTCContext_EnableTimelagCompensationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enabletimelagcompensation");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableTimelagCompensation = (PLibMCDriver_ScanLabRTCContext_EnableTimelagCompensationPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enabletimelagcompensation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableTimelagCompensation == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableTimelagCompensation = (PLibMCDriver_ScanLabRTCContext_DisableTimelagCompensationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disabletimelagcompensation");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableTimelagCompensation = (PLibMCDriver_ScanLabRTCContext_DisableTimelagCompensationPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disabletimelagcompensation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableTimelagCompensation == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableMarkOnTheFly2D = (PLibMCDriver_ScanLabRTCContext_EnableMarkOnTheFly2DPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enablemarkonthefly2d");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableMarkOnTheFly2D = (PLibMCDriver_ScanLabRTCContext_EnableMarkOnTheFly2DPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enablemarkonthefly2d");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableMarkOnTheFly2D == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableMarkOnTheFly2D = (PLibMCDriver_ScanLabRTCContext_DisableMarkOnTheFly2DPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disablemarkonthefly2d");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableMarkOnTheFly2D = (PLibMCDriver_ScanLabRTCContext_DisableMarkOnTheFly2DPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disablemarkonthefly2d");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableMarkOnTheFly2D == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_MarkOnTheFly2DIsEnabled = (PLibMCDriver_ScanLabRTCContext_MarkOnTheFly2DIsEnabledPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_markonthefly2disenabled");
		#else // _WIN32
		pWrapperTable->m_RTCContext_MarkOnTheFly2DIsEnabled = (PLibMCDriver_ScanLabRTCContext_MarkOnTheFly2DIsEnabledPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_markonthefly2disenabled");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_MarkOnTheFly2DIsEnabled == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_Get2DMarkOnTheFlyPosition = (PLibMCDriver_ScanLabRTCContext_Get2DMarkOnTheFlyPositionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_get2dmarkontheflyposition");
		#else // _WIN32
		pWrapperTable->m_RTCContext_Get2DMarkOnTheFlyPosition = (PLibMCDriver_ScanLabRTCContext_Get2DMarkOnTheFlyPositionPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_get2dmarkontheflyposition");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_Get2DMarkOnTheFlyPosition == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_CheckOnTheFlyError = (PLibMCDriver_ScanLabRTCContext_CheckOnTheFlyErrorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_checkontheflyerror");
		#else // _WIN32
		pWrapperTable->m_RTCContext_CheckOnTheFlyError = (PLibMCDriver_ScanLabRTCContext_CheckOnTheFlyErrorPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_checkontheflyerror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_CheckOnTheFlyError == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_LaserPowerCalibrationIsEnabled = (PLibMCDriver_ScanLabRTCContext_LaserPowerCalibrationIsEnabledPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_laserpowercalibrationisenabled");
		#else // _WIN32
		pWrapperTable->m_RTCContext_LaserPowerCalibrationIsEnabled = (PLibMCDriver_ScanLabRTCContext_LaserPowerCalibrationIsEnabledPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_laserpowercalibrationisenabled");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_LaserPowerCalibrationIsEnabled == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_LaserPowerCalibrationIsLinear = (PLibMCDriver_ScanLabRTCContext_LaserPowerCalibrationIsLinearPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_laserpowercalibrationislinear");
		#else // _WIN32
		pWrapperTable->m_RTCContext_LaserPowerCalibrationIsLinear = (PLibMCDriver_ScanLabRTCContext_LaserPowerCalibrationIsLinearPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_laserpowercalibrationislinear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_LaserPowerCalibrationIsLinear == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ClearLaserPowerCalibration = (PLibMCDriver_ScanLabRTCContext_ClearLaserPowerCalibrationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_clearlaserpowercalibration");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ClearLaserPowerCalibration = (PLibMCDriver_ScanLabRTCContext_ClearLaserPowerCalibrationPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_clearlaserpowercalibration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ClearLaserPowerCalibration == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetLaserPowerCalibration = (PLibMCDriver_ScanLabRTCContext_GetLaserPowerCalibrationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserpowercalibration");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetLaserPowerCalibration = (PLibMCDriver_ScanLabRTCContext_GetLaserPowerCalibrationPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getlaserpowercalibration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetLaserPowerCalibration == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLinearLaserPowerCalibration = (PLibMCDriver_ScanLabRTCContext_SetLinearLaserPowerCalibrationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlinearlaserpowercalibration");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLinearLaserPowerCalibration = (PLibMCDriver_ScanLabRTCContext_SetLinearLaserPowerCalibrationPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlinearlaserpowercalibration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLinearLaserPowerCalibration == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetPiecewiseLinearLaserPowerCalibration = (PLibMCDriver_ScanLabRTCContext_SetPiecewiseLinearLaserPowerCalibrationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setpiecewiselinearlaserpowercalibration");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetPiecewiseLinearLaserPowerCalibration = (PLibMCDriver_ScanLabRTCContext_SetPiecewiseLinearLaserPowerCalibrationPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setpiecewiselinearlaserpowercalibration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetPiecewiseLinearLaserPowerCalibration == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableSpatialLaserPowerModulation = (PLibMCDriver_ScanLabRTCContext_EnableSpatialLaserPowerModulationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enablespatiallaserpowermodulation");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableSpatialLaserPowerModulation = (PLibMCDriver_ScanLabRTCContext_EnableSpatialLaserPowerModulationPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enablespatiallaserpowermodulation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableSpatialLaserPowerModulation == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisablePowerModulation = (PLibMCDriver_ScanLabRTCContext_DisablePowerModulationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disablepowermodulation");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisablePowerModulation = (PLibMCDriver_ScanLabRTCContext_DisablePowerModulationPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disablepowermodulation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisablePowerModulation == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableLineSubdivision = (PLibMCDriver_ScanLabRTCContext_EnableLineSubdivisionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enablelinesubdivision");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableLineSubdivision = (PLibMCDriver_ScanLabRTCContext_EnableLineSubdivisionPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enablelinesubdivision");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableLineSubdivision == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableLineSubdivision = (PLibMCDriver_ScanLabRTCContext_DisableLineSubdivisionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disablelinesubdivision");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableLineSubdivision = (PLibMCDriver_ScanLabRTCContext_DisableLineSubdivisionPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disablelinesubdivision");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableLineSubdivision == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ReadMultiMCBSP = (PLibMCDriver_ScanLabRTCContext_ReadMultiMCBSPPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_readmultimcbsp");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ReadMultiMCBSP = (PLibMCDriver_ScanLabRTCContext_ReadMultiMCBSPPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_readmultimcbsp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ReadMultiMCBSP == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_CreateUARTConnection = (PLibMCDriver_ScanLabRTCContext_CreateUARTConnectionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_createuartconnection");
		#else // _WIN32
		pWrapperTable->m_RTCContext_CreateUARTConnection = (PLibMCDriver_ScanLabRTCContext_CreateUARTConnectionPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_createuartconnection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_CreateUARTConnection == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableScanAhead = (PLibMCDriver_ScanLabRTCContext_EnableScanAheadPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enablescanahead");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableScanAhead = (PLibMCDriver_ScanLabRTCContext_EnableScanAheadPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enablescanahead");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableScanAhead == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableScanAhead = (PLibMCDriver_ScanLabRTCContext_DisableScanAheadPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disablescanahead");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableScanAhead = (PLibMCDriver_ScanLabRTCContext_DisableScanAheadPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disablescanahead");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableScanAhead == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ActivateScanAheadAutoDelays = (PLibMCDriver_ScanLabRTCContext_ActivateScanAheadAutoDelaysPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_activatescanaheadautodelays");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ActivateScanAheadAutoDelays = (PLibMCDriver_ScanLabRTCContext_ActivateScanAheadAutoDelaysPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_activatescanaheadautodelays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ActivateScanAheadAutoDelays == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DeactivateScanAheadAutoDelays = (PLibMCDriver_ScanLabRTCContext_DeactivateScanAheadAutoDelaysPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_deactivatescanaheadautodelays");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DeactivateScanAheadAutoDelays = (PLibMCDriver_ScanLabRTCContext_DeactivateScanAheadAutoDelaysPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_deactivatescanaheadautodelays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DeactivateScanAheadAutoDelays == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ScanAheadAutoDelaysAreActivated = (PLibMCDriver_ScanLabRTCContext_ScanAheadAutoDelaysAreActivatedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_scanaheadautodelaysareactivated");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ScanAheadAutoDelaysAreActivated = (PLibMCDriver_ScanLabRTCContext_ScanAheadAutoDelaysAreActivatedPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_scanaheadautodelaysareactivated");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ScanAheadAutoDelaysAreActivated == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInMicroseconds = (PLibMCDriver_ScanLabRTCContext_SetScanAheadLaserShiftsInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInMicroseconds = (PLibMCDriver_ScanLabRTCContext_SetScanAheadLaserShiftsInMicrosecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInMicroseconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInUnits = (PLibMCDriver_ScanLabRTCContext_SetScanAheadLaserShiftsInUnitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinunits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInUnits = (PLibMCDriver_ScanLabRTCContext_SetScanAheadLaserShiftsInUnitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinunits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInUnits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetScanAheadLineParameters = (PLibMCDriver_ScanLabRTCContext_SetScanAheadLineParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setscanaheadlineparameters");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetScanAheadLineParameters = (PLibMCDriver_ScanLabRTCContext_SetScanAheadLineParametersPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setscanaheadlineparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetScanAheadLineParameters == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_SearchCards = (PLibMCDriver_ScanLabRTCSelector_SearchCardsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_searchcards");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_SearchCards = (PLibMCDriver_ScanLabRTCSelector_SearchCardsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_searchcards");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_SearchCards == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_SearchCardsByRange = (PLibMCDriver_ScanLabRTCSelector_SearchCardsByRangePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_searchcardsbyrange");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_SearchCardsByRange = (PLibMCDriver_ScanLabRTCSelector_SearchCardsByRangePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_searchcardsbyrange");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_SearchCardsByRange == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_GetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetCardCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_getcardcount");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_GetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetCardCountPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_getcardcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_GetCardCount == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_GetEthernetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetEthernetCardCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_getethernetcardcount");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_GetEthernetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetEthernetCardCountPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_getethernetcardcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_GetEthernetCardCount == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireCard = (PLibMCDriver_ScanLabRTCSelector_AcquireCardPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecard");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireCard = (PLibMCDriver_ScanLabRTCSelector_AcquireCardPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecard");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireCard == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireCardBySerialPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecardbyserial");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireCardBySerialPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecardbyserial");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireCardBySerial == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCard = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcard");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCard = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcard");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireEthernetCard == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardBySerialPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardBySerialPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadsdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadSDKPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadsdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_LoadSDK == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadCustomSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadCustomSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadcustomsdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadCustomSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadCustomSDKPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadcustomsdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_LoadCustomSDK == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_CreateRTCSelector = (PLibMCDriver_ScanLabDriver_ScanLab_CreateRTCSelectorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_creatertcselector");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_CreateRTCSelector = (PLibMCDriver_ScanLabDriver_ScanLab_CreateRTCSelectorPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_creatertcselector");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_CreateRTCSelector == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_EnableJournaling = (PLibMCDriver_ScanLabDriver_ScanLab_EnableJournalingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_enablejournaling");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_EnableJournaling = (PLibMCDriver_ScanLabDriver_ScanLab_EnableJournalingPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_enablejournaling");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_EnableJournaling == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_SetFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_SetFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_setfirmware");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_SetFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_SetFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_setfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_SetFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_SetCustomFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_SetCustomFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_setcustomfirmware");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_SetCustomFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_SetCustomFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_setcustomfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_SetCustomFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetToSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_settosimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetToSimulationModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_settosimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_issimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsSimulationModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_issimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_IsInitialized = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsInitializedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_isinitialized");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_IsInitialized = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsInitializedPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_isinitialized");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_IsInitialized == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_Initialise = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialisePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_initialise");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_Initialise = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialisePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_initialise");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_Initialise == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_InitialiseFromConfiguration = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialiseFromConfigurationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_initialisefromconfiguration");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_InitialiseFromConfiguration = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialiseFromConfigurationPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_initialisefromconfiguration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_InitialiseFromConfiguration == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetIPAddress = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetIPAddressPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getipaddress");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetIPAddress = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetIPAddressPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getipaddress");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetIPAddress == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetNetmask = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetNetmaskPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getnetmask");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetNetmask = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetNetmaskPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getnetmask");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetNetmask == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetSerialNumber = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSerialNumberPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getserialnumber");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetSerialNumber = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSerialNumberPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getserialnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetSerialNumber == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetContext = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetContextPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getcontext");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetContext = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetContextPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getcontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetContext == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSelectorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getselector");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSelectorPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getselector");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_loadfirmware");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_loadfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadCustomFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_loadcustomfirmware");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadCustomFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_loadcustomfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCorrectionFilePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setcorrectionfile");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCorrectionFilePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setcorrectionfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureLaserModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_configurelasermode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureLaserModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_configurelasermode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureDelaysPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_configuredelays");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureDelaysPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_configuredelays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetOIERecordingMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetOIERecordingModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setoierecordingmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetOIERecordingMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetOIERecordingModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setoierecordingmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_SetOIERecordingMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetOIERecordingMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetOIERecordingModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getoierecordingmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetOIERecordingMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetOIERecordingModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getoierecordingmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetOIERecordingMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_EnableAttributeFilter = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_EnableAttributeFilterPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_enableattributefilter");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_EnableAttributeFilter = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_EnableAttributeFilterPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_enableattributefilter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_EnableAttributeFilter == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_DisableAttributeFilter = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DisableAttributeFilterPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_disableattributefilter");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_DisableAttributeFilter = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DisableAttributeFilterPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_disableattributefilter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_DisableAttributeFilter == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DrawLayerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_drawlayer");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DrawLayerPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_drawlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetDefaultCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetDefaultCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getdefaultcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetDefaultCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetDefaultCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getdefaultcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetDefaultCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_EnableTimelagCompensation = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_EnableTimelagCompensationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_enabletimelagcompensation");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_EnableTimelagCompensation = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_EnableTimelagCompensationPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_enabletimelagcompensation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_EnableTimelagCompensation == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_DisableTimelagCompensation = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DisableTimelagCompensationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_disabletimelagcompensation");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_DisableTimelagCompensation = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DisableTimelagCompensationPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_disabletimelagcompensation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_DisableTimelagCompensation == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetToSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetToSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_settosimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetToSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetToSimulationModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_settosimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetToSimulationMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_IsSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_IsSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_issimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_IsSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_IsSimulationModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_issimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_IsSimulationMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_IsInitialized = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_IsInitializedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_isinitialized");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_IsInitialized = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_IsInitializedPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_isinitialized");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_IsInitialized == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_ScannerIsInitialized = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ScannerIsInitializedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_scannerisinitialized");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_ScannerIsInitialized = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ScannerIsInitializedPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_scannerisinitialized");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_ScannerIsInitialized == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetScannerCount = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetScannerCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getscannercount");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetScannerCount = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetScannerCountPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getscannercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetScannerCount == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScanner = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_InitialiseScannerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescanner");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScanner = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_InitialiseScannerPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescanner");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScanner == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScannerFromConfiguration = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_InitialiseScannerFromConfigurationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescannerfromconfiguration");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScannerFromConfiguration = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_InitialiseScannerFromConfigurationPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescannerfromconfiguration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScannerFromConfiguration == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetIPAddress = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetIPAddressPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getipaddress");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetIPAddress = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetIPAddressPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getipaddress");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetIPAddress == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetNetmask = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetNetmaskPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getnetmask");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetNetmask = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetNetmaskPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getnetmask");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetNetmask == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSerialNumber = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetSerialNumberPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getserialnumber");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSerialNumber = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetSerialNumberPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getserialnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSerialNumber == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetLaserIndex = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetLaserIndexPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getlaserindex");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetLaserIndex = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetLaserIndexPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getlaserindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetLaserIndex == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSelector = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetSelectorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getselector");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSelector = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetSelectorPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getselector");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSelector == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetContext = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetContextPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getcontext");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetContext = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetContextPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getcontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetContext == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_LoadFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_loadfirmware");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_LoadFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_loadfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadCustomFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_LoadCustomFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_loadcustomfirmware");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadCustomFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_LoadCustomFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_loadcustomfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadCustomFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCorrectionFile = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetCorrectionFilePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_setcorrectionfile");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCorrectionFile = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetCorrectionFilePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_setcorrectionfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCorrectionFile == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureLaserMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ConfigureLaserModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_configurelasermode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureLaserMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ConfigureLaserModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_configurelasermode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureLaserMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureDelays = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ConfigureDelaysPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_configuredelays");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureDelays = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ConfigureDelaysPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_configuredelays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureDelays == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetOIERecordingMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetOIERecordingModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_setoierecordingmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetOIERecordingMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetOIERecordingModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_setoierecordingmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetOIERecordingMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetOIERecordingMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetOIERecordingModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getoierecordingmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetOIERecordingMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetOIERecordingModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getoierecordingmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetOIERecordingMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableAttributeFilter = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_EnableAttributeFilterPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_enableattributefilter");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableAttributeFilter = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_EnableAttributeFilterPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_enableattributefilter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableAttributeFilter == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableAttributeFilter = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DisableAttributeFilterPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_disableattributefilter");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableAttributeFilter = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DisableAttributeFilterPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_disableattributefilter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableAttributeFilter == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_DrawLayer = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DrawLayerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_drawlayer");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_DrawLayer = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DrawLayerPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_drawlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_DrawLayer == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetAllCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetAllCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_setallcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetAllCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetAllCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_setallcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetAllCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_setcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_setcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetDefaultCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetDefaultCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getdefaultcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_GetDefaultCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetDefaultCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_getdefaultcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetDefaultCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableTimelagCompensation = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_EnableTimelagCompensationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_enabletimelagcompensation");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableTimelagCompensation = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_EnableTimelagCompensationPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_enabletimelagcompensation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableTimelagCompensation == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableTimelagCompensation = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DisableTimelagCompensationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_disabletimelagcompensation");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableTimelagCompensation = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DisableTimelagCompensationPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6xn_disabletimelagcompensation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableTimelagCompensation == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabGetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlab_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_scanlab_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_scanlab_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_scanlab_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabInjectComponentPtr) dlsym(hLibrary, "libmcdriver_scanlab_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_scanlab_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabCreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabCreateDriverPtr) dlsym(hLibrary, "libmcdriver_scanlab_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}

	inline LibMCDriver_ScanLabResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_ScanLabResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_ScanLabResult eLookupError = LIBMCDRIVER_SCANLAB_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_queryparametersex", (void**)&(pWrapperTable->m_Driver_QueryParametersEx));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParametersEx == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_uartconnection_getbaudrate", (void**)&(pWrapperTable->m_UARTConnection_GetBaudRate));
		if ( (eLookupError != 0) || (pWrapperTable->m_UARTConnection_GetBaudRate == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_uartconnection_getconfiguredbaudrate", (void**)&(pWrapperTable->m_UARTConnection_GetConfiguredBaudRate));
		if ( (eLookupError != 0) || (pWrapperTable->m_UARTConnection_GetConfiguredBaudRate == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_uartconnection_clearreceivebuffer", (void**)&(pWrapperTable->m_UARTConnection_ClearReceiveBuffer));
		if ( (eLookupError != 0) || (pWrapperTable->m_UARTConnection_ClearReceiveBuffer == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_uartconnection_availablebytes", (void**)&(pWrapperTable->m_UARTConnection_AvailableBytes));
		if ( (eLookupError != 0) || (pWrapperTable->m_UARTConnection_AvailableBytes == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_uartconnection_writestring", (void**)&(pWrapperTable->m_UARTConnection_WriteString));
		if ( (eLookupError != 0) || (pWrapperTable->m_UARTConnection_WriteString == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_uartconnection_writedata", (void**)&(pWrapperTable->m_UARTConnection_WriteData));
		if ( (eLookupError != 0) || (pWrapperTable->m_UARTConnection_WriteData == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_uartconnection_readdata", (void**)&(pWrapperTable->m_UARTConnection_ReadData));
		if ( (eLookupError != 0) || (pWrapperTable->m_UARTConnection_ReadData == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_uartconnection_readline", (void**)&(pWrapperTable->m_UARTConnection_ReadLine));
		if ( (eLookupError != 0) || (pWrapperTable->m_UARTConnection_ReadLine == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_drawpolyline", (void**)&(pWrapperTable->m_RTCJob_DrawPolyline));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_DrawPolyline == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_drawpolylineoie", (void**)&(pWrapperTable->m_RTCJob_DrawPolylineOIE));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_DrawPolylineOIE == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_drawhatches", (void**)&(pWrapperTable->m_RTCJob_DrawHatches));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_DrawHatches == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addsetpower", (void**)&(pWrapperTable->m_RTCJob_AddSetPower));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddSetPower == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addsetanalogout", (void**)&(pWrapperTable->m_RTCJob_AddSetAnalogOut));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddSetAnalogOut == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addsetdigitalout", (void**)&(pWrapperTable->m_RTCJob_AddSetDigitalOut));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddSetDigitalOut == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addsetpowerforpidcontrol", (void**)&(pWrapperTable->m_RTCJob_AddSetPowerForPIDControl));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddSetPowerForPIDControl == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addsetjumpspeed", (void**)&(pWrapperTable->m_RTCJob_AddSetJumpSpeed));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddSetJumpSpeed == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addsetmarkspeed", (void**)&(pWrapperTable->m_RTCJob_AddSetMarkSpeed));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddSetMarkSpeed == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addjumpmovement", (void**)&(pWrapperTable->m_RTCJob_AddJumpMovement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddJumpMovement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addmarkmovement", (void**)&(pWrapperTable->m_RTCJob_AddMarkMovement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddMarkMovement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addtimedmarkmovement", (void**)&(pWrapperTable->m_RTCJob_AddTimedMarkMovement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddTimedMarkMovement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcjob_addfreevariable", (void**)&(pWrapperTable->m_RTCJob_AddFreeVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCJob_AddFreeVariable == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_scanheadconnectioncheckisenabled", (void**)&(pWrapperTable->m_RTCRecording_ScanheadConnectionCheckIsEnabled));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_ScanheadConnectionCheckIsEnabled == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_enablescanheadconnectioncheck", (void**)&(pWrapperTable->m_RTCRecording_EnableScanheadConnectionCheck));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_EnableScanheadConnectionCheck == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_disablescanheadconnectioncheck", (void**)&(pWrapperTable->m_RTCRecording_DisableScanheadConnectionCheck));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_DisableScanheadConnectionCheck == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_clear", (void**)&(pWrapperTable->m_RTCRecording_Clear));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_Clear == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_addchannel", (void**)&(pWrapperTable->m_RTCRecording_AddChannel));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_AddChannel == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_removechannel", (void**)&(pWrapperTable->m_RTCRecording_RemoveChannel));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_RemoveChannel == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_haschannel", (void**)&(pWrapperTable->m_RTCRecording_HasChannel));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_HasChannel == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_getchanneltype", (void**)&(pWrapperTable->m_RTCRecording_GetChannelType));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_GetChannelType == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_getrecordcount", (void**)&(pWrapperTable->m_RTCRecording_GetRecordCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_GetRecordCount == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_getrecordentry", (void**)&(pWrapperTable->m_RTCRecording_GetRecordEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_GetRecordEntry == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_getallrecordentries", (void**)&(pWrapperTable->m_RTCRecording_GetAllRecordEntries));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_GetAllRecordEntries == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_enablerecording", (void**)&(pWrapperTable->m_RTCRecording_EnableRecording));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_EnableRecording == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_disablerecording", (void**)&(pWrapperTable->m_RTCRecording_DisableRecording));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_DisableRecording == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_executelistwithrecording", (void**)&(pWrapperTable->m_RTCRecording_ExecuteListWithRecording));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_ExecuteListWithRecording == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_addrecordstodatatable", (void**)&(pWrapperTable->m_RTCRecording_AddRecordsToDataTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_AddRecordsToDataTable == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcrecording_addscaledrecordstodatatable", (void**)&(pWrapperTable->m_RTCRecording_AddScaledRecordsToDataTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCRecording_AddScaledRecordsToDataTable == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_getidentifier", (void**)&(pWrapperTable->m_GPIOSequence_GetIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_GetIdentifier == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_clear", (void**)&(pWrapperTable->m_GPIOSequence_Clear));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_Clear == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_addoutput", (void**)&(pWrapperTable->m_GPIOSequence_AddOutput));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_AddOutput == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_adddelay", (void**)&(pWrapperTable->m_GPIOSequence_AddDelay));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_AddDelay == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_waitforinput", (void**)&(pWrapperTable->m_GPIOSequence_WaitforInput));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_WaitforInput == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_addlabel", (void**)&(pWrapperTable->m_GPIOSequence_AddLabel));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_AddLabel == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_gotolabel", (void**)&(pWrapperTable->m_GPIOSequence_GoToLabel));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_GoToLabel == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_conditionalgotolabel", (void**)&(pWrapperTable->m_GPIOSequence_ConditionalGoToLabel));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_ConditionalGoToLabel == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_enableautomaticselection", (void**)&(pWrapperTable->m_GPIOSequence_EnableAutomaticSelection));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_EnableAutomaticSelection == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_gpiosequence_disableautomaticselection", (void**)&(pWrapperTable->m_GPIOSequence_DisableAutomaticSelection));
		if ( (eLookupError != 0) || (pWrapperTable->m_GPIOSequence_DisableAutomaticSelection == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_setcontroloutputpins", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_SetControlOutputPins));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_SetControlOutputPins == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_getcontroloutputpins", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_GetControlOutputPins));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_GetControlOutputPins == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_setselectionoutputpins", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_SetSelectionOutputPins));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_SetSelectionOutputPins == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_getselectionoutputpins", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_GetSelectionOutputPins));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_GetSelectionOutputPins == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_setacknowledgeinputpin", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeInputPin));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeInputPin == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_getacknowledgeinputpin", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeInputPin));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeInputPin == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_setselectiondelay", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_SetSelectionDelay));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_SetSelectionDelay == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_getselectiondelay", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_GetSelectionDelay));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_GetSelectionDelay == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_setacknowledgetimeout", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeTimeout));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_SetAcknowledgeTimeout == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_getacknowledgetimeout", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeTimeout));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_GetAcknowledgeTimeout == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_enableautomaticselection", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_EnableAutomaticSelection));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_EnableAutomaticSelection == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_disableautomaticselection", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_DisableAutomaticSelection));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_DisableAutomaticSelection == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_nlightafxprofileselector_addcustomselection", (void**)&(pWrapperTable->m_NLightAFXProfileSelector_AddCustomSelection));
		if ( (eLookupError != 0) || (pWrapperTable->m_NLightAFXProfileSelector_AddCustomSelection == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_loadfirmware", (void**)&(pWrapperTable->m_RTCContext_LoadFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_LoadFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_loadcorrectionfile", (void**)&(pWrapperTable->m_RTCContext_LoadCorrectionFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_LoadCorrectionFile == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_selectcorrectiontable", (void**)&(pWrapperTable->m_RTCContext_SelectCorrectionTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SelectCorrectionTable == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_configurelists", (void**)&(pWrapperTable->m_RTCContext_ConfigureLists));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ConfigureLists == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlasermode", (void**)&(pWrapperTable->m_RTCContext_SetLaserMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disableautolasercontrol", (void**)&(pWrapperTable->m_RTCContext_DisableAutoLaserControl));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableAutoLaserControl == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlasercontrolparameters", (void**)&(pWrapperTable->m_RTCContext_SetLaserControlParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserControlParameters == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserpulsesinbits", (void**)&(pWrapperTable->m_RTCContext_SetLaserPulsesInBits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserPulsesInBits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setstandbyinbits", (void**)&(pWrapperTable->m_RTCContext_SetStandbyInBits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetStandbyInBits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getipaddress", (void**)&(pWrapperTable->m_RTCContext_GetIPAddress));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetIPAddress == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getnetmask", (void**)&(pWrapperTable->m_RTCContext_GetNetmask));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetNetmask == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getserialnumber", (void**)&(pWrapperTable->m_RTCContext_GetSerialNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetSerialNumber == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getlaserindex", (void**)&(pWrapperTable->m_RTCContext_GetLaserIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetLaserIndex == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserorigin", (void**)&(pWrapperTable->m_RTCContext_SetLaserOrigin));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserOrigin == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getlaserorigin", (void**)&(pWrapperTable->m_RTCContext_GetLaserOrigin));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetLaserOrigin == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserfield", (void**)&(pWrapperTable->m_RTCContext_SetLaserField));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserField == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_resetlaserfield", (void**)&(pWrapperTable->m_RTCContext_ResetLaserField));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ResetLaserField == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enablerangechecking", (void**)&(pWrapperTable->m_RTCContext_EnableRangeChecking));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableRangeChecking == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disablerangechecking", (void**)&(pWrapperTable->m_RTCContext_DisableRangeChecking));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableRangeChecking == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getlaserfield", (void**)&(pWrapperTable->m_RTCContext_GetLaserField));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetLaserField == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setstartlist", (void**)&(pWrapperTable->m_RTCContext_SetStartList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetStartList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setendoflist", (void**)&(pWrapperTable->m_RTCContext_SetEndOfList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetEndOfList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_executelist", (void**)&(pWrapperTable->m_RTCContext_ExecuteList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ExecuteList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setautochangepos", (void**)&(pWrapperTable->m_RTCContext_SetAutoChangePos));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetAutoChangePos == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setdelays", (void**)&(pWrapperTable->m_RTCContext_SetDelays));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetDelays == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserdelaysinbits", (void**)&(pWrapperTable->m_RTCContext_SetLaserDelaysInBits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserDelaysInBits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_drawpolyline", (void**)&(pWrapperTable->m_RTCContext_DrawPolyline));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DrawPolyline == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_drawpolylineoie", (void**)&(pWrapperTable->m_RTCContext_DrawPolylineOIE));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DrawPolylineOIE == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_drawhatches", (void**)&(pWrapperTable->m_RTCContext_DrawHatches));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DrawHatches == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addsetpower", (void**)&(pWrapperTable->m_RTCContext_AddSetPower));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddSetPower == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addsetanalogout", (void**)&(pWrapperTable->m_RTCContext_AddSetAnalogOut));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddSetAnalogOut == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addsetdigitalout", (void**)&(pWrapperTable->m_RTCContext_AddSetDigitalOut));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddSetDigitalOut == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addsetpowerforpidcontrol", (void**)&(pWrapperTable->m_RTCContext_AddSetPowerForPIDControl));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddSetPowerForPIDControl == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addsetjumpspeed", (void**)&(pWrapperTable->m_RTCContext_AddSetJumpSpeed));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddSetJumpSpeed == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addsetmarkspeed", (void**)&(pWrapperTable->m_RTCContext_AddSetMarkSpeed));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddSetMarkSpeed == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addjumpmovement", (void**)&(pWrapperTable->m_RTCContext_AddJumpMovement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddJumpMovement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addmarkmovement", (void**)&(pWrapperTable->m_RTCContext_AddMarkMovement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddMarkMovement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addtimedmarkmovement", (void**)&(pWrapperTable->m_RTCContext_AddTimedMarkMovement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddTimedMarkMovement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addfreevariable", (void**)&(pWrapperTable->m_RTCContext_AddFreeVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddFreeVariable == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getcurrentfreevariable", (void**)&(pWrapperTable->m_RTCContext_GetCurrentFreeVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetCurrentFreeVariable == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_gettimestamp", (void**)&(pWrapperTable->m_RTCContext_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetTimeStamp == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getrtcchannel", (void**)&(pWrapperTable->m_RTCContext_GetRTCChannel));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetRTCChannel == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getrtcinternalvalue", (void**)&(pWrapperTable->m_RTCContext_GetRTCInternalValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetRTCInternalValue == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_stopexecution", (void**)&(pWrapperTable->m_RTCContext_StopExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_StopExecution == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_drawhatchesoie", (void**)&(pWrapperTable->m_RTCContext_DrawHatchesOIE));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DrawHatchesOIE == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addlayertolist", (void**)&(pWrapperTable->m_RTCContext_AddLayerToList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddLayerToList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_waitforencoderx", (void**)&(pWrapperTable->m_RTCContext_WaitForEncoderX));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_WaitForEncoderX == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_waitforencodery", (void**)&(pWrapperTable->m_RTCContext_WaitForEncoderY));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_WaitForEncoderY == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_waitforencoderxsteps", (void**)&(pWrapperTable->m_RTCContext_WaitForEncoderXSteps));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_WaitForEncoderXSteps == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_waitforencoderysteps", (void**)&(pWrapperTable->m_RTCContext_WaitForEncoderYSteps));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_WaitForEncoderYSteps == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addcustomdelay", (void**)&(pWrapperTable->m_RTCContext_AddCustomDelay));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddCustomDelay == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getcorrectionfactor", (void**)&(pWrapperTable->m_RTCContext_GetCorrectionFactor));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetCorrectionFactor == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getstatus", (void**)&(pWrapperTable->m_RTCContext_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetStatus == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getheadstatus", (void**)&(pWrapperTable->m_RTCContext_GetHeadStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetHeadStatus == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getstatevalues", (void**)&(pWrapperTable->m_RTCContext_GetStateValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetStateValues == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getinputpointer", (void**)&(pWrapperTable->m_RTCContext_GetInputPointer));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetInputPointer == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getrtcversion", (void**)&(pWrapperTable->m_RTCContext_GetRTCVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetRTCVersion == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setcommunicationtimeouts", (void**)&(pWrapperTable->m_RTCContext_SetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getcommunicationtimeouts", (void**)&(pWrapperTable->m_RTCContext_GetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_initializeforoie", (void**)&(pWrapperTable->m_RTCContext_InitializeForOIE));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_InitializeForOIE == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserpinout", (void**)&(pWrapperTable->m_RTCContext_SetLaserPinOut));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserPinOut == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getlaserpinin", (void**)&(pWrapperTable->m_RTCContext_GetLaserPinIn));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetLaserPinIn == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addlaserpinouttolist", (void**)&(pWrapperTable->m_RTCContext_AddLaserPinOutToList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddLaserPinOutToList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addwritedigitaliolist", (void**)&(pWrapperTable->m_RTCContext_AddWriteDigitalIOList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddWriteDigitalIOList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addwritemaskeddigitaliolist", (void**)&(pWrapperTable->m_RTCContext_AddWriteMaskedDigitalIOList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddWriteMaskedDigitalIOList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableoie", (void**)&(pWrapperTable->m_RTCContext_EnableOIE));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableOIE == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disableoie", (void**)&(pWrapperTable->m_RTCContext_DisableOIE));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableOIE == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_createnlightafxbeamprofileselector", (void**)&(pWrapperTable->m_RTCContext_CreateNLightAFXBeamProfileSelector));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_CreateNLightAFXBeamProfileSelector == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addgpiosequence", (void**)&(pWrapperTable->m_RTCContext_AddGPIOSequence));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddGPIOSequence == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_writegpiosequencetolist", (void**)&(pWrapperTable->m_RTCContext_WriteGPIOSequenceToList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_WriteGPIOSequenceToList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_findgpiosequence", (void**)&(pWrapperTable->m_RTCContext_FindGPIOSequence));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_FindGPIOSequence == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_deletegpiosequence", (void**)&(pWrapperTable->m_RTCContext_DeleteGPIOSequence));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DeleteGPIOSequence == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_startoiemeasurement", (void**)&(pWrapperTable->m_RTCContext_StartOIEMeasurement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_StartOIEMeasurement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_startoiemeasurementex", (void**)&(pWrapperTable->m_RTCContext_StartOIEMeasurementEx));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_StartOIEMeasurementEx == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_stopoiemeasurement", (void**)&(pWrapperTable->m_RTCContext_StopOIEMeasurement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_StopOIEMeasurement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setoiepidmode", (void**)&(pWrapperTable->m_RTCContext_SetOIEPIDMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetOIEPIDMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableoiepidcontrol", (void**)&(pWrapperTable->m_RTCContext_EnableOIEPIDControl));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableOIEPIDControl == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disableoiepidcontrol", (void**)&(pWrapperTable->m_RTCContext_DisableOIEPIDControl));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableOIEPIDControl == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_clearoiemeasurementtags", (void**)&(pWrapperTable->m_RTCContext_ClearOIEMeasurementTags));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ClearOIEMeasurementTags == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableoiemeasurementtagging", (void**)&(pWrapperTable->m_RTCContext_EnableOIEMeasurementTagging));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableOIEMeasurementTagging == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disableoiemeasurementtagging", (void**)&(pWrapperTable->m_RTCContext_DisableOIEMeasurementTagging));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableOIEMeasurementTagging == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getoiemaxmeasurementtag", (void**)&(pWrapperTable->m_RTCContext_GetOIEMaxMeasurementTag));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetOIEMaxMeasurementTag == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_mapoiemeasurementtag", (void**)&(pWrapperTable->m_RTCContext_MapOIEMeasurementTag));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_MapOIEMeasurementTag == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disableskywriting", (void**)&(pWrapperTable->m_RTCContext_DisableSkyWriting));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableSkyWriting == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableskywritingmode1", (void**)&(pWrapperTable->m_RTCContext_EnableSkyWritingMode1));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableSkyWritingMode1 == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableskywritingmode2", (void**)&(pWrapperTable->m_RTCContext_EnableSkyWritingMode2));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableSkyWritingMode2 == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableskywritingmode3", (void**)&(pWrapperTable->m_RTCContext_EnableSkyWritingMode3));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableSkyWritingMode3 == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableskywritingmode4", (void**)&(pWrapperTable->m_RTCContext_EnableSkyWritingMode4));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableSkyWritingMode4 == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_settransformationangle", (void**)&(pWrapperTable->m_RTCContext_SetTransformationAngle));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetTransformationAngle == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_settransformationscale", (void**)&(pWrapperTable->m_RTCContext_SetTransformationScale));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetTransformationScale == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_settransformationoffset", (void**)&(pWrapperTable->m_RTCContext_SetTransformationOffset));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetTransformationOffset == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_settransformationmatrix", (void**)&(pWrapperTable->m_RTCContext_SetTransformationMatrix));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetTransformationMatrix == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_preparerecording", (void**)&(pWrapperTable->m_RTCContext_PrepareRecording));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_PrepareRecording == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_hasrecording", (void**)&(pWrapperTable->m_RTCContext_HasRecording));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_HasRecording == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_findrecording", (void**)&(pWrapperTable->m_RTCContext_FindRecording));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_FindRecording == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enabletimelagcompensation", (void**)&(pWrapperTable->m_RTCContext_EnableTimelagCompensation));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableTimelagCompensation == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disabletimelagcompensation", (void**)&(pWrapperTable->m_RTCContext_DisableTimelagCompensation));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableTimelagCompensation == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enablemarkonthefly2d", (void**)&(pWrapperTable->m_RTCContext_EnableMarkOnTheFly2D));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableMarkOnTheFly2D == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disablemarkonthefly2d", (void**)&(pWrapperTable->m_RTCContext_DisableMarkOnTheFly2D));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableMarkOnTheFly2D == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_markonthefly2disenabled", (void**)&(pWrapperTable->m_RTCContext_MarkOnTheFly2DIsEnabled));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_MarkOnTheFly2DIsEnabled == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_get2dmarkontheflyposition", (void**)&(pWrapperTable->m_RTCContext_Get2DMarkOnTheFlyPosition));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_Get2DMarkOnTheFlyPosition == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_checkontheflyerror", (void**)&(pWrapperTable->m_RTCContext_CheckOnTheFlyError));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_CheckOnTheFlyError == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_laserpowercalibrationisenabled", (void**)&(pWrapperTable->m_RTCContext_LaserPowerCalibrationIsEnabled));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_LaserPowerCalibrationIsEnabled == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_laserpowercalibrationislinear", (void**)&(pWrapperTable->m_RTCContext_LaserPowerCalibrationIsLinear));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_LaserPowerCalibrationIsLinear == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_clearlaserpowercalibration", (void**)&(pWrapperTable->m_RTCContext_ClearLaserPowerCalibration));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ClearLaserPowerCalibration == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getlaserpowercalibration", (void**)&(pWrapperTable->m_RTCContext_GetLaserPowerCalibration));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetLaserPowerCalibration == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlinearlaserpowercalibration", (void**)&(pWrapperTable->m_RTCContext_SetLinearLaserPowerCalibration));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLinearLaserPowerCalibration == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setpiecewiselinearlaserpowercalibration", (void**)&(pWrapperTable->m_RTCContext_SetPiecewiseLinearLaserPowerCalibration));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetPiecewiseLinearLaserPowerCalibration == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enablespatiallaserpowermodulation", (void**)&(pWrapperTable->m_RTCContext_EnableSpatialLaserPowerModulation));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableSpatialLaserPowerModulation == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disablepowermodulation", (void**)&(pWrapperTable->m_RTCContext_DisablePowerModulation));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisablePowerModulation == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enablelinesubdivision", (void**)&(pWrapperTable->m_RTCContext_EnableLineSubdivision));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableLineSubdivision == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disablelinesubdivision", (void**)&(pWrapperTable->m_RTCContext_DisableLineSubdivision));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableLineSubdivision == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_readmultimcbsp", (void**)&(pWrapperTable->m_RTCContext_ReadMultiMCBSP));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ReadMultiMCBSP == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_createuartconnection", (void**)&(pWrapperTable->m_RTCContext_CreateUARTConnection));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_CreateUARTConnection == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enablescanahead", (void**)&(pWrapperTable->m_RTCContext_EnableScanAhead));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableScanAhead == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disablescanahead", (void**)&(pWrapperTable->m_RTCContext_DisableScanAhead));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableScanAhead == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_activatescanaheadautodelays", (void**)&(pWrapperTable->m_RTCContext_ActivateScanAheadAutoDelays));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ActivateScanAheadAutoDelays == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_deactivatescanaheadautodelays", (void**)&(pWrapperTable->m_RTCContext_DeactivateScanAheadAutoDelays));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DeactivateScanAheadAutoDelays == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_scanaheadautodelaysareactivated", (void**)&(pWrapperTable->m_RTCContext_ScanAheadAutoDelaysAreActivated));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ScanAheadAutoDelaysAreActivated == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInMicroseconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinunits", (void**)&(pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInUnits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetScanAheadLaserShiftsInUnits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setscanaheadlineparameters", (void**)&(pWrapperTable->m_RTCContext_SetScanAheadLineParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetScanAheadLineParameters == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_searchcards", (void**)&(pWrapperTable->m_RTCSelector_SearchCards));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_SearchCards == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_searchcardsbyrange", (void**)&(pWrapperTable->m_RTCSelector_SearchCardsByRange));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_SearchCardsByRange == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_getcardcount", (void**)&(pWrapperTable->m_RTCSelector_GetCardCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_GetCardCount == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_getethernetcardcount", (void**)&(pWrapperTable->m_RTCSelector_GetEthernetCardCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_GetEthernetCardCount == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquirecard", (void**)&(pWrapperTable->m_RTCSelector_AcquireCard));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireCard == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquirecardbyserial", (void**)&(pWrapperTable->m_RTCSelector_AcquireCardBySerial));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireCardBySerial == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquireethernetcard", (void**)&(pWrapperTable->m_RTCSelector_AcquireEthernetCard));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireEthernetCard == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial", (void**)&(pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_loadsdk", (void**)&(pWrapperTable->m_Driver_ScanLab_LoadSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_LoadSDK == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_loadcustomsdk", (void**)&(pWrapperTable->m_Driver_ScanLab_LoadCustomSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_LoadCustomSDK == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_creatertcselector", (void**)&(pWrapperTable->m_Driver_ScanLab_CreateRTCSelector));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_CreateRTCSelector == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_enablejournaling", (void**)&(pWrapperTable->m_Driver_ScanLab_EnableJournaling));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_EnableJournaling == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_setfirmware", (void**)&(pWrapperTable->m_Driver_ScanLab_SetFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_SetFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_setcustomfirmware", (void**)&(pWrapperTable->m_Driver_ScanLab_SetCustomFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_SetCustomFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_settosimulationmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_issimulationmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_isinitialized", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_IsInitialized));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_IsInitialized == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_initialise", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_Initialise));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_Initialise == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_initialisefromconfiguration", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_InitialiseFromConfiguration));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_InitialiseFromConfiguration == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_setcommunicationtimeouts", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getipaddress", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetIPAddress));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetIPAddress == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getnetmask", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetNetmask));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetNetmask == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getserialnumber", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetSerialNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetSerialNumber == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getcontext", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetContext == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getselector", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_loadfirmware", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_loadcustomfirmware", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_setcorrectionfile", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_configurelasermode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_configuredelays", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_setoierecordingmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_SetOIERecordingMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_SetOIERecordingMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getoierecordingmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetOIERecordingMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetOIERecordingMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_enableattributefilter", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_EnableAttributeFilter));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_EnableAttributeFilter == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_disableattributefilter", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_DisableAttributeFilter));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_DisableAttributeFilter == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_drawlayer", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getcommunicationtimeouts", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getdefaultcommunicationtimeouts", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetDefaultCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetDefaultCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_enabletimelagcompensation", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_EnableTimelagCompensation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_EnableTimelagCompensation == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_disabletimelagcompensation", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_DisableTimelagCompensation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_DisableTimelagCompensation == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_settosimulationmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_SetToSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetToSimulationMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_issimulationmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_IsSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_IsSimulationMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_isinitialized", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_IsInitialized));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_IsInitialized == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_scannerisinitialized", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_ScannerIsInitialized));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_ScannerIsInitialized == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getscannercount", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetScannerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetScannerCount == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescanner", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScanner));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScanner == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescannerfromconfiguration", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScannerFromConfiguration));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_InitialiseScannerFromConfiguration == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getipaddress", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetIPAddress));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetIPAddress == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getnetmask", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetNetmask));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetNetmask == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getserialnumber", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSerialNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSerialNumber == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getlaserindex", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetLaserIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetLaserIndex == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getselector", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSelector));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetSelector == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getcontext", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetContext == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_loadfirmware", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_loadcustomfirmware", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadCustomFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_LoadCustomFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_setcorrectionfile", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCorrectionFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCorrectionFile == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_configurelasermode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureLaserMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureLaserMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_configuredelays", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureDelays));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_ConfigureDelays == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_setoierecordingmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_SetOIERecordingMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetOIERecordingMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getoierecordingmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetOIERecordingMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetOIERecordingMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_enableattributefilter", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableAttributeFilter));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableAttributeFilter == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_disableattributefilter", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableAttributeFilter));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableAttributeFilter == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_drawlayer", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_DrawLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_DrawLayer == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_setallcommunicationtimeouts", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_SetAllCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetAllCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_setcommunicationtimeouts", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_SetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getcommunicationtimeouts", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_getdefaultcommunicationtimeouts", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_GetDefaultCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_GetDefaultCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_enabletimelagcompensation", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableTimelagCompensation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_EnableTimelagCompensation == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6xn_disabletimelagcompensation", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableTimelagCompensation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6xN_DisableTimelagCompensation == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededType = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_ScanLab_uint32 bytesNeededBuild = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::QueryParameters - Updates the driver parameters in the driver environment. Should only be called in the driver thread.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	* CDriver::QueryParametersEx - Updates the driver parameters in the driver environment. Might be called out of thread. Implementation MUST be able to handle parallel calls.
	* @param[in] pDriverUpdateInstance - Status update instance.
	*/
	void CDriver::QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance)
	{
		LibMCEnvHandle hDriverUpdateInstance = pDriverUpdateInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParametersEx(m_pHandle, hDriverUpdateInstance));
	}
	
	/**
	 * Method definitions for class CUARTConnection
	 */
	
	/**
	* CUARTConnection::GetBaudRate - Returns the actual baud rate of the RS232 Interface.
	* @return Baud rate.
	*/
	LibMCDriver_ScanLab_uint32 CUARTConnection::GetBaudRate()
	{
		LibMCDriver_ScanLab_uint32 resultBaudRate = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_GetBaudRate(m_pHandle, &resultBaudRate));
		
		return resultBaudRate;
	}
	
	/**
	* CUARTConnection::GetConfiguredBaudRate - Returns the configured baud rate of the RS232 Interface.
	* @return Baud rate.
	*/
	LibMCDriver_ScanLab_uint32 CUARTConnection::GetConfiguredBaudRate()
	{
		LibMCDriver_ScanLab_uint32 resultBaudRate = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_GetConfiguredBaudRate(m_pHandle, &resultBaudRate));
		
		return resultBaudRate;
	}
	
	/**
	* CUARTConnection::ClearReceiveBuffer - Clears the receive buffer.
	*/
	void CUARTConnection::ClearReceiveBuffer()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_ClearReceiveBuffer(m_pHandle));
	}
	
	/**
	* CUARTConnection::AvailableBytes - Returns the number of currently received bytes.
	* @return Number of currently received bytes.
	*/
	LibMCDriver_ScanLab_uint32 CUARTConnection::AvailableBytes()
	{
		LibMCDriver_ScanLab_uint32 resultByteCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_AvailableBytes(m_pHandle, &resultByteCount));
		
		return resultByteCount;
	}
	
	/**
	* CUARTConnection::WriteString - Sends a string over the interface. The call is blocking.
	* @param[in] sValue - String to send.
	*/
	void CUARTConnection::WriteString(const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_WriteString(m_pHandle, sValue.c_str()));
	}
	
	/**
	* CUARTConnection::WriteData - Sends a data buffer over the interface. The call is blocking.
	* @param[in] DataBuffer - Data to send.
	*/
	void CUARTConnection::WriteData(const CInputVector<LibMCDriver_ScanLab_uint8> & DataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_WriteData(m_pHandle, (LibMCDriver_ScanLab_uint64)DataBuffer.size(), DataBuffer.data()));
	}
	
	/**
	* CUARTConnection::ReadData - Blocking call for reading a certain number of bytes. Will remove the bytes from the received buffer. Fails if not enough data is available after the timeout.
	* @param[in] nByteCount - Number of bytes to read.
	* @param[in] nTimeOutInMS - Timeout in Milliseconds.
	* @param[out] DataBuffer - Receive buffer.
	*/
	void CUARTConnection::ReadData(const LibMCDriver_ScanLab_uint32 nByteCount, const LibMCDriver_ScanLab_uint32 nTimeOutInMS, std::vector<LibMCDriver_ScanLab_uint8> & DataBuffer)
	{
		LibMCDriver_ScanLab_uint64 elementsNeededData = 0;
		LibMCDriver_ScanLab_uint64 elementsWrittenData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_ReadData(m_pHandle, nByteCount, nTimeOutInMS, 0, &elementsNeededData, nullptr));
		DataBuffer.resize((size_t) elementsNeededData);
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_ReadData(m_pHandle, nByteCount, nTimeOutInMS, elementsNeededData, &elementsWrittenData, DataBuffer.data()));
	}
	
	/**
	* CUARTConnection::ReadLine - Blocking call for reading until a line end signature is coming. Fails if timeout is hit or number of bytes have been reached.
	* @param[in] sSeparator - Line Separator to search for.
	* @param[in] nMaxLineLength - Maximum line length to receive, excluding line separator.
	* @param[in] nTimeOutInMS - Timeout in Milliseconds.
	* @return Received line.
	*/
	std::string CUARTConnection::ReadLine(const std::string & sSeparator, const LibMCDriver_ScanLab_uint32 nMaxLineLength, const LibMCDriver_ScanLab_uint32 nTimeOutInMS)
	{
		LibMCDriver_ScanLab_uint32 bytesNeededLine = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenLine = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_ReadLine(m_pHandle, sSeparator.c_str(), nMaxLineLength, nTimeOutInMS, 0, &bytesNeededLine, nullptr));
		std::vector<char> bufferLine(bytesNeededLine);
		CheckError(m_pWrapper->m_WrapperTable.m_UARTConnection_ReadLine(m_pHandle, sSeparator.c_str(), nMaxLineLength, nTimeOutInMS, bytesNeededLine, &bytesWrittenLine, &bufferLine[0]));
		
		return std::string(&bufferLine[0]);
	}
	
	/**
	 * Method definitions for class CRTCJob
	 */
	
	/**
	* CRTCJob::DrawPolyline - Writes a polyline into the open list
	* @param[in] PointsBuffer - Points of polyline to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Jump speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	*/
	void CRTCJob::DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_DrawPolyline(m_pHandle, (LibMCDriver_ScanLab_uint64)PointsBuffer.size(), PointsBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue));
	}
	
	/**
	* CRTCJob::DrawPolylineOIE - Writes a polyline into the open list with OIE Enabled.
	* @param[in] PointsBuffer - Points of polyline to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Jump speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	* @param[in] nOIEPIDControlIndex - OIE PID Control Index. 0 disables PID Control, MUST be smaller or equal 63.
	*/
	void CRTCJob::DrawPolylineOIE(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue, const LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_DrawPolylineOIE(m_pHandle, (LibMCDriver_ScanLab_uint64)PointsBuffer.size(), PointsBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue, nOIEPIDControlIndex));
	}
	
	/**
	* CRTCJob::DrawHatches - Writes a list of hatches into the open list
	* @param[in] HatchesBuffer - Hatches to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Jump speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	*/
	void CRTCJob::DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_DrawHatches(m_pHandle, (LibMCDriver_ScanLab_uint64)HatchesBuffer.size(), HatchesBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue));
	}
	
	/**
	* CRTCJob::AddSetPower - adds a power change to the open list. MUST NOT be used for PID control.
	* @param[in] fPowerInPercent - Laser power in percent
	*/
	void CRTCJob::AddSetPower(const LibMCDriver_ScanLab_single fPowerInPercent)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddSetPower(m_pHandle, fPowerInPercent));
	}
	
	/**
	* CRTCJob::AddSetAnalogOut - Adds changing an analog port to the open list. Should not interfere with laser power control.
	* @param[in] eLaserPort - Laser port to set. MUST not be an analog port or the call fails.
	* @param[in] fOutputValue - New Normalized output value. Value is clipped between 0 and 1.
	*/
	void CRTCJob::AddSetAnalogOut(const eLaserPort eLaserPort, const LibMCDriver_ScanLab_single fOutputValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddSetAnalogOut(m_pHandle, eLaserPort, fOutputValue));
	}
	
	/**
	* CRTCJob::AddSetDigitalOut - Adds changing an digital port to the open list. Should not interfere with laser power control.
	* @param[in] eLaserPort - Laser port to set. MUST not be an digital port or the call fails.
	* @param[in] fOutputValue - New Normalized output value. Value is clipped between 0 and 1.
	*/
	void CRTCJob::AddSetDigitalOut(const eLaserPort eLaserPort, const LibMCDriver_ScanLab_single fOutputValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddSetDigitalOut(m_pHandle, eLaserPort, fOutputValue));
	}
	
	/**
	* CRTCJob::AddSetPowerForPIDControl - adds a base power change to the open list. If using PID control, this base power will be used at starting power when the laser is turned on.
	* @param[in] fPowerInPercent - Laser power in percent
	*/
	void CRTCJob::AddSetPowerForPIDControl(const LibMCDriver_ScanLab_single fPowerInPercent)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddSetPowerForPIDControl(m_pHandle, fPowerInPercent));
	}
	
	/**
	* CRTCJob::AddSetJumpSpeed - adds a jump speed change to the open list
	* @param[in] fJumpSpeedInMMPerSecond - Jump speed in mm/s
	*/
	void CRTCJob::AddSetJumpSpeed(const LibMCDriver_ScanLab_single fJumpSpeedInMMPerSecond)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddSetJumpSpeed(m_pHandle, fJumpSpeedInMMPerSecond));
	}
	
	/**
	* CRTCJob::AddSetMarkSpeed - adds a mark speed change to the open list
	* @param[in] fMarkSpeedInMMPerSecond - Mark speed in mm/s
	*/
	void CRTCJob::AddSetMarkSpeed(const LibMCDriver_ScanLab_single fMarkSpeedInMMPerSecond)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddSetMarkSpeed(m_pHandle, fMarkSpeedInMMPerSecond));
	}
	
	/**
	* CRTCJob::AddJumpMovement - Adds a Jump movement to the open list
	* @param[in] dTargetX - X Position.
	* @param[in] dTargetY - Y Position.
	*/
	void CRTCJob::AddJumpMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddJumpMovement(m_pHandle, dTargetX, dTargetY));
	}
	
	/**
	* CRTCJob::AddMarkMovement - Adds a Mark movement to the open list
	* @param[in] dTargetX - X Position.
	* @param[in] dTargetY - Y Position.
	*/
	void CRTCJob::AddMarkMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddMarkMovement(m_pHandle, dTargetX, dTargetY));
	}
	
	/**
	* CRTCJob::AddTimedMarkMovement - Adds a timed Mark movement to the open list
	* @param[in] dTargetX - X Position.
	* @param[in] dTargetY - Y Position.
	* @param[in] dDurationInMicroseconds - Duration of mark movement in Microseconds.
	*/
	void CRTCJob::AddTimedMarkMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY, const LibMCDriver_ScanLab_double dDurationInMicroseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddTimedMarkMovement(m_pHandle, dTargetX, dTargetY, dDurationInMicroseconds));
	}
	
	/**
	* CRTCJob::AddFreeVariable - Adds a free variable set to the open list
	* @param[in] nVariableNo - Number of the variable (0-7).
	* @param[in] nValue - Value to set.
	*/
	void CRTCJob::AddFreeVariable(const LibMCDriver_ScanLab_uint32 nVariableNo, const LibMCDriver_ScanLab_uint32 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCJob_AddFreeVariable(m_pHandle, nVariableNo, nValue));
	}
	
	/**
	 * Method definitions for class CRTCRecording
	 */
	
	/**
	* CRTCRecording::ScanheadConnectionCheckIsEnabled - Returns if the scan head connection is checked when recording
	* @return If true, the Scanhead connection will be checked for an error when recording.
	*/
	bool CRTCRecording::ScanheadConnectionCheckIsEnabled()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_ScanheadConnectionCheckIsEnabled(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CRTCRecording::EnableScanheadConnectionCheck - Enables the Scanhead connection check. The check is enabled by default.
	*/
	void CRTCRecording::EnableScanheadConnectionCheck()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_EnableScanheadConnectionCheck(m_pHandle));
	}
	
	/**
	* CRTCRecording::DisableScanheadConnectionCheck - Disables the Scanhead connection check.
	*/
	void CRTCRecording::DisableScanheadConnectionCheck()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_DisableScanheadConnectionCheck(m_pHandle));
	}
	
	/**
	* CRTCRecording::Clear - Clears all recording data and channels.
	*/
	void CRTCRecording::Clear()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_Clear(m_pHandle));
	}
	
	/**
	* CRTCRecording::AddChannel - Adds a new channel to record. Fails if more than 8 channels are recorded. Fails if recording has been already started.
	* @param[in] sChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores. MUST be unique.
	* @param[in] eChannelType - Channel type enum. MUST NOT be Undefined.
	*/
	void CRTCRecording::AddChannel(const std::string & sChannelName, const eRTCChannelType eChannelType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_AddChannel(m_pHandle, sChannelName.c_str(), eChannelType));
	}
	
	/**
	* CRTCRecording::RemoveChannel - Removes a new channel from the recording and all recorded data of that channel. Does nothing if channel does not exist. 
	* @param[in] sChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
	*/
	void CRTCRecording::RemoveChannel(const std::string & sChannelName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_RemoveChannel(m_pHandle, sChannelName.c_str()));
	}
	
	/**
	* CRTCRecording::HasChannel - Returns if a channel name exist.
	* @param[in] sChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
	* @return Returns true if channel exists.
	*/
	bool CRTCRecording::HasChannel(const std::string & sChannelName)
	{
		bool resultChannelExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_HasChannel(m_pHandle, sChannelName.c_str(), &resultChannelExists));
		
		return resultChannelExists;
	}
	
	/**
	* CRTCRecording::GetChannelType - Returns the type of a channel. Returns Undefined if channel does not exist.
	* @param[in] sChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
	* @return Channel type enum.
	*/
	eRTCChannelType CRTCRecording::GetChannelType(const std::string & sChannelName)
	{
		eRTCChannelType resultChannelType = (eRTCChannelType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_GetChannelType(m_pHandle, sChannelName.c_str(), &resultChannelType));
		
		return resultChannelType;
	}
	
	/**
	* CRTCRecording::GetRecordCount - Returns how many record entries have been recorded.
	* @param[in] sChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
	* @return The number of record entries.
	*/
	LibMCDriver_ScanLab_uint64 CRTCRecording::GetRecordCount(const std::string & sChannelName)
	{
		LibMCDriver_ScanLab_uint64 resultRecordCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_GetRecordCount(m_pHandle, sChannelName.c_str(), &resultRecordCount));
		
		return resultRecordCount;
	}
	
	/**
	* CRTCRecording::GetRecordEntry - Returns a specific record entry. Fails if Channel does not exist.
	* @param[in] sChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
	* @param[in] nRecordIndex - Index of Record entry. MUST be between 0 and RecordCount - 1.
	* @return Value of record entry.
	*/
	LibMCDriver_ScanLab_int32 CRTCRecording::GetRecordEntry(const std::string & sChannelName, const LibMCDriver_ScanLab_uint64 nRecordIndex)
	{
		LibMCDriver_ScanLab_int32 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_GetRecordEntry(m_pHandle, sChannelName.c_str(), nRecordIndex, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CRTCRecording::GetAllRecordEntries - Returns all record entries of a channel. Fails if Channel does not exist.
	* @param[in] sChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
	* @param[out] ValuesBuffer - Array of all record entries.
	*/
	void CRTCRecording::GetAllRecordEntries(const std::string & sChannelName, std::vector<LibMCDriver_ScanLab_int32> & ValuesBuffer)
	{
		LibMCDriver_ScanLab_uint64 elementsNeededValues = 0;
		LibMCDriver_ScanLab_uint64 elementsWrittenValues = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_GetAllRecordEntries(m_pHandle, sChannelName.c_str(), 0, &elementsNeededValues, nullptr));
		ValuesBuffer.resize((size_t) elementsNeededValues);
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_GetAllRecordEntries(m_pHandle, sChannelName.c_str(), elementsNeededValues, &elementsWrittenValues, ValuesBuffer.data()));
	}
	
	/**
	* CRTCRecording::EnableRecording - Enables recording of position data of the RTC Card. This is a list command.
	* @param[in] eFrequency - Recording frequency.
	*/
	void CRTCRecording::EnableRecording(const eRTCRecordingFrequency eFrequency)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_EnableRecording(m_pHandle, eFrequency));
	}
	
	/**
	* CRTCRecording::DisableRecording - Disables recording of position data of the RTC Card. This is a list command.
	*/
	void CRTCRecording::DisableRecording()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_DisableRecording(m_pHandle));
	}
	
	/**
	* CRTCRecording::ExecuteListWithRecording - Executes the list with recording the position data from the RTC card. DEPRECIATED!
	*/
	void CRTCRecording::ExecuteListWithRecording()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_ExecuteListWithRecording(m_pHandle));
	}
	
	/**
	* CRTCRecording::AddRecordsToDataTable - Writes a certain channel to a data table as int32 columns. Fails if Channel does not exist
	* @param[in] sChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
	* @param[in] pDataTable - Data table instance to write to.
	* @param[in] sColumnIdentifier - Identifier of the Column.
	* @param[in] sColumnDescription - Description of the Column.
	*/
	void CRTCRecording::AddRecordsToDataTable(const std::string & sChannelName, classParam<LibMCEnv::CDataTable> pDataTable, const std::string & sColumnIdentifier, const std::string & sColumnDescription)
	{
		LibMCEnvHandle hDataTable = pDataTable.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_AddRecordsToDataTable(m_pHandle, sChannelName.c_str(), hDataTable, sColumnIdentifier.c_str(), sColumnDescription.c_str()));
	}
	
	/**
	* CRTCRecording::AddScaledRecordsToDataTable - Writes a certain channel to a data table as double columns, while linearly transforming the values. The DataTable will be filled with the transform RawValue times ScaleFactor + Offset. Fails if Channel does not exist.
	* @param[in] sChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
	* @param[in] pDataTable - Data table instance to write to.
	* @param[in] sColumnIdentifier - Identifier of the Column.
	* @param[in] sColumnDescription - Description of the Column.
	* @param[in] dScaleFactor - Factor that the raw value is scaled with.
	* @param[in] dOffset - Offset that the raw value is scaled with.
	*/
	void CRTCRecording::AddScaledRecordsToDataTable(const std::string & sChannelName, classParam<LibMCEnv::CDataTable> pDataTable, const std::string & sColumnIdentifier, const std::string & sColumnDescription, const LibMCDriver_ScanLab_double dScaleFactor, const LibMCDriver_ScanLab_double dOffset)
	{
		LibMCEnvHandle hDataTable = pDataTable.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_RTCRecording_AddScaledRecordsToDataTable(m_pHandle, sChannelName.c_str(), hDataTable, sColumnIdentifier.c_str(), sColumnDescription.c_str(), dScaleFactor, dOffset));
	}
	
	/**
	 * Method definitions for class CGPIOSequence
	 */
	
	/**
	* CGPIOSequence::GetIdentifier - Returns the identifier of the GPIO Sequence.
	* @return Returns identifier string
	*/
	std::string CGPIOSequence::GetIdentifier()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededIdentifier = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_GetIdentifier(m_pHandle, 0, &bytesNeededIdentifier, nullptr));
		std::vector<char> bufferIdentifier(bytesNeededIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_GetIdentifier(m_pHandle, bytesNeededIdentifier, &bytesWrittenIdentifier, &bufferIdentifier[0]));
		
		return std::string(&bufferIdentifier[0]);
	}
	
	/**
	* CGPIOSequence::Clear - Clears all sequence steps.
	*/
	void CGPIOSequence::Clear()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_Clear(m_pHandle));
	}
	
	/**
	* CGPIOSequence::AddOutput - Adds the writing of an output pin.
	* @param[in] nOutputBit - RTC Digital Output Bit index. MUST be between 0 and 15.
	* @param[in] bOutputValue - If true, bit will be set, if false bit will be cleared.
	*/
	void CGPIOSequence::AddOutput(const LibMCDriver_ScanLab_uint32 nOutputBit, const bool bOutputValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_AddOutput(m_pHandle, nOutputBit, bOutputValue));
	}
	
	/**
	* CGPIOSequence::AddDelay - Adds a delay to the GPIO Sequence.
	* @param[in] nDelayInMilliseconds - Delay in milliseconds.
	*/
	void CGPIOSequence::AddDelay(const LibMCDriver_ScanLab_uint32 nDelayInMilliseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_AddDelay(m_pHandle, nDelayInMilliseconds));
	}
	
	/**
	* CGPIOSequence::WaitforInput - Waits for an input pin to reach a certain value.
	* @param[in] nInputBit - RTC Digital Output Bit index. MUST be between 0 and 15.
	* @param[in] bInputValue - If true, the wait is for the bit becoming 1, if false, the wait is for the bit becoming 0.
	* @param[in] nMaxDelayInMilliseconds - Sets the maximum time it is allowed to take. Fails, if MaxDelay is 0.
	*/
	void CGPIOSequence::WaitforInput(const LibMCDriver_ScanLab_uint32 nInputBit, const bool bInputValue, const LibMCDriver_ScanLab_uint32 nMaxDelayInMilliseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_WaitforInput(m_pHandle, nInputBit, bInputValue, nMaxDelayInMilliseconds));
	}
	
	/**
	* CGPIOSequence::AddLabel - Adds a label to the current sequence position.
	* @param[in] sLabelName - Name of the label. Must be unique in the sequence. Only alphanumeric characters and _ and - are allowed. 
	* @param[in] nMaxPasses - Maximum number of times this label can be passed. Triggers an error if the label is passed more often.
	*/
	void CGPIOSequence::AddLabel(const std::string & sLabelName, const LibMCDriver_ScanLab_uint32 nMaxPasses)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_AddLabel(m_pHandle, sLabelName.c_str(), nMaxPasses));
	}
	
	/**
	* CGPIOSequence::GoToLabel - Jumps to a label. Fails if label does not exist.
	* @param[in] sLabelName - Name of the label. Must be unique in the sequence. Only alphanumeric characters and _ and - are allowed. 
	*/
	void CGPIOSequence::GoToLabel(const std::string & sLabelName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_GoToLabel(m_pHandle, sLabelName.c_str()));
	}
	
	/**
	* CGPIOSequence::ConditionalGoToLabel - Jumps to a label, if a certain input pin is set or cleared. Fails if label does not exist. Does nothing, if the input condition is not fulfilled.
	* @param[in] nInputBit - RTC Digital Output Bit index. MUST be between 0 and 15.
	* @param[in] bInputValue - If true, the jump is for the bit becoming 1, if false, the jump is for the bit becoming 0.
	* @param[in] sLabelName - Name of the label. Must be unique in the sequence. Only alphanumeric characters and _ and - are allowed. 
	*/
	void CGPIOSequence::ConditionalGoToLabel(const LibMCDriver_ScanLab_uint32 nInputBit, const bool bInputValue, const std::string & sLabelName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_ConditionalGoToLabel(m_pHandle, nInputBit, bInputValue, sLabelName.c_str()));
	}
	
	/**
	* CGPIOSequence::EnableAutomaticSelection - Enables the GPIOSequence inside the DrawLayer Routine. The Sequence ID will be taken out of the build profile in this case.
	*/
	void CGPIOSequence::EnableAutomaticSelection()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_EnableAutomaticSelection(m_pHandle));
	}
	
	/**
	* CGPIOSequence::DisableAutomaticSelection - Disables the GPIOSequence selection.
	*/
	void CGPIOSequence::DisableAutomaticSelection()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_GPIOSequence_DisableAutomaticSelection(m_pHandle));
	}
	
	/**
	 * Method definitions for class CNLightAFXProfileSelector
	 */
	
	/**
	* CNLightAFXProfileSelector::SetControlOutputPins - Sets the control output pin mapping for the nLight AFX Laser. Call will fail if profile selection is enabled.
	* @param[in] nEnableDigitalOutputBit - RTC Digital Output Bit index that is connected to the AFX beam selection enable flag (Pro_B7). MUST be between 0 and 15. Default is 0.
	* @param[in] nStartDigitalOutputBit - RTC Digital Output Bit index that is connected to the AFX beam selection start flag (Pro_Start). MUST be between 0 and 15. Default is 1
	*/
	void CNLightAFXProfileSelector::SetControlOutputPins(const LibMCDriver_ScanLab_uint32 nEnableDigitalOutputBit, const LibMCDriver_ScanLab_uint32 nStartDigitalOutputBit)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_SetControlOutputPins(m_pHandle, nEnableDigitalOutputBit, nStartDigitalOutputBit));
	}
	
	/**
	* CNLightAFXProfileSelector::GetControlOutputPins - Returns the control output pin mapping for the nLight AFX Laser.
	* @param[out] nEnableDigitalOutputBit - RTC Digital Output Bit index that is connected to the AFX beam selection enable flag (Pro_B7). MUST be between 0 and 15. Default is 0.
	* @param[out] nStartDigitalOutputBit - RTC Digital Output Bit index that is connected to the AFX beam selection start flag (Pro_Start). MUST be between 0 and 15. Default is 1
	*/
	void CNLightAFXProfileSelector::GetControlOutputPins(LibMCDriver_ScanLab_uint32 & nEnableDigitalOutputBit, LibMCDriver_ScanLab_uint32 & nStartDigitalOutputBit)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_GetControlOutputPins(m_pHandle, &nEnableDigitalOutputBit, &nStartDigitalOutputBit));
	}
	
	/**
	* CNLightAFXProfileSelector::SetSelectionOutputPins - Sets the selection output pin mapping for the nLight AFX Laser. Call will fail if profile selection is enabled.
	* @param[in] nStartIndexSelection0OutputBit - RTC Digital Output Bit index that is connected to lowest bit of the selection index (Pro_B1). MUST be between 0 and 15. Default is 2.
	* @param[in] nStartIndexSelection1OutputBit - RTC Digital Output Bit index that is connected to second lowest bit of the selection index (Pro_B2). MUST be between 0 and 15. Default is 3.
	* @param[in] nStartIndexSelection2OutputBit - RTC Digital Output Bit index that is connected to third lowest bit of the selection index (Pro_B3). MUST be between 0 and 15. Default is 4.
	*/
	void CNLightAFXProfileSelector::SetSelectionOutputPins(const LibMCDriver_ScanLab_uint32 nStartIndexSelection0OutputBit, const LibMCDriver_ScanLab_uint32 nStartIndexSelection1OutputBit, const LibMCDriver_ScanLab_uint32 nStartIndexSelection2OutputBit)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_SetSelectionOutputPins(m_pHandle, nStartIndexSelection0OutputBit, nStartIndexSelection1OutputBit, nStartIndexSelection2OutputBit));
	}
	
	/**
	* CNLightAFXProfileSelector::GetSelectionOutputPins - Returns the selection output pin mapping for the nLight AFX Laser.
	* @param[out] nStartIndexSelection0OutputBit - RTC Digital Output Bit index that is connected to lowest bit of the selection index (Pro_B1). MUST be between 0 and 15. Default is 2.
	* @param[out] nStartIndexSelection1OutputBit - RTC Digital Output Bit index that is connected to second lowest bit of the selection index (Pro_B2). MUST be between 0 and 15. Default is 3.
	* @param[out] nStartIndexSelection2OutputBit - RTC Digital Output Bit index that is connected to third lowest bit of the selection index (Pro_B3). MUST be between 0 and 15. Default is 4.
	*/
	void CNLightAFXProfileSelector::GetSelectionOutputPins(LibMCDriver_ScanLab_uint32 & nStartIndexSelection0OutputBit, LibMCDriver_ScanLab_uint32 & nStartIndexSelection1OutputBit, LibMCDriver_ScanLab_uint32 & nStartIndexSelection2OutputBit)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_GetSelectionOutputPins(m_pHandle, &nStartIndexSelection0OutputBit, &nStartIndexSelection1OutputBit, &nStartIndexSelection2OutputBit));
	}
	
	/**
	* CNLightAFXProfileSelector::SetAcknowledgeInputPin - Sets the acknowledge pin mapping for the nLight AFX Laser. Call will fail if profile selection is enabled.
	* @param[in] nSelectionAcknowledgeInputBit - RTC Digital Input Bit index that is connected to the AFX beam selection ready flag (BPP_RDY). MUST be between 0 and 15. Default is 0.
	*/
	void CNLightAFXProfileSelector::SetAcknowledgeInputPin(const LibMCDriver_ScanLab_uint32 nSelectionAcknowledgeInputBit)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_SetAcknowledgeInputPin(m_pHandle, nSelectionAcknowledgeInputBit));
	}
	
	/**
	* CNLightAFXProfileSelector::GetAcknowledgeInputPin - Returns the acknowledge pin mapping for the nLight AFX Laser.
	* @return RTC Digital Input Bit index that is connected to the AFX beam selection ready flag (BPP_RDY).
	*/
	LibMCDriver_ScanLab_uint32 CNLightAFXProfileSelector::GetAcknowledgeInputPin()
	{
		LibMCDriver_ScanLab_uint32 resultSelectionAcknowledgeInputBit = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_GetAcknowledgeInputPin(m_pHandle, &resultSelectionAcknowledgeInputBit));
		
		return resultSelectionAcknowledgeInputBit;
	}
	
	/**
	* CNLightAFXProfileSelector::SetSelectionDelay - Sets the delay that is added for the AFX Mode selection to be transfered. Call will fail if profile selection is enabled.
	* @param[in] nSelectionDelayInMilliseconds - Selection Delay in milliseconds. Default is 30.
	*/
	void CNLightAFXProfileSelector::SetSelectionDelay(const LibMCDriver_ScanLab_uint32 nSelectionDelayInMilliseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_SetSelectionDelay(m_pHandle, nSelectionDelayInMilliseconds));
	}
	
	/**
	* CNLightAFXProfileSelector::GetSelectionDelay - Returns the delay that is added for the AFX Mode selection to transfered.
	* @return Selection Delay in milliseconds. Default is 30.
	*/
	LibMCDriver_ScanLab_uint32 CNLightAFXProfileSelector::GetSelectionDelay()
	{
		LibMCDriver_ScanLab_uint32 resultSelectionDelayInMilliseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_GetSelectionDelay(m_pHandle, &resultSelectionDelayInMilliseconds));
		
		return resultSelectionDelayInMilliseconds;
	}
	
	/**
	* CNLightAFXProfileSelector::SetAcknowledgeTimeout - Sets the timeout that the AFX Mode selection will wait to be applied. Call will fail if profile selection is enabled.
	* @param[in] nAcknowledgeInMilliseconds - Acknowledge Timeout in Milliseconds. Default is 500.
	*/
	void CNLightAFXProfileSelector::SetAcknowledgeTimeout(const LibMCDriver_ScanLab_uint32 nAcknowledgeInMilliseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_SetAcknowledgeTimeout(m_pHandle, nAcknowledgeInMilliseconds));
	}
	
	/**
	* CNLightAFXProfileSelector::GetAcknowledgeTimeout - Returns the timeout that the AFX Mode selection will wait to be applied.
	* @return Acknowledge Timeout in Milliseconds. Default is 500.
	*/
	LibMCDriver_ScanLab_uint32 CNLightAFXProfileSelector::GetAcknowledgeTimeout()
	{
		LibMCDriver_ScanLab_uint32 resultAcknowledgeTimeoutInMilliseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_GetAcknowledgeTimeout(m_pHandle, &resultAcknowledgeTimeoutInMilliseconds));
		
		return resultAcknowledgeTimeoutInMilliseconds;
	}
	
	/**
	* CNLightAFXProfileSelector::EnableAutomaticSelection - Enables the AFX Mode selection inside the DrawLayer Routine. The Laser Mode will be taken out of the build profile in this case.
	*/
	void CNLightAFXProfileSelector::EnableAutomaticSelection()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_EnableAutomaticSelection(m_pHandle));
	}
	
	/**
	* CNLightAFXProfileSelector::DisableAutomaticSelection - Disables the AFX Mode selection.
	*/
	void CNLightAFXProfileSelector::DisableAutomaticSelection()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_DisableAutomaticSelection(m_pHandle));
	}
	
	/**
	* CNLightAFXProfileSelector::AddCustomSelection - Adds a custom selection cycle to the currenly open list.
	* @param[in] nAFXModeIndex - AFX Mode index to set. MUST be between 0 and 7.
	*/
	void CNLightAFXProfileSelector::AddCustomSelection(const LibMCDriver_ScanLab_uint32 nAFXModeIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_NLightAFXProfileSelector_AddCustomSelection(m_pHandle, nAFXModeIndex));
	}
	
	/**
	 * Method definitions for class CRTCContext
	 */
	
	/**
	* CRTCContext::LoadFirmware - Loads card firmware from resource files.
	* @param[in] FirmwareDataBuffer - byte array of the firmware program file.
	* @param[in] FPGADataBuffer - byte array of the firmware FPGA file.
	* @param[in] AuxiliaryDataBuffer - byte array of the binary auxiliary file.
	*/
	void CRTCContext::LoadFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_LoadFirmware(m_pHandle, (LibMCDriver_ScanLab_uint64)FirmwareDataBuffer.size(), FirmwareDataBuffer.data(), (LibMCDriver_ScanLab_uint64)FPGADataBuffer.size(), FPGADataBuffer.data(), (LibMCDriver_ScanLab_uint64)AuxiliaryDataBuffer.size(), AuxiliaryDataBuffer.data()));
	}
	
	/**
	* CRTCContext::LoadCorrectionFile - Loads card calibration file from given resource file.
	* @param[in] CorrectionFileBuffer - binary data of the correction file.
	* @param[in] nTableNumber - Correction table index of card (1..8)
	* @param[in] nDimension - Is it a 2D or 3D correction file.
	*/
	void CRTCContext::LoadCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_LoadCorrectionFile(m_pHandle, (LibMCDriver_ScanLab_uint64)CorrectionFileBuffer.size(), CorrectionFileBuffer.data(), nTableNumber, nDimension));
	}
	
	/**
	* CRTCContext::SelectCorrectionTable - Selects Correction Table on card.
	* @param[in] nTableNumberHeadA - Table Number for HeadA (1..8) or off (0).
	* @param[in] nTableNumberHeadB - Table Number for HeadA (1..8) or off (0).
	*/
	void CRTCContext::SelectCorrectionTable(const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SelectCorrectionTable(m_pHandle, nTableNumberHeadA, nTableNumberHeadB));
	}
	
	/**
	* CRTCContext::ConfigureLists - Configures list buffer size.
	* @param[in] nSizeListA - Size of List A
	* @param[in] nSizeListB - Size of List B
	*/
	void CRTCContext::ConfigureLists(const LibMCDriver_ScanLab_uint32 nSizeListA, const LibMCDriver_ScanLab_uint32 nSizeListB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ConfigureLists(m_pHandle, nSizeListA, nSizeListB));
	}
	
	/**
	* CRTCContext::SetLaserMode - Sets laser mode of card.
	* @param[in] eLaserMode - Laser Mode Enum
	* @param[in] eLaserPort - Laser Port Enum
	*/
	void CRTCContext::SetLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserMode(m_pHandle, eLaserMode, eLaserPort));
	}
	
	/**
	* CRTCContext::DisableAutoLaserControl - Disables automatic laser control.
	*/
	void CRTCContext::DisableAutoLaserControl()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableAutoLaserControl(m_pHandle));
	}
	
	/**
	* CRTCContext::SetLaserControlParameters - Sets laser control parameters of card.
	* @param[in] bDisableLaser - Laser is disabled
	* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
	* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
	* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
	* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
	* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
	* @param[in] bOutputSynchronizationActive - Output synchronization active
	*/
	void CRTCContext::SetLaserControlParameters(const bool bDisableLaser, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserControlParameters(m_pHandle, bDisableLaser, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive));
	}
	
	/**
	* CRTCContext::SetLaserPulsesInBits - Sets laser control pulse interval (in 1/64th microseconds)
	* @param[in] nHalfPeriod - Half Output period in 1/64th microseconds
	* @param[in] nPulseLength - Pulse Length in 1/64th microseconds
	*/
	void CRTCContext::SetLaserPulsesInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserPulsesInBits(m_pHandle, nHalfPeriod, nPulseLength));
	}
	
	/**
	* CRTCContext::SetLaserPulsesInMicroSeconds - Sets laser control pulse interval (in microseconds)
	* @param[in] dHalfPeriod - Half Output period in microseconds
	* @param[in] dPulseLength - Pulse Length in microseconds
	*/
	void CRTCContext::SetLaserPulsesInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserPulsesInMicroSeconds(m_pHandle, dHalfPeriod, dPulseLength));
	}
	
	/**
	* CRTCContext::SetStandbyInBits - Sets standby pulse interval (in 1/64th microseconds)
	* @param[in] nHalfPeriod - Half Output period in 1/64th microseconds
	* @param[in] nPulseLength - Pulse Length in 1/64th microseconds
	*/
	void CRTCContext::SetStandbyInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetStandbyInBits(m_pHandle, nHalfPeriod, nPulseLength));
	}
	
	/**
	* CRTCContext::SetStandbyInMicroSeconds - Sets laser control pulse interval (in microseconds)
	* @param[in] dHalfPeriod - Half Output period in microseconds
	* @param[in] dPulseLength - Pulse Length in microseconds
	*/
	void CRTCContext::SetStandbyInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetStandbyInMicroSeconds(m_pHandle, dHalfPeriod, dPulseLength));
	}
	
	/**
	* CRTCContext::GetIPAddress - Returns the IP Address of the RTC Card. Fails if driver has not been initialized.
	* @return IP Address Value.
	*/
	std::string CRTCContext::GetIPAddress()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededIPAddress = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenIPAddress = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetIPAddress(m_pHandle, 0, &bytesNeededIPAddress, nullptr));
		std::vector<char> bufferIPAddress(bytesNeededIPAddress);
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetIPAddress(m_pHandle, bytesNeededIPAddress, &bytesWrittenIPAddress, &bufferIPAddress[0]));
		
		return std::string(&bufferIPAddress[0]);
	}
	
	/**
	* CRTCContext::GetNetmask - Returns the Netmask of the RTC Card. Fails if driver has not been initialized.
	* @return Netmask Value.
	*/
	std::string CRTCContext::GetNetmask()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededNetmask = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenNetmask = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetNetmask(m_pHandle, 0, &bytesNeededNetmask, nullptr));
		std::vector<char> bufferNetmask(bytesNeededNetmask);
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetNetmask(m_pHandle, bytesNeededNetmask, &bytesWrittenNetmask, &bufferNetmask[0]));
		
		return std::string(&bufferNetmask[0]);
	}
	
	/**
	* CRTCContext::GetSerialNumber - Returns serial number of card
	* @return Returns serial number of board.
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetSerialNumber()
	{
		LibMCDriver_ScanLab_uint32 resultSerialNumber = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetSerialNumber(m_pHandle, &resultSerialNumber));
		
		return resultSerialNumber;
	}
	
	/**
	* CRTCContext::GetLaserIndex - Returns the laser index assigned to the card. This is the laser index that will be used to map the toolpath laser data to the according device.
	* @return Returns laser index of board.
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetLaserIndex()
	{
		LibMCDriver_ScanLab_uint32 resultLaserIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetLaserIndex(m_pHandle, &resultLaserIndex));
		
		return resultLaserIndex;
	}
	
	/**
	* CRTCContext::SetLaserOrigin - Sets the laser origin in absolute coordinates. This origin will be used to relatively position lasers to one another.
	* @param[in] dOriginX - Sets laser origin X coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
	* @param[in] dOriginY - Sets laser origin Y coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
	*/
	void CRTCContext::SetLaserOrigin(const LibMCDriver_ScanLab_double dOriginX, const LibMCDriver_ScanLab_double dOriginY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserOrigin(m_pHandle, dOriginX, dOriginY));
	}
	
	/**
	* CRTCContext::GetLaserOrigin - Returns the laser origin in absolute coordinates. This origin will be used to relatively position lasers to one another.
	* @param[out] dOriginX - Laser origin X coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
	* @param[out] dOriginY - Laser origin Y coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
	*/
	void CRTCContext::GetLaserOrigin(LibMCDriver_ScanLab_double & dOriginX, LibMCDriver_ScanLab_double & dOriginY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetLaserOrigin(m_pHandle, &dOriginX, &dOriginY));
	}
	
	/**
	* CRTCContext::SetLaserField - Sets the laser field limits in absolute coordinates.
	* @param[in] dMinX - Sets minimum laser X coordinate in mm.
	* @param[in] dMinY - Sets minimum laser Y coordinate in mm.
	* @param[in] dMaxX - Sets maximum laser X coordinate in mm.
	* @param[in] dMaxY - Sets maximum laser Y coordinate in mm.
	*/
	void CRTCContext::SetLaserField(const LibMCDriver_ScanLab_double dMinX, const LibMCDriver_ScanLab_double dMinY, const LibMCDriver_ScanLab_double dMaxX, const LibMCDriver_ScanLab_double dMaxY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserField(m_pHandle, dMinX, dMinY, dMaxX, dMaxY));
	}
	
	/**
	* CRTCContext::ResetLaserField - Resets the laser field to default values.
	*/
	void CRTCContext::ResetLaserField()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ResetLaserField(m_pHandle));
	}
	
	/**
	* CRTCContext::EnableRangeChecking - Enables range checking of the laser field. A laser field MUST have been set before.
	*/
	void CRTCContext::EnableRangeChecking()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableRangeChecking(m_pHandle));
	}
	
	/**
	* CRTCContext::DisableRangeChecking - Disables range checking of the laser field.
	*/
	void CRTCContext::DisableRangeChecking()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableRangeChecking(m_pHandle));
	}
	
	/**
	* CRTCContext::GetLaserField - Returns the laser field limits in absolute coordinates.
	* @param[out] dMinX - Sets minimum laser X coordinate in mm.
	* @param[out] dMinY - Sets minimum laser Y coordinate in mm.
	* @param[out] dMaxX - Sets maximum laser X coordinate in mm.
	* @param[out] dMaxY - Sets maximum laser Y coordinate in mm.
	* @return Returns true if a laser field has been set.
	*/
	bool CRTCContext::GetLaserField(LibMCDriver_ScanLab_double & dMinX, LibMCDriver_ScanLab_double & dMinY, LibMCDriver_ScanLab_double & dMaxX, LibMCDriver_ScanLab_double & dMaxY)
	{
		bool resultHasLaserField = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetLaserField(m_pHandle, &dMinX, &dMinY, &dMaxX, &dMaxY, &resultHasLaserField));
		
		return resultHasLaserField;
	}
	
	/**
	* CRTCContext::SetStartList - Opens the list to write
	* @param[in] nListIndex - Index of List (1 or 2).
	* @param[in] nPosition - Relative Position in List.
	*/
	void CRTCContext::SetStartList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetStartList(m_pHandle, nListIndex, nPosition));
	}
	
	/**
	* CRTCContext::SetEndOfList - Closes the currently open list
	*/
	void CRTCContext::SetEndOfList()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetEndOfList(m_pHandle));
	}
	
	/**
	* CRTCContext::ExecuteList - Executes the list
	* @param[in] nListIndex - Index of List (1 or 2).
	* @param[in] nPosition - Relative Position in List.
	*/
	void CRTCContext::ExecuteList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ExecuteList(m_pHandle, nListIndex, nPosition));
	}
	
	/**
	* CRTCContext::SetAutoChangePos - Sets the AutoChange Position of the currently not running list.
	* @param[in] nPosition - Relative Position in List.
	*/
	void CRTCContext::SetAutoChangePos(const LibMCDriver_ScanLab_uint32 nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetAutoChangePos(m_pHandle, nPosition));
	}
	
	/**
	* CRTCContext::SetDelays - Sets the laser delays
	* @param[in] nMarkDelay - Mark delay in microseconds (MUST be multiple of 10)
	* @param[in] nJumpDelay - Jump delay in microseconds (MUST be multiple of 10)
	* @param[in] nPolygonDelay - Polygon delay in microseconds (MUST be multiple of 10)
	*/
	void CRTCContext::SetDelays(const LibMCDriver_ScanLab_uint32 nMarkDelay, const LibMCDriver_ScanLab_uint32 nJumpDelay, const LibMCDriver_ScanLab_uint32 nPolygonDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetDelays(m_pHandle, nMarkDelay, nJumpDelay, nPolygonDelay));
	}
	
	/**
	* CRTCContext::SetLaserDelaysInMicroseconds - Sets the laser delays (on the list)
	* @param[in] dLaserOnDelay - LaserOn delay in microseconds
	* @param[in] dLaserOffDelay - LaserOff delay in microseconds
	*/
	void CRTCContext::SetLaserDelaysInMicroseconds(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserDelaysInMicroseconds(m_pHandle, dLaserOnDelay, dLaserOffDelay));
	}
	
	/**
	* CRTCContext::SetLaserDelaysInBits - Sets the laser delays (on the list)
	* @param[in] nLaserOnDelay - LaserOn delay in bits (1/64th microseconds)
	* @param[in] nLaserOffDelay - LaserOff delay in bits (1/64th microseconds)
	*/
	void CRTCContext::SetLaserDelaysInBits(const LibMCDriver_ScanLab_int32 nLaserOnDelay, const LibMCDriver_ScanLab_int32 nLaserOffDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserDelaysInBits(m_pHandle, nLaserOnDelay, nLaserOffDelay));
	}
	
	/**
	* CRTCContext::DrawPolyline - Writes a polyline into the open list
	* @param[in] PointsBuffer - Points of polyline to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Jump speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	*/
	void CRTCContext::DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DrawPolyline(m_pHandle, (LibMCDriver_ScanLab_uint64)PointsBuffer.size(), PointsBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue));
	}
	
	/**
	* CRTCContext::DrawPolylineOIE - Writes a polyline into the open list with OIE Enabled.
	* @param[in] PointsBuffer - Points of polyline to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Jump speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	* @param[in] nOIEPIDControlIndex - OIE PID Control Index. 0 disables PID Control, MUST be smaller or equal 63.
	*/
	void CRTCContext::DrawPolylineOIE(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue, const LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DrawPolylineOIE(m_pHandle, (LibMCDriver_ScanLab_uint64)PointsBuffer.size(), PointsBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue, nOIEPIDControlIndex));
	}
	
	/**
	* CRTCContext::DrawHatches - Writes a list of hatches into the open list
	* @param[in] HatchesBuffer - Hatches to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Jump speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	*/
	void CRTCContext::DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DrawHatches(m_pHandle, (LibMCDriver_ScanLab_uint64)HatchesBuffer.size(), HatchesBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue));
	}
	
	/**
	* CRTCContext::AddSetPower - adds a power change to the open list. MUST NOT be used for PID control.
	* @param[in] fPowerInPercent - Laser power in percent
	*/
	void CRTCContext::AddSetPower(const LibMCDriver_ScanLab_single fPowerInPercent)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddSetPower(m_pHandle, fPowerInPercent));
	}
	
	/**
	* CRTCContext::AddSetAnalogOut - Adds changing an analog port to the open list. Should not interfere with laser power control.
	* @param[in] eLaserPort - Laser port to set. MUST not be an analog port or the call fails.
	* @param[in] fOutputValue - New Normalized output value. Value is clipped between 0 and 1.
	*/
	void CRTCContext::AddSetAnalogOut(const eLaserPort eLaserPort, const LibMCDriver_ScanLab_single fOutputValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddSetAnalogOut(m_pHandle, eLaserPort, fOutputValue));
	}
	
	/**
	* CRTCContext::AddSetDigitalOut - Adds changing an digital port to the open list. Should not interfere with laser power control.
	* @param[in] eLaserPort - Laser port to set. MUST not be an digital port or the call fails.
	* @param[in] fOutputValue - New Normalized output value. Value is clipped between 0 and 1.
	*/
	void CRTCContext::AddSetDigitalOut(const eLaserPort eLaserPort, const LibMCDriver_ScanLab_single fOutputValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddSetDigitalOut(m_pHandle, eLaserPort, fOutputValue));
	}
	
	/**
	* CRTCContext::AddSetPowerForPIDControl - adds a base power change to the open list. If using PID control, this base power will be used at starting power when the laser is turned on.
	* @param[in] fPowerInPercent - Laser power in percent
	*/
	void CRTCContext::AddSetPowerForPIDControl(const LibMCDriver_ScanLab_single fPowerInPercent)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddSetPowerForPIDControl(m_pHandle, fPowerInPercent));
	}
	
	/**
	* CRTCContext::AddSetJumpSpeed - adds a jump speed change to the open list
	* @param[in] fJumpSpeedInMMPerSecond - Jump speed in mm/s
	*/
	void CRTCContext::AddSetJumpSpeed(const LibMCDriver_ScanLab_single fJumpSpeedInMMPerSecond)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddSetJumpSpeed(m_pHandle, fJumpSpeedInMMPerSecond));
	}
	
	/**
	* CRTCContext::AddSetMarkSpeed - adds a mark speed change to the open list
	* @param[in] fMarkSpeedInMMPerSecond - Mark speed in mm/s
	*/
	void CRTCContext::AddSetMarkSpeed(const LibMCDriver_ScanLab_single fMarkSpeedInMMPerSecond)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddSetMarkSpeed(m_pHandle, fMarkSpeedInMMPerSecond));
	}
	
	/**
	* CRTCContext::AddJumpMovement - Adds a Jump movement to the open list
	* @param[in] dTargetX - X Position.
	* @param[in] dTargetY - Y Position.
	*/
	void CRTCContext::AddJumpMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddJumpMovement(m_pHandle, dTargetX, dTargetY));
	}
	
	/**
	* CRTCContext::AddMarkMovement - Adds a Mark movement to the open list
	* @param[in] dTargetX - X Position.
	* @param[in] dTargetY - Y Position.
	*/
	void CRTCContext::AddMarkMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddMarkMovement(m_pHandle, dTargetX, dTargetY));
	}
	
	/**
	* CRTCContext::AddTimedMarkMovement - Adds a timed Mark movement to the open list
	* @param[in] dTargetX - X Position.
	* @param[in] dTargetY - Y Position.
	* @param[in] dDurationInMicroseconds - Duration of mark movement in Microseconds.
	*/
	void CRTCContext::AddTimedMarkMovement(const LibMCDriver_ScanLab_double dTargetX, const LibMCDriver_ScanLab_double dTargetY, const LibMCDriver_ScanLab_double dDurationInMicroseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddTimedMarkMovement(m_pHandle, dTargetX, dTargetY, dDurationInMicroseconds));
	}
	
	/**
	* CRTCContext::AddFreeVariable - Adds a free variable set to the open list
	* @param[in] nVariableNo - Number of the variable (0-7).
	* @param[in] nValue - Value to set.
	*/
	void CRTCContext::AddFreeVariable(const LibMCDriver_ScanLab_uint32 nVariableNo, const LibMCDriver_ScanLab_uint32 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddFreeVariable(m_pHandle, nVariableNo, nValue));
	}
	
	/**
	* CRTCContext::GetCurrentFreeVariable - Returns the currently set free variable.
	* @param[in] nVariableNo - Number of the variable (0-7).
	* @return Value to return.
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetCurrentFreeVariable(const LibMCDriver_ScanLab_uint32 nVariableNo)
	{
		LibMCDriver_ScanLab_uint32 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetCurrentFreeVariable(m_pHandle, nVariableNo, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CRTCContext::GetTimeStamp - Returns the current RTC time stamp.
	* @return TimeStamp Value.
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetTimeStamp()
	{
		LibMCDriver_ScanLab_uint32 resultTimeStamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetTimeStamp(m_pHandle, &resultTimeStamp));
		
		return resultTimeStamp;
	}
	
	/**
	* CRTCContext::GetRTCChannel - Returns an RTC Channel in real time. The signal register is instantly read and directly passed back to the caller.
	* @param[in] eChannelType - Internal RTC Channel type. See SCANLAB RTC Documentation for set_trigger for a proper explanation.
	* @return Internal Value of that signal.
	*/
	LibMCDriver_ScanLab_int32 CRTCContext::GetRTCChannel(const eRTCChannelType eChannelType)
	{
		LibMCDriver_ScanLab_int32 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetRTCChannel(m_pHandle, eChannelType, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CRTCContext::GetRTCInternalValue - Returns an internal RTC value by RTC Signal ID. The signal register is instantly read and directly passed back to the caller.
	* @param[in] nInternalSignalID - Internal RTC Signal ID. See SCANLAB RTC Documentation for set_trigger for a proper explanation. Some values are mapped from the enum definition of RTCChannelType.
	* @return Internal Value of that signal.
	*/
	LibMCDriver_ScanLab_int32 CRTCContext::GetRTCInternalValue(const LibMCDriver_ScanLab_uint32 nInternalSignalID)
	{
		LibMCDriver_ScanLab_int32 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetRTCInternalValue(m_pHandle, nInternalSignalID, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CRTCContext::StopExecution - Stops the execution of the current list immediately.
	*/
	void CRTCContext::StopExecution()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_StopExecution(m_pHandle));
	}
	
	/**
	* CRTCContext::DrawHatchesOIE - Writes a list of hatches into the open list with OIE Enabled.
	* @param[in] HatchesBuffer - Hatches to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Jump speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	* @param[in] nOIEPIDControlIndex - OIE PID Control Index. 0 disables PID Control, MUST be smaller or equal 63.
	*/
	void CRTCContext::DrawHatchesOIE(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue, const LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DrawHatchesOIE(m_pHandle, (LibMCDriver_ScanLab_uint64)HatchesBuffer.size(), HatchesBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue, nOIEPIDControlIndex));
	}
	
	/**
	* CRTCContext::AddLayerToList - Adds a layer instance to the current open list.
	* @param[in] pLayer - Instance of the layer to add to the lists.
	* @param[in] bFailIfNonAssignedDataExists - If true, fails if there is a laser index that does not match.
	*/
	void CRTCContext::AddLayerToList(classParam<LibMCEnv::CToolpathLayer> pLayer, const bool bFailIfNonAssignedDataExists)
	{
		LibMCEnvHandle hLayer = pLayer.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddLayerToList(m_pHandle, hLayer, bFailIfNonAssignedDataExists));
	}
	
	/**
	* CRTCContext::WaitForEncoderX - Adds a command to wait for the encoder for reaching an X axis position. Fails if Mark on the Fly is not enabled.
	* @param[in] dPositionInMM - Position Value to reach in mm.
	* @param[in] bInPositiveHalfPlane - If true, waits for the encoder reaching a value that is larger than PositionInMM. If false, waits for the encoder reaching a value that is smaller than PositionInMM.
	*/
	void CRTCContext::WaitForEncoderX(const LibMCDriver_ScanLab_double dPositionInMM, const bool bInPositiveHalfPlane)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_WaitForEncoderX(m_pHandle, dPositionInMM, bInPositiveHalfPlane));
	}
	
	/**
	* CRTCContext::WaitForEncoderY - Adds a command to wait for the encoder for reaching an Y axis position. Fails if Mark on the Fly is not enabled.
	* @param[in] dPositionInMM - Position Value to reach in mm.
	* @param[in] bInPositiveHalfPlane - If true, waits for the encoder reaching a value that is larger than PositionInMM. If false, waits for the encoder reaching a value that is smaller than PositionInMM.
	*/
	void CRTCContext::WaitForEncoderY(const LibMCDriver_ScanLab_double dPositionInMM, const bool bInPositiveHalfPlane)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_WaitForEncoderY(m_pHandle, dPositionInMM, bInPositiveHalfPlane));
	}
	
	/**
	* CRTCContext::WaitForEncoderXSteps - Adds a command to wait for the encoder for reaching an X axis position. Fails if Mark on the Fly is not enabled.
	* @param[in] nPositionInSteps - Position Value to reach in steps.
	* @param[in] bInPositiveHalfPlane - If true, waits for the encoder reaching a value that is larger than PositionInMM. If false, waits for the encoder reaching a value that is smaller than PositionInMM.
	*/
	void CRTCContext::WaitForEncoderXSteps(const LibMCDriver_ScanLab_int32 nPositionInSteps, const bool bInPositiveHalfPlane)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_WaitForEncoderXSteps(m_pHandle, nPositionInSteps, bInPositiveHalfPlane));
	}
	
	/**
	* CRTCContext::WaitForEncoderYSteps - Adds a command to wait for the encoder for reaching an Y axis position. Fails if Mark on the Fly is not enabled.
	* @param[in] nPositionInSteps - Position Value to reach in steps.
	* @param[in] bInPositiveHalfPlane - If true, waits for the encoder reaching a value that is larger than PositionInMM. If false, waits for the encoder reaching a value that is smaller than PositionInMM.
	*/
	void CRTCContext::WaitForEncoderYSteps(const LibMCDriver_ScanLab_int32 nPositionInSteps, const bool bInPositiveHalfPlane)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_WaitForEncoderYSteps(m_pHandle, nPositionInSteps, bInPositiveHalfPlane));
	}
	
	/**
	* CRTCContext::AddCustomDelay - Adds a custom delay to the list
	* @param[in] nDelayInMicroseconds - Custom delay value in microseconds (MUST be multiple of 10)
	*/
	void CRTCContext::AddCustomDelay(const LibMCDriver_ScanLab_uint32 nDelayInMicroseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddCustomDelay(m_pHandle, nDelayInMicroseconds));
	}
	
	/**
	* CRTCContext::GetCorrectionFactor - Returns correction factor of Card Calibration (in bits per mm)
	* @return CorrectionFactor
	*/
	LibMCDriver_ScanLab_double CRTCContext::GetCorrectionFactor()
	{
		LibMCDriver_ScanLab_double resultCorrectionFactor = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetCorrectionFactor(m_pHandle, &resultCorrectionFactor));
		
		return resultCorrectionFactor;
	}
	
	/**
	* CRTCContext::GetStatus - Returns status of list execution
	* @param[out] bBusy - Execution is busy
	* @param[out] nPosition - Returns current executed position
	*/
	void CRTCContext::GetStatus(bool & bBusy, LibMCDriver_ScanLab_uint32 & nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetStatus(m_pHandle, &bBusy, &nPosition));
	}
	
	/**
	* CRTCContext::GetHeadStatus - Returns status of scan head
	* @param[in] nHeadNo - Head Number
	* @param[out] bPositionXisOK - Position X is ok
	* @param[out] bPositionYisOK - Position Y is ok
	* @param[out] bTemperatureisOK - Temperature is ok
	* @param[out] bPowerisOK - Power is ok
	*/
	void CRTCContext::GetHeadStatus(const LibMCDriver_ScanLab_uint32 nHeadNo, bool & bPositionXisOK, bool & bPositionYisOK, bool & bTemperatureisOK, bool & bPowerisOK)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetHeadStatus(m_pHandle, nHeadNo, &bPositionXisOK, &bPositionYisOK, &bTemperatureisOK, &bPowerisOK));
	}
	
	/**
	* CRTCContext::GetStateValues - Returns status values of scan head
	* @param[out] bLaserIsOn - Laser is on
	* @param[out] nPositionX - Current Position X in Units
	* @param[out] nPositionY - Current Position Y in Units
	* @param[out] nPositionZ - Current Position Z in Units
	* @param[out] nCorrectedPositionX - Current Position X in Units
	* @param[out] nCorrectedPositionY - Current Position Y in Units
	* @param[out] nCorrectedPositionZ - Current Position Z in Units
	* @param[out] nFocusShift - Current Focus Shift in Units
	* @param[out] nMarkSpeed - Current Mark Speed in Units
	*/
	void CRTCContext::GetStateValues(bool & bLaserIsOn, LibMCDriver_ScanLab_int32 & nPositionX, LibMCDriver_ScanLab_int32 & nPositionY, LibMCDriver_ScanLab_int32 & nPositionZ, LibMCDriver_ScanLab_int32 & nCorrectedPositionX, LibMCDriver_ScanLab_int32 & nCorrectedPositionY, LibMCDriver_ScanLab_int32 & nCorrectedPositionZ, LibMCDriver_ScanLab_int32 & nFocusShift, LibMCDriver_ScanLab_int32 & nMarkSpeed)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetStateValues(m_pHandle, &bLaserIsOn, &nPositionX, &nPositionY, &nPositionZ, &nCorrectedPositionX, &nCorrectedPositionY, &nCorrectedPositionZ, &nFocusShift, &nMarkSpeed));
	}
	
	/**
	* CRTCContext::GetInputPointer - returns current input list position
	* @return Returns current position of open list
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetInputPointer()
	{
		LibMCDriver_ScanLab_uint32 resultPosition = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetInputPointer(m_pHandle, &resultPosition));
		
		return resultPosition;
	}
	
	/**
	* CRTCContext::GetRTCVersion - Returns version information of the RTC Card
	* @param[out] nRTCVersion - RTC Card Version
	* @param[out] nRTCType - RTC Card Type
	* @param[out] nDLLVersion - RTC DLL Version
	* @param[out] nHEXVersion - RTC HEX Version
	* @param[out] nBIOSVersion - RTC BIOS Version
	*/
	void CRTCContext::GetRTCVersion(LibMCDriver_ScanLab_uint32 & nRTCVersion, LibMCDriver_ScanLab_uint32 & nRTCType, LibMCDriver_ScanLab_uint32 & nDLLVersion, LibMCDriver_ScanLab_uint32 & nHEXVersion, LibMCDriver_ScanLab_uint32 & nBIOSVersion)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetRTCVersion(m_pHandle, &nRTCVersion, &nRTCType, &nDLLVersion, &nHEXVersion, &nBIOSVersion));
	}
	
	/**
	* CRTCContext::SetCommunicationTimeouts - Set RTC Ethernet communication timeouts for a specific connection. The Driver defaults will not be changed.
	* @param[in] dInitialTimeout - Initial timeout in ms
	* @param[in] dMaxTimeout - Max timeout in ms
	* @param[in] dMultiplier - Multiplier
	*/
	void CRTCContext::SetCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetCommunicationTimeouts(m_pHandle, dInitialTimeout, dMaxTimeout, dMultiplier));
	}
	
	/**
	* CRTCContext::GetCommunicationTimeouts - Get RTC Ethernet communication timeouts
	* @param[out] dInitialTimeout - Initial timeout in ms
	* @param[out] dMaxTimeout - Max timeout in ms
	* @param[out] dMultiplier - Multiplier
	*/
	void CRTCContext::GetCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetCommunicationTimeouts(m_pHandle, &dInitialTimeout, &dMaxTimeout, &dMultiplier));
	}
	
	/**
	* CRTCContext::InitializeForOIE - Initializes the RTC card for the open interface extension. MUST be called before the OIE is initialized.
	* @param[in] SignalChannelsBuffer - Array of signal channels. MUST NOT be empty
	* @param[in] eOperationMode - OIE Operation Mode
	*/
	void CRTCContext::InitializeForOIE(const CInputVector<LibMCDriver_ScanLab_uint32> & SignalChannelsBuffer, const eOIEOperationMode eOperationMode)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_InitializeForOIE(m_pHandle, (LibMCDriver_ScanLab_uint64)SignalChannelsBuffer.size(), SignalChannelsBuffer.data(), eOperationMode));
	}
	
	/**
	* CRTCContext::SetLaserPinOut - Sets the laser pin outputs to a certain state. Control command, has immediate effect.
	* @param[in] bLaserOut1 - Value for Laser Out Pin 1
	* @param[in] bLaserOut2 - Value for Laser Out Pin 2
	*/
	void CRTCContext::SetLaserPinOut(const bool bLaserOut1, const bool bLaserOut2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserPinOut(m_pHandle, bLaserOut1, bLaserOut2));
	}
	
	/**
	* CRTCContext::GetLaserPinIn - Read the laser pin input values. Control command, has immediate effect.
	* @param[out] bLaserOut1 - Value for Laser In Pin 1
	* @param[out] bLaserOut2 - Value for Laser In Pin 2
	*/
	void CRTCContext::GetLaserPinIn(bool & bLaserOut1, bool & bLaserOut2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetLaserPinIn(m_pHandle, &bLaserOut1, &bLaserOut2));
	}
	
	/**
	* CRTCContext::AddLaserPinOutToList - Adds the laser pin command to the current open list.
	* @param[in] bLaserOut1 - Value for Laser Out Pin 1
	* @param[in] bLaserOut2 - Value for Laser Out Pin 2
	*/
	void CRTCContext::AddLaserPinOutToList(const bool bLaserOut1, const bool bLaserOut2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddLaserPinOutToList(m_pHandle, bLaserOut1, bLaserOut2));
	}
	
	/**
	* CRTCContext::AddWriteDigitalIOList - Adds the change of all 16 digital IO Ports to the current open list.
	* @param[in] nDigitalOutput - Value for the digital IO. MUST be between 0 and 65535.
	*/
	void CRTCContext::AddWriteDigitalIOList(const LibMCDriver_ScanLab_uint32 nDigitalOutput)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddWriteDigitalIOList(m_pHandle, nDigitalOutput));
	}
	
	/**
	* CRTCContext::AddWriteMaskedDigitalIOList - Adds the change a subset of 16 digital IO Ports to the current open list.
	* @param[in] nDigitalOutput - Value for the digital IO. MUST be between 0 and 65535.
	* @param[in] nOutputMask - Mask of the digital IO. Only the bits with value 1 are changed in the output state. MUST be between 0 and 65535.
	*/
	void CRTCContext::AddWriteMaskedDigitalIOList(const LibMCDriver_ScanLab_uint32 nDigitalOutput, const LibMCDriver_ScanLab_uint32 nOutputMask)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddWriteMaskedDigitalIOList(m_pHandle, nDigitalOutput, nOutputMask));
	}
	
	/**
	* CRTCContext::EnableOIE - Writes an OIE enabling command block to the open list.
	*/
	void CRTCContext::EnableOIE()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableOIE(m_pHandle));
	}
	
	/**
	* CRTCContext::DisableOIE - Writes an OIE disabling command block to the open list.
	*/
	void CRTCContext::DisableOIE()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableOIE(m_pHandle));
	}
	
	/**
	* CRTCContext::CreateNLightAFXBeamProfileSelector - Creates an nLight AFX Beam Selector instance. If called multiple times, the same instance will be returned.
	* @return nLight Profile selector instance.
	*/
	PNLightAFXProfileSelector CRTCContext::CreateNLightAFXBeamProfileSelector()
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_CreateNLightAFXBeamProfileSelector(m_pHandle, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CNLightAFXProfileSelector>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCContext::AddGPIOSequence - Adds a GPIO Sequence. Fails if Sequence with the same identifier already exists.
	* @param[in] sIdentifier - Identifier for the sequence.
	* @return GPIOSequence instance.
	*/
	PGPIOSequence CRTCContext::AddGPIOSequence(const std::string & sIdentifier)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddGPIOSequence(m_pHandle, sIdentifier.c_str(), &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CGPIOSequence>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCContext::WriteGPIOSequenceToList - Writes a GPIO Sequence to the current list. Fails if sequence does not exist.
	* @param[in] sIdentifier - Identifier for the sequence.
	*/
	void CRTCContext::WriteGPIOSequenceToList(const std::string & sIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_WriteGPIOSequenceToList(m_pHandle, sIdentifier.c_str()));
	}
	
	/**
	* CRTCContext::FindGPIOSequence - Finds a GPIO Sequence. 
	* @param[in] sIdentifier - Identifier for the sequence.
	* @param[in] bMustExist - If true, the call fails if Sequence with the identifier does not exist.
	* @return GPIOSequence instance. Returns null, if MustExist is fales and a sequence with the identifier does not exist.
	*/
	PGPIOSequence CRTCContext::FindGPIOSequence(const std::string & sIdentifier, const bool bMustExist)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_FindGPIOSequence(m_pHandle, sIdentifier.c_str(), bMustExist, &hInstance));
		
		if (hInstance) {
			return std::make_shared<CGPIOSequence>(m_pWrapper, hInstance);
		} else {
			return nullptr;
		}
	}
	
	/**
	* CRTCContext::DeleteGPIOSequence - Deletes a GPIO Sequence. Does nothing if Sequence with the identifier does not exists.
	* @param[in] sIdentifier - Identifier for the sequence.
	*/
	void CRTCContext::DeleteGPIOSequence(const std::string & sIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DeleteGPIOSequence(m_pHandle, sIdentifier.c_str()));
	}
	
	/**
	* CRTCContext::StartOIEMeasurement - Writes an OIE measurement start command block to the open list. Same as StartOIEMeasurement with false as parameter.
	*/
	void CRTCContext::StartOIEMeasurement()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_StartOIEMeasurement(m_pHandle));
	}
	
	/**
	* CRTCContext::StartOIEMeasurementEx - Writes an OIE measurement start command block to the open list, with parameterized LaserOn Trigger
	* @param[in] bLaserOnTrigger - If true, only triggers a measurement, when the laser is on.
	*/
	void CRTCContext::StartOIEMeasurementEx(const bool bLaserOnTrigger)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_StartOIEMeasurementEx(m_pHandle, bLaserOnTrigger));
	}
	
	/**
	* CRTCContext::StopOIEMeasurement - Writes an OIE measurement start command block to the open list.
	*/
	void CRTCContext::StopOIEMeasurement()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_StopOIEMeasurement(m_pHandle));
	}
	
	/**
	* CRTCContext::SetOIEPIDMode - Sets OIE PID Index.
	* @param[in] nOIEPIDIndex - OIE PID Index. MUST be between 0 and 63. 0 means PID disabled.
	*/
	void CRTCContext::SetOIEPIDMode(const LibMCDriver_ScanLab_uint32 nOIEPIDIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetOIEPIDMode(m_pHandle, nOIEPIDIndex));
	}
	
	/**
	* CRTCContext::EnableOIEPIDControl - Enables OIE PID Control. Affects only subsequent layers that are drawn into lists.
	*/
	void CRTCContext::EnableOIEPIDControl()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableOIEPIDControl(m_pHandle));
	}
	
	/**
	* CRTCContext::DisableOIEPIDControl - Disables OIE PID Control.
	*/
	void CRTCContext::DisableOIEPIDControl()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableOIEPIDControl(m_pHandle));
	}
	
	/**
	* CRTCContext::ClearOIEMeasurementTags - Clears all stored OIE Measurement tags of the context. New Tag Indices will start from 0 again.
	*/
	void CRTCContext::ClearOIEMeasurementTags()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ClearOIEMeasurementTags(m_pHandle));
	}
	
	/**
	* CRTCContext::EnableOIEMeasurementTagging - Enables OIE Measurement tagging.
	*/
	void CRTCContext::EnableOIEMeasurementTagging()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableOIEMeasurementTagging(m_pHandle));
	}
	
	/**
	* CRTCContext::DisableOIEMeasurementTagging - Disables OIE Measurement tagging.
	*/
	void CRTCContext::DisableOIEMeasurementTagging()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableOIEMeasurementTagging(m_pHandle));
	}
	
	/**
	* CRTCContext::GetOIEMaxMeasurementTag - Returns the current maximum measurement tag that has been sent to the OIE.
	* @return Measurement Tag that has been sent to the OIE.
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetOIEMaxMeasurementTag()
	{
		LibMCDriver_ScanLab_uint32 resultMeasurementTag = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetOIEMaxMeasurementTag(m_pHandle, &resultMeasurementTag));
		
		return resultMeasurementTag;
	}
	
	/**
	* CRTCContext::MapOIEMeasurementTag - Maps an OIE Measurement tag back to the original scan parameters.
	* @param[in] nMeasurementTag - Measurement Tag that has been sent to the OIE.
	* @param[out] nPartID - ID of the part.
	* @param[out] nProfileID - ID of the profile.
	* @param[out] nSegmentID - ID of the segment.
	* @param[out] nVectorID - ID of the vector.
	*/
	void CRTCContext::MapOIEMeasurementTag(const LibMCDriver_ScanLab_uint32 nMeasurementTag, LibMCDriver_ScanLab_uint32 & nPartID, LibMCDriver_ScanLab_uint32 & nProfileID, LibMCDriver_ScanLab_uint32 & nSegmentID, LibMCDriver_ScanLab_uint32 & nVectorID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_MapOIEMeasurementTag(m_pHandle, nMeasurementTag, &nPartID, &nProfileID, &nSegmentID, &nVectorID));
	}
	
	/**
	* CRTCContext::DisableSkyWriting - Disable skywriting.
	*/
	void CRTCContext::DisableSkyWriting()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableSkyWriting(m_pHandle));
	}
	
	/**
	* CRTCContext::EnableSkyWritingMode1 - Enables skywriting on the list in mode 1. See Scanlab RTC Documentation for details.
	* @param[in] dTimelag - Skywriting Timelag
	* @param[in] nLaserOnShift - Skywriting Laser On Shift
	* @param[in] nNPrev - Duration of pre-motion in ticks
	* @param[in] nNPost - Duration of post-motion in ticks. 
	*/
	void CRTCContext::EnableSkyWritingMode1(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableSkyWritingMode1(m_pHandle, dTimelag, nLaserOnShift, nNPrev, nNPost));
	}
	
	/**
	* CRTCContext::EnableSkyWritingMode2 - Enables skywriting on the list in mode 2. See Scanlab RTC Documentation for details.
	* @param[in] dTimelag - Skywriting Timelag
	* @param[in] nLaserOnShift - Skywriting Laser On Shift
	* @param[in] nNPrev - Duration of pre-motion in ticks
	* @param[in] nNPost - Duration of post-motion in ticks. 
	*/
	void CRTCContext::EnableSkyWritingMode2(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableSkyWritingMode2(m_pHandle, dTimelag, nLaserOnShift, nNPrev, nNPost));
	}
	
	/**
	* CRTCContext::EnableSkyWritingMode3 - Enables skywriting on the list in mode 3. See Scanlab RTC Documentation for details.
	* @param[in] dTimelag - Skywriting Timelag
	* @param[in] nLaserOnShift - Skywriting Laser On Shift
	* @param[in] nNPrev - Duration of pre-motion in ticks
	* @param[in] nNPost - Duration of post-motion in ticks. 
	* @param[in] dLimit - Skywriting Angle limit
	*/
	void CRTCContext::EnableSkyWritingMode3(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost, const LibMCDriver_ScanLab_double dLimit)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableSkyWritingMode3(m_pHandle, dTimelag, nLaserOnShift, nNPrev, nNPost, dLimit));
	}
	
	/**
	* CRTCContext::EnableSkyWritingMode4 - Enables skywriting on the list in mode 4. See Scanlab RTC Documentation for details.
	* @param[in] dTimelag - Skywriting Timelag
	* @param[in] nLaserOnShift - Skywriting Laser On Shift
	* @param[in] nNPrev - Duration of pre-motion in ticks
	* @param[in] nNPost - Duration of post-motion in ticks. 
	* @param[in] dLimit - Skywriting Angle limit
	*/
	void CRTCContext::EnableSkyWritingMode4(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost, const LibMCDriver_ScanLab_double dLimit)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableSkyWritingMode4(m_pHandle, dTimelag, nLaserOnShift, nNPrev, nNPost, dLimit));
	}
	
	/**
	* CRTCContext::SetTransformationAngle - Sets the transformation angle of the scan field.
	* @param[in] dAngleInDegrees - Angle in Degrees
	*/
	void CRTCContext::SetTransformationAngle(const LibMCDriver_ScanLab_double dAngleInDegrees)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetTransformationAngle(m_pHandle, dAngleInDegrees));
	}
	
	/**
	* CRTCContext::SetTransformationScale - Sets the transformation scale of the scan field.
	* @param[in] dScaleFactor - Scale Factor (1.0 is no scaling). Allowed value is -16 to 16.
	*/
	void CRTCContext::SetTransformationScale(const LibMCDriver_ScanLab_double dScaleFactor)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetTransformationScale(m_pHandle, dScaleFactor));
	}
	
	/**
	* CRTCContext::SetTransformationOffset - Sets the transformation offset of the scan field.
	* @param[in] nOffsetX - Offset in X (in bits)
	* @param[in] nOffsetY - Offset in X (in bits)
	*/
	void CRTCContext::SetTransformationOffset(const LibMCDriver_ScanLab_int32 nOffsetX, const LibMCDriver_ScanLab_int32 nOffsetY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetTransformationOffset(m_pHandle, nOffsetX, nOffsetY));
	}
	
	/**
	* CRTCContext::SetTransformationMatrix - Sets the transformation matrix of the scan field.
	* @param[in] dM11 - Upper left field of the transformation matrix
	* @param[in] dM12 - Upper right field of the transformation matrix
	* @param[in] dM21 - Lower left field of the transformation matrix
	* @param[in] dM22 - Lower right field of the transformation matrix
	*/
	void CRTCContext::SetTransformationMatrix(const LibMCDriver_ScanLab_double dM11, const LibMCDriver_ScanLab_double dM12, const LibMCDriver_ScanLab_double dM21, const LibMCDriver_ScanLab_double dM22)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetTransformationMatrix(m_pHandle, dM11, dM12, dM21, dM22));
	}
	
	/**
	* CRTCContext::PrepareRecording - Prepares recording of position data of the RTC Card. This needs to be called before any list is started.
	* @param[in] bKeepInMemory - If true, the recording will be persisted in the driver and can be recovered by its UUID. If false, the lifetime of the recording data ends with the release of the recording instance. Persistent Recordings will eat up a lot of memory and should be taken under careful consideration. Recordings can be made non-persistent with the RemoveFromMemory function of the instance.
	* @return Recording instance.
	*/
	PRTCRecording CRTCContext::PrepareRecording(const bool bKeepInMemory)
	{
		LibMCDriver_ScanLabHandle hRecordingInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_PrepareRecording(m_pHandle, bKeepInMemory, &hRecordingInstance));
		
		if (!hRecordingInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCRecording>(m_pWrapper, hRecordingInstance);
	}
	
	/**
	* CRTCContext::HasRecording - Checks if a recording exists in the driver memory. Recording MUST have been created with KeepInMemory set to true.
	* @param[in] sUUID - UUID of the recording to find.
	* @return Returns if the recording exists.
	*/
	bool CRTCContext::HasRecording(const std::string & sUUID)
	{
		bool resultRecordingExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_HasRecording(m_pHandle, sUUID.c_str(), &resultRecordingExists));
		
		return resultRecordingExists;
	}
	
	/**
	* CRTCContext::FindRecording - Find a recording in the driver memory. Recording MUST have been created with KeepInMemory set to true. Fails if recording does not exist.
	* @param[in] sUUID - UUID of the recording to find.
	* @return Recording instance.
	*/
	PRTCRecording CRTCContext::FindRecording(const std::string & sUUID)
	{
		LibMCDriver_ScanLabHandle hRecordingInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_FindRecording(m_pHandle, sUUID.c_str(), &hRecordingInstance));
		
		if (!hRecordingInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCRecording>(m_pWrapper, hRecordingInstance);
	}
	
	/**
	* CRTCContext::EnableTimelagCompensation - Enables timelag compensation.
	* @param[in] nTimeLagXYInMicroseconds - Time lag of XY axes (in microseconds). MUST be a multiple of 10.
	* @param[in] nTimeLagZInMicroseconds - Time lag of Z axis (in microseconds). MUST be a multiple of 10.
	*/
	void CRTCContext::EnableTimelagCompensation(const LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, const LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableTimelagCompensation(m_pHandle, nTimeLagXYInMicroseconds, nTimeLagZInMicroseconds));
	}
	
	/**
	* CRTCContext::DisableTimelagCompensation - Disables timelag compensation.
	*/
	void CRTCContext::DisableTimelagCompensation()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableTimelagCompensation(m_pHandle));
	}
	
	/**
	* CRTCContext::EnableMarkOnTheFly2D - Enables mark on the fly 2D. This is a list command.
	* @param[in] dScaleXInMMperEncoderStep - Scale factor X in mm per encoder step
	* @param[in] dScaleYInMMperEncoderStep - Scale factor Y in mm per encoder step
	*/
	void CRTCContext::EnableMarkOnTheFly2D(const LibMCDriver_ScanLab_double dScaleXInMMperEncoderStep, const LibMCDriver_ScanLab_double dScaleYInMMperEncoderStep)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableMarkOnTheFly2D(m_pHandle, dScaleXInMMperEncoderStep, dScaleYInMMperEncoderStep));
	}
	
	/**
	* CRTCContext::DisableMarkOnTheFly2D - Disable mark on the fly 2D. This is a list command.
	*/
	void CRTCContext::DisableMarkOnTheFly2D()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableMarkOnTheFly2D(m_pHandle));
	}
	
	/**
	* CRTCContext::MarkOnTheFly2DIsEnabled - Returns if mark on the fly 2D has been enabled.
	* @return Returns true if mark on the fly 2D is enabled.
	*/
	bool CRTCContext::MarkOnTheFly2DIsEnabled()
	{
		bool resultIsEnabled = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_MarkOnTheFly2DIsEnabled(m_pHandle, &resultIsEnabled));
		
		return resultIsEnabled;
	}
	
	/**
	* CRTCContext::Get2DMarkOnTheFlyPosition - Returns 2D mark on the fly position.
	* @param[out] nPositionX - Mark on the fly position X
	* @param[out] nPositionY - Mark on the fly position Y
	*/
	void CRTCContext::Get2DMarkOnTheFlyPosition(LibMCDriver_ScanLab_int32 & nPositionX, LibMCDriver_ScanLab_int32 & nPositionY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_Get2DMarkOnTheFlyPosition(m_pHandle, &nPositionX, &nPositionY));
	}
	
	/**
	* CRTCContext::CheckOnTheFlyError - Checks mark on the fly error.
	* @param[in] bFailIfError - If true, the call will fail in case of an error.
	* @return Bitfield corresponding to the get_marking_info call, as described in the RTC SDK Documentation.
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::CheckOnTheFlyError(const bool bFailIfError)
	{
		LibMCDriver_ScanLab_uint32 resultErrorCode = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_CheckOnTheFlyError(m_pHandle, bFailIfError, &resultErrorCode));
		
		return resultErrorCode;
	}
	
	/**
	* CRTCContext::LaserPowerCalibrationIsEnabled - Returns if the laser power calibration table is non-empty.
	* @return Laser Calibration Is Enabled
	*/
	bool CRTCContext::LaserPowerCalibrationIsEnabled()
	{
		bool resultCalibrationEnabled = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_LaserPowerCalibrationIsEnabled(m_pHandle, &resultCalibrationEnabled));
		
		return resultCalibrationEnabled;
	}
	
	/**
	* CRTCContext::LaserPowerCalibrationIsLinear - Returns if the laser power calibration table has one entry.
	* @return Laser Calibration Is Affine Linear
	*/
	bool CRTCContext::LaserPowerCalibrationIsLinear()
	{
		bool resultCalibrationIsLinear = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_LaserPowerCalibrationIsLinear(m_pHandle, &resultCalibrationIsLinear));
		
		return resultCalibrationIsLinear;
	}
	
	/**
	* CRTCContext::ClearLaserPowerCalibration - Clears the laser power calibration table.
	*/
	void CRTCContext::ClearLaserPowerCalibration()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ClearLaserPowerCalibration(m_pHandle));
	}
	
	/**
	* CRTCContext::GetLaserPowerCalibration - Returns the laser power calibration table. Fails if laser calibration is not enabled.
	* @param[out] CalibrationPointsBuffer - Laser Calibration Points
	*/
	void CRTCContext::GetLaserPowerCalibration(std::vector<sLaserCalibrationPoint> & CalibrationPointsBuffer)
	{
		LibMCDriver_ScanLab_uint64 elementsNeededCalibrationPoints = 0;
		LibMCDriver_ScanLab_uint64 elementsWrittenCalibrationPoints = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetLaserPowerCalibration(m_pHandle, 0, &elementsNeededCalibrationPoints, nullptr));
		CalibrationPointsBuffer.resize((size_t) elementsNeededCalibrationPoints);
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetLaserPowerCalibration(m_pHandle, elementsNeededCalibrationPoints, &elementsWrittenCalibrationPoints, CalibrationPointsBuffer.data()));
	}
	
	/**
	* CRTCContext::SetLinearLaserPowerCalibration - Enables the laser power calibration with an affine linear tranformation.
	* @param[in] dPowerOffsetInPercent - Additional offset of the Power value.
	* @param[in] dPowerOutputScaling - Scaling factor of the laser output.
	*/
	void CRTCContext::SetLinearLaserPowerCalibration(const LibMCDriver_ScanLab_double dPowerOffsetInPercent, const LibMCDriver_ScanLab_double dPowerOutputScaling)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLinearLaserPowerCalibration(m_pHandle, dPowerOffsetInPercent, dPowerOutputScaling));
	}
	
	/**
	* CRTCContext::SetPiecewiseLinearLaserPowerCalibration - Enables the laser power calibration with multiple calibration point values. Table MUST NOT have negative power entries. Laser Power Output will be linear scaled with the given values within their respective intervals. Any laser power outside of the minimum or maximum Power values will be scaled according to the respective minimum or maximum scaling value.
	* @param[in] CalibrationPointsBuffer - Laser Calibration Points. Array will be sorted by Laser Power Keys. Array MUST NOT be empty. Array MUST NOT have duplicate entries (to an accuracy of 0.01 Percent).
	*/
	void CRTCContext::SetPiecewiseLinearLaserPowerCalibration(const CInputVector<sLaserCalibrationPoint> & CalibrationPointsBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetPiecewiseLinearLaserPowerCalibration(m_pHandle, (LibMCDriver_ScanLab_uint64)CalibrationPointsBuffer.size(), CalibrationPointsBuffer.data()));
	}
	
	/**
	* CRTCContext::EnableSpatialLaserPowerModulation - Enables a spatial laser power modulation via callback.
	* @param[in] pModulationCallback - Callback to call for modulating the laser power.
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CRTCContext::EnableSpatialLaserPowerModulation(const SpatialPowerModulationCallback pModulationCallback, const LibMCDriver_ScanLab_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableSpatialLaserPowerModulation(m_pHandle, pModulationCallback, pUserData));
	}
	
	/**
	* CRTCContext::DisablePowerModulation - Disables all power modulation functions.
	*/
	void CRTCContext::DisablePowerModulation()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisablePowerModulation(m_pHandle));
	}
	
	/**
	* CRTCContext::EnableLineSubdivision - If this function is enabled, all mark lines will be subdivided so that the maximum length is small than the threshold.
	* @param[in] dLengthThreshold - Length threshold in mm.
	*/
	void CRTCContext::EnableLineSubdivision(const LibMCDriver_ScanLab_double dLengthThreshold)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableLineSubdivision(m_pHandle, dLengthThreshold));
	}
	
	/**
	* CRTCContext::DisableLineSubdivision - Disables the subdivision of mark lines.
	*/
	void CRTCContext::DisableLineSubdivision()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableLineSubdivision(m_pHandle));
	}
	
	/**
	* CRTCContext::ReadMultiMCBSP - Reads a multi MCBSP register from the RTC Card. Should be used only for debugging purposes.
	* @param[in] nRegisterNo - Number of the register to read.
	* @return Value of the register.
	*/
	LibMCDriver_ScanLab_int32 CRTCContext::ReadMultiMCBSP(const LibMCDriver_ScanLab_uint32 nRegisterNo)
	{
		LibMCDriver_ScanLab_int32 resultRegisterContent = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ReadMultiMCBSP(m_pHandle, nRegisterNo, &resultRegisterContent));
		
		return resultRegisterContent;
	}
	
	/**
	* CRTCContext::CreateUARTConnection - Creates a new UART Connection. Closes any other one that might be active.
	* @param[in] nDesiredBaudRate - Desired baud rate. 160 Bd…12.8 MBd.  The other RS-232 interface parameters cannot be altered (data bits: 8, start bits: 1, stop bits: 1, parity: none).
	* @return UART Connection instance.
	*/
	PUARTConnection CRTCContext::CreateUARTConnection(const LibMCDriver_ScanLab_uint32 nDesiredBaudRate)
	{
		LibMCDriver_ScanLabHandle hConnection = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_CreateUARTConnection(m_pHandle, nDesiredBaudRate, &hConnection));
		
		if (!hConnection) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CUARTConnection>(m_pWrapper, hConnection);
	}
	
	/**
	* CRTCContext::EnableScanAhead - Enables the Scanahead mode of the RTC card.
	* @param[in] nHeadNo - Head Number
	* @param[in] nTableNo - Table Number
	*/
	void CRTCContext::EnableScanAhead(const LibMCDriver_ScanLab_uint32 nHeadNo, const LibMCDriver_ScanLab_uint32 nTableNo)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableScanAhead(m_pHandle, nHeadNo, nTableNo));
	}
	
	/**
	* CRTCContext::DisableScanAhead - Disables the Scanahead mode of the RTC card.
	*/
	void CRTCContext::DisableScanAhead()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableScanAhead(m_pHandle));
	}
	
	/**
	* CRTCContext::ActivateScanAheadAutoDelays - Activates the ScanAhead Auto Delays.
	*/
	void CRTCContext::ActivateScanAheadAutoDelays()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ActivateScanAheadAutoDelays(m_pHandle));
	}
	
	/**
	* CRTCContext::DeactivateScanAheadAutoDelays - Deactivates the ScanAhead Auto Delays.
	*/
	void CRTCContext::DeactivateScanAheadAutoDelays()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DeactivateScanAheadAutoDelays(m_pHandle));
	}
	
	/**
	* CRTCContext::ScanAheadAutoDelaysAreActivated - Returns if ScanAhead Auto Delays are activated.
	* @return Returns true if Auto Delays are activated.
	*/
	bool CRTCContext::ScanAheadAutoDelaysAreActivated()
	{
		bool resultActivated = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ScanAheadAutoDelaysAreActivated(m_pHandle, &resultActivated));
		
		return resultActivated;
	}
	
	/**
	* CRTCContext::SetScanAheadLaserShiftsInMicroseconds - Enables the Scanahead mode of the RTC card.
	* @param[in] dLaserOnShiftInMicroSeconds - Laser on shift in Microseconds. Will be rounded to 64th microseconds.
	* @param[in] dLaserOffShiftInMicroSeconds - Laser off shift in Microseconds. Will be rounded to 64th microseconds.
	*/
	void CRTCContext::SetScanAheadLaserShiftsInMicroseconds(const LibMCDriver_ScanLab_double dLaserOnShiftInMicroSeconds, const LibMCDriver_ScanLab_double dLaserOffShiftInMicroSeconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetScanAheadLaserShiftsInMicroseconds(m_pHandle, dLaserOnShiftInMicroSeconds, dLaserOffShiftInMicroSeconds));
	}
	
	/**
	* CRTCContext::SetScanAheadLaserShiftsInUnits - Enables the Scanahead mode of the RTC card.
	* @param[in] nLaserOnShift - Laser on shift in Units, which are 1/64th of a Microsecond.
	* @param[in] nLaserOffShift - Laser on shift in Units, which are 1/64th of a Microsecond.
	*/
	void CRTCContext::SetScanAheadLaserShiftsInUnits(const LibMCDriver_ScanLab_int32 nLaserOnShift, const LibMCDriver_ScanLab_int32 nLaserOffShift)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetScanAheadLaserShiftsInUnits(m_pHandle, nLaserOnShift, nLaserOffShift));
	}
	
	/**
	* CRTCContext::SetScanAheadLineParameters - Controls the Scanahead Line parameters.
	* @param[in] nCornerScale - Corner sharpness scale in Percent.. 100 percent means sharp corners. Values above 100 will be clipped to 100.
	* @param[in] nEndScale - Line end sharpness scale in Percent.. 100 percent means straight line ends. Values above 100 will be clipped to 100.
	* @param[in] nAccelerationScale - Fraction of active laser time (not path lenght) during acceleration in Percent.. 100 percent means sharp corners. Values above 100 will be clipped to 100.
	*/
	void CRTCContext::SetScanAheadLineParameters(const LibMCDriver_ScanLab_uint32 nCornerScale, const LibMCDriver_ScanLab_uint32 nEndScale, const LibMCDriver_ScanLab_uint32 nAccelerationScale)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetScanAheadLineParameters(m_pHandle, nCornerScale, nEndScale, nAccelerationScale));
	}
	
	/**
	 * Method definitions for class CRTCSelector
	 */
	
	/**
	* CRTCSelector::SearchCards - Searches Ethernet Cards
	* @param[in] sIP - IP Network Address.
	* @param[in] sNetmask - IP Netmask Address.
	* @param[in] nTimeout - Time out in microseconds.
	* @return Returns how many ethernet cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::SearchCards(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout)
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_SearchCards(m_pHandle, sIP.c_str(), sNetmask.c_str(), nTimeout, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::SearchCardsByRange - Searches Ethernet Cards
	* @param[in] sStartIP - IP Network Address.
	* @param[in] sEndIP - IP Network Address.
	* @param[in] nTimeout - Time out in microseconds.
	* @return Returns how many ethernet cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::SearchCardsByRange(const std::string & sStartIP, const std::string & sEndIP, const LibMCDriver_ScanLab_uint32 nTimeout)
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_SearchCardsByRange(m_pHandle, sStartIP.c_str(), sEndIP.c_str(), nTimeout, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::GetCardCount - Returns number of detected Cards
	* @return Returns how many cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::GetCardCount()
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_GetCardCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::GetEthernetCardCount - Returns number of found ethernet cards
	* @return Returns how many ethernet cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::GetEthernetCardCount()
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_GetEthernetCardCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::AcquireCard - Acquires a card and returns an RTCContext instance.
	* @param[in] nNumber - Number of Card (1-based). Must be between 1 and CardCount.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireCard(const LibMCDriver_ScanLab_uint32 nNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireCard(m_pHandle, nNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCSelector::AcquireCardBySerial - Acquires a card and returns an RTCContext instance.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireCardBySerial(m_pHandle, nSerialNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCSelector::AcquireEthernetCard - Acquires an ethernet card and returns an RTCContext instance.
	* @param[in] nNumber - Number of Card (1-based). Must be between 1 and EthernetCardCount.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireEthernetCard(const LibMCDriver_ScanLab_uint32 nNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireEthernetCard(m_pHandle, nNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCSelector::AcquireEthernetCardBySerial - Acquires an ethernet card and returns an RTCContext instance.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireEthernetCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireEthernetCardBySerial(m_pHandle, nSerialNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	 * Method definitions for class CDriver_ScanLab
	 */
	
	/**
	* CDriver_ScanLab::LoadSDK - Initializes the ScanLab SDK.
	* @param[in] sResourceName - Resource name of Scanlab DLL
	*/
	void CDriver_ScanLab::LoadSDK(const std::string & sResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_LoadSDK(m_pHandle, sResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLab::LoadCustomSDK - Initializes the ScanLab SDK from an external source.
	* @param[in] ScanlabDLLBuffer - Byte array of Scanlab DLL
	*/
	void CDriver_ScanLab::LoadCustomSDK(const CInputVector<LibMCDriver_ScanLab_uint8> & ScanlabDLLBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_LoadCustomSDK(m_pHandle, (LibMCDriver_ScanLab_uint64)ScanlabDLLBuffer.size(), ScanlabDLLBuffer.data()));
	}
	
	/**
	* CDriver_ScanLab::CreateRTCSelector - Creates and initializes a new RTC selector singleton. Should only be called once per Process.
	* @return New Selector instance
	*/
	PRTCSelector CDriver_ScanLab::CreateRTCSelector()
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_CreateRTCSelector(m_pHandle, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCSelector>(m_pWrapper, hInstance);
	}
	
	/**
	* CDriver_ScanLab::EnableJournaling - Enables journaling of the SDK. MUST be called before LoadSDK or LoadCustomSDK.
	*/
	void CDriver_ScanLab::EnableJournaling()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_EnableJournaling(m_pHandle));
	}
	
	/**
	* CDriver_ScanLab::SetFirmware - Sets the default firmware from the driver resources. If given, Initialise will upload this firmware before acquiring the RTC card.
	* @param[in] sFirmwareResource - resource name of the firmware program file.
	* @param[in] sFPGAResource - resource name of the firmware FPGA file.
	* @param[in] sAuxiliaryResource - resource name of the binary auxiliary file.
	*/
	void CDriver_ScanLab::SetFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_SetFirmware(m_pHandle, sFirmwareResource.c_str(), sFPGAResource.c_str(), sAuxiliaryResource.c_str()));
	}
	
	/**
	* CDriver_ScanLab::SetCustomFirmware - Sets the default firmware from a binary array. If given, Initialise will upload this firmware before acquiring the RTC card.
	* @param[in] FirmwareDataBuffer - byte array of the firmware program file.
	* @param[in] FPGADataBuffer - byte array of the firmware FPGA file.
	* @param[in] AuxiliaryDataBuffer - byte array of the binary auxiliary file.
	*/
	void CDriver_ScanLab::SetCustomFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_SetCustomFirmware(m_pHandle, (LibMCDriver_ScanLab_uint64)FirmwareDataBuffer.size(), FirmwareDataBuffer.data(), (LibMCDriver_ScanLab_uint64)FPGADataBuffer.size(), FPGADataBuffer.data(), (LibMCDriver_ScanLab_uint64)AuxiliaryDataBuffer.size(), AuxiliaryDataBuffer.data()));
	}
	
	/**
	 * Method definitions for class CDriver_ScanLab_RTC6
	 */
	
	/**
	* CDriver_ScanLab_RTC6::SetToSimulationMode - Turns the driver into a simulation mode.
	*/
	void CDriver_ScanLab_RTC6::SetToSimulationMode()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_SetToSimulationMode(m_pHandle));
	}
	
	/**
	* CDriver_ScanLab_RTC6::IsSimulationMode - Returns if the driver is in simulation mode.
	* @return Flag if driver is in simulation mode.
	*/
	bool CDriver_ScanLab_RTC6::IsSimulationMode()
	{
		bool resultSimulationModeEnabled = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_IsSimulationMode(m_pHandle, &resultSimulationModeEnabled));
		
		return resultSimulationModeEnabled;
	}
	
	/**
	* CDriver_ScanLab_RTC6::IsInitialized - Returns if the driver is initalized.
	* @return Flag if driver is initialized.
	*/
	bool CDriver_ScanLab_RTC6::IsInitialized()
	{
		bool resultIsInitialized = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_IsInitialized(m_pHandle, &resultIsInitialized));
		
		return resultIsInitialized;
	}
	
	/**
	* CDriver_ScanLab_RTC6::Initialise - Manually initializes the RTC6 Scanner Driver.
	* @param[in] sIP - IP Network Address. Empty string for local card.
	* @param[in] sNetmask - IP Netmask Address. Empty string for local card.
	* @param[in] nTimeout - Time out in microseconds.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	*/
	void CDriver_ScanLab_RTC6::Initialise(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout, const LibMCDriver_ScanLab_uint32 nSerialNumber)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_Initialise(m_pHandle, sIP.c_str(), sNetmask.c_str(), nTimeout, nSerialNumber));
	}
	
	/**
	* CDriver_ScanLab_RTC6::InitialiseFromConfiguration - Initializes the RTC6 Scanner Driver from a configuration preset. Calls Initialise, LoadFirmware, SetCorrectionFile, ConfigureLaserMode and ConfigureDelays.
	* @param[in] sPresetName - Name of the configuration preset.
	*/
	void CDriver_ScanLab_RTC6::InitialiseFromConfiguration(const std::string & sPresetName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_InitialiseFromConfiguration(m_pHandle, sPresetName.c_str()));
	}
	
	/**
	* CDriver_ScanLab_RTC6::SetCommunicationTimeouts - Set RTC Ethernet communication timeouts. The given values will be defaults for all subsequent connections.
	* @param[in] dInitialTimeout - Initial timeout in ms
	* @param[in] dMaxTimeout - Max timeout in ms
	* @param[in] dMultiplier - Multiplier
	*/
	void CDriver_ScanLab_RTC6::SetCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_SetCommunicationTimeouts(m_pHandle, dInitialTimeout, dMaxTimeout, dMultiplier));
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetIPAddress - Returns the IP Address of the RTC Card. Fails if driver has not been initialized.
	* @return IP Address Value.
	*/
	std::string CDriver_ScanLab_RTC6::GetIPAddress()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededIPAddress = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenIPAddress = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetIPAddress(m_pHandle, 0, &bytesNeededIPAddress, nullptr));
		std::vector<char> bufferIPAddress(bytesNeededIPAddress);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetIPAddress(m_pHandle, bytesNeededIPAddress, &bytesWrittenIPAddress, &bufferIPAddress[0]));
		
		return std::string(&bufferIPAddress[0]);
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetNetmask - Returns the Netmask of the RTC Card. Fails if driver has not been initialized.
	* @return Netmask Value.
	*/
	std::string CDriver_ScanLab_RTC6::GetNetmask()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededNetmask = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenNetmask = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetNetmask(m_pHandle, 0, &bytesNeededNetmask, nullptr));
		std::vector<char> bufferNetmask(bytesNeededNetmask);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetNetmask(m_pHandle, bytesNeededNetmask, &bytesWrittenNetmask, &bufferNetmask[0]));
		
		return std::string(&bufferNetmask[0]);
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetSerialNumber - Returns the Serial Number of the RTC Card. Fails if driver has not been initialized.
	* @return Serial Number of card.
	*/
	LibMCDriver_ScanLab_uint32 CDriver_ScanLab_RTC6::GetSerialNumber()
	{
		LibMCDriver_ScanLab_uint32 resultSerialNumber = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetSerialNumber(m_pHandle, &resultSerialNumber));
		
		return resultSerialNumber;
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetContext - Returns the RTC Context Instance. Fails if it card has not been initialised.
	* @return RTC Context Instance.
	*/
	PRTCContext CDriver_ScanLab_RTC6::GetContext()
	{
		LibMCDriver_ScanLabHandle hContextInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetContext(m_pHandle, &hContextInstance));
		
		if (!hContextInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hContextInstance);
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetSelector - Returns the RTC Selector Instance. Fails if it card has not been initialised.
	* @return RTC Selector Instance.
	*/
	PRTCSelector CDriver_ScanLab_RTC6::GetSelector()
	{
		LibMCDriver_ScanLabHandle hSelectorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetSelector(m_pHandle, &hSelectorInstance));
		
		if (!hSelectorInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCSelector>(m_pWrapper, hSelectorInstance);
	}
	
	/**
	* CDriver_ScanLab_RTC6::LoadFirmware - Loads the firmware from the driver resources. DEPRECIATED. Use SetFirmare before calling Initialise..
	* @param[in] sFirmwareResource - resource name of the firmware program file.
	* @param[in] sFPGAResource - resource name of the firmware FPGA file.
	* @param[in] sAuxiliaryResource - resource name of the binary auxiliary file.
	*/
	void CDriver_ScanLab_RTC6::LoadFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_LoadFirmware(m_pHandle, sFirmwareResource.c_str(), sFPGAResource.c_str(), sAuxiliaryResource.c_str()));
	}
	
	/**
	* CDriver_ScanLab_RTC6::LoadCustomFirmware - Loads the firmware from custom resources. DEPRECIATED. Use SetCustomFirmare before calling Initialise..
	* @param[in] FirmwareDataBuffer - byte array of the firmware program file.
	* @param[in] FPGADataBuffer - byte array of the firmware FPGA file.
	* @param[in] AuxiliaryDataBuffer - byte array of the binary auxiliary file.
	*/
	void CDriver_ScanLab_RTC6::LoadCustomFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_LoadCustomFirmware(m_pHandle, (LibMCDriver_ScanLab_uint64)FirmwareDataBuffer.size(), FirmwareDataBuffer.data(), (LibMCDriver_ScanLab_uint64)FPGADataBuffer.size(), FPGADataBuffer.data(), (LibMCDriver_ScanLab_uint64)AuxiliaryDataBuffer.size(), AuxiliaryDataBuffer.data()));
	}
	
	/**
	* CDriver_ScanLab_RTC6::SetCorrectionFile - Sets the correction file stream.
	* @param[in] CorrectionFileBuffer - binary data of the correction file.
	* @param[in] nTableNumber - Correction table index of card (1..8)
	* @param[in] nDimension - Is it a 2D or 3D correction file.
	* @param[in] nTableNumberHeadA - Table number of Head A.
	* @param[in] nTableNumberHeadB - Table number of Head B.
	*/
	void CDriver_ScanLab_RTC6::SetCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension, const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_SetCorrectionFile(m_pHandle, (LibMCDriver_ScanLab_uint64)CorrectionFileBuffer.size(), CorrectionFileBuffer.data(), nTableNumber, nDimension, nTableNumberHeadA, nTableNumberHeadB));
	}
	
	/**
	* CDriver_ScanLab_RTC6::ConfigureLaserMode - Configures the laser mode. MUST be called before any exposure.
	* @param[in] eLaserMode - Laser Mode Enum
	* @param[in] eLaserPort - Laser Port Enum
	* @param[in] dMaxLaserPower - Maximum laser power.
	* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
	* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
	* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
	* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
	* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
	* @param[in] bOutputSynchronizationActive - Output synchronization active
	*/
	void CDriver_ScanLab_RTC6::ConfigureLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort, const LibMCDriver_ScanLab_double dMaxLaserPower, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_ConfigureLaserMode(m_pHandle, eLaserMode, eLaserPort, dMaxLaserPower, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive));
	}
	
	/**
	* CDriver_ScanLab_RTC6::ConfigureDelays - Configures the default laser and scanner delays. ATTENTION: Will create and overwrite execution list 1!
	* @param[in] dLaserOnDelay - Laser On Delay in Microseconds
	* @param[in] dLaserOffDelay - Laser Off Delay in Microseconds
	* @param[in] dMarkDelay - Mark delay in microseconds (will be rounded to a multiple of 10)
	* @param[in] dJumpDelay - Jump delay in microseconds (will be rounded to a multiple of 10)
	* @param[in] dPolygonDelay - Polygon delay in microseconds (will be rounded to a multiple of 10)
	*/
	void CDriver_ScanLab_RTC6::ConfigureDelays(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay, const LibMCDriver_ScanLab_double dMarkDelay, const LibMCDriver_ScanLab_double dJumpDelay, const LibMCDriver_ScanLab_double dPolygonDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_ConfigureDelays(m_pHandle, dLaserOnDelay, dLaserOffDelay, dMarkDelay, dJumpDelay, dPolygonDelay));
	}
	
	/**
	* CDriver_ScanLab_RTC6::SetOIERecordingMode - Sets the recording mode for using the Open Interface extension. Will be taken into account by DrawLayer. Default is No Recording.
	* @param[in] eRecordingMode - Recording mode enum
	*/
	void CDriver_ScanLab_RTC6::SetOIERecordingMode(const eOIERecordingMode eRecordingMode)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_SetOIERecordingMode(m_pHandle, eRecordingMode));
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetOIERecordingMode - Returns the recording mode for using the Open Interface extension, taking into account by DrawLayer. Default is No Recording.
	* @return Recording mode enum
	*/
	eOIERecordingMode CDriver_ScanLab_RTC6::GetOIERecordingMode()
	{
		eOIERecordingMode resultRecordingMode = (eOIERecordingMode) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetOIERecordingMode(m_pHandle, &resultRecordingMode));
		
		return resultRecordingMode;
	}
	
	/**
	* CDriver_ScanLab_RTC6::EnableAttributeFilter - Enables filtering of the segments by segment attributes. A segment will only be drawn if the given integer attribute has the given value.
	* @param[in] sNameSpace - Namespace of Attribute to filter for.
	* @param[in] sAttributeName - Name of Attribute to filter for.
	* @param[in] nAttributeValue - Attribute Value to filter for.
	*/
	void CDriver_ScanLab_RTC6::EnableAttributeFilter(const std::string & sNameSpace, const std::string & sAttributeName, const LibMCDriver_ScanLab_int64 nAttributeValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_EnableAttributeFilter(m_pHandle, sNameSpace.c_str(), sAttributeName.c_str(), nAttributeValue));
	}
	
	/**
	* CDriver_ScanLab_RTC6::DisableAttributeFilter - Disables filtering of the segments by segment attributes.
	*/
	void CDriver_ScanLab_RTC6::DisableAttributeFilter()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_DisableAttributeFilter(m_pHandle));
	}
	
	/**
	* CDriver_ScanLab_RTC6::DrawLayer - Draws a layer of a build stream. Blocks until the layer is drawn.
	* @param[in] sStreamUUID - UUID of the build stream. Must have been loaded in memory by the system.
	* @param[in] nLayerIndex - Layer index of the build file.
	*/
	void CDriver_ScanLab_RTC6::DrawLayer(const std::string & sStreamUUID, const LibMCDriver_ScanLab_uint32 nLayerIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_DrawLayer(m_pHandle, sStreamUUID.c_str(), nLayerIndex));
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetCommunicationTimeouts - Returns the current RTC Ethernet communication timeouts. Fails, if no RTC card has been acquired yet.
	* @param[out] dInitialTimeout - Initial timeout in ms
	* @param[out] dMaxTimeout - Max timeout in ms
	* @param[out] dMultiplier - Multiplier
	*/
	void CDriver_ScanLab_RTC6::GetCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetCommunicationTimeouts(m_pHandle, &dInitialTimeout, &dMaxTimeout, &dMultiplier));
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetDefaultCommunicationTimeouts - Returns the RTC Ethernet communication timeouts that will be used for a subsequent connection.
	* @param[out] dInitialTimeout - Initial timeout in ms
	* @param[out] dMaxTimeout - Max timeout in ms
	* @param[out] dMultiplier - Multiplier
	*/
	void CDriver_ScanLab_RTC6::GetDefaultCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetDefaultCommunicationTimeouts(m_pHandle, &dInitialTimeout, &dMaxTimeout, &dMultiplier));
	}
	
	/**
	* CDriver_ScanLab_RTC6::EnableTimelagCompensation - Enables timelag compensation.
	* @param[in] nTimeLagXYInMicroseconds - Time lag of XY axes (in microseconds). MUST be a multiple of 10.
	* @param[in] nTimeLagZInMicroseconds - Time lag of Z axis (in microseconds). MUST be a multiple of 10.
	*/
	void CDriver_ScanLab_RTC6::EnableTimelagCompensation(const LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, const LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_EnableTimelagCompensation(m_pHandle, nTimeLagXYInMicroseconds, nTimeLagZInMicroseconds));
	}
	
	/**
	* CDriver_ScanLab_RTC6::DisableTimelagCompensation - Disables timelag compensation.
	*/
	void CDriver_ScanLab_RTC6::DisableTimelagCompensation()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_DisableTimelagCompensation(m_pHandle));
	}
	
	/**
	 * Method definitions for class CDriver_ScanLab_RTC6xN
	 */
	
	/**
	* CDriver_ScanLab_RTC6xN::SetToSimulationMode - Turns the driver into a simulation mode.
	*/
	void CDriver_ScanLab_RTC6xN::SetToSimulationMode()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_SetToSimulationMode(m_pHandle));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::IsSimulationMode - Returns if the driver is in simulation mode.
	* @return Flag if driver is in simulation mode.
	*/
	bool CDriver_ScanLab_RTC6xN::IsSimulationMode()
	{
		bool resultSimulationModeEnabled = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_IsSimulationMode(m_pHandle, &resultSimulationModeEnabled));
		
		return resultSimulationModeEnabled;
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::IsInitialized - Returns if all the scanners of the driver are initalized.
	* @return Flag if driver is initialized.
	*/
	bool CDriver_ScanLab_RTC6xN::IsInitialized()
	{
		bool resultIsInitialized = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_IsInitialized(m_pHandle, &resultIsInitialized));
		
		return resultIsInitialized;
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::ScannerIsInitialized - Returns if a specific scanners of the driver are initalized.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @return Flag if scanner is initialized.
	*/
	bool CDriver_ScanLab_RTC6xN::ScannerIsInitialized(const LibMCDriver_ScanLab_uint32 nScannerIndex)
	{
		bool resultIsInitialized = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_ScannerIsInitialized(m_pHandle, nScannerIndex, &resultIsInitialized));
		
		return resultIsInitialized;
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetScannerCount - Returns if number of scanners.
	* @return Number of scanners supported by this driver.
	*/
	LibMCDriver_ScanLab_uint32 CDriver_ScanLab_RTC6xN::GetScannerCount()
	{
		LibMCDriver_ScanLab_uint32 resultNumberOfScanners = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetScannerCount(m_pHandle, &resultNumberOfScanners));
		
		return resultNumberOfScanners;
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::InitialiseScanner - Initializes one of the RTC6 Scanner Drivers.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[in] sIP - IP Network Address. Empty string for local card.
	* @param[in] sNetmask - IP Netmask Address. Empty string for local card.
	* @param[in] nTimeout - Time out in microseconds.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	* @param[in] nLaserIndex - Associated Laser Index from the toolpath data. 1-based, MUST NOT be 0. Each Scanner MUST own a unique laser index.
	*/
	void CDriver_ScanLab_RTC6xN::InitialiseScanner(const LibMCDriver_ScanLab_uint32 nScannerIndex, const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout, const LibMCDriver_ScanLab_uint32 nSerialNumber, const LibMCDriver_ScanLab_uint32 nLaserIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_InitialiseScanner(m_pHandle, nScannerIndex, sIP.c_str(), sNetmask.c_str(), nTimeout, nSerialNumber, nLaserIndex));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::InitialiseScannerFromConfiguration - Initializes the RTC6 Scanner Driver from a configuration preset. Calls Initialise, LoadFirmware, SetCorrectionFile, ConfigureLaserMode and ConfigureDelays.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[in] sPresetName - Name of the configuration preset.
	*/
	void CDriver_ScanLab_RTC6xN::InitialiseScannerFromConfiguration(const LibMCDriver_ScanLab_uint32 nScannerIndex, const std::string & sPresetName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_InitialiseScannerFromConfiguration(m_pHandle, nScannerIndex, sPresetName.c_str()));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetIPAddress - Returns the IP Address of the RTC Card. Fails if driver has not been initialized.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @return IP Address Value.
	*/
	std::string CDriver_ScanLab_RTC6xN::GetIPAddress(const LibMCDriver_ScanLab_uint32 nScannerIndex)
	{
		LibMCDriver_ScanLab_uint32 bytesNeededIPAddress = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenIPAddress = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetIPAddress(m_pHandle, nScannerIndex, 0, &bytesNeededIPAddress, nullptr));
		std::vector<char> bufferIPAddress(bytesNeededIPAddress);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetIPAddress(m_pHandle, nScannerIndex, bytesNeededIPAddress, &bytesWrittenIPAddress, &bufferIPAddress[0]));
		
		return std::string(&bufferIPAddress[0]);
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetNetmask - Returns the Netmask of the RTC Card. Fails if driver has not been initialized.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @return Netmask Value.
	*/
	std::string CDriver_ScanLab_RTC6xN::GetNetmask(const LibMCDriver_ScanLab_uint32 nScannerIndex)
	{
		LibMCDriver_ScanLab_uint32 bytesNeededNetmask = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenNetmask = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetNetmask(m_pHandle, nScannerIndex, 0, &bytesNeededNetmask, nullptr));
		std::vector<char> bufferNetmask(bytesNeededNetmask);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetNetmask(m_pHandle, nScannerIndex, bytesNeededNetmask, &bytesWrittenNetmask, &bufferNetmask[0]));
		
		return std::string(&bufferNetmask[0]);
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetSerialNumber - Returns the Serial Number of the RTC Card. Fails if driver has not been initialized.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @return Serial Number of card.
	*/
	LibMCDriver_ScanLab_uint32 CDriver_ScanLab_RTC6xN::GetSerialNumber(const LibMCDriver_ScanLab_uint32 nScannerIndex)
	{
		LibMCDriver_ScanLab_uint32 resultSerialNumber = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetSerialNumber(m_pHandle, nScannerIndex, &resultSerialNumber));
		
		return resultSerialNumber;
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetLaserIndex - Returns associated Laser Index from the toolpath data.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @return Associated Laser Index from the toolpath data.
	*/
	LibMCDriver_ScanLab_uint32 CDriver_ScanLab_RTC6xN::GetLaserIndex(const LibMCDriver_ScanLab_uint32 nScannerIndex)
	{
		LibMCDriver_ScanLab_uint32 resultLaserIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetLaserIndex(m_pHandle, nScannerIndex, &resultLaserIndex));
		
		return resultLaserIndex;
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetSelector - Returns the RTC Selector Instance. Fails if it card has not been initialised.
	* @return RTC Selector Instance.
	*/
	PRTCSelector CDriver_ScanLab_RTC6xN::GetSelector()
	{
		LibMCDriver_ScanLabHandle hSelectorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetSelector(m_pHandle, &hSelectorInstance));
		
		if (!hSelectorInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCSelector>(m_pWrapper, hSelectorInstance);
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetContext - Returns the RTC Context Instance. Fails if it card has not been initialised.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @return RTC Context Instance.
	*/
	PRTCContext CDriver_ScanLab_RTC6xN::GetContext(const LibMCDriver_ScanLab_uint32 nScannerIndex)
	{
		LibMCDriver_ScanLabHandle hContextInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetContext(m_pHandle, nScannerIndex, &hContextInstance));
		
		if (!hContextInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hContextInstance);
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::LoadFirmware - Loads the firmware from the driver resources and for a specific scanner. DEPRECIATED. Use SetFirmare before calling Initialise..
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[in] sFirmwareResource - resource name of the firmware program file.
	* @param[in] sFPGAResource - resource name of the firmware FPGA file.
	* @param[in] sAuxiliaryResource - resource name of the binary auxiliary file.
	*/
	void CDriver_ScanLab_RTC6xN::LoadFirmware(const LibMCDriver_ScanLab_uint32 nScannerIndex, const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_LoadFirmware(m_pHandle, nScannerIndex, sFirmwareResource.c_str(), sFPGAResource.c_str(), sAuxiliaryResource.c_str()));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::LoadCustomFirmware - Loads the firmware from custom resources and for a specific scanner. DEPRECIATED. Use SetCustomFirmare before calling Initialise..
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[in] FirmwareDataBuffer - byte array of the firmware program file.
	* @param[in] FPGADataBuffer - byte array of the firmware FPGA file.
	* @param[in] AuxiliaryDataBuffer - byte array of the binary auxiliary file.
	*/
	void CDriver_ScanLab_RTC6xN::LoadCustomFirmware(const LibMCDriver_ScanLab_uint32 nScannerIndex, const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_LoadCustomFirmware(m_pHandle, nScannerIndex, (LibMCDriver_ScanLab_uint64)FirmwareDataBuffer.size(), FirmwareDataBuffer.data(), (LibMCDriver_ScanLab_uint64)FPGADataBuffer.size(), FPGADataBuffer.data(), (LibMCDriver_ScanLab_uint64)AuxiliaryDataBuffer.size(), AuxiliaryDataBuffer.data()));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::SetCorrectionFile - Sets the correction file stream.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[in] CorrectionFileBuffer - binary data of the correction file.
	* @param[in] nTableNumber - Correction table index of card (1..8)
	* @param[in] nDimension - Is it a 2D or 3D correction file.
	* @param[in] nTableNumberHeadA - Table number of Head A.
	* @param[in] nTableNumberHeadB - Table number of Head B.
	*/
	void CDriver_ScanLab_RTC6xN::SetCorrectionFile(const LibMCDriver_ScanLab_uint32 nScannerIndex, const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension, const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_SetCorrectionFile(m_pHandle, nScannerIndex, (LibMCDriver_ScanLab_uint64)CorrectionFileBuffer.size(), CorrectionFileBuffer.data(), nTableNumber, nDimension, nTableNumberHeadA, nTableNumberHeadB));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::ConfigureLaserMode - Configures the laser mode.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[in] eLaserMode - Laser Mode Enum
	* @param[in] eLaserPort - Laser Port Enum
	* @param[in] dMaxLaserPower - Maximum laser power.
	* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
	* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
	* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
	* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
	* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
	* @param[in] bOutputSynchronizationActive - Output synchronization active
	*/
	void CDriver_ScanLab_RTC6xN::ConfigureLaserMode(const LibMCDriver_ScanLab_uint32 nScannerIndex, const eLaserMode eLaserMode, const eLaserPort eLaserPort, const LibMCDriver_ScanLab_double dMaxLaserPower, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_ConfigureLaserMode(m_pHandle, nScannerIndex, eLaserMode, eLaserPort, dMaxLaserPower, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::ConfigureDelays - Configures the default laser and scanner delays. ATTENTION: Will create and overwrite execution list 1!
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[in] dLaserOnDelay - Laser On Delay in Microseconds
	* @param[in] dLaserOffDelay - Laser Off Delay in Microseconds
	* @param[in] dMarkDelay - Mark delay in microseconds (will be rounded to a multiple of 10)
	* @param[in] dJumpDelay - Jump delay in microseconds (will be rounded to a multiple of 10)
	* @param[in] dPolygonDelay - Polygon delay in microseconds (will be rounded to a multiple of 10)
	*/
	void CDriver_ScanLab_RTC6xN::ConfigureDelays(const LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay, const LibMCDriver_ScanLab_double dMarkDelay, const LibMCDriver_ScanLab_double dJumpDelay, const LibMCDriver_ScanLab_double dPolygonDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_ConfigureDelays(m_pHandle, nScannerIndex, dLaserOnDelay, dLaserOffDelay, dMarkDelay, dJumpDelay, dPolygonDelay));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::SetOIERecordingMode - Sets the recording mode for using the Open Interface extension. Will be taken into account by DrawLayer. Default is No Recording.
	* @param[in] eRecordingMode - Recording mode enum
	*/
	void CDriver_ScanLab_RTC6xN::SetOIERecordingMode(const eOIERecordingMode eRecordingMode)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_SetOIERecordingMode(m_pHandle, eRecordingMode));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetOIERecordingMode - Returns the recording mode for using the Open Interface extension, taking into account by DrawLayer. Default is No Recording.
	* @return Recording mode enum
	*/
	eOIERecordingMode CDriver_ScanLab_RTC6xN::GetOIERecordingMode()
	{
		eOIERecordingMode resultRecordingMode = (eOIERecordingMode) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetOIERecordingMode(m_pHandle, &resultRecordingMode));
		
		return resultRecordingMode;
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::EnableAttributeFilter - Enables filtering of the segments by segment attributes. A segment will only be drawn if the given integer attribute has the given value.
	* @param[in] sNameSpace - Namespace of Attribute to filter for.
	* @param[in] sAttributeName - Name of Attribute to filter for.
	* @param[in] nAttributeValue - Attribute Value to filter for.
	*/
	void CDriver_ScanLab_RTC6xN::EnableAttributeFilter(const std::string & sNameSpace, const std::string & sAttributeName, const LibMCDriver_ScanLab_int64 nAttributeValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_EnableAttributeFilter(m_pHandle, sNameSpace.c_str(), sAttributeName.c_str(), nAttributeValue));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::DisableAttributeFilter - Disables filtering of the segments by segment attributes.
	*/
	void CDriver_ScanLab_RTC6xN::DisableAttributeFilter()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_DisableAttributeFilter(m_pHandle));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::DrawLayer - Draws a layer of a build stream on List 1. Blocks until the layer is drawn. Laser Indices are automatically assigned. Will fail if 
	* @param[in] sStreamUUID - UUID of the build stream. Must have been loaded in memory by the system.
	* @param[in] nLayerIndex - Layer index of the build file.
	* @param[in] bFailIfNonAssignedDataExists - If true, the call will fail in case a layer contains data that is not assigned to any defined scanner card.
	*/
	void CDriver_ScanLab_RTC6xN::DrawLayer(const std::string & sStreamUUID, const LibMCDriver_ScanLab_uint32 nLayerIndex, const bool bFailIfNonAssignedDataExists)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_DrawLayer(m_pHandle, sStreamUUID.c_str(), nLayerIndex, bFailIfNonAssignedDataExists));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::SetAllCommunicationTimeouts - Set RTC Ethernet communication timeouts for all existing and future connections.
	* @param[in] dInitialTimeout - Initial timeout in ms
	* @param[in] dMaxTimeout - Max timeout in ms
	* @param[in] dMultiplier - Multiplier
	*/
	void CDriver_ScanLab_RTC6xN::SetAllCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_SetAllCommunicationTimeouts(m_pHandle, dInitialTimeout, dMaxTimeout, dMultiplier));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::SetCommunicationTimeouts - Set RTC Ethernet communication timeouts for a specific scanner. The given values will be defaults for all subsequent connections.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[in] dInitialTimeout - Initial timeout in ms
	* @param[in] dMaxTimeout - Max timeout in ms
	* @param[in] dMultiplier - Multiplier
	*/
	void CDriver_ScanLab_RTC6xN::SetCommunicationTimeouts(const LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_SetCommunicationTimeouts(m_pHandle, nScannerIndex, dInitialTimeout, dMaxTimeout, dMultiplier));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetCommunicationTimeouts - Get RTC Ethernet communication timeouts. Fails if the RTC Card is not connected.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[out] dInitialTimeout - Initial timeout in ms
	* @param[out] dMaxTimeout - Max timeout in ms
	* @param[out] dMultiplier - Multiplier
	*/
	void CDriver_ScanLab_RTC6xN::GetCommunicationTimeouts(const LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetCommunicationTimeouts(m_pHandle, nScannerIndex, &dInitialTimeout, &dMaxTimeout, &dMultiplier));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::GetDefaultCommunicationTimeouts - Returns the RTC Ethernet communication timeouts that will be used for any subsequent connection.
	* @param[out] dInitialTimeout - Initial timeout in ms
	* @param[out] dMaxTimeout - Max timeout in ms
	* @param[out] dMultiplier - Multiplier
	*/
	void CDriver_ScanLab_RTC6xN::GetDefaultCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_GetDefaultCommunicationTimeouts(m_pHandle, &dInitialTimeout, &dMaxTimeout, &dMultiplier));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::EnableTimelagCompensation - Enables timelag compensation.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	* @param[in] nTimeLagXYInMicroseconds - Time lag of XY axes (in microseconds). MUST be a multiple of 10.
	* @param[in] nTimeLagZInMicroseconds - Time lag of Z axis (in microseconds). MUST be a multiple of 10.
	*/
	void CDriver_ScanLab_RTC6xN::EnableTimelagCompensation(const LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, const LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_EnableTimelagCompensation(m_pHandle, nScannerIndex, nTimeLagXYInMicroseconds, nTimeLagZInMicroseconds));
	}
	
	/**
	* CDriver_ScanLab_RTC6xN::DisableTimelagCompensation - Disables timelag compensation.
	* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
	*/
	void CDriver_ScanLab_RTC6xN::DisableTimelagCompensation(const LibMCDriver_ScanLab_uint32 nScannerIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6xN_DisableTimelagCompensation(m_pHandle, nScannerIndex));
	}

} // namespace LibMCDriver_ScanLab

#endif // __LIBMCDRIVER_SCANLAB_CPPHEADER_DYNAMIC_CPP

