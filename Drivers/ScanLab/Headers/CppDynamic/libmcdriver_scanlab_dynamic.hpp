/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver ScanLab RTC

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_SCANLAB_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_SCANLAB_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_scanlab_types.hpp"
#include "libmcdriver_scanlab_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_ScanLab {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CRTCContext;
class CRTCSelector;
class CDriver_ScanLab;
class CDriver_ScanLab_RTC6;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_ScanLabWrapper;
typedef CBase CLibMCDriver_ScanLabBase;
typedef CDriver CLibMCDriver_ScanLabDriver;
typedef CRTCContext CLibMCDriver_ScanLabRTCContext;
typedef CRTCSelector CLibMCDriver_ScanLabRTCSelector;
typedef CDriver_ScanLab CLibMCDriver_ScanLabDriver_ScanLab;
typedef CDriver_ScanLab_RTC6 CLibMCDriver_ScanLabDriver_ScanLab_RTC6;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CRTCContext> PRTCContext;
typedef std::shared_ptr<CRTCSelector> PRTCSelector;
typedef std::shared_ptr<CDriver_ScanLab> PDriver_ScanLab;
typedef std::shared_ptr<CDriver_ScanLab_RTC6> PDriver_ScanLab_RTC6;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_ScanLabWrapper;
typedef PBase PLibMCDriver_ScanLabBase;
typedef PDriver PLibMCDriver_ScanLabDriver;
typedef PRTCContext PLibMCDriver_ScanLabRTCContext;
typedef PRTCSelector PLibMCDriver_ScanLabRTCSelector;
typedef PDriver_ScanLab PLibMCDriver_ScanLabDriver_ScanLab;
typedef PDriver_ScanLab_RTC6 PLibMCDriver_ScanLabDriver_ScanLab_RTC6;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_ScanLabHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_ScanLabException 
**************************************************************************************************************************/
class ELibMCDriver_ScanLabException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_ScanLabResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_ScanLabException(LibMCDriver_ScanLabResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_ScanLabResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLAB_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_SCANLAB_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_SCANLAB_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_SCANLAB_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_SCANLAB_ERROR_DRIVERERROR: return "DRIVERERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_NO_PCIE_CARD_FOUND: return "RTC6_NO_PCIE_CARD_FOUND";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ACCESS_DENIED: return "RTC6_ACCESS_DENIED";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_SEND_ERROR: return "RTC6_SEND_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TIMEOUT: return "RTC6_TIMEOUT";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_PARAM_ERROR: return "RTC6_PARAM_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_BUSY: return "RTC6_BUSY";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_REJECTED: return "RTC6_REJECTED";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_IGNORED: return "RTC6_IGNORED";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERSION_MISMATCH: return "RTC6_VERSION_MISMATCH";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERIFY_ERROR: return "RTC6_VERIFY_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TYPE_REJECTED: return "RTC6_TYPE_REJECTED";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_OUT_OF_MEMORY: return "RTC6_OUT_OF_MEMORY";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_FLASH_ERROR: return "RTC6_FLASH_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ETH_ERROR: return "RTC6_ETH_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_CONFIG_ERROR: return "RTC6_CONFIG_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_UNKNOWN_ERROR: return "RTC6_UNKNOWN_ERROR";
			case LIBMCDRIVER_SCANLAB_ERROR_RTCOPEN_FAILED: return "RTCOPEN_FAILED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCPROC: return "INVALIDRTCPROC";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDIPADDRESS: return "INVALIDIPADDRESS";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNETMASK: return "INVALIDNETMASK";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYACQUIRED: return "CARDALREADYACQUIRED";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTFOUND: return "CARDNOTFOUND";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADPROGRAMFILE: return "COULDNOTLOADPROGRAMFILE";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADCORRECTIONFILE: return "COULDNOTLOADCORRECTIONFILE";
			case LIBMCDRIVER_SCANLAB_ERROR_DELAYSMUSTBEMULTIPLEOF10: return "DELAYSMUSTBEMULTIPLEOF10";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKNOTLOADED: return "SCANLABSDKNOTLOADED";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKALREADYLOADED: return "SCANLABSDKALREADYLOADED";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYINITIALIZED: return "CARDALREADYINITIALIZED";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTINITIALIZED: return "CARDNOTINITIALIZED";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOINTCOUNT: return "INVALIDPOINTCOUNT";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDMAXLASERPOWER: return "INVALIDMAXLASERPOWER";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERDELAY: return "INVALIDLASERDELAY";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERDELAY: return "INVALIDSCANNERDELAY";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANLABSDK: return "INVALIDSCANLABSDK";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIESIGNALBUFFERARRAY: return "INVALIDOIESIGNALBUFFERARRAY";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGTIMELAG: return "INVALIDSKYWRITINGTIMELAG";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGLASERONSHIFT: return "INVALIDSKYWRITINGLASERONSHIFT";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPREV: return "INVALIDSKYWRITINGNPREV";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPOST: return "INVALIDSKYWRITINGNPOST";
			case LIBMCDRIVER_SCANLAB_ERROR_OIEHASNOTBEENINITIALIZED: return "OIEHASNOTBEENINITIALIZED";
			case LIBMCDRIVER_SCANLAB_ERROR_UNSUPPORTEDOIEOPERATIONMODE: return "UNSUPPORTEDOIEOPERATIONMODE";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLAB_SUCCESS: return "success";
			case LIBMCDRIVER_SCANLAB_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_SCANLAB_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_SCANLAB_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_SCANLAB_ERROR_DRIVERERROR: return "a driver error occured";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_NO_PCIE_CARD_FOUND: return "RTC6: No PCIE Card was found";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ACCESS_DENIED: return "RTC6: Access Denied";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_SEND_ERROR: return "RTC6: Send Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TIMEOUT: return "RTC6: Timeout";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_PARAM_ERROR: return "RTC6: Param Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_BUSY: return "RTC6: Busy";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_REJECTED: return "RTC6: Rejected";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_IGNORED: return "RTC6: Ignored";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERSION_MISMATCH: return "RTC6: Version Mismatch";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_VERIFY_ERROR: return "RTC6: Verify Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_TYPE_REJECTED: return "RTC6: Type Rejected";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_OUT_OF_MEMORY: return "RTC6: Out of Memory";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_FLASH_ERROR: return "RTC6: Flash Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_ETH_ERROR: return "RTC6: Eth Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_CONFIG_ERROR: return "RTC6: Config Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTC6_UNKNOWN_ERROR: return "RTC6: Unknown Error";
			case LIBMCDRIVER_SCANLAB_ERROR_RTCOPEN_FAILED: return "RTC open failed";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDRTCPROC: return "Invalid RTC proc";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDIPADDRESS: return "Invalid IP Address";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDNETMASK: return "Invalid NetMask";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYACQUIRED: return "Card already acquired";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTFOUND: return "Card not found";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADPROGRAMFILE: return "Could not load program file";
			case LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADCORRECTIONFILE: return "Could not load correction file";
			case LIBMCDRIVER_SCANLAB_ERROR_DELAYSMUSTBEMULTIPLEOF10: return "Delays must be a multiple of 10 microseconds";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKNOTLOADED: return "Scanlab RTC has not been loaded";
			case LIBMCDRIVER_SCANLAB_ERROR_SCANLABSDKALREADYLOADED: return "Scanlab RTC has already been loaded";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDALREADYINITIALIZED: return "Scanlab RTC card is already initialized";
			case LIBMCDRIVER_SCANLAB_ERROR_CARDNOTINITIALIZED: return "Scanlab RTC card is not initialized";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDPOINTCOUNT: return "Invalid point count";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDMAXLASERPOWER: return "Invalid max laser power.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDLASERDELAY: return "Invalid laser delay.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANNERDELAY: return "Invalid scanner delay.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSCANLABSDK: return "Invalid SCANLAB SDK.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDOIESIGNALBUFFERARRAY: return "Invalid OIE Signal buffer array.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGTIMELAG: return "Invalid Skywriting Timelag.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGLASERONSHIFT: return "Invalid Skywriting Laser On Shift.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPREV: return "Invalid Skywriting N Prev.";
			case LIBMCDRIVER_SCANLAB_ERROR_INVALIDSKYWRITINGNPOST: return "Invalid Skywriting N Post.";
			case LIBMCDRIVER_SCANLAB_ERROR_OIEHASNOTBEENINITIALIZED: return "OIE has not been initialized.";
			case LIBMCDRIVER_SCANLAB_ERROR_UNSUPPORTEDOIEOPERATIONMODE: return "Unsupported OIE Operation Mode.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_ScanLabInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_ScanLabResult nResult);

	inline void GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLab_pvoid pSymbolAddressMethod);
	inline LibMCDriver_ScanLab_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_ScanLabDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_ScanLabResult checkBinaryVersion()
	{
		LibMCDriver_ScanLab_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_SCANLAB_VERSION_MAJOR) {
			return LIBMCDRIVER_SCANLAB_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	LibMCDriver_ScanLabResult initWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabResult releaseWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabResult loadWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_ScanLabResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CRTCContext;
	friend class CRTCSelector;
	friend class CDriver_ScanLab;
	friend class CDriver_ScanLab_RTC6;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_ScanLabHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_ScanLabResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_ScanLabHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro, std::string & sBuild);
	inline void QueryParameters();
	inline void QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance);
};
	
/*************************************************************************************************************************
 Class CRTCContext 
**************************************************************************************************************************/
class CRTCContext : public CBase {
public:
	
	/**
	* CRTCContext::CRTCContext - Constructor for RTCContext class.
	*/
	CRTCContext(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void LoadFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer);
	inline void LoadCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension);
	inline void SelectCorrectionTable(const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB);
	inline void ConfigureLists(const LibMCDriver_ScanLab_uint32 nSizeListA, const LibMCDriver_ScanLab_uint32 nSizeListB);
	inline void SetLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort);
	inline void DisableAutoLaserControl();
	inline void SetLaserControlParameters(const bool bDisableLaser, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive);
	inline void SetLaserPulsesInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength);
	inline void SetLaserPulsesInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength);
	inline void SetStandbyInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength);
	inline void SetStandbyInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength);
	inline LibMCDriver_ScanLab_uint32 GetSerialNumber();
	inline void SetStartList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition);
	inline void SetEndOfList();
	inline void ExecuteList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition);
	inline void SetAutoChangePos(const LibMCDriver_ScanLab_uint32 nPosition);
	inline void SetDelays(const LibMCDriver_ScanLab_uint32 nMarkDelay, const LibMCDriver_ScanLab_uint32 nJumpDelay, const LibMCDriver_ScanLab_uint32 nPolygonDelay);
	inline void SetLaserDelaysInMicroseconds(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay);
	inline void SetLaserDelaysInBits(const LibMCDriver_ScanLab_uint32 nLaserOnDelay, const LibMCDriver_ScanLab_uint32 nLaserOffDelay);
	inline void DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue);
	inline void DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue);
	inline void AddCustomDelay(const LibMCDriver_ScanLab_uint32 nDelay);
	inline LibMCDriver_ScanLab_double GetCorrectionFactor();
	inline void GetStatus(bool & bBusy, LibMCDriver_ScanLab_uint32 & nPosition);
	inline void GetHeadStatus(const LibMCDriver_ScanLab_uint32 nHeadNo, bool & bPositionXisOK, bool & bPositionYisOK, bool & bTemperatureisOK, bool & bPowerisOK);
	inline void GetStateValues(bool & bLaserIsOn, LibMCDriver_ScanLab_int32 & nPositionX, LibMCDriver_ScanLab_int32 & nPositionY, LibMCDriver_ScanLab_int32 & nPositionZ, LibMCDriver_ScanLab_int32 & nCorrectedPositionX, LibMCDriver_ScanLab_int32 & nCorrectedPositionY, LibMCDriver_ScanLab_int32 & nCorrectedPositionZ, LibMCDriver_ScanLab_int32 & nFocusShift, LibMCDriver_ScanLab_int32 & nMarkSpeed);
	inline LibMCDriver_ScanLab_uint32 GetInputPointer();
	inline void GetRTCVersion(LibMCDriver_ScanLab_uint32 & nRTCVersion, LibMCDriver_ScanLab_uint32 & nRTCType, LibMCDriver_ScanLab_uint32 & nDLLVersion, LibMCDriver_ScanLab_uint32 & nHEXVersion, LibMCDriver_ScanLab_uint32 & nBIOSVersion);
	inline void SetCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier);
	inline void GetCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier);
	inline void InitializeForOIE(const CInputVector<LibMCDriver_ScanLab_uint32> & SignalChannelsBuffer, const eOIEOperationMode eOperationMode);
	inline void EnableOIE();
	inline void DisableOIE();
	inline void StartOIEMeasurement();
	inline void StopOIEMeasurement();
	inline void DisableSkyWriting();
	inline void EnableSkyWritingMode1(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost);
	inline void EnableSkyWritingMode2(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost);
	inline void EnableSkyWritingMode3(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost, const LibMCDriver_ScanLab_double dLimit);
};
	
/*************************************************************************************************************************
 Class CRTCSelector 
**************************************************************************************************************************/
class CRTCSelector : public CBase {
public:
	
	/**
	* CRTCSelector::CRTCSelector - Constructor for RTCSelector class.
	*/
	CRTCSelector(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCDriver_ScanLab_uint32 SearchCards(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout);
	inline LibMCDriver_ScanLab_uint32 SearchCardsByRange(const std::string & sStartIP, const std::string & sEndIP, const LibMCDriver_ScanLab_uint32 nTimeout);
	inline LibMCDriver_ScanLab_uint32 GetCardCount();
	inline LibMCDriver_ScanLab_uint32 GetEthernetCardCount();
	inline PRTCContext AcquireCard(const LibMCDriver_ScanLab_uint32 nNumber);
	inline PRTCContext AcquireCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber);
	inline PRTCContext AcquireEthernetCard(const LibMCDriver_ScanLab_uint32 nNumber);
	inline PRTCContext AcquireEthernetCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber);
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLab 
**************************************************************************************************************************/
class CDriver_ScanLab : public CDriver {
public:
	
	/**
	* CDriver_ScanLab::CDriver_ScanLab - Constructor for Driver_ScanLab class.
	*/
	CDriver_ScanLab(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline void LoadSDK(const std::string & sResourceName);
	inline void LoadCustomSDK(const CInputVector<LibMCDriver_ScanLab_uint8> & ScanlabDLLBuffer);
	inline PRTCSelector CreateRTCSelector();
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLab_RTC6 
**************************************************************************************************************************/
class CDriver_ScanLab_RTC6 : public CDriver_ScanLab {
public:
	
	/**
	* CDriver_ScanLab_RTC6::CDriver_ScanLab_RTC6 - Constructor for Driver_ScanLab_RTC6 class.
	*/
	CDriver_ScanLab_RTC6(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CDriver_ScanLab(pWrapper, pHandle)
	{
	}
	
	inline void SetToSimulationMode();
	inline bool IsSimulationMode();
	inline void Initialise(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout, const LibMCDriver_ScanLab_uint32 nSerialNumber);
	inline PRTCContext GetContext();
	inline PRTCSelector GetSelector();
	inline void LoadFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource);
	inline void LoadCustomFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer);
	inline void SetCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension, const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB);
	inline void ConfigureLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort, const LibMCDriver_ScanLab_double dMaxLaserPower, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive);
	inline void ConfigureDelays(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay, const LibMCDriver_ScanLab_double dMarkDelay, const LibMCDriver_ScanLab_double dJumpDelay, const LibMCDriver_ScanLab_double dPolygonDelay);
	inline void DrawLayer(const std::string & sStreamUUID, const LibMCDriver_ScanLab_uint32 nLayerIndex);
	inline void SetCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier);
	inline void GetCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_ScanLabHandle hInstance = pInstance.GetHandle();
		LibMCDriver_ScanLab_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLab_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_ScanLabException(LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_ScanLabException(LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_ScanLab_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_ScanLab_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (hInstance) {
			return std::make_shared<CDriver>(this, hInstance);
		} else {
			return nullptr;
		}
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_ScanLabResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_ScanLabException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_ScanLabResult CWrapper::initWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_Driver_QueryParametersEx = nullptr;
		pWrapperTable->m_RTCContext_LoadFirmware = nullptr;
		pWrapperTable->m_RTCContext_LoadCorrectionFile = nullptr;
		pWrapperTable->m_RTCContext_SelectCorrectionTable = nullptr;
		pWrapperTable->m_RTCContext_ConfigureLists = nullptr;
		pWrapperTable->m_RTCContext_SetLaserMode = nullptr;
		pWrapperTable->m_RTCContext_DisableAutoLaserControl = nullptr;
		pWrapperTable->m_RTCContext_SetLaserControlParameters = nullptr;
		pWrapperTable->m_RTCContext_SetLaserPulsesInBits = nullptr;
		pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds = nullptr;
		pWrapperTable->m_RTCContext_SetStandbyInBits = nullptr;
		pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds = nullptr;
		pWrapperTable->m_RTCContext_GetSerialNumber = nullptr;
		pWrapperTable->m_RTCContext_SetStartList = nullptr;
		pWrapperTable->m_RTCContext_SetEndOfList = nullptr;
		pWrapperTable->m_RTCContext_ExecuteList = nullptr;
		pWrapperTable->m_RTCContext_SetAutoChangePos = nullptr;
		pWrapperTable->m_RTCContext_SetDelays = nullptr;
		pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds = nullptr;
		pWrapperTable->m_RTCContext_SetLaserDelaysInBits = nullptr;
		pWrapperTable->m_RTCContext_DrawPolyline = nullptr;
		pWrapperTable->m_RTCContext_DrawHatches = nullptr;
		pWrapperTable->m_RTCContext_AddCustomDelay = nullptr;
		pWrapperTable->m_RTCContext_GetCorrectionFactor = nullptr;
		pWrapperTable->m_RTCContext_GetStatus = nullptr;
		pWrapperTable->m_RTCContext_GetHeadStatus = nullptr;
		pWrapperTable->m_RTCContext_GetStateValues = nullptr;
		pWrapperTable->m_RTCContext_GetInputPointer = nullptr;
		pWrapperTable->m_RTCContext_GetRTCVersion = nullptr;
		pWrapperTable->m_RTCContext_SetCommunicationTimeouts = nullptr;
		pWrapperTable->m_RTCContext_GetCommunicationTimeouts = nullptr;
		pWrapperTable->m_RTCContext_InitializeForOIE = nullptr;
		pWrapperTable->m_RTCContext_EnableOIE = nullptr;
		pWrapperTable->m_RTCContext_DisableOIE = nullptr;
		pWrapperTable->m_RTCContext_StartOIEMeasurement = nullptr;
		pWrapperTable->m_RTCContext_StopOIEMeasurement = nullptr;
		pWrapperTable->m_RTCContext_DisableSkyWriting = nullptr;
		pWrapperTable->m_RTCContext_EnableSkyWritingMode1 = nullptr;
		pWrapperTable->m_RTCContext_EnableSkyWritingMode2 = nullptr;
		pWrapperTable->m_RTCContext_EnableSkyWritingMode3 = nullptr;
		pWrapperTable->m_RTCSelector_SearchCards = nullptr;
		pWrapperTable->m_RTCSelector_SearchCardsByRange = nullptr;
		pWrapperTable->m_RTCSelector_GetCardCount = nullptr;
		pWrapperTable->m_RTCSelector_GetEthernetCardCount = nullptr;
		pWrapperTable->m_RTCSelector_AcquireCard = nullptr;
		pWrapperTable->m_RTCSelector_AcquireCardBySerial = nullptr;
		pWrapperTable->m_RTCSelector_AcquireEthernetCard = nullptr;
		pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial = nullptr;
		pWrapperTable->m_Driver_ScanLab_LoadSDK = nullptr;
		pWrapperTable->m_Driver_ScanLab_LoadCustomSDK = nullptr;
		pWrapperTable->m_Driver_ScanLab_CreateRTCSelector = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_Initialise = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetContext = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}

	inline LibMCDriver_ScanLabResult CWrapper::releaseWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}

	inline LibMCDriver_ScanLabResult CWrapper::loadWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_ScanLabDriver_QueryParametersExPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_queryparametersex");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_ScanLabDriver_QueryParametersExPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_queryparametersex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParametersEx == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_LoadFirmware = (PLibMCDriver_ScanLabRTCContext_LoadFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_loadfirmware");
		#else // _WIN32
		pWrapperTable->m_RTCContext_LoadFirmware = (PLibMCDriver_ScanLabRTCContext_LoadFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_loadfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_LoadFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_LoadCorrectionFile = (PLibMCDriver_ScanLabRTCContext_LoadCorrectionFilePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_loadcorrectionfile");
		#else // _WIN32
		pWrapperTable->m_RTCContext_LoadCorrectionFile = (PLibMCDriver_ScanLabRTCContext_LoadCorrectionFilePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_loadcorrectionfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_LoadCorrectionFile == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SelectCorrectionTable = (PLibMCDriver_ScanLabRTCContext_SelectCorrectionTablePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_selectcorrectiontable");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SelectCorrectionTable = (PLibMCDriver_ScanLabRTCContext_SelectCorrectionTablePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_selectcorrectiontable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SelectCorrectionTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ConfigureLists = (PLibMCDriver_ScanLabRTCContext_ConfigureListsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_configurelists");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ConfigureLists = (PLibMCDriver_ScanLabRTCContext_ConfigureListsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_configurelists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ConfigureLists == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserMode = (PLibMCDriver_ScanLabRTCContext_SetLaserModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlasermode");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserMode = (PLibMCDriver_ScanLabRTCContext_SetLaserModePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlasermode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableAutoLaserControl = (PLibMCDriver_ScanLabRTCContext_DisableAutoLaserControlPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disableautolasercontrol");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableAutoLaserControl = (PLibMCDriver_ScanLabRTCContext_DisableAutoLaserControlPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disableautolasercontrol");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableAutoLaserControl == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserControlParameters = (PLibMCDriver_ScanLabRTCContext_SetLaserControlParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlasercontrolparameters");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserControlParameters = (PLibMCDriver_ScanLabRTCContext_SetLaserControlParametersPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlasercontrolparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserControlParameters == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInBitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinbits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInBitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinbits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserPulsesInBits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInMicroSecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInMicroSecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInBits = (PLibMCDriver_ScanLabRTCContext_SetStandbyInBitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinbits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInBits = (PLibMCDriver_ScanLabRTCContext_SetStandbyInBitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinbits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetStandbyInBits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetStandbyInMicroSecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetStandbyInMicroSecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetSerialNumber = (PLibMCDriver_ScanLabRTCContext_GetSerialNumberPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getserialnumber");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetSerialNumber = (PLibMCDriver_ScanLabRTCContext_GetSerialNumberPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getserialnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetSerialNumber == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetStartList = (PLibMCDriver_ScanLabRTCContext_SetStartListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setstartlist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetStartList = (PLibMCDriver_ScanLabRTCContext_SetStartListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setstartlist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetStartList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetEndOfList = (PLibMCDriver_ScanLabRTCContext_SetEndOfListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setendoflist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetEndOfList = (PLibMCDriver_ScanLabRTCContext_SetEndOfListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setendoflist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetEndOfList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ExecuteList = (PLibMCDriver_ScanLabRTCContext_ExecuteListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_executelist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ExecuteList = (PLibMCDriver_ScanLabRTCContext_ExecuteListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_executelist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ExecuteList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetAutoChangePos = (PLibMCDriver_ScanLabRTCContext_SetAutoChangePosPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setautochangepos");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetAutoChangePos = (PLibMCDriver_ScanLabRTCContext_SetAutoChangePosPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setautochangepos");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetAutoChangePos == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetDelays = (PLibMCDriver_ScanLabRTCContext_SetDelaysPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setdelays");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetDelays = (PLibMCDriver_ScanLabRTCContext_SetDelaysPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setdelays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetDelays == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInMicrosecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInBitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinbits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInBitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinbits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserDelaysInBits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DrawPolyline = (PLibMCDriver_ScanLabRTCContext_DrawPolylinePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_drawpolyline");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DrawPolyline = (PLibMCDriver_ScanLabRTCContext_DrawPolylinePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_drawpolyline");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DrawPolyline == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DrawHatches = (PLibMCDriver_ScanLabRTCContext_DrawHatchesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_drawhatches");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DrawHatches = (PLibMCDriver_ScanLabRTCContext_DrawHatchesPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_drawhatches");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DrawHatches == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddCustomDelay = (PLibMCDriver_ScanLabRTCContext_AddCustomDelayPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addcustomdelay");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddCustomDelay = (PLibMCDriver_ScanLabRTCContext_AddCustomDelayPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addcustomdelay");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddCustomDelay == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetCorrectionFactor = (PLibMCDriver_ScanLabRTCContext_GetCorrectionFactorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getcorrectionfactor");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetCorrectionFactor = (PLibMCDriver_ScanLabRTCContext_GetCorrectionFactorPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getcorrectionfactor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetCorrectionFactor == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetStatus = (PLibMCDriver_ScanLabRTCContext_GetStatusPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getstatus");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetStatus = (PLibMCDriver_ScanLabRTCContext_GetStatusPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetStatus == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetHeadStatus = (PLibMCDriver_ScanLabRTCContext_GetHeadStatusPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getheadstatus");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetHeadStatus = (PLibMCDriver_ScanLabRTCContext_GetHeadStatusPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getheadstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetHeadStatus == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetStateValues = (PLibMCDriver_ScanLabRTCContext_GetStateValuesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getstatevalues");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetStateValues = (PLibMCDriver_ScanLabRTCContext_GetStateValuesPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getstatevalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetStateValues == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetInputPointer = (PLibMCDriver_ScanLabRTCContext_GetInputPointerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getinputpointer");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetInputPointer = (PLibMCDriver_ScanLabRTCContext_GetInputPointerPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getinputpointer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetInputPointer == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetRTCVersion = (PLibMCDriver_ScanLabRTCContext_GetRTCVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcversion");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetRTCVersion = (PLibMCDriver_ScanLabRTCContext_GetRTCVersionPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetRTCVersion == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetCommunicationTimeouts = (PLibMCDriver_ScanLabRTCContext_SetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetCommunicationTimeouts = (PLibMCDriver_ScanLabRTCContext_SetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetCommunicationTimeouts = (PLibMCDriver_ScanLabRTCContext_GetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetCommunicationTimeouts = (PLibMCDriver_ScanLabRTCContext_GetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_InitializeForOIE = (PLibMCDriver_ScanLabRTCContext_InitializeForOIEPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_initializeforoie");
		#else // _WIN32
		pWrapperTable->m_RTCContext_InitializeForOIE = (PLibMCDriver_ScanLabRTCContext_InitializeForOIEPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_initializeforoie");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_InitializeForOIE == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableOIE = (PLibMCDriver_ScanLabRTCContext_EnableOIEPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableoie");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableOIE = (PLibMCDriver_ScanLabRTCContext_EnableOIEPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableoie");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableOIE == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableOIE = (PLibMCDriver_ScanLabRTCContext_DisableOIEPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disableoie");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableOIE = (PLibMCDriver_ScanLabRTCContext_DisableOIEPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disableoie");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableOIE == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_StartOIEMeasurement = (PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_startoiemeasurement");
		#else // _WIN32
		pWrapperTable->m_RTCContext_StartOIEMeasurement = (PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_startoiemeasurement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_StartOIEMeasurement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_StopOIEMeasurement = (PLibMCDriver_ScanLabRTCContext_StopOIEMeasurementPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_stopoiemeasurement");
		#else // _WIN32
		pWrapperTable->m_RTCContext_StopOIEMeasurement = (PLibMCDriver_ScanLabRTCContext_StopOIEMeasurementPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_stopoiemeasurement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_StopOIEMeasurement == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableSkyWriting = (PLibMCDriver_ScanLabRTCContext_DisableSkyWritingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disableskywriting");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableSkyWriting = (PLibMCDriver_ScanLabRTCContext_DisableSkyWritingPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disableskywriting");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableSkyWriting == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode1 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode1Ptr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode1");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode1 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode1Ptr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode1");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableSkyWritingMode1 == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode2 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode2Ptr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode2");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode2 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode2Ptr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableSkyWritingMode2 == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode3 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode3Ptr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode3");
		#else // _WIN32
		pWrapperTable->m_RTCContext_EnableSkyWritingMode3 = (PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode3Ptr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_enableskywritingmode3");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_EnableSkyWritingMode3 == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_SearchCards = (PLibMCDriver_ScanLabRTCSelector_SearchCardsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_searchcards");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_SearchCards = (PLibMCDriver_ScanLabRTCSelector_SearchCardsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_searchcards");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_SearchCards == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_SearchCardsByRange = (PLibMCDriver_ScanLabRTCSelector_SearchCardsByRangePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_searchcardsbyrange");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_SearchCardsByRange = (PLibMCDriver_ScanLabRTCSelector_SearchCardsByRangePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_searchcardsbyrange");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_SearchCardsByRange == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_GetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetCardCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_getcardcount");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_GetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetCardCountPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_getcardcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_GetCardCount == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_GetEthernetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetEthernetCardCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_getethernetcardcount");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_GetEthernetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetEthernetCardCountPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_getethernetcardcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_GetEthernetCardCount == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireCard = (PLibMCDriver_ScanLabRTCSelector_AcquireCardPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecard");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireCard = (PLibMCDriver_ScanLabRTCSelector_AcquireCardPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecard");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireCard == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireCardBySerialPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecardbyserial");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireCardBySerialPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecardbyserial");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireCardBySerial == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCard = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcard");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCard = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcard");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireEthernetCard == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardBySerialPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardBySerialPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadsdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadSDKPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadsdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_LoadSDK == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadCustomSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadCustomSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadcustomsdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadCustomSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadCustomSDKPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadcustomsdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_LoadCustomSDK == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_CreateRTCSelector = (PLibMCDriver_ScanLabDriver_ScanLab_CreateRTCSelectorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_creatertcselector");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_CreateRTCSelector = (PLibMCDriver_ScanLabDriver_ScanLab_CreateRTCSelectorPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_creatertcselector");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_CreateRTCSelector == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetToSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_settosimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetToSimulationModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_settosimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_issimulationmode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsSimulationModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_issimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_Initialise = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialisePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_initialise");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_Initialise = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialisePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_initialise");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_Initialise == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetContext = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetContextPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getcontext");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetContext = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetContextPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getcontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetContext == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSelectorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getselector");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSelectorPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getselector");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_loadfirmware");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_loadfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadCustomFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_loadcustomfirmware");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadCustomFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_loadcustomfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCorrectionFilePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setcorrectionfile");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCorrectionFilePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setcorrectionfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureLaserModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_configurelasermode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureLaserModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_configurelasermode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureDelaysPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_configuredelays");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureDelaysPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_configuredelays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DrawLayerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_drawlayer");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DrawLayerPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_drawlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_setcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetCommunicationTimeoutsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getcommunicationtimeouts");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts = (PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetCommunicationTimeoutsPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc6_getcommunicationtimeouts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabGetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlab_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_scanlab_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_scanlab_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_scanlab_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabInjectComponentPtr) dlsym(hLibrary, "libmcdriver_scanlab_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_scanlab_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabCreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabCreateDriverPtr) dlsym(hLibrary, "libmcdriver_scanlab_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}

	inline LibMCDriver_ScanLabResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_ScanLabResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_ScanLabResult eLookupError = LIBMCDRIVER_SCANLAB_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_queryparametersex", (void**)&(pWrapperTable->m_Driver_QueryParametersEx));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParametersEx == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_loadfirmware", (void**)&(pWrapperTable->m_RTCContext_LoadFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_LoadFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_loadcorrectionfile", (void**)&(pWrapperTable->m_RTCContext_LoadCorrectionFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_LoadCorrectionFile == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_selectcorrectiontable", (void**)&(pWrapperTable->m_RTCContext_SelectCorrectionTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SelectCorrectionTable == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_configurelists", (void**)&(pWrapperTable->m_RTCContext_ConfigureLists));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ConfigureLists == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlasermode", (void**)&(pWrapperTable->m_RTCContext_SetLaserMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disableautolasercontrol", (void**)&(pWrapperTable->m_RTCContext_DisableAutoLaserControl));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableAutoLaserControl == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlasercontrolparameters", (void**)&(pWrapperTable->m_RTCContext_SetLaserControlParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserControlParameters == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserpulsesinbits", (void**)&(pWrapperTable->m_RTCContext_SetLaserPulsesInBits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserPulsesInBits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setstandbyinbits", (void**)&(pWrapperTable->m_RTCContext_SetStandbyInBits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetStandbyInBits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getserialnumber", (void**)&(pWrapperTable->m_RTCContext_GetSerialNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetSerialNumber == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setstartlist", (void**)&(pWrapperTable->m_RTCContext_SetStartList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetStartList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setendoflist", (void**)&(pWrapperTable->m_RTCContext_SetEndOfList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetEndOfList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_executelist", (void**)&(pWrapperTable->m_RTCContext_ExecuteList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ExecuteList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setautochangepos", (void**)&(pWrapperTable->m_RTCContext_SetAutoChangePos));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetAutoChangePos == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setdelays", (void**)&(pWrapperTable->m_RTCContext_SetDelays));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetDelays == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserdelaysinbits", (void**)&(pWrapperTable->m_RTCContext_SetLaserDelaysInBits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserDelaysInBits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_drawpolyline", (void**)&(pWrapperTable->m_RTCContext_DrawPolyline));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DrawPolyline == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_drawhatches", (void**)&(pWrapperTable->m_RTCContext_DrawHatches));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DrawHatches == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addcustomdelay", (void**)&(pWrapperTable->m_RTCContext_AddCustomDelay));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddCustomDelay == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getcorrectionfactor", (void**)&(pWrapperTable->m_RTCContext_GetCorrectionFactor));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetCorrectionFactor == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getstatus", (void**)&(pWrapperTable->m_RTCContext_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetStatus == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getheadstatus", (void**)&(pWrapperTable->m_RTCContext_GetHeadStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetHeadStatus == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getstatevalues", (void**)&(pWrapperTable->m_RTCContext_GetStateValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetStateValues == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getinputpointer", (void**)&(pWrapperTable->m_RTCContext_GetInputPointer));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetInputPointer == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getrtcversion", (void**)&(pWrapperTable->m_RTCContext_GetRTCVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetRTCVersion == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setcommunicationtimeouts", (void**)&(pWrapperTable->m_RTCContext_SetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getcommunicationtimeouts", (void**)&(pWrapperTable->m_RTCContext_GetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_initializeforoie", (void**)&(pWrapperTable->m_RTCContext_InitializeForOIE));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_InitializeForOIE == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableoie", (void**)&(pWrapperTable->m_RTCContext_EnableOIE));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableOIE == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disableoie", (void**)&(pWrapperTable->m_RTCContext_DisableOIE));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableOIE == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_startoiemeasurement", (void**)&(pWrapperTable->m_RTCContext_StartOIEMeasurement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_StartOIEMeasurement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_stopoiemeasurement", (void**)&(pWrapperTable->m_RTCContext_StopOIEMeasurement));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_StopOIEMeasurement == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disableskywriting", (void**)&(pWrapperTable->m_RTCContext_DisableSkyWriting));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableSkyWriting == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableskywritingmode1", (void**)&(pWrapperTable->m_RTCContext_EnableSkyWritingMode1));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableSkyWritingMode1 == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableskywritingmode2", (void**)&(pWrapperTable->m_RTCContext_EnableSkyWritingMode2));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableSkyWritingMode2 == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_enableskywritingmode3", (void**)&(pWrapperTable->m_RTCContext_EnableSkyWritingMode3));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_EnableSkyWritingMode3 == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_searchcards", (void**)&(pWrapperTable->m_RTCSelector_SearchCards));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_SearchCards == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_searchcardsbyrange", (void**)&(pWrapperTable->m_RTCSelector_SearchCardsByRange));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_SearchCardsByRange == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_getcardcount", (void**)&(pWrapperTable->m_RTCSelector_GetCardCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_GetCardCount == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_getethernetcardcount", (void**)&(pWrapperTable->m_RTCSelector_GetEthernetCardCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_GetEthernetCardCount == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquirecard", (void**)&(pWrapperTable->m_RTCSelector_AcquireCard));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireCard == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquirecardbyserial", (void**)&(pWrapperTable->m_RTCSelector_AcquireCardBySerial));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireCardBySerial == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquireethernetcard", (void**)&(pWrapperTable->m_RTCSelector_AcquireEthernetCard));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireEthernetCard == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial", (void**)&(pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_loadsdk", (void**)&(pWrapperTable->m_Driver_ScanLab_LoadSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_LoadSDK == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_loadcustomsdk", (void**)&(pWrapperTable->m_Driver_ScanLab_LoadCustomSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_LoadCustomSDK == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_creatertcselector", (void**)&(pWrapperTable->m_Driver_ScanLab_CreateRTCSelector));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_CreateRTCSelector == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_settosimulationmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_SetToSimulationMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_issimulationmode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_IsSimulationMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_initialise", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_Initialise));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_Initialise == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getcontext", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetContext == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getselector", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetSelector == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_loadfirmware", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_LoadFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_loadcustomfirmware", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_LoadCustomFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_setcorrectionfile", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_SetCorrectionFile == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_configurelasermode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureLaserMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_configuredelays", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_ConfigureDelays == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_drawlayer", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_DrawLayer == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_setcommunicationtimeouts", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_SetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc6_getcommunicationtimeouts", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC6_GetCommunicationTimeouts == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededType = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_ScanLab_uint32 bytesNeededBuild = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::QueryParameters - Updates the driver parameters in the driver environment. Should only be called in the driver thread.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	* CDriver::QueryParametersEx - Updates the driver parameters in the driver environment. Might be called out of thread. Implementation MUST be able to handle parallel calls.
	* @param[in] pDriverUpdateInstance - Status update instance.
	*/
	void CDriver::QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance)
	{
		LibMCEnvHandle hDriverUpdateInstance = pDriverUpdateInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParametersEx(m_pHandle, hDriverUpdateInstance));
	}
	
	/**
	 * Method definitions for class CRTCContext
	 */
	
	/**
	* CRTCContext::LoadFirmware - Loads card firmware from resource files.
	* @param[in] FirmwareDataBuffer - byte array of the firmware program file.
	* @param[in] FPGADataBuffer - byte array of the firmware FPGA file.
	* @param[in] AuxiliaryDataBuffer - byte array of the binary auxiliary file.
	*/
	void CRTCContext::LoadFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_LoadFirmware(m_pHandle, (LibMCDriver_ScanLab_uint64)FirmwareDataBuffer.size(), FirmwareDataBuffer.data(), (LibMCDriver_ScanLab_uint64)FPGADataBuffer.size(), FPGADataBuffer.data(), (LibMCDriver_ScanLab_uint64)AuxiliaryDataBuffer.size(), AuxiliaryDataBuffer.data()));
	}
	
	/**
	* CRTCContext::LoadCorrectionFile - Loads card calibration file from given resource file.
	* @param[in] CorrectionFileBuffer - binary data of the correction file.
	* @param[in] nTableNumber - Correction table index of card (1..8)
	* @param[in] nDimension - Is it a 2D or 3D correction file.
	*/
	void CRTCContext::LoadCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_LoadCorrectionFile(m_pHandle, (LibMCDriver_ScanLab_uint64)CorrectionFileBuffer.size(), CorrectionFileBuffer.data(), nTableNumber, nDimension));
	}
	
	/**
	* CRTCContext::SelectCorrectionTable - Selects Correction Table on card.
	* @param[in] nTableNumberHeadA - Table Number for HeadA (1..8) or off (0).
	* @param[in] nTableNumberHeadB - Table Number for HeadA (1..8) or off (0).
	*/
	void CRTCContext::SelectCorrectionTable(const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SelectCorrectionTable(m_pHandle, nTableNumberHeadA, nTableNumberHeadB));
	}
	
	/**
	* CRTCContext::ConfigureLists - Configures list buffer size.
	* @param[in] nSizeListA - Size of List A
	* @param[in] nSizeListB - Size of List B
	*/
	void CRTCContext::ConfigureLists(const LibMCDriver_ScanLab_uint32 nSizeListA, const LibMCDriver_ScanLab_uint32 nSizeListB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ConfigureLists(m_pHandle, nSizeListA, nSizeListB));
	}
	
	/**
	* CRTCContext::SetLaserMode - Sets laser mode of card.
	* @param[in] eLaserMode - Laser Mode Enum
	* @param[in] eLaserPort - Laser Port Enum
	*/
	void CRTCContext::SetLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserMode(m_pHandle, eLaserMode, eLaserPort));
	}
	
	/**
	* CRTCContext::DisableAutoLaserControl - Disables automatic laser control.
	*/
	void CRTCContext::DisableAutoLaserControl()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableAutoLaserControl(m_pHandle));
	}
	
	/**
	* CRTCContext::SetLaserControlParameters - Sets laser control parameters of card.
	* @param[in] bDisableLaser - Laser is disabled
	* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
	* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
	* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
	* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
	* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
	* @param[in] bOutputSynchronizationActive - Output synchronization active
	*/
	void CRTCContext::SetLaserControlParameters(const bool bDisableLaser, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserControlParameters(m_pHandle, bDisableLaser, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive));
	}
	
	/**
	* CRTCContext::SetLaserPulsesInBits - Sets laser control pulse interval (in 1/64th microseconds)
	* @param[in] nHalfPeriod - Half Output period in 1/64th microseconds
	* @param[in] nPulseLength - Pulse Length in 1/64th microseconds
	*/
	void CRTCContext::SetLaserPulsesInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserPulsesInBits(m_pHandle, nHalfPeriod, nPulseLength));
	}
	
	/**
	* CRTCContext::SetLaserPulsesInMicroSeconds - Sets laser control pulse interval (in microseconds)
	* @param[in] dHalfPeriod - Half Output period in microseconds
	* @param[in] dPulseLength - Pulse Length in microseconds
	*/
	void CRTCContext::SetLaserPulsesInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserPulsesInMicroSeconds(m_pHandle, dHalfPeriod, dPulseLength));
	}
	
	/**
	* CRTCContext::SetStandbyInBits - Sets standby pulse interval (in 1/64th microseconds)
	* @param[in] nHalfPeriod - Half Output period in 1/64th microseconds
	* @param[in] nPulseLength - Pulse Length in 1/64th microseconds
	*/
	void CRTCContext::SetStandbyInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetStandbyInBits(m_pHandle, nHalfPeriod, nPulseLength));
	}
	
	/**
	* CRTCContext::SetStandbyInMicroSeconds - Sets laser control pulse interval (in microseconds)
	* @param[in] dHalfPeriod - Half Output period in microseconds
	* @param[in] dPulseLength - Pulse Length in microseconds
	*/
	void CRTCContext::SetStandbyInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetStandbyInMicroSeconds(m_pHandle, dHalfPeriod, dPulseLength));
	}
	
	/**
	* CRTCContext::GetSerialNumber - Returns serial number of card
	* @return Returns serial number of board.
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetSerialNumber()
	{
		LibMCDriver_ScanLab_uint32 resultSerialNumber = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetSerialNumber(m_pHandle, &resultSerialNumber));
		
		return resultSerialNumber;
	}
	
	/**
	* CRTCContext::SetStartList - Opens the list to write
	* @param[in] nListIndex - Index of List (1 or 2).
	* @param[in] nPosition - Relative Position in List.
	*/
	void CRTCContext::SetStartList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetStartList(m_pHandle, nListIndex, nPosition));
	}
	
	/**
	* CRTCContext::SetEndOfList - Closes the currently open list
	*/
	void CRTCContext::SetEndOfList()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetEndOfList(m_pHandle));
	}
	
	/**
	* CRTCContext::ExecuteList - Executes the list
	* @param[in] nListIndex - Index of List (1 or 2).
	* @param[in] nPosition - Relative Position in List.
	*/
	void CRTCContext::ExecuteList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ExecuteList(m_pHandle, nListIndex, nPosition));
	}
	
	/**
	* CRTCContext::SetAutoChangePos - Sets the AutoChange Position of the currently not running list.
	* @param[in] nPosition - Relative Position in List.
	*/
	void CRTCContext::SetAutoChangePos(const LibMCDriver_ScanLab_uint32 nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetAutoChangePos(m_pHandle, nPosition));
	}
	
	/**
	* CRTCContext::SetDelays - Sets the laser delays
	* @param[in] nMarkDelay - Mark delay in microseconds (MUST be multiple of 10)
	* @param[in] nJumpDelay - Jump delay in microseconds (MUST be multiple of 10)
	* @param[in] nPolygonDelay - Polygon delay in microseconds (MUST be multiple of 10)
	*/
	void CRTCContext::SetDelays(const LibMCDriver_ScanLab_uint32 nMarkDelay, const LibMCDriver_ScanLab_uint32 nJumpDelay, const LibMCDriver_ScanLab_uint32 nPolygonDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetDelays(m_pHandle, nMarkDelay, nJumpDelay, nPolygonDelay));
	}
	
	/**
	* CRTCContext::SetLaserDelaysInMicroseconds - Sets the laser delays (on the list)
	* @param[in] dLaserOnDelay - LaserOn delay in microseconds
	* @param[in] dLaserOffDelay - LaserOff delay in microseconds
	*/
	void CRTCContext::SetLaserDelaysInMicroseconds(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserDelaysInMicroseconds(m_pHandle, dLaserOnDelay, dLaserOffDelay));
	}
	
	/**
	* CRTCContext::SetLaserDelaysInBits - Sets the laser delays (on the list)
	* @param[in] nLaserOnDelay - LaserOn delay in bits (1/64th microseconds)
	* @param[in] nLaserOffDelay - LaserOff delay in bits (1/64th microseconds)
	*/
	void CRTCContext::SetLaserDelaysInBits(const LibMCDriver_ScanLab_uint32 nLaserOnDelay, const LibMCDriver_ScanLab_uint32 nLaserOffDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserDelaysInBits(m_pHandle, nLaserOnDelay, nLaserOffDelay));
	}
	
	/**
	* CRTCContext::DrawPolyline - Writes a polyline into the open list
	* @param[in] PointsBuffer - Points of polyline to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Mark speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	*/
	void CRTCContext::DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DrawPolyline(m_pHandle, (LibMCDriver_ScanLab_uint64)PointsBuffer.size(), PointsBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue));
	}
	
	/**
	* CRTCContext::DrawHatches - Writes a list of hatches into the open list
	* @param[in] HatchesBuffer - Hatches to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Mark speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	*/
	void CRTCContext::DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DrawHatches(m_pHandle, (LibMCDriver_ScanLab_uint64)HatchesBuffer.size(), HatchesBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue));
	}
	
	/**
	* CRTCContext::AddCustomDelay - Adds a custom delay to the list
	* @param[in] nDelay - Custom delay value in microseconds (MUST be multiple of 10)
	*/
	void CRTCContext::AddCustomDelay(const LibMCDriver_ScanLab_uint32 nDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddCustomDelay(m_pHandle, nDelay));
	}
	
	/**
	* CRTCContext::GetCorrectionFactor - Returns correction factor of Card Calibration (in bits per mm)
	* @return CorrectionFactor
	*/
	LibMCDriver_ScanLab_double CRTCContext::GetCorrectionFactor()
	{
		LibMCDriver_ScanLab_double resultCorrectionFactor = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetCorrectionFactor(m_pHandle, &resultCorrectionFactor));
		
		return resultCorrectionFactor;
	}
	
	/**
	* CRTCContext::GetStatus - Returns status of list execution
	* @param[out] bBusy - Execution is busy
	* @param[out] nPosition - Returns current executed position
	*/
	void CRTCContext::GetStatus(bool & bBusy, LibMCDriver_ScanLab_uint32 & nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetStatus(m_pHandle, &bBusy, &nPosition));
	}
	
	/**
	* CRTCContext::GetHeadStatus - Returns status of scan head
	* @param[in] nHeadNo - Head Number
	* @param[out] bPositionXisOK - Position X is ok
	* @param[out] bPositionYisOK - Position Y is ok
	* @param[out] bTemperatureisOK - Temperature is ok
	* @param[out] bPowerisOK - Power is ok
	*/
	void CRTCContext::GetHeadStatus(const LibMCDriver_ScanLab_uint32 nHeadNo, bool & bPositionXisOK, bool & bPositionYisOK, bool & bTemperatureisOK, bool & bPowerisOK)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetHeadStatus(m_pHandle, nHeadNo, &bPositionXisOK, &bPositionYisOK, &bTemperatureisOK, &bPowerisOK));
	}
	
	/**
	* CRTCContext::GetStateValues - Returns status values of scan head
	* @param[out] bLaserIsOn - Laser is on
	* @param[out] nPositionX - Current Position X in Units
	* @param[out] nPositionY - Current Position Y in Units
	* @param[out] nPositionZ - Current Position Z in Units
	* @param[out] nCorrectedPositionX - Current Position X in Units
	* @param[out] nCorrectedPositionY - Current Position Y in Units
	* @param[out] nCorrectedPositionZ - Current Position Z in Units
	* @param[out] nFocusShift - Current Focus Shift in Units
	* @param[out] nMarkSpeed - Current Mark Speed in Units
	*/
	void CRTCContext::GetStateValues(bool & bLaserIsOn, LibMCDriver_ScanLab_int32 & nPositionX, LibMCDriver_ScanLab_int32 & nPositionY, LibMCDriver_ScanLab_int32 & nPositionZ, LibMCDriver_ScanLab_int32 & nCorrectedPositionX, LibMCDriver_ScanLab_int32 & nCorrectedPositionY, LibMCDriver_ScanLab_int32 & nCorrectedPositionZ, LibMCDriver_ScanLab_int32 & nFocusShift, LibMCDriver_ScanLab_int32 & nMarkSpeed)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetStateValues(m_pHandle, &bLaserIsOn, &nPositionX, &nPositionY, &nPositionZ, &nCorrectedPositionX, &nCorrectedPositionY, &nCorrectedPositionZ, &nFocusShift, &nMarkSpeed));
	}
	
	/**
	* CRTCContext::GetInputPointer - returns current input list position
	* @return Returns current position of open list
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetInputPointer()
	{
		LibMCDriver_ScanLab_uint32 resultPosition = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetInputPointer(m_pHandle, &resultPosition));
		
		return resultPosition;
	}
	
	/**
	* CRTCContext::GetRTCVersion - Returns version information of the RTC Card
	* @param[out] nRTCVersion - RTC Card Version
	* @param[out] nRTCType - RTC Card Type
	* @param[out] nDLLVersion - RTC DLL Version
	* @param[out] nHEXVersion - RTC HEX Version
	* @param[out] nBIOSVersion - RTC BIOS Version
	*/
	void CRTCContext::GetRTCVersion(LibMCDriver_ScanLab_uint32 & nRTCVersion, LibMCDriver_ScanLab_uint32 & nRTCType, LibMCDriver_ScanLab_uint32 & nDLLVersion, LibMCDriver_ScanLab_uint32 & nHEXVersion, LibMCDriver_ScanLab_uint32 & nBIOSVersion)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetRTCVersion(m_pHandle, &nRTCVersion, &nRTCType, &nDLLVersion, &nHEXVersion, &nBIOSVersion));
	}
	
	/**
	* CRTCContext::SetCommunicationTimeouts - Set RTC Ethernet communication timeouts
	* @param[in] dInitialTimeout - Initial timeout in ms
	* @param[in] dMaxTimeout - Max timeout in ms
	* @param[in] dMultiplier - Multiplier
	*/
	void CRTCContext::SetCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetCommunicationTimeouts(m_pHandle, dInitialTimeout, dMaxTimeout, dMultiplier));
	}
	
	/**
	* CRTCContext::GetCommunicationTimeouts - Get RTC Ethernet communication timeouts
	* @param[out] dInitialTimeout - Initial timeout in ms
	* @param[out] dMaxTimeout - Max timeout in ms
	* @param[out] dMultiplier - Multiplier
	*/
	void CRTCContext::GetCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetCommunicationTimeouts(m_pHandle, &dInitialTimeout, &dMaxTimeout, &dMultiplier));
	}
	
	/**
	* CRTCContext::InitializeForOIE - Initializes the RTC card for the open interface extension. MUST be called before the OIE is initialized.
	* @param[in] SignalChannelsBuffer - Array of signal channels. MUST NOT be empty
	* @param[in] eOperationMode - OIE Operation Mode
	*/
	void CRTCContext::InitializeForOIE(const CInputVector<LibMCDriver_ScanLab_uint32> & SignalChannelsBuffer, const eOIEOperationMode eOperationMode)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_InitializeForOIE(m_pHandle, (LibMCDriver_ScanLab_uint64)SignalChannelsBuffer.size(), SignalChannelsBuffer.data(), eOperationMode));
	}
	
	/**
	* CRTCContext::EnableOIE - Writes an OIE enabling command block to the open list.
	*/
	void CRTCContext::EnableOIE()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableOIE(m_pHandle));
	}
	
	/**
	* CRTCContext::DisableOIE - Writes an OIE disabling command block to the open list.
	*/
	void CRTCContext::DisableOIE()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableOIE(m_pHandle));
	}
	
	/**
	* CRTCContext::StartOIEMeasurement - Writes an OIE measurement start command block to the open list.
	*/
	void CRTCContext::StartOIEMeasurement()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_StartOIEMeasurement(m_pHandle));
	}
	
	/**
	* CRTCContext::StopOIEMeasurement - Writes an OIE measurement start command block to the open list.
	*/
	void CRTCContext::StopOIEMeasurement()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_StopOIEMeasurement(m_pHandle));
	}
	
	/**
	* CRTCContext::DisableSkyWriting - Disable skywriting.
	*/
	void CRTCContext::DisableSkyWriting()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableSkyWriting(m_pHandle));
	}
	
	/**
	* CRTCContext::EnableSkyWritingMode1 - Enables skywriting on the list in mode 1. See Scanlab RTC Documentation for details.
	* @param[in] dTimelag - Skywriting Timelag
	* @param[in] nLaserOnShift - Skywriting Laser On Shift
	* @param[in] nNPrev - Duration of pre-motion in ticks
	* @param[in] nNPost - Duration of post-motion in ticks. 
	*/
	void CRTCContext::EnableSkyWritingMode1(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableSkyWritingMode1(m_pHandle, dTimelag, nLaserOnShift, nNPrev, nNPost));
	}
	
	/**
	* CRTCContext::EnableSkyWritingMode2 - Enables skywriting on the list in mode 2. See Scanlab RTC Documentation for details.
	* @param[in] dTimelag - Skywriting Timelag
	* @param[in] nLaserOnShift - Skywriting Laser On Shift
	* @param[in] nNPrev - Duration of pre-motion in ticks
	* @param[in] nNPost - Duration of post-motion in ticks. 
	*/
	void CRTCContext::EnableSkyWritingMode2(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableSkyWritingMode2(m_pHandle, dTimelag, nLaserOnShift, nNPrev, nNPost));
	}
	
	/**
	* CRTCContext::EnableSkyWritingMode3 - Enables skywriting on the list in mode 3. See Scanlab RTC Documentation for details.
	* @param[in] dTimelag - Skywriting Timelag
	* @param[in] nLaserOnShift - Skywriting Laser On Shift
	* @param[in] nNPrev - Duration of pre-motion in ticks
	* @param[in] nNPost - Duration of post-motion in ticks. 
	* @param[in] dLimit - Skywriting Angle limit
	*/
	void CRTCContext::EnableSkyWritingMode3(const LibMCDriver_ScanLab_double dTimelag, const LibMCDriver_ScanLab_int64 nLaserOnShift, const LibMCDriver_ScanLab_int64 nNPrev, const LibMCDriver_ScanLab_int64 nNPost, const LibMCDriver_ScanLab_double dLimit)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_EnableSkyWritingMode3(m_pHandle, dTimelag, nLaserOnShift, nNPrev, nNPost, dLimit));
	}
	
	/**
	 * Method definitions for class CRTCSelector
	 */
	
	/**
	* CRTCSelector::SearchCards - Searches Ethernet Cards
	* @param[in] sIP - IP Network Address.
	* @param[in] sNetmask - IP Netmask Address.
	* @param[in] nTimeout - Time out in microseconds.
	* @return Returns how many ethernet cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::SearchCards(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout)
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_SearchCards(m_pHandle, sIP.c_str(), sNetmask.c_str(), nTimeout, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::SearchCardsByRange - Searches Ethernet Cards
	* @param[in] sStartIP - IP Network Address.
	* @param[in] sEndIP - IP Network Address.
	* @param[in] nTimeout - Time out in microseconds.
	* @return Returns how many ethernet cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::SearchCardsByRange(const std::string & sStartIP, const std::string & sEndIP, const LibMCDriver_ScanLab_uint32 nTimeout)
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_SearchCardsByRange(m_pHandle, sStartIP.c_str(), sEndIP.c_str(), nTimeout, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::GetCardCount - Returns number of detected Cards
	* @return Returns how many cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::GetCardCount()
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_GetCardCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::GetEthernetCardCount - Returns number of found ethernet cards
	* @return Returns how many ethernet cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::GetEthernetCardCount()
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_GetEthernetCardCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::AcquireCard - Acquires a card and returns an RTCContext instance.
	* @param[in] nNumber - Number of Card (1-based). Must be between 1 and CardCount.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireCard(const LibMCDriver_ScanLab_uint32 nNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireCard(m_pHandle, nNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCSelector::AcquireCardBySerial - Acquires a card and returns an RTCContext instance.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireCardBySerial(m_pHandle, nSerialNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCSelector::AcquireEthernetCard - Acquires an ethernet card and returns an RTCContext instance.
	* @param[in] nNumber - Number of Card (1-based). Must be between 1 and EthernetCardCount.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireEthernetCard(const LibMCDriver_ScanLab_uint32 nNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireEthernetCard(m_pHandle, nNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCSelector::AcquireEthernetCardBySerial - Acquires an ethernet card and returns an RTCContext instance.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireEthernetCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireEthernetCardBySerial(m_pHandle, nSerialNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	 * Method definitions for class CDriver_ScanLab
	 */
	
	/**
	* CDriver_ScanLab::LoadSDK - Initializes the ScanLab SDK.
	* @param[in] sResourceName - Resource name of Scanlab DLL
	*/
	void CDriver_ScanLab::LoadSDK(const std::string & sResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_LoadSDK(m_pHandle, sResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLab::LoadCustomSDK - Initializes the ScanLab SDK from an external source.
	* @param[in] ScanlabDLLBuffer - Byte array of Scanlab DLL
	*/
	void CDriver_ScanLab::LoadCustomSDK(const CInputVector<LibMCDriver_ScanLab_uint8> & ScanlabDLLBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_LoadCustomSDK(m_pHandle, (LibMCDriver_ScanLab_uint64)ScanlabDLLBuffer.size(), ScanlabDLLBuffer.data()));
	}
	
	/**
	* CDriver_ScanLab::CreateRTCSelector - Creates and initializes a new RTC selector singleton. Should only be called once per Process.
	* @return New Selector instance
	*/
	PRTCSelector CDriver_ScanLab::CreateRTCSelector()
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_CreateRTCSelector(m_pHandle, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCSelector>(m_pWrapper, hInstance);
	}
	
	/**
	 * Method definitions for class CDriver_ScanLab_RTC6
	 */
	
	/**
	* CDriver_ScanLab_RTC6::SetToSimulationMode - Turns the driver into a simulation mode.
	*/
	void CDriver_ScanLab_RTC6::SetToSimulationMode()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_SetToSimulationMode(m_pHandle));
	}
	
	/**
	* CDriver_ScanLab_RTC6::IsSimulationMode - Returns if the driver is in simulation mode.
	* @return Flag if driver is in simulation mode.
	*/
	bool CDriver_ScanLab_RTC6::IsSimulationMode()
	{
		bool resultSimulationModeEnabled = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_IsSimulationMode(m_pHandle, &resultSimulationModeEnabled));
		
		return resultSimulationModeEnabled;
	}
	
	/**
	* CDriver_ScanLab_RTC6::Initialise - Initializes the RTC6 Scanner Driver.
	* @param[in] sIP - IP Network Address. Empty string for local card.
	* @param[in] sNetmask - IP Netmask Address. Empty string for local card.
	* @param[in] nTimeout - Time out in microseconds.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	*/
	void CDriver_ScanLab_RTC6::Initialise(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout, const LibMCDriver_ScanLab_uint32 nSerialNumber)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_Initialise(m_pHandle, sIP.c_str(), sNetmask.c_str(), nTimeout, nSerialNumber));
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetContext - Returns the RTC Context Instance. Fails if it card has not been initialised.
	* @return RTC Context Instance.
	*/
	PRTCContext CDriver_ScanLab_RTC6::GetContext()
	{
		LibMCDriver_ScanLabHandle hContextInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetContext(m_pHandle, &hContextInstance));
		
		if (!hContextInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hContextInstance);
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetSelector - Returns the RTC Selector Instance. Fails if it card has not been initialised.
	* @return RTC Selector Instance.
	*/
	PRTCSelector CDriver_ScanLab_RTC6::GetSelector()
	{
		LibMCDriver_ScanLabHandle hSelectorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetSelector(m_pHandle, &hSelectorInstance));
		
		if (!hSelectorInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCSelector>(m_pWrapper, hSelectorInstance);
	}
	
	/**
	* CDriver_ScanLab_RTC6::LoadFirmware - Loads the firmware from the driver resources.
	* @param[in] sFirmwareResource - resource name of the firmware program file.
	* @param[in] sFPGAResource - resource name of the firmware FPGA file.
	* @param[in] sAuxiliaryResource - resource name of the binary auxiliary file.
	*/
	void CDriver_ScanLab_RTC6::LoadFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_LoadFirmware(m_pHandle, sFirmwareResource.c_str(), sFPGAResource.c_str(), sAuxiliaryResource.c_str()));
	}
	
	/**
	* CDriver_ScanLab_RTC6::LoadCustomFirmware - Loads the firmware from custom resources.
	* @param[in] FirmwareDataBuffer - byte array of the firmware program file.
	* @param[in] FPGADataBuffer - byte array of the firmware FPGA file.
	* @param[in] AuxiliaryDataBuffer - byte array of the binary auxiliary file.
	*/
	void CDriver_ScanLab_RTC6::LoadCustomFirmware(const CInputVector<LibMCDriver_ScanLab_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLab_uint8> & AuxiliaryDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_LoadCustomFirmware(m_pHandle, (LibMCDriver_ScanLab_uint64)FirmwareDataBuffer.size(), FirmwareDataBuffer.data(), (LibMCDriver_ScanLab_uint64)FPGADataBuffer.size(), FPGADataBuffer.data(), (LibMCDriver_ScanLab_uint64)AuxiliaryDataBuffer.size(), AuxiliaryDataBuffer.data()));
	}
	
	/**
	* CDriver_ScanLab_RTC6::SetCorrectionFile - Sets the correction file stream.
	* @param[in] CorrectionFileBuffer - binary data of the correction file.
	* @param[in] nTableNumber - Correction table index of card (1..8)
	* @param[in] nDimension - Is it a 2D or 3D correction file.
	* @param[in] nTableNumberHeadA - Table number of Head A.
	* @param[in] nTableNumberHeadB - Table number of Head B.
	*/
	void CDriver_ScanLab_RTC6::SetCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension, const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_SetCorrectionFile(m_pHandle, (LibMCDriver_ScanLab_uint64)CorrectionFileBuffer.size(), CorrectionFileBuffer.data(), nTableNumber, nDimension, nTableNumberHeadA, nTableNumberHeadB));
	}
	
	/**
	* CDriver_ScanLab_RTC6::ConfigureLaserMode - Configures the laser mode.
	* @param[in] eLaserMode - Laser Mode Enum
	* @param[in] eLaserPort - Laser Port Enum
	* @param[in] dMaxLaserPower - Maximum laser power.
	* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
	* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
	* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
	* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
	* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
	* @param[in] bOutputSynchronizationActive - Output synchronization active
	*/
	void CDriver_ScanLab_RTC6::ConfigureLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort, const LibMCDriver_ScanLab_double dMaxLaserPower, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_ConfigureLaserMode(m_pHandle, eLaserMode, eLaserPort, dMaxLaserPower, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive));
	}
	
	/**
	* CDriver_ScanLab_RTC6::ConfigureDelays - Configures the default laser and scanner delays.
	* @param[in] dLaserOnDelay - Laser On Delay in Microseconds
	* @param[in] dLaserOffDelay - Laser Off Delay in Microseconds
	* @param[in] dMarkDelay - Mark delay in microseconds (will be rounded to a multiple of 10)
	* @param[in] dJumpDelay - Jump delay in microseconds (will be rounded to a multiple of 10)
	* @param[in] dPolygonDelay - Polygon delay in microseconds (will be rounded to a multiple of 10)
	*/
	void CDriver_ScanLab_RTC6::ConfigureDelays(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay, const LibMCDriver_ScanLab_double dMarkDelay, const LibMCDriver_ScanLab_double dJumpDelay, const LibMCDriver_ScanLab_double dPolygonDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_ConfigureDelays(m_pHandle, dLaserOnDelay, dLaserOffDelay, dMarkDelay, dJumpDelay, dPolygonDelay));
	}
	
	/**
	* CDriver_ScanLab_RTC6::DrawLayer - Draws a layer of a build stream. Blocks until the layer is drawn.
	* @param[in] sStreamUUID - UUID of the build stream. Must have been loaded in memory by the system.
	* @param[in] nLayerIndex - Layer index of the build file.
	*/
	void CDriver_ScanLab_RTC6::DrawLayer(const std::string & sStreamUUID, const LibMCDriver_ScanLab_uint32 nLayerIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_DrawLayer(m_pHandle, sStreamUUID.c_str(), nLayerIndex));
	}
	
	/**
	* CDriver_ScanLab_RTC6::SetCommunicationTimeouts - Set RTC Ethernet communication timeouts
	* @param[in] dInitialTimeout - Initial timeout in ms
	* @param[in] dMaxTimeout - Max timeout in ms
	* @param[in] dMultiplier - Multiplier
	*/
	void CDriver_ScanLab_RTC6::SetCommunicationTimeouts(const LibMCDriver_ScanLab_double dInitialTimeout, const LibMCDriver_ScanLab_double dMaxTimeout, const LibMCDriver_ScanLab_double dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_SetCommunicationTimeouts(m_pHandle, dInitialTimeout, dMaxTimeout, dMultiplier));
	}
	
	/**
	* CDriver_ScanLab_RTC6::GetCommunicationTimeouts - Get RTC Ethernet communication timeouts
	* @param[out] dInitialTimeout - Initial timeout in ms
	* @param[out] dMaxTimeout - Max timeout in ms
	* @param[out] dMultiplier - Multiplier
	*/
	void CDriver_ScanLab_RTC6::GetCommunicationTimeouts(LibMCDriver_ScanLab_double & dInitialTimeout, LibMCDriver_ScanLab_double & dMaxTimeout, LibMCDriver_ScanLab_double & dMultiplier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC6_GetCommunicationTimeouts(m_pHandle, &dInitialTimeout, &dMaxTimeout, &dMultiplier));
	}

} // namespace LibMCDriver_ScanLab

#endif // __LIBMCDRIVER_SCANLAB_CPPHEADER_DYNAMIC_CPP

