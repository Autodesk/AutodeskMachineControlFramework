/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver ScanLab RTC5

Interface version: 1.0.0

*/

#ifndef __LIBMCDRIVER_SCANLAB_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_SCANLAB_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_scanlab_types.hpp"
#include "libmcdriver_scanlab_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_ScanLab {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CRTCContext;
class CRTCSelector;
class CDriver_ScanLab;
class CDriver_ScanLab_RTC5;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_ScanLabWrapper;
typedef CBase CLibMCDriver_ScanLabBase;
typedef CDriver CLibMCDriver_ScanLabDriver;
typedef CRTCContext CLibMCDriver_ScanLabRTCContext;
typedef CRTCSelector CLibMCDriver_ScanLabRTCSelector;
typedef CDriver_ScanLab CLibMCDriver_ScanLabDriver_ScanLab;
typedef CDriver_ScanLab_RTC5 CLibMCDriver_ScanLabDriver_ScanLab_RTC5;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CRTCContext> PRTCContext;
typedef std::shared_ptr<CRTCSelector> PRTCSelector;
typedef std::shared_ptr<CDriver_ScanLab> PDriver_ScanLab;
typedef std::shared_ptr<CDriver_ScanLab_RTC5> PDriver_ScanLab_RTC5;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_ScanLabWrapper;
typedef PBase PLibMCDriver_ScanLabBase;
typedef PDriver PLibMCDriver_ScanLabDriver;
typedef PRTCContext PLibMCDriver_ScanLabRTCContext;
typedef PRTCSelector PLibMCDriver_ScanLabRTCSelector;
typedef PDriver_ScanLab PLibMCDriver_ScanLabDriver_ScanLab;
typedef PDriver_ScanLab_RTC5 PLibMCDriver_ScanLabDriver_ScanLab_RTC5;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_ScanLabHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_ScanLabException 
**************************************************************************************************************************/
class ELibMCDriver_ScanLabException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_ScanLabResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_ScanLabException(LibMCDriver_ScanLabResult errorCode, const std::string & sErrorMessage)
		: m_errorMessage("LibMCDriver_ScanLab Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
	{
		m_errorCode = errorCode;
	}

	/**
	* Returns error code
	*/
	LibMCDriver_ScanLabResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector( const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector( const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_ScanLabInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_ScanLabResult nResult);

	inline void GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLab_pvoid pSymbolAddressMethod);
	inline LibMCDriver_ScanLab_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_ScanLabDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_ScanLabResult checkBinaryVersion()
	{
		LibMCDriver_ScanLab_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != LIBMCDRIVER_SCANLAB_VERSION_MAJOR) || (nMinor < LIBMCDRIVER_SCANLAB_VERSION_MINOR) ) {
			return LIBMCDRIVER_SCANLAB_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	LibMCDriver_ScanLabResult initWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabResult releaseWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabResult loadWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_ScanLabResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CRTCContext;
	friend class CRTCSelector;
	friend class CDriver_ScanLab;
	friend class CDriver_ScanLab_RTC5;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_ScanLabHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_ScanLabResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_ScanLabHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro, std::string & sBuild);
	inline void GetHeaderInformation(std::string & sNameSpace, std::string & sBaseName);
	inline void QueryParameters();
};
	
/*************************************************************************************************************************
 Class CRTCContext 
**************************************************************************************************************************/
class CRTCContext : public CBase {
public:
	
	/**
	* CRTCContext::CRTCContext - Constructor for RTCContext class.
	*/
	CRTCContext(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void LoadFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource);
	inline void LoadCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension);
	inline void SelectCorrectionTable(const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB);
	inline void ConfigureLists(const LibMCDriver_ScanLab_uint32 nSizeListA, const LibMCDriver_ScanLab_uint32 nSizeListB);
	inline void SetLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort);
	inline void DisableAutoLaserControl();
	inline void SetLaserControlParameters(const bool bDisableLaser, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive);
	inline void SetLaserPulsesInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength);
	inline void SetLaserPulsesInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength);
	inline void SetStandbyInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength);
	inline void SetStandbyInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength);
	inline LibMCDriver_ScanLab_uint32 GetSerialNumber();
	inline void SetStartList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition);
	inline void SetEndOfList();
	inline void ExecuteList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition);
	inline void SetAutoChangePos(const LibMCDriver_ScanLab_uint32 nPosition);
	inline void SetDelays(const LibMCDriver_ScanLab_uint32 nMarkDelay, const LibMCDriver_ScanLab_uint32 nJumpDelay, const LibMCDriver_ScanLab_uint32 nPolygonDelay);
	inline void SetLaserDelaysInMicroseconds(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay);
	inline void SetLaserDelaysInBits(const LibMCDriver_ScanLab_uint32 nLaserOnDelay, const LibMCDriver_ScanLab_uint32 nLaserOffDelay);
	inline void DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue);
	inline void DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue);
	inline void AddCustomDelay(const LibMCDriver_ScanLab_uint32 nDelay);
	inline LibMCDriver_ScanLab_double GetCorrectionFactor();
	inline void GetStatus(bool & bBusy, LibMCDriver_ScanLab_uint32 & nPosition);
	inline void GetHeadStatus(const LibMCDriver_ScanLab_uint32 nHeadNo, bool & bPositionXisOK, bool & bPositionYisOK, bool & bTemperatureisOK, bool & bPowerisOK);
	inline void GetStateValues(bool & bLaserIsOn, LibMCDriver_ScanLab_uint32 & nPositionX, LibMCDriver_ScanLab_uint32 & nPositionY, LibMCDriver_ScanLab_uint32 & nPositionZ, LibMCDriver_ScanLab_uint32 & nCorrectedPositionX, LibMCDriver_ScanLab_uint32 & nCorrectedPositionY, LibMCDriver_ScanLab_uint32 & nCorrectedPositionZ, LibMCDriver_ScanLab_uint32 & nFocusShift, LibMCDriver_ScanLab_uint32 & nMarkSpeed);
	inline LibMCDriver_ScanLab_uint32 GetInputPointer();
	inline void GetRTCVersion(LibMCDriver_ScanLab_uint32 & nRTCVersion, LibMCDriver_ScanLab_uint32 & nRTCType, LibMCDriver_ScanLab_uint32 & nDLLVersion, LibMCDriver_ScanLab_uint32 & nHEXVersion, LibMCDriver_ScanLab_uint32 & nBIOSVersion);
};
	
/*************************************************************************************************************************
 Class CRTCSelector 
**************************************************************************************************************************/
class CRTCSelector : public CBase {
public:
	
	/**
	* CRTCSelector::CRTCSelector - Constructor for RTCSelector class.
	*/
	CRTCSelector(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCDriver_ScanLab_uint32 SearchCards(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout);
	inline LibMCDriver_ScanLab_uint32 SearchCardsByRange(const std::string & sStartIP, const std::string & sEndIP, const LibMCDriver_ScanLab_uint32 nTimeout);
	inline LibMCDriver_ScanLab_uint32 GetCardCount();
	inline LibMCDriver_ScanLab_uint32 GetEthernetCardCount();
	inline PRTCContext AcquireCard(const LibMCDriver_ScanLab_uint32 nNumber);
	inline PRTCContext AcquireCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber);
	inline PRTCContext AcquireEthernetCard(const LibMCDriver_ScanLab_uint32 nNumber);
	inline PRTCContext AcquireEthernetCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber);
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLab 
**************************************************************************************************************************/
class CDriver_ScanLab : public CDriver {
public:
	
	/**
	* CDriver_ScanLab::CDriver_ScanLab - Constructor for Driver_ScanLab class.
	*/
	CDriver_ScanLab(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline void LoadSDK(const std::string & sResourceName);
	inline PRTCSelector CreateRTCSelector();
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLab_RTC5 
**************************************************************************************************************************/
class CDriver_ScanLab_RTC5 : public CDriver_ScanLab {
public:
	
	/**
	* CDriver_ScanLab_RTC5::CDriver_ScanLab_RTC5 - Constructor for Driver_ScanLab_RTC5 class.
	*/
	CDriver_ScanLab_RTC5(CWrapper* pWrapper, LibMCDriver_ScanLabHandle pHandle)
		: CDriver_ScanLab(pWrapper, pHandle)
	{
	}
	
	inline void Initialise(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout, const LibMCDriver_ScanLab_uint32 nSerialNumber);
	inline void LoadFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource);
	inline void SetCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension, const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB);
	inline void ConfigureLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort, const LibMCDriver_ScanLab_double dMaxLaserPower, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive);
	inline void DrawLayer(const std::string & sStreamUUID, const LibMCDriver_ScanLab_uint32 nLayerIndex);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_ScanLabHandle hInstance = pInstance.GetHandle();
		LibMCDriver_ScanLab_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLab_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_ScanLabException(LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_ScanLabException(LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_ScanLab_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_ScanLab_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDriver>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_ScanLabResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_ScanLabException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_ScanLabResult CWrapper::initWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_GetHeaderInformation = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_RTCContext_LoadFirmware = nullptr;
		pWrapperTable->m_RTCContext_LoadCorrectionFile = nullptr;
		pWrapperTable->m_RTCContext_SelectCorrectionTable = nullptr;
		pWrapperTable->m_RTCContext_ConfigureLists = nullptr;
		pWrapperTable->m_RTCContext_SetLaserMode = nullptr;
		pWrapperTable->m_RTCContext_DisableAutoLaserControl = nullptr;
		pWrapperTable->m_RTCContext_SetLaserControlParameters = nullptr;
		pWrapperTable->m_RTCContext_SetLaserPulsesInBits = nullptr;
		pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds = nullptr;
		pWrapperTable->m_RTCContext_SetStandbyInBits = nullptr;
		pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds = nullptr;
		pWrapperTable->m_RTCContext_GetSerialNumber = nullptr;
		pWrapperTable->m_RTCContext_SetStartList = nullptr;
		pWrapperTable->m_RTCContext_SetEndOfList = nullptr;
		pWrapperTable->m_RTCContext_ExecuteList = nullptr;
		pWrapperTable->m_RTCContext_SetAutoChangePos = nullptr;
		pWrapperTable->m_RTCContext_SetDelays = nullptr;
		pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds = nullptr;
		pWrapperTable->m_RTCContext_SetLaserDelaysInBits = nullptr;
		pWrapperTable->m_RTCContext_DrawPolyline = nullptr;
		pWrapperTable->m_RTCContext_DrawHatches = nullptr;
		pWrapperTable->m_RTCContext_AddCustomDelay = nullptr;
		pWrapperTable->m_RTCContext_GetCorrectionFactor = nullptr;
		pWrapperTable->m_RTCContext_GetStatus = nullptr;
		pWrapperTable->m_RTCContext_GetHeadStatus = nullptr;
		pWrapperTable->m_RTCContext_GetStateValues = nullptr;
		pWrapperTable->m_RTCContext_GetInputPointer = nullptr;
		pWrapperTable->m_RTCContext_GetRTCVersion = nullptr;
		pWrapperTable->m_RTCSelector_SearchCards = nullptr;
		pWrapperTable->m_RTCSelector_SearchCardsByRange = nullptr;
		pWrapperTable->m_RTCSelector_GetCardCount = nullptr;
		pWrapperTable->m_RTCSelector_GetEthernetCardCount = nullptr;
		pWrapperTable->m_RTCSelector_AcquireCard = nullptr;
		pWrapperTable->m_RTCSelector_AcquireCardBySerial = nullptr;
		pWrapperTable->m_RTCSelector_AcquireEthernetCard = nullptr;
		pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial = nullptr;
		pWrapperTable->m_Driver_ScanLab_LoadSDK = nullptr;
		pWrapperTable->m_Driver_ScanLab_CreateRTCSelector = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC5_Initialise = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC5_LoadFirmware = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC5_SetCorrectionFile = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC5_ConfigureLaserMode = nullptr;
		pWrapperTable->m_Driver_ScanLab_RTC5_DrawLayer = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}

	inline LibMCDriver_ScanLabResult CWrapper::releaseWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}

	inline LibMCDriver_ScanLabResult CWrapper::loadWrapperTable(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = (int)strlen(pLibraryFileName);
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetHeaderInformation = (PLibMCDriver_ScanLabDriver_GetHeaderInformationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_getheaderinformation");
		#else // _WIN32
		pWrapperTable->m_Driver_GetHeaderInformation = (PLibMCDriver_ScanLabDriver_GetHeaderInformationPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_getheaderinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetHeaderInformation == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_LoadFirmware = (PLibMCDriver_ScanLabRTCContext_LoadFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_loadfirmware");
		#else // _WIN32
		pWrapperTable->m_RTCContext_LoadFirmware = (PLibMCDriver_ScanLabRTCContext_LoadFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_loadfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_LoadFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_LoadCorrectionFile = (PLibMCDriver_ScanLabRTCContext_LoadCorrectionFilePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_loadcorrectionfile");
		#else // _WIN32
		pWrapperTable->m_RTCContext_LoadCorrectionFile = (PLibMCDriver_ScanLabRTCContext_LoadCorrectionFilePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_loadcorrectionfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_LoadCorrectionFile == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SelectCorrectionTable = (PLibMCDriver_ScanLabRTCContext_SelectCorrectionTablePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_selectcorrectiontable");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SelectCorrectionTable = (PLibMCDriver_ScanLabRTCContext_SelectCorrectionTablePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_selectcorrectiontable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SelectCorrectionTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ConfigureLists = (PLibMCDriver_ScanLabRTCContext_ConfigureListsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_configurelists");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ConfigureLists = (PLibMCDriver_ScanLabRTCContext_ConfigureListsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_configurelists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ConfigureLists == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserMode = (PLibMCDriver_ScanLabRTCContext_SetLaserModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlasermode");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserMode = (PLibMCDriver_ScanLabRTCContext_SetLaserModePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlasermode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DisableAutoLaserControl = (PLibMCDriver_ScanLabRTCContext_DisableAutoLaserControlPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_disableautolasercontrol");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DisableAutoLaserControl = (PLibMCDriver_ScanLabRTCContext_DisableAutoLaserControlPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_disableautolasercontrol");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DisableAutoLaserControl == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserControlParameters = (PLibMCDriver_ScanLabRTCContext_SetLaserControlParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlasercontrolparameters");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserControlParameters = (PLibMCDriver_ScanLabRTCContext_SetLaserControlParametersPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlasercontrolparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserControlParameters == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInBitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinbits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInBitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinbits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserPulsesInBits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInMicroSecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInMicroSecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInBits = (PLibMCDriver_ScanLabRTCContext_SetStandbyInBitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinbits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInBits = (PLibMCDriver_ScanLabRTCContext_SetStandbyInBitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinbits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetStandbyInBits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetStandbyInMicroSecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds = (PLibMCDriver_ScanLabRTCContext_SetStandbyInMicroSecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetSerialNumber = (PLibMCDriver_ScanLabRTCContext_GetSerialNumberPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getserialnumber");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetSerialNumber = (PLibMCDriver_ScanLabRTCContext_GetSerialNumberPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getserialnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetSerialNumber == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetStartList = (PLibMCDriver_ScanLabRTCContext_SetStartListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setstartlist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetStartList = (PLibMCDriver_ScanLabRTCContext_SetStartListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setstartlist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetStartList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetEndOfList = (PLibMCDriver_ScanLabRTCContext_SetEndOfListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setendoflist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetEndOfList = (PLibMCDriver_ScanLabRTCContext_SetEndOfListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setendoflist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetEndOfList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_ExecuteList = (PLibMCDriver_ScanLabRTCContext_ExecuteListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_executelist");
		#else // _WIN32
		pWrapperTable->m_RTCContext_ExecuteList = (PLibMCDriver_ScanLabRTCContext_ExecuteListPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_executelist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_ExecuteList == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetAutoChangePos = (PLibMCDriver_ScanLabRTCContext_SetAutoChangePosPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setautochangepos");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetAutoChangePos = (PLibMCDriver_ScanLabRTCContext_SetAutoChangePosPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setautochangepos");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetAutoChangePos == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetDelays = (PLibMCDriver_ScanLabRTCContext_SetDelaysPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setdelays");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetDelays = (PLibMCDriver_ScanLabRTCContext_SetDelaysPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setdelays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetDelays == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInMicrosecondsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInBitsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinbits");
		#else // _WIN32
		pWrapperTable->m_RTCContext_SetLaserDelaysInBits = (PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInBitsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_setlaserdelaysinbits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_SetLaserDelaysInBits == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DrawPolyline = (PLibMCDriver_ScanLabRTCContext_DrawPolylinePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_drawpolyline");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DrawPolyline = (PLibMCDriver_ScanLabRTCContext_DrawPolylinePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_drawpolyline");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DrawPolyline == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_DrawHatches = (PLibMCDriver_ScanLabRTCContext_DrawHatchesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_drawhatches");
		#else // _WIN32
		pWrapperTable->m_RTCContext_DrawHatches = (PLibMCDriver_ScanLabRTCContext_DrawHatchesPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_drawhatches");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_DrawHatches == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_AddCustomDelay = (PLibMCDriver_ScanLabRTCContext_AddCustomDelayPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_addcustomdelay");
		#else // _WIN32
		pWrapperTable->m_RTCContext_AddCustomDelay = (PLibMCDriver_ScanLabRTCContext_AddCustomDelayPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_addcustomdelay");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_AddCustomDelay == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetCorrectionFactor = (PLibMCDriver_ScanLabRTCContext_GetCorrectionFactorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getcorrectionfactor");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetCorrectionFactor = (PLibMCDriver_ScanLabRTCContext_GetCorrectionFactorPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getcorrectionfactor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetCorrectionFactor == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetStatus = (PLibMCDriver_ScanLabRTCContext_GetStatusPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getstatus");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetStatus = (PLibMCDriver_ScanLabRTCContext_GetStatusPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetStatus == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetHeadStatus = (PLibMCDriver_ScanLabRTCContext_GetHeadStatusPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getheadstatus");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetHeadStatus = (PLibMCDriver_ScanLabRTCContext_GetHeadStatusPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getheadstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetHeadStatus == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetStateValues = (PLibMCDriver_ScanLabRTCContext_GetStateValuesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getstatevalues");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetStateValues = (PLibMCDriver_ScanLabRTCContext_GetStateValuesPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getstatevalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetStateValues == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetInputPointer = (PLibMCDriver_ScanLabRTCContext_GetInputPointerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getinputpointer");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetInputPointer = (PLibMCDriver_ScanLabRTCContext_GetInputPointerPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getinputpointer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetInputPointer == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCContext_GetRTCVersion = (PLibMCDriver_ScanLabRTCContext_GetRTCVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcversion");
		#else // _WIN32
		pWrapperTable->m_RTCContext_GetRTCVersion = (PLibMCDriver_ScanLabRTCContext_GetRTCVersionPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtccontext_getrtcversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCContext_GetRTCVersion == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_SearchCards = (PLibMCDriver_ScanLabRTCSelector_SearchCardsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_searchcards");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_SearchCards = (PLibMCDriver_ScanLabRTCSelector_SearchCardsPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_searchcards");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_SearchCards == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_SearchCardsByRange = (PLibMCDriver_ScanLabRTCSelector_SearchCardsByRangePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_searchcardsbyrange");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_SearchCardsByRange = (PLibMCDriver_ScanLabRTCSelector_SearchCardsByRangePtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_searchcardsbyrange");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_SearchCardsByRange == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_GetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetCardCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_getcardcount");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_GetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetCardCountPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_getcardcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_GetCardCount == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_GetEthernetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetEthernetCardCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_getethernetcardcount");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_GetEthernetCardCount = (PLibMCDriver_ScanLabRTCSelector_GetEthernetCardCountPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_getethernetcardcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_GetEthernetCardCount == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireCard = (PLibMCDriver_ScanLabRTCSelector_AcquireCardPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecard");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireCard = (PLibMCDriver_ScanLabRTCSelector_AcquireCardPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecard");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireCard == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireCardBySerialPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecardbyserial");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireCardBySerialPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquirecardbyserial");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireCardBySerial == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCard = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcard");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCard = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcard");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireEthernetCard == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardBySerialPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial");
		#else // _WIN32
		pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial = (PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardBySerialPtr) dlsym(hLibrary, "libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadsdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_LoadSDK = (PLibMCDriver_ScanLabDriver_ScanLab_LoadSDKPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_loadsdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_LoadSDK == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_CreateRTCSelector = (PLibMCDriver_ScanLabDriver_ScanLab_CreateRTCSelectorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_creatertcselector");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_CreateRTCSelector = (PLibMCDriver_ScanLabDriver_ScanLab_CreateRTCSelectorPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_creatertcselector");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_CreateRTCSelector == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_Initialise = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_InitialisePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_initialise");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_Initialise = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_InitialisePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_initialise");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC5_Initialise == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_LoadFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_LoadFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_loadfirmware");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_LoadFirmware = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_LoadFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_loadfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC5_LoadFirmware == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_SetCorrectionFile = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_SetCorrectionFilePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_setcorrectionfile");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_SetCorrectionFile = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_SetCorrectionFilePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_setcorrectionfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC5_SetCorrectionFile == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_ConfigureLaserMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_ConfigureLaserModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_configurelasermode");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_ConfigureLaserMode = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_ConfigureLaserModePtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_configurelasermode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC5_ConfigureLaserMode == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_DrawLayer = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_DrawLayerPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_drawlayer");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_RTC5_DrawLayer = (PLibMCDriver_ScanLabDriver_ScanLab_RTC5_DrawLayerPtr) dlsym(hLibrary, "libmcdriver_scanlab_driver_scanlab_rtc5_drawlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_RTC5_DrawLayer == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabGetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlab_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_scanlab_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_scanlab_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_scanlab_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabInjectComponentPtr) dlsym(hLibrary, "libmcdriver_scanlab_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_scanlab_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabCreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_scanlab_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabCreateDriverPtr) dlsym(hLibrary, "libmcdriver_scanlab_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}

	inline LibMCDriver_ScanLabResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_ScanLabResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_ScanLabResult eLookupError = LIBMCDRIVER_SCANLAB_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_getheaderinformation", (void**)&(pWrapperTable->m_Driver_GetHeaderInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetHeaderInformation == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_loadfirmware", (void**)&(pWrapperTable->m_RTCContext_LoadFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_LoadFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_loadcorrectionfile", (void**)&(pWrapperTable->m_RTCContext_LoadCorrectionFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_LoadCorrectionFile == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_selectcorrectiontable", (void**)&(pWrapperTable->m_RTCContext_SelectCorrectionTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SelectCorrectionTable == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_configurelists", (void**)&(pWrapperTable->m_RTCContext_ConfigureLists));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ConfigureLists == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlasermode", (void**)&(pWrapperTable->m_RTCContext_SetLaserMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_disableautolasercontrol", (void**)&(pWrapperTable->m_RTCContext_DisableAutoLaserControl));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DisableAutoLaserControl == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlasercontrolparameters", (void**)&(pWrapperTable->m_RTCContext_SetLaserControlParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserControlParameters == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserpulsesinbits", (void**)&(pWrapperTable->m_RTCContext_SetLaserPulsesInBits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserPulsesInBits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserPulsesInMicroSeconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setstandbyinbits", (void**)&(pWrapperTable->m_RTCContext_SetStandbyInBits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetStandbyInBits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetStandbyInMicroSeconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getserialnumber", (void**)&(pWrapperTable->m_RTCContext_GetSerialNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetSerialNumber == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setstartlist", (void**)&(pWrapperTable->m_RTCContext_SetStartList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetStartList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setendoflist", (void**)&(pWrapperTable->m_RTCContext_SetEndOfList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetEndOfList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_executelist", (void**)&(pWrapperTable->m_RTCContext_ExecuteList));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_ExecuteList == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setautochangepos", (void**)&(pWrapperTable->m_RTCContext_SetAutoChangePos));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetAutoChangePos == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setdelays", (void**)&(pWrapperTable->m_RTCContext_SetDelays));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetDelays == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds", (void**)&(pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserDelaysInMicroseconds == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_setlaserdelaysinbits", (void**)&(pWrapperTable->m_RTCContext_SetLaserDelaysInBits));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_SetLaserDelaysInBits == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_drawpolyline", (void**)&(pWrapperTable->m_RTCContext_DrawPolyline));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DrawPolyline == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_drawhatches", (void**)&(pWrapperTable->m_RTCContext_DrawHatches));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_DrawHatches == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_addcustomdelay", (void**)&(pWrapperTable->m_RTCContext_AddCustomDelay));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_AddCustomDelay == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getcorrectionfactor", (void**)&(pWrapperTable->m_RTCContext_GetCorrectionFactor));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetCorrectionFactor == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getstatus", (void**)&(pWrapperTable->m_RTCContext_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetStatus == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getheadstatus", (void**)&(pWrapperTable->m_RTCContext_GetHeadStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetHeadStatus == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getstatevalues", (void**)&(pWrapperTable->m_RTCContext_GetStateValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetStateValues == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getinputpointer", (void**)&(pWrapperTable->m_RTCContext_GetInputPointer));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetInputPointer == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtccontext_getrtcversion", (void**)&(pWrapperTable->m_RTCContext_GetRTCVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCContext_GetRTCVersion == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_searchcards", (void**)&(pWrapperTable->m_RTCSelector_SearchCards));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_SearchCards == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_searchcardsbyrange", (void**)&(pWrapperTable->m_RTCSelector_SearchCardsByRange));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_SearchCardsByRange == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_getcardcount", (void**)&(pWrapperTable->m_RTCSelector_GetCardCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_GetCardCount == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_getethernetcardcount", (void**)&(pWrapperTable->m_RTCSelector_GetEthernetCardCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_GetEthernetCardCount == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquirecard", (void**)&(pWrapperTable->m_RTCSelector_AcquireCard));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireCard == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquirecardbyserial", (void**)&(pWrapperTable->m_RTCSelector_AcquireCardBySerial));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireCardBySerial == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquireethernetcard", (void**)&(pWrapperTable->m_RTCSelector_AcquireEthernetCard));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireEthernetCard == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial", (void**)&(pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial));
		if ( (eLookupError != 0) || (pWrapperTable->m_RTCSelector_AcquireEthernetCardBySerial == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_loadsdk", (void**)&(pWrapperTable->m_Driver_ScanLab_LoadSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_LoadSDK == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_creatertcselector", (void**)&(pWrapperTable->m_Driver_ScanLab_CreateRTCSelector));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_CreateRTCSelector == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc5_initialise", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC5_Initialise));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC5_Initialise == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc5_loadfirmware", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC5_LoadFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC5_LoadFirmware == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc5_setcorrectionfile", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC5_SetCorrectionFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC5_SetCorrectionFile == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc5_configurelasermode", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC5_ConfigureLaserMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC5_ConfigureLaserMode == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_driver_scanlab_rtc5_drawlayer", (void**)&(pWrapperTable->m_Driver_ScanLab_RTC5_DrawLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_RTC5_DrawLayer == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlab_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_ScanLab_uint32 bytesNeededType = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_ScanLab_uint32 & nMajor, LibMCDriver_ScanLab_uint32 & nMinor, LibMCDriver_ScanLab_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_ScanLab_uint32 bytesNeededBuild = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::GetHeaderInformation - returns the header information
	* @param[out] sNameSpace - NameSpace of the driver.
	* @param[out] sBaseName - BaseName of the driver.
	*/
	void CDriver::GetHeaderInformation(std::string & sNameSpace, std::string & sBaseName)
	{
		LibMCDriver_ScanLab_uint32 bytesNeededNameSpace = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenNameSpace = 0;
		LibMCDriver_ScanLab_uint32 bytesNeededBaseName = 0;
		LibMCDriver_ScanLab_uint32 bytesWrittenBaseName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetHeaderInformation(m_pHandle, 0, &bytesNeededNameSpace, nullptr, 0, &bytesNeededBaseName, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		std::vector<char> bufferBaseName(bytesNeededBaseName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetHeaderInformation(m_pHandle, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0], bytesNeededBaseName, &bytesWrittenBaseName, &bufferBaseName[0]));
		sNameSpace = std::string(&bufferNameSpace[0]);
		sBaseName = std::string(&bufferBaseName[0]);
	}
	
	/**
	* CDriver::QueryParameters - Stores the driver parameters in the driver environment.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	 * Method definitions for class CRTCContext
	 */
	
	/**
	* CRTCContext::LoadFirmware - Loads card firmware from resource files.
	* @param[in] sFirmwareResource - resource name of the firmware program file.
	* @param[in] sFPGAResource - resource name of the firmware FPGA file.
	* @param[in] sAuxiliaryResource - resource name of the binary auxiliary file.
	*/
	void CRTCContext::LoadFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_LoadFirmware(m_pHandle, sFirmwareResource.c_str(), sFPGAResource.c_str(), sAuxiliaryResource.c_str()));
	}
	
	/**
	* CRTCContext::LoadCorrectionFile - Loads card calibration file from given resource file.
	* @param[in] CorrectionFileBuffer - binary data of the correction file.
	* @param[in] nTableNumber - Correction table index of card (1..8)
	* @param[in] nDimension - Is it a 2D or 3D correction file.
	*/
	void CRTCContext::LoadCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_LoadCorrectionFile(m_pHandle, (LibMCDriver_ScanLab_uint64)CorrectionFileBuffer.size(), CorrectionFileBuffer.data(), nTableNumber, nDimension));
	}
	
	/**
	* CRTCContext::SelectCorrectionTable - Selects Correction Table on card.
	* @param[in] nTableNumberHeadA - Table Number for HeadA (1..8) or off (0).
	* @param[in] nTableNumberHeadB - Table Number for HeadA (1..8) or off (0).
	*/
	void CRTCContext::SelectCorrectionTable(const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SelectCorrectionTable(m_pHandle, nTableNumberHeadA, nTableNumberHeadB));
	}
	
	/**
	* CRTCContext::ConfigureLists - Configures list buffer size.
	* @param[in] nSizeListA - Size of List A
	* @param[in] nSizeListB - Size of List B
	*/
	void CRTCContext::ConfigureLists(const LibMCDriver_ScanLab_uint32 nSizeListA, const LibMCDriver_ScanLab_uint32 nSizeListB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ConfigureLists(m_pHandle, nSizeListA, nSizeListB));
	}
	
	/**
	* CRTCContext::SetLaserMode - Sets laser mode of card.
	* @param[in] eLaserMode - Laser Mode Enum
	* @param[in] eLaserPort - Laser Port Enum
	*/
	void CRTCContext::SetLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserMode(m_pHandle, eLaserMode, eLaserPort));
	}
	
	/**
	* CRTCContext::DisableAutoLaserControl - Disables automatic laser control.
	*/
	void CRTCContext::DisableAutoLaserControl()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DisableAutoLaserControl(m_pHandle));
	}
	
	/**
	* CRTCContext::SetLaserControlParameters - Sets laser control parameters of card.
	* @param[in] bDisableLaser - Laser is disabled
	* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
	* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
	* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
	* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
	* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
	* @param[in] bOutputSynchronizationActive - Output synchronization active
	*/
	void CRTCContext::SetLaserControlParameters(const bool bDisableLaser, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserControlParameters(m_pHandle, bDisableLaser, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive));
	}
	
	/**
	* CRTCContext::SetLaserPulsesInBits - Sets laser control pulse interval (in 1/64th microseconds)
	* @param[in] nHalfPeriod - Half Output period in 1/64th microseconds
	* @param[in] nPulseLength - Pulse Length in 1/64th microseconds
	*/
	void CRTCContext::SetLaserPulsesInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserPulsesInBits(m_pHandle, nHalfPeriod, nPulseLength));
	}
	
	/**
	* CRTCContext::SetLaserPulsesInMicroSeconds - Sets laser control pulse interval (in microseconds)
	* @param[in] dHalfPeriod - Half Output period in microseconds
	* @param[in] dPulseLength - Pulse Length in microseconds
	*/
	void CRTCContext::SetLaserPulsesInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserPulsesInMicroSeconds(m_pHandle, dHalfPeriod, dPulseLength));
	}
	
	/**
	* CRTCContext::SetStandbyInBits - Sets standby pulse interval (in 1/64th microseconds)
	* @param[in] nHalfPeriod - Half Output period in 1/64th microseconds
	* @param[in] nPulseLength - Pulse Length in 1/64th microseconds
	*/
	void CRTCContext::SetStandbyInBits(const LibMCDriver_ScanLab_uint32 nHalfPeriod, const LibMCDriver_ScanLab_uint32 nPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetStandbyInBits(m_pHandle, nHalfPeriod, nPulseLength));
	}
	
	/**
	* CRTCContext::SetStandbyInMicroSeconds - Sets laser control pulse interval (in microseconds)
	* @param[in] dHalfPeriod - Half Output period in microseconds
	* @param[in] dPulseLength - Pulse Length in microseconds
	*/
	void CRTCContext::SetStandbyInMicroSeconds(const LibMCDriver_ScanLab_double dHalfPeriod, const LibMCDriver_ScanLab_double dPulseLength)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetStandbyInMicroSeconds(m_pHandle, dHalfPeriod, dPulseLength));
	}
	
	/**
	* CRTCContext::GetSerialNumber - Returns serial number of card
	* @return Returns serial number of board.
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetSerialNumber()
	{
		LibMCDriver_ScanLab_uint32 resultSerialNumber = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetSerialNumber(m_pHandle, &resultSerialNumber));
		
		return resultSerialNumber;
	}
	
	/**
	* CRTCContext::SetStartList - Opens the list to write
	* @param[in] nListIndex - Index of List (1 or 2).
	* @param[in] nPosition - Relative Position in List.
	*/
	void CRTCContext::SetStartList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetStartList(m_pHandle, nListIndex, nPosition));
	}
	
	/**
	* CRTCContext::SetEndOfList - Closes the currently open list
	*/
	void CRTCContext::SetEndOfList()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetEndOfList(m_pHandle));
	}
	
	/**
	* CRTCContext::ExecuteList - Executes the list
	* @param[in] nListIndex - Index of List (1 or 2).
	* @param[in] nPosition - Relative Position in List.
	*/
	void CRTCContext::ExecuteList(const LibMCDriver_ScanLab_uint32 nListIndex, const LibMCDriver_ScanLab_uint32 nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_ExecuteList(m_pHandle, nListIndex, nPosition));
	}
	
	/**
	* CRTCContext::SetAutoChangePos - Sets the AutoChange Position of the currently not running list.
	* @param[in] nPosition - Relative Position in List.
	*/
	void CRTCContext::SetAutoChangePos(const LibMCDriver_ScanLab_uint32 nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetAutoChangePos(m_pHandle, nPosition));
	}
	
	/**
	* CRTCContext::SetDelays - Sets the laser delays (on the list)
	* @param[in] nMarkDelay - Mark delay in microseconds (MUST be multiple of 10)
	* @param[in] nJumpDelay - Jump delay in microseconds (MUST be multiple of 10)
	* @param[in] nPolygonDelay - Polygon delay in microseconds (MUST be multiple of 10)
	*/
	void CRTCContext::SetDelays(const LibMCDriver_ScanLab_uint32 nMarkDelay, const LibMCDriver_ScanLab_uint32 nJumpDelay, const LibMCDriver_ScanLab_uint32 nPolygonDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetDelays(m_pHandle, nMarkDelay, nJumpDelay, nPolygonDelay));
	}
	
	/**
	* CRTCContext::SetLaserDelaysInMicroseconds - Sets the laser delays (on the list)
	* @param[in] dLaserOnDelay - LaserOn delay in microseconds
	* @param[in] dLaserOffDelay - LaserOff delay in microseconds
	*/
	void CRTCContext::SetLaserDelaysInMicroseconds(const LibMCDriver_ScanLab_double dLaserOnDelay, const LibMCDriver_ScanLab_double dLaserOffDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserDelaysInMicroseconds(m_pHandle, dLaserOnDelay, dLaserOffDelay));
	}
	
	/**
	* CRTCContext::SetLaserDelaysInBits - Sets the laser delays (on the list)
	* @param[in] nLaserOnDelay - LaserOn delay in bits (1/64th microseconds)
	* @param[in] nLaserOffDelay - LaserOff delay in bits (1/64th microseconds)
	*/
	void CRTCContext::SetLaserDelaysInBits(const LibMCDriver_ScanLab_uint32 nLaserOnDelay, const LibMCDriver_ScanLab_uint32 nLaserOffDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_SetLaserDelaysInBits(m_pHandle, nLaserOnDelay, nLaserOffDelay));
	}
	
	/**
	* CRTCContext::DrawPolyline - Writes a polyline into the open list
	* @param[in] PointsBuffer - Points of polyline to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Mark speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	*/
	void CRTCContext::DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DrawPolyline(m_pHandle, (LibMCDriver_ScanLab_uint64)PointsBuffer.size(), PointsBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue));
	}
	
	/**
	* CRTCContext::DrawHatches - Writes a list of hatches into the open list
	* @param[in] HatchesBuffer - Hatches to draw.
	* @param[in] fMarkSpeed - Mark speed in mm/s
	* @param[in] fJumpSpeed - Mark speed in mm/s
	* @param[in] fPower - Laser power in percent
	* @param[in] fZValue - Focus Z Value
	*/
	void CRTCContext::DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLab_single fMarkSpeed, const LibMCDriver_ScanLab_single fJumpSpeed, const LibMCDriver_ScanLab_single fPower, const LibMCDriver_ScanLab_single fZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_DrawHatches(m_pHandle, (LibMCDriver_ScanLab_uint64)HatchesBuffer.size(), HatchesBuffer.data(), fMarkSpeed, fJumpSpeed, fPower, fZValue));
	}
	
	/**
	* CRTCContext::AddCustomDelay - Adds a custom delay to the list
	* @param[in] nDelay - Custom delay value in microseconds (MUST be multiple of 10)
	*/
	void CRTCContext::AddCustomDelay(const LibMCDriver_ScanLab_uint32 nDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_AddCustomDelay(m_pHandle, nDelay));
	}
	
	/**
	* CRTCContext::GetCorrectionFactor - Returns correction factor of Card Calibration (in bits per mm)
	* @return CorrectionFactor
	*/
	LibMCDriver_ScanLab_double CRTCContext::GetCorrectionFactor()
	{
		LibMCDriver_ScanLab_double resultCorrectionFactor = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetCorrectionFactor(m_pHandle, &resultCorrectionFactor));
		
		return resultCorrectionFactor;
	}
	
	/**
	* CRTCContext::GetStatus - Returns status of list execution
	* @param[out] bBusy - Execution is busy
	* @param[out] nPosition - Returns current executed position
	*/
	void CRTCContext::GetStatus(bool & bBusy, LibMCDriver_ScanLab_uint32 & nPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetStatus(m_pHandle, &bBusy, &nPosition));
	}
	
	/**
	* CRTCContext::GetHeadStatus - Returns status of scan head
	* @param[in] nHeadNo - Head Number
	* @param[out] bPositionXisOK - Position X is ok
	* @param[out] bPositionYisOK - Position Y is ok
	* @param[out] bTemperatureisOK - Temperature is ok
	* @param[out] bPowerisOK - Power is ok
	*/
	void CRTCContext::GetHeadStatus(const LibMCDriver_ScanLab_uint32 nHeadNo, bool & bPositionXisOK, bool & bPositionYisOK, bool & bTemperatureisOK, bool & bPowerisOK)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetHeadStatus(m_pHandle, nHeadNo, &bPositionXisOK, &bPositionYisOK, &bTemperatureisOK, &bPowerisOK));
	}
	
	/**
	* CRTCContext::GetStateValues - Returns status values of scan head
	* @param[out] bLaserIsOn - Laser is on
	* @param[out] nPositionX - Current Position X in Units
	* @param[out] nPositionY - Current Position Y in Units
	* @param[out] nPositionZ - Current Position Z in Units
	* @param[out] nCorrectedPositionX - Current Position X in Units
	* @param[out] nCorrectedPositionY - Current Position Y in Units
	* @param[out] nCorrectedPositionZ - Current Position Z in Units
	* @param[out] nFocusShift - Current Focus Shift in Units
	* @param[out] nMarkSpeed - Current Mark Speed in Units
	*/
	void CRTCContext::GetStateValues(bool & bLaserIsOn, LibMCDriver_ScanLab_uint32 & nPositionX, LibMCDriver_ScanLab_uint32 & nPositionY, LibMCDriver_ScanLab_uint32 & nPositionZ, LibMCDriver_ScanLab_uint32 & nCorrectedPositionX, LibMCDriver_ScanLab_uint32 & nCorrectedPositionY, LibMCDriver_ScanLab_uint32 & nCorrectedPositionZ, LibMCDriver_ScanLab_uint32 & nFocusShift, LibMCDriver_ScanLab_uint32 & nMarkSpeed)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetStateValues(m_pHandle, &bLaserIsOn, &nPositionX, &nPositionY, &nPositionZ, &nCorrectedPositionX, &nCorrectedPositionY, &nCorrectedPositionZ, &nFocusShift, &nMarkSpeed));
	}
	
	/**
	* CRTCContext::GetInputPointer - returns current input list position
	* @return Returns current position of open list
	*/
	LibMCDriver_ScanLab_uint32 CRTCContext::GetInputPointer()
	{
		LibMCDriver_ScanLab_uint32 resultPosition = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetInputPointer(m_pHandle, &resultPosition));
		
		return resultPosition;
	}
	
	/**
	* CRTCContext::GetRTCVersion - Returns version information of the RTC Card
	* @param[out] nRTCVersion - RTC Card Version
	* @param[out] nRTCType - RTC Card Type
	* @param[out] nDLLVersion - RTC DLL Version
	* @param[out] nHEXVersion - RTC HEX Version
	* @param[out] nBIOSVersion - RTC BIOS Version
	*/
	void CRTCContext::GetRTCVersion(LibMCDriver_ScanLab_uint32 & nRTCVersion, LibMCDriver_ScanLab_uint32 & nRTCType, LibMCDriver_ScanLab_uint32 & nDLLVersion, LibMCDriver_ScanLab_uint32 & nHEXVersion, LibMCDriver_ScanLab_uint32 & nBIOSVersion)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RTCContext_GetRTCVersion(m_pHandle, &nRTCVersion, &nRTCType, &nDLLVersion, &nHEXVersion, &nBIOSVersion));
	}
	
	/**
	 * Method definitions for class CRTCSelector
	 */
	
	/**
	* CRTCSelector::SearchCards - Searches Ethernet Cards
	* @param[in] sIP - IP Network Address.
	* @param[in] sNetmask - IP Netmask Address.
	* @param[in] nTimeout - Time out in microseconds.
	* @return Returns how many ethernet cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::SearchCards(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout)
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_SearchCards(m_pHandle, sIP.c_str(), sNetmask.c_str(), nTimeout, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::SearchCardsByRange - Searches Ethernet Cards
	* @param[in] sStartIP - IP Network Address.
	* @param[in] sEndIP - IP Network Address.
	* @param[in] nTimeout - Time out in microseconds.
	* @return Returns how many ethernet cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::SearchCardsByRange(const std::string & sStartIP, const std::string & sEndIP, const LibMCDriver_ScanLab_uint32 nTimeout)
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_SearchCardsByRange(m_pHandle, sStartIP.c_str(), sEndIP.c_str(), nTimeout, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::GetCardCount - Returns number of detected Cards
	* @return Returns how many cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::GetCardCount()
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_GetCardCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::GetEthernetCardCount - Returns number of found ethernet cards
	* @return Returns how many ethernet cards have been found.
	*/
	LibMCDriver_ScanLab_uint32 CRTCSelector::GetEthernetCardCount()
	{
		LibMCDriver_ScanLab_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_GetEthernetCardCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CRTCSelector::AcquireCard - Acquires a card and returns an RTCContext instance.
	* @param[in] nNumber - Number of Card (1-based). Must be between 1 and CardCount.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireCard(const LibMCDriver_ScanLab_uint32 nNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireCard(m_pHandle, nNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCSelector::AcquireCardBySerial - Acquires a card and returns an RTCContext instance.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireCardBySerial(m_pHandle, nSerialNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCSelector::AcquireEthernetCard - Acquires an ethernet card and returns an RTCContext instance.
	* @param[in] nNumber - Number of Card (1-based). Must be between 1 and EthernetCardCount.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireEthernetCard(const LibMCDriver_ScanLab_uint32 nNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireEthernetCard(m_pHandle, nNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CRTCSelector::AcquireEthernetCardBySerial - Acquires an ethernet card and returns an RTCContext instance.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	* @return New Context# instance
	*/
	PRTCContext CRTCSelector::AcquireEthernetCardBySerial(const LibMCDriver_ScanLab_uint32 nSerialNumber)
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_RTCSelector_AcquireEthernetCardBySerial(m_pHandle, nSerialNumber, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCContext>(m_pWrapper, hInstance);
	}
	
	/**
	 * Method definitions for class CDriver_ScanLab
	 */
	
	/**
	* CDriver_ScanLab::LoadSDK - Initializes the ScanLab SDK.
	* @param[in] sResourceName - Resource name of Scanlab DLL
	*/
	void CDriver_ScanLab::LoadSDK(const std::string & sResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_LoadSDK(m_pHandle, sResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLab::CreateRTCSelector - Creates and initializes a new RTC selector singleton. Should only be called once per Process.
	* @return New Selector instance
	*/
	PRTCSelector CDriver_ScanLab::CreateRTCSelector()
	{
		LibMCDriver_ScanLabHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_CreateRTCSelector(m_pHandle, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRTCSelector>(m_pWrapper, hInstance);
	}
	
	/**
	 * Method definitions for class CDriver_ScanLab_RTC5
	 */
	
	/**
	* CDriver_ScanLab_RTC5::Initialise - Initializes the RTC5 Scanner Driver.
	* @param[in] sIP - IP Network Address. Empty string for local card.
	* @param[in] sNetmask - IP Netmask Address. Empty string for local card.
	* @param[in] nTimeout - Time out in microseconds.
	* @param[in] nSerialNumber - Desired Serial Number of card.
	*/
	void CDriver_ScanLab_RTC5::Initialise(const std::string & sIP, const std::string & sNetmask, const LibMCDriver_ScanLab_uint32 nTimeout, const LibMCDriver_ScanLab_uint32 nSerialNumber)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC5_Initialise(m_pHandle, sIP.c_str(), sNetmask.c_str(), nTimeout, nSerialNumber));
	}
	
	/**
	* CDriver_ScanLab_RTC5::LoadFirmware - Loads the firmware from the driver resources.
	* @param[in] sFirmwareResource - resource name of the firmware program file.
	* @param[in] sFPGAResource - resource name of the firmware FPGA file.
	* @param[in] sAuxiliaryResource - resource name of the binary auxiliary file.
	*/
	void CDriver_ScanLab_RTC5::LoadFirmware(const std::string & sFirmwareResource, const std::string & sFPGAResource, const std::string & sAuxiliaryResource)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC5_LoadFirmware(m_pHandle, sFirmwareResource.c_str(), sFPGAResource.c_str(), sAuxiliaryResource.c_str()));
	}
	
	/**
	* CDriver_ScanLab_RTC5::SetCorrectionFile - Sets the correction file stream.
	* @param[in] CorrectionFileBuffer - binary data of the correction file.
	* @param[in] nTableNumber - Correction table index of card (1..8)
	* @param[in] nDimension - Is it a 2D or 3D correction file.
	* @param[in] nTableNumberHeadA - Table number of Head A.
	* @param[in] nTableNumberHeadB - Table number of Head B.
	*/
	void CDriver_ScanLab_RTC5::SetCorrectionFile(const CInputVector<LibMCDriver_ScanLab_uint8> & CorrectionFileBuffer, const LibMCDriver_ScanLab_uint32 nTableNumber, const LibMCDriver_ScanLab_uint32 nDimension, const LibMCDriver_ScanLab_uint32 nTableNumberHeadA, const LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC5_SetCorrectionFile(m_pHandle, (LibMCDriver_ScanLab_uint64)CorrectionFileBuffer.size(), CorrectionFileBuffer.data(), nTableNumber, nDimension, nTableNumberHeadA, nTableNumberHeadB));
	}
	
	/**
	* CDriver_ScanLab_RTC5::ConfigureLaserMode - Configures the laser mode.
	* @param[in] eLaserMode - Laser Mode Enum
	* @param[in] eLaserPort - Laser Port Enum
	* @param[in] dMaxLaserPower - Maximum laser power.
	* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
	* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
	* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
	* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
	* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
	* @param[in] bOutputSynchronizationActive - Output synchronization active
	*/
	void CDriver_ScanLab_RTC5::ConfigureLaserMode(const eLaserMode eLaserMode, const eLaserPort eLaserPort, const LibMCDriver_ScanLab_double dMaxLaserPower, const bool bFinishLaserPulseAfterOn, const bool bPhaseShiftOfLaserSignal, const bool bLaserOnSignalLowActive, const bool bLaserHalfSignalsLowActive, const bool bSetDigitalInOneHighActive, const bool bOutputSynchronizationActive)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC5_ConfigureLaserMode(m_pHandle, eLaserMode, eLaserPort, dMaxLaserPower, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive));
	}
	
	/**
	* CDriver_ScanLab_RTC5::DrawLayer - Draws a layer of a build stream. Blocks until the layer is drawn.
	* @param[in] sStreamUUID - UUID of the build stream. Must have been loaded in memory by the system.
	* @param[in] nLayerIndex - Layer index of the build file.
	*/
	void CDriver_ScanLab_RTC5::DrawLayer(const std::string & sStreamUUID, const LibMCDriver_ScanLab_uint32 nLayerIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_RTC5_DrawLayer(m_pHandle, sStreamUUID.c_str(), nLayerIndex));
	}

} // namespace LibMCDriver_ScanLab

#endif // __LIBMCDRIVER_SCANLAB_CPPHEADER_DYNAMIC_CPP

