/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver ScanLab RTC

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_SCANLAB_DYNAMICHEADER_CPPTYPES
#define __LIBMCDRIVER_SCANLAB_DYNAMICHEADER_CPPTYPES

#include "libmcdriver_scanlab_types.hpp"

#include "libmcenv_types.hpp"


/*************************************************************************************************************************
 Class definition for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class definition for Driver
**************************************************************************************************************************/

/**
* Configures a driver with its specific configuration data.
*
* @param[in] pDriver - Driver instance.
* @param[in] pConfigurationString - Configuration data of driver.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ConfigurePtr) (LibMCDriver_ScanLab_Driver pDriver, const char * pConfigurationString);

/**
* returns the name identifier of the driver
*
* @param[in] pDriver - Driver instance.
* @param[in] nNameBufferSize - size of the buffer (including trailing 0)
* @param[out] pNameNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pNameBuffer -  buffer of Name of the driver., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_GetNamePtr) (LibMCDriver_ScanLab_Driver pDriver, const LibMCDriver_ScanLab_uint32 nNameBufferSize, LibMCDriver_ScanLab_uint32* pNameNeededChars, char * pNameBuffer);

/**
* returns the type identifier of the driver
*
* @param[in] pDriver - Driver instance.
* @param[in] nTypeBufferSize - size of the buffer (including trailing 0)
* @param[out] pTypeNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pTypeBuffer -  buffer of Type of the driver., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_GetTypePtr) (LibMCDriver_ScanLab_Driver pDriver, const LibMCDriver_ScanLab_uint32 nTypeBufferSize, LibMCDriver_ScanLab_uint32* pTypeNeededChars, char * pTypeBuffer);

/**
* returns the version identifiers of the driver
*
* @param[in] pDriver - Driver instance.
* @param[out] pMajor - Major version.
* @param[out] pMinor - Minor version.
* @param[out] pMicro - Micro version.
* @param[in] nBuildBufferSize - size of the buffer (including trailing 0)
* @param[out] pBuildNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pBuildBuffer -  buffer of Build identifier., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_GetVersionPtr) (LibMCDriver_ScanLab_Driver pDriver, LibMCDriver_ScanLab_uint32 * pMajor, LibMCDriver_ScanLab_uint32 * pMinor, LibMCDriver_ScanLab_uint32 * pMicro, const LibMCDriver_ScanLab_uint32 nBuildBufferSize, LibMCDriver_ScanLab_uint32* pBuildNeededChars, char * pBuildBuffer);

/**
* Updates the driver parameters in the driver environment. Should only be called in the driver thread.
*
* @param[in] pDriver - Driver instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_QueryParametersPtr) (LibMCDriver_ScanLab_Driver pDriver);

/**
* Updates the driver parameters in the driver environment. Might be called out of thread. Implementation MUST be able to handle parallel calls.
*
* @param[in] pDriver - Driver instance.
* @param[in] pDriverUpdateInstance - Status update instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_QueryParametersExPtr) (LibMCDriver_ScanLab_Driver pDriver, LibMCEnv_DriverStatusUpdateSession pDriverUpdateInstance);

/*************************************************************************************************************************
 Class definition for UARTConnection
**************************************************************************************************************************/

/**
* Returns the actual baud rate of the RS232 Interface.
*
* @param[in] pUARTConnection - UARTConnection instance.
* @param[out] pBaudRate - Baud rate.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabUARTConnection_GetBaudRatePtr) (LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint32 * pBaudRate);

/**
* Returns the configured baud rate of the RS232 Interface.
*
* @param[in] pUARTConnection - UARTConnection instance.
* @param[out] pBaudRate - Baud rate.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabUARTConnection_GetConfiguredBaudRatePtr) (LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint32 * pBaudRate);

/**
* Clears the receive buffer.
*
* @param[in] pUARTConnection - UARTConnection instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabUARTConnection_ClearReceiveBufferPtr) (LibMCDriver_ScanLab_UARTConnection pUARTConnection);

/**
* Returns the number of currently received bytes.
*
* @param[in] pUARTConnection - UARTConnection instance.
* @param[out] pByteCount - Number of currently received bytes.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabUARTConnection_AvailableBytesPtr) (LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint32 * pByteCount);

/**
* Sends a string over the interface. The call is blocking.
*
* @param[in] pUARTConnection - UARTConnection instance.
* @param[in] pValue - String to send.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabUARTConnection_WriteStringPtr) (LibMCDriver_ScanLab_UARTConnection pUARTConnection, const char * pValue);

/**
* Sends a data buffer over the interface. The call is blocking.
*
* @param[in] pUARTConnection - UARTConnection instance.
* @param[in] nDataBufferSize - Number of elements in buffer
* @param[in] pDataBuffer - uint8 buffer of Data to send.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabUARTConnection_WriteDataPtr) (LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint64 nDataBufferSize, const LibMCDriver_ScanLab_uint8 * pDataBuffer);

/**
* Blocking call for reading a certain number of bytes. Will remove the bytes from the received buffer. Fails if not enough data is available after the timeout.
*
* @param[in] pUARTConnection - UARTConnection instance.
* @param[in] nByteCount - Number of bytes to read.
* @param[in] nTimeOutInMS - Timeout in Milliseconds.
* @param[in] nDataBufferSize - Number of elements in buffer
* @param[out] pDataNeededCount - will be filled with the count of the written elements, or needed buffer size.
* @param[out] pDataBuffer - uint8  buffer of Receive buffer.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabUARTConnection_ReadDataPtr) (LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint32 nByteCount, LibMCDriver_ScanLab_uint32 nTimeOutInMS, const LibMCDriver_ScanLab_uint64 nDataBufferSize, LibMCDriver_ScanLab_uint64* pDataNeededCount, LibMCDriver_ScanLab_uint8 * pDataBuffer);

/**
* Blocking call for reading until a line end signature is coming. Fails if timeout is hit or number of bytes have been reached.
*
* @param[in] pUARTConnection - UARTConnection instance.
* @param[in] pSeparator - Line Separator to search for.
* @param[in] nMaxLineLength - Maximum line length to receive, excluding line separator.
* @param[in] nTimeOutInMS - Timeout in Milliseconds.
* @param[in] nLineBufferSize - size of the buffer (including trailing 0)
* @param[out] pLineNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pLineBuffer -  buffer of Received line., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabUARTConnection_ReadLinePtr) (LibMCDriver_ScanLab_UARTConnection pUARTConnection, const char * pSeparator, LibMCDriver_ScanLab_uint32 nMaxLineLength, LibMCDriver_ScanLab_uint32 nTimeOutInMS, const LibMCDriver_ScanLab_uint32 nLineBufferSize, LibMCDriver_ScanLab_uint32* pLineNeededChars, char * pLineBuffer);

/*************************************************************************************************************************
 Class definition for RTCJob
**************************************************************************************************************************/

/**
* Writes a polyline into the open list
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] nPointsBufferSize - Number of elements in buffer
* @param[in] pPointsBuffer - Point2D buffer of Points of polyline to draw.
* @param[in] fMarkSpeed - Mark speed in mm/s
* @param[in] fJumpSpeed - Jump speed in mm/s
* @param[in] fPower - Laser power in percent
* @param[in] fZValue - Focus Z Value
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_DrawPolylinePtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_uint64 nPointsBufferSize, const LibMCDriver_ScanLab::sPoint2D * pPointsBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue);

/**
* Writes a polyline into the open list with OIE Enabled.
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] nPointsBufferSize - Number of elements in buffer
* @param[in] pPointsBuffer - Point2D buffer of Points of polyline to draw.
* @param[in] fMarkSpeed - Mark speed in mm/s
* @param[in] fJumpSpeed - Jump speed in mm/s
* @param[in] fPower - Laser power in percent
* @param[in] fZValue - Focus Z Value
* @param[in] nOIEPIDControlIndex - OIE PID Control Index. 0 disables PID Control, MUST be smaller or equal 63.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_DrawPolylineOIEPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_uint64 nPointsBufferSize, const LibMCDriver_ScanLab::sPoint2D * pPointsBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue, LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex);

/**
* Writes a list of hatches into the open list
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] nHatchesBufferSize - Number of elements in buffer
* @param[in] pHatchesBuffer - Hatch2D buffer of Hatches to draw.
* @param[in] fMarkSpeed - Mark speed in mm/s
* @param[in] fJumpSpeed - Jump speed in mm/s
* @param[in] fPower - Laser power in percent
* @param[in] fZValue - Focus Z Value
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_DrawHatchesPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_uint64 nHatchesBufferSize, const LibMCDriver_ScanLab::sHatch2D * pHatchesBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue);

/**
* adds a power change to the open list. MUST NOT be used for PID control.
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] fPowerInPercent - Laser power in percent
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddSetPowerPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_single fPowerInPercent);

/**
* Adds changing an analog port to the open list. Should not interfere with laser power control.
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] eLaserPort - Laser port to set. MUST not be an analog port or the call fails.
* @param[in] fOutputValue - New Normalized output value. Value is clipped between 0 and 1.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddSetAnalogOutPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab::eLaserPort eLaserPort, LibMCDriver_ScanLab_single fOutputValue);

/**
* Adds changing an digital port to the open list. Should not interfere with laser power control.
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] eLaserPort - Laser port to set. MUST not be an digital port or the call fails.
* @param[in] fOutputValue - New Normalized output value. Value is clipped between 0 and 1.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddSetDigitalOutPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab::eLaserPort eLaserPort, LibMCDriver_ScanLab_single fOutputValue);

/**
* adds a base power change to the open list. If using PID control, this base power will be used at starting power when the laser is turned on.
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] fPowerInPercent - Laser power in percent
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddSetPowerForPIDControlPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_single fPowerInPercent);

/**
* adds a jump speed change to the open list
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] fJumpSpeedInMMPerSecond - Jump speed in mm/s
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddSetJumpSpeedPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_single fJumpSpeedInMMPerSecond);

/**
* adds a mark speed change to the open list
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] fMarkSpeedInMMPerSecond - Mark speed in mm/s
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddSetMarkSpeedPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_single fMarkSpeedInMMPerSecond);

/**
* Adds a Jump movement to the open list
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] dTargetX - X Position.
* @param[in] dTargetY - Y Position.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddJumpMovementPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_double dTargetX, LibMCDriver_ScanLab_double dTargetY);

/**
* Adds a Mark movement to the open list
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] dTargetX - X Position.
* @param[in] dTargetY - Y Position.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddMarkMovementPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_double dTargetX, LibMCDriver_ScanLab_double dTargetY);

/**
* Adds a timed Mark movement to the open list
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] dTargetX - X Position.
* @param[in] dTargetY - Y Position.
* @param[in] dDurationInMicroseconds - Duration of mark movement in Microseconds.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddTimedMarkMovementPtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_double dTargetX, LibMCDriver_ScanLab_double dTargetY, LibMCDriver_ScanLab_double dDurationInMicroseconds);

/**
* Adds a free variable set to the open list
*
* @param[in] pRTCJob - RTCJob instance.
* @param[in] nVariableNo - Number of the variable (0-7).
* @param[in] nValue - Value to set.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCJob_AddFreeVariablePtr) (LibMCDriver_ScanLab_RTCJob pRTCJob, LibMCDriver_ScanLab_uint32 nVariableNo, LibMCDriver_ScanLab_uint32 nValue);

/*************************************************************************************************************************
 Class definition for RTCRecording
**************************************************************************************************************************/

/**
* Returns if the scan head connection is checked when recording
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[out] pValue - If true, the Scanhead connection will be checked for an error when recording.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_ScanheadConnectionCheckIsEnabledPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, bool * pValue);

/**
* Enables the Scanhead connection check. The check is enabled by default.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_EnableScanheadConnectionCheckPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording);

/**
* Disables the Scanhead connection check.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_DisableScanheadConnectionCheckPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording);

/**
* Clears all recording data and channels.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_ClearPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording);

/**
* Adds a new channel to record. Fails if more than 8 channels are recorded. Fails if recording has been already started.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] pChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores. MUST be unique.
* @param[in] eChannelType - Channel type enum. MUST NOT be Undefined.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_AddChannelPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, const char * pChannelName, LibMCDriver_ScanLab::eRTCChannelType eChannelType);

/**
* Removes a new channel from the recording and all recorded data of that channel. Does nothing if channel does not exist. 
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] pChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_RemoveChannelPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, const char * pChannelName);

/**
* Returns if a channel name exist.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] pChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
* @param[out] pChannelExists - Returns true if channel exists.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_HasChannelPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, const char * pChannelName, bool * pChannelExists);

/**
* Returns the type of a channel. Returns Undefined if channel does not exist.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] pChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
* @param[out] pChannelType - Channel type enum.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_GetChannelTypePtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, const char * pChannelName, LibMCDriver_ScanLab::eRTCChannelType * pChannelType);

/**
* Returns how many record entries have been recorded.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] pChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
* @param[out] pRecordCount - The number of record entries.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_GetRecordCountPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, const char * pChannelName, LibMCDriver_ScanLab_uint64 * pRecordCount);

/**
* Returns a specific record entry. Fails if Channel does not exist.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] pChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
* @param[in] nRecordIndex - Index of Record entry. MUST be between 0 and RecordCount - 1.
* @param[out] pValue - Value of record entry.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_GetRecordEntryPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, const char * pChannelName, LibMCDriver_ScanLab_uint64 nRecordIndex, LibMCDriver_ScanLab_int32 * pValue);

/**
* Returns all record entries of a channel. Fails if Channel does not exist.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] pChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
* @param[in] nValuesBufferSize - Number of elements in buffer
* @param[out] pValuesNeededCount - will be filled with the count of the written elements, or needed buffer size.
* @param[out] pValuesBuffer - int32  buffer of Array of all record entries.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_GetAllRecordEntriesPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, const char * pChannelName, const LibMCDriver_ScanLab_uint64 nValuesBufferSize, LibMCDriver_ScanLab_uint64* pValuesNeededCount, LibMCDriver_ScanLab_int32 * pValuesBuffer);

/**
* Enables recording of position data of the RTC Card. This is a list command.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] eFrequency - Recording frequency.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_EnableRecordingPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, LibMCDriver_ScanLab::eRTCRecordingFrequency eFrequency);

/**
* Disables recording of position data of the RTC Card. This is a list command.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_DisableRecordingPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording);

/**
* Executes the list with recording the position data from the RTC card. DEPRECIATED!
*
* @param[in] pRTCRecording - RTCRecording instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_ExecuteListWithRecordingPtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording);

/**
* Writes a certain channel to a data table as int32 columns. Fails if Channel does not exist
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] pChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
* @param[in] pDataTable - Data table instance to write to.
* @param[in] pColumnIdentifier - Identifier of the Column.
* @param[in] pColumnDescription - Description of the Column.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_AddRecordsToDataTablePtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, const char * pChannelName, LibMCEnv_DataTable pDataTable, const char * pColumnIdentifier, const char * pColumnDescription);

/**
* Writes a certain channel to a data table as double columns, while linearly transforming the values. The DataTable will be filled with the transform RawValue times ScaleFactor + Offset. Fails if Channel does not exist.
*
* @param[in] pRTCRecording - RTCRecording instance.
* @param[in] pChannelName - Identifier string. MUST be a non-empty alphanumeric string, with optional scores and underscores.
* @param[in] pDataTable - Data table instance to write to.
* @param[in] pColumnIdentifier - Identifier of the Column.
* @param[in] pColumnDescription - Description of the Column.
* @param[in] dScaleFactor - Factor that the raw value is scaled with.
* @param[in] dOffset - Offset that the raw value is scaled with.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCRecording_AddScaledRecordsToDataTablePtr) (LibMCDriver_ScanLab_RTCRecording pRTCRecording, const char * pChannelName, LibMCEnv_DataTable pDataTable, const char * pColumnIdentifier, const char * pColumnDescription, LibMCDriver_ScanLab_double dScaleFactor, LibMCDriver_ScanLab_double dOffset);

/*************************************************************************************************************************
 Class definition for GPIOSequence
**************************************************************************************************************************/

/**
* Returns the identifier of the GPIO Sequence.
*
* @param[in] pGPIOSequence - GPIOSequence instance.
* @param[in] nIdentifierBufferSize - size of the buffer (including trailing 0)
* @param[out] pIdentifierNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pIdentifierBuffer -  buffer of Returns identifier string, may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGPIOSequence_GetIdentifierPtr) (LibMCDriver_ScanLab_GPIOSequence pGPIOSequence, const LibMCDriver_ScanLab_uint32 nIdentifierBufferSize, LibMCDriver_ScanLab_uint32* pIdentifierNeededChars, char * pIdentifierBuffer);

/**
* Clears all sequence steps.
*
* @param[in] pGPIOSequence - GPIOSequence instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGPIOSequence_ClearPtr) (LibMCDriver_ScanLab_GPIOSequence pGPIOSequence);

/**
* Adds the writing of an output pin.
*
* @param[in] pGPIOSequence - GPIOSequence instance.
* @param[in] nOutputBit - RTC Digital Output Bit index. MUST be between 0 and 15.
* @param[in] bOutputValue - If true, bit will be set, if false bit will be cleared.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGPIOSequence_AddOutputPtr) (LibMCDriver_ScanLab_GPIOSequence pGPIOSequence, LibMCDriver_ScanLab_uint32 nOutputBit, bool bOutputValue);

/**
* Adds a delay to the GPIO Sequence.
*
* @param[in] pGPIOSequence - GPIOSequence instance.
* @param[in] nDelayInMilliseconds - Delay in milliseconds.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGPIOSequence_AddDelayPtr) (LibMCDriver_ScanLab_GPIOSequence pGPIOSequence, LibMCDriver_ScanLab_uint32 nDelayInMilliseconds);

/**
* Waits for an input pin to reach a certain value.
*
* @param[in] pGPIOSequence - GPIOSequence instance.
* @param[in] nInputBit - RTC Digital Output Bit index. MUST be between 0 and 15.
* @param[in] bInputValue - If true, the wait is for the bit becoming 1, if false, the wait is for the bit becoming 0.
* @param[in] nMaxDelayInMilliseconds - Sets the maximum time it is allowed to take. Fails, if MaxDelay is 0.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGPIOSequence_WaitforInputPtr) (LibMCDriver_ScanLab_GPIOSequence pGPIOSequence, LibMCDriver_ScanLab_uint32 nInputBit, bool bInputValue, LibMCDriver_ScanLab_uint32 nMaxDelayInMilliseconds);

/**
* Adds a label to the current sequence position.
*
* @param[in] pGPIOSequence - GPIOSequence instance.
* @param[in] pLabelName - Name of the label. Must be unique in the sequence. Only alphanumeric characters and _ and - are allowed. 
* @param[in] nMaxPasses - Maximum number of times this label can be passed. Triggers an error if the label is passed more often.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGPIOSequence_AddLabelPtr) (LibMCDriver_ScanLab_GPIOSequence pGPIOSequence, const char * pLabelName, LibMCDriver_ScanLab_uint32 nMaxPasses);

/**
* Jumps to a label. Fails if label does not exist.
*
* @param[in] pGPIOSequence - GPIOSequence instance.
* @param[in] pLabelName - Name of the label. Must be unique in the sequence. Only alphanumeric characters and _ and - are allowed. 
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGPIOSequence_GoToLabelPtr) (LibMCDriver_ScanLab_GPIOSequence pGPIOSequence, const char * pLabelName);

/**
* Jumps to a label, if a certain input pin is set or cleared. Fails if label does not exist. Does nothing, if the input condition is not fulfilled.
*
* @param[in] pGPIOSequence - GPIOSequence instance.
* @param[in] nInputBit - RTC Digital Output Bit index. MUST be between 0 and 15.
* @param[in] bInputValue - If true, the jump is for the bit becoming 1, if false, the jump is for the bit becoming 0.
* @param[in] pLabelName - Name of the label. Must be unique in the sequence. Only alphanumeric characters and _ and - are allowed. 
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGPIOSequence_ConditionalGoToLabelPtr) (LibMCDriver_ScanLab_GPIOSequence pGPIOSequence, LibMCDriver_ScanLab_uint32 nInputBit, bool bInputValue, const char * pLabelName);

/*************************************************************************************************************************
 Class definition for NLightAFXProfileSelector
**************************************************************************************************************************/

/**
* Sets the control output pin mapping for the nLight AFX Laser. Call will fail if profile selection is enabled.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[in] nEnableDigitalOutputBit - RTC Digital Output Bit index that is connected to the AFX beam selection enable flag (Pro_B7). MUST be between 0 and 15. Default is 0.
* @param[in] nStartDigitalOutputBit - RTC Digital Output Bit index that is connected to the AFX beam selection start flag (Pro_Start). MUST be between 0 and 15. Default is 1
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_SetControlOutputPinsPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 nEnableDigitalOutputBit, LibMCDriver_ScanLab_uint32 nStartDigitalOutputBit);

/**
* Returns the control output pin mapping for the nLight AFX Laser.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[out] pEnableDigitalOutputBit - RTC Digital Output Bit index that is connected to the AFX beam selection enable flag (Pro_B7). MUST be between 0 and 15. Default is 0.
* @param[out] pStartDigitalOutputBit - RTC Digital Output Bit index that is connected to the AFX beam selection start flag (Pro_Start). MUST be between 0 and 15. Default is 1
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_GetControlOutputPinsPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 * pEnableDigitalOutputBit, LibMCDriver_ScanLab_uint32 * pStartDigitalOutputBit);

/**
* Sets the selection output pin mapping for the nLight AFX Laser. Call will fail if profile selection is enabled.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[in] nStartIndexSelection0OutputBit - RTC Digital Output Bit index that is connected to lowest bit of the selection index (Pro_B1). MUST be between 0 and 15. Default is 2.
* @param[in] nStartIndexSelection1OutputBit - RTC Digital Output Bit index that is connected to second lowest bit of the selection index (Pro_B2). MUST be between 0 and 15. Default is 3.
* @param[in] nStartIndexSelection2OutputBit - RTC Digital Output Bit index that is connected to third lowest bit of the selection index (Pro_B3). MUST be between 0 and 15. Default is 4.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_SetSelectionOutputPinsPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 nStartIndexSelection0OutputBit, LibMCDriver_ScanLab_uint32 nStartIndexSelection1OutputBit, LibMCDriver_ScanLab_uint32 nStartIndexSelection2OutputBit);

/**
* Returns the selection output pin mapping for the nLight AFX Laser.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[out] pStartIndexSelection0OutputBit - RTC Digital Output Bit index that is connected to lowest bit of the selection index (Pro_B1). MUST be between 0 and 15. Default is 2.
* @param[out] pStartIndexSelection1OutputBit - RTC Digital Output Bit index that is connected to second lowest bit of the selection index (Pro_B2). MUST be between 0 and 15. Default is 3.
* @param[out] pStartIndexSelection2OutputBit - RTC Digital Output Bit index that is connected to third lowest bit of the selection index (Pro_B3). MUST be between 0 and 15. Default is 4.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_GetSelectionOutputPinsPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 * pStartIndexSelection0OutputBit, LibMCDriver_ScanLab_uint32 * pStartIndexSelection1OutputBit, LibMCDriver_ScanLab_uint32 * pStartIndexSelection2OutputBit);

/**
* Sets the acknowledge pin mapping for the nLight AFX Laser. Call will fail if profile selection is enabled.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[in] nSelectionAcknowledgeInputBit - RTC Digital Input Bit index that is connected to the AFX beam selection ready flag (BPP_RDY). MUST be between 0 and 15. Default is 0.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_SetAcknowledgeInputPinPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 nSelectionAcknowledgeInputBit);

/**
* Returns the acknowledge pin mapping for the nLight AFX Laser.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[out] pSelectionAcknowledgeInputBit - RTC Digital Input Bit index that is connected to the AFX beam selection ready flag (BPP_RDY).
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_GetAcknowledgeInputPinPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 * pSelectionAcknowledgeInputBit);

/**
* Sets the delay that is added for the AFX Mode selection to be transfered. Call will fail if profile selection is enabled.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[in] nSelectionDelayInMilliseconds - Selection Delay in milliseconds. Default is 30.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_SetSelectionDelayPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 nSelectionDelayInMilliseconds);

/**
* Returns the delay that is added for the AFX Mode selection to transfered.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[out] pSelectionDelayInMilliseconds - Selection Delay in milliseconds. Default is 30.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_GetSelectionDelayPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 * pSelectionDelayInMilliseconds);

/**
* Sets the timeout that the AFX Mode selection will wait to be applied. Call will fail if profile selection is enabled.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[in] nAcknowledgeInMilliseconds - Acknowledge Timeout in Milliseconds. Default is 500.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_SetAcknowledgeTimeoutPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 nAcknowledgeInMilliseconds);

/**
* Returns the timeout that the AFX Mode selection will wait to be applied.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[out] pAcknowledgeTimeoutInMilliseconds - Acknowledge Timeout in Milliseconds. Default is 500.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_GetAcknowledgeTimeoutPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 * pAcknowledgeTimeoutInMilliseconds);

/**
* Enables the AFX Mode selection inside the DrawLayer Routine. The Laser Mode will be taken out of the build profile in this case.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_EnableAutomaticSelectionPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector);

/**
* Disables the AFX Mode selection.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_DisableAutomaticSelectionPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector);

/**
* Adds a custom selection cycle to the currenly open list.
*
* @param[in] pNLightAFXProfileSelector - NLightAFXProfileSelector instance.
* @param[in] nAFXModeIndex - AFX Mode index to set. MUST be between 0 and 7.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabNLightAFXProfileSelector_AddCustomSelectionPtr) (LibMCDriver_ScanLab_NLightAFXProfileSelector pNLightAFXProfileSelector, LibMCDriver_ScanLab_uint32 nAFXModeIndex);

/*************************************************************************************************************************
 Class definition for RTCContext
**************************************************************************************************************************/

/**
* Loads card firmware from resource files.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nFirmwareDataBufferSize - Number of elements in buffer
* @param[in] pFirmwareDataBuffer - uint8 buffer of byte array of the firmware program file.
* @param[in] nFPGADataBufferSize - Number of elements in buffer
* @param[in] pFPGADataBuffer - uint8 buffer of byte array of the firmware FPGA file.
* @param[in] nAuxiliaryDataBufferSize - Number of elements in buffer
* @param[in] pAuxiliaryDataBuffer - uint8 buffer of byte array of the binary auxiliary file.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_LoadFirmwarePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nFirmwareDataBufferSize, const LibMCDriver_ScanLab_uint8 * pFirmwareDataBuffer, LibMCDriver_ScanLab_uint64 nFPGADataBufferSize, const LibMCDriver_ScanLab_uint8 * pFPGADataBuffer, LibMCDriver_ScanLab_uint64 nAuxiliaryDataBufferSize, const LibMCDriver_ScanLab_uint8 * pAuxiliaryDataBuffer);

/**
* Loads card calibration file from given resource file.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nCorrectionFileBufferSize - Number of elements in buffer
* @param[in] pCorrectionFileBuffer - uint8 buffer of binary data of the correction file.
* @param[in] nTableNumber - Correction table index of card (1..8)
* @param[in] nDimension - Is it a 2D or 3D correction file.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_LoadCorrectionFilePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nCorrectionFileBufferSize, const LibMCDriver_ScanLab_uint8 * pCorrectionFileBuffer, LibMCDriver_ScanLab_uint32 nTableNumber, LibMCDriver_ScanLab_uint32 nDimension);

/**
* Selects Correction Table on card.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nTableNumberHeadA - Table Number for HeadA (1..8) or off (0).
* @param[in] nTableNumberHeadB - Table Number for HeadA (1..8) or off (0).
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SelectCorrectionTablePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nTableNumberHeadA, LibMCDriver_ScanLab_uint32 nTableNumberHeadB);

/**
* Configures list buffer size.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nSizeListA - Size of List A
* @param[in] nSizeListB - Size of List B
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_ConfigureListsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nSizeListA, LibMCDriver_ScanLab_uint32 nSizeListB);

/**
* Sets laser mode of card.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] eLaserMode - Laser Mode Enum
* @param[in] eLaserPort - Laser Port Enum
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLaserModePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab::eLaserMode eLaserMode, LibMCDriver_ScanLab::eLaserPort eLaserPort);

/**
* Disables automatic laser control.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableAutoLaserControlPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Sets laser control parameters of card.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] bDisableLaser - Laser is disabled
* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
* @param[in] bOutputSynchronizationActive - Output synchronization active
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLaserControlParametersPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool bDisableLaser, bool bFinishLaserPulseAfterOn, bool bPhaseShiftOfLaserSignal, bool bLaserOnSignalLowActive, bool bLaserHalfSignalsLowActive, bool bSetDigitalInOneHighActive, bool bOutputSynchronizationActive);

/**
* Sets laser control pulse interval (in 1/64th microseconds)
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nHalfPeriod - Half Output period in 1/64th microseconds
* @param[in] nPulseLength - Pulse Length in 1/64th microseconds
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInBitsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nHalfPeriod, LibMCDriver_ScanLab_uint32 nPulseLength);

/**
* Sets laser control pulse interval (in microseconds)
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dHalfPeriod - Half Output period in microseconds
* @param[in] dPulseLength - Pulse Length in microseconds
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInMicroSecondsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dHalfPeriod, LibMCDriver_ScanLab_double dPulseLength);

/**
* Sets standby pulse interval (in 1/64th microseconds)
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nHalfPeriod - Half Output period in 1/64th microseconds
* @param[in] nPulseLength - Pulse Length in 1/64th microseconds
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetStandbyInBitsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nHalfPeriod, LibMCDriver_ScanLab_uint32 nPulseLength);

/**
* Sets laser control pulse interval (in microseconds)
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dHalfPeriod - Half Output period in microseconds
* @param[in] dPulseLength - Pulse Length in microseconds
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetStandbyInMicroSecondsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dHalfPeriod, LibMCDriver_ScanLab_double dPulseLength);

/**
* Returns the IP Address of the RTC Card. Fails if driver has not been initialized.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nIPAddressBufferSize - size of the buffer (including trailing 0)
* @param[out] pIPAddressNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pIPAddressBuffer -  buffer of IP Address Value., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetIPAddressPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, const LibMCDriver_ScanLab_uint32 nIPAddressBufferSize, LibMCDriver_ScanLab_uint32* pIPAddressNeededChars, char * pIPAddressBuffer);

/**
* Returns the Netmask of the RTC Card. Fails if driver has not been initialized.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nNetmaskBufferSize - size of the buffer (including trailing 0)
* @param[out] pNetmaskNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pNetmaskBuffer -  buffer of Netmask Value., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetNetmaskPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, const LibMCDriver_ScanLab_uint32 nNetmaskBufferSize, LibMCDriver_ScanLab_uint32* pNetmaskNeededChars, char * pNetmaskBuffer);

/**
* Returns serial number of card
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pSerialNumber - Returns serial number of board.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetSerialNumberPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pSerialNumber);

/**
* Returns the laser index assigned to the card. This is the laser index that will be used to map the toolpath laser data to the according device.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pLaserIndex - Returns laser index of board.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetLaserIndexPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pLaserIndex);

/**
* Sets the laser origin in absolute coordinates. This origin will be used to relatively position lasers to one another.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dOriginX - Sets laser origin X coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
* @param[in] dOriginY - Sets laser origin Y coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLaserOriginPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dOriginX, LibMCDriver_ScanLab_double dOriginY);

/**
* Returns the laser origin in absolute coordinates. This origin will be used to relatively position lasers to one another.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pOriginX - Laser origin X coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
* @param[out] pOriginY - Laser origin Y coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetLaserOriginPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double * pOriginX, LibMCDriver_ScanLab_double * pOriginY);

/**
* Sets the laser field limits in absolute coordinates.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dMinX - Sets minimum laser X coordinate in mm.
* @param[in] dMinY - Sets minimum laser Y coordinate in mm.
* @param[in] dMaxX - Sets maximum laser X coordinate in mm.
* @param[in] dMaxY - Sets maximum laser Y coordinate in mm.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLaserFieldPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dMinX, LibMCDriver_ScanLab_double dMinY, LibMCDriver_ScanLab_double dMaxX, LibMCDriver_ScanLab_double dMaxY);

/**
* Resets the laser field to default values.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_ResetLaserFieldPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Enables range checking of the laser field. A laser field MUST have been set before.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableRangeCheckingPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Disables range checking of the laser field.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableRangeCheckingPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Returns the laser field limits in absolute coordinates.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pMinX - Sets minimum laser X coordinate in mm.
* @param[out] pMinY - Sets minimum laser Y coordinate in mm.
* @param[out] pMaxX - Sets maximum laser X coordinate in mm.
* @param[out] pMaxY - Sets maximum laser Y coordinate in mm.
* @param[out] pHasLaserField - Returns true if a laser field has been set.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetLaserFieldPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double * pMinX, LibMCDriver_ScanLab_double * pMinY, LibMCDriver_ScanLab_double * pMaxX, LibMCDriver_ScanLab_double * pMaxY, bool * pHasLaserField);

/**
* Opens the list to write
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nListIndex - Index of List (1 or 2).
* @param[in] nPosition - Relative Position in List.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetStartListPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nListIndex, LibMCDriver_ScanLab_uint32 nPosition);

/**
* Closes the currently open list
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetEndOfListPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Executes the list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nListIndex - Index of List (1 or 2).
* @param[in] nPosition - Relative Position in List.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_ExecuteListPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nListIndex, LibMCDriver_ScanLab_uint32 nPosition);

/**
* Sets the AutoChange Position of the currently not running list.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nPosition - Relative Position in List.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetAutoChangePosPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nPosition);

/**
* Sets the laser delays
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nMarkDelay - Mark delay in microseconds (MUST be multiple of 10)
* @param[in] nJumpDelay - Jump delay in microseconds (MUST be multiple of 10)
* @param[in] nPolygonDelay - Polygon delay in microseconds (MUST be multiple of 10)
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetDelaysPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nMarkDelay, LibMCDriver_ScanLab_uint32 nJumpDelay, LibMCDriver_ScanLab_uint32 nPolygonDelay);

/**
* Sets the laser delays (on the list)
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dLaserOnDelay - LaserOn delay in microseconds
* @param[in] dLaserOffDelay - LaserOff delay in microseconds
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInMicrosecondsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dLaserOnDelay, LibMCDriver_ScanLab_double dLaserOffDelay);

/**
* Sets the laser delays (on the list)
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nLaserOnDelay - LaserOn delay in bits (1/64th microseconds)
* @param[in] nLaserOffDelay - LaserOff delay in bits (1/64th microseconds)
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInBitsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nLaserOnDelay, LibMCDriver_ScanLab_int32 nLaserOffDelay);

/**
* Writes a polyline into the open list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nPointsBufferSize - Number of elements in buffer
* @param[in] pPointsBuffer - Point2D buffer of Points of polyline to draw.
* @param[in] fMarkSpeed - Mark speed in mm/s
* @param[in] fJumpSpeed - Jump speed in mm/s
* @param[in] fPower - Laser power in percent
* @param[in] fZValue - Focus Z Value
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DrawPolylinePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nPointsBufferSize, const LibMCDriver_ScanLab::sPoint2D * pPointsBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue);

/**
* Writes a polyline into the open list with OIE Enabled.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nPointsBufferSize - Number of elements in buffer
* @param[in] pPointsBuffer - Point2D buffer of Points of polyline to draw.
* @param[in] fMarkSpeed - Mark speed in mm/s
* @param[in] fJumpSpeed - Jump speed in mm/s
* @param[in] fPower - Laser power in percent
* @param[in] fZValue - Focus Z Value
* @param[in] nOIEPIDControlIndex - OIE PID Control Index. 0 disables PID Control, MUST be smaller or equal 63.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DrawPolylineOIEPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nPointsBufferSize, const LibMCDriver_ScanLab::sPoint2D * pPointsBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue, LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex);

/**
* Writes a list of hatches into the open list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nHatchesBufferSize - Number of elements in buffer
* @param[in] pHatchesBuffer - Hatch2D buffer of Hatches to draw.
* @param[in] fMarkSpeed - Mark speed in mm/s
* @param[in] fJumpSpeed - Jump speed in mm/s
* @param[in] fPower - Laser power in percent
* @param[in] fZValue - Focus Z Value
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DrawHatchesPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nHatchesBufferSize, const LibMCDriver_ScanLab::sHatch2D * pHatchesBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue);

/**
* adds a power change to the open list. MUST NOT be used for PID control.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] fPowerInPercent - Laser power in percent
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddSetPowerPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_single fPowerInPercent);

/**
* Adds changing an analog port to the open list. Should not interfere with laser power control.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] eLaserPort - Laser port to set. MUST not be an analog port or the call fails.
* @param[in] fOutputValue - New Normalized output value. Value is clipped between 0 and 1.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddSetAnalogOutPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab::eLaserPort eLaserPort, LibMCDriver_ScanLab_single fOutputValue);

/**
* Adds changing an digital port to the open list. Should not interfere with laser power control.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] eLaserPort - Laser port to set. MUST not be an digital port or the call fails.
* @param[in] fOutputValue - New Normalized output value. Value is clipped between 0 and 1.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddSetDigitalOutPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab::eLaserPort eLaserPort, LibMCDriver_ScanLab_single fOutputValue);

/**
* adds a base power change to the open list. If using PID control, this base power will be used at starting power when the laser is turned on.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] fPowerInPercent - Laser power in percent
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddSetPowerForPIDControlPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_single fPowerInPercent);

/**
* adds a jump speed change to the open list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] fJumpSpeedInMMPerSecond - Jump speed in mm/s
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddSetJumpSpeedPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_single fJumpSpeedInMMPerSecond);

/**
* adds a mark speed change to the open list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] fMarkSpeedInMMPerSecond - Mark speed in mm/s
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddSetMarkSpeedPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_single fMarkSpeedInMMPerSecond);

/**
* Adds a Jump movement to the open list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dTargetX - X Position.
* @param[in] dTargetY - Y Position.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddJumpMovementPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTargetX, LibMCDriver_ScanLab_double dTargetY);

/**
* Adds a Mark movement to the open list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dTargetX - X Position.
* @param[in] dTargetY - Y Position.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddMarkMovementPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTargetX, LibMCDriver_ScanLab_double dTargetY);

/**
* Adds a timed Mark movement to the open list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dTargetX - X Position.
* @param[in] dTargetY - Y Position.
* @param[in] dDurationInMicroseconds - Duration of mark movement in Microseconds.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddTimedMarkMovementPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTargetX, LibMCDriver_ScanLab_double dTargetY, LibMCDriver_ScanLab_double dDurationInMicroseconds);

/**
* Adds a free variable set to the open list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nVariableNo - Number of the variable (0-7).
* @param[in] nValue - Value to set.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddFreeVariablePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nVariableNo, LibMCDriver_ScanLab_uint32 nValue);

/**
* Returns the currently set free variable.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nVariableNo - Number of the variable (0-7).
* @param[out] pValue - Value to return.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetCurrentFreeVariablePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nVariableNo, LibMCDriver_ScanLab_uint32 * pValue);

/**
* Returns the current RTC time stamp.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pTimeStamp - TimeStamp Value.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetTimeStampPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pTimeStamp);

/**
* Returns an RTC Channel in real time. The signal register is instantly read and directly passed back to the caller.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] eChannelType - Internal RTC Channel type. See SCANLAB RTC Documentation for set_trigger for a proper explanation.
* @param[out] pValue - Internal Value of that signal.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetRTCChannelPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab::eRTCChannelType eChannelType, LibMCDriver_ScanLab_int32 * pValue);

/**
* Returns an internal RTC value by RTC Signal ID. The signal register is instantly read and directly passed back to the caller.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nInternalSignalID - Internal RTC Signal ID. See SCANLAB RTC Documentation for set_trigger for a proper explanation. Some values are mapped from the enum definition of RTCChannelType.
* @param[out] pValue - Internal Value of that signal.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetRTCInternalValuePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nInternalSignalID, LibMCDriver_ScanLab_int32 * pValue);

/**
* Stops the execution of the current list immediately.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_StopExecutionPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Writes a list of hatches into the open list with OIE Enabled.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nHatchesBufferSize - Number of elements in buffer
* @param[in] pHatchesBuffer - Hatch2D buffer of Hatches to draw.
* @param[in] fMarkSpeed - Mark speed in mm/s
* @param[in] fJumpSpeed - Jump speed in mm/s
* @param[in] fPower - Laser power in percent
* @param[in] fZValue - Focus Z Value
* @param[in] nOIEPIDControlIndex - OIE PID Control Index. 0 disables PID Control, MUST be smaller or equal 63.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DrawHatchesOIEPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nHatchesBufferSize, const LibMCDriver_ScanLab::sHatch2D * pHatchesBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue, LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex);

/**
* Adds a layer instance to the current open list.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] pLayer - Instance of the layer to add to the lists.
* @param[in] bFailIfNonAssignedDataExists - If true, fails if there is a laser index that does not match.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddLayerToListPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCEnv_ToolpathLayer pLayer, bool bFailIfNonAssignedDataExists);

/**
* Adds a command to wait for the encoder for reaching an X axis position. Fails if Mark on the Fly is not enabled.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dPositionInMM - Position Value to reach in mm.
* @param[in] bInPositiveHalfPlane - If true, waits for the encoder reaching a value that is larger than PositionInMM. If false, waits for the encoder reaching a value that is smaller than PositionInMM.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_WaitForEncoderXPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dPositionInMM, bool bInPositiveHalfPlane);

/**
* Adds a command to wait for the encoder for reaching an Y axis position. Fails if Mark on the Fly is not enabled.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dPositionInMM - Position Value to reach in mm.
* @param[in] bInPositiveHalfPlane - If true, waits for the encoder reaching a value that is larger than PositionInMM. If false, waits for the encoder reaching a value that is smaller than PositionInMM.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_WaitForEncoderYPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dPositionInMM, bool bInPositiveHalfPlane);

/**
* Adds a command to wait for the encoder for reaching an X axis position. Fails if Mark on the Fly is not enabled.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nPositionInSteps - Position Value to reach in steps.
* @param[in] bInPositiveHalfPlane - If true, waits for the encoder reaching a value that is larger than PositionInMM. If false, waits for the encoder reaching a value that is smaller than PositionInMM.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_WaitForEncoderXStepsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nPositionInSteps, bool bInPositiveHalfPlane);

/**
* Adds a command to wait for the encoder for reaching an Y axis position. Fails if Mark on the Fly is not enabled.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nPositionInSteps - Position Value to reach in steps.
* @param[in] bInPositiveHalfPlane - If true, waits for the encoder reaching a value that is larger than PositionInMM. If false, waits for the encoder reaching a value that is smaller than PositionInMM.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_WaitForEncoderYStepsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nPositionInSteps, bool bInPositiveHalfPlane);

/**
* Adds a custom delay to the list
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nDelayInMicroseconds - Custom delay value in microseconds (MUST be multiple of 10)
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddCustomDelayPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nDelayInMicroseconds);

/**
* Returns correction factor of Card Calibration (in bits per mm)
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pCorrectionFactor - CorrectionFactor
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetCorrectionFactorPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double * pCorrectionFactor);

/**
* Returns status of list execution
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pBusy - Execution is busy
* @param[out] pPosition - Returns current executed position
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetStatusPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pBusy, LibMCDriver_ScanLab_uint32 * pPosition);

/**
* Returns status of scan head
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nHeadNo - Head Number
* @param[out] pPositionXisOK - Position X is ok
* @param[out] pPositionYisOK - Position Y is ok
* @param[out] pTemperatureisOK - Temperature is ok
* @param[out] pPowerisOK - Power is ok
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetHeadStatusPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nHeadNo, bool * pPositionXisOK, bool * pPositionYisOK, bool * pTemperatureisOK, bool * pPowerisOK);

/**
* Returns status values of scan head
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pLaserIsOn - Laser is on
* @param[out] pPositionX - Current Position X in Units
* @param[out] pPositionY - Current Position Y in Units
* @param[out] pPositionZ - Current Position Z in Units
* @param[out] pCorrectedPositionX - Current Position X in Units
* @param[out] pCorrectedPositionY - Current Position Y in Units
* @param[out] pCorrectedPositionZ - Current Position Z in Units
* @param[out] pFocusShift - Current Focus Shift in Units
* @param[out] pMarkSpeed - Current Mark Speed in Units
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetStateValuesPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pLaserIsOn, LibMCDriver_ScanLab_int32 * pPositionX, LibMCDriver_ScanLab_int32 * pPositionY, LibMCDriver_ScanLab_int32 * pPositionZ, LibMCDriver_ScanLab_int32 * pCorrectedPositionX, LibMCDriver_ScanLab_int32 * pCorrectedPositionY, LibMCDriver_ScanLab_int32 * pCorrectedPositionZ, LibMCDriver_ScanLab_int32 * pFocusShift, LibMCDriver_ScanLab_int32 * pMarkSpeed);

/**
* returns current input list position
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pPosition - Returns current position of open list
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetInputPointerPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pPosition);

/**
* Returns version information of the RTC Card
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pRTCVersion - RTC Card Version
* @param[out] pRTCType - RTC Card Type
* @param[out] pDLLVersion - RTC DLL Version
* @param[out] pHEXVersion - RTC HEX Version
* @param[out] pBIOSVersion - RTC BIOS Version
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetRTCVersionPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pRTCVersion, LibMCDriver_ScanLab_uint32 * pRTCType, LibMCDriver_ScanLab_uint32 * pDLLVersion, LibMCDriver_ScanLab_uint32 * pHEXVersion, LibMCDriver_ScanLab_uint32 * pBIOSVersion);

/**
* Set RTC Ethernet communication timeouts for a specific connection. The Driver defaults will not be changed.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dInitialTimeout - Initial timeout in ms
* @param[in] dMaxTimeout - Max timeout in ms
* @param[in] dMultiplier - Multiplier
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetCommunicationTimeoutsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dInitialTimeout, LibMCDriver_ScanLab_double dMaxTimeout, LibMCDriver_ScanLab_double dMultiplier);

/**
* Get RTC Ethernet communication timeouts
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pInitialTimeout - Initial timeout in ms
* @param[out] pMaxTimeout - Max timeout in ms
* @param[out] pMultiplier - Multiplier
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetCommunicationTimeoutsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double * pInitialTimeout, LibMCDriver_ScanLab_double * pMaxTimeout, LibMCDriver_ScanLab_double * pMultiplier);

/**
* Initializes the RTC card for the open interface extension. MUST be called before the OIE is initialized.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nSignalChannelsBufferSize - Number of elements in buffer
* @param[in] pSignalChannelsBuffer - uint32 buffer of Array of signal channels. MUST NOT be empty
* @param[in] eOperationMode - OIE Operation Mode
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_InitializeForOIEPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nSignalChannelsBufferSize, const LibMCDriver_ScanLab_uint32 * pSignalChannelsBuffer, LibMCDriver_ScanLab::eOIEOperationMode eOperationMode);

/**
* Sets the laser pin outputs to a certain state. Control command, has immediate effect.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] bLaserOut1 - Value for Laser Out Pin 1
* @param[in] bLaserOut2 - Value for Laser Out Pin 2
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLaserPinOutPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool bLaserOut1, bool bLaserOut2);

/**
* Read the laser pin input values. Control command, has immediate effect.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pLaserOut1 - Value for Laser In Pin 1
* @param[out] pLaserOut2 - Value for Laser In Pin 2
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetLaserPinInPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pLaserOut1, bool * pLaserOut2);

/**
* Adds the laser pin command to the current open list.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] bLaserOut1 - Value for Laser Out Pin 1
* @param[in] bLaserOut2 - Value for Laser Out Pin 2
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddLaserPinOutToListPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool bLaserOut1, bool bLaserOut2);

/**
* Adds the change of all 16 digital IO Ports to the current open list.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nDigitalOutput - Value for the digital IO. MUST be between 0 and 65535.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddWriteDigitalIOListPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nDigitalOutput);

/**
* Adds the change a subset of 16 digital IO Ports to the current open list.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nDigitalOutput - Value for the digital IO. MUST be between 0 and 65535.
* @param[in] nOutputMask - Mask of the digital IO. Only the bits with value 1 are changed in the output state. MUST be between 0 and 65535.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddWriteMaskedDigitalIOListPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nDigitalOutput, LibMCDriver_ScanLab_uint32 nOutputMask);

/**
* Writes an OIE enabling command block to the open list.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableOIEPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Writes an OIE disabling command block to the open list.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableOIEPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Creates an nLight AFX Beam Selector instance. If called multiple times, the same instance will be returned.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pInstance - nLight Profile selector instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_CreateNLightAFXBeamProfileSelectorPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_NLightAFXProfileSelector * pInstance);

/**
* Adds a GPIO Sequence. Fails if Sequence with the same identifier already exists.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] pIdentifier - Identifier for the sequence.
* @param[out] pInstance - GPIOSequence instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_AddGPIOSequencePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, const char * pIdentifier, LibMCDriver_ScanLab_GPIOSequence * pInstance);

/**
* Finds a GPIO Sequence. 
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] pIdentifier - Identifier for the sequence.
* @param[in] bMustExist - If true, the call fails if Sequence with the identifier does not exist.
* @param[out] pInstance - GPIOSequence instance. Returns null, if MustExist is fales and a sequence with the identifier does not exist.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_FindGPIOSequencePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, const char * pIdentifier, bool bMustExist, LibMCDriver_ScanLab_GPIOSequence * pInstance);

/**
* Deletes a GPIO Sequence. Does nothing if Sequence with the identifier does not exists.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] pIdentifier - Identifier for the sequence.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DeleteGPIOSequencePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, const char * pIdentifier);

/**
* Writes an OIE measurement start command block to the open list. Same as StartOIEMeasurement with false as parameter.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Writes an OIE measurement start command block to the open list, with parameterized LaserOn Trigger
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] bLaserOnTrigger - If true, only triggers a measurement, when the laser is on.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementExPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool bLaserOnTrigger);

/**
* Writes an OIE measurement start command block to the open list.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_StopOIEMeasurementPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Sets OIE PID Index.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nOIEPIDIndex - OIE PID Index. MUST be between 0 and 63. 0 means PID disabled.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetOIEPIDModePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nOIEPIDIndex);

/**
* Enables OIE PID Control. Affects only subsequent layers that are drawn into lists.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableOIEPIDControlPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Disables OIE PID Control.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableOIEPIDControlPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Clears all stored OIE Measurement tags of the context. New Tag Indices will start from 0 again.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_ClearOIEMeasurementTagsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Enables OIE Measurement tagging.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableOIEMeasurementTaggingPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Disables OIE Measurement tagging.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableOIEMeasurementTaggingPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Returns the current maximum measurement tag that has been sent to the OIE.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pMeasurementTag - Measurement Tag that has been sent to the OIE.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetOIEMaxMeasurementTagPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pMeasurementTag);

/**
* Maps an OIE Measurement tag back to the original scan parameters.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nMeasurementTag - Measurement Tag that has been sent to the OIE.
* @param[out] pPartID - ID of the part.
* @param[out] pProfileID - ID of the profile.
* @param[out] pSegmentID - ID of the segment.
* @param[out] pVectorID - ID of the vector.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_MapOIEMeasurementTagPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nMeasurementTag, LibMCDriver_ScanLab_uint32 * pPartID, LibMCDriver_ScanLab_uint32 * pProfileID, LibMCDriver_ScanLab_uint32 * pSegmentID, LibMCDriver_ScanLab_uint32 * pVectorID);

/**
* Disable skywriting.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableSkyWritingPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Enables skywriting on the list in mode 1. See Scanlab RTC Documentation for details.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dTimelag - Skywriting Timelag
* @param[in] nLaserOnShift - Skywriting Laser On Shift
* @param[in] nNPrev - Duration of pre-motion in ticks
* @param[in] nNPost - Duration of post-motion in ticks. 
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode1Ptr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTimelag, LibMCDriver_ScanLab_int64 nLaserOnShift, LibMCDriver_ScanLab_int64 nNPrev, LibMCDriver_ScanLab_int64 nNPost);

/**
* Enables skywriting on the list in mode 2. See Scanlab RTC Documentation for details.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dTimelag - Skywriting Timelag
* @param[in] nLaserOnShift - Skywriting Laser On Shift
* @param[in] nNPrev - Duration of pre-motion in ticks
* @param[in] nNPost - Duration of post-motion in ticks. 
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode2Ptr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTimelag, LibMCDriver_ScanLab_int64 nLaserOnShift, LibMCDriver_ScanLab_int64 nNPrev, LibMCDriver_ScanLab_int64 nNPost);

/**
* Enables skywriting on the list in mode 3. See Scanlab RTC Documentation for details.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dTimelag - Skywriting Timelag
* @param[in] nLaserOnShift - Skywriting Laser On Shift
* @param[in] nNPrev - Duration of pre-motion in ticks
* @param[in] nNPost - Duration of post-motion in ticks. 
* @param[in] dLimit - Skywriting Angle limit
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode3Ptr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTimelag, LibMCDriver_ScanLab_int64 nLaserOnShift, LibMCDriver_ScanLab_int64 nNPrev, LibMCDriver_ScanLab_int64 nNPost, LibMCDriver_ScanLab_double dLimit);

/**
* Enables skywriting on the list in mode 4. See Scanlab RTC Documentation for details.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dTimelag - Skywriting Timelag
* @param[in] nLaserOnShift - Skywriting Laser On Shift
* @param[in] nNPrev - Duration of pre-motion in ticks
* @param[in] nNPost - Duration of post-motion in ticks. 
* @param[in] dLimit - Skywriting Angle limit
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode4Ptr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTimelag, LibMCDriver_ScanLab_int64 nLaserOnShift, LibMCDriver_ScanLab_int64 nNPrev, LibMCDriver_ScanLab_int64 nNPost, LibMCDriver_ScanLab_double dLimit);

/**
* Sets the transformation angle of the scan field.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dAngleInDegrees - Angle in Degrees
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetTransformationAnglePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dAngleInDegrees);

/**
* Sets the transformation scale of the scan field.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dScaleFactor - Scale Factor (1.0 is no scaling). Allowed value is -16 to 16.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetTransformationScalePtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dScaleFactor);

/**
* Sets the transformation offset of the scan field.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nOffsetX - Offset in X (in bits)
* @param[in] nOffsetY - Offset in X (in bits)
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetTransformationOffsetPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nOffsetX, LibMCDriver_ScanLab_int32 nOffsetY);

/**
* Sets the transformation matrix of the scan field.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dM11 - Upper left field of the transformation matrix
* @param[in] dM12 - Upper right field of the transformation matrix
* @param[in] dM21 - Lower left field of the transformation matrix
* @param[in] dM22 - Lower right field of the transformation matrix
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetTransformationMatrixPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dM11, LibMCDriver_ScanLab_double dM12, LibMCDriver_ScanLab_double dM21, LibMCDriver_ScanLab_double dM22);

/**
* Prepares recording of position data of the RTC Card. This needs to be called before any list is started.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] bKeepInMemory - If true, the recording will be persisted in the driver and can be recovered by its UUID. If false, the lifetime of the recording data ends with the release of the recording instance. Persistent Recordings will eat up a lot of memory and should be taken under careful consideration. Recordings can be made non-persistent with the RemoveFromMemory function of the instance.
* @param[out] pRecordingInstance - Recording instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_PrepareRecordingPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool bKeepInMemory, LibMCDriver_ScanLab_RTCRecording * pRecordingInstance);

/**
* Checks if a recording exists in the driver memory. Recording MUST have been created with KeepInMemory set to true.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] pUUID - UUID of the recording to find.
* @param[out] pRecordingExists - Returns if the recording exists.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_HasRecordingPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, const char * pUUID, bool * pRecordingExists);

/**
* Find a recording in the driver memory. Recording MUST have been created with KeepInMemory set to true. Fails if recording does not exist.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] pUUID - UUID of the recording to find.
* @param[out] pRecordingInstance - Recording instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_FindRecordingPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, const char * pUUID, LibMCDriver_ScanLab_RTCRecording * pRecordingInstance);

/**
* Enables timelag compensation.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nTimeLagXYInMicroseconds - Time lag of XY axes (in microseconds). MUST be a multiple of 10.
* @param[in] nTimeLagZInMicroseconds - Time lag of Z axis (in microseconds). MUST be a multiple of 10.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableTimelagCompensationPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds);

/**
* Disables timelag compensation.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableTimelagCompensationPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Enables mark on the fly 2D. This is a list command.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dScaleXInMMperEncoderStep - Scale factor X in mm per encoder step
* @param[in] dScaleYInMMperEncoderStep - Scale factor Y in mm per encoder step
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableMarkOnTheFly2DPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dScaleXInMMperEncoderStep, LibMCDriver_ScanLab_double dScaleYInMMperEncoderStep);

/**
* Disable mark on the fly 2D. This is a list command.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableMarkOnTheFly2DPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Returns if mark on the fly 2D has been enabled.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pIsEnabled - Returns true if mark on the fly 2D is enabled.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_MarkOnTheFly2DIsEnabledPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pIsEnabled);

/**
* Returns 2D mark on the fly position.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pPositionX - Mark on the fly position X
* @param[out] pPositionY - Mark on the fly position Y
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_Get2DMarkOnTheFlyPositionPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 * pPositionX, LibMCDriver_ScanLab_int32 * pPositionY);

/**
* Checks mark on the fly error.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] bFailIfError - If true, the call will fail in case of an error.
* @param[out] pErrorCode - Bitfield corresponding to the get_marking_info call, as described in the RTC SDK Documentation.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_CheckOnTheFlyErrorPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool bFailIfError, LibMCDriver_ScanLab_uint32 * pErrorCode);

/**
* Returns if the laser power calibration table is non-empty.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pCalibrationEnabled - Laser Calibration Is Enabled
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_LaserPowerCalibrationIsEnabledPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pCalibrationEnabled);

/**
* Returns if the laser power calibration table has one entry.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pCalibrationIsLinear - Laser Calibration Is Affine Linear
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_LaserPowerCalibrationIsLinearPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pCalibrationIsLinear);

/**
* Clears the laser power calibration table.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_ClearLaserPowerCalibrationPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Returns the laser power calibration table. Fails if laser calibration is not enabled.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nCalibrationPointsBufferSize - Number of elements in buffer
* @param[out] pCalibrationPointsNeededCount - will be filled with the count of the written elements, or needed buffer size.
* @param[out] pCalibrationPointsBuffer - LaserCalibrationPoint  buffer of Laser Calibration Points
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_GetLaserPowerCalibrationPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, const LibMCDriver_ScanLab_uint64 nCalibrationPointsBufferSize, LibMCDriver_ScanLab_uint64* pCalibrationPointsNeededCount, LibMCDriver_ScanLab::sLaserCalibrationPoint * pCalibrationPointsBuffer);

/**
* Enables the laser power calibration with an affine linear tranformation.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dPowerOffsetInPercent - Additional offset of the Power value.
* @param[in] dPowerOutputScaling - Scaling factor of the laser output.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetLinearLaserPowerCalibrationPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dPowerOffsetInPercent, LibMCDriver_ScanLab_double dPowerOutputScaling);

/**
* Enables the laser power calibration with multiple calibration point values. Table MUST NOT have negative power entries. Laser Power Output will be linear scaled with the given values within their respective intervals. Any laser power outside of the minimum or maximum Power values will be scaled according to the respective minimum or maximum scaling value.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nCalibrationPointsBufferSize - Number of elements in buffer
* @param[in] pCalibrationPointsBuffer - LaserCalibrationPoint buffer of Laser Calibration Points. Array will be sorted by Laser Power Keys. Array MUST NOT be empty. Array MUST NOT have duplicate entries (to an accuracy of 0.01 Percent).
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetPiecewiseLinearLaserPowerCalibrationPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nCalibrationPointsBufferSize, const LibMCDriver_ScanLab::sLaserCalibrationPoint * pCalibrationPointsBuffer);

/**
* Enables a spatial laser power modulation via callback.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] pModulationCallback - Callback to call for modulating the laser power.
* @param[in] pUserData - Userdata that is passed to the callback function
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableSpatialLaserPowerModulationPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab::SpatialPowerModulationCallback pModulationCallback, LibMCDriver_ScanLab_pvoid pUserData);

/**
* Disables all power modulation functions.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisablePowerModulationPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* If this function is enabled, all mark lines will be subdivided so that the maximum length is small than the threshold.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dLengthThreshold - Length threshold in mm.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableLineSubdivisionPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dLengthThreshold);

/**
* Disables the subdivision of mark lines.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableLineSubdivisionPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Reads a multi MCBSP register from the RTC Card. Should be used only for debugging purposes.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nRegisterNo - Number of the register to read.
* @param[out] pRegisterContent - Value of the register.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_ReadMultiMCBSPPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nRegisterNo, LibMCDriver_ScanLab_int32 * pRegisterContent);

/**
* Creates a new UART Connection. Closes any other one that might be active.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nDesiredBaudRate - Desired baud rate. 160 Bd…12.8 MBd.  The other RS-232 interface parameters cannot be altered (data bits: 8, start bits: 1, stop bits: 1, parity: none).
* @param[out] pConnection - UART Connection instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_CreateUARTConnectionPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nDesiredBaudRate, LibMCDriver_ScanLab_UARTConnection * pConnection);

/**
* Enables the Scanahead mode of the RTC card.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nHeadNo - Head Number
* @param[in] nTableNo - Table Number
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_EnableScanAheadPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nHeadNo, LibMCDriver_ScanLab_uint32 nTableNo);

/**
* Disables the Scanahead mode of the RTC card.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DisableScanAheadPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Activates the ScanAhead Auto Delays.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_ActivateScanAheadAutoDelaysPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Deactivates the ScanAhead Auto Delays.
*
* @param[in] pRTCContext - RTCContext instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_DeactivateScanAheadAutoDelaysPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext);

/**
* Returns if ScanAhead Auto Delays are activated.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[out] pActivated - Returns true if Auto Delays are activated.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_ScanAheadAutoDelaysAreActivatedPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pActivated);

/**
* Enables the Scanahead mode of the RTC card.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] dLaserOnShiftInMicroSeconds - Laser on shift in Microseconds. Will be rounded to 64th microseconds.
* @param[in] dLaserOffShiftInMicroSeconds - Laser off shift in Microseconds. Will be rounded to 64th microseconds.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetScanAheadLaserShiftsInMicrosecondsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dLaserOnShiftInMicroSeconds, LibMCDriver_ScanLab_double dLaserOffShiftInMicroSeconds);

/**
* Enables the Scanahead mode of the RTC card.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nLaserOnShift - Laser on shift in Units, which are 1/64th of a Microsecond.
* @param[in] nLaserOffShift - Laser on shift in Units, which are 1/64th of a Microsecond.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetScanAheadLaserShiftsInUnitsPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nLaserOnShift, LibMCDriver_ScanLab_int32 nLaserOffShift);

/**
* Controls the Scanahead Line parameters.
*
* @param[in] pRTCContext - RTCContext instance.
* @param[in] nCornerScale - Corner sharpness scale in Percent.. 100 percent means sharp corners. Values above 100 will be clipped to 100.
* @param[in] nEndScale - Line end sharpness scale in Percent.. 100 percent means straight line ends. Values above 100 will be clipped to 100.
* @param[in] nAccelerationScale - Fraction of active laser time (not path lenght) during acceleration in Percent.. 100 percent means sharp corners. Values above 100 will be clipped to 100.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCContext_SetScanAheadLineParametersPtr) (LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nCornerScale, LibMCDriver_ScanLab_uint32 nEndScale, LibMCDriver_ScanLab_uint32 nAccelerationScale);

/*************************************************************************************************************************
 Class definition for RTCSelector
**************************************************************************************************************************/

/**
* Searches Ethernet Cards
*
* @param[in] pRTCSelector - RTCSelector instance.
* @param[in] pIP - IP Network Address.
* @param[in] pNetmask - IP Netmask Address.
* @param[in] nTimeout - Time out in microseconds.
* @param[out] pCount - Returns how many ethernet cards have been found.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCSelector_SearchCardsPtr) (LibMCDriver_ScanLab_RTCSelector pRTCSelector, const char * pIP, const char * pNetmask, LibMCDriver_ScanLab_uint32 nTimeout, LibMCDriver_ScanLab_uint32 * pCount);

/**
* Searches Ethernet Cards
*
* @param[in] pRTCSelector - RTCSelector instance.
* @param[in] pStartIP - IP Network Address.
* @param[in] pEndIP - IP Network Address.
* @param[in] nTimeout - Time out in microseconds.
* @param[out] pCount - Returns how many ethernet cards have been found.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCSelector_SearchCardsByRangePtr) (LibMCDriver_ScanLab_RTCSelector pRTCSelector, const char * pStartIP, const char * pEndIP, LibMCDriver_ScanLab_uint32 nTimeout, LibMCDriver_ScanLab_uint32 * pCount);

/**
* Returns number of detected Cards
*
* @param[in] pRTCSelector - RTCSelector instance.
* @param[out] pCount - Returns how many cards have been found.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCSelector_GetCardCountPtr) (LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 * pCount);

/**
* Returns number of found ethernet cards
*
* @param[in] pRTCSelector - RTCSelector instance.
* @param[out] pCount - Returns how many ethernet cards have been found.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCSelector_GetEthernetCardCountPtr) (LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 * pCount);

/**
* Acquires a card and returns an RTCContext instance.
*
* @param[in] pRTCSelector - RTCSelector instance.
* @param[in] nNumber - Number of Card (1-based). Must be between 1 and CardCount.
* @param[out] pInstance - New Context# instance
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCSelector_AcquireCardPtr) (LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 nNumber, LibMCDriver_ScanLab_RTCContext * pInstance);

/**
* Acquires a card and returns an RTCContext instance.
*
* @param[in] pRTCSelector - RTCSelector instance.
* @param[in] nSerialNumber - Desired Serial Number of card.
* @param[out] pInstance - New Context# instance
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCSelector_AcquireCardBySerialPtr) (LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 nSerialNumber, LibMCDriver_ScanLab_RTCContext * pInstance);

/**
* Acquires an ethernet card and returns an RTCContext instance.
*
* @param[in] pRTCSelector - RTCSelector instance.
* @param[in] nNumber - Number of Card (1-based). Must be between 1 and EthernetCardCount.
* @param[out] pInstance - New Context# instance
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardPtr) (LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 nNumber, LibMCDriver_ScanLab_RTCContext * pInstance);

/**
* Acquires an ethernet card and returns an RTCContext instance.
*
* @param[in] pRTCSelector - RTCSelector instance.
* @param[in] nSerialNumber - Desired Serial Number of card.
* @param[out] pInstance - New Context# instance
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardBySerialPtr) (LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 nSerialNumber, LibMCDriver_ScanLab_RTCContext * pInstance);

/*************************************************************************************************************************
 Class definition for Driver_ScanLab
**************************************************************************************************************************/

/**
* Initializes the ScanLab SDK.
*
* @param[in] pDriver_ScanLab - Driver_ScanLab instance.
* @param[in] pResourceName - Resource name of Scanlab DLL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_LoadSDKPtr) (LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab, const char * pResourceName);

/**
* Initializes the ScanLab SDK from an external source.
*
* @param[in] pDriver_ScanLab - Driver_ScanLab instance.
* @param[in] nScanlabDLLBufferSize - Number of elements in buffer
* @param[in] pScanlabDLLBuffer - uint8 buffer of Byte array of Scanlab DLL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_LoadCustomSDKPtr) (LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab, LibMCDriver_ScanLab_uint64 nScanlabDLLBufferSize, const LibMCDriver_ScanLab_uint8 * pScanlabDLLBuffer);

/**
* Creates and initializes a new RTC selector singleton. Should only be called once per Process.
*
* @param[in] pDriver_ScanLab - Driver_ScanLab instance.
* @param[out] pInstance - New Selector instance
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_CreateRTCSelectorPtr) (LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab, LibMCDriver_ScanLab_RTCSelector * pInstance);

/**
* Enables journaling of the SDK. MUST be called before LoadSDK or LoadCustomSDK.
*
* @param[in] pDriver_ScanLab - Driver_ScanLab instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_EnableJournalingPtr) (LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab);

/**
* Sets the default firmware from the driver resources. If given, Initialise will upload this firmware before acquiring the RTC card.
*
* @param[in] pDriver_ScanLab - Driver_ScanLab instance.
* @param[in] pFirmwareResource - resource name of the firmware program file.
* @param[in] pFPGAResource - resource name of the firmware FPGA file.
* @param[in] pAuxiliaryResource - resource name of the binary auxiliary file.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_SetFirmwarePtr) (LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab, const char * pFirmwareResource, const char * pFPGAResource, const char * pAuxiliaryResource);

/**
* Sets the default firmware from a binary array. If given, Initialise will upload this firmware before acquiring the RTC card.
*
* @param[in] pDriver_ScanLab - Driver_ScanLab instance.
* @param[in] nFirmwareDataBufferSize - Number of elements in buffer
* @param[in] pFirmwareDataBuffer - uint8 buffer of byte array of the firmware program file.
* @param[in] nFPGADataBufferSize - Number of elements in buffer
* @param[in] pFPGADataBuffer - uint8 buffer of byte array of the firmware FPGA file.
* @param[in] nAuxiliaryDataBufferSize - Number of elements in buffer
* @param[in] pAuxiliaryDataBuffer - uint8 buffer of byte array of the binary auxiliary file.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_SetCustomFirmwarePtr) (LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab, LibMCDriver_ScanLab_uint64 nFirmwareDataBufferSize, const LibMCDriver_ScanLab_uint8 * pFirmwareDataBuffer, LibMCDriver_ScanLab_uint64 nFPGADataBufferSize, const LibMCDriver_ScanLab_uint8 * pFPGADataBuffer, LibMCDriver_ScanLab_uint64 nAuxiliaryDataBufferSize, const LibMCDriver_ScanLab_uint8 * pAuxiliaryDataBuffer);

/*************************************************************************************************************************
 Class definition for Driver_ScanLab_RTC6
**************************************************************************************************************************/

/**
* Turns the driver into a simulation mode.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetToSimulationModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6);

/**
* Returns if the driver is in simulation mode.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[out] pSimulationModeEnabled - Flag if driver is in simulation mode.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsSimulationModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, bool * pSimulationModeEnabled);

/**
* Returns if the driver is initalized.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[out] pIsInitialized - Flag if driver is initialized.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsInitializedPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, bool * pIsInitialized);

/**
* Manually initializes the RTC6 Scanner Driver.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] pIP - IP Network Address. Empty string for local card.
* @param[in] pNetmask - IP Netmask Address. Empty string for local card.
* @param[in] nTimeout - Time out in microseconds.
* @param[in] nSerialNumber - Desired Serial Number of card.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialisePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pIP, const char * pNetmask, LibMCDriver_ScanLab_uint32 nTimeout, LibMCDriver_ScanLab_uint32 nSerialNumber);

/**
* Initializes the RTC6 Scanner Driver from a configuration preset. Calls Initialise, LoadFirmware, SetCorrectionFile, ConfigureLaserMode and ConfigureDelays.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] pPresetName - Name of the configuration preset.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialiseFromConfigurationPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pPresetName);

/**
* Set RTC Ethernet communication timeouts. The given values will be defaults for all subsequent connections.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] dInitialTimeout - Initial timeout in ms
* @param[in] dMaxTimeout - Max timeout in ms
* @param[in] dMultiplier - Multiplier
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCommunicationTimeoutsPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_double dInitialTimeout, LibMCDriver_ScanLab_double dMaxTimeout, LibMCDriver_ScanLab_double dMultiplier);

/**
* Returns the IP Address of the RTC Card. Fails if driver has not been initialized.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] nIPAddressBufferSize - size of the buffer (including trailing 0)
* @param[out] pIPAddressNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pIPAddressBuffer -  buffer of IP Address Value., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetIPAddressPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const LibMCDriver_ScanLab_uint32 nIPAddressBufferSize, LibMCDriver_ScanLab_uint32* pIPAddressNeededChars, char * pIPAddressBuffer);

/**
* Returns the Netmask of the RTC Card. Fails if driver has not been initialized.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] nNetmaskBufferSize - size of the buffer (including trailing 0)
* @param[out] pNetmaskNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pNetmaskBuffer -  buffer of Netmask Value., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetNetmaskPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const LibMCDriver_ScanLab_uint32 nNetmaskBufferSize, LibMCDriver_ScanLab_uint32* pNetmaskNeededChars, char * pNetmaskBuffer);

/**
* Returns the Serial Number of the RTC Card. Fails if driver has not been initialized.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[out] pSerialNumber - Serial Number of card.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSerialNumberPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_uint32 * pSerialNumber);

/**
* Returns the RTC Context Instance. Fails if it card has not been initialised.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[out] pContextInstance - RTC Context Instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetContextPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_RTCContext * pContextInstance);

/**
* Returns the RTC Selector Instance. Fails if it card has not been initialised.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[out] pSelectorInstance - RTC Selector Instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSelectorPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_RTCSelector * pSelectorInstance);

/**
* Loads the firmware from the driver resources. DEPRECIATED. Use SetFirmare before calling Initialise..
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] pFirmwareResource - resource name of the firmware program file.
* @param[in] pFPGAResource - resource name of the firmware FPGA file.
* @param[in] pAuxiliaryResource - resource name of the binary auxiliary file.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadFirmwarePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pFirmwareResource, const char * pFPGAResource, const char * pAuxiliaryResource);

/**
* Loads the firmware from custom resources. DEPRECIATED. Use SetCustomFirmare before calling Initialise..
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] nFirmwareDataBufferSize - Number of elements in buffer
* @param[in] pFirmwareDataBuffer - uint8 buffer of byte array of the firmware program file.
* @param[in] nFPGADataBufferSize - Number of elements in buffer
* @param[in] pFPGADataBuffer - uint8 buffer of byte array of the firmware FPGA file.
* @param[in] nAuxiliaryDataBufferSize - Number of elements in buffer
* @param[in] pAuxiliaryDataBuffer - uint8 buffer of byte array of the binary auxiliary file.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadCustomFirmwarePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_uint64 nFirmwareDataBufferSize, const LibMCDriver_ScanLab_uint8 * pFirmwareDataBuffer, LibMCDriver_ScanLab_uint64 nFPGADataBufferSize, const LibMCDriver_ScanLab_uint8 * pFPGADataBuffer, LibMCDriver_ScanLab_uint64 nAuxiliaryDataBufferSize, const LibMCDriver_ScanLab_uint8 * pAuxiliaryDataBuffer);

/**
* Sets the correction file stream.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] nCorrectionFileBufferSize - Number of elements in buffer
* @param[in] pCorrectionFileBuffer - uint8 buffer of binary data of the correction file.
* @param[in] nTableNumber - Correction table index of card (1..8)
* @param[in] nDimension - Is it a 2D or 3D correction file.
* @param[in] nTableNumberHeadA - Table number of Head A.
* @param[in] nTableNumberHeadB - Table number of Head B.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCorrectionFilePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_uint64 nCorrectionFileBufferSize, const LibMCDriver_ScanLab_uint8 * pCorrectionFileBuffer, LibMCDriver_ScanLab_uint32 nTableNumber, LibMCDriver_ScanLab_uint32 nDimension, LibMCDriver_ScanLab_uint32 nTableNumberHeadA, LibMCDriver_ScanLab_uint32 nTableNumberHeadB);

/**
* Configures the laser mode. MUST be called before any exposure.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] eLaserMode - Laser Mode Enum
* @param[in] eLaserPort - Laser Port Enum
* @param[in] dMaxLaserPower - Maximum laser power.
* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
* @param[in] bOutputSynchronizationActive - Output synchronization active
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureLaserModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab::eLaserMode eLaserMode, LibMCDriver_ScanLab::eLaserPort eLaserPort, LibMCDriver_ScanLab_double dMaxLaserPower, bool bFinishLaserPulseAfterOn, bool bPhaseShiftOfLaserSignal, bool bLaserOnSignalLowActive, bool bLaserHalfSignalsLowActive, bool bSetDigitalInOneHighActive, bool bOutputSynchronizationActive);

/**
* Configures the default laser and scanner delays. ATTENTION: Will create and overwrite execution list 1!
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] dLaserOnDelay - Laser On Delay in Microseconds
* @param[in] dLaserOffDelay - Laser Off Delay in Microseconds
* @param[in] dMarkDelay - Mark delay in microseconds (will be rounded to a multiple of 10)
* @param[in] dJumpDelay - Jump delay in microseconds (will be rounded to a multiple of 10)
* @param[in] dPolygonDelay - Polygon delay in microseconds (will be rounded to a multiple of 10)
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureDelaysPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_double dLaserOnDelay, LibMCDriver_ScanLab_double dLaserOffDelay, LibMCDriver_ScanLab_double dMarkDelay, LibMCDriver_ScanLab_double dJumpDelay, LibMCDriver_ScanLab_double dPolygonDelay);

/**
* Sets the recording mode for using the Open Interface extension. Will be taken into account by DrawLayer. Default is No Recording.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] eRecordingMode - Recording mode enum
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetOIERecordingModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab::eOIERecordingMode eRecordingMode);

/**
* Returns the recording mode for using the Open Interface extension, taking into account by DrawLayer. Default is No Recording.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[out] pRecordingMode - Recording mode enum
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetOIERecordingModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab::eOIERecordingMode * pRecordingMode);

/**
* Enables filtering of the segments by segment attributes. A segment will only be drawn if the given integer attribute has the given value.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] pNameSpace - Namespace of Attribute to filter for.
* @param[in] pAttributeName - Name of Attribute to filter for.
* @param[in] nAttributeValue - Attribute Value to filter for.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_EnableAttributeFilterPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pNameSpace, const char * pAttributeName, LibMCDriver_ScanLab_int64 nAttributeValue);

/**
* Disables filtering of the segments by segment attributes.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DisableAttributeFilterPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6);

/**
* Draws a layer of a build stream. Blocks until the layer is drawn.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] pStreamUUID - UUID of the build stream. Must have been loaded in memory by the system.
* @param[in] nLayerIndex - Layer index of the build file.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DrawLayerPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pStreamUUID, LibMCDriver_ScanLab_uint32 nLayerIndex);

/**
* Returns the current RTC Ethernet communication timeouts. Fails, if no RTC card has been acquired yet.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[out] pInitialTimeout - Initial timeout in ms
* @param[out] pMaxTimeout - Max timeout in ms
* @param[out] pMultiplier - Multiplier
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetCommunicationTimeoutsPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_double * pInitialTimeout, LibMCDriver_ScanLab_double * pMaxTimeout, LibMCDriver_ScanLab_double * pMultiplier);

/**
* Returns the RTC Ethernet communication timeouts that will be used for a subsequent connection.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[out] pInitialTimeout - Initial timeout in ms
* @param[out] pMaxTimeout - Max timeout in ms
* @param[out] pMultiplier - Multiplier
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetDefaultCommunicationTimeoutsPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_double * pInitialTimeout, LibMCDriver_ScanLab_double * pMaxTimeout, LibMCDriver_ScanLab_double * pMultiplier);

/**
* Enables timelag compensation.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @param[in] nTimeLagXYInMicroseconds - Time lag of XY axes (in microseconds). MUST be a multiple of 10.
* @param[in] nTimeLagZInMicroseconds - Time lag of Z axis (in microseconds). MUST be a multiple of 10.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_EnableTimelagCompensationPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds);

/**
* Disables timelag compensation.
*
* @param[in] pDriver_ScanLab_RTC6 - Driver_ScanLab_RTC6 instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DisableTimelagCompensationPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6);

/*************************************************************************************************************************
 Class definition for Driver_ScanLab_RTC6xN
**************************************************************************************************************************/

/**
* Turns the driver into a simulation mode.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetToSimulationModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN);

/**
* Returns if the driver is in simulation mode.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[out] pSimulationModeEnabled - Flag if driver is in simulation mode.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_IsSimulationModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, bool * pSimulationModeEnabled);

/**
* Returns if all the scanners of the driver are initalized.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[out] pIsInitialized - Flag if driver is initialized.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_IsInitializedPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, bool * pIsInitialized);

/**
* Returns if a specific scanners of the driver are initalized.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[out] pIsInitialized - Flag if scanner is initialized.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ScannerIsInitializedPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, bool * pIsInitialized);

/**
* Returns if number of scanners.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[out] pNumberOfScanners - Number of scanners supported by this driver.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetScannerCountPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 * pNumberOfScanners);

/**
* Initializes one of the RTC6 Scanner Drivers.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] pIP - IP Network Address. Empty string for local card.
* @param[in] pNetmask - IP Netmask Address. Empty string for local card.
* @param[in] nTimeout - Time out in microseconds.
* @param[in] nSerialNumber - Desired Serial Number of card.
* @param[in] nLaserIndex - Associated Laser Index from the toolpath data. 1-based, MUST NOT be 0. Each Scanner MUST own a unique laser index.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_InitialiseScannerPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const char * pIP, const char * pNetmask, LibMCDriver_ScanLab_uint32 nTimeout, LibMCDriver_ScanLab_uint32 nSerialNumber, LibMCDriver_ScanLab_uint32 nLaserIndex);

/**
* Initializes the RTC6 Scanner Driver from a configuration preset. Calls Initialise, LoadFirmware, SetCorrectionFile, ConfigureLaserMode and ConfigureDelays.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] pPresetName - Name of the configuration preset.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_InitialiseScannerFromConfigurationPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const char * pPresetName);

/**
* Returns the IP Address of the RTC Card. Fails if driver has not been initialized.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] nIPAddressBufferSize - size of the buffer (including trailing 0)
* @param[out] pIPAddressNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pIPAddressBuffer -  buffer of IP Address Value., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetIPAddressPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_uint32 nIPAddressBufferSize, LibMCDriver_ScanLab_uint32* pIPAddressNeededChars, char * pIPAddressBuffer);

/**
* Returns the Netmask of the RTC Card. Fails if driver has not been initialized.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] nNetmaskBufferSize - size of the buffer (including trailing 0)
* @param[out] pNetmaskNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pNetmaskBuffer -  buffer of Netmask Value., may be NULL
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetNetmaskPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_uint32 nNetmaskBufferSize, LibMCDriver_ScanLab_uint32* pNetmaskNeededChars, char * pNetmaskBuffer);

/**
* Returns the Serial Number of the RTC Card. Fails if driver has not been initialized.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[out] pSerialNumber - Serial Number of card.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetSerialNumberPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint32 * pSerialNumber);

/**
* Returns associated Laser Index from the toolpath data.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[out] pLaserIndex - Associated Laser Index from the toolpath data.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetLaserIndexPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint32 * pLaserIndex);

/**
* Returns the RTC Selector Instance. Fails if it card has not been initialised.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[out] pSelectorInstance - RTC Selector Instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetSelectorPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_RTCSelector * pSelectorInstance);

/**
* Returns the RTC Context Instance. Fails if it card has not been initialised.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[out] pContextInstance - RTC Context Instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetContextPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_RTCContext * pContextInstance);

/**
* Loads the firmware from the driver resources and for a specific scanner. DEPRECIATED. Use SetFirmare before calling Initialise..
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] pFirmwareResource - resource name of the firmware program file.
* @param[in] pFPGAResource - resource name of the firmware FPGA file.
* @param[in] pAuxiliaryResource - resource name of the binary auxiliary file.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_LoadFirmwarePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const char * pFirmwareResource, const char * pFPGAResource, const char * pAuxiliaryResource);

/**
* Loads the firmware from custom resources and for a specific scanner. DEPRECIATED. Use SetCustomFirmare before calling Initialise..
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] nFirmwareDataBufferSize - Number of elements in buffer
* @param[in] pFirmwareDataBuffer - uint8 buffer of byte array of the firmware program file.
* @param[in] nFPGADataBufferSize - Number of elements in buffer
* @param[in] pFPGADataBuffer - uint8 buffer of byte array of the firmware FPGA file.
* @param[in] nAuxiliaryDataBufferSize - Number of elements in buffer
* @param[in] pAuxiliaryDataBuffer - uint8 buffer of byte array of the binary auxiliary file.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_LoadCustomFirmwarePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint64 nFirmwareDataBufferSize, const LibMCDriver_ScanLab_uint8 * pFirmwareDataBuffer, LibMCDriver_ScanLab_uint64 nFPGADataBufferSize, const LibMCDriver_ScanLab_uint8 * pFPGADataBuffer, LibMCDriver_ScanLab_uint64 nAuxiliaryDataBufferSize, const LibMCDriver_ScanLab_uint8 * pAuxiliaryDataBuffer);

/**
* Sets the correction file stream.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] nCorrectionFileBufferSize - Number of elements in buffer
* @param[in] pCorrectionFileBuffer - uint8 buffer of binary data of the correction file.
* @param[in] nTableNumber - Correction table index of card (1..8)
* @param[in] nDimension - Is it a 2D or 3D correction file.
* @param[in] nTableNumberHeadA - Table number of Head A.
* @param[in] nTableNumberHeadB - Table number of Head B.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetCorrectionFilePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint64 nCorrectionFileBufferSize, const LibMCDriver_ScanLab_uint8 * pCorrectionFileBuffer, LibMCDriver_ScanLab_uint32 nTableNumber, LibMCDriver_ScanLab_uint32 nDimension, LibMCDriver_ScanLab_uint32 nTableNumberHeadA, LibMCDriver_ScanLab_uint32 nTableNumberHeadB);

/**
* Configures the laser mode.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] eLaserMode - Laser Mode Enum
* @param[in] eLaserPort - Laser Port Enum
* @param[in] dMaxLaserPower - Maximum laser power.
* @param[in] bFinishLaserPulseAfterOn - Finish laser pulse after LaserOn
* @param[in] bPhaseShiftOfLaserSignal - 180 degree phase shift of Laser signal
* @param[in] bLaserOnSignalLowActive - Set Laser On Signal Low Active
* @param[in] bLaserHalfSignalsLowActive - Set Laser Half Signal Low Active
* @param[in] bSetDigitalInOneHighActive - Set Digital In 1 high Active
* @param[in] bOutputSynchronizationActive - Output synchronization active
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ConfigureLaserModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab::eLaserMode eLaserMode, LibMCDriver_ScanLab::eLaserPort eLaserPort, LibMCDriver_ScanLab_double dMaxLaserPower, bool bFinishLaserPulseAfterOn, bool bPhaseShiftOfLaserSignal, bool bLaserOnSignalLowActive, bool bLaserHalfSignalsLowActive, bool bSetDigitalInOneHighActive, bool bOutputSynchronizationActive);

/**
* Configures the default laser and scanner delays. ATTENTION: Will create and overwrite execution list 1!
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] dLaserOnDelay - Laser On Delay in Microseconds
* @param[in] dLaserOffDelay - Laser Off Delay in Microseconds
* @param[in] dMarkDelay - Mark delay in microseconds (will be rounded to a multiple of 10)
* @param[in] dJumpDelay - Jump delay in microseconds (will be rounded to a multiple of 10)
* @param[in] dPolygonDelay - Polygon delay in microseconds (will be rounded to a multiple of 10)
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ConfigureDelaysPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_double dLaserOnDelay, LibMCDriver_ScanLab_double dLaserOffDelay, LibMCDriver_ScanLab_double dMarkDelay, LibMCDriver_ScanLab_double dJumpDelay, LibMCDriver_ScanLab_double dPolygonDelay);

/**
* Sets the recording mode for using the Open Interface extension. Will be taken into account by DrawLayer. Default is No Recording.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] eRecordingMode - Recording mode enum
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetOIERecordingModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab::eOIERecordingMode eRecordingMode);

/**
* Returns the recording mode for using the Open Interface extension, taking into account by DrawLayer. Default is No Recording.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[out] pRecordingMode - Recording mode enum
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetOIERecordingModePtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab::eOIERecordingMode * pRecordingMode);

/**
* Enables filtering of the segments by segment attributes. A segment will only be drawn if the given integer attribute has the given value.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] pNameSpace - Namespace of Attribute to filter for.
* @param[in] pAttributeName - Name of Attribute to filter for.
* @param[in] nAttributeValue - Attribute Value to filter for.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_EnableAttributeFilterPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, const char * pNameSpace, const char * pAttributeName, LibMCDriver_ScanLab_int64 nAttributeValue);

/**
* Disables filtering of the segments by segment attributes.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DisableAttributeFilterPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN);

/**
* Draws a layer of a build stream on List 1. Blocks until the layer is drawn. Laser Indices are automatically assigned. Will fail if 
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] pStreamUUID - UUID of the build stream. Must have been loaded in memory by the system.
* @param[in] nLayerIndex - Layer index of the build file.
* @param[in] bFailIfNonAssignedDataExists - If true, the call will fail in case a layer contains data that is not assigned to any defined scanner card.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DrawLayerPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, const char * pStreamUUID, LibMCDriver_ScanLab_uint32 nLayerIndex, bool bFailIfNonAssignedDataExists);

/**
* Set RTC Ethernet communication timeouts for all existing and future connections.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] dInitialTimeout - Initial timeout in ms
* @param[in] dMaxTimeout - Max timeout in ms
* @param[in] dMultiplier - Multiplier
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetAllCommunicationTimeoutsPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_double dInitialTimeout, LibMCDriver_ScanLab_double dMaxTimeout, LibMCDriver_ScanLab_double dMultiplier);

/**
* Set RTC Ethernet communication timeouts for a specific scanner. The given values will be defaults for all subsequent connections.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] dInitialTimeout - Initial timeout in ms
* @param[in] dMaxTimeout - Max timeout in ms
* @param[in] dMultiplier - Multiplier
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetCommunicationTimeoutsPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_double dInitialTimeout, LibMCDriver_ScanLab_double dMaxTimeout, LibMCDriver_ScanLab_double dMultiplier);

/**
* Get RTC Ethernet communication timeouts. Fails if the RTC Card is not connected.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[out] pInitialTimeout - Initial timeout in ms
* @param[out] pMaxTimeout - Max timeout in ms
* @param[out] pMultiplier - Multiplier
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetCommunicationTimeoutsPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_double * pInitialTimeout, LibMCDriver_ScanLab_double * pMaxTimeout, LibMCDriver_ScanLab_double * pMultiplier);

/**
* Returns the RTC Ethernet communication timeouts that will be used for any subsequent connection.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[out] pInitialTimeout - Initial timeout in ms
* @param[out] pMaxTimeout - Max timeout in ms
* @param[out] pMultiplier - Multiplier
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetDefaultCommunicationTimeoutsPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_double * pInitialTimeout, LibMCDriver_ScanLab_double * pMaxTimeout, LibMCDriver_ScanLab_double * pMultiplier);

/**
* Enables timelag compensation.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @param[in] nTimeLagXYInMicroseconds - Time lag of XY axes (in microseconds). MUST be a multiple of 10.
* @param[in] nTimeLagZInMicroseconds - Time lag of Z axis (in microseconds). MUST be a multiple of 10.
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_EnableTimelagCompensationPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds);

/**
* Disables timelag compensation.
*
* @param[in] pDriver_ScanLab_RTC6xN - Driver_ScanLab_RTC6xN instance.
* @param[in] nScannerIndex - Index of the scanner (0-based). MUST be smaller than ScannerCount
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DisableTimelagCompensationPtr) (LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex);

/*************************************************************************************************************************
 Global functions
**************************************************************************************************************************/

/**
* retrieves the binary version of this library.
*
* @param[out] pMajor - returns the major version of this library
* @param[out] pMinor - returns the minor version of this library
* @param[out] pMicro - returns the micro version of this library
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGetVersionPtr) (LibMCDriver_ScanLab_uint32 * pMajor, LibMCDriver_ScanLab_uint32 * pMinor, LibMCDriver_ScanLab_uint32 * pMicro);

/**
* Returns the last error recorded on this object
*
* @param[in] pInstance - Instance Handle
* @param[in] nErrorMessageBufferSize - size of the buffer (including trailing 0)
* @param[out] pErrorMessageNeededChars - will be filled with the count of the written bytes, or needed buffer size.
* @param[out] pErrorMessageBuffer -  buffer of Message of the last error, may be NULL
* @param[out] pHasError - Is there a last error to query
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGetLastErrorPtr) (LibMCDriver_ScanLab_Base pInstance, const LibMCDriver_ScanLab_uint32 nErrorMessageBufferSize, LibMCDriver_ScanLab_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError);

/**
* Releases shared ownership of an Instance
*
* @param[in] pInstance - Instance Handle
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabReleaseInstancePtr) (LibMCDriver_ScanLab_Base pInstance);

/**
* Acquires shared ownership of an Instance
*
* @param[in] pInstance - Instance Handle
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabAcquireInstancePtr) (LibMCDriver_ScanLab_Base pInstance);

/**
* Injects an imported component for usage within this component
*
* @param[in] pNameSpace - NameSpace of the injected component
* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabInjectComponentPtr) (const char * pNameSpace, LibMCDriver_ScanLab_pvoid pSymbolAddressMethod);

/**
* Returns the address of the SymbolLookupMethod
*
* @param[out] pSymbolLookupMethod - Address of the SymbolAddressMethod
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabGetSymbolLookupMethodPtr) (LibMCDriver_ScanLab_pvoid * pSymbolLookupMethod);

/**
* Creates a driver instance with a specific name.
*
* @param[in] pName - Name of driver to be created.
* @param[in] pType - Type of driver to be created.
* @param[in] pDriverEnvironment - Environment of this driver.
* @param[out] pInstance - New Driver instance
* @return error code or 0 (success)
*/
typedef LibMCDriver_ScanLabResult (*PLibMCDriver_ScanLabCreateDriverPtr) (const char * pName, const char * pType, LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCDriver_ScanLab_Driver * pInstance);

/*************************************************************************************************************************
 Function Table Structure
**************************************************************************************************************************/

typedef struct {
	void * m_LibraryHandle;
	PLibMCDriver_ScanLabDriver_ConfigurePtr m_Driver_Configure;
	PLibMCDriver_ScanLabDriver_GetNamePtr m_Driver_GetName;
	PLibMCDriver_ScanLabDriver_GetTypePtr m_Driver_GetType;
	PLibMCDriver_ScanLabDriver_GetVersionPtr m_Driver_GetVersion;
	PLibMCDriver_ScanLabDriver_QueryParametersPtr m_Driver_QueryParameters;
	PLibMCDriver_ScanLabDriver_QueryParametersExPtr m_Driver_QueryParametersEx;
	PLibMCDriver_ScanLabUARTConnection_GetBaudRatePtr m_UARTConnection_GetBaudRate;
	PLibMCDriver_ScanLabUARTConnection_GetConfiguredBaudRatePtr m_UARTConnection_GetConfiguredBaudRate;
	PLibMCDriver_ScanLabUARTConnection_ClearReceiveBufferPtr m_UARTConnection_ClearReceiveBuffer;
	PLibMCDriver_ScanLabUARTConnection_AvailableBytesPtr m_UARTConnection_AvailableBytes;
	PLibMCDriver_ScanLabUARTConnection_WriteStringPtr m_UARTConnection_WriteString;
	PLibMCDriver_ScanLabUARTConnection_WriteDataPtr m_UARTConnection_WriteData;
	PLibMCDriver_ScanLabUARTConnection_ReadDataPtr m_UARTConnection_ReadData;
	PLibMCDriver_ScanLabUARTConnection_ReadLinePtr m_UARTConnection_ReadLine;
	PLibMCDriver_ScanLabRTCJob_DrawPolylinePtr m_RTCJob_DrawPolyline;
	PLibMCDriver_ScanLabRTCJob_DrawPolylineOIEPtr m_RTCJob_DrawPolylineOIE;
	PLibMCDriver_ScanLabRTCJob_DrawHatchesPtr m_RTCJob_DrawHatches;
	PLibMCDriver_ScanLabRTCJob_AddSetPowerPtr m_RTCJob_AddSetPower;
	PLibMCDriver_ScanLabRTCJob_AddSetAnalogOutPtr m_RTCJob_AddSetAnalogOut;
	PLibMCDriver_ScanLabRTCJob_AddSetDigitalOutPtr m_RTCJob_AddSetDigitalOut;
	PLibMCDriver_ScanLabRTCJob_AddSetPowerForPIDControlPtr m_RTCJob_AddSetPowerForPIDControl;
	PLibMCDriver_ScanLabRTCJob_AddSetJumpSpeedPtr m_RTCJob_AddSetJumpSpeed;
	PLibMCDriver_ScanLabRTCJob_AddSetMarkSpeedPtr m_RTCJob_AddSetMarkSpeed;
	PLibMCDriver_ScanLabRTCJob_AddJumpMovementPtr m_RTCJob_AddJumpMovement;
	PLibMCDriver_ScanLabRTCJob_AddMarkMovementPtr m_RTCJob_AddMarkMovement;
	PLibMCDriver_ScanLabRTCJob_AddTimedMarkMovementPtr m_RTCJob_AddTimedMarkMovement;
	PLibMCDriver_ScanLabRTCJob_AddFreeVariablePtr m_RTCJob_AddFreeVariable;
	PLibMCDriver_ScanLabRTCRecording_ScanheadConnectionCheckIsEnabledPtr m_RTCRecording_ScanheadConnectionCheckIsEnabled;
	PLibMCDriver_ScanLabRTCRecording_EnableScanheadConnectionCheckPtr m_RTCRecording_EnableScanheadConnectionCheck;
	PLibMCDriver_ScanLabRTCRecording_DisableScanheadConnectionCheckPtr m_RTCRecording_DisableScanheadConnectionCheck;
	PLibMCDriver_ScanLabRTCRecording_ClearPtr m_RTCRecording_Clear;
	PLibMCDriver_ScanLabRTCRecording_AddChannelPtr m_RTCRecording_AddChannel;
	PLibMCDriver_ScanLabRTCRecording_RemoveChannelPtr m_RTCRecording_RemoveChannel;
	PLibMCDriver_ScanLabRTCRecording_HasChannelPtr m_RTCRecording_HasChannel;
	PLibMCDriver_ScanLabRTCRecording_GetChannelTypePtr m_RTCRecording_GetChannelType;
	PLibMCDriver_ScanLabRTCRecording_GetRecordCountPtr m_RTCRecording_GetRecordCount;
	PLibMCDriver_ScanLabRTCRecording_GetRecordEntryPtr m_RTCRecording_GetRecordEntry;
	PLibMCDriver_ScanLabRTCRecording_GetAllRecordEntriesPtr m_RTCRecording_GetAllRecordEntries;
	PLibMCDriver_ScanLabRTCRecording_EnableRecordingPtr m_RTCRecording_EnableRecording;
	PLibMCDriver_ScanLabRTCRecording_DisableRecordingPtr m_RTCRecording_DisableRecording;
	PLibMCDriver_ScanLabRTCRecording_ExecuteListWithRecordingPtr m_RTCRecording_ExecuteListWithRecording;
	PLibMCDriver_ScanLabRTCRecording_AddRecordsToDataTablePtr m_RTCRecording_AddRecordsToDataTable;
	PLibMCDriver_ScanLabRTCRecording_AddScaledRecordsToDataTablePtr m_RTCRecording_AddScaledRecordsToDataTable;
	PLibMCDriver_ScanLabGPIOSequence_GetIdentifierPtr m_GPIOSequence_GetIdentifier;
	PLibMCDriver_ScanLabGPIOSequence_ClearPtr m_GPIOSequence_Clear;
	PLibMCDriver_ScanLabGPIOSequence_AddOutputPtr m_GPIOSequence_AddOutput;
	PLibMCDriver_ScanLabGPIOSequence_AddDelayPtr m_GPIOSequence_AddDelay;
	PLibMCDriver_ScanLabGPIOSequence_WaitforInputPtr m_GPIOSequence_WaitforInput;
	PLibMCDriver_ScanLabGPIOSequence_AddLabelPtr m_GPIOSequence_AddLabel;
	PLibMCDriver_ScanLabGPIOSequence_GoToLabelPtr m_GPIOSequence_GoToLabel;
	PLibMCDriver_ScanLabGPIOSequence_ConditionalGoToLabelPtr m_GPIOSequence_ConditionalGoToLabel;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_SetControlOutputPinsPtr m_NLightAFXProfileSelector_SetControlOutputPins;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_GetControlOutputPinsPtr m_NLightAFXProfileSelector_GetControlOutputPins;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_SetSelectionOutputPinsPtr m_NLightAFXProfileSelector_SetSelectionOutputPins;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_GetSelectionOutputPinsPtr m_NLightAFXProfileSelector_GetSelectionOutputPins;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_SetAcknowledgeInputPinPtr m_NLightAFXProfileSelector_SetAcknowledgeInputPin;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_GetAcknowledgeInputPinPtr m_NLightAFXProfileSelector_GetAcknowledgeInputPin;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_SetSelectionDelayPtr m_NLightAFXProfileSelector_SetSelectionDelay;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_GetSelectionDelayPtr m_NLightAFXProfileSelector_GetSelectionDelay;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_SetAcknowledgeTimeoutPtr m_NLightAFXProfileSelector_SetAcknowledgeTimeout;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_GetAcknowledgeTimeoutPtr m_NLightAFXProfileSelector_GetAcknowledgeTimeout;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_EnableAutomaticSelectionPtr m_NLightAFXProfileSelector_EnableAutomaticSelection;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_DisableAutomaticSelectionPtr m_NLightAFXProfileSelector_DisableAutomaticSelection;
	PLibMCDriver_ScanLabNLightAFXProfileSelector_AddCustomSelectionPtr m_NLightAFXProfileSelector_AddCustomSelection;
	PLibMCDriver_ScanLabRTCContext_LoadFirmwarePtr m_RTCContext_LoadFirmware;
	PLibMCDriver_ScanLabRTCContext_LoadCorrectionFilePtr m_RTCContext_LoadCorrectionFile;
	PLibMCDriver_ScanLabRTCContext_SelectCorrectionTablePtr m_RTCContext_SelectCorrectionTable;
	PLibMCDriver_ScanLabRTCContext_ConfigureListsPtr m_RTCContext_ConfigureLists;
	PLibMCDriver_ScanLabRTCContext_SetLaserModePtr m_RTCContext_SetLaserMode;
	PLibMCDriver_ScanLabRTCContext_DisableAutoLaserControlPtr m_RTCContext_DisableAutoLaserControl;
	PLibMCDriver_ScanLabRTCContext_SetLaserControlParametersPtr m_RTCContext_SetLaserControlParameters;
	PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInBitsPtr m_RTCContext_SetLaserPulsesInBits;
	PLibMCDriver_ScanLabRTCContext_SetLaserPulsesInMicroSecondsPtr m_RTCContext_SetLaserPulsesInMicroSeconds;
	PLibMCDriver_ScanLabRTCContext_SetStandbyInBitsPtr m_RTCContext_SetStandbyInBits;
	PLibMCDriver_ScanLabRTCContext_SetStandbyInMicroSecondsPtr m_RTCContext_SetStandbyInMicroSeconds;
	PLibMCDriver_ScanLabRTCContext_GetIPAddressPtr m_RTCContext_GetIPAddress;
	PLibMCDriver_ScanLabRTCContext_GetNetmaskPtr m_RTCContext_GetNetmask;
	PLibMCDriver_ScanLabRTCContext_GetSerialNumberPtr m_RTCContext_GetSerialNumber;
	PLibMCDriver_ScanLabRTCContext_GetLaserIndexPtr m_RTCContext_GetLaserIndex;
	PLibMCDriver_ScanLabRTCContext_SetLaserOriginPtr m_RTCContext_SetLaserOrigin;
	PLibMCDriver_ScanLabRTCContext_GetLaserOriginPtr m_RTCContext_GetLaserOrigin;
	PLibMCDriver_ScanLabRTCContext_SetLaserFieldPtr m_RTCContext_SetLaserField;
	PLibMCDriver_ScanLabRTCContext_ResetLaserFieldPtr m_RTCContext_ResetLaserField;
	PLibMCDriver_ScanLabRTCContext_EnableRangeCheckingPtr m_RTCContext_EnableRangeChecking;
	PLibMCDriver_ScanLabRTCContext_DisableRangeCheckingPtr m_RTCContext_DisableRangeChecking;
	PLibMCDriver_ScanLabRTCContext_GetLaserFieldPtr m_RTCContext_GetLaserField;
	PLibMCDriver_ScanLabRTCContext_SetStartListPtr m_RTCContext_SetStartList;
	PLibMCDriver_ScanLabRTCContext_SetEndOfListPtr m_RTCContext_SetEndOfList;
	PLibMCDriver_ScanLabRTCContext_ExecuteListPtr m_RTCContext_ExecuteList;
	PLibMCDriver_ScanLabRTCContext_SetAutoChangePosPtr m_RTCContext_SetAutoChangePos;
	PLibMCDriver_ScanLabRTCContext_SetDelaysPtr m_RTCContext_SetDelays;
	PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInMicrosecondsPtr m_RTCContext_SetLaserDelaysInMicroseconds;
	PLibMCDriver_ScanLabRTCContext_SetLaserDelaysInBitsPtr m_RTCContext_SetLaserDelaysInBits;
	PLibMCDriver_ScanLabRTCContext_DrawPolylinePtr m_RTCContext_DrawPolyline;
	PLibMCDriver_ScanLabRTCContext_DrawPolylineOIEPtr m_RTCContext_DrawPolylineOIE;
	PLibMCDriver_ScanLabRTCContext_DrawHatchesPtr m_RTCContext_DrawHatches;
	PLibMCDriver_ScanLabRTCContext_AddSetPowerPtr m_RTCContext_AddSetPower;
	PLibMCDriver_ScanLabRTCContext_AddSetAnalogOutPtr m_RTCContext_AddSetAnalogOut;
	PLibMCDriver_ScanLabRTCContext_AddSetDigitalOutPtr m_RTCContext_AddSetDigitalOut;
	PLibMCDriver_ScanLabRTCContext_AddSetPowerForPIDControlPtr m_RTCContext_AddSetPowerForPIDControl;
	PLibMCDriver_ScanLabRTCContext_AddSetJumpSpeedPtr m_RTCContext_AddSetJumpSpeed;
	PLibMCDriver_ScanLabRTCContext_AddSetMarkSpeedPtr m_RTCContext_AddSetMarkSpeed;
	PLibMCDriver_ScanLabRTCContext_AddJumpMovementPtr m_RTCContext_AddJumpMovement;
	PLibMCDriver_ScanLabRTCContext_AddMarkMovementPtr m_RTCContext_AddMarkMovement;
	PLibMCDriver_ScanLabRTCContext_AddTimedMarkMovementPtr m_RTCContext_AddTimedMarkMovement;
	PLibMCDriver_ScanLabRTCContext_AddFreeVariablePtr m_RTCContext_AddFreeVariable;
	PLibMCDriver_ScanLabRTCContext_GetCurrentFreeVariablePtr m_RTCContext_GetCurrentFreeVariable;
	PLibMCDriver_ScanLabRTCContext_GetTimeStampPtr m_RTCContext_GetTimeStamp;
	PLibMCDriver_ScanLabRTCContext_GetRTCChannelPtr m_RTCContext_GetRTCChannel;
	PLibMCDriver_ScanLabRTCContext_GetRTCInternalValuePtr m_RTCContext_GetRTCInternalValue;
	PLibMCDriver_ScanLabRTCContext_StopExecutionPtr m_RTCContext_StopExecution;
	PLibMCDriver_ScanLabRTCContext_DrawHatchesOIEPtr m_RTCContext_DrawHatchesOIE;
	PLibMCDriver_ScanLabRTCContext_AddLayerToListPtr m_RTCContext_AddLayerToList;
	PLibMCDriver_ScanLabRTCContext_WaitForEncoderXPtr m_RTCContext_WaitForEncoderX;
	PLibMCDriver_ScanLabRTCContext_WaitForEncoderYPtr m_RTCContext_WaitForEncoderY;
	PLibMCDriver_ScanLabRTCContext_WaitForEncoderXStepsPtr m_RTCContext_WaitForEncoderXSteps;
	PLibMCDriver_ScanLabRTCContext_WaitForEncoderYStepsPtr m_RTCContext_WaitForEncoderYSteps;
	PLibMCDriver_ScanLabRTCContext_AddCustomDelayPtr m_RTCContext_AddCustomDelay;
	PLibMCDriver_ScanLabRTCContext_GetCorrectionFactorPtr m_RTCContext_GetCorrectionFactor;
	PLibMCDriver_ScanLabRTCContext_GetStatusPtr m_RTCContext_GetStatus;
	PLibMCDriver_ScanLabRTCContext_GetHeadStatusPtr m_RTCContext_GetHeadStatus;
	PLibMCDriver_ScanLabRTCContext_GetStateValuesPtr m_RTCContext_GetStateValues;
	PLibMCDriver_ScanLabRTCContext_GetInputPointerPtr m_RTCContext_GetInputPointer;
	PLibMCDriver_ScanLabRTCContext_GetRTCVersionPtr m_RTCContext_GetRTCVersion;
	PLibMCDriver_ScanLabRTCContext_SetCommunicationTimeoutsPtr m_RTCContext_SetCommunicationTimeouts;
	PLibMCDriver_ScanLabRTCContext_GetCommunicationTimeoutsPtr m_RTCContext_GetCommunicationTimeouts;
	PLibMCDriver_ScanLabRTCContext_InitializeForOIEPtr m_RTCContext_InitializeForOIE;
	PLibMCDriver_ScanLabRTCContext_SetLaserPinOutPtr m_RTCContext_SetLaserPinOut;
	PLibMCDriver_ScanLabRTCContext_GetLaserPinInPtr m_RTCContext_GetLaserPinIn;
	PLibMCDriver_ScanLabRTCContext_AddLaserPinOutToListPtr m_RTCContext_AddLaserPinOutToList;
	PLibMCDriver_ScanLabRTCContext_AddWriteDigitalIOListPtr m_RTCContext_AddWriteDigitalIOList;
	PLibMCDriver_ScanLabRTCContext_AddWriteMaskedDigitalIOListPtr m_RTCContext_AddWriteMaskedDigitalIOList;
	PLibMCDriver_ScanLabRTCContext_EnableOIEPtr m_RTCContext_EnableOIE;
	PLibMCDriver_ScanLabRTCContext_DisableOIEPtr m_RTCContext_DisableOIE;
	PLibMCDriver_ScanLabRTCContext_CreateNLightAFXBeamProfileSelectorPtr m_RTCContext_CreateNLightAFXBeamProfileSelector;
	PLibMCDriver_ScanLabRTCContext_AddGPIOSequencePtr m_RTCContext_AddGPIOSequence;
	PLibMCDriver_ScanLabRTCContext_FindGPIOSequencePtr m_RTCContext_FindGPIOSequence;
	PLibMCDriver_ScanLabRTCContext_DeleteGPIOSequencePtr m_RTCContext_DeleteGPIOSequence;
	PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementPtr m_RTCContext_StartOIEMeasurement;
	PLibMCDriver_ScanLabRTCContext_StartOIEMeasurementExPtr m_RTCContext_StartOIEMeasurementEx;
	PLibMCDriver_ScanLabRTCContext_StopOIEMeasurementPtr m_RTCContext_StopOIEMeasurement;
	PLibMCDriver_ScanLabRTCContext_SetOIEPIDModePtr m_RTCContext_SetOIEPIDMode;
	PLibMCDriver_ScanLabRTCContext_EnableOIEPIDControlPtr m_RTCContext_EnableOIEPIDControl;
	PLibMCDriver_ScanLabRTCContext_DisableOIEPIDControlPtr m_RTCContext_DisableOIEPIDControl;
	PLibMCDriver_ScanLabRTCContext_ClearOIEMeasurementTagsPtr m_RTCContext_ClearOIEMeasurementTags;
	PLibMCDriver_ScanLabRTCContext_EnableOIEMeasurementTaggingPtr m_RTCContext_EnableOIEMeasurementTagging;
	PLibMCDriver_ScanLabRTCContext_DisableOIEMeasurementTaggingPtr m_RTCContext_DisableOIEMeasurementTagging;
	PLibMCDriver_ScanLabRTCContext_GetOIEMaxMeasurementTagPtr m_RTCContext_GetOIEMaxMeasurementTag;
	PLibMCDriver_ScanLabRTCContext_MapOIEMeasurementTagPtr m_RTCContext_MapOIEMeasurementTag;
	PLibMCDriver_ScanLabRTCContext_DisableSkyWritingPtr m_RTCContext_DisableSkyWriting;
	PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode1Ptr m_RTCContext_EnableSkyWritingMode1;
	PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode2Ptr m_RTCContext_EnableSkyWritingMode2;
	PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode3Ptr m_RTCContext_EnableSkyWritingMode3;
	PLibMCDriver_ScanLabRTCContext_EnableSkyWritingMode4Ptr m_RTCContext_EnableSkyWritingMode4;
	PLibMCDriver_ScanLabRTCContext_SetTransformationAnglePtr m_RTCContext_SetTransformationAngle;
	PLibMCDriver_ScanLabRTCContext_SetTransformationScalePtr m_RTCContext_SetTransformationScale;
	PLibMCDriver_ScanLabRTCContext_SetTransformationOffsetPtr m_RTCContext_SetTransformationOffset;
	PLibMCDriver_ScanLabRTCContext_SetTransformationMatrixPtr m_RTCContext_SetTransformationMatrix;
	PLibMCDriver_ScanLabRTCContext_PrepareRecordingPtr m_RTCContext_PrepareRecording;
	PLibMCDriver_ScanLabRTCContext_HasRecordingPtr m_RTCContext_HasRecording;
	PLibMCDriver_ScanLabRTCContext_FindRecordingPtr m_RTCContext_FindRecording;
	PLibMCDriver_ScanLabRTCContext_EnableTimelagCompensationPtr m_RTCContext_EnableTimelagCompensation;
	PLibMCDriver_ScanLabRTCContext_DisableTimelagCompensationPtr m_RTCContext_DisableTimelagCompensation;
	PLibMCDriver_ScanLabRTCContext_EnableMarkOnTheFly2DPtr m_RTCContext_EnableMarkOnTheFly2D;
	PLibMCDriver_ScanLabRTCContext_DisableMarkOnTheFly2DPtr m_RTCContext_DisableMarkOnTheFly2D;
	PLibMCDriver_ScanLabRTCContext_MarkOnTheFly2DIsEnabledPtr m_RTCContext_MarkOnTheFly2DIsEnabled;
	PLibMCDriver_ScanLabRTCContext_Get2DMarkOnTheFlyPositionPtr m_RTCContext_Get2DMarkOnTheFlyPosition;
	PLibMCDriver_ScanLabRTCContext_CheckOnTheFlyErrorPtr m_RTCContext_CheckOnTheFlyError;
	PLibMCDriver_ScanLabRTCContext_LaserPowerCalibrationIsEnabledPtr m_RTCContext_LaserPowerCalibrationIsEnabled;
	PLibMCDriver_ScanLabRTCContext_LaserPowerCalibrationIsLinearPtr m_RTCContext_LaserPowerCalibrationIsLinear;
	PLibMCDriver_ScanLabRTCContext_ClearLaserPowerCalibrationPtr m_RTCContext_ClearLaserPowerCalibration;
	PLibMCDriver_ScanLabRTCContext_GetLaserPowerCalibrationPtr m_RTCContext_GetLaserPowerCalibration;
	PLibMCDriver_ScanLabRTCContext_SetLinearLaserPowerCalibrationPtr m_RTCContext_SetLinearLaserPowerCalibration;
	PLibMCDriver_ScanLabRTCContext_SetPiecewiseLinearLaserPowerCalibrationPtr m_RTCContext_SetPiecewiseLinearLaserPowerCalibration;
	PLibMCDriver_ScanLabRTCContext_EnableSpatialLaserPowerModulationPtr m_RTCContext_EnableSpatialLaserPowerModulation;
	PLibMCDriver_ScanLabRTCContext_DisablePowerModulationPtr m_RTCContext_DisablePowerModulation;
	PLibMCDriver_ScanLabRTCContext_EnableLineSubdivisionPtr m_RTCContext_EnableLineSubdivision;
	PLibMCDriver_ScanLabRTCContext_DisableLineSubdivisionPtr m_RTCContext_DisableLineSubdivision;
	PLibMCDriver_ScanLabRTCContext_ReadMultiMCBSPPtr m_RTCContext_ReadMultiMCBSP;
	PLibMCDriver_ScanLabRTCContext_CreateUARTConnectionPtr m_RTCContext_CreateUARTConnection;
	PLibMCDriver_ScanLabRTCContext_EnableScanAheadPtr m_RTCContext_EnableScanAhead;
	PLibMCDriver_ScanLabRTCContext_DisableScanAheadPtr m_RTCContext_DisableScanAhead;
	PLibMCDriver_ScanLabRTCContext_ActivateScanAheadAutoDelaysPtr m_RTCContext_ActivateScanAheadAutoDelays;
	PLibMCDriver_ScanLabRTCContext_DeactivateScanAheadAutoDelaysPtr m_RTCContext_DeactivateScanAheadAutoDelays;
	PLibMCDriver_ScanLabRTCContext_ScanAheadAutoDelaysAreActivatedPtr m_RTCContext_ScanAheadAutoDelaysAreActivated;
	PLibMCDriver_ScanLabRTCContext_SetScanAheadLaserShiftsInMicrosecondsPtr m_RTCContext_SetScanAheadLaserShiftsInMicroseconds;
	PLibMCDriver_ScanLabRTCContext_SetScanAheadLaserShiftsInUnitsPtr m_RTCContext_SetScanAheadLaserShiftsInUnits;
	PLibMCDriver_ScanLabRTCContext_SetScanAheadLineParametersPtr m_RTCContext_SetScanAheadLineParameters;
	PLibMCDriver_ScanLabRTCSelector_SearchCardsPtr m_RTCSelector_SearchCards;
	PLibMCDriver_ScanLabRTCSelector_SearchCardsByRangePtr m_RTCSelector_SearchCardsByRange;
	PLibMCDriver_ScanLabRTCSelector_GetCardCountPtr m_RTCSelector_GetCardCount;
	PLibMCDriver_ScanLabRTCSelector_GetEthernetCardCountPtr m_RTCSelector_GetEthernetCardCount;
	PLibMCDriver_ScanLabRTCSelector_AcquireCardPtr m_RTCSelector_AcquireCard;
	PLibMCDriver_ScanLabRTCSelector_AcquireCardBySerialPtr m_RTCSelector_AcquireCardBySerial;
	PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardPtr m_RTCSelector_AcquireEthernetCard;
	PLibMCDriver_ScanLabRTCSelector_AcquireEthernetCardBySerialPtr m_RTCSelector_AcquireEthernetCardBySerial;
	PLibMCDriver_ScanLabDriver_ScanLab_LoadSDKPtr m_Driver_ScanLab_LoadSDK;
	PLibMCDriver_ScanLabDriver_ScanLab_LoadCustomSDKPtr m_Driver_ScanLab_LoadCustomSDK;
	PLibMCDriver_ScanLabDriver_ScanLab_CreateRTCSelectorPtr m_Driver_ScanLab_CreateRTCSelector;
	PLibMCDriver_ScanLabDriver_ScanLab_EnableJournalingPtr m_Driver_ScanLab_EnableJournaling;
	PLibMCDriver_ScanLabDriver_ScanLab_SetFirmwarePtr m_Driver_ScanLab_SetFirmware;
	PLibMCDriver_ScanLabDriver_ScanLab_SetCustomFirmwarePtr m_Driver_ScanLab_SetCustomFirmware;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetToSimulationModePtr m_Driver_ScanLab_RTC6_SetToSimulationMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsSimulationModePtr m_Driver_ScanLab_RTC6_IsSimulationMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_IsInitializedPtr m_Driver_ScanLab_RTC6_IsInitialized;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialisePtr m_Driver_ScanLab_RTC6_Initialise;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_InitialiseFromConfigurationPtr m_Driver_ScanLab_RTC6_InitialiseFromConfiguration;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCommunicationTimeoutsPtr m_Driver_ScanLab_RTC6_SetCommunicationTimeouts;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetIPAddressPtr m_Driver_ScanLab_RTC6_GetIPAddress;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetNetmaskPtr m_Driver_ScanLab_RTC6_GetNetmask;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSerialNumberPtr m_Driver_ScanLab_RTC6_GetSerialNumber;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetContextPtr m_Driver_ScanLab_RTC6_GetContext;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetSelectorPtr m_Driver_ScanLab_RTC6_GetSelector;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadFirmwarePtr m_Driver_ScanLab_RTC6_LoadFirmware;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_LoadCustomFirmwarePtr m_Driver_ScanLab_RTC6_LoadCustomFirmware;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetCorrectionFilePtr m_Driver_ScanLab_RTC6_SetCorrectionFile;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureLaserModePtr m_Driver_ScanLab_RTC6_ConfigureLaserMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_ConfigureDelaysPtr m_Driver_ScanLab_RTC6_ConfigureDelays;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_SetOIERecordingModePtr m_Driver_ScanLab_RTC6_SetOIERecordingMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetOIERecordingModePtr m_Driver_ScanLab_RTC6_GetOIERecordingMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_EnableAttributeFilterPtr m_Driver_ScanLab_RTC6_EnableAttributeFilter;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DisableAttributeFilterPtr m_Driver_ScanLab_RTC6_DisableAttributeFilter;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DrawLayerPtr m_Driver_ScanLab_RTC6_DrawLayer;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetCommunicationTimeoutsPtr m_Driver_ScanLab_RTC6_GetCommunicationTimeouts;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_GetDefaultCommunicationTimeoutsPtr m_Driver_ScanLab_RTC6_GetDefaultCommunicationTimeouts;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_EnableTimelagCompensationPtr m_Driver_ScanLab_RTC6_EnableTimelagCompensation;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6_DisableTimelagCompensationPtr m_Driver_ScanLab_RTC6_DisableTimelagCompensation;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetToSimulationModePtr m_Driver_ScanLab_RTC6xN_SetToSimulationMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_IsSimulationModePtr m_Driver_ScanLab_RTC6xN_IsSimulationMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_IsInitializedPtr m_Driver_ScanLab_RTC6xN_IsInitialized;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ScannerIsInitializedPtr m_Driver_ScanLab_RTC6xN_ScannerIsInitialized;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetScannerCountPtr m_Driver_ScanLab_RTC6xN_GetScannerCount;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_InitialiseScannerPtr m_Driver_ScanLab_RTC6xN_InitialiseScanner;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_InitialiseScannerFromConfigurationPtr m_Driver_ScanLab_RTC6xN_InitialiseScannerFromConfiguration;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetIPAddressPtr m_Driver_ScanLab_RTC6xN_GetIPAddress;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetNetmaskPtr m_Driver_ScanLab_RTC6xN_GetNetmask;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetSerialNumberPtr m_Driver_ScanLab_RTC6xN_GetSerialNumber;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetLaserIndexPtr m_Driver_ScanLab_RTC6xN_GetLaserIndex;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetSelectorPtr m_Driver_ScanLab_RTC6xN_GetSelector;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetContextPtr m_Driver_ScanLab_RTC6xN_GetContext;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_LoadFirmwarePtr m_Driver_ScanLab_RTC6xN_LoadFirmware;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_LoadCustomFirmwarePtr m_Driver_ScanLab_RTC6xN_LoadCustomFirmware;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetCorrectionFilePtr m_Driver_ScanLab_RTC6xN_SetCorrectionFile;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ConfigureLaserModePtr m_Driver_ScanLab_RTC6xN_ConfigureLaserMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_ConfigureDelaysPtr m_Driver_ScanLab_RTC6xN_ConfigureDelays;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetOIERecordingModePtr m_Driver_ScanLab_RTC6xN_SetOIERecordingMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetOIERecordingModePtr m_Driver_ScanLab_RTC6xN_GetOIERecordingMode;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_EnableAttributeFilterPtr m_Driver_ScanLab_RTC6xN_EnableAttributeFilter;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DisableAttributeFilterPtr m_Driver_ScanLab_RTC6xN_DisableAttributeFilter;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DrawLayerPtr m_Driver_ScanLab_RTC6xN_DrawLayer;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetAllCommunicationTimeoutsPtr m_Driver_ScanLab_RTC6xN_SetAllCommunicationTimeouts;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_SetCommunicationTimeoutsPtr m_Driver_ScanLab_RTC6xN_SetCommunicationTimeouts;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetCommunicationTimeoutsPtr m_Driver_ScanLab_RTC6xN_GetCommunicationTimeouts;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_GetDefaultCommunicationTimeoutsPtr m_Driver_ScanLab_RTC6xN_GetDefaultCommunicationTimeouts;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_EnableTimelagCompensationPtr m_Driver_ScanLab_RTC6xN_EnableTimelagCompensation;
	PLibMCDriver_ScanLabDriver_ScanLab_RTC6xN_DisableTimelagCompensationPtr m_Driver_ScanLab_RTC6xN_DisableTimelagCompensation;
	PLibMCDriver_ScanLabGetVersionPtr m_GetVersion;
	PLibMCDriver_ScanLabGetLastErrorPtr m_GetLastError;
	PLibMCDriver_ScanLabReleaseInstancePtr m_ReleaseInstance;
	PLibMCDriver_ScanLabAcquireInstancePtr m_AcquireInstance;
	PLibMCDriver_ScanLabInjectComponentPtr m_InjectComponent;
	PLibMCDriver_ScanLabGetSymbolLookupMethodPtr m_GetSymbolLookupMethod;
	PLibMCDriver_ScanLabCreateDriverPtr m_CreateDriver;
} sLibMCDriver_ScanLabDynamicWrapperTable;

#endif // __LIBMCDRIVER_SCANLAB_DYNAMICHEADER_CPPTYPES

