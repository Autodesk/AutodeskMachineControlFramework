/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of MC Driver ScanLab RTC. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 2.0.0

*/

#include "libmcdriver_scanlab_abi.hpp"
#include "libmcdriver_scanlab_interfaces.hpp"
#include "libmcdriver_scanlab_interfaceexception.hpp"

#include <map>

using namespace LibMCDriver_ScanLab::Impl;

LibMCDriver_ScanLabResult handleLibMCDriver_ScanLabException(IBase * pIBaseClass, ELibMCDriver_ScanLabInterfaceException & Exception)
{
	LibMCDriver_ScanLabResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_ScanLabResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDriver_ScanLabResult errorCode = LIBMCDRIVER_SCANLAB_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_ScanLabResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDriver_ScanLabResult errorCode = LIBMCDRIVER_SCANLAB_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Driver
**************************************************************************************************************************/
LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_configure(LibMCDriver_ScanLab_Driver pDriver, const char * pConfigurationString)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (pConfigurationString == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sConfigurationString(pConfigurationString);
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver->Configure(sConfigurationString);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_getname(LibMCDriver_ScanLab_Driver pDriver, const LibMCDriver_ScanLab_uint32 nNameBufferSize, LibMCDriver_ScanLab_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIDriver->GetName();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCDriver_ScanLab_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_gettype(LibMCDriver_ScanLab_Driver pDriver, const LibMCDriver_ScanLab_uint32 nTypeBufferSize, LibMCDriver_ScanLab_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sType("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIDriver->GetType();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIDriver->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (LibMCDriver_ScanLab_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_getversion(LibMCDriver_ScanLab_Driver pDriver, LibMCDriver_ScanLab_uint32 * pMajor, LibMCDriver_ScanLab_uint32 * pMinor, LibMCDriver_ScanLab_uint32 * pMicro, const LibMCDriver_ScanLab_uint32 nBuildBufferSize, LibMCDriver_ScanLab_uint32* pBuildNeededChars, char * pBuildBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (!pMajor)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if ( (!pBuildBuffer) && !(pBuildNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sBuild("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetVersion(*pMajor, *pMinor, *pMicro, sBuild);

			pIDriver->_setCache (new ParameterCache_4<LibMCDriver_ScanLab_uint32, LibMCDriver_ScanLab_uint32, LibMCDriver_ScanLab_uint32, std::string> (*pMajor, *pMinor, *pMicro, sBuild));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<LibMCDriver_ScanLab_uint32, LibMCDriver_ScanLab_uint32, LibMCDriver_ScanLab_uint32, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (*pMajor, *pMinor, *pMicro, sBuild);
			pIDriver->_setCache (nullptr);
		}
		
		if (pBuildNeededChars)
			*pBuildNeededChars = (LibMCDriver_ScanLab_uint32) (sBuild.size()+1);
		if (pBuildBuffer) {
			if (sBuild.size() >= nBuildBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iBuild = 0; iBuild < sBuild.size(); iBuild++)
				pBuildBuffer[iBuild] = sBuild[iBuild];
			pBuildBuffer[sBuild.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_queryparameters(LibMCDriver_ScanLab_Driver pDriver)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver->QueryParameters();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_queryparametersex(LibMCDriver_ScanLab_Driver pDriver, LibMCEnv_DriverStatusUpdateSession pDriverUpdateInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		LibMCEnv::PDriverStatusUpdateSession pIDriverUpdateInstance = std::make_shared<LibMCEnv::CDriverStatusUpdateSession>(CWrapper::sPLibMCEnvWrapper.get(), pDriverUpdateInstance);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverUpdateInstance.get());
		if (!pIDriverUpdateInstance)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver->QueryParametersEx(pIDriverUpdateInstance);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for UARTConnection
**************************************************************************************************************************/
LibMCDriver_ScanLabResult libmcdriver_scanlab_uartconnection_getbaudrate(LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint32 * pBaudRate)
{
	IBase* pIBaseClass = (IBase *)pUARTConnection;

	try {
		if (pBaudRate == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IUARTConnection* pIUARTConnection = dynamic_cast<IUARTConnection*>(pIBaseClass);
		if (!pIUARTConnection)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pBaudRate = pIUARTConnection->GetBaudRate();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_uartconnection_getconfiguredbaudrate(LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint32 * pBaudRate)
{
	IBase* pIBaseClass = (IBase *)pUARTConnection;

	try {
		if (pBaudRate == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IUARTConnection* pIUARTConnection = dynamic_cast<IUARTConnection*>(pIBaseClass);
		if (!pIUARTConnection)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pBaudRate = pIUARTConnection->GetConfiguredBaudRate();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_uartconnection_clearreceivebuffer(LibMCDriver_ScanLab_UARTConnection pUARTConnection)
{
	IBase* pIBaseClass = (IBase *)pUARTConnection;

	try {
		IUARTConnection* pIUARTConnection = dynamic_cast<IUARTConnection*>(pIBaseClass);
		if (!pIUARTConnection)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIUARTConnection->ClearReceiveBuffer();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_uartconnection_availablebytes(LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint32 * pByteCount)
{
	IBase* pIBaseClass = (IBase *)pUARTConnection;

	try {
		if (pByteCount == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IUARTConnection* pIUARTConnection = dynamic_cast<IUARTConnection*>(pIBaseClass);
		if (!pIUARTConnection)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pByteCount = pIUARTConnection->AvailableBytes();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_uartconnection_writestring(LibMCDriver_ScanLab_UARTConnection pUARTConnection, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pUARTConnection;

	try {
		if (pValue == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sValue(pValue);
		IUARTConnection* pIUARTConnection = dynamic_cast<IUARTConnection*>(pIBaseClass);
		if (!pIUARTConnection)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIUARTConnection->WriteString(sValue);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_uartconnection_writedata(LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint64 nDataBufferSize, const LibMCDriver_ScanLab_uint8 * pDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pUARTConnection;

	try {
		if ( (!pDataBuffer) && (nDataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IUARTConnection* pIUARTConnection = dynamic_cast<IUARTConnection*>(pIBaseClass);
		if (!pIUARTConnection)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIUARTConnection->WriteData(nDataBufferSize, pDataBuffer);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_uartconnection_readdata(LibMCDriver_ScanLab_UARTConnection pUARTConnection, LibMCDriver_ScanLab_uint32 nByteCount, LibMCDriver_ScanLab_uint32 nTimeOutInMS, const LibMCDriver_ScanLab_uint64 nDataBufferSize, LibMCDriver_ScanLab_uint64* pDataNeededCount, LibMCDriver_ScanLab_uint8 * pDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pUARTConnection;

	try {
		if ((!pDataBuffer) && !(pDataNeededCount))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IUARTConnection* pIUARTConnection = dynamic_cast<IUARTConnection*>(pIBaseClass);
		if (!pIUARTConnection)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIUARTConnection->ReadData(nByteCount, nTimeOutInMS, nDataBufferSize, pDataNeededCount, pDataBuffer);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_uartconnection_readline(LibMCDriver_ScanLab_UARTConnection pUARTConnection, const char * pSeparator, LibMCDriver_ScanLab_uint32 nMaxLineLength, LibMCDriver_ScanLab_uint32 nTimeOutInMS, const LibMCDriver_ScanLab_uint32 nLineBufferSize, LibMCDriver_ScanLab_uint32* pLineNeededChars, char * pLineBuffer)
{
	IBase* pIBaseClass = (IBase *)pUARTConnection;

	try {
		if (pSeparator == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if ( (!pLineBuffer) && !(pLineNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sSeparator(pSeparator);
		std::string sLine("");
		IUARTConnection* pIUARTConnection = dynamic_cast<IUARTConnection*>(pIBaseClass);
		if (!pIUARTConnection)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pLineBuffer == nullptr);
		if (isCacheCall) {
			sLine = pIUARTConnection->ReadLine(sSeparator, nMaxLineLength, nTimeOutInMS);

			pIUARTConnection->_setCache (new ParameterCache_1<std::string> (sLine));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUARTConnection->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (sLine);
			pIUARTConnection->_setCache (nullptr);
		}
		
		if (pLineNeededChars)
			*pLineNeededChars = (LibMCDriver_ScanLab_uint32) (sLine.size()+1);
		if (pLineBuffer) {
			if (sLine.size() >= nLineBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iLine = 0; iLine < sLine.size(); iLine++)
				pLineBuffer[iLine] = sLine[iLine];
			pLineBuffer[sLine.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for RTCContext
**************************************************************************************************************************/
LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_loadfirmware(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nFirmwareDataBufferSize, const LibMCDriver_ScanLab_uint8 * pFirmwareDataBuffer, LibMCDriver_ScanLab_uint64 nFPGADataBufferSize, const LibMCDriver_ScanLab_uint8 * pFPGADataBuffer, LibMCDriver_ScanLab_uint64 nAuxiliaryDataBufferSize, const LibMCDriver_ScanLab_uint8 * pAuxiliaryDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pFirmwareDataBuffer) && (nFirmwareDataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if ( (!pFPGADataBuffer) && (nFPGADataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if ( (!pAuxiliaryDataBuffer) && (nAuxiliaryDataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->LoadFirmware(nFirmwareDataBufferSize, pFirmwareDataBuffer, nFPGADataBufferSize, pFPGADataBuffer, nAuxiliaryDataBufferSize, pAuxiliaryDataBuffer);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_loadcorrectionfile(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nCorrectionFileBufferSize, const LibMCDriver_ScanLab_uint8 * pCorrectionFileBuffer, LibMCDriver_ScanLab_uint32 nTableNumber, LibMCDriver_ScanLab_uint32 nDimension)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pCorrectionFileBuffer) && (nCorrectionFileBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->LoadCorrectionFile(nCorrectionFileBufferSize, pCorrectionFileBuffer, nTableNumber, nDimension);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_selectcorrectiontable(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nTableNumberHeadA, LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SelectCorrectionTable(nTableNumberHeadA, nTableNumberHeadB);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_configurelists(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nSizeListA, LibMCDriver_ScanLab_uint32 nSizeListB)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->ConfigureLists(nSizeListA, nSizeListB);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setlasermode(LibMCDriver_ScanLab_RTCContext pRTCContext, eLibMCDriver_ScanLabLaserMode eLaserMode, eLibMCDriver_ScanLabLaserPort eLaserPort)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetLaserMode(eLaserMode, eLaserPort);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disableautolasercontrol(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableAutoLaserControl();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setlasercontrolparameters(LibMCDriver_ScanLab_RTCContext pRTCContext, bool bDisableLaser, bool bFinishLaserPulseAfterOn, bool bPhaseShiftOfLaserSignal, bool bLaserOnSignalLowActive, bool bLaserHalfSignalsLowActive, bool bSetDigitalInOneHighActive, bool bOutputSynchronizationActive)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetLaserControlParameters(bDisableLaser, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setlaserpulsesinbits(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nHalfPeriod, LibMCDriver_ScanLab_uint32 nPulseLength)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetLaserPulsesInBits(nHalfPeriod, nPulseLength);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dHalfPeriod, LibMCDriver_ScanLab_double dPulseLength)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetLaserPulsesInMicroSeconds(dHalfPeriod, dPulseLength);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setstandbyinbits(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nHalfPeriod, LibMCDriver_ScanLab_uint32 nPulseLength)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetStandbyInBits(nHalfPeriod, nPulseLength);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dHalfPeriod, LibMCDriver_ScanLab_double dPulseLength)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetStandbyInMicroSeconds(dHalfPeriod, dPulseLength);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getipaddress(LibMCDriver_ScanLab_RTCContext pRTCContext, const LibMCDriver_ScanLab_uint32 nIPAddressBufferSize, LibMCDriver_ScanLab_uint32* pIPAddressNeededChars, char * pIPAddressBuffer)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pIPAddressBuffer) && !(pIPAddressNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sIPAddress("");
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIPAddressBuffer == nullptr);
		if (isCacheCall) {
			sIPAddress = pIRTCContext->GetIPAddress();

			pIRTCContext->_setCache (new ParameterCache_1<std::string> (sIPAddress));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIRTCContext->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (sIPAddress);
			pIRTCContext->_setCache (nullptr);
		}
		
		if (pIPAddressNeededChars)
			*pIPAddressNeededChars = (LibMCDriver_ScanLab_uint32) (sIPAddress.size()+1);
		if (pIPAddressBuffer) {
			if (sIPAddress.size() >= nIPAddressBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iIPAddress = 0; iIPAddress < sIPAddress.size(); iIPAddress++)
				pIPAddressBuffer[iIPAddress] = sIPAddress[iIPAddress];
			pIPAddressBuffer[sIPAddress.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getnetmask(LibMCDriver_ScanLab_RTCContext pRTCContext, const LibMCDriver_ScanLab_uint32 nNetmaskBufferSize, LibMCDriver_ScanLab_uint32* pNetmaskNeededChars, char * pNetmaskBuffer)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pNetmaskBuffer) && !(pNetmaskNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sNetmask("");
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNetmaskBuffer == nullptr);
		if (isCacheCall) {
			sNetmask = pIRTCContext->GetNetmask();

			pIRTCContext->_setCache (new ParameterCache_1<std::string> (sNetmask));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIRTCContext->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (sNetmask);
			pIRTCContext->_setCache (nullptr);
		}
		
		if (pNetmaskNeededChars)
			*pNetmaskNeededChars = (LibMCDriver_ScanLab_uint32) (sNetmask.size()+1);
		if (pNetmaskBuffer) {
			if (sNetmask.size() >= nNetmaskBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iNetmask = 0; iNetmask < sNetmask.size(); iNetmask++)
				pNetmaskBuffer[iNetmask] = sNetmask[iNetmask];
			pNetmaskBuffer[sNetmask.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getserialnumber(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pSerialNumber)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pSerialNumber == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pSerialNumber = pIRTCContext->GetSerialNumber();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getlaserindex(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pLaserIndex)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pLaserIndex == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pLaserIndex = pIRTCContext->GetLaserIndex();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setlaserorigin(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dOriginX, LibMCDriver_ScanLab_double dOriginY)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetLaserOrigin(dOriginX, dOriginY);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getlaserorigin(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double * pOriginX, LibMCDriver_ScanLab_double * pOriginY)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (!pOriginX)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pOriginY)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->GetLaserOrigin(*pOriginX, *pOriginY);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setlaserfield(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dMinX, LibMCDriver_ScanLab_double dMinY, LibMCDriver_ScanLab_double dMaxX, LibMCDriver_ScanLab_double dMaxY)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetLaserField(dMinX, dMinY, dMaxX, dMaxY);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_resetlaserfield(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->ResetLaserField();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enablerangechecking(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableRangeChecking();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disablerangechecking(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableRangeChecking();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getlaserfield(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double * pMinX, LibMCDriver_ScanLab_double * pMinY, LibMCDriver_ScanLab_double * pMaxX, LibMCDriver_ScanLab_double * pMaxY, bool * pHasLaserField)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (!pMinX)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMinY)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMaxX)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMaxY)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pHasLaserField == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pHasLaserField = pIRTCContext->GetLaserField(*pMinX, *pMinY, *pMaxX, *pMaxY);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setstartlist(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nListIndex, LibMCDriver_ScanLab_uint32 nPosition)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetStartList(nListIndex, nPosition);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setendoflist(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetEndOfList();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_executelist(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nListIndex, LibMCDriver_ScanLab_uint32 nPosition)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->ExecuteList(nListIndex, nPosition);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setautochangepos(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nPosition)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetAutoChangePos(nPosition);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setdelays(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nMarkDelay, LibMCDriver_ScanLab_uint32 nJumpDelay, LibMCDriver_ScanLab_uint32 nPolygonDelay)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetDelays(nMarkDelay, nJumpDelay, nPolygonDelay);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dLaserOnDelay, LibMCDriver_ScanLab_double dLaserOffDelay)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetLaserDelaysInMicroseconds(dLaserOnDelay, dLaserOffDelay);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setlaserdelaysinbits(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nLaserOnDelay, LibMCDriver_ScanLab_int32 nLaserOffDelay)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetLaserDelaysInBits(nLaserOnDelay, nLaserOffDelay);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_drawpolyline(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nPointsBufferSize, const sLibMCDriver_ScanLabPoint2D * pPointsBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pPointsBuffer) && (nPointsBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DrawPolyline(nPointsBufferSize, pPointsBuffer, fMarkSpeed, fJumpSpeed, fPower, fZValue);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_drawpolylineoie(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nPointsBufferSize, const sLibMCDriver_ScanLabPoint2D * pPointsBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue, LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pPointsBuffer) && (nPointsBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DrawPolylineOIE(nPointsBufferSize, pPointsBuffer, fMarkSpeed, fJumpSpeed, fPower, fZValue, nOIEPIDControlIndex);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_drawhatches(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nHatchesBufferSize, const sLibMCDriver_ScanLabHatch2D * pHatchesBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pHatchesBuffer) && (nHatchesBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DrawHatches(nHatchesBufferSize, pHatchesBuffer, fMarkSpeed, fJumpSpeed, fPower, fZValue);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addsetpower(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_single fPowerInPercent)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddSetPower(fPowerInPercent);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addsetanalogout(LibMCDriver_ScanLab_RTCContext pRTCContext, eLibMCDriver_ScanLabLaserPort eLaserPort, LibMCDriver_ScanLab_single fOutputValue)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddSetAnalogOut(eLaserPort, fOutputValue);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addsetdigitalout(LibMCDriver_ScanLab_RTCContext pRTCContext, eLibMCDriver_ScanLabLaserPort eLaserPort, LibMCDriver_ScanLab_single fOutputValue)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddSetDigitalOut(eLaserPort, fOutputValue);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addsetpowerforpidcontrol(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_single fPowerInPercent)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddSetPowerForPIDControl(fPowerInPercent);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addsetjumpspeed(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_single fJumpSpeedInMMPerSecond)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddSetJumpSpeed(fJumpSpeedInMMPerSecond);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addsetmarkspeed(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_single fMarkSpeedInMMPerSecond)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddSetMarkSpeed(fMarkSpeedInMMPerSecond);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addjumpmovement(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTargetX, LibMCDriver_ScanLab_double dTargetY)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddJumpMovement(dTargetX, dTargetY);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addmarkmovement(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTargetX, LibMCDriver_ScanLab_double dTargetY)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddMarkMovement(dTargetX, dTargetY);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addtimedmarkmovement(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTargetX, LibMCDriver_ScanLab_double dTargetY, LibMCDriver_ScanLab_double dDurationInMicroseconds)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddTimedMarkMovement(dTargetX, dTargetY, dDurationInMicroseconds);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addfreevariable(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nVariableNo, LibMCDriver_ScanLab_uint32 nValue)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddFreeVariable(nVariableNo, nValue);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getcurrentfreevariable(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nVariableNo, LibMCDriver_ScanLab_uint32 * pValue)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pValue == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pValue = pIRTCContext->GetCurrentFreeVariable(nVariableNo);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_gettimestamp(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pTimeStamp)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pTimeStamp == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pTimeStamp = pIRTCContext->GetTimeStamp();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_stopexecution(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->StopExecution();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_drawhatchesoie(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nHatchesBufferSize, const sLibMCDriver_ScanLabHatch2D * pHatchesBuffer, LibMCDriver_ScanLab_single fMarkSpeed, LibMCDriver_ScanLab_single fJumpSpeed, LibMCDriver_ScanLab_single fPower, LibMCDriver_ScanLab_single fZValue, LibMCDriver_ScanLab_uint32 nOIEPIDControlIndex)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pHatchesBuffer) && (nHatchesBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DrawHatchesOIE(nHatchesBufferSize, pHatchesBuffer, fMarkSpeed, fJumpSpeed, fPower, fZValue, nOIEPIDControlIndex);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addlayertolist(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCEnv_ToolpathLayer pLayer, bool bFailIfNonAssignedDataExists)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		LibMCEnv::PToolpathLayer pILayer = std::make_shared<LibMCEnv::CToolpathLayer>(CWrapper::sPLibMCEnvWrapper.get(), pLayer);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pILayer.get());
		if (!pILayer)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddLayerToList(pILayer, bFailIfNonAssignedDataExists);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_waitforencoderx(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dPositionInMM, bool bInPositiveHalfPlane)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->WaitForEncoderX(dPositionInMM, bInPositiveHalfPlane);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_waitforencodery(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dPositionInMM, bool bInPositiveHalfPlane)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->WaitForEncoderY(dPositionInMM, bInPositiveHalfPlane);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_waitforencoderxsteps(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nPositionInSteps, bool bInPositiveHalfPlane)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->WaitForEncoderXSteps(nPositionInSteps, bInPositiveHalfPlane);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_waitforencoderysteps(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nPositionInSteps, bool bInPositiveHalfPlane)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->WaitForEncoderYSteps(nPositionInSteps, bInPositiveHalfPlane);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_addcustomdelay(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nDelay)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->AddCustomDelay(nDelay);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getcorrectionfactor(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double * pCorrectionFactor)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pCorrectionFactor == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pCorrectionFactor = pIRTCContext->GetCorrectionFactor();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getstatus(LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pBusy, LibMCDriver_ScanLab_uint32 * pPosition)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (!pBusy)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pPosition)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->GetStatus(*pBusy, *pPosition);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getheadstatus(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nHeadNo, bool * pPositionXisOK, bool * pPositionYisOK, bool * pTemperatureisOK, bool * pPowerisOK)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (!pPositionXisOK)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pPositionYisOK)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pTemperatureisOK)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pPowerisOK)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->GetHeadStatus(nHeadNo, *pPositionXisOK, *pPositionYisOK, *pTemperatureisOK, *pPowerisOK);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getstatevalues(LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pLaserIsOn, LibMCDriver_ScanLab_int32 * pPositionX, LibMCDriver_ScanLab_int32 * pPositionY, LibMCDriver_ScanLab_int32 * pPositionZ, LibMCDriver_ScanLab_int32 * pCorrectedPositionX, LibMCDriver_ScanLab_int32 * pCorrectedPositionY, LibMCDriver_ScanLab_int32 * pCorrectedPositionZ, LibMCDriver_ScanLab_int32 * pFocusShift, LibMCDriver_ScanLab_int32 * pMarkSpeed)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (!pLaserIsOn)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pPositionX)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pPositionY)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pPositionZ)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pCorrectedPositionX)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pCorrectedPositionY)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pCorrectedPositionZ)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pFocusShift)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMarkSpeed)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->GetStateValues(*pLaserIsOn, *pPositionX, *pPositionY, *pPositionZ, *pCorrectedPositionX, *pCorrectedPositionY, *pCorrectedPositionZ, *pFocusShift, *pMarkSpeed);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getinputpointer(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pPosition)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pPosition == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pPosition = pIRTCContext->GetInputPointer();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getrtcversion(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 * pRTCVersion, LibMCDriver_ScanLab_uint32 * pRTCType, LibMCDriver_ScanLab_uint32 * pDLLVersion, LibMCDriver_ScanLab_uint32 * pHEXVersion, LibMCDriver_ScanLab_uint32 * pBIOSVersion)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (!pRTCVersion)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pRTCType)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pDLLVersion)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pHEXVersion)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pBIOSVersion)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->GetRTCVersion(*pRTCVersion, *pRTCType, *pDLLVersion, *pHEXVersion, *pBIOSVersion);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setcommunicationtimeouts(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dInitialTimeout, LibMCDriver_ScanLab_double dMaxTimeout, LibMCDriver_ScanLab_double dMultiplier)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetCommunicationTimeouts(dInitialTimeout, dMaxTimeout, dMultiplier);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getcommunicationtimeouts(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double * pInitialTimeout, LibMCDriver_ScanLab_double * pMaxTimeout, LibMCDriver_ScanLab_double * pMultiplier)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (!pInitialTimeout)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMaxTimeout)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMultiplier)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->GetCommunicationTimeouts(*pInitialTimeout, *pMaxTimeout, *pMultiplier);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_initializeforoie(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nSignalChannelsBufferSize, const LibMCDriver_ScanLab_uint32 * pSignalChannelsBuffer, eLibMCDriver_ScanLabOIEOperationMode eOperationMode)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pSignalChannelsBuffer) && (nSignalChannelsBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->InitializeForOIE(nSignalChannelsBufferSize, pSignalChannelsBuffer, eOperationMode);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enableoie(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableOIE();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disableoie(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableOIE();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_startoiemeasurement(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->StartOIEMeasurement();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_startoiemeasurementex(LibMCDriver_ScanLab_RTCContext pRTCContext, bool bLaserOnTrigger)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->StartOIEMeasurementEx(bLaserOnTrigger);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_stopoiemeasurement(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->StopOIEMeasurement();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setoiepidmode(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nOIEPIDIndex)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetOIEPIDMode(nOIEPIDIndex);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enableoiepidcontrol(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableOIEPIDControl();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disableoiepidcontrol(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableOIEPIDControl();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_clearoiemeasurementtags(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->ClearOIEMeasurementTags();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enableoiemeasurementtagging(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableOIEMeasurementTagging();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disableoiemeasurementtagging(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableOIEMeasurementTagging();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_mapoiemeasurementtag(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nMeasurementTag, LibMCDriver_ScanLab_uint32 * pPartID, LibMCDriver_ScanLab_uint32 * pProfileID, LibMCDriver_ScanLab_uint32 * pSegmentID, LibMCDriver_ScanLab_uint32 * pVectorID)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (!pPartID)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pProfileID)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pSegmentID)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pVectorID)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->MapOIEMeasurementTag(nMeasurementTag, *pPartID, *pProfileID, *pSegmentID, *pVectorID);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disableskywriting(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableSkyWriting();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enableskywritingmode1(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTimelag, LibMCDriver_ScanLab_int64 nLaserOnShift, LibMCDriver_ScanLab_int64 nNPrev, LibMCDriver_ScanLab_int64 nNPost)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableSkyWritingMode1(dTimelag, nLaserOnShift, nNPrev, nNPost);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enableskywritingmode2(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTimelag, LibMCDriver_ScanLab_int64 nLaserOnShift, LibMCDriver_ScanLab_int64 nNPrev, LibMCDriver_ScanLab_int64 nNPost)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableSkyWritingMode2(dTimelag, nLaserOnShift, nNPrev, nNPost);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enableskywritingmode3(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTimelag, LibMCDriver_ScanLab_int64 nLaserOnShift, LibMCDriver_ScanLab_int64 nNPrev, LibMCDriver_ScanLab_int64 nNPost, LibMCDriver_ScanLab_double dLimit)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableSkyWritingMode3(dTimelag, nLaserOnShift, nNPrev, nNPost, dLimit);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enableskywritingmode4(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dTimelag, LibMCDriver_ScanLab_int64 nLaserOnShift, LibMCDriver_ScanLab_int64 nNPrev, LibMCDriver_ScanLab_int64 nNPost, LibMCDriver_ScanLab_double dLimit)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableSkyWritingMode4(dTimelag, nLaserOnShift, nNPrev, nNPost, dLimit);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_settransformationangle(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dAngleInDegrees)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetTransformationAngle(dAngleInDegrees);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_settransformationscale(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dScaleFactor)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetTransformationScale(dScaleFactor);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_settransformationoffset(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nOffsetX, LibMCDriver_ScanLab_int32 nOffsetY)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetTransformationOffset(nOffsetX, nOffsetY);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_settransformationmatrix(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dM11, LibMCDriver_ScanLab_double dM12, LibMCDriver_ScanLab_double dM21, LibMCDriver_ScanLab_double dM22)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetTransformationMatrix(dM11, dM12, dM21, dM22);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_preparerecording(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->PrepareRecording();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enablerecording(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableRecording();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disablerecording(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableRecording();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_executelistwithrecording(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nListIndex, LibMCDriver_ScanLab_uint32 nPosition)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->ExecuteListWithRecording(nListIndex, nPosition);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enabletimelagcompensation(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableTimelagCompensation(nTimeLagXYInMicroseconds, nTimeLagZInMicroseconds);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disabletimelagcompensation(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableTimelagCompensation();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enablemarkonthefly2d(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dScaleXInMMperEncoderStep, LibMCDriver_ScanLab_double dScaleYInMMperEncoderStep)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableMarkOnTheFly2D(dScaleXInMMperEncoderStep, dScaleYInMMperEncoderStep);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disablemarkonthefly2d(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableMarkOnTheFly2D();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_markonthefly2disenabled(LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pIsEnabled)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pIsEnabled == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pIsEnabled = pIRTCContext->MarkOnTheFly2DIsEnabled();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_get2dmarkontheflyposition(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 * pPositionX, LibMCDriver_ScanLab_int32 * pPositionY)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (!pPositionX)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pPositionY)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->Get2DMarkOnTheFlyPosition(*pPositionX, *pPositionY);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_checkontheflyerror(LibMCDriver_ScanLab_RTCContext pRTCContext, bool bFailIfError, LibMCDriver_ScanLab_uint32 * pErrorCode)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pErrorCode == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pErrorCode = pIRTCContext->CheckOnTheFlyError(bFailIfError);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_laserpowercalibrationisenabled(LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pCalibrationEnabled)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pCalibrationEnabled == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pCalibrationEnabled = pIRTCContext->LaserPowerCalibrationIsEnabled();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_laserpowercalibrationislinear(LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pCalibrationIsLinear)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pCalibrationIsLinear == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pCalibrationIsLinear = pIRTCContext->LaserPowerCalibrationIsLinear();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_clearlaserpowercalibration(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->ClearLaserPowerCalibration();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_getlaserpowercalibration(LibMCDriver_ScanLab_RTCContext pRTCContext, const LibMCDriver_ScanLab_uint64 nCalibrationPointsBufferSize, LibMCDriver_ScanLab_uint64* pCalibrationPointsNeededCount, sLibMCDriver_ScanLabLaserCalibrationPoint * pCalibrationPointsBuffer)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ((!pCalibrationPointsBuffer) && !(pCalibrationPointsNeededCount))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->GetLaserPowerCalibration(nCalibrationPointsBufferSize, pCalibrationPointsNeededCount, pCalibrationPointsBuffer);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setlinearlaserpowercalibration(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dPowerOffsetInPercent, LibMCDriver_ScanLab_double dPowerOutputScaling)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetLinearLaserPowerCalibration(dPowerOffsetInPercent, dPowerOutputScaling);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setpiecewiselinearlaserpowercalibration(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint64 nCalibrationPointsBufferSize, const sLibMCDriver_ScanLabLaserCalibrationPoint * pCalibrationPointsBuffer)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if ( (!pCalibrationPointsBuffer) && (nCalibrationPointsBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetPiecewiseLinearLaserPowerCalibration(nCalibrationPointsBufferSize, pCalibrationPointsBuffer);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enablespatiallaserpowermodulation(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLabSpatialPowerModulationCallback pModulationCallback, LibMCDriver_ScanLab_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableSpatialLaserPowerModulation(pModulationCallback, pUserData);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disablepowermodulation(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisablePowerModulation();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enablelinesubdivision(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dLengthThreshold)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableLineSubdivision(dLengthThreshold);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disablelinesubdivision(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableLineSubdivision();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_readmultimcbsp(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nRegisterNo, LibMCDriver_ScanLab_int32 * pRegisterContent)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pRegisterContent == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pRegisterContent = pIRTCContext->ReadMultiMCBSP(nRegisterNo);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_createuartconnection(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nDesiredBaudRate, LibMCDriver_ScanLab_UARTConnection * pConnection)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pConnection == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseConnection(nullptr);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseConnection = pIRTCContext->CreateUARTConnection(nDesiredBaudRate);

		*pConnection = (IBase*)(pBaseConnection);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_enablescanahead(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nHeadNo, LibMCDriver_ScanLab_uint32 nTableNo)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->EnableScanAhead(nHeadNo, nTableNo);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_disablescanahead(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DisableScanAhead();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_activatescanaheadautodelays(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->ActivateScanAheadAutoDelays();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_deactivatescanaheadautodelays(LibMCDriver_ScanLab_RTCContext pRTCContext)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->DeactivateScanAheadAutoDelays();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_scanaheadautodelaysareactivated(LibMCDriver_ScanLab_RTCContext pRTCContext, bool * pActivated)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		if (pActivated == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pActivated = pIRTCContext->ScanAheadAutoDelaysAreActivated();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinmicroseconds(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_double dLaserOnShiftInMicroSeconds, LibMCDriver_ScanLab_double dLaserOffShiftInMicroSeconds)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetScanAheadLaserShiftsInMicroseconds(dLaserOnShiftInMicroSeconds, dLaserOffShiftInMicroSeconds);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinunits(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_int32 nLaserOnShift, LibMCDriver_ScanLab_int32 nLaserOffShift)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetScanAheadLaserShiftsInUnits(nLaserOnShift, nLaserOffShift);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtccontext_setscanaheadlineparameters(LibMCDriver_ScanLab_RTCContext pRTCContext, LibMCDriver_ScanLab_uint32 nCornerScale, LibMCDriver_ScanLab_uint32 nEndScale, LibMCDriver_ScanLab_uint32 nAccelerationScale)
{
	IBase* pIBaseClass = (IBase *)pRTCContext;

	try {
		IRTCContext* pIRTCContext = dynamic_cast<IRTCContext*>(pIBaseClass);
		if (!pIRTCContext)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIRTCContext->SetScanAheadLineParameters(nCornerScale, nEndScale, nAccelerationScale);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for RTCSelector
**************************************************************************************************************************/
LibMCDriver_ScanLabResult libmcdriver_scanlab_rtcselector_searchcards(LibMCDriver_ScanLab_RTCSelector pRTCSelector, const char * pIP, const char * pNetmask, LibMCDriver_ScanLab_uint32 nTimeout, LibMCDriver_ScanLab_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pRTCSelector;

	try {
		if (pIP == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pNetmask == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pCount == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sIP(pIP);
		std::string sNetmask(pNetmask);
		IRTCSelector* pIRTCSelector = dynamic_cast<IRTCSelector*>(pIBaseClass);
		if (!pIRTCSelector)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pCount = pIRTCSelector->SearchCards(sIP, sNetmask, nTimeout);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtcselector_searchcardsbyrange(LibMCDriver_ScanLab_RTCSelector pRTCSelector, const char * pStartIP, const char * pEndIP, LibMCDriver_ScanLab_uint32 nTimeout, LibMCDriver_ScanLab_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pRTCSelector;

	try {
		if (pStartIP == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pEndIP == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pCount == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sStartIP(pStartIP);
		std::string sEndIP(pEndIP);
		IRTCSelector* pIRTCSelector = dynamic_cast<IRTCSelector*>(pIBaseClass);
		if (!pIRTCSelector)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pCount = pIRTCSelector->SearchCardsByRange(sStartIP, sEndIP, nTimeout);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtcselector_getcardcount(LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pRTCSelector;

	try {
		if (pCount == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCSelector* pIRTCSelector = dynamic_cast<IRTCSelector*>(pIBaseClass);
		if (!pIRTCSelector)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pCount = pIRTCSelector->GetCardCount();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtcselector_getethernetcardcount(LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pRTCSelector;

	try {
		if (pCount == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IRTCSelector* pIRTCSelector = dynamic_cast<IRTCSelector*>(pIBaseClass);
		if (!pIRTCSelector)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pCount = pIRTCSelector->GetEthernetCardCount();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtcselector_acquirecard(LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 nNumber, LibMCDriver_ScanLab_RTCContext * pInstance)
{
	IBase* pIBaseClass = (IBase *)pRTCSelector;

	try {
		if (pInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		IRTCSelector* pIRTCSelector = dynamic_cast<IRTCSelector*>(pIBaseClass);
		if (!pIRTCSelector)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseInstance = pIRTCSelector->AcquireCard(nNumber);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtcselector_acquirecardbyserial(LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 nSerialNumber, LibMCDriver_ScanLab_RTCContext * pInstance)
{
	IBase* pIBaseClass = (IBase *)pRTCSelector;

	try {
		if (pInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		IRTCSelector* pIRTCSelector = dynamic_cast<IRTCSelector*>(pIBaseClass);
		if (!pIRTCSelector)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseInstance = pIRTCSelector->AcquireCardBySerial(nSerialNumber);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtcselector_acquireethernetcard(LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 nNumber, LibMCDriver_ScanLab_RTCContext * pInstance)
{
	IBase* pIBaseClass = (IBase *)pRTCSelector;

	try {
		if (pInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		IRTCSelector* pIRTCSelector = dynamic_cast<IRTCSelector*>(pIBaseClass);
		if (!pIRTCSelector)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseInstance = pIRTCSelector->AcquireEthernetCard(nNumber);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial(LibMCDriver_ScanLab_RTCSelector pRTCSelector, LibMCDriver_ScanLab_uint32 nSerialNumber, LibMCDriver_ScanLab_RTCContext * pInstance)
{
	IBase* pIBaseClass = (IBase *)pRTCSelector;

	try {
		if (pInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		IRTCSelector* pIRTCSelector = dynamic_cast<IRTCSelector*>(pIBaseClass);
		if (!pIRTCSelector)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseInstance = pIRTCSelector->AcquireEthernetCardBySerial(nSerialNumber);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Driver_ScanLab
**************************************************************************************************************************/
LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_loadsdk(LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab, const char * pResourceName)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab;

	try {
		if (pResourceName == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sResourceName(pResourceName);
		IDriver_ScanLab* pIDriver_ScanLab = dynamic_cast<IDriver_ScanLab*>(pIBaseClass);
		if (!pIDriver_ScanLab)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab->LoadSDK(sResourceName);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_loadcustomsdk(LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab, LibMCDriver_ScanLab_uint64 nScanlabDLLBufferSize, const LibMCDriver_ScanLab_uint8 * pScanlabDLLBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab;

	try {
		if ( (!pScanlabDLLBuffer) && (nScanlabDLLBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab* pIDriver_ScanLab = dynamic_cast<IDriver_ScanLab*>(pIBaseClass);
		if (!pIDriver_ScanLab)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab->LoadCustomSDK(nScanlabDLLBufferSize, pScanlabDLLBuffer);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_creatertcselector(LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab, LibMCDriver_ScanLab_RTCSelector * pInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab;

	try {
		if (pInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		IDriver_ScanLab* pIDriver_ScanLab = dynamic_cast<IDriver_ScanLab*>(pIBaseClass);
		if (!pIDriver_ScanLab)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseInstance = pIDriver_ScanLab->CreateRTCSelector();

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_enablejournaling(LibMCDriver_ScanLab_Driver_ScanLab pDriver_ScanLab)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab;

	try {
		IDriver_ScanLab* pIDriver_ScanLab = dynamic_cast<IDriver_ScanLab*>(pIBaseClass);
		if (!pIDriver_ScanLab)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab->EnableJournaling();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Driver_ScanLab_RTC6
**************************************************************************************************************************/
LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_settosimulationmode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->SetToSimulationMode();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_issimulationmode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, bool * pSimulationModeEnabled)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pSimulationModeEnabled == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pSimulationModeEnabled = pIDriver_ScanLab_RTC6->IsSimulationMode();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_isinitialized(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, bool * pIsInitialized)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pIsInitialized == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pIsInitialized = pIDriver_ScanLab_RTC6->IsInitialized();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_initialise(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pIP, const char * pNetmask, LibMCDriver_ScanLab_uint32 nTimeout, LibMCDriver_ScanLab_uint32 nSerialNumber)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pIP == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pNetmask == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sIP(pIP);
		std::string sNetmask(pNetmask);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->Initialise(sIP, sNetmask, nTimeout, nSerialNumber);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_initialisefromconfiguration(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pPresetName)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pPresetName == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sPresetName(pPresetName);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->InitialiseFromConfiguration(sPresetName);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_setcommunicationtimeouts(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_double dInitialTimeout, LibMCDriver_ScanLab_double dMaxTimeout, LibMCDriver_ScanLab_double dMultiplier)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->SetCommunicationTimeouts(dInitialTimeout, dMaxTimeout, dMultiplier);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_getipaddress(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const LibMCDriver_ScanLab_uint32 nIPAddressBufferSize, LibMCDriver_ScanLab_uint32* pIPAddressNeededChars, char * pIPAddressBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if ( (!pIPAddressBuffer) && !(pIPAddressNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sIPAddress("");
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIPAddressBuffer == nullptr);
		if (isCacheCall) {
			sIPAddress = pIDriver_ScanLab_RTC6->GetIPAddress();

			pIDriver_ScanLab_RTC6->_setCache (new ParameterCache_1<std::string> (sIPAddress));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver_ScanLab_RTC6->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (sIPAddress);
			pIDriver_ScanLab_RTC6->_setCache (nullptr);
		}
		
		if (pIPAddressNeededChars)
			*pIPAddressNeededChars = (LibMCDriver_ScanLab_uint32) (sIPAddress.size()+1);
		if (pIPAddressBuffer) {
			if (sIPAddress.size() >= nIPAddressBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iIPAddress = 0; iIPAddress < sIPAddress.size(); iIPAddress++)
				pIPAddressBuffer[iIPAddress] = sIPAddress[iIPAddress];
			pIPAddressBuffer[sIPAddress.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_getnetmask(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const LibMCDriver_ScanLab_uint32 nNetmaskBufferSize, LibMCDriver_ScanLab_uint32* pNetmaskNeededChars, char * pNetmaskBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if ( (!pNetmaskBuffer) && !(pNetmaskNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sNetmask("");
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNetmaskBuffer == nullptr);
		if (isCacheCall) {
			sNetmask = pIDriver_ScanLab_RTC6->GetNetmask();

			pIDriver_ScanLab_RTC6->_setCache (new ParameterCache_1<std::string> (sNetmask));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver_ScanLab_RTC6->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (sNetmask);
			pIDriver_ScanLab_RTC6->_setCache (nullptr);
		}
		
		if (pNetmaskNeededChars)
			*pNetmaskNeededChars = (LibMCDriver_ScanLab_uint32) (sNetmask.size()+1);
		if (pNetmaskBuffer) {
			if (sNetmask.size() >= nNetmaskBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iNetmask = 0; iNetmask < sNetmask.size(); iNetmask++)
				pNetmaskBuffer[iNetmask] = sNetmask[iNetmask];
			pNetmaskBuffer[sNetmask.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_getserialnumber(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_uint32 * pSerialNumber)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pSerialNumber == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pSerialNumber = pIDriver_ScanLab_RTC6->GetSerialNumber();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_getcontext(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_RTCContext * pContextInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pContextInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseContextInstance(nullptr);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseContextInstance = pIDriver_ScanLab_RTC6->GetContext();

		*pContextInstance = (IBase*)(pBaseContextInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_getselector(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_RTCSelector * pSelectorInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pSelectorInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseSelectorInstance(nullptr);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseSelectorInstance = pIDriver_ScanLab_RTC6->GetSelector();

		*pSelectorInstance = (IBase*)(pBaseSelectorInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_loadfirmware(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pFirmwareResource, const char * pFPGAResource, const char * pAuxiliaryResource)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pFirmwareResource == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pFPGAResource == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pAuxiliaryResource == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sFirmwareResource(pFirmwareResource);
		std::string sFPGAResource(pFPGAResource);
		std::string sAuxiliaryResource(pAuxiliaryResource);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->LoadFirmware(sFirmwareResource, sFPGAResource, sAuxiliaryResource);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_loadcustomfirmware(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_uint64 nFirmwareDataBufferSize, const LibMCDriver_ScanLab_uint8 * pFirmwareDataBuffer, LibMCDriver_ScanLab_uint64 nFPGADataBufferSize, const LibMCDriver_ScanLab_uint8 * pFPGADataBuffer, LibMCDriver_ScanLab_uint64 nAuxiliaryDataBufferSize, const LibMCDriver_ScanLab_uint8 * pAuxiliaryDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if ( (!pFirmwareDataBuffer) && (nFirmwareDataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if ( (!pFPGADataBuffer) && (nFPGADataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if ( (!pAuxiliaryDataBuffer) && (nAuxiliaryDataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->LoadCustomFirmware(nFirmwareDataBufferSize, pFirmwareDataBuffer, nFPGADataBufferSize, pFPGADataBuffer, nAuxiliaryDataBufferSize, pAuxiliaryDataBuffer);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_setcorrectionfile(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_uint64 nCorrectionFileBufferSize, const LibMCDriver_ScanLab_uint8 * pCorrectionFileBuffer, LibMCDriver_ScanLab_uint32 nTableNumber, LibMCDriver_ScanLab_uint32 nDimension, LibMCDriver_ScanLab_uint32 nTableNumberHeadA, LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if ( (!pCorrectionFileBuffer) && (nCorrectionFileBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->SetCorrectionFile(nCorrectionFileBufferSize, pCorrectionFileBuffer, nTableNumber, nDimension, nTableNumberHeadA, nTableNumberHeadB);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_configurelasermode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, eLibMCDriver_ScanLabLaserMode eLaserMode, eLibMCDriver_ScanLabLaserPort eLaserPort, LibMCDriver_ScanLab_double dMaxLaserPower, bool bFinishLaserPulseAfterOn, bool bPhaseShiftOfLaserSignal, bool bLaserOnSignalLowActive, bool bLaserHalfSignalsLowActive, bool bSetDigitalInOneHighActive, bool bOutputSynchronizationActive)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->ConfigureLaserMode(eLaserMode, eLaserPort, dMaxLaserPower, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_configuredelays(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_double dLaserOnDelay, LibMCDriver_ScanLab_double dLaserOffDelay, LibMCDriver_ScanLab_double dMarkDelay, LibMCDriver_ScanLab_double dJumpDelay, LibMCDriver_ScanLab_double dPolygonDelay)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->ConfigureDelays(dLaserOnDelay, dLaserOffDelay, dMarkDelay, dJumpDelay, dPolygonDelay);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_setoierecordingmode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, eLibMCDriver_ScanLabOIERecordingMode eRecordingMode)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->SetOIERecordingMode(eRecordingMode);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_getoierecordingmode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, eLibMCDriver_ScanLabOIERecordingMode * pRecordingMode)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pRecordingMode == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pRecordingMode = pIDriver_ScanLab_RTC6->GetOIERecordingMode();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_enableattributefilter(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pNameSpace, const char * pAttributeName, LibMCDriver_ScanLab_int64 nAttributeValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pAttributeName == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sAttributeName(pAttributeName);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->EnableAttributeFilter(sNameSpace, sAttributeName, nAttributeValue);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_disableattributefilter(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->DisableAttributeFilter();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_drawlayer(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, const char * pStreamUUID, LibMCDriver_ScanLab_uint32 nLayerIndex)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (pStreamUUID == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sStreamUUID(pStreamUUID);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->DrawLayer(sStreamUUID, nLayerIndex);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_getcommunicationtimeouts(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_double * pInitialTimeout, LibMCDriver_ScanLab_double * pMaxTimeout, LibMCDriver_ScanLab_double * pMultiplier)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		if (!pInitialTimeout)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMaxTimeout)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMultiplier)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->GetCommunicationTimeouts(*pInitialTimeout, *pMaxTimeout, *pMultiplier);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_enabletimelagcompensation(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6, LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->EnableTimelagCompensation(nTimeLagXYInMicroseconds, nTimeLagZInMicroseconds);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6_disabletimelagcompensation(LibMCDriver_ScanLab_Driver_ScanLab_RTC6 pDriver_ScanLab_RTC6)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6;

	try {
		IDriver_ScanLab_RTC6* pIDriver_ScanLab_RTC6 = dynamic_cast<IDriver_ScanLab_RTC6*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6->DisableTimelagCompensation();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Driver_ScanLab_RTC6xN
**************************************************************************************************************************/
LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_settosimulationmode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->SetToSimulationMode();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_issimulationmode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, bool * pSimulationModeEnabled)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pSimulationModeEnabled == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pSimulationModeEnabled = pIDriver_ScanLab_RTC6xN->IsSimulationMode();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_isinitialized(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, bool * pIsInitialized)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pIsInitialized == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pIsInitialized = pIDriver_ScanLab_RTC6xN->IsInitialized();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_scannerisinitialized(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, bool * pIsInitialized)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pIsInitialized == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pIsInitialized = pIDriver_ScanLab_RTC6xN->ScannerIsInitialized(nScannerIndex);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_getscannercount(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 * pNumberOfScanners)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pNumberOfScanners == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pNumberOfScanners = pIDriver_ScanLab_RTC6xN->GetScannerCount();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescanner(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const char * pIP, const char * pNetmask, LibMCDriver_ScanLab_uint32 nTimeout, LibMCDriver_ScanLab_uint32 nSerialNumber, LibMCDriver_ScanLab_uint32 nLaserIndex)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pIP == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pNetmask == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sIP(pIP);
		std::string sNetmask(pNetmask);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->InitialiseScanner(nScannerIndex, sIP, sNetmask, nTimeout, nSerialNumber, nLaserIndex);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescannerfromconfiguration(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const char * pPresetName)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pPresetName == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sPresetName(pPresetName);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->InitialiseScannerFromConfiguration(nScannerIndex, sPresetName);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_getipaddress(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_uint32 nIPAddressBufferSize, LibMCDriver_ScanLab_uint32* pIPAddressNeededChars, char * pIPAddressBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if ( (!pIPAddressBuffer) && !(pIPAddressNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sIPAddress("");
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIPAddressBuffer == nullptr);
		if (isCacheCall) {
			sIPAddress = pIDriver_ScanLab_RTC6xN->GetIPAddress(nScannerIndex);

			pIDriver_ScanLab_RTC6xN->_setCache (new ParameterCache_1<std::string> (sIPAddress));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver_ScanLab_RTC6xN->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (sIPAddress);
			pIDriver_ScanLab_RTC6xN->_setCache (nullptr);
		}
		
		if (pIPAddressNeededChars)
			*pIPAddressNeededChars = (LibMCDriver_ScanLab_uint32) (sIPAddress.size()+1);
		if (pIPAddressBuffer) {
			if (sIPAddress.size() >= nIPAddressBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iIPAddress = 0; iIPAddress < sIPAddress.size(); iIPAddress++)
				pIPAddressBuffer[iIPAddress] = sIPAddress[iIPAddress];
			pIPAddressBuffer[sIPAddress.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_getnetmask(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const LibMCDriver_ScanLab_uint32 nNetmaskBufferSize, LibMCDriver_ScanLab_uint32* pNetmaskNeededChars, char * pNetmaskBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if ( (!pNetmaskBuffer) && !(pNetmaskNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sNetmask("");
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNetmaskBuffer == nullptr);
		if (isCacheCall) {
			sNetmask = pIDriver_ScanLab_RTC6xN->GetNetmask(nScannerIndex);

			pIDriver_ScanLab_RTC6xN->_setCache (new ParameterCache_1<std::string> (sNetmask));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver_ScanLab_RTC6xN->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
			cache->retrieveData (sNetmask);
			pIDriver_ScanLab_RTC6xN->_setCache (nullptr);
		}
		
		if (pNetmaskNeededChars)
			*pNetmaskNeededChars = (LibMCDriver_ScanLab_uint32) (sNetmask.size()+1);
		if (pNetmaskBuffer) {
			if (sNetmask.size() >= nNetmaskBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iNetmask = 0; iNetmask < sNetmask.size(); iNetmask++)
				pNetmaskBuffer[iNetmask] = sNetmask[iNetmask];
			pNetmaskBuffer[sNetmask.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_getserialnumber(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint32 * pSerialNumber)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pSerialNumber == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pSerialNumber = pIDriver_ScanLab_RTC6xN->GetSerialNumber(nScannerIndex);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_getlaserindex(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint32 * pLaserIndex)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pLaserIndex == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pLaserIndex = pIDriver_ScanLab_RTC6xN->GetLaserIndex(nScannerIndex);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_getselector(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_RTCSelector * pSelectorInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pSelectorInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseSelectorInstance(nullptr);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseSelectorInstance = pIDriver_ScanLab_RTC6xN->GetSelector();

		*pSelectorInstance = (IBase*)(pBaseSelectorInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_getcontext(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_RTCContext * pContextInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pContextInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pBaseContextInstance(nullptr);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pBaseContextInstance = pIDriver_ScanLab_RTC6xN->GetContext(nScannerIndex);

		*pContextInstance = (IBase*)(pBaseContextInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_loadfirmware(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, const char * pFirmwareResource, const char * pFPGAResource, const char * pAuxiliaryResource)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pFirmwareResource == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pFPGAResource == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pAuxiliaryResource == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sFirmwareResource(pFirmwareResource);
		std::string sFPGAResource(pFPGAResource);
		std::string sAuxiliaryResource(pAuxiliaryResource);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->LoadFirmware(nScannerIndex, sFirmwareResource, sFPGAResource, sAuxiliaryResource);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_loadcustomfirmware(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint64 nFirmwareDataBufferSize, const LibMCDriver_ScanLab_uint8 * pFirmwareDataBuffer, LibMCDriver_ScanLab_uint64 nFPGADataBufferSize, const LibMCDriver_ScanLab_uint8 * pFPGADataBuffer, LibMCDriver_ScanLab_uint64 nAuxiliaryDataBufferSize, const LibMCDriver_ScanLab_uint8 * pAuxiliaryDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if ( (!pFirmwareDataBuffer) && (nFirmwareDataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if ( (!pFPGADataBuffer) && (nFPGADataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if ( (!pAuxiliaryDataBuffer) && (nAuxiliaryDataBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->LoadCustomFirmware(nScannerIndex, nFirmwareDataBufferSize, pFirmwareDataBuffer, nFPGADataBufferSize, pFPGADataBuffer, nAuxiliaryDataBufferSize, pAuxiliaryDataBuffer);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_setcorrectionfile(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint64 nCorrectionFileBufferSize, const LibMCDriver_ScanLab_uint8 * pCorrectionFileBuffer, LibMCDriver_ScanLab_uint32 nTableNumber, LibMCDriver_ScanLab_uint32 nDimension, LibMCDriver_ScanLab_uint32 nTableNumberHeadA, LibMCDriver_ScanLab_uint32 nTableNumberHeadB)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if ( (!pCorrectionFileBuffer) && (nCorrectionFileBufferSize>0))
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->SetCorrectionFile(nScannerIndex, nCorrectionFileBufferSize, pCorrectionFileBuffer, nTableNumber, nDimension, nTableNumberHeadA, nTableNumberHeadB);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_configurelasermode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, eLibMCDriver_ScanLabLaserMode eLaserMode, eLibMCDriver_ScanLabLaserPort eLaserPort, LibMCDriver_ScanLab_double dMaxLaserPower, bool bFinishLaserPulseAfterOn, bool bPhaseShiftOfLaserSignal, bool bLaserOnSignalLowActive, bool bLaserHalfSignalsLowActive, bool bSetDigitalInOneHighActive, bool bOutputSynchronizationActive)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->ConfigureLaserMode(nScannerIndex, eLaserMode, eLaserPort, dMaxLaserPower, bFinishLaserPulseAfterOn, bPhaseShiftOfLaserSignal, bLaserOnSignalLowActive, bLaserHalfSignalsLowActive, bSetDigitalInOneHighActive, bOutputSynchronizationActive);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_configuredelays(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_double dLaserOnDelay, LibMCDriver_ScanLab_double dLaserOffDelay, LibMCDriver_ScanLab_double dMarkDelay, LibMCDriver_ScanLab_double dJumpDelay, LibMCDriver_ScanLab_double dPolygonDelay)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->ConfigureDelays(nScannerIndex, dLaserOnDelay, dLaserOffDelay, dMarkDelay, dJumpDelay, dPolygonDelay);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_setoierecordingmode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, eLibMCDriver_ScanLabOIERecordingMode eRecordingMode)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->SetOIERecordingMode(eRecordingMode);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_getoierecordingmode(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, eLibMCDriver_ScanLabOIERecordingMode * pRecordingMode)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pRecordingMode == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		*pRecordingMode = pIDriver_ScanLab_RTC6xN->GetOIERecordingMode();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_enableattributefilter(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, const char * pNameSpace, const char * pAttributeName, LibMCDriver_ScanLab_int64 nAttributeValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pAttributeName == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sAttributeName(pAttributeName);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->EnableAttributeFilter(sNameSpace, sAttributeName, nAttributeValue);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_disableattributefilter(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->DisableAttributeFilter();

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_drawlayer(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, const char * pStreamUUID, LibMCDriver_ScanLab_uint32 nLayerIndex, bool bFailIfNonAssignedDataExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (pStreamUUID == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sStreamUUID(pStreamUUID);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->DrawLayer(sStreamUUID, nLayerIndex, bFailIfNonAssignedDataExists);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_setcommunicationtimeouts(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_double dInitialTimeout, LibMCDriver_ScanLab_double dMaxTimeout, LibMCDriver_ScanLab_double dMultiplier)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->SetCommunicationTimeouts(nScannerIndex, dInitialTimeout, dMaxTimeout, dMultiplier);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_getcommunicationtimeouts(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_double * pInitialTimeout, LibMCDriver_ScanLab_double * pMaxTimeout, LibMCDriver_ScanLab_double * pMultiplier)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		if (!pInitialTimeout)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMaxTimeout)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMultiplier)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->GetCommunicationTimeouts(nScannerIndex, *pInitialTimeout, *pMaxTimeout, *pMultiplier);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_enabletimelagcompensation(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex, LibMCDriver_ScanLab_uint32 nTimeLagXYInMicroseconds, LibMCDriver_ScanLab_uint32 nTimeLagZInMicroseconds)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->EnableTimelagCompensation(nScannerIndex, nTimeLagXYInMicroseconds, nTimeLagZInMicroseconds);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_driver_scanlab_rtc6xn_disabletimelagcompensation(LibMCDriver_ScanLab_Driver_ScanLab_RTC6xN pDriver_ScanLab_RTC6xN, LibMCDriver_ScanLab_uint32 nScannerIndex)
{
	IBase* pIBaseClass = (IBase *)pDriver_ScanLab_RTC6xN;

	try {
		IDriver_ScanLab_RTC6xN* pIDriver_ScanLab_RTC6xN = dynamic_cast<IDriver_ScanLab_RTC6xN*>(pIBaseClass);
		if (!pIDriver_ScanLab_RTC6xN)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		pIDriver_ScanLab_RTC6xN->DisableTimelagCompensation(nScannerIndex);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDriver_ScanLabResult LibMCDriver_ScanLab::Impl::LibMCDriver_ScanLab_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdriver_scanlab_driver_configure") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_configure;
	if (sProcName == "libmcdriver_scanlab_driver_getname") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_getname;
	if (sProcName == "libmcdriver_scanlab_driver_gettype") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_gettype;
	if (sProcName == "libmcdriver_scanlab_driver_getversion") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_getversion;
	if (sProcName == "libmcdriver_scanlab_driver_queryparameters") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_queryparameters;
	if (sProcName == "libmcdriver_scanlab_driver_queryparametersex") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_queryparametersex;
	if (sProcName == "libmcdriver_scanlab_uartconnection_getbaudrate") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_uartconnection_getbaudrate;
	if (sProcName == "libmcdriver_scanlab_uartconnection_getconfiguredbaudrate") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_uartconnection_getconfiguredbaudrate;
	if (sProcName == "libmcdriver_scanlab_uartconnection_clearreceivebuffer") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_uartconnection_clearreceivebuffer;
	if (sProcName == "libmcdriver_scanlab_uartconnection_availablebytes") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_uartconnection_availablebytes;
	if (sProcName == "libmcdriver_scanlab_uartconnection_writestring") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_uartconnection_writestring;
	if (sProcName == "libmcdriver_scanlab_uartconnection_writedata") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_uartconnection_writedata;
	if (sProcName == "libmcdriver_scanlab_uartconnection_readdata") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_uartconnection_readdata;
	if (sProcName == "libmcdriver_scanlab_uartconnection_readline") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_uartconnection_readline;
	if (sProcName == "libmcdriver_scanlab_rtccontext_loadfirmware") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_loadfirmware;
	if (sProcName == "libmcdriver_scanlab_rtccontext_loadcorrectionfile") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_loadcorrectionfile;
	if (sProcName == "libmcdriver_scanlab_rtccontext_selectcorrectiontable") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_selectcorrectiontable;
	if (sProcName == "libmcdriver_scanlab_rtccontext_configurelists") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_configurelists;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setlasermode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setlasermode;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disableautolasercontrol") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disableautolasercontrol;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setlasercontrolparameters") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setlasercontrolparameters;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setlaserpulsesinbits") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setlaserpulsesinbits;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setlaserpulsesinmicroseconds;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setstandbyinbits") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setstandbyinbits;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setstandbyinmicroseconds;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getipaddress") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getipaddress;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getnetmask") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getnetmask;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getserialnumber") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getserialnumber;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getlaserindex") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getlaserindex;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setlaserorigin") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setlaserorigin;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getlaserorigin") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getlaserorigin;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setlaserfield") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setlaserfield;
	if (sProcName == "libmcdriver_scanlab_rtccontext_resetlaserfield") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_resetlaserfield;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enablerangechecking") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enablerangechecking;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disablerangechecking") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disablerangechecking;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getlaserfield") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getlaserfield;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setstartlist") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setstartlist;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setendoflist") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setendoflist;
	if (sProcName == "libmcdriver_scanlab_rtccontext_executelist") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_executelist;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setautochangepos") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setautochangepos;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setdelays") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setdelays;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setlaserdelaysinmicroseconds;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setlaserdelaysinbits") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setlaserdelaysinbits;
	if (sProcName == "libmcdriver_scanlab_rtccontext_drawpolyline") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_drawpolyline;
	if (sProcName == "libmcdriver_scanlab_rtccontext_drawpolylineoie") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_drawpolylineoie;
	if (sProcName == "libmcdriver_scanlab_rtccontext_drawhatches") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_drawhatches;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addsetpower") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addsetpower;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addsetanalogout") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addsetanalogout;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addsetdigitalout") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addsetdigitalout;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addsetpowerforpidcontrol") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addsetpowerforpidcontrol;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addsetjumpspeed") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addsetjumpspeed;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addsetmarkspeed") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addsetmarkspeed;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addjumpmovement") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addjumpmovement;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addmarkmovement") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addmarkmovement;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addtimedmarkmovement") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addtimedmarkmovement;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addfreevariable") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addfreevariable;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getcurrentfreevariable") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getcurrentfreevariable;
	if (sProcName == "libmcdriver_scanlab_rtccontext_gettimestamp") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_gettimestamp;
	if (sProcName == "libmcdriver_scanlab_rtccontext_stopexecution") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_stopexecution;
	if (sProcName == "libmcdriver_scanlab_rtccontext_drawhatchesoie") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_drawhatchesoie;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addlayertolist") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addlayertolist;
	if (sProcName == "libmcdriver_scanlab_rtccontext_waitforencoderx") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_waitforencoderx;
	if (sProcName == "libmcdriver_scanlab_rtccontext_waitforencodery") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_waitforencodery;
	if (sProcName == "libmcdriver_scanlab_rtccontext_waitforencoderxsteps") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_waitforencoderxsteps;
	if (sProcName == "libmcdriver_scanlab_rtccontext_waitforencoderysteps") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_waitforencoderysteps;
	if (sProcName == "libmcdriver_scanlab_rtccontext_addcustomdelay") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_addcustomdelay;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getcorrectionfactor") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getcorrectionfactor;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getstatus") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getstatus;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getheadstatus") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getheadstatus;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getstatevalues") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getstatevalues;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getinputpointer") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getinputpointer;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getrtcversion") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getrtcversion;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setcommunicationtimeouts") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setcommunicationtimeouts;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getcommunicationtimeouts") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getcommunicationtimeouts;
	if (sProcName == "libmcdriver_scanlab_rtccontext_initializeforoie") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_initializeforoie;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enableoie") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enableoie;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disableoie") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disableoie;
	if (sProcName == "libmcdriver_scanlab_rtccontext_startoiemeasurement") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_startoiemeasurement;
	if (sProcName == "libmcdriver_scanlab_rtccontext_startoiemeasurementex") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_startoiemeasurementex;
	if (sProcName == "libmcdriver_scanlab_rtccontext_stopoiemeasurement") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_stopoiemeasurement;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setoiepidmode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setoiepidmode;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enableoiepidcontrol") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enableoiepidcontrol;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disableoiepidcontrol") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disableoiepidcontrol;
	if (sProcName == "libmcdriver_scanlab_rtccontext_clearoiemeasurementtags") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_clearoiemeasurementtags;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enableoiemeasurementtagging") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enableoiemeasurementtagging;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disableoiemeasurementtagging") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disableoiemeasurementtagging;
	if (sProcName == "libmcdriver_scanlab_rtccontext_mapoiemeasurementtag") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_mapoiemeasurementtag;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disableskywriting") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disableskywriting;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enableskywritingmode1") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enableskywritingmode1;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enableskywritingmode2") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enableskywritingmode2;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enableskywritingmode3") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enableskywritingmode3;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enableskywritingmode4") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enableskywritingmode4;
	if (sProcName == "libmcdriver_scanlab_rtccontext_settransformationangle") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_settransformationangle;
	if (sProcName == "libmcdriver_scanlab_rtccontext_settransformationscale") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_settransformationscale;
	if (sProcName == "libmcdriver_scanlab_rtccontext_settransformationoffset") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_settransformationoffset;
	if (sProcName == "libmcdriver_scanlab_rtccontext_settransformationmatrix") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_settransformationmatrix;
	if (sProcName == "libmcdriver_scanlab_rtccontext_preparerecording") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_preparerecording;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enablerecording") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enablerecording;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disablerecording") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disablerecording;
	if (sProcName == "libmcdriver_scanlab_rtccontext_executelistwithrecording") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_executelistwithrecording;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enabletimelagcompensation") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enabletimelagcompensation;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disabletimelagcompensation") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disabletimelagcompensation;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enablemarkonthefly2d") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enablemarkonthefly2d;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disablemarkonthefly2d") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disablemarkonthefly2d;
	if (sProcName == "libmcdriver_scanlab_rtccontext_markonthefly2disenabled") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_markonthefly2disenabled;
	if (sProcName == "libmcdriver_scanlab_rtccontext_get2dmarkontheflyposition") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_get2dmarkontheflyposition;
	if (sProcName == "libmcdriver_scanlab_rtccontext_checkontheflyerror") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_checkontheflyerror;
	if (sProcName == "libmcdriver_scanlab_rtccontext_laserpowercalibrationisenabled") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_laserpowercalibrationisenabled;
	if (sProcName == "libmcdriver_scanlab_rtccontext_laserpowercalibrationislinear") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_laserpowercalibrationislinear;
	if (sProcName == "libmcdriver_scanlab_rtccontext_clearlaserpowercalibration") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_clearlaserpowercalibration;
	if (sProcName == "libmcdriver_scanlab_rtccontext_getlaserpowercalibration") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_getlaserpowercalibration;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setlinearlaserpowercalibration") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setlinearlaserpowercalibration;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setpiecewiselinearlaserpowercalibration") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setpiecewiselinearlaserpowercalibration;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enablespatiallaserpowermodulation") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enablespatiallaserpowermodulation;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disablepowermodulation") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disablepowermodulation;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enablelinesubdivision") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enablelinesubdivision;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disablelinesubdivision") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disablelinesubdivision;
	if (sProcName == "libmcdriver_scanlab_rtccontext_readmultimcbsp") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_readmultimcbsp;
	if (sProcName == "libmcdriver_scanlab_rtccontext_createuartconnection") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_createuartconnection;
	if (sProcName == "libmcdriver_scanlab_rtccontext_enablescanahead") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_enablescanahead;
	if (sProcName == "libmcdriver_scanlab_rtccontext_disablescanahead") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_disablescanahead;
	if (sProcName == "libmcdriver_scanlab_rtccontext_activatescanaheadautodelays") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_activatescanaheadautodelays;
	if (sProcName == "libmcdriver_scanlab_rtccontext_deactivatescanaheadautodelays") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_deactivatescanaheadautodelays;
	if (sProcName == "libmcdriver_scanlab_rtccontext_scanaheadautodelaysareactivated") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_scanaheadautodelaysareactivated;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinmicroseconds") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinmicroseconds;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinunits") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setscanaheadlasershiftsinunits;
	if (sProcName == "libmcdriver_scanlab_rtccontext_setscanaheadlineparameters") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtccontext_setscanaheadlineparameters;
	if (sProcName == "libmcdriver_scanlab_rtcselector_searchcards") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtcselector_searchcards;
	if (sProcName == "libmcdriver_scanlab_rtcselector_searchcardsbyrange") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtcselector_searchcardsbyrange;
	if (sProcName == "libmcdriver_scanlab_rtcselector_getcardcount") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtcselector_getcardcount;
	if (sProcName == "libmcdriver_scanlab_rtcselector_getethernetcardcount") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtcselector_getethernetcardcount;
	if (sProcName == "libmcdriver_scanlab_rtcselector_acquirecard") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtcselector_acquirecard;
	if (sProcName == "libmcdriver_scanlab_rtcselector_acquirecardbyserial") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtcselector_acquirecardbyserial;
	if (sProcName == "libmcdriver_scanlab_rtcselector_acquireethernetcard") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtcselector_acquireethernetcard;
	if (sProcName == "libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_rtcselector_acquireethernetcardbyserial;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_loadsdk") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_loadsdk;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_loadcustomsdk") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_loadcustomsdk;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_creatertcselector") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_creatertcselector;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_enablejournaling") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_enablejournaling;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_settosimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_settosimulationmode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_issimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_issimulationmode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_isinitialized") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_isinitialized;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_initialise") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_initialise;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_initialisefromconfiguration") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_initialisefromconfiguration;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_setcommunicationtimeouts") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_setcommunicationtimeouts;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_getipaddress") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_getipaddress;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_getnetmask") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_getnetmask;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_getserialnumber") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_getserialnumber;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_getcontext") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_getcontext;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_getselector") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_getselector;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_loadfirmware") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_loadfirmware;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_loadcustomfirmware") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_loadcustomfirmware;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_setcorrectionfile") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_setcorrectionfile;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_configurelasermode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_configurelasermode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_configuredelays") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_configuredelays;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_setoierecordingmode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_setoierecordingmode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_getoierecordingmode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_getoierecordingmode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_enableattributefilter") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_enableattributefilter;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_disableattributefilter") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_disableattributefilter;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_drawlayer") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_drawlayer;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_getcommunicationtimeouts") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_getcommunicationtimeouts;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_enabletimelagcompensation") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_enabletimelagcompensation;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6_disabletimelagcompensation") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6_disabletimelagcompensation;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_settosimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_settosimulationmode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_issimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_issimulationmode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_isinitialized") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_isinitialized;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_scannerisinitialized") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_scannerisinitialized;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_getscannercount") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_getscannercount;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescanner") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescanner;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescannerfromconfiguration") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_initialisescannerfromconfiguration;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_getipaddress") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_getipaddress;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_getnetmask") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_getnetmask;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_getserialnumber") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_getserialnumber;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_getlaserindex") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_getlaserindex;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_getselector") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_getselector;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_getcontext") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_getcontext;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_loadfirmware") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_loadfirmware;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_loadcustomfirmware") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_loadcustomfirmware;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_setcorrectionfile") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_setcorrectionfile;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_configurelasermode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_configurelasermode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_configuredelays") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_configuredelays;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_setoierecordingmode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_setoierecordingmode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_getoierecordingmode") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_getoierecordingmode;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_enableattributefilter") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_enableattributefilter;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_disableattributefilter") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_disableattributefilter;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_drawlayer") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_drawlayer;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_setcommunicationtimeouts") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_setcommunicationtimeouts;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_getcommunicationtimeouts") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_getcommunicationtimeouts;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_enabletimelagcompensation") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_enabletimelagcompensation;
	if (sProcName == "libmcdriver_scanlab_driver_scanlab_rtc6xn_disabletimelagcompensation") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_driver_scanlab_rtc6xn_disabletimelagcompensation;
	if (sProcName == "libmcdriver_scanlab_getversion") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_getversion;
	if (sProcName == "libmcdriver_scanlab_getlasterror") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_getlasterror;
	if (sProcName == "libmcdriver_scanlab_releaseinstance") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_releaseinstance;
	if (sProcName == "libmcdriver_scanlab_acquireinstance") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_acquireinstance;
	if (sProcName == "libmcdriver_scanlab_injectcomponent") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_injectcomponent;
	if (sProcName == "libmcdriver_scanlab_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_getsymbollookupmethod;
	if (sProcName == "libmcdriver_scanlab_createdriver") 
		*ppProcAddress = (void*) &libmcdriver_scanlab_createdriver;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDRIVER_SCANLAB_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDRIVER_SCANLAB_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDriver_ScanLabResult libmcdriver_scanlab_getversion(LibMCDriver_ScanLab_uint32 * pMajor, LibMCDriver_ScanLab_uint32 * pMinor, LibMCDriver_ScanLab_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_getlasterror(LibMCDriver_ScanLab_Base pInstance, const LibMCDriver_ScanLab_uint32 nErrorMessageBufferSize, LibMCDriver_ScanLab_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCDriver_ScanLab_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_releaseinstance(LibMCDriver_ScanLab_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_acquireinstance(LibMCDriver_ScanLab_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_injectcomponent(const char * pNameSpace, LibMCDriver_ScanLab_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCEnv") {
			if (CWrapper::sPLibMCEnvWrapper.get() != nullptr) {
				throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCDriver_ScanLabInterfaceException(LIBMCDRIVER_SCANLAB_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_getsymbollookupmethod(LibMCDriver_ScanLab_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCDriver_ScanLab::Impl::LibMCDriver_ScanLab_GetProcAddress;
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ScanLabResult libmcdriver_scanlab_createdriver(const char * pName, const char * pType, LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCDriver_ScanLab_Driver * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pType == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		if (pInstance == nullptr)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sType(pType);
		LibMCEnv::PDriverEnvironment pIDriverEnvironment = std::make_shared<LibMCEnv::CDriverEnvironment>(CWrapper::sPLibMCEnvWrapper.get(), pDriverEnvironment);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverEnvironment.get());
		if (!pIDriverEnvironment)
			throw ELibMCDriver_ScanLabInterfaceException (LIBMCDRIVER_SCANLAB_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDriver(sName, sType, pIDriverEnvironment);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_SCANLAB_SUCCESS;
	}
	catch (ELibMCDriver_ScanLabInterfaceException & Exception) {
		return handleLibMCDriver_ScanLabException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


