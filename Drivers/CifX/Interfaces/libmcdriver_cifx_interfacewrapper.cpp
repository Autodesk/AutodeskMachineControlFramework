/*++

Copyright (C) 2023 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of MC Driver cifX. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmcdriver_cifx_abi.hpp"
#include "libmcdriver_cifx_interfaces.hpp"
#include "libmcdriver_cifx_interfaceexception.hpp"

#include <map>

using namespace LibMCDriver_CifX::Impl;

LibMCDriver_CifXResult handleLibMCDriver_CifXException(IBase * pIBaseClass, ELibMCDriver_CifXInterfaceException & Exception)
{
	LibMCDriver_CifXResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_CifXResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDriver_CifXResult errorCode = LIBMCDRIVER_CIFX_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_CifXResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDriver_CifXResult errorCode = LIBMCDRIVER_CIFX_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Driver
**************************************************************************************************************************/
LibMCDriver_CifXResult libmcdriver_cifx_driver_configure(LibMCDriver_CifX_Driver pDriver, const char * pConfigurationString)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (pConfigurationString == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sConfigurationString(pConfigurationString);
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pIDriver->Configure(sConfigurationString);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_getname(LibMCDriver_CifX_Driver pDriver, const LibMCDriver_CifX_uint32 nNameBufferSize, LibMCDriver_CifX_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIDriver->GetName();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCDriver_CifX_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_gettype(LibMCDriver_CifX_Driver pDriver, const LibMCDriver_CifX_uint32 nTypeBufferSize, LibMCDriver_CifX_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sType("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIDriver->GetType();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIDriver->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (LibMCDriver_CifX_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_getversion(LibMCDriver_CifX_Driver pDriver, LibMCDriver_CifX_uint32 * pMajor, LibMCDriver_CifX_uint32 * pMinor, LibMCDriver_CifX_uint32 * pMicro, const LibMCDriver_CifX_uint32 nBuildBufferSize, LibMCDriver_CifX_uint32* pBuildNeededChars, char * pBuildBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (!pMajor)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if ( (!pBuildBuffer) && !(pBuildNeededChars) )
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sBuild("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetVersion(*pMajor, *pMinor, *pMicro, sBuild);

			pIDriver->_setCache (new ParameterCache_4<LibMCDriver_CifX_uint32, LibMCDriver_CifX_uint32, LibMCDriver_CifX_uint32, std::string> (*pMajor, *pMinor, *pMicro, sBuild));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<LibMCDriver_CifX_uint32, LibMCDriver_CifX_uint32, LibMCDriver_CifX_uint32, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
			cache->retrieveData (*pMajor, *pMinor, *pMicro, sBuild);
			pIDriver->_setCache (nullptr);
		}
		
		if (pBuildNeededChars)
			*pBuildNeededChars = (LibMCDriver_CifX_uint32) (sBuild.size()+1);
		if (pBuildBuffer) {
			if (sBuild.size() >= nBuildBufferSize)
				throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_BUFFERTOOSMALL);
			for (size_t iBuild = 0; iBuild < sBuild.size(); iBuild++)
				pBuildBuffer[iBuild] = sBuild[iBuild];
			pBuildBuffer[sBuild.size()] = 0;
		}
		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_getheaderinformation(LibMCDriver_CifX_Driver pDriver, const LibMCDriver_CifX_uint32 nNameSpaceBufferSize, LibMCDriver_CifX_uint32* pNameSpaceNeededChars, char * pNameSpaceBuffer, const LibMCDriver_CifX_uint32 nBaseNameBufferSize, LibMCDriver_CifX_uint32* pBaseNameNeededChars, char * pBaseNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameSpaceBuffer) && !(pNameSpaceNeededChars) )
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if ( (!pBaseNameBuffer) && !(pBaseNameNeededChars) )
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sNameSpace("");
		std::string sBaseName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameSpaceBuffer == nullptr) || (pBaseNameBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetHeaderInformation(sNameSpace, sBaseName);

			pIDriver->_setCache (new ParameterCache_2<std::string, std::string> (sNameSpace, sBaseName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
			cache->retrieveData (sNameSpace, sBaseName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameSpaceNeededChars)
			*pNameSpaceNeededChars = (LibMCDriver_CifX_uint32) (sNameSpace.size()+1);
		if (pNameSpaceBuffer) {
			if (sNameSpace.size() >= nNameSpaceBufferSize)
				throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_BUFFERTOOSMALL);
			for (size_t iNameSpace = 0; iNameSpace < sNameSpace.size(); iNameSpace++)
				pNameSpaceBuffer[iNameSpace] = sNameSpace[iNameSpace];
			pNameSpaceBuffer[sNameSpace.size()] = 0;
		}
		if (pBaseNameNeededChars)
			*pBaseNameNeededChars = (LibMCDriver_CifX_uint32) (sBaseName.size()+1);
		if (pBaseNameBuffer) {
			if (sBaseName.size() >= nBaseNameBufferSize)
				throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_BUFFERTOOSMALL);
			for (size_t iBaseName = 0; iBaseName < sBaseName.size(); iBaseName++)
				pBaseNameBuffer[iBaseName] = sBaseName[iBaseName];
			pBaseNameBuffer[sBaseName.size()] = 0;
		}
		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_queryparameters(LibMCDriver_CifX_Driver pDriver)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pIDriver->QueryParameters();

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BoardInformation
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Driver_CifX
**************************************************************************************************************************/
LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_settosimulationmode(LibMCDriver_CifX_Driver_CifX pDriver_CifX)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pIDriver_CifX->SetToSimulationMode();

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_issimulationmode(LibMCDriver_CifX_Driver_CifX pDriver_CifX, bool * pSimulationModeEnabled)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pSimulationModeEnabled == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		*pSimulationModeEnabled = pIDriver_CifX->IsSimulationMode();

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_setcustomsdkresource(LibMCDriver_CifX_Driver_CifX pDriver_CifX, const char * pResourceName)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pResourceName == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sResourceName(pResourceName);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pIDriver_CifX->SetCustomSDKResource(sResourceName);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_enumerateboards(LibMCDriver_CifX_Driver_CifX pDriver_CifX, LibMCDriver_CifX_uint32 * pBoardCount)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pBoardCount == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		*pBoardCount = pIDriver_CifX->EnumerateBoards();

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_getboardinformation(LibMCDriver_CifX_Driver_CifX pDriver_CifX, LibMCDriver_CifX_uint32 nBoardIndex, LibMCDriver_CifX_BoardInformation * pBoardInformationInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pBoardInformationInstance == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		IBase* pBaseBoardInformationInstance(nullptr);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pBaseBoardInformationInstance = pIDriver_CifX->GetBoardInformation(nBoardIndex);

		*pBoardInformationInstance = (IBase*)(pBaseBoardInformationInstance);
		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_connect(LibMCDriver_CifX_Driver_CifX pDriver_CifX)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pIDriver_CifX->Connect();

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_disconnect(LibMCDriver_CifX_Driver_CifX pDriver_CifX)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pIDriver_CifX->Disconnect();

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_isconnected(LibMCDriver_CifX_Driver_CifX pDriver_CifX, bool * pBoardsAreConnected)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pBoardsAreConnected == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		*pBoardsAreConnected = pIDriver_CifX->IsConnected();

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_valueexists(LibMCDriver_CifX_Driver_CifX pDriver_CifX, const char * pName, bool * pExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (pExists == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		*pExists = pIDriver_CifX->ValueExists(sName);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_writeintegervalue(LibMCDriver_CifX_Driver_CifX pDriver_CifX, const char * pName, LibMCDriver_CifX_int64 nValue, LibMCDriver_CifX_uint32 nTimeOutInMs)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pIDriver_CifX->WriteIntegerValue(sName, nValue, nTimeOutInMs);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_writeboolvalue(LibMCDriver_CifX_Driver_CifX pDriver_CifX, const char * pName, bool bValue, LibMCDriver_CifX_uint32 nTimeOutInMs)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pIDriver_CifX->WriteBoolValue(sName, bValue, nTimeOutInMs);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_writedoublevalue(LibMCDriver_CifX_Driver_CifX pDriver_CifX, const char * pName, LibMCDriver_CifX_double dValue, LibMCDriver_CifX_uint32 nTimeOutInMs)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		pIDriver_CifX->WriteDoubleValue(sName, dValue, nTimeOutInMs);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_readintegervalue(LibMCDriver_CifX_Driver_CifX pDriver_CifX, const char * pName, LibMCDriver_CifX_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_CifX->ReadIntegerValue(sName);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_readboolvalue(LibMCDriver_CifX_Driver_CifX pDriver_CifX, const char * pName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_CifX->ReadBoolValue(sName);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_driver_cifx_readdoublevalue(LibMCDriver_CifX_Driver_CifX pDriver_CifX, const char * pName, LibMCDriver_CifX_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_CifX;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IDriver_CifX* pIDriver_CifX = dynamic_cast<IDriver_CifX*>(pIBaseClass);
		if (!pIDriver_CifX)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_CifX->ReadDoubleValue(sName);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDriver_CifXResult LibMCDriver_CifX::Impl::LibMCDriver_CifX_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdriver_cifx_driver_configure") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_configure;
	if (sProcName == "libmcdriver_cifx_driver_getname") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_getname;
	if (sProcName == "libmcdriver_cifx_driver_gettype") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_gettype;
	if (sProcName == "libmcdriver_cifx_driver_getversion") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_getversion;
	if (sProcName == "libmcdriver_cifx_driver_getheaderinformation") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_getheaderinformation;
	if (sProcName == "libmcdriver_cifx_driver_queryparameters") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_queryparameters;
	if (sProcName == "libmcdriver_cifx_driver_cifx_settosimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_settosimulationmode;
	if (sProcName == "libmcdriver_cifx_driver_cifx_issimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_issimulationmode;
	if (sProcName == "libmcdriver_cifx_driver_cifx_setcustomsdkresource") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_setcustomsdkresource;
	if (sProcName == "libmcdriver_cifx_driver_cifx_enumerateboards") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_enumerateboards;
	if (sProcName == "libmcdriver_cifx_driver_cifx_getboardinformation") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_getboardinformation;
	if (sProcName == "libmcdriver_cifx_driver_cifx_connect") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_connect;
	if (sProcName == "libmcdriver_cifx_driver_cifx_disconnect") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_disconnect;
	if (sProcName == "libmcdriver_cifx_driver_cifx_isconnected") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_isconnected;
	if (sProcName == "libmcdriver_cifx_driver_cifx_valueexists") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_valueexists;
	if (sProcName == "libmcdriver_cifx_driver_cifx_writeintegervalue") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_writeintegervalue;
	if (sProcName == "libmcdriver_cifx_driver_cifx_writeboolvalue") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_writeboolvalue;
	if (sProcName == "libmcdriver_cifx_driver_cifx_writedoublevalue") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_writedoublevalue;
	if (sProcName == "libmcdriver_cifx_driver_cifx_readintegervalue") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_readintegervalue;
	if (sProcName == "libmcdriver_cifx_driver_cifx_readboolvalue") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_readboolvalue;
	if (sProcName == "libmcdriver_cifx_driver_cifx_readdoublevalue") 
		*ppProcAddress = (void*) &libmcdriver_cifx_driver_cifx_readdoublevalue;
	if (sProcName == "libmcdriver_cifx_getversion") 
		*ppProcAddress = (void*) &libmcdriver_cifx_getversion;
	if (sProcName == "libmcdriver_cifx_getlasterror") 
		*ppProcAddress = (void*) &libmcdriver_cifx_getlasterror;
	if (sProcName == "libmcdriver_cifx_releaseinstance") 
		*ppProcAddress = (void*) &libmcdriver_cifx_releaseinstance;
	if (sProcName == "libmcdriver_cifx_acquireinstance") 
		*ppProcAddress = (void*) &libmcdriver_cifx_acquireinstance;
	if (sProcName == "libmcdriver_cifx_injectcomponent") 
		*ppProcAddress = (void*) &libmcdriver_cifx_injectcomponent;
	if (sProcName == "libmcdriver_cifx_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdriver_cifx_getsymbollookupmethod;
	if (sProcName == "libmcdriver_cifx_createdriver") 
		*ppProcAddress = (void*) &libmcdriver_cifx_createdriver;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDRIVER_CIFX_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDRIVER_CIFX_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDriver_CifXResult libmcdriver_cifx_getversion(LibMCDriver_CifX_uint32 * pMajor, LibMCDriver_CifX_uint32 * pMinor, LibMCDriver_CifX_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_getlasterror(LibMCDriver_CifX_Base pInstance, const LibMCDriver_CifX_uint32 nErrorMessageBufferSize, LibMCDriver_CifX_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCDriver_CifX_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_releaseinstance(LibMCDriver_CifX_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_acquireinstance(LibMCDriver_CifX_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_injectcomponent(const char * pNameSpace, LibMCDriver_CifX_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCEnv") {
			if (CWrapper::sPLibMCEnvWrapper.get() != nullptr) {
				throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCDriver_CifXInterfaceException(LIBMCDRIVER_CIFX_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_getsymbollookupmethod(LibMCDriver_CifX_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCDriver_CifX::Impl::LibMCDriver_CifX_GetProcAddress;
		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_CifXResult libmcdriver_cifx_createdriver(const char * pName, const char * pType, LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCDriver_CifX_Driver * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (pType == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		if (pInstance == nullptr)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sType(pType);
		LibMCEnv::PDriverEnvironment pIDriverEnvironment = std::make_shared<LibMCEnv::CDriverEnvironment>(CWrapper::sPLibMCEnvWrapper.get(), pDriverEnvironment);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverEnvironment.get());
		if (!pIDriverEnvironment)
			throw ELibMCDriver_CifXInterfaceException (LIBMCDRIVER_CIFX_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDriver(sName, sType, pIDriverEnvironment);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_CIFX_SUCCESS;
	}
	catch (ELibMCDriver_CifXInterfaceException & Exception) {
		return handleLibMCDriver_CifXException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


