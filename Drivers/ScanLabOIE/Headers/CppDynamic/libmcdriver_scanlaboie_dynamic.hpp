/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver ScanLab Open Interface Extension

Interface version: 1.0.0

*/

#ifndef __LIBMCDRIVER_SCANLABOIE_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_SCANLABOIE_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_scanlaboie_types.hpp"
#include "libmcdriver_scanlaboie_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_ScanLabOIE {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class COIEDevice;
class CDeviceConfiguration;
class CDriver_ScanLab_OIE;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_ScanLabOIEWrapper;
typedef CBase CLibMCDriver_ScanLabOIEBase;
typedef CDriver CLibMCDriver_ScanLabOIEDriver;
typedef COIEDevice CLibMCDriver_ScanLabOIEOIEDevice;
typedef CDeviceConfiguration CLibMCDriver_ScanLabOIEDeviceConfiguration;
typedef CDriver_ScanLab_OIE CLibMCDriver_ScanLabOIEDriver_ScanLab_OIE;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<COIEDevice> POIEDevice;
typedef std::shared_ptr<CDeviceConfiguration> PDeviceConfiguration;
typedef std::shared_ptr<CDriver_ScanLab_OIE> PDriver_ScanLab_OIE;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_ScanLabOIEWrapper;
typedef PBase PLibMCDriver_ScanLabOIEBase;
typedef PDriver PLibMCDriver_ScanLabOIEDriver;
typedef POIEDevice PLibMCDriver_ScanLabOIEOIEDevice;
typedef PDeviceConfiguration PLibMCDriver_ScanLabOIEDeviceConfiguration;
typedef PDriver_ScanLab_OIE PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_ScanLabOIEHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_ScanLabOIEException 
**************************************************************************************************************************/
class ELibMCDriver_ScanLabOIEException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_ScanLabOIEResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_ScanLabOIEException(LibMCDriver_ScanLabOIEResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_ScanLabOIEResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLABOIE_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_SCANLABOIE_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_SCANLABOIE_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERTYPE: return "INVALIDDRIVERTYPE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERNAME: return "INVALIDDRIVERNAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERENVIRONMENT: return "INVALIDDRIVERENVIRONMENT";
			case LIBMCDRIVER_SCANLABOIE_ERROR_SDKALREADYINITIALIZED: return "SDKALREADYINITIALIZED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSCANLABOIESDK: return "INVALIDSCANLABOIESDK";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICENOTAVAILABLEANYMORE: return "DEVICENOTAVAILABLEANYMORE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTADDDEVICE: return "COULDNOTADDDEVICE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEALREADYCONNECTED: return "DEVICEALREADYCONNECTED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEALREADYREMOVED: return "DEVICEALREADYREMOVED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICENOTCONNECTED: return "DEVICENOTCONNECTED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPCOUNTONDEVICE: return "INVALIDAPPCOUNTONDEVICE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPINDEX: return "INVALIDAPPINDEX";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPNAME: return "INVALIDAPPNAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPVERSION: return "INVALIDAPPVERSION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRESPONSETIMEOUT: return "INVALIDRESPONSETIMEOUT";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPPACKAGEBUFFER: return "INVALIDAPPPACKAGEBUFFER";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRESOURCENAME: return "INVALIDRESOURCENAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORELIBRESSLRESOURCE: return "COULDNOTSTORELIBRESSLRESOURCE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORELIBCRYPTORESOURCE: return "COULDNOTSTORELIBCRYPTORESOURCE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREQT5CORERESOURCE: return "COULDNOTSTOREQT5CORERESOURCE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREQT5NETWORKRESOURCE: return "COULDNOTSTOREQT5NETWORKRESOURCE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_SCANLABOIESDKNOTLOADED: return "SCANLABOIESDKNOTLOADED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDEVICENAME: return "INVALIDDEVICENAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEHASNOTBEENFOUND: return "DEVICEHASNOTBEENFOUND";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEISALREADYEXISTING: return "DEVICEISALREADYEXISTING";
			case LIBMCDRIVER_SCANLABOIE_ERROR_EMPTYDEVICENAME: return "EMPTYDEVICENAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDVALUESPERPACKET: return "INVALIDVALUESPERPACKET";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDBUFFERSIZE: return "INVALIDBUFFERSIZE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_PACKETISNOTRECORDING: return "PACKETISNOTRECORDING";
			case LIBMCDRIVER_SCANLABOIE_ERROR_TOOMANYVALUESINPACKET: return "TOOMANYVALUESINPACKET";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOTENOUGHVALUESINPACKET: return "NOTENOUGHVALUESINPACKET";
			case LIBMCDRIVER_SCANLABOIE_ERROR_BUFFEROVERFLOW: return "BUFFEROVERFLOW";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLABOIE_SUCCESS: return "success";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_SCANLABOIE_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_SCANLABOIE_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERTYPE: return "Invalid OIE Driver type";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERNAME: return "Invalid OIE Driver name";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERENVIRONMENT: return "Invalid OIE Driver environment";
			case LIBMCDRIVER_SCANLABOIE_ERROR_SDKALREADYINITIALIZED: return "SDK already initialized.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSCANLABOIESDK: return "Invalid Scanlab OIE SDK.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICENOTAVAILABLEANYMORE: return "Device not available anymore.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTADDDEVICE: return "Could not add device.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEALREADYCONNECTED: return "Device already connected.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEALREADYREMOVED: return "Device already removed.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICENOTCONNECTED: return "Device not connected.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPCOUNTONDEVICE: return "Invalid app count on device.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPINDEX: return "Invalid app index.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPNAME: return "Invalid app name.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPVERSION: return "Invalid app version.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRESPONSETIMEOUT: return "Invalid response timeout.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPPACKAGEBUFFER: return "Invalid app package buffer.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRESOURCENAME: return "Invalid resource name.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORELIBRESSLRESOURCE: return "Could not store LibreSSL resource.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORELIBCRYPTORESOURCE: return "Could not store LibCrypto resource.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREQT5CORERESOURCE: return "Could not store QT5Core resource.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREQT5NETWORKRESOURCE: return "Could not store QT5Network resource.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_SCANLABOIESDKNOTLOADED: return "Scanlab OIE SDK not loaded.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDEVICENAME: return "Invalid device name.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEHASNOTBEENFOUND: return "Device has not been found.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEISALREADYEXISTING: return "Device is already existing.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_EMPTYDEVICENAME: return "Empty device name.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDVALUESPERPACKET: return "Invalid values per packet.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDBUFFERSIZE: return "Invalid buffer size.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_PACKETISNOTRECORDING: return "Packet is not recording.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_TOOMANYVALUESINPACKET: return "Too many values in packet.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOTENOUGHVALUESINPACKET: return "Not enough values in packet.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_BUFFEROVERFLOW: return "Buffer overflow.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_ScanLabOIEInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_ScanLabOIEResult nResult);

	inline void GetVersion(LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLabOIE_pvoid pSymbolAddressMethod);
	inline LibMCDriver_ScanLabOIE_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_ScanLabOIEDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_ScanLabOIEResult checkBinaryVersion()
	{
		LibMCDriver_ScanLabOIE_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_SCANLABOIE_VERSION_MAJOR) {
			return LIBMCDRIVER_SCANLABOIE_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
	}
	LibMCDriver_ScanLabOIEResult initWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabOIEResult releaseWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabOIEResult loadWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_ScanLabOIEResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class COIEDevice;
	friend class CDeviceConfiguration;
	friend class CDriver_ScanLab_OIE;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_ScanLabOIEHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_ScanLabOIEResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_ScanLabOIEHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nMicro, std::string & sBuild);
	inline void GetHeaderInformation(std::string & sNameSpace, std::string & sBaseName);
	inline void QueryParameters();
};
	
/*************************************************************************************************************************
 Class COIEDevice 
**************************************************************************************************************************/
class COIEDevice : public CBase {
public:
	
	/**
	* COIEDevice::COIEDevice - Constructor for OIEDevice class.
	*/
	COIEDevice(CWrapper* pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetDeviceName();
	inline void SetHostName(const std::string & sHostName);
	inline std::string GetHostName();
	inline void SetPort(const LibMCDriver_ScanLabOIE_uint32 nPort);
	inline LibMCDriver_ScanLabOIE_uint32 GetPort();
	inline bool IsConnected();
	inline LibMCDriver_ScanLabOIE_uint32 GetDeviceID();
	inline void Connect(const std::string & sUserName, const std::string & sPassword);
	inline void Disconnect();
	inline void RefreshAppList();
	inline LibMCDriver_ScanLabOIE_uint32 GetAppCount();
	inline std::string GetAppName(const LibMCDriver_ScanLabOIE_uint32 nIndex);
	inline void GetAppVersion(const LibMCDriver_ScanLabOIE_uint32 nIndex, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch);
	inline void GetAppInfo(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::string & sName, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch);
	inline void SetRTCCorrectionData(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & CorrectionDataBuffer);
	inline void StartAppByName(const std::string & sName, classParam<CDeviceConfiguration> pDeviceConfig);
	inline void StartAppByIndex(const LibMCDriver_ScanLabOIE_uint32 nIndex, classParam<CDeviceConfiguration> pDeviceConfig);
	inline void StartAppByMajorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, classParam<CDeviceConfiguration> pDeviceConfig);
	inline void StartAppByMinorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, const LibMCDriver_ScanLabOIE_uint32 nMinorVersion, classParam<CDeviceConfiguration> pDeviceConfig);
	inline void StopApp();
	inline bool AppIsRunning();
	inline void GetRunningApp(std::string & sName, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch);
	inline void InstallApp(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & AppPackageBuffer);
	inline void UninstallAppByName(const std::string & sName);
	inline void UninstallAppByIndex(const LibMCDriver_ScanLabOIE_uint32 nIndex);
	inline void UninstallAppByMajorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion);
	inline void UninstallAppByMinorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, const LibMCDriver_ScanLabOIE_uint32 nMinorVersion);
};
	
/*************************************************************************************************************************
 Class CDeviceConfiguration 
**************************************************************************************************************************/
class CDeviceConfiguration : public CBase {
public:
	
	/**
	* CDeviceConfiguration::CDeviceConfiguration - Constructor for DeviceConfiguration class.
	*/
	CDeviceConfiguration(CWrapper* pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline eRTCDeviceType GetDeviceType();
	inline LibMCDriver_ScanLabOIE_uint32 GetRTCSignalCount();
	inline LibMCDriver_ScanLabOIE_uint32 GetSensorSignalCount();
	inline void GetRTCSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & SignalIDsBuffer);
	inline void GetSensorSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & SignalIDsBuffer);
	inline std::string GetDeviceConfigurationString();
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLab_OIE 
**************************************************************************************************************************/
class CDriver_ScanLab_OIE : public CDriver {
public:
	
	/**
	* CDriver_ScanLab_OIE::CDriver_ScanLab_OIE - Constructor for Driver_ScanLab_OIE class.
	*/
	CDriver_ScanLab_OIE(CWrapper* pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline void SetDependencyResourceNames(const std::string & sLibSSLResourceName, const std::string & sLibCryptoResourceName, const std::string & sQT5CoreResourceName, const std::string & sQT5NetworkResourceName);
	inline void InitializeSDK(const std::string & sOIEResourceName);
	inline void InitializeCustomSDK(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & OIEDLLBuffer);
	inline POIEDevice AddDevice(const std::string & sName, const std::string & sHostName, const LibMCDriver_ScanLabOIE_uint32 nPort, const LibMCDriver_ScanLabOIE_uint32 nResponseTimeOut);
	inline bool HasDevice(const std::string & sName);
	inline POIEDevice FindDevice(const std::string & sName);
	inline void RemoveDevice(classParam<COIEDevice> pDeviceInstance);
	inline void RemoveDeviceByName(const std::string & sName);
	inline PDeviceConfiguration ParseDeviceConfiguration(const std::string & sDeviceConfigString);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_ScanLabOIEHandle hInstance = pInstance.GetHandle();
		LibMCDriver_ScanLabOIE_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabOIEHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabOIEHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLabOIE_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_ScanLabOIEException(LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_ScanLabOIEException(LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_ScanLabOIE_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_ScanLabOIE_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_ScanLabOIEHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDriver>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_ScanLabOIEResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_ScanLabOIEException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_ScanLabOIEResult CWrapper::initWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_GetHeaderInformation = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_OIEDevice_GetDeviceName = nullptr;
		pWrapperTable->m_OIEDevice_SetHostName = nullptr;
		pWrapperTable->m_OIEDevice_GetHostName = nullptr;
		pWrapperTable->m_OIEDevice_SetPort = nullptr;
		pWrapperTable->m_OIEDevice_GetPort = nullptr;
		pWrapperTable->m_OIEDevice_IsConnected = nullptr;
		pWrapperTable->m_OIEDevice_GetDeviceID = nullptr;
		pWrapperTable->m_OIEDevice_Connect = nullptr;
		pWrapperTable->m_OIEDevice_Disconnect = nullptr;
		pWrapperTable->m_OIEDevice_RefreshAppList = nullptr;
		pWrapperTable->m_OIEDevice_GetAppCount = nullptr;
		pWrapperTable->m_OIEDevice_GetAppName = nullptr;
		pWrapperTable->m_OIEDevice_GetAppVersion = nullptr;
		pWrapperTable->m_OIEDevice_GetAppInfo = nullptr;
		pWrapperTable->m_OIEDevice_SetRTCCorrectionData = nullptr;
		pWrapperTable->m_OIEDevice_StartAppByName = nullptr;
		pWrapperTable->m_OIEDevice_StartAppByIndex = nullptr;
		pWrapperTable->m_OIEDevice_StartAppByMajorVersion = nullptr;
		pWrapperTable->m_OIEDevice_StartAppByMinorVersion = nullptr;
		pWrapperTable->m_OIEDevice_StopApp = nullptr;
		pWrapperTable->m_OIEDevice_AppIsRunning = nullptr;
		pWrapperTable->m_OIEDevice_GetRunningApp = nullptr;
		pWrapperTable->m_OIEDevice_InstallApp = nullptr;
		pWrapperTable->m_OIEDevice_UninstallAppByName = nullptr;
		pWrapperTable->m_OIEDevice_UninstallAppByIndex = nullptr;
		pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion = nullptr;
		pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetDeviceType = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_AddDevice = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_HasDevice = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_FindDevice = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
	}

	inline LibMCDriver_ScanLabOIEResult CWrapper::releaseWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
	}

	inline LibMCDriver_ScanLabOIEResult CWrapper::loadWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabOIEDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabOIEDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabOIEDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabOIEDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabOIEDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabOIEDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabOIEDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabOIEDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetHeaderInformation = (PLibMCDriver_ScanLabOIEDriver_GetHeaderInformationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_getheaderinformation");
		#else // _WIN32
		pWrapperTable->m_Driver_GetHeaderInformation = (PLibMCDriver_ScanLabOIEDriver_GetHeaderInformationPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_getheaderinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetHeaderInformation == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabOIEDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabOIEDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetDeviceName = (PLibMCDriver_ScanLabOIEOIEDevice_GetDeviceNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getdevicename");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetDeviceName = (PLibMCDriver_ScanLabOIEOIEDevice_GetDeviceNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getdevicename");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetDeviceName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_SetHostName = (PLibMCDriver_ScanLabOIEOIEDevice_SetHostNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_sethostname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_SetHostName = (PLibMCDriver_ScanLabOIEOIEDevice_SetHostNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_sethostname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_SetHostName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetHostName = (PLibMCDriver_ScanLabOIEOIEDevice_GetHostNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_gethostname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetHostName = (PLibMCDriver_ScanLabOIEOIEDevice_GetHostNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_gethostname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetHostName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_SetPort = (PLibMCDriver_ScanLabOIEOIEDevice_SetPortPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_setport");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_SetPort = (PLibMCDriver_ScanLabOIEOIEDevice_SetPortPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_setport");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_SetPort == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetPort = (PLibMCDriver_ScanLabOIEOIEDevice_GetPortPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getport");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetPort = (PLibMCDriver_ScanLabOIEOIEDevice_GetPortPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getport");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetPort == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_IsConnected = (PLibMCDriver_ScanLabOIEOIEDevice_IsConnectedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_isconnected");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_IsConnected = (PLibMCDriver_ScanLabOIEOIEDevice_IsConnectedPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_isconnected");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_IsConnected == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetDeviceID = (PLibMCDriver_ScanLabOIEOIEDevice_GetDeviceIDPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getdeviceid");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetDeviceID = (PLibMCDriver_ScanLabOIEOIEDevice_GetDeviceIDPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getdeviceid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetDeviceID == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_Connect = (PLibMCDriver_ScanLabOIEOIEDevice_ConnectPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_connect");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_Connect = (PLibMCDriver_ScanLabOIEOIEDevice_ConnectPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_connect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_Connect == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_Disconnect = (PLibMCDriver_ScanLabOIEOIEDevice_DisconnectPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_disconnect");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_Disconnect = (PLibMCDriver_ScanLabOIEOIEDevice_DisconnectPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_disconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_Disconnect == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_RefreshAppList = (PLibMCDriver_ScanLabOIEOIEDevice_RefreshAppListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_refreshapplist");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_RefreshAppList = (PLibMCDriver_ScanLabOIEOIEDevice_RefreshAppListPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_refreshapplist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_RefreshAppList == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetAppCount = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappcount");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetAppCount = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetAppCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetAppName = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetAppName = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetAppName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetAppVersion = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetAppVersion = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetAppVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetAppInfo = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppInfoPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappinfo");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetAppInfo = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppInfoPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappinfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetAppInfo == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_SetRTCCorrectionData = (PLibMCDriver_ScanLabOIEOIEDevice_SetRTCCorrectionDataPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_setrtccorrectiondata");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_SetRTCCorrectionData = (PLibMCDriver_ScanLabOIEOIEDevice_SetRTCCorrectionDataPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_setrtccorrectiondata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_SetRTCCorrectionData == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StartAppByName = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StartAppByName = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StartAppByName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StartAppByIndex = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByIndexPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyindex");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StartAppByIndex = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByIndexPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StartAppByIndex == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StartAppByMajorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByMajorVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbymajorversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StartAppByMajorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByMajorVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbymajorversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StartAppByMajorVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StartAppByMinorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByMinorVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyminorversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StartAppByMinorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByMinorVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyminorversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StartAppByMinorVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StopApp = (PLibMCDriver_ScanLabOIEOIEDevice_StopAppPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_stopapp");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StopApp = (PLibMCDriver_ScanLabOIEOIEDevice_StopAppPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_stopapp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StopApp == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_AppIsRunning = (PLibMCDriver_ScanLabOIEOIEDevice_AppIsRunningPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_appisrunning");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_AppIsRunning = (PLibMCDriver_ScanLabOIEOIEDevice_AppIsRunningPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_appisrunning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_AppIsRunning == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetRunningApp = (PLibMCDriver_ScanLabOIEOIEDevice_GetRunningAppPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getrunningapp");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetRunningApp = (PLibMCDriver_ScanLabOIEOIEDevice_GetRunningAppPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getrunningapp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetRunningApp == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_InstallApp = (PLibMCDriver_ScanLabOIEOIEDevice_InstallAppPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_installapp");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_InstallApp = (PLibMCDriver_ScanLabOIEOIEDevice_InstallAppPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_installapp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_InstallApp == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByName = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByName = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_UninstallAppByName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByIndex = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByIndexPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyindex");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByIndex = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByIndexPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_UninstallAppByIndex == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByMajorVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbymajorversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByMajorVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbymajorversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByMinorVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyminorversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByMinorVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyminorversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetDeviceType = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetDeviceTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getdevicetype");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetDeviceType = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetDeviceTypePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getdevicetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetDeviceType == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetRTCSignalCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalcount");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetRTCSignalCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetSensorSignalCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalcount");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetSensorSignalCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetRTCSignalIDsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalids");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetRTCSignalIDsPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetSensorSignalIDsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalids");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetSensorSignalIDsPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetDeviceConfigurationStringPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getdeviceconfigurationstring");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetDeviceConfigurationStringPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getdeviceconfigurationstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_SetDependencyResourceNamesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_setdependencyresourcenames");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_SetDependencyResourceNamesPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_setdependencyresourcenames");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_InitializeSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_initializesdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_InitializeSDKPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_initializesdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_InitializeCustomSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_initializecustomsdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_InitializeCustomSDKPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_initializecustomsdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_AddDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_AddDevicePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_adddevice");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_AddDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_AddDevicePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_adddevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_AddDevice == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_HasDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_HasDevicePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_hasdevice");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_HasDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_HasDevicePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_hasdevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_HasDevice == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_FindDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_FindDevicePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_finddevice");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_FindDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_FindDevicePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_finddevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_FindDevice == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_RemoveDevicePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_removedevice");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_RemoveDevicePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_removedevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_RemoveDeviceByNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_removedevicebyname");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_RemoveDeviceByNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_removedevicebyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_ParseDeviceConfigurationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_parsedeviceconfiguration");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_ParseDeviceConfigurationPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_parsedeviceconfiguration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabOIEGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabOIEGetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabOIEGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabOIEGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabOIEReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabOIEReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabOIEAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabOIEAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabOIEInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabOIEInjectComponentPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabOIEGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabOIEGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabOIECreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabOIECreateDriverPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
	}

	inline LibMCDriver_ScanLabOIEResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_ScanLabOIEResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_ScanLabOIEResult eLookupError = LIBMCDRIVER_SCANLABOIE_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_getheaderinformation", (void**)&(pWrapperTable->m_Driver_GetHeaderInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetHeaderInformation == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getdevicename", (void**)&(pWrapperTable->m_OIEDevice_GetDeviceName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetDeviceName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_sethostname", (void**)&(pWrapperTable->m_OIEDevice_SetHostName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_SetHostName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_gethostname", (void**)&(pWrapperTable->m_OIEDevice_GetHostName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetHostName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_setport", (void**)&(pWrapperTable->m_OIEDevice_SetPort));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_SetPort == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getport", (void**)&(pWrapperTable->m_OIEDevice_GetPort));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetPort == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_isconnected", (void**)&(pWrapperTable->m_OIEDevice_IsConnected));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_IsConnected == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getdeviceid", (void**)&(pWrapperTable->m_OIEDevice_GetDeviceID));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetDeviceID == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_connect", (void**)&(pWrapperTable->m_OIEDevice_Connect));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_Connect == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_disconnect", (void**)&(pWrapperTable->m_OIEDevice_Disconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_Disconnect == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_refreshapplist", (void**)&(pWrapperTable->m_OIEDevice_RefreshAppList));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_RefreshAppList == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getappcount", (void**)&(pWrapperTable->m_OIEDevice_GetAppCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetAppCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getappname", (void**)&(pWrapperTable->m_OIEDevice_GetAppName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetAppName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getappversion", (void**)&(pWrapperTable->m_OIEDevice_GetAppVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetAppVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getappinfo", (void**)&(pWrapperTable->m_OIEDevice_GetAppInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetAppInfo == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_setrtccorrectiondata", (void**)&(pWrapperTable->m_OIEDevice_SetRTCCorrectionData));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_SetRTCCorrectionData == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_startappbyname", (void**)&(pWrapperTable->m_OIEDevice_StartAppByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StartAppByName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_startappbyindex", (void**)&(pWrapperTable->m_OIEDevice_StartAppByIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StartAppByIndex == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_startappbymajorversion", (void**)&(pWrapperTable->m_OIEDevice_StartAppByMajorVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StartAppByMajorVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_startappbyminorversion", (void**)&(pWrapperTable->m_OIEDevice_StartAppByMinorVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StartAppByMinorVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_stopapp", (void**)&(pWrapperTable->m_OIEDevice_StopApp));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StopApp == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_appisrunning", (void**)&(pWrapperTable->m_OIEDevice_AppIsRunning));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_AppIsRunning == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getrunningapp", (void**)&(pWrapperTable->m_OIEDevice_GetRunningApp));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetRunningApp == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_installapp", (void**)&(pWrapperTable->m_OIEDevice_InstallApp));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_InstallApp == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_uninstallappbyname", (void**)&(pWrapperTable->m_OIEDevice_UninstallAppByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_UninstallAppByName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_uninstallappbyindex", (void**)&(pWrapperTable->m_OIEDevice_UninstallAppByIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_UninstallAppByIndex == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_uninstallappbymajorversion", (void**)&(pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_uninstallappbyminorversion", (void**)&(pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getdevicetype", (void**)&(pWrapperTable->m_DeviceConfiguration_GetDeviceType));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetDeviceType == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalcount", (void**)&(pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalcount", (void**)&(pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalids", (void**)&(pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalids", (void**)&(pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getdeviceconfigurationstring", (void**)&(pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_setdependencyresourcenames", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_initializesdk", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_initializecustomsdk", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_adddevice", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_AddDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_AddDevice == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_hasdevice", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_HasDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_HasDevice == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_finddevice", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_FindDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_FindDevice == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_removedevice", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_removedevicebyname", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_parsedeviceconfiguration", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededType = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededBuild = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::GetHeaderInformation - returns the header information
	* @param[out] sNameSpace - NameSpace of the driver.
	* @param[out] sBaseName - BaseName of the driver.
	*/
	void CDriver::GetHeaderInformation(std::string & sNameSpace, std::string & sBaseName)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededNameSpace = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenNameSpace = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesNeededBaseName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenBaseName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetHeaderInformation(m_pHandle, 0, &bytesNeededNameSpace, nullptr, 0, &bytesNeededBaseName, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		std::vector<char> bufferBaseName(bytesNeededBaseName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetHeaderInformation(m_pHandle, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0], bytesNeededBaseName, &bytesWrittenBaseName, &bufferBaseName[0]));
		sNameSpace = std::string(&bufferNameSpace[0]);
		sBaseName = std::string(&bufferBaseName[0]);
	}
	
	/**
	* CDriver::QueryParameters - Stores the driver parameters in the driver environment.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	 * Method definitions for class COIEDevice
	 */
	
	/**
	* COIEDevice::GetDeviceName - Returns the unique name of the device.
	* @return Name of device.
	*/
	std::string COIEDevice::GetDeviceName()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededDeviceName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenDeviceName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetDeviceName(m_pHandle, 0, &bytesNeededDeviceName, nullptr));
		std::vector<char> bufferDeviceName(bytesNeededDeviceName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetDeviceName(m_pHandle, bytesNeededDeviceName, &bytesWrittenDeviceName, &bufferDeviceName[0]));
		
		return std::string(&bufferDeviceName[0]);
	}
	
	/**
	* COIEDevice::SetHostName - Sets the host name of the device. Fails if device is already connected.
	* @param[in] sHostName - New Host name of device.
	*/
	void COIEDevice::SetHostName(const std::string & sHostName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_SetHostName(m_pHandle, sHostName.c_str()));
	}
	
	/**
	* COIEDevice::GetHostName - Returns the host name of the device.
	* @return Host name of device.
	*/
	std::string COIEDevice::GetHostName()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededHostName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenHostName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetHostName(m_pHandle, 0, &bytesNeededHostName, nullptr));
		std::vector<char> bufferHostName(bytesNeededHostName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetHostName(m_pHandle, bytesNeededHostName, &bytesWrittenHostName, &bufferHostName[0]));
		
		return std::string(&bufferHostName[0]);
	}
	
	/**
	* COIEDevice::SetPort - Sets the port of the device. Fails if device is already connected.
	* @param[in] nPort - New port of device.
	*/
	void COIEDevice::SetPort(const LibMCDriver_ScanLabOIE_uint32 nPort)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_SetPort(m_pHandle, nPort));
	}
	
	/**
	* COIEDevice::GetPort - Returns the port of the device. Fails if device is already connected.
	* @return Port of device.
	*/
	LibMCDriver_ScanLabOIE_uint32 COIEDevice::GetPort()
	{
		LibMCDriver_ScanLabOIE_uint32 resultPort = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetPort(m_pHandle, &resultPort));
		
		return resultPort;
	}
	
	/**
	* COIEDevice::IsConnected - Returns if the device is connected and logged in.
	* @return Flag if the device is connected.
	*/
	bool COIEDevice::IsConnected()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_IsConnected(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* COIEDevice::GetDeviceID - Returns the ID of the device.
	* @return ID of the device.
	*/
	LibMCDriver_ScanLabOIE_uint32 COIEDevice::GetDeviceID()
	{
		LibMCDriver_ScanLabOIE_uint32 resultDeviceID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetDeviceID(m_pHandle, &resultDeviceID));
		
		return resultDeviceID;
	}
	
	/**
	* COIEDevice::Connect - Connects to the device and attempts to log in with user name and password.
	* @param[in] sUserName - UserName to use.
	* @param[in] sPassword - Password to use.
	*/
	void COIEDevice::Connect(const std::string & sUserName, const std::string & sPassword)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_Connect(m_pHandle, sUserName.c_str(), sPassword.c_str()));
	}
	
	/**
	* COIEDevice::Disconnect - Disconnects from the device. Has no effect if device is not connected.
	*/
	void COIEDevice::Disconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_Disconnect(m_pHandle));
	}
	
	/**
	* COIEDevice::RefreshAppList - Refreshes the list of installed apps on the system.
	*/
	void COIEDevice::RefreshAppList()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_RefreshAppList(m_pHandle));
	}
	
	/**
	* COIEDevice::GetAppCount - Returns how many apps are installed on the device. Fails if device is not connected.
	* @return Number of apps installed on the device.
	*/
	LibMCDriver_ScanLabOIE_uint32 COIEDevice::GetAppCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* COIEDevice::GetAppName - Returns the name of an app from the app list.
	* @param[in] nIndex - Index of App, 0-based
	* @return Name of app.
	*/
	std::string COIEDevice::GetAppName(const LibMCDriver_ScanLabOIE_uint32 nIndex)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppName(m_pHandle, nIndex, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppName(m_pHandle, nIndex, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* COIEDevice::GetAppVersion - Returns the version of an app from the app list.
	* @param[in] nIndex - Index of App, 0-based
	* @param[out] nMajor - Major version of the app.
	* @param[out] nMinor - Minor version of the app.
	* @param[out] nPatch - Patch version of the app.
	*/
	void COIEDevice::GetAppVersion(const LibMCDriver_ScanLabOIE_uint32 nIndex, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppVersion(m_pHandle, nIndex, &nMajor, &nMinor, &nPatch));
	}
	
	/**
	* COIEDevice::GetAppInfo - Returns the name and version of an app from the app list.
	* @param[in] nIndex - Index of App, 0-based
	* @param[out] sName - Name of app.
	* @param[out] nMajor - Major version of the app.
	* @param[out] nMinor - Minor version of the app.
	* @param[out] nPatch - Patch version of the app.
	*/
	void COIEDevice::GetAppInfo(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::string & sName, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppInfo(m_pHandle, nIndex, 0, &bytesNeededName, nullptr, &nMajor, &nMinor, &nPatch));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppInfo(m_pHandle, nIndex, bytesNeededName, &bytesWrittenName, &bufferName[0], &nMajor, &nMinor, &nPatch));
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* COIEDevice::SetRTCCorrectionData - Sets the RTC6 correction file data. If this function is not called, inverse coordinate transformation will be disabled.
	* @param[in] CorrectionDataBuffer - Patch version of the app.
	*/
	void COIEDevice::SetRTCCorrectionData(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & CorrectionDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_SetRTCCorrectionData(m_pHandle, (LibMCDriver_ScanLabOIE_uint64)CorrectionDataBuffer.size(), CorrectionDataBuffer.data()));
	}
	
	/**
	* COIEDevice::StartAppByName - Starts an app by its name. Fails if an app is already running.
	* @param[in] sName - Name of app to be started.
	* @param[in] pDeviceConfig - Device configuration instance.
	*/
	void COIEDevice::StartAppByName(const std::string & sName, classParam<CDeviceConfiguration> pDeviceConfig)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceConfig = pDeviceConfig.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StartAppByName(m_pHandle, sName.c_str(), hDeviceConfig));
	}
	
	/**
	* COIEDevice::StartAppByIndex - Starts an app by its index. Fails if an app is already running.
	* @param[in] nIndex - Index of App, 0-based
	* @param[in] pDeviceConfig - Device configuration instance.
	*/
	void COIEDevice::StartAppByIndex(const LibMCDriver_ScanLabOIE_uint32 nIndex, classParam<CDeviceConfiguration> pDeviceConfig)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceConfig = pDeviceConfig.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StartAppByIndex(m_pHandle, nIndex, hDeviceConfig));
	}
	
	/**
	* COIEDevice::StartAppByMajorVersion - Starts an app by its major version. Fails if an app is already running.
	* @param[in] sName - Name of app to be started.
	* @param[in] nMajorVersion - Major version of app to be started. Fails if app does not exist or only with wrong major number.
	* @param[in] pDeviceConfig - Device configuration instance.
	*/
	void COIEDevice::StartAppByMajorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, classParam<CDeviceConfiguration> pDeviceConfig)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceConfig = pDeviceConfig.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StartAppByMajorVersion(m_pHandle, sName.c_str(), nMajorVersion, hDeviceConfig));
	}
	
	/**
	* COIEDevice::StartAppByMinorVersion - Starts an app by its major version. Fails if an app is already running.
	* @param[in] sName - Name of app to be started.
	* @param[in] nMajorVersion - Major version of app to be started. Fails if app does not exist or only with wrong major number.
	* @param[in] nMinorVersion - Minor version of app to be started. Fails if app does not exist or only with wrong minor number.
	* @param[in] pDeviceConfig - Device configuration instance.
	*/
	void COIEDevice::StartAppByMinorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, const LibMCDriver_ScanLabOIE_uint32 nMinorVersion, classParam<CDeviceConfiguration> pDeviceConfig)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceConfig = pDeviceConfig.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StartAppByMinorVersion(m_pHandle, sName.c_str(), nMajorVersion, nMinorVersion, hDeviceConfig));
	}
	
	/**
	* COIEDevice::StopApp - Stops the currently running app. Does nothing if no app is running.
	*/
	void COIEDevice::StopApp()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StopApp(m_pHandle));
	}
	
	/**
	* COIEDevice::AppIsRunning - Returns if the device is running an app.
	* @return Flag if the device is running an app.
	*/
	bool COIEDevice::AppIsRunning()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_AppIsRunning(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* COIEDevice::GetRunningApp - Returns if the app that is currently running on the device. Fails if no app is running on the device.
	* @param[out] sName - Name of app.
	* @param[out] nMajor - Major version of the app.
	* @param[out] nMinor - Minor version of the app.
	* @param[out] nPatch - Patch version of the app.
	*/
	void COIEDevice::GetRunningApp(std::string & sName, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetRunningApp(m_pHandle, 0, &bytesNeededName, nullptr, &nMajor, &nMinor, &nPatch));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetRunningApp(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0], &nMajor, &nMinor, &nPatch));
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* COIEDevice::InstallApp - Installs an app package on the device. Fails if any app is running on the device. You have to be logged in with an administrator account.
	* @param[in] AppPackageBuffer - Binary data of the app to be installed.
	*/
	void COIEDevice::InstallApp(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & AppPackageBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_InstallApp(m_pHandle, (LibMCDriver_ScanLabOIE_uint64)AppPackageBuffer.size(), AppPackageBuffer.data()));
	}
	
	/**
	* COIEDevice::UninstallAppByName - Uninstall all the versions of an app by its name. Fails if any app is running on the device.
	* @param[in] sName - Name of app to be uninstalled.
	*/
	void COIEDevice::UninstallAppByName(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_UninstallAppByName(m_pHandle, sName.c_str()));
	}
	
	/**
	* COIEDevice::UninstallAppByIndex - Uninstall an app by its index. Fails if any app is running on the device.
	* @param[in] nIndex - Index of App, 0-based
	*/
	void COIEDevice::UninstallAppByIndex(const LibMCDriver_ScanLabOIE_uint32 nIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_UninstallAppByIndex(m_pHandle, nIndex));
	}
	
	/**
	* COIEDevice::UninstallAppByMajorVersion - Uninstall all major versions of an app. Fails if any app is running on the device.
	* @param[in] sName - Name of app to be uninstalled.
	* @param[in] nMajorVersion - Major version of app to be uninstalled. Fails if app does not exist or only with wrong major number.
	*/
	void COIEDevice::UninstallAppByMajorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_UninstallAppByMajorVersion(m_pHandle, sName.c_str(), nMajorVersion));
	}
	
	/**
	* COIEDevice::UninstallAppByMinorVersion - Uninstall all minor versions of an app. Fails if any app is running on the device.
	* @param[in] sName - Name of app to be uninstalled.
	* @param[in] nMajorVersion - Major version of app to be uninstalled.
	* @param[in] nMinorVersion - Minor version of app to be uninstalled.
	*/
	void COIEDevice::UninstallAppByMinorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, const LibMCDriver_ScanLabOIE_uint32 nMinorVersion)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_UninstallAppByMinorVersion(m_pHandle, sName.c_str(), nMajorVersion, nMinorVersion));
	}
	
	/**
	 * Method definitions for class CDeviceConfiguration
	 */
	
	/**
	* CDeviceConfiguration::GetDeviceType - Returns if the device is configured to work with an RTC5 or RTC6 card.
	* @return Configured device Type
	*/
	eRTCDeviceType CDeviceConfiguration::GetDeviceType()
	{
		eRTCDeviceType resultDeviceType = (eRTCDeviceType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetDeviceType(m_pHandle, &resultDeviceType));
		
		return resultDeviceType;
	}
	
	/**
	* CDeviceConfiguration::GetRTCSignalCount - Returns the configured RTC signal count the configuration.
	* @return RTC Signal Count
	*/
	LibMCDriver_ScanLabOIE_uint32 CDeviceConfiguration::GetRTCSignalCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultSignalCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetRTCSignalCount(m_pHandle, &resultSignalCount));
		
		return resultSignalCount;
	}
	
	/**
	* CDeviceConfiguration::GetSensorSignalCount - Returns the configured Sensor signal count the configuration.
	* @return Sensor Signal Count
	*/
	LibMCDriver_ScanLabOIE_uint32 CDeviceConfiguration::GetSensorSignalCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultSignalCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetSensorSignalCount(m_pHandle, &resultSignalCount));
		
		return resultSignalCount;
	}
	
	/**
	* CDeviceConfiguration::GetRTCSignalIDs - Returns the configured RTC signal IDs of the configuration.
	* @param[out] SignalIDsBuffer - RTC Signal IDs
	*/
	void CDeviceConfiguration::GetRTCSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & SignalIDsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededSignalIDs = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenSignalIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetRTCSignalIDs(m_pHandle, 0, &elementsNeededSignalIDs, nullptr));
		SignalIDsBuffer.resize((size_t) elementsNeededSignalIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetRTCSignalIDs(m_pHandle, elementsNeededSignalIDs, &elementsWrittenSignalIDs, SignalIDsBuffer.data()));
	}
	
	/**
	* CDeviceConfiguration::GetSensorSignalIDs - Returns the configured Sensor signal IDs of the configuration.
	* @param[out] SignalIDsBuffer - Sensor Signal IDs
	*/
	void CDeviceConfiguration::GetSensorSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & SignalIDsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededSignalIDs = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenSignalIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetSensorSignalIDs(m_pHandle, 0, &elementsNeededSignalIDs, nullptr));
		SignalIDsBuffer.resize((size_t) elementsNeededSignalIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetSensorSignalIDs(m_pHandle, elementsNeededSignalIDs, &elementsWrittenSignalIDs, SignalIDsBuffer.data()));
	}
	
	/**
	* CDeviceConfiguration::GetDeviceConfigurationString - Returns the device configuration string.
	* @return Device configuration string.
	*/
	std::string CDeviceConfiguration::GetDeviceConfigurationString()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededDeviceConfigurationString = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenDeviceConfigurationString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetDeviceConfigurationString(m_pHandle, 0, &bytesNeededDeviceConfigurationString, nullptr));
		std::vector<char> bufferDeviceConfigurationString(bytesNeededDeviceConfigurationString);
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetDeviceConfigurationString(m_pHandle, bytesNeededDeviceConfigurationString, &bytesWrittenDeviceConfigurationString, &bufferDeviceConfigurationString[0]));
		
		return std::string(&bufferDeviceConfigurationString[0]);
	}
	
	/**
	 * Method definitions for class CDriver_ScanLab_OIE
	 */
	
	/**
	* CDriver_ScanLab_OIE::SetDependencyResourceNames - Sets the resource names of the OIE SDK Dependencies. Searches in Machine Resources first, then in Driver Resources.
	* @param[in] sLibSSLResourceName - Resource name of LibSSL DLL. Default is libssl_win64 or libssl_linux64, depending on platform.
	* @param[in] sLibCryptoResourceName - Resource name of LibCrypto DLL. Default is libcrypto_win64 or libcrypto_linux64, depending on platform.
	* @param[in] sQT5CoreResourceName - Resource name of Qt5Core DLL. Default is qt5core_win64 or qt5core_linux64, depending on platform.
	* @param[in] sQT5NetworkResourceName - Resource name of Qt5Network DLL. Default is qt5network_win64 or qt5network_linux64, depending on platform.
	*/
	void CDriver_ScanLab_OIE::SetDependencyResourceNames(const std::string & sLibSSLResourceName, const std::string & sLibCryptoResourceName, const std::string & sQT5CoreResourceName, const std::string & sQT5NetworkResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_SetDependencyResourceNames(m_pHandle, sLibSSLResourceName.c_str(), sLibCryptoResourceName.c_str(), sQT5CoreResourceName.c_str(), sQT5NetworkResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLab_OIE::InitializeSDK - Initializes the ScanLab OIE SDK.
	* @param[in] sOIEResourceName - Resource name of Scanlab OIE DLL. Searches in Machine Resources first, then in Driver Resources.
	*/
	void CDriver_ScanLab_OIE::InitializeSDK(const std::string & sOIEResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_InitializeSDK(m_pHandle, sOIEResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLab_OIE::InitializeCustomSDK - Initializes the ScanLab OIE SDK from a custom array.
	* @param[in] OIEDLLBuffer - Byte array of Scanlab OIE DLL
	*/
	void CDriver_ScanLab_OIE::InitializeCustomSDK(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & OIEDLLBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_InitializeCustomSDK(m_pHandle, (LibMCDriver_ScanLabOIE_uint64)OIEDLLBuffer.size(), OIEDLLBuffer.data()));
	}
	
	/**
	* CDriver_ScanLab_OIE::AddDevice - Adds a new device to the OIE.
	* @param[in] sName - Name of the device. MUST be a unique string and not exist yet.
	* @param[in] sHostName - Host name of device.
	* @param[in] nPort - Port of device.
	* @param[in] nResponseTimeOut - Response timeout of device in ms.
	* @return OIE Device Instance
	*/
	POIEDevice CDriver_ScanLab_OIE::AddDevice(const std::string & sName, const std::string & sHostName, const LibMCDriver_ScanLabOIE_uint32 nPort, const LibMCDriver_ScanLabOIE_uint32 nResponseTimeOut)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_AddDevice(m_pHandle, sName.c_str(), sHostName.c_str(), nPort, nResponseTimeOut, &hDeviceInstance));
		
		if (!hDeviceInstance) {
			CheckError(LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COIEDevice>(m_pWrapper, hDeviceInstance);
	}
	
	/**
	* CDriver_ScanLab_OIE::HasDevice - Checks a device with the given name has been previously added.
	* @param[in] sName - Name of the device.
	* @return Flag if device exists.
	*/
	bool CDriver_ScanLab_OIE::HasDevice(const std::string & sName)
	{
		bool resultHasDevice = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_HasDevice(m_pHandle, sName.c_str(), &resultHasDevice));
		
		return resultHasDevice;
	}
	
	/**
	* CDriver_ScanLab_OIE::FindDevice - Finds a previously added device by name. Device MUST exist or function throws an error.
	* @param[in] sName - Name of the device.
	* @return OIE Device Instance
	*/
	POIEDevice CDriver_ScanLab_OIE::FindDevice(const std::string & sName)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_FindDevice(m_pHandle, sName.c_str(), &hDeviceInstance));
		
		if (!hDeviceInstance) {
			CheckError(LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COIEDevice>(m_pWrapper, hDeviceInstance);
	}
	
	/**
	* CDriver_ScanLab_OIE::RemoveDevice - Removes a device from the OIE.
	* @param[in] pDeviceInstance - OIE Device Instance
	*/
	void CDriver_ScanLab_OIE::RemoveDevice(classParam<COIEDevice> pDeviceInstance)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceInstance = pDeviceInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_RemoveDevice(m_pHandle, hDeviceInstance));
	}
	
	/**
	* CDriver_ScanLab_OIE::RemoveDeviceByName - Removes a device from the OIE by name. Does nothing if the device does not exist.
	* @param[in] sName - Name of the device.
	*/
	void CDriver_ScanLab_OIE::RemoveDeviceByName(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_RemoveDeviceByName(m_pHandle, sName.c_str()));
	}
	
	/**
	* CDriver_ScanLab_OIE::ParseDeviceConfiguration - Reads the configuration information from a device configuration string.
	* @param[in] sDeviceConfigString - Device config string.
	* @return Device configuration instance.
	*/
	PDeviceConfiguration CDriver_ScanLab_OIE::ParseDeviceConfiguration(const std::string & sDeviceConfigString)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceConfigInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_ParseDeviceConfiguration(m_pHandle, sDeviceConfigString.c_str(), &hDeviceConfigInstance));
		
		if (!hDeviceConfigInstance) {
			CheckError(LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDeviceConfiguration>(m_pWrapper, hDeviceConfigInstance);
	}

} // namespace LibMCDriver_ScanLabOIE

#endif // __LIBMCDRIVER_SCANLABOIE_CPPHEADER_DYNAMIC_CPP

