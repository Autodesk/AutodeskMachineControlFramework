/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver ScanLab Open Interface Extension

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_SCANLABOIE_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_SCANLABOIE_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_scanlaboie_types.hpp"
#include "libmcdriver_scanlaboie_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_ScanLabOIE {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CDeviceConfiguration;
class CDataRecording;
class COIEDevice;
class CDriver_ScanLab_OIE;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_ScanLabOIEWrapper;
typedef CBase CLibMCDriver_ScanLabOIEBase;
typedef CDriver CLibMCDriver_ScanLabOIEDriver;
typedef CDeviceConfiguration CLibMCDriver_ScanLabOIEDeviceConfiguration;
typedef CDataRecording CLibMCDriver_ScanLabOIEDataRecording;
typedef COIEDevice CLibMCDriver_ScanLabOIEOIEDevice;
typedef CDriver_ScanLab_OIE CLibMCDriver_ScanLabOIEDriver_ScanLab_OIE;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CDeviceConfiguration> PDeviceConfiguration;
typedef std::shared_ptr<CDataRecording> PDataRecording;
typedef std::shared_ptr<COIEDevice> POIEDevice;
typedef std::shared_ptr<CDriver_ScanLab_OIE> PDriver_ScanLab_OIE;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_ScanLabOIEWrapper;
typedef PBase PLibMCDriver_ScanLabOIEBase;
typedef PDriver PLibMCDriver_ScanLabOIEDriver;
typedef PDeviceConfiguration PLibMCDriver_ScanLabOIEDeviceConfiguration;
typedef PDataRecording PLibMCDriver_ScanLabOIEDataRecording;
typedef POIEDevice PLibMCDriver_ScanLabOIEOIEDevice;
typedef PDriver_ScanLab_OIE PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_ScanLabOIEHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_ScanLabOIEException 
**************************************************************************************************************************/
class ELibMCDriver_ScanLabOIEException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_ScanLabOIEResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_ScanLabOIEException(LibMCDriver_ScanLabOIEResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_ScanLabOIEResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLABOIE_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_SCANLABOIE_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_SCANLABOIE_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERTYPE: return "INVALIDDRIVERTYPE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERNAME: return "INVALIDDRIVERNAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERENVIRONMENT: return "INVALIDDRIVERENVIRONMENT";
			case LIBMCDRIVER_SCANLABOIE_ERROR_SDKALREADYINITIALIZED: return "SDKALREADYINITIALIZED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSCANLABOIESDK: return "INVALIDSCANLABOIESDK";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICENOTAVAILABLEANYMORE: return "DEVICENOTAVAILABLEANYMORE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTADDDEVICE: return "COULDNOTADDDEVICE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEALREADYCONNECTED: return "DEVICEALREADYCONNECTED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEALREADYREMOVED: return "DEVICEALREADYREMOVED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICENOTCONNECTED: return "DEVICENOTCONNECTED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPCOUNTONDEVICE: return "INVALIDAPPCOUNTONDEVICE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPINDEX: return "INVALIDAPPINDEX";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPNAME: return "INVALIDAPPNAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPVERSION: return "INVALIDAPPVERSION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRESPONSETIMEOUT: return "INVALIDRESPONSETIMEOUT";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPPACKAGEBUFFER: return "INVALIDAPPPACKAGEBUFFER";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRESOURCENAME: return "INVALIDRESOURCENAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORELIBRESSLRESOURCE: return "COULDNOTSTORELIBRESSLRESOURCE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORELIBCRYPTORESOURCE: return "COULDNOTSTORELIBCRYPTORESOURCE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREQT5CORERESOURCE: return "COULDNOTSTOREQT5CORERESOURCE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREQT5NETWORKRESOURCE: return "COULDNOTSTOREQT5NETWORKRESOURCE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_SCANLABOIESDKNOTLOADED: return "SCANLABOIESDKNOTLOADED";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDEVICENAME: return "INVALIDDEVICENAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEHASNOTBEENFOUND: return "DEVICEHASNOTBEENFOUND";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEISALREADYEXISTING: return "DEVICEISALREADYEXISTING";
			case LIBMCDRIVER_SCANLABOIE_ERROR_EMPTYDEVICENAME: return "EMPTYDEVICENAME";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDVALUESPERRECORD: return "INVALIDVALUESPERRECORD";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDBUFFERSIZE: return "INVALIDBUFFERSIZE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_PACKETISNOTRECORDING: return "PACKETISNOTRECORDING";
			case LIBMCDRIVER_SCANLABOIE_ERROR_TOOMANYVALUESINPACKET: return "TOOMANYVALUESINPACKET";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOTENOUGHVALUESINPACKET: return "NOTENOUGHVALUESINPACKET";
			case LIBMCDRIVER_SCANLABOIE_ERROR_BUFFEROVERFLOW: return "BUFFEROVERFLOW";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRTCSIGNALCOUNT: return "INVALIDRTCSIGNALCOUNT";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSENSORSIGNALCOUNT: return "INVALIDSENSORSIGNALCOUNT";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NODATARECORDINGAVAILABLE: return "NODATARECORDINGAVAILABLE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRTCVALUESPERRECORD: return "INVALIDRTCVALUESPERRECORD";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRECORDINDEX: return "INVALIDRECORDINDEX";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSIGNALINDEX: return "INVALIDSIGNALINDEX";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTARTAPP: return "COULDNOTSTARTAPP";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOPAPP: return "COULDNOTSTOPAPP";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSENSORINDEX: return "INVALIDSENSORINDEX";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRTCINDEX: return "INVALIDRTCINDEX";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREOIECALIBRATIONLIBRARYBUFFER: return "COULDNOTSTOREOIECALIBRATIONLIBRARYBUFFER";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORERTCSTREAMPARSERBUFFER: return "COULDNOTSTORERTCSTREAMPARSERBUFFER";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTGETRTCSIGNALIDS: return "COULDNOTGETRTCSIGNALIDS";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTCREATEDEVICECONFIGURATION: return "COULDNOTCREATEDEVICECONFIGURATION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_UNSUPPORTEDOIESDKVERSION: return "UNSUPPORTEDOIESDKVERSION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDEVICECONFIGURATION: return "INVALIDDEVICECONFIGURATION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_OIESDKLIBRARYRETURNSINVALIDVERSION: return "OIESDKLIBRARYRETURNSINVALIDVERSION";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDADDITIONALSIGNALCOUNT: return "INVALIDADDITIONALSIGNALCOUNT";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NORTCVALUESAVAILABLE: return "NORTCVALUESAVAILABLE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOSENSORVALUESAVAILABLE: return "NOSENSORVALUESAVAILABLE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOADDITIONALVALUESAVAILABLE: return "NOADDITIONALVALUESAVAILABLE";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDADDITIONALINDEX: return "INVALIDADDITIONALINDEX";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLABOIE_SUCCESS: return "success";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_SCANLABOIE_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_SCANLABOIE_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERTYPE: return "Invalid OIE Driver type";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERNAME: return "Invalid OIE Driver name";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDRIVERENVIRONMENT: return "Invalid OIE Driver environment";
			case LIBMCDRIVER_SCANLABOIE_ERROR_SDKALREADYINITIALIZED: return "SDK already initialized.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSCANLABOIESDK: return "Invalid Scanlab OIE SDK.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICENOTAVAILABLEANYMORE: return "Device not available anymore.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTADDDEVICE: return "Could not add device.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEALREADYCONNECTED: return "Device already connected.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEALREADYREMOVED: return "Device already removed.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICENOTCONNECTED: return "Device not connected.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPCOUNTONDEVICE: return "Invalid app count on device.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPINDEX: return "Invalid app index.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPNAME: return "Invalid app name.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPVERSION: return "Invalid app version.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRESPONSETIMEOUT: return "Invalid response timeout.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDAPPPACKAGEBUFFER: return "Invalid app package buffer.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRESOURCENAME: return "Invalid resource name.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORELIBRESSLRESOURCE: return "Could not store LibreSSL resource.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORELIBCRYPTORESOURCE: return "Could not store LibCrypto resource.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREQT5CORERESOURCE: return "Could not store QT5Core resource.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREQT5NETWORKRESOURCE: return "Could not store QT5Network resource.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_SCANLABOIESDKNOTLOADED: return "Scanlab OIE SDK not loaded.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDEVICENAME: return "Invalid device name.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEHASNOTBEENFOUND: return "Device has not been found.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_DEVICEISALREADYEXISTING: return "Device is already existing.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_EMPTYDEVICENAME: return "Empty device name.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDVALUESPERRECORD: return "Invalid values per record.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDBUFFERSIZE: return "Invalid buffer size.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_PACKETISNOTRECORDING: return "Packet is not recording.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_TOOMANYVALUESINPACKET: return "Too many values in packet.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOTENOUGHVALUESINPACKET: return "Not enough values in packet.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_BUFFEROVERFLOW: return "Buffer overflow.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRTCSIGNALCOUNT: return "Invalid RTC signal count.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSENSORSIGNALCOUNT: return "Invalid Sensor signal count.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NODATARECORDINGAVAILABLE: return "No data recording available.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRTCVALUESPERRECORD: return "Invalid RTC values per record.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRECORDINDEX: return "Invalid record index.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSIGNALINDEX: return "Invalid signal index.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTARTAPP: return "Could not start app.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOPAPP: return "Could not stop app.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDSENSORINDEX: return "Invalid sensor index.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDRTCINDEX: return "Invalid RTC index.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTOREOIECALIBRATIONLIBRARYBUFFER: return "Could not store OIE Calibration library buffer.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTSTORERTCSTREAMPARSERBUFFER: return "Could not store RTC Stream parser buffer.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTGETRTCSIGNALIDS: return "Could not get RTC Signal IDs.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTCREATEDEVICECONFIGURATION: return "Could not create device configuration.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_UNSUPPORTEDOIESDKVERSION: return "Unsupported OIE SDK Version.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDDEVICECONFIGURATION: return "Invalid device configuration.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_OIESDKLIBRARYRETURNSINVALIDVERSION: return "OIE SDK Library returns invalid version.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDADDITIONALSIGNALCOUNT: return "Invalid Additional signal count.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NORTCVALUESAVAILABLE: return "No RTC values available.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOSENSORVALUESAVAILABLE: return "No Sensor values available.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_NOADDITIONALVALUESAVAILABLE: return "No Additional values available.";
			case LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDADDITIONALINDEX: return "Invalid additional index.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_ScanLabOIEInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_ScanLabOIEResult nResult);

	inline void GetVersion(LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLabOIE_pvoid pSymbolAddressMethod);
	inline LibMCDriver_ScanLabOIE_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_ScanLabOIEDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_ScanLabOIEResult checkBinaryVersion()
	{
		LibMCDriver_ScanLabOIE_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_SCANLABOIE_VERSION_MAJOR) {
			return LIBMCDRIVER_SCANLABOIE_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
	}
	LibMCDriver_ScanLabOIEResult initWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabOIEResult releaseWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabOIEResult loadWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_ScanLabOIEResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CDeviceConfiguration;
	friend class CDataRecording;
	friend class COIEDevice;
	friend class CDriver_ScanLab_OIE;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_ScanLabOIEHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_ScanLabOIEResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_ScanLabOIEHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nMicro, std::string & sBuild);
	inline void QueryParameters();
	inline void QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance);
};
	
/*************************************************************************************************************************
 Class CDeviceConfiguration 
**************************************************************************************************************************/
class CDeviceConfiguration : public CBase {
public:
	
	/**
	* CDeviceConfiguration::CDeviceConfiguration - Constructor for DeviceConfiguration class.
	*/
	CDeviceConfiguration(CWrapper* pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline eRTCDeviceType GetDeviceType();
	inline LibMCDriver_ScanLabOIE_uint32 GetRTCSignalCount();
	inline LibMCDriver_ScanLabOIE_uint32 GetSensorSignalCount();
	inline LibMCDriver_ScanLabOIE_uint32 GetAdditionalSignalCount();
	inline void GetRTCSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & SignalIDsBuffer);
	inline void GetSensorSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & SignalIDsBuffer);
	inline void GetAdditionalSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & AdditionalIDsBuffer);
	inline void GetAdditionalSignalInfo(const LibMCDriver_ScanLabOIE_uint32 nIndex, LibMCDriver_ScanLabOIE_uint32 & nSignalID, std::string & sSignalName);
	inline std::string GetDeviceConfigurationString();
};
	
/*************************************************************************************************************************
 Class CDataRecording 
**************************************************************************************************************************/
class CDataRecording : public CBase {
public:
	
	/**
	* CDataRecording::CDataRecording - Constructor for DataRecording class.
	*/
	CDataRecording(CWrapper* pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCDriver_ScanLabOIE_uint32 GetRTCSignalCount();
	inline LibMCDriver_ScanLabOIE_uint32 GetSensorSignalCount();
	inline LibMCDriver_ScanLabOIE_uint32 GetAdditionalSignalCount();
	inline LibMCDriver_ScanLabOIE_uint64 GetRecordCount();
	inline void GetRecordInformation(const LibMCDriver_ScanLabOIE_uint32 nIndex, LibMCDriver_ScanLabOIE_uint32 & nPacketNumber, LibMCDriver_ScanLabOIE_double & dX, LibMCDriver_ScanLabOIE_double & dY);
	inline LibMCDriver_ScanLabOIE_uint32 GetMeasurementTag(const LibMCDriver_ScanLabOIE_uint32 nIndex);
	inline void GetRTCSignalsOfRecord(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & RTCSignalsBuffer);
	inline void GetSensorSignalsOfRecord(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & SensorSignalsBuffer);
	inline void GetAdditionalSignalsOfRecord(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & AdditionalSignalsBuffer);
	inline void GetAllCoordinates(std::vector<LibMCDriver_ScanLabOIE_double> & XArrayBuffer, std::vector<LibMCDriver_ScanLabOIE_double> & YArrayBuffer);
	inline void GetAllPacketNumbers(std::vector<LibMCDriver_ScanLabOIE_uint32> & PacketNumersBuffer);
	inline void GetAllMeasurementTags(std::vector<LibMCDriver_ScanLabOIE_uint32> & MeasurementTagsBuffer);
	inline void GetAllRTCSignals(const LibMCDriver_ScanLabOIE_uint32 nRTCIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & SignalsBuffer);
	inline void GetAllSensorSignals(const LibMCDriver_ScanLabOIE_uint32 nSignalIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & SignalsBuffer);
	inline void GetAllAdditionalSignals(const LibMCDriver_ScanLabOIE_uint32 nAdditionalIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & SignalsBuffer);
	inline std::string StoreAsBuildData(const std::string & sName, classParam<LibMCEnv::CBuild> pBuild);
};
	
/*************************************************************************************************************************
 Class COIEDevice 
**************************************************************************************************************************/
class COIEDevice : public CBase {
public:
	
	/**
	* COIEDevice::COIEDevice - Constructor for OIEDevice class.
	*/
	COIEDevice(CWrapper* pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetDeviceName();
	inline void SetHostName(const std::string & sHostName);
	inline std::string GetHostName();
	inline void SetPort(const LibMCDriver_ScanLabOIE_uint32 nPort);
	inline LibMCDriver_ScanLabOIE_uint32 GetPort();
	inline bool IsConnected();
	inline LibMCDriver_ScanLabOIE_uint32 GetDeviceID();
	inline void Connect(const std::string & sUserName, const std::string & sPassword);
	inline void Disconnect();
	inline void RefreshAppList();
	inline LibMCDriver_ScanLabOIE_uint32 GetAppCount();
	inline std::string GetAppName(const LibMCDriver_ScanLabOIE_uint32 nIndex);
	inline void GetAppVersion(const LibMCDriver_ScanLabOIE_uint32 nIndex, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch);
	inline void GetAppInfo(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::string & sName, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch);
	inline void StartAppByName(const std::string & sName);
	inline void StartAppByIndex(const LibMCDriver_ScanLabOIE_uint32 nIndex);
	inline void StartAppByMajorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion);
	inline void StartAppByMinorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, const LibMCDriver_ScanLabOIE_uint32 nMinorVersion);
	inline void StopApp();
	inline bool AppIsRunning();
	inline void GetRunningApp(std::string & sName, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch);
	inline void InstallApp(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & AppPackageBuffer);
	inline void UninstallAppByName(const std::string & sName);
	inline void UninstallAppByIndex(const LibMCDriver_ScanLabOIE_uint32 nIndex);
	inline void UninstallAppByMajorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion);
	inline void UninstallAppByMinorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, const LibMCDriver_ScanLabOIE_uint32 nMinorVersion);
	inline PDataRecording RetrieveCurrentRecording();
	inline void ClearCurrentRecording();
	inline PDataRecording LoadRecordingFromBuild(classParam<LibMCEnv::CBuild> pBuild, const std::string & sDataUUID);
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLab_OIE 
**************************************************************************************************************************/
class CDriver_ScanLab_OIE : public CDriver {
public:
	
	/**
	* CDriver_ScanLab_OIE::CDriver_ScanLab_OIE - Constructor for Driver_ScanLab_OIE class.
	*/
	CDriver_ScanLab_OIE(CWrapper* pWrapper, LibMCDriver_ScanLabOIEHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline eOIEDeviceDriverType GetDriverType();
	inline void SetDependencyResourceNames(const std::string & sLibSSLResourceName, const std::string & sLibCryptoResourceName, const std::string & sQT5CoreResourceName, const std::string & sQT5NetworkResourceName);
	inline void SetOIE3ResourceNames(const std::string & sOIECalibrationLibraryResourceName, const std::string & sRTCStreamParserResourceName);
	inline void InitializeSDK(const std::string & sOIEResourceName);
	inline void InitializeCustomSDK(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & OIEDLLBuffer);
	inline POIEDevice AddDevice(const std::string & sName, const std::string & sHostName, const LibMCDriver_ScanLabOIE_uint32 nPort, classParam<CDeviceConfiguration> pDeviceConfig, const CInputVector<LibMCDriver_ScanLabOIE_uint8> & CorrectionDataBuffer, const LibMCDriver_ScanLabOIE_uint32 nResponseTimeOut);
	inline bool HasDevice(const std::string & sName);
	inline POIEDevice FindDevice(const std::string & sName);
	inline void RemoveDevice(classParam<COIEDevice> pDeviceInstance);
	inline void RemoveDeviceByName(const std::string & sName);
	inline PDeviceConfiguration ParseDeviceConfiguration(const std::string & sDeviceConfigString);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_ScanLabOIEHandle hInstance = pInstance.GetHandle();
		LibMCDriver_ScanLabOIE_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabOIEHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabOIEHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLabOIE_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_ScanLabOIEException(LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_ScanLabOIEException(LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_ScanLabOIE_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_ScanLabOIE_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_ScanLabOIEHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (hInstance) {
			return std::make_shared<CDriver>(this, hInstance);
		} else {
			return nullptr;
		}
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_ScanLabOIEResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_ScanLabOIEException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_ScanLabOIEResult CWrapper::initWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_Driver_QueryParametersEx = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetDeviceType = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalCount = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalIDs = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalInfo = nullptr;
		pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString = nullptr;
		pWrapperTable->m_DataRecording_GetRTCSignalCount = nullptr;
		pWrapperTable->m_DataRecording_GetSensorSignalCount = nullptr;
		pWrapperTable->m_DataRecording_GetAdditionalSignalCount = nullptr;
		pWrapperTable->m_DataRecording_GetRecordCount = nullptr;
		pWrapperTable->m_DataRecording_GetRecordInformation = nullptr;
		pWrapperTable->m_DataRecording_GetMeasurementTag = nullptr;
		pWrapperTable->m_DataRecording_GetRTCSignalsOfRecord = nullptr;
		pWrapperTable->m_DataRecording_GetSensorSignalsOfRecord = nullptr;
		pWrapperTable->m_DataRecording_GetAdditionalSignalsOfRecord = nullptr;
		pWrapperTable->m_DataRecording_GetAllCoordinates = nullptr;
		pWrapperTable->m_DataRecording_GetAllPacketNumbers = nullptr;
		pWrapperTable->m_DataRecording_GetAllMeasurementTags = nullptr;
		pWrapperTable->m_DataRecording_GetAllRTCSignals = nullptr;
		pWrapperTable->m_DataRecording_GetAllSensorSignals = nullptr;
		pWrapperTable->m_DataRecording_GetAllAdditionalSignals = nullptr;
		pWrapperTable->m_DataRecording_StoreAsBuildData = nullptr;
		pWrapperTable->m_OIEDevice_GetDeviceName = nullptr;
		pWrapperTable->m_OIEDevice_SetHostName = nullptr;
		pWrapperTable->m_OIEDevice_GetHostName = nullptr;
		pWrapperTable->m_OIEDevice_SetPort = nullptr;
		pWrapperTable->m_OIEDevice_GetPort = nullptr;
		pWrapperTable->m_OIEDevice_IsConnected = nullptr;
		pWrapperTable->m_OIEDevice_GetDeviceID = nullptr;
		pWrapperTable->m_OIEDevice_Connect = nullptr;
		pWrapperTable->m_OIEDevice_Disconnect = nullptr;
		pWrapperTable->m_OIEDevice_RefreshAppList = nullptr;
		pWrapperTable->m_OIEDevice_GetAppCount = nullptr;
		pWrapperTable->m_OIEDevice_GetAppName = nullptr;
		pWrapperTable->m_OIEDevice_GetAppVersion = nullptr;
		pWrapperTable->m_OIEDevice_GetAppInfo = nullptr;
		pWrapperTable->m_OIEDevice_StartAppByName = nullptr;
		pWrapperTable->m_OIEDevice_StartAppByIndex = nullptr;
		pWrapperTable->m_OIEDevice_StartAppByMajorVersion = nullptr;
		pWrapperTable->m_OIEDevice_StartAppByMinorVersion = nullptr;
		pWrapperTable->m_OIEDevice_StopApp = nullptr;
		pWrapperTable->m_OIEDevice_AppIsRunning = nullptr;
		pWrapperTable->m_OIEDevice_GetRunningApp = nullptr;
		pWrapperTable->m_OIEDevice_InstallApp = nullptr;
		pWrapperTable->m_OIEDevice_UninstallAppByName = nullptr;
		pWrapperTable->m_OIEDevice_UninstallAppByIndex = nullptr;
		pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion = nullptr;
		pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion = nullptr;
		pWrapperTable->m_OIEDevice_RetrieveCurrentRecording = nullptr;
		pWrapperTable->m_OIEDevice_ClearCurrentRecording = nullptr;
		pWrapperTable->m_OIEDevice_LoadRecordingFromBuild = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_GetDriverType = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_SetOIE3ResourceNames = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_AddDevice = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_HasDevice = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_FindDevice = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName = nullptr;
		pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
	}

	inline LibMCDriver_ScanLabOIEResult CWrapper::releaseWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
	}

	inline LibMCDriver_ScanLabOIEResult CWrapper::loadWrapperTable(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabOIEDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabOIEDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabOIEDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabOIEDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabOIEDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabOIEDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabOIEDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabOIEDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabOIEDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabOIEDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_ScanLabOIEDriver_QueryParametersExPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_queryparametersex");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_ScanLabOIEDriver_QueryParametersExPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_queryparametersex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParametersEx == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetDeviceType = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetDeviceTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getdevicetype");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetDeviceType = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetDeviceTypePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getdevicetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetDeviceType == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetRTCSignalCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalcount");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetRTCSignalCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetSensorSignalCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalcount");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetSensorSignalCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetAdditionalSignalCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getadditionalsignalcount");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalCount = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetAdditionalSignalCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getadditionalsignalcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetRTCSignalIDsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalids");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetRTCSignalIDsPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetSensorSignalIDsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalids");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetSensorSignalIDsPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetAdditionalSignalIDsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getadditionalsignalids");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalIDs = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetAdditionalSignalIDsPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getadditionalsignalids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalIDs == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalInfo = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetAdditionalSignalInfoPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getadditionalsignalinfo");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalInfo = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetAdditionalSignalInfoPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getadditionalsignalinfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalInfo == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetDeviceConfigurationStringPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getdeviceconfigurationstring");
		#else // _WIN32
		pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString = (PLibMCDriver_ScanLabOIEDeviceConfiguration_GetDeviceConfigurationStringPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_deviceconfiguration_getdeviceconfigurationstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetRTCSignalCount = (PLibMCDriver_ScanLabOIEDataRecording_GetRTCSignalCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getrtcsignalcount");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetRTCSignalCount = (PLibMCDriver_ScanLabOIEDataRecording_GetRTCSignalCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getrtcsignalcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetRTCSignalCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetSensorSignalCount = (PLibMCDriver_ScanLabOIEDataRecording_GetSensorSignalCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getsensorsignalcount");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetSensorSignalCount = (PLibMCDriver_ScanLabOIEDataRecording_GetSensorSignalCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getsensorsignalcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetSensorSignalCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetAdditionalSignalCount = (PLibMCDriver_ScanLabOIEDataRecording_GetAdditionalSignalCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getadditionalsignalcount");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetAdditionalSignalCount = (PLibMCDriver_ScanLabOIEDataRecording_GetAdditionalSignalCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getadditionalsignalcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetAdditionalSignalCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetRecordCount = (PLibMCDriver_ScanLabOIEDataRecording_GetRecordCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getrecordcount");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetRecordCount = (PLibMCDriver_ScanLabOIEDataRecording_GetRecordCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getrecordcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetRecordCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetRecordInformation = (PLibMCDriver_ScanLabOIEDataRecording_GetRecordInformationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getrecordinformation");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetRecordInformation = (PLibMCDriver_ScanLabOIEDataRecording_GetRecordInformationPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getrecordinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetRecordInformation == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetMeasurementTag = (PLibMCDriver_ScanLabOIEDataRecording_GetMeasurementTagPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getmeasurementtag");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetMeasurementTag = (PLibMCDriver_ScanLabOIEDataRecording_GetMeasurementTagPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getmeasurementtag");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetMeasurementTag == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetRTCSignalsOfRecord = (PLibMCDriver_ScanLabOIEDataRecording_GetRTCSignalsOfRecordPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getrtcsignalsofrecord");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetRTCSignalsOfRecord = (PLibMCDriver_ScanLabOIEDataRecording_GetRTCSignalsOfRecordPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getrtcsignalsofrecord");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetRTCSignalsOfRecord == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetSensorSignalsOfRecord = (PLibMCDriver_ScanLabOIEDataRecording_GetSensorSignalsOfRecordPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getsensorsignalsofrecord");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetSensorSignalsOfRecord = (PLibMCDriver_ScanLabOIEDataRecording_GetSensorSignalsOfRecordPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getsensorsignalsofrecord");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetSensorSignalsOfRecord == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetAdditionalSignalsOfRecord = (PLibMCDriver_ScanLabOIEDataRecording_GetAdditionalSignalsOfRecordPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getadditionalsignalsofrecord");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetAdditionalSignalsOfRecord = (PLibMCDriver_ScanLabOIEDataRecording_GetAdditionalSignalsOfRecordPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getadditionalsignalsofrecord");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetAdditionalSignalsOfRecord == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetAllCoordinates = (PLibMCDriver_ScanLabOIEDataRecording_GetAllCoordinatesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getallcoordinates");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetAllCoordinates = (PLibMCDriver_ScanLabOIEDataRecording_GetAllCoordinatesPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getallcoordinates");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetAllCoordinates == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetAllPacketNumbers = (PLibMCDriver_ScanLabOIEDataRecording_GetAllPacketNumbersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getallpacketnumbers");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetAllPacketNumbers = (PLibMCDriver_ScanLabOIEDataRecording_GetAllPacketNumbersPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getallpacketnumbers");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetAllPacketNumbers == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetAllMeasurementTags = (PLibMCDriver_ScanLabOIEDataRecording_GetAllMeasurementTagsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getallmeasurementtags");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetAllMeasurementTags = (PLibMCDriver_ScanLabOIEDataRecording_GetAllMeasurementTagsPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getallmeasurementtags");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetAllMeasurementTags == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetAllRTCSignals = (PLibMCDriver_ScanLabOIEDataRecording_GetAllRTCSignalsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getallrtcsignals");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetAllRTCSignals = (PLibMCDriver_ScanLabOIEDataRecording_GetAllRTCSignalsPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getallrtcsignals");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetAllRTCSignals == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetAllSensorSignals = (PLibMCDriver_ScanLabOIEDataRecording_GetAllSensorSignalsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getallsensorsignals");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetAllSensorSignals = (PLibMCDriver_ScanLabOIEDataRecording_GetAllSensorSignalsPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getallsensorsignals");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetAllSensorSignals == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_GetAllAdditionalSignals = (PLibMCDriver_ScanLabOIEDataRecording_GetAllAdditionalSignalsPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_getalladditionalsignals");
		#else // _WIN32
		pWrapperTable->m_DataRecording_GetAllAdditionalSignals = (PLibMCDriver_ScanLabOIEDataRecording_GetAllAdditionalSignalsPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_getalladditionalsignals");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_GetAllAdditionalSignals == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataRecording_StoreAsBuildData = (PLibMCDriver_ScanLabOIEDataRecording_StoreAsBuildDataPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_datarecording_storeasbuilddata");
		#else // _WIN32
		pWrapperTable->m_DataRecording_StoreAsBuildData = (PLibMCDriver_ScanLabOIEDataRecording_StoreAsBuildDataPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_datarecording_storeasbuilddata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataRecording_StoreAsBuildData == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetDeviceName = (PLibMCDriver_ScanLabOIEOIEDevice_GetDeviceNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getdevicename");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetDeviceName = (PLibMCDriver_ScanLabOIEOIEDevice_GetDeviceNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getdevicename");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetDeviceName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_SetHostName = (PLibMCDriver_ScanLabOIEOIEDevice_SetHostNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_sethostname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_SetHostName = (PLibMCDriver_ScanLabOIEOIEDevice_SetHostNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_sethostname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_SetHostName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetHostName = (PLibMCDriver_ScanLabOIEOIEDevice_GetHostNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_gethostname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetHostName = (PLibMCDriver_ScanLabOIEOIEDevice_GetHostNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_gethostname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetHostName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_SetPort = (PLibMCDriver_ScanLabOIEOIEDevice_SetPortPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_setport");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_SetPort = (PLibMCDriver_ScanLabOIEOIEDevice_SetPortPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_setport");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_SetPort == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetPort = (PLibMCDriver_ScanLabOIEOIEDevice_GetPortPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getport");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetPort = (PLibMCDriver_ScanLabOIEOIEDevice_GetPortPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getport");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetPort == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_IsConnected = (PLibMCDriver_ScanLabOIEOIEDevice_IsConnectedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_isconnected");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_IsConnected = (PLibMCDriver_ScanLabOIEOIEDevice_IsConnectedPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_isconnected");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_IsConnected == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetDeviceID = (PLibMCDriver_ScanLabOIEOIEDevice_GetDeviceIDPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getdeviceid");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetDeviceID = (PLibMCDriver_ScanLabOIEOIEDevice_GetDeviceIDPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getdeviceid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetDeviceID == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_Connect = (PLibMCDriver_ScanLabOIEOIEDevice_ConnectPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_connect");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_Connect = (PLibMCDriver_ScanLabOIEOIEDevice_ConnectPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_connect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_Connect == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_Disconnect = (PLibMCDriver_ScanLabOIEOIEDevice_DisconnectPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_disconnect");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_Disconnect = (PLibMCDriver_ScanLabOIEOIEDevice_DisconnectPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_disconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_Disconnect == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_RefreshAppList = (PLibMCDriver_ScanLabOIEOIEDevice_RefreshAppListPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_refreshapplist");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_RefreshAppList = (PLibMCDriver_ScanLabOIEOIEDevice_RefreshAppListPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_refreshapplist");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_RefreshAppList == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetAppCount = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppCountPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappcount");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetAppCount = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppCountPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetAppCount == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetAppName = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetAppName = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetAppName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetAppVersion = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetAppVersion = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetAppVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetAppInfo = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppInfoPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappinfo");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetAppInfo = (PLibMCDriver_ScanLabOIEOIEDevice_GetAppInfoPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getappinfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetAppInfo == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StartAppByName = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StartAppByName = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StartAppByName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StartAppByIndex = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByIndexPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyindex");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StartAppByIndex = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByIndexPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StartAppByIndex == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StartAppByMajorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByMajorVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbymajorversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StartAppByMajorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByMajorVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbymajorversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StartAppByMajorVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StartAppByMinorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByMinorVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyminorversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StartAppByMinorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_StartAppByMinorVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_startappbyminorversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StartAppByMinorVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_StopApp = (PLibMCDriver_ScanLabOIEOIEDevice_StopAppPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_stopapp");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_StopApp = (PLibMCDriver_ScanLabOIEOIEDevice_StopAppPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_stopapp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_StopApp == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_AppIsRunning = (PLibMCDriver_ScanLabOIEOIEDevice_AppIsRunningPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_appisrunning");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_AppIsRunning = (PLibMCDriver_ScanLabOIEOIEDevice_AppIsRunningPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_appisrunning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_AppIsRunning == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_GetRunningApp = (PLibMCDriver_ScanLabOIEOIEDevice_GetRunningAppPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_getrunningapp");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_GetRunningApp = (PLibMCDriver_ScanLabOIEOIEDevice_GetRunningAppPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_getrunningapp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_GetRunningApp == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_InstallApp = (PLibMCDriver_ScanLabOIEOIEDevice_InstallAppPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_installapp");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_InstallApp = (PLibMCDriver_ScanLabOIEOIEDevice_InstallAppPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_installapp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_InstallApp == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByName = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyname");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByName = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_UninstallAppByName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByIndex = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByIndexPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyindex");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByIndex = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByIndexPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_UninstallAppByIndex == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByMajorVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbymajorversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByMajorVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbymajorversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByMinorVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyminorversion");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion = (PLibMCDriver_ScanLabOIEOIEDevice_UninstallAppByMinorVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_uninstallappbyminorversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_RetrieveCurrentRecording = (PLibMCDriver_ScanLabOIEOIEDevice_RetrieveCurrentRecordingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_retrievecurrentrecording");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_RetrieveCurrentRecording = (PLibMCDriver_ScanLabOIEOIEDevice_RetrieveCurrentRecordingPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_retrievecurrentrecording");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_RetrieveCurrentRecording == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_ClearCurrentRecording = (PLibMCDriver_ScanLabOIEOIEDevice_ClearCurrentRecordingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_clearcurrentrecording");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_ClearCurrentRecording = (PLibMCDriver_ScanLabOIEOIEDevice_ClearCurrentRecordingPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_clearcurrentrecording");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_ClearCurrentRecording == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OIEDevice_LoadRecordingFromBuild = (PLibMCDriver_ScanLabOIEOIEDevice_LoadRecordingFromBuildPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_oiedevice_loadrecordingfrombuild");
		#else // _WIN32
		pWrapperTable->m_OIEDevice_LoadRecordingFromBuild = (PLibMCDriver_ScanLabOIEOIEDevice_LoadRecordingFromBuildPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_oiedevice_loadrecordingfrombuild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OIEDevice_LoadRecordingFromBuild == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_GetDriverType = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_GetDriverTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_getdrivertype");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_GetDriverType = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_GetDriverTypePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_getdrivertype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_GetDriverType == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_SetDependencyResourceNamesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_setdependencyresourcenames");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_SetDependencyResourceNamesPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_setdependencyresourcenames");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_SetOIE3ResourceNames = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_SetOIE3ResourceNamesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_setoie3resourcenames");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_SetOIE3ResourceNames = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_SetOIE3ResourceNamesPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_setoie3resourcenames");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_SetOIE3ResourceNames == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_InitializeSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_initializesdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_InitializeSDKPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_initializesdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_InitializeCustomSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_initializecustomsdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_InitializeCustomSDKPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_initializecustomsdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_AddDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_AddDevicePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_adddevice");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_AddDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_AddDevicePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_adddevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_AddDevice == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_HasDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_HasDevicePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_hasdevice");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_HasDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_HasDevicePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_hasdevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_HasDevice == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_FindDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_FindDevicePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_finddevice");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_FindDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_FindDevicePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_finddevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_FindDevice == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_RemoveDevicePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_removedevice");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_RemoveDevicePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_removedevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_RemoveDeviceByNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_removedevicebyname");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_RemoveDeviceByNamePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_removedevicebyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_ParseDeviceConfigurationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_parsedeviceconfiguration");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration = (PLibMCDriver_ScanLabOIEDriver_ScanLab_OIE_ParseDeviceConfigurationPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_driver_scanlab_oie_parsedeviceconfiguration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabOIEGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabOIEGetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabOIEGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabOIEGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabOIEReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabOIEReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabOIEAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabOIEAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_scanlaboie_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabOIEInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabOIEInjectComponentPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabOIEGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabOIEGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabOIECreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_scanlaboie_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabOIECreateDriverPtr) dlsym(hLibrary, "libmcdriver_scanlaboie_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
	}

	inline LibMCDriver_ScanLabOIEResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabOIEDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_ScanLabOIEResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_ScanLabOIEResult eLookupError = LIBMCDRIVER_SCANLABOIE_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_queryparametersex", (void**)&(pWrapperTable->m_Driver_QueryParametersEx));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParametersEx == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getdevicetype", (void**)&(pWrapperTable->m_DeviceConfiguration_GetDeviceType));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetDeviceType == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalcount", (void**)&(pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetRTCSignalCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalcount", (void**)&(pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetSensorSignalCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getadditionalsignalcount", (void**)&(pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getrtcsignalids", (void**)&(pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetRTCSignalIDs == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getsensorsignalids", (void**)&(pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetSensorSignalIDs == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getadditionalsignalids", (void**)&(pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalIDs == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getadditionalsignalinfo", (void**)&(pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetAdditionalSignalInfo == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_deviceconfiguration_getdeviceconfigurationstring", (void**)&(pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString));
		if ( (eLookupError != 0) || (pWrapperTable->m_DeviceConfiguration_GetDeviceConfigurationString == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getrtcsignalcount", (void**)&(pWrapperTable->m_DataRecording_GetRTCSignalCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetRTCSignalCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getsensorsignalcount", (void**)&(pWrapperTable->m_DataRecording_GetSensorSignalCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetSensorSignalCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getadditionalsignalcount", (void**)&(pWrapperTable->m_DataRecording_GetAdditionalSignalCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetAdditionalSignalCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getrecordcount", (void**)&(pWrapperTable->m_DataRecording_GetRecordCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetRecordCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getrecordinformation", (void**)&(pWrapperTable->m_DataRecording_GetRecordInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetRecordInformation == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getmeasurementtag", (void**)&(pWrapperTable->m_DataRecording_GetMeasurementTag));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetMeasurementTag == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getrtcsignalsofrecord", (void**)&(pWrapperTable->m_DataRecording_GetRTCSignalsOfRecord));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetRTCSignalsOfRecord == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getsensorsignalsofrecord", (void**)&(pWrapperTable->m_DataRecording_GetSensorSignalsOfRecord));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetSensorSignalsOfRecord == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getadditionalsignalsofrecord", (void**)&(pWrapperTable->m_DataRecording_GetAdditionalSignalsOfRecord));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetAdditionalSignalsOfRecord == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getallcoordinates", (void**)&(pWrapperTable->m_DataRecording_GetAllCoordinates));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetAllCoordinates == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getallpacketnumbers", (void**)&(pWrapperTable->m_DataRecording_GetAllPacketNumbers));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetAllPacketNumbers == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getallmeasurementtags", (void**)&(pWrapperTable->m_DataRecording_GetAllMeasurementTags));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetAllMeasurementTags == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getallrtcsignals", (void**)&(pWrapperTable->m_DataRecording_GetAllRTCSignals));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetAllRTCSignals == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getallsensorsignals", (void**)&(pWrapperTable->m_DataRecording_GetAllSensorSignals));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetAllSensorSignals == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_getalladditionalsignals", (void**)&(pWrapperTable->m_DataRecording_GetAllAdditionalSignals));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_GetAllAdditionalSignals == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_datarecording_storeasbuilddata", (void**)&(pWrapperTable->m_DataRecording_StoreAsBuildData));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataRecording_StoreAsBuildData == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getdevicename", (void**)&(pWrapperTable->m_OIEDevice_GetDeviceName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetDeviceName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_sethostname", (void**)&(pWrapperTable->m_OIEDevice_SetHostName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_SetHostName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_gethostname", (void**)&(pWrapperTable->m_OIEDevice_GetHostName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetHostName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_setport", (void**)&(pWrapperTable->m_OIEDevice_SetPort));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_SetPort == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getport", (void**)&(pWrapperTable->m_OIEDevice_GetPort));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetPort == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_isconnected", (void**)&(pWrapperTable->m_OIEDevice_IsConnected));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_IsConnected == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getdeviceid", (void**)&(pWrapperTable->m_OIEDevice_GetDeviceID));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetDeviceID == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_connect", (void**)&(pWrapperTable->m_OIEDevice_Connect));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_Connect == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_disconnect", (void**)&(pWrapperTable->m_OIEDevice_Disconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_Disconnect == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_refreshapplist", (void**)&(pWrapperTable->m_OIEDevice_RefreshAppList));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_RefreshAppList == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getappcount", (void**)&(pWrapperTable->m_OIEDevice_GetAppCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetAppCount == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getappname", (void**)&(pWrapperTable->m_OIEDevice_GetAppName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetAppName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getappversion", (void**)&(pWrapperTable->m_OIEDevice_GetAppVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetAppVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getappinfo", (void**)&(pWrapperTable->m_OIEDevice_GetAppInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetAppInfo == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_startappbyname", (void**)&(pWrapperTable->m_OIEDevice_StartAppByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StartAppByName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_startappbyindex", (void**)&(pWrapperTable->m_OIEDevice_StartAppByIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StartAppByIndex == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_startappbymajorversion", (void**)&(pWrapperTable->m_OIEDevice_StartAppByMajorVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StartAppByMajorVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_startappbyminorversion", (void**)&(pWrapperTable->m_OIEDevice_StartAppByMinorVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StartAppByMinorVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_stopapp", (void**)&(pWrapperTable->m_OIEDevice_StopApp));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_StopApp == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_appisrunning", (void**)&(pWrapperTable->m_OIEDevice_AppIsRunning));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_AppIsRunning == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_getrunningapp", (void**)&(pWrapperTable->m_OIEDevice_GetRunningApp));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_GetRunningApp == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_installapp", (void**)&(pWrapperTable->m_OIEDevice_InstallApp));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_InstallApp == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_uninstallappbyname", (void**)&(pWrapperTable->m_OIEDevice_UninstallAppByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_UninstallAppByName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_uninstallappbyindex", (void**)&(pWrapperTable->m_OIEDevice_UninstallAppByIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_UninstallAppByIndex == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_uninstallappbymajorversion", (void**)&(pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_UninstallAppByMajorVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_uninstallappbyminorversion", (void**)&(pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_UninstallAppByMinorVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_retrievecurrentrecording", (void**)&(pWrapperTable->m_OIEDevice_RetrieveCurrentRecording));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_RetrieveCurrentRecording == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_clearcurrentrecording", (void**)&(pWrapperTable->m_OIEDevice_ClearCurrentRecording));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_ClearCurrentRecording == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_oiedevice_loadrecordingfrombuild", (void**)&(pWrapperTable->m_OIEDevice_LoadRecordingFromBuild));
		if ( (eLookupError != 0) || (pWrapperTable->m_OIEDevice_LoadRecordingFromBuild == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_getdrivertype", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_GetDriverType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_GetDriverType == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_setdependencyresourcenames", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_SetDependencyResourceNames == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_setoie3resourcenames", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_SetOIE3ResourceNames));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_SetOIE3ResourceNames == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_initializesdk", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_InitializeSDK == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_initializecustomsdk", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_InitializeCustomSDK == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_adddevice", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_AddDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_AddDevice == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_hasdevice", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_HasDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_HasDevice == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_finddevice", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_FindDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_FindDevice == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_removedevice", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_RemoveDevice == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_removedevicebyname", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_RemoveDeviceByName == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_driver_scanlab_oie_parsedeviceconfiguration", (void**)&(pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLab_OIE_ParseDeviceConfiguration == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlaboie_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_SCANLABOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_SCANLABOIE_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededType = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededBuild = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::QueryParameters - Updates the driver parameters in the driver environment. Should only be called in the driver thread.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	* CDriver::QueryParametersEx - Updates the driver parameters in the driver environment. Might be called out of thread. Implementation MUST be able to handle parallel calls.
	* @param[in] pDriverUpdateInstance - Status update instance.
	*/
	void CDriver::QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance)
	{
		LibMCEnvHandle hDriverUpdateInstance = pDriverUpdateInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParametersEx(m_pHandle, hDriverUpdateInstance));
	}
	
	/**
	 * Method definitions for class CDeviceConfiguration
	 */
	
	/**
	* CDeviceConfiguration::GetDeviceType - Returns if the device is configured to work with an RTC5 or RTC6 card.
	* @return Configured device Type
	*/
	eRTCDeviceType CDeviceConfiguration::GetDeviceType()
	{
		eRTCDeviceType resultDeviceType = (eRTCDeviceType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetDeviceType(m_pHandle, &resultDeviceType));
		
		return resultDeviceType;
	}
	
	/**
	* CDeviceConfiguration::GetRTCSignalCount - Returns the configured RTC signal count of the configuration.
	* @return RTC Signal Count
	*/
	LibMCDriver_ScanLabOIE_uint32 CDeviceConfiguration::GetRTCSignalCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultSignalCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetRTCSignalCount(m_pHandle, &resultSignalCount));
		
		return resultSignalCount;
	}
	
	/**
	* CDeviceConfiguration::GetSensorSignalCount - Returns the configured Sensor signal count of the configuration.
	* @return Sensor Signal Count
	*/
	LibMCDriver_ScanLabOIE_uint32 CDeviceConfiguration::GetSensorSignalCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultSignalCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetSensorSignalCount(m_pHandle, &resultSignalCount));
		
		return resultSignalCount;
	}
	
	/**
	* CDeviceConfiguration::GetAdditionalSignalCount - Returns the configured Additional signal count of the configuration.
	* @return Additional Signal Count
	*/
	LibMCDriver_ScanLabOIE_uint32 CDeviceConfiguration::GetAdditionalSignalCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultSignalCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetAdditionalSignalCount(m_pHandle, &resultSignalCount));
		
		return resultSignalCount;
	}
	
	/**
	* CDeviceConfiguration::GetRTCSignalIDs - Returns the configured RTC signal IDs of the configuration.
	* @param[out] SignalIDsBuffer - RTC Signal IDs
	*/
	void CDeviceConfiguration::GetRTCSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & SignalIDsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededSignalIDs = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenSignalIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetRTCSignalIDs(m_pHandle, 0, &elementsNeededSignalIDs, nullptr));
		SignalIDsBuffer.resize((size_t) elementsNeededSignalIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetRTCSignalIDs(m_pHandle, elementsNeededSignalIDs, &elementsWrittenSignalIDs, SignalIDsBuffer.data()));
	}
	
	/**
	* CDeviceConfiguration::GetSensorSignalIDs - Returns the configured Sensor signal IDs of the configuration.
	* @param[out] SignalIDsBuffer - Sensor Signal IDs
	*/
	void CDeviceConfiguration::GetSensorSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & SignalIDsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededSignalIDs = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenSignalIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetSensorSignalIDs(m_pHandle, 0, &elementsNeededSignalIDs, nullptr));
		SignalIDsBuffer.resize((size_t) elementsNeededSignalIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetSensorSignalIDs(m_pHandle, elementsNeededSignalIDs, &elementsWrittenSignalIDs, SignalIDsBuffer.data()));
	}
	
	/**
	* CDeviceConfiguration::GetAdditionalSignalIDs - Returns the configured Additional signal IDs of the configuration.
	* @param[out] AdditionalIDsBuffer - Additional Signal IDs
	*/
	void CDeviceConfiguration::GetAdditionalSignalIDs(std::vector<LibMCDriver_ScanLabOIE_uint32> & AdditionalIDsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededAdditionalIDs = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenAdditionalIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetAdditionalSignalIDs(m_pHandle, 0, &elementsNeededAdditionalIDs, nullptr));
		AdditionalIDsBuffer.resize((size_t) elementsNeededAdditionalIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetAdditionalSignalIDs(m_pHandle, elementsNeededAdditionalIDs, &elementsWrittenAdditionalIDs, AdditionalIDsBuffer.data()));
	}
	
	/**
	* CDeviceConfiguration::GetAdditionalSignalInfo - Returns the configured Additional signal information.
	* @param[in] nIndex - Index of additional signal. 0-based.
	* @param[out] nSignalID - ID of additional signal.
	* @param[out] sSignalName - Name of additional signal.
	*/
	void CDeviceConfiguration::GetAdditionalSignalInfo(const LibMCDriver_ScanLabOIE_uint32 nIndex, LibMCDriver_ScanLabOIE_uint32 & nSignalID, std::string & sSignalName)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededSignalName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenSignalName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetAdditionalSignalInfo(m_pHandle, nIndex, &nSignalID, 0, &bytesNeededSignalName, nullptr));
		std::vector<char> bufferSignalName(bytesNeededSignalName);
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetAdditionalSignalInfo(m_pHandle, nIndex, &nSignalID, bytesNeededSignalName, &bytesWrittenSignalName, &bufferSignalName[0]));
		sSignalName = std::string(&bufferSignalName[0]);
	}
	
	/**
	* CDeviceConfiguration::GetDeviceConfigurationString - Returns the device configuration string.
	* @return Device configuration string.
	*/
	std::string CDeviceConfiguration::GetDeviceConfigurationString()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededDeviceConfigurationString = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenDeviceConfigurationString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetDeviceConfigurationString(m_pHandle, 0, &bytesNeededDeviceConfigurationString, nullptr));
		std::vector<char> bufferDeviceConfigurationString(bytesNeededDeviceConfigurationString);
		CheckError(m_pWrapper->m_WrapperTable.m_DeviceConfiguration_GetDeviceConfigurationString(m_pHandle, bytesNeededDeviceConfigurationString, &bytesWrittenDeviceConfigurationString, &bufferDeviceConfigurationString[0]));
		
		return std::string(&bufferDeviceConfigurationString[0]);
	}
	
	/**
	 * Method definitions for class CDataRecording
	 */
	
	/**
	* CDataRecording::GetRTCSignalCount - Returns the configured RTC signal count of the configuration.
	* @return RTC Signal Count
	*/
	LibMCDriver_ScanLabOIE_uint32 CDataRecording::GetRTCSignalCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultSignalCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetRTCSignalCount(m_pHandle, &resultSignalCount));
		
		return resultSignalCount;
	}
	
	/**
	* CDataRecording::GetSensorSignalCount - Returns the configured Sensor signal count of the configuration.
	* @return Sensor Signal Count
	*/
	LibMCDriver_ScanLabOIE_uint32 CDataRecording::GetSensorSignalCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultSignalCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetSensorSignalCount(m_pHandle, &resultSignalCount));
		
		return resultSignalCount;
	}
	
	/**
	* CDataRecording::GetAdditionalSignalCount - Returns the configured Additional data signal count of the configuration.
	* @return Sensor Signal Count
	*/
	LibMCDriver_ScanLabOIE_uint32 CDataRecording::GetAdditionalSignalCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultSignalCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAdditionalSignalCount(m_pHandle, &resultSignalCount));
		
		return resultSignalCount;
	}
	
	/**
	* CDataRecording::GetRecordCount - Returns the number of records in the recording.
	* @return Number of records in the recording
	*/
	LibMCDriver_ScanLabOIE_uint64 CDataRecording::GetRecordCount()
	{
		LibMCDriver_ScanLabOIE_uint64 resultRecord = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetRecordCount(m_pHandle, &resultRecord));
		
		return resultRecord;
	}
	
	/**
	* CDataRecording::GetRecordInformation - Returns the information about a specific record.
	* @param[in] nIndex - Index of the record. 0-based. MUST be smaller than RecordCount.
	* @param[out] nPacketNumber - Packet Number of the record.
	* @param[out] dX - X Coordinate of the record.
	* @param[out] dY - Y Coordinate of the record.
	*/
	void CDataRecording::GetRecordInformation(const LibMCDriver_ScanLabOIE_uint32 nIndex, LibMCDriver_ScanLabOIE_uint32 & nPacketNumber, LibMCDriver_ScanLabOIE_double & dX, LibMCDriver_ScanLabOIE_double & dY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetRecordInformation(m_pHandle, nIndex, &nPacketNumber, &dX, &dY));
	}
	
	/**
	* CDataRecording::GetMeasurementTag - Returns the measurement tag of a specific record.
	* @param[in] nIndex - Index of the record. 0-based. MUST be smaller than RecordCount.
	* @return Measurement Tag of the record.
	*/
	LibMCDriver_ScanLabOIE_uint32 CDataRecording::GetMeasurementTag(const LibMCDriver_ScanLabOIE_uint32 nIndex)
	{
		LibMCDriver_ScanLabOIE_uint32 resultMeasurementTag = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetMeasurementTag(m_pHandle, nIndex, &resultMeasurementTag));
		
		return resultMeasurementTag;
	}
	
	/**
	* CDataRecording::GetRTCSignalsOfRecord - Returns the RTC signals of a specific record.
	* @param[in] nIndex - Index of the record. 0-based. MUST be smaller than RecordCount.
	* @param[out] RTCSignalsBuffer - Recorded RTC Signals
	*/
	void CDataRecording::GetRTCSignalsOfRecord(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & RTCSignalsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededRTCSignals = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenRTCSignals = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetRTCSignalsOfRecord(m_pHandle, nIndex, 0, &elementsNeededRTCSignals, nullptr));
		RTCSignalsBuffer.resize((size_t) elementsNeededRTCSignals);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetRTCSignalsOfRecord(m_pHandle, nIndex, elementsNeededRTCSignals, &elementsWrittenRTCSignals, RTCSignalsBuffer.data()));
	}
	
	/**
	* CDataRecording::GetSensorSignalsOfRecord - Returns the sensor signals of a specific record.
	* @param[in] nIndex - Index of the record. 0-based. MUST be smaller than RecordCount.
	* @param[out] SensorSignalsBuffer - Recorded Sensor Signals
	*/
	void CDataRecording::GetSensorSignalsOfRecord(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & SensorSignalsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededSensorSignals = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenSensorSignals = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetSensorSignalsOfRecord(m_pHandle, nIndex, 0, &elementsNeededSensorSignals, nullptr));
		SensorSignalsBuffer.resize((size_t) elementsNeededSensorSignals);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetSensorSignalsOfRecord(m_pHandle, nIndex, elementsNeededSensorSignals, &elementsWrittenSensorSignals, SensorSignalsBuffer.data()));
	}
	
	/**
	* CDataRecording::GetAdditionalSignalsOfRecord - Returns the additional signals of a specific record.
	* @param[in] nIndex - Index of the record. 0-based. MUST be smaller than RecordCount.
	* @param[out] AdditionalSignalsBuffer - Recorded Additional Signals
	*/
	void CDataRecording::GetAdditionalSignalsOfRecord(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & AdditionalSignalsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededAdditionalSignals = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenAdditionalSignals = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAdditionalSignalsOfRecord(m_pHandle, nIndex, 0, &elementsNeededAdditionalSignals, nullptr));
		AdditionalSignalsBuffer.resize((size_t) elementsNeededAdditionalSignals);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAdditionalSignalsOfRecord(m_pHandle, nIndex, elementsNeededAdditionalSignals, &elementsWrittenAdditionalSignals, AdditionalSignalsBuffer.data()));
	}
	
	/**
	* CDataRecording::GetAllCoordinates - Returns an array of all coordinates.
	* @param[out] XArrayBuffer - Array of X Coordinates of all records.
	* @param[out] YArrayBuffer - Array of Y Coordinates of all records.
	*/
	void CDataRecording::GetAllCoordinates(std::vector<LibMCDriver_ScanLabOIE_double> & XArrayBuffer, std::vector<LibMCDriver_ScanLabOIE_double> & YArrayBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededXArray = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenXArray = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsNeededYArray = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenYArray = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllCoordinates(m_pHandle, 0, &elementsNeededXArray, nullptr, 0, &elementsNeededYArray, nullptr));
		XArrayBuffer.resize((size_t) elementsNeededXArray);
		YArrayBuffer.resize((size_t) elementsNeededYArray);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllCoordinates(m_pHandle, elementsNeededXArray, &elementsWrittenXArray, XArrayBuffer.data(), elementsNeededYArray, &elementsWrittenYArray, YArrayBuffer.data()));
	}
	
	/**
	* CDataRecording::GetAllPacketNumbers - Returns an array of all packet numbers.
	* @param[out] PacketNumersBuffer - Array of Packet Numbers of all records.
	*/
	void CDataRecording::GetAllPacketNumbers(std::vector<LibMCDriver_ScanLabOIE_uint32> & PacketNumersBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededPacketNumers = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenPacketNumers = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllPacketNumbers(m_pHandle, 0, &elementsNeededPacketNumers, nullptr));
		PacketNumersBuffer.resize((size_t) elementsNeededPacketNumers);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllPacketNumbers(m_pHandle, elementsNeededPacketNumers, &elementsWrittenPacketNumers, PacketNumersBuffer.data()));
	}
	
	/**
	* CDataRecording::GetAllMeasurementTags - Returns an array of all measurement tags.
	* @param[out] MeasurementTagsBuffer - Array of Measurement Tags of all records.
	*/
	void CDataRecording::GetAllMeasurementTags(std::vector<LibMCDriver_ScanLabOIE_uint32> & MeasurementTagsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededMeasurementTags = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenMeasurementTags = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllMeasurementTags(m_pHandle, 0, &elementsNeededMeasurementTags, nullptr));
		MeasurementTagsBuffer.resize((size_t) elementsNeededMeasurementTags);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllMeasurementTags(m_pHandle, elementsNeededMeasurementTags, &elementsWrittenMeasurementTags, MeasurementTagsBuffer.data()));
	}
	
	/**
	* CDataRecording::GetAllRTCSignals - Returns an array of all RTC signals of a specific index.
	* @param[in] nRTCIndex - Index of the signal to return. 0-based. MUST be smaller than RTCSignalCount.
	* @param[out] SignalsBuffer - Array of the Indexed Sensor Signal of all records.
	*/
	void CDataRecording::GetAllRTCSignals(const LibMCDriver_ScanLabOIE_uint32 nRTCIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & SignalsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededSignals = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenSignals = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllRTCSignals(m_pHandle, nRTCIndex, 0, &elementsNeededSignals, nullptr));
		SignalsBuffer.resize((size_t) elementsNeededSignals);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllRTCSignals(m_pHandle, nRTCIndex, elementsNeededSignals, &elementsWrittenSignals, SignalsBuffer.data()));
	}
	
	/**
	* CDataRecording::GetAllSensorSignals - Returns an array of all sensor signals of a specific index.
	* @param[in] nSignalIndex - Index of the signal to return. 0-based. MUST be smaller than SensorSignalCount.
	* @param[out] SignalsBuffer - Array of the Indexed RTC Signal of all records.
	*/
	void CDataRecording::GetAllSensorSignals(const LibMCDriver_ScanLabOIE_uint32 nSignalIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & SignalsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededSignals = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenSignals = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllSensorSignals(m_pHandle, nSignalIndex, 0, &elementsNeededSignals, nullptr));
		SignalsBuffer.resize((size_t) elementsNeededSignals);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllSensorSignals(m_pHandle, nSignalIndex, elementsNeededSignals, &elementsWrittenSignals, SignalsBuffer.data()));
	}
	
	/**
	* CDataRecording::GetAllAdditionalSignals - Returns an array of all additional signals of a specific index.
	* @param[in] nAdditionalIndex - Index of the signal to return. 0-based. MUST be smaller than AdditionalSignalCount.
	* @param[out] SignalsBuffer - Array of the Indexed RTC Signal of all records.
	*/
	void CDataRecording::GetAllAdditionalSignals(const LibMCDriver_ScanLabOIE_uint32 nAdditionalIndex, std::vector<LibMCDriver_ScanLabOIE_int32> & SignalsBuffer)
	{
		LibMCDriver_ScanLabOIE_uint64 elementsNeededSignals = 0;
		LibMCDriver_ScanLabOIE_uint64 elementsWrittenSignals = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllAdditionalSignals(m_pHandle, nAdditionalIndex, 0, &elementsNeededSignals, nullptr));
		SignalsBuffer.resize((size_t) elementsNeededSignals);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_GetAllAdditionalSignals(m_pHandle, nAdditionalIndex, elementsNeededSignals, &elementsWrittenSignals, SignalsBuffer.data()));
	}
	
	/**
	* CDataRecording::StoreAsBuildData - Stores the recording attached to a build data object. The mime-type of the data will be application/scanlaboie-1.0.
	* @param[in] sName - Name of the recording to be stored.
	* @param[in] pBuild - Build that should store the data.
	* @return Data UUID of the build data.
	*/
	std::string CDataRecording::StoreAsBuildData(const std::string & sName, classParam<LibMCEnv::CBuild> pBuild)
	{
		LibMCEnvHandle hBuild = pBuild.GetHandle();
		LibMCDriver_ScanLabOIE_uint32 bytesNeededDataUUID = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_StoreAsBuildData(m_pHandle, sName.c_str(), hBuild, 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_DataRecording_StoreAsBuildData(m_pHandle, sName.c_str(), hBuild, bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	 * Method definitions for class COIEDevice
	 */
	
	/**
	* COIEDevice::GetDeviceName - Returns the unique name of the device.
	* @return Name of device.
	*/
	std::string COIEDevice::GetDeviceName()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededDeviceName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenDeviceName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetDeviceName(m_pHandle, 0, &bytesNeededDeviceName, nullptr));
		std::vector<char> bufferDeviceName(bytesNeededDeviceName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetDeviceName(m_pHandle, bytesNeededDeviceName, &bytesWrittenDeviceName, &bufferDeviceName[0]));
		
		return std::string(&bufferDeviceName[0]);
	}
	
	/**
	* COIEDevice::SetHostName - Sets the host name of the device. Fails if device is already connected.
	* @param[in] sHostName - New Host name of device.
	*/
	void COIEDevice::SetHostName(const std::string & sHostName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_SetHostName(m_pHandle, sHostName.c_str()));
	}
	
	/**
	* COIEDevice::GetHostName - Returns the host name of the device.
	* @return Host name of device.
	*/
	std::string COIEDevice::GetHostName()
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededHostName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenHostName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetHostName(m_pHandle, 0, &bytesNeededHostName, nullptr));
		std::vector<char> bufferHostName(bytesNeededHostName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetHostName(m_pHandle, bytesNeededHostName, &bytesWrittenHostName, &bufferHostName[0]));
		
		return std::string(&bufferHostName[0]);
	}
	
	/**
	* COIEDevice::SetPort - Sets the port of the device. Fails if device is already connected.
	* @param[in] nPort - New port of device.
	*/
	void COIEDevice::SetPort(const LibMCDriver_ScanLabOIE_uint32 nPort)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_SetPort(m_pHandle, nPort));
	}
	
	/**
	* COIEDevice::GetPort - Returns the port of the device. Fails if device is already connected.
	* @return Port of device.
	*/
	LibMCDriver_ScanLabOIE_uint32 COIEDevice::GetPort()
	{
		LibMCDriver_ScanLabOIE_uint32 resultPort = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetPort(m_pHandle, &resultPort));
		
		return resultPort;
	}
	
	/**
	* COIEDevice::IsConnected - Returns if the device is connected and logged in.
	* @return Flag if the device is connected.
	*/
	bool COIEDevice::IsConnected()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_IsConnected(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* COIEDevice::GetDeviceID - Returns the ID of the device.
	* @return ID of the device.
	*/
	LibMCDriver_ScanLabOIE_uint32 COIEDevice::GetDeviceID()
	{
		LibMCDriver_ScanLabOIE_uint32 resultDeviceID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetDeviceID(m_pHandle, &resultDeviceID));
		
		return resultDeviceID;
	}
	
	/**
	* COIEDevice::Connect - Connects to the device and attempts to log in with user name and password.
	* @param[in] sUserName - UserName to use.
	* @param[in] sPassword - Password to use.
	*/
	void COIEDevice::Connect(const std::string & sUserName, const std::string & sPassword)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_Connect(m_pHandle, sUserName.c_str(), sPassword.c_str()));
	}
	
	/**
	* COIEDevice::Disconnect - Disconnects from the device. Has no effect if device is not connected.
	*/
	void COIEDevice::Disconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_Disconnect(m_pHandle));
	}
	
	/**
	* COIEDevice::RefreshAppList - Refreshes the list of installed apps on the system.
	*/
	void COIEDevice::RefreshAppList()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_RefreshAppList(m_pHandle));
	}
	
	/**
	* COIEDevice::GetAppCount - Returns how many apps are installed on the device. Fails if device is not connected.
	* @return Number of apps installed on the device.
	*/
	LibMCDriver_ScanLabOIE_uint32 COIEDevice::GetAppCount()
	{
		LibMCDriver_ScanLabOIE_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* COIEDevice::GetAppName - Returns the name of an app from the app list.
	* @param[in] nIndex - Index of App, 0-based
	* @return Name of app.
	*/
	std::string COIEDevice::GetAppName(const LibMCDriver_ScanLabOIE_uint32 nIndex)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppName(m_pHandle, nIndex, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppName(m_pHandle, nIndex, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* COIEDevice::GetAppVersion - Returns the version of an app from the app list.
	* @param[in] nIndex - Index of App, 0-based
	* @param[out] nMajor - Major version of the app.
	* @param[out] nMinor - Minor version of the app.
	* @param[out] nPatch - Patch version of the app.
	*/
	void COIEDevice::GetAppVersion(const LibMCDriver_ScanLabOIE_uint32 nIndex, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppVersion(m_pHandle, nIndex, &nMajor, &nMinor, &nPatch));
	}
	
	/**
	* COIEDevice::GetAppInfo - Returns the name and version of an app from the app list.
	* @param[in] nIndex - Index of App, 0-based
	* @param[out] sName - Name of app.
	* @param[out] nMajor - Major version of the app.
	* @param[out] nMinor - Minor version of the app.
	* @param[out] nPatch - Patch version of the app.
	*/
	void COIEDevice::GetAppInfo(const LibMCDriver_ScanLabOIE_uint32 nIndex, std::string & sName, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppInfo(m_pHandle, nIndex, 0, &bytesNeededName, nullptr, &nMajor, &nMinor, &nPatch));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetAppInfo(m_pHandle, nIndex, bytesNeededName, &bytesWrittenName, &bufferName[0], &nMajor, &nMinor, &nPatch));
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* COIEDevice::StartAppByName - Starts an app by its name. Fails if an app is already running. Starts recording of signals.
	* @param[in] sName - Name of app to be started.
	*/
	void COIEDevice::StartAppByName(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StartAppByName(m_pHandle, sName.c_str()));
	}
	
	/**
	* COIEDevice::StartAppByIndex - Starts an app by its index. Fails if an app is already running.
	* @param[in] nIndex - Index of App, 0-based
	*/
	void COIEDevice::StartAppByIndex(const LibMCDriver_ScanLabOIE_uint32 nIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StartAppByIndex(m_pHandle, nIndex));
	}
	
	/**
	* COIEDevice::StartAppByMajorVersion - Starts an app by its major version. Fails if an app is already running.
	* @param[in] sName - Name of app to be started.
	* @param[in] nMajorVersion - Major version of app to be started. Fails if app does not exist or only with wrong major number.
	*/
	void COIEDevice::StartAppByMajorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StartAppByMajorVersion(m_pHandle, sName.c_str(), nMajorVersion));
	}
	
	/**
	* COIEDevice::StartAppByMinorVersion - Starts an app by its major version. Fails if an app is already running.
	* @param[in] sName - Name of app to be started.
	* @param[in] nMajorVersion - Major version of app to be started. Fails if app does not exist or only with wrong major number.
	* @param[in] nMinorVersion - Minor version of app to be started. Fails if app does not exist or only with wrong minor number.
	*/
	void COIEDevice::StartAppByMinorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, const LibMCDriver_ScanLabOIE_uint32 nMinorVersion)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StartAppByMinorVersion(m_pHandle, sName.c_str(), nMajorVersion, nMinorVersion));
	}
	
	/**
	* COIEDevice::StopApp - Stops the currently running app. Does nothing if no app is running. Stops recording of signals.
	*/
	void COIEDevice::StopApp()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_StopApp(m_pHandle));
	}
	
	/**
	* COIEDevice::AppIsRunning - Returns if the device is running an app.
	* @return Flag if the device is running an app.
	*/
	bool COIEDevice::AppIsRunning()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_AppIsRunning(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* COIEDevice::GetRunningApp - Returns if the app that is currently running on the device. Fails if no app is running on the device.
	* @param[out] sName - Name of app.
	* @param[out] nMajor - Major version of the app.
	* @param[out] nMinor - Minor version of the app.
	* @param[out] nPatch - Patch version of the app.
	*/
	void COIEDevice::GetRunningApp(std::string & sName, LibMCDriver_ScanLabOIE_uint32 & nMajor, LibMCDriver_ScanLabOIE_uint32 & nMinor, LibMCDriver_ScanLabOIE_uint32 & nPatch)
	{
		LibMCDriver_ScanLabOIE_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLabOIE_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetRunningApp(m_pHandle, 0, &bytesNeededName, nullptr, &nMajor, &nMinor, &nPatch));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_GetRunningApp(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0], &nMajor, &nMinor, &nPatch));
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* COIEDevice::InstallApp - Installs an app package on the device. Fails if any app is running on the device. You have to be logged in with an administrator account.
	* @param[in] AppPackageBuffer - Binary data of the app to be installed.
	*/
	void COIEDevice::InstallApp(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & AppPackageBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_InstallApp(m_pHandle, (LibMCDriver_ScanLabOIE_uint64)AppPackageBuffer.size(), AppPackageBuffer.data()));
	}
	
	/**
	* COIEDevice::UninstallAppByName - Uninstall all the versions of an app by its name. Fails if any app is running on the device.
	* @param[in] sName - Name of app to be uninstalled.
	*/
	void COIEDevice::UninstallAppByName(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_UninstallAppByName(m_pHandle, sName.c_str()));
	}
	
	/**
	* COIEDevice::UninstallAppByIndex - Uninstall an app by its index. Fails if any app is running on the device.
	* @param[in] nIndex - Index of App, 0-based
	*/
	void COIEDevice::UninstallAppByIndex(const LibMCDriver_ScanLabOIE_uint32 nIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_UninstallAppByIndex(m_pHandle, nIndex));
	}
	
	/**
	* COIEDevice::UninstallAppByMajorVersion - Uninstall all major versions of an app. Fails if any app is running on the device.
	* @param[in] sName - Name of app to be uninstalled.
	* @param[in] nMajorVersion - Major version of app to be uninstalled. Fails if app does not exist or only with wrong major number.
	*/
	void COIEDevice::UninstallAppByMajorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_UninstallAppByMajorVersion(m_pHandle, sName.c_str(), nMajorVersion));
	}
	
	/**
	* COIEDevice::UninstallAppByMinorVersion - Uninstall all minor versions of an app. Fails if any app is running on the device.
	* @param[in] sName - Name of app to be uninstalled.
	* @param[in] nMajorVersion - Major version of app to be uninstalled.
	* @param[in] nMinorVersion - Minor version of app to be uninstalled.
	*/
	void COIEDevice::UninstallAppByMinorVersion(const std::string & sName, const LibMCDriver_ScanLabOIE_uint32 nMajorVersion, const LibMCDriver_ScanLabOIE_uint32 nMinorVersion)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_UninstallAppByMinorVersion(m_pHandle, sName.c_str(), nMajorVersion, nMinorVersion));
	}
	
	/**
	* COIEDevice::RetrieveCurrentRecording - Retrieves a copy of the current recording DataRecording Instance and continues recording into a new empty instance.
	* @return Recording instance
	*/
	PDataRecording COIEDevice::RetrieveCurrentRecording()
	{
		LibMCDriver_ScanLabOIEHandle hRecordingInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_RetrieveCurrentRecording(m_pHandle, &hRecordingInstance));
		
		if (!hRecordingInstance) {
			CheckError(LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataRecording>(m_pWrapper, hRecordingInstance);
	}
	
	/**
	* COIEDevice::ClearCurrentRecording - Clears the current recording data and continues recording into a new empty instance.
	*/
	void COIEDevice::ClearCurrentRecording()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_ClearCurrentRecording(m_pHandle));
	}
	
	/**
	* COIEDevice::LoadRecordingFromBuild - Loads a recording from a previously stored build data. The mime-type of the data MUST be application/scanlaboie-1.0.
	* @param[in] pBuild - Build that contains the data.
	* @param[in] sDataUUID - Data UUID of the build data.
	* @return Recording instance
	*/
	PDataRecording COIEDevice::LoadRecordingFromBuild(classParam<LibMCEnv::CBuild> pBuild, const std::string & sDataUUID)
	{
		LibMCEnvHandle hBuild = pBuild.GetHandle();
		LibMCDriver_ScanLabOIEHandle hRecordingInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_OIEDevice_LoadRecordingFromBuild(m_pHandle, hBuild, sDataUUID.c_str(), &hRecordingInstance));
		
		if (!hRecordingInstance) {
			CheckError(LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataRecording>(m_pWrapper, hRecordingInstance);
	}
	
	/**
	 * Method definitions for class CDriver_ScanLab_OIE
	 */
	
	/**
	* CDriver_ScanLab_OIE::GetDriverType - Returns the type of the device driver.
	* @return Type of device driver.
	*/
	eOIEDeviceDriverType CDriver_ScanLab_OIE::GetDriverType()
	{
		eOIEDeviceDriverType resultDeviceDriverType = (eOIEDeviceDriverType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_GetDriverType(m_pHandle, &resultDeviceDriverType));
		
		return resultDeviceDriverType;
	}
	
	/**
	* CDriver_ScanLab_OIE::SetDependencyResourceNames - Sets the resource names of the OIE SDK Dependencies. Searches in Machine Resources first, then in Driver Resources.
	* @param[in] sLibSSLResourceName - Resource name of LibSSL DLL. Default is libssl_win64 or libssl_linux64, depending on platform.
	* @param[in] sLibCryptoResourceName - Resource name of LibCrypto DLL. Default is libcrypto_win64 or libcrypto_linux64, depending on platform.
	* @param[in] sQT5CoreResourceName - Resource name of Qt5Core DLL. Default is qt5core_win64 or qt5core_linux64, depending on platform.
	* @param[in] sQT5NetworkResourceName - Resource name of Qt5Network DLL. Default is qt5network_win64 or qt5network_linux64, depending on platform.
	*/
	void CDriver_ScanLab_OIE::SetDependencyResourceNames(const std::string & sLibSSLResourceName, const std::string & sLibCryptoResourceName, const std::string & sQT5CoreResourceName, const std::string & sQT5NetworkResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_SetDependencyResourceNames(m_pHandle, sLibSSLResourceName.c_str(), sLibCryptoResourceName.c_str(), sQT5CoreResourceName.c_str(), sQT5NetworkResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLab_OIE::SetOIE3ResourceNames - Sets the resource names of the OIE SDK Dependencies for version 3. Searches in Machine Resources first, then in Driver Resources.
	* @param[in] sOIECalibrationLibraryResourceName - Resource name of OIE Calibration Library DLL. Default is oiecalibrationlibrary_win64 or oiecalibrationlibrary_linux64, depending on platform.
	* @param[in] sRTCStreamParserResourceName - Resource name of RTC Stream Parser Library DLL. Default is oiestreamparser_win64 or oiestreamparser_linux64, depending on platform.
	*/
	void CDriver_ScanLab_OIE::SetOIE3ResourceNames(const std::string & sOIECalibrationLibraryResourceName, const std::string & sRTCStreamParserResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_SetOIE3ResourceNames(m_pHandle, sOIECalibrationLibraryResourceName.c_str(), sRTCStreamParserResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLab_OIE::InitializeSDK - Initializes the ScanLab OIE SDK.
	* @param[in] sOIEResourceName - Resource name of Scanlab OIE DLL. Searches in Machine Resources first, then in Driver Resources.
	*/
	void CDriver_ScanLab_OIE::InitializeSDK(const std::string & sOIEResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_InitializeSDK(m_pHandle, sOIEResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLab_OIE::InitializeCustomSDK - Initializes the ScanLab OIE SDK from a custom array.
	* @param[in] OIEDLLBuffer - Byte array of Scanlab OIE DLL
	*/
	void CDriver_ScanLab_OIE::InitializeCustomSDK(const CInputVector<LibMCDriver_ScanLabOIE_uint8> & OIEDLLBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_InitializeCustomSDK(m_pHandle, (LibMCDriver_ScanLabOIE_uint64)OIEDLLBuffer.size(), OIEDLLBuffer.data()));
	}
	
	/**
	* CDriver_ScanLab_OIE::AddDevice - Adds a new device to the OIE.
	* @param[in] sName - Name of the device. MUST be a unique string and not exist yet.
	* @param[in] sHostName - Host name of device.
	* @param[in] nPort - Port of device.
	* @param[in] pDeviceConfig - Device configuration instance.
	* @param[in] CorrectionDataBuffer - Patch version of the app.
	* @param[in] nResponseTimeOut - Response timeout of device in ms.
	* @return OIE Device Instance
	*/
	POIEDevice CDriver_ScanLab_OIE::AddDevice(const std::string & sName, const std::string & sHostName, const LibMCDriver_ScanLabOIE_uint32 nPort, classParam<CDeviceConfiguration> pDeviceConfig, const CInputVector<LibMCDriver_ScanLabOIE_uint8> & CorrectionDataBuffer, const LibMCDriver_ScanLabOIE_uint32 nResponseTimeOut)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceConfig = pDeviceConfig.GetHandle();
		LibMCDriver_ScanLabOIEHandle hDeviceInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_AddDevice(m_pHandle, sName.c_str(), sHostName.c_str(), nPort, hDeviceConfig, (LibMCDriver_ScanLabOIE_uint64)CorrectionDataBuffer.size(), CorrectionDataBuffer.data(), nResponseTimeOut, &hDeviceInstance));
		
		if (!hDeviceInstance) {
			CheckError(LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COIEDevice>(m_pWrapper, hDeviceInstance);
	}
	
	/**
	* CDriver_ScanLab_OIE::HasDevice - Checks a device with the given name has been previously added.
	* @param[in] sName - Name of the device.
	* @return Flag if device exists.
	*/
	bool CDriver_ScanLab_OIE::HasDevice(const std::string & sName)
	{
		bool resultHasDevice = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_HasDevice(m_pHandle, sName.c_str(), &resultHasDevice));
		
		return resultHasDevice;
	}
	
	/**
	* CDriver_ScanLab_OIE::FindDevice - Finds a previously added device by name. Device MUST exist or function throws an error.
	* @param[in] sName - Name of the device.
	* @return OIE Device Instance
	*/
	POIEDevice CDriver_ScanLab_OIE::FindDevice(const std::string & sName)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_FindDevice(m_pHandle, sName.c_str(), &hDeviceInstance));
		
		if (!hDeviceInstance) {
			CheckError(LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COIEDevice>(m_pWrapper, hDeviceInstance);
	}
	
	/**
	* CDriver_ScanLab_OIE::RemoveDevice - Removes a device from the OIE.
	* @param[in] pDeviceInstance - OIE Device Instance
	*/
	void CDriver_ScanLab_OIE::RemoveDevice(classParam<COIEDevice> pDeviceInstance)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceInstance = pDeviceInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_RemoveDevice(m_pHandle, hDeviceInstance));
	}
	
	/**
	* CDriver_ScanLab_OIE::RemoveDeviceByName - Removes a device from the OIE by name. Does nothing if the device does not exist.
	* @param[in] sName - Name of the device.
	*/
	void CDriver_ScanLab_OIE::RemoveDeviceByName(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_RemoveDeviceByName(m_pHandle, sName.c_str()));
	}
	
	/**
	* CDriver_ScanLab_OIE::ParseDeviceConfiguration - Reads the configuration information from a device configuration string.
	* @param[in] sDeviceConfigString - Device config string.
	* @return Device configuration instance.
	*/
	PDeviceConfiguration CDriver_ScanLab_OIE::ParseDeviceConfiguration(const std::string & sDeviceConfigString)
	{
		LibMCDriver_ScanLabOIEHandle hDeviceConfigInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLab_OIE_ParseDeviceConfiguration(m_pHandle, sDeviceConfigString.c_str(), &hDeviceConfigInstance));
		
		if (!hDeviceConfigInstance) {
			CheckError(LIBMCDRIVER_SCANLABOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDeviceConfiguration>(m_pWrapper, hDeviceConfigInstance);
	}

} // namespace LibMCDriver_ScanLabOIE

#endif // __LIBMCDRIVER_SCANLABOIE_CPPHEADER_DYNAMIC_CPP

