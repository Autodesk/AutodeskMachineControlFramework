/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ header file in order to allow easy
development of ScanLab Open Interface Extension. The implementer of ScanLab Open Interface Extension needs to
derive concrete classes from the abstract classes in this header.

Interface version: 1.0.0

*/


#ifndef __LIBOIE_CPPINTERFACES
#define __LIBOIE_CPPINTERFACES

#include <string>
#include <memory>

#include "liboie_types.hpp"



namespace LibOIE {
namespace Impl {

/**
 Forward declarations of class interfaces
*/
class IBase;
class IIterator;
class IDataPackage;
class IPyroDataPackage;
class IPyroDataPackageIterator;
class IOctDataPackage;
class IOctDataPackageIterator;
class IRemoteFunctionCall;
class IConnection;
class IConnectionIterator;
class IServer;



/*************************************************************************************************************************
 Parameter Cache definitions
**************************************************************************************************************************/

class ParameterCache {
	public:
		virtual ~ParameterCache() {}
};

template <class T1> class ParameterCache_1 : public ParameterCache {
	private:
		T1 m_param1;
	public:
		ParameterCache_1 (const T1 & param1)
			: m_param1 (param1)
		{
		}

		void retrieveData (T1 & param1)
		{
			param1 = m_param1;
		}
};

template <class T1, class T2> class ParameterCache_2 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
	public:
		ParameterCache_2 (const T1 & param1, const T2 & param2)
			: m_param1 (param1), m_param2 (param2)
		{
		}

		void retrieveData (T1 & param1, T2 & param2)
		{
			param1 = m_param1;
			param2 = m_param2;
		}
};

template <class T1, class T2, class T3> class ParameterCache_3 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
	public:
		ParameterCache_3 (const T1 & param1, const T2 & param2, const T3 & param3)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
		}
};

template <class T1, class T2, class T3, class T4> class ParameterCache_4 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
		T4 m_param4;
	public:
		ParameterCache_4 (const T1 & param1, const T2 & param2, const T3 & param3, const T4 & param4)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3), m_param4 (param4)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3, T4 & param4)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
			param4 = m_param4;
		}
};


/*************************************************************************************************************************
 Class interface for Base 
**************************************************************************************************************************/

class IBase {
private:
	std::unique_ptr<ParameterCache> m_ParameterCache;
public:
	/**
	* IBase::~IBase - virtual destructor of IBase
	*/
	virtual ~IBase() {};

	/**
	* IBase::ReleaseBaseClassInterface - Releases ownership of a base class interface. Deletes the reference, if necessary.
	* @param[in] pIBase - The base class instance to release
	*/
	static void ReleaseBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->DecRefCount();
		}
	};

	/**
	* IBase::AcquireBaseClassInterface - Acquires shared ownership of a base class interface.
	* @param[in] pIBase - The base class instance to acquire
	*/
	static void AcquireBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->IncRefCount();
		}
	};


	/**
	* IBase::GetLastErrorMessage - Returns the last error registered of this class instance
	* @param[out] sErrorMessage - Message of the last error registered
	* @return Has an error been registered already
	*/
	virtual bool GetLastErrorMessage(std::string & sErrorMessage) = 0;

	/**
	* IBase::ClearErrorMessages - Clears all registered messages of this class instance
	*/
	virtual void ClearErrorMessages() = 0;

	/**
	* IBase::RegisterErrorMessage - Registers an error message with this class instance
	* @param[in] sErrorMessage - Error message to register
	*/
	virtual void RegisterErrorMessage(const std::string & sErrorMessage) = 0;

	/**
	* IBase::IncRefCount - Increases the reference count of a class instance
	*/
	virtual void IncRefCount() = 0;

	/**
	* IBase::DecRefCount - Decreases the reference count of a class instance and free releases it, if the last reference has been removed
	* @return Has the object been released
	*/
	virtual bool DecRefCount() = 0;

	/**
	* IBase::_setCache - set parameter cache of object
	*/
	void _setCache(ParameterCache * pCache)
	{
		m_ParameterCache.reset(pCache);
	}

	/**
	* IBase::_getCache - returns parameter cache of object
	*/
	ParameterCache* _getCache()
	{
		return m_ParameterCache.get();
	}

};


/**
 Definition of a shared pointer class for IBase
*/
template<class T>
class IBaseSharedPtr : public std::shared_ptr<T>
{
public:
	explicit IBaseSharedPtr(T* t = nullptr)
		: std::shared_ptr<T>(t, IBase::ReleaseBaseClassInterface)
	{
		t->IncRefCount();
	}

	// Reset function, as it also needs to properly set the deleter.
	void reset(T* t = nullptr)
	{
		std::shared_ptr<T>::reset(t, IBase::ReleaseBaseClassInterface);
	}

	// Get-function that increases the Base class's reference count
	T* getCoOwningPtr()
	{
		T* t = this->get();
		t->IncRefCount();
		return t;
	}
};


typedef IBaseSharedPtr<IBase> PIBase;


/*************************************************************************************************************************
 Class interface for Iterator 
**************************************************************************************************************************/

class IIterator : public virtual IBase {
public:
	/**
	* IIterator::MoveNext - Iterates to the next resource in the list.
	* @return Iterates to the next resource in the list.
	*/
	virtual bool MoveNext() = 0;

	/**
	* IIterator::MovePrevious - Iterates to the previous resource in the list.
	* @return Iterates to the previous resource in the list.
	*/
	virtual bool MovePrevious() = 0;

	/**
	* IIterator::GetCurrent - Returns the resource the iterator points at.
	* @return returns the resource instance.
	*/
	virtual IBase * GetCurrent() = 0;

	/**
	* IIterator::Clone - Creates a new resource iterator with the same resource list.
	* @return returns the cloned Iterator instance
	*/
	virtual IIterator * Clone() = 0;

	/**
	* IIterator::Count - Returns the number of resoucres the iterator captures.
	* @return returns the number of resources the iterator captures.
	*/
	virtual LibOIE_uint64 Count() = 0;

};

typedef IBaseSharedPtr<IIterator> PIIterator;


/*************************************************************************************************************************
 Class interface for DataPackage 
**************************************************************************************************************************/

class IDataPackage : public virtual IBase {
public:
	/**
	* IDataPackage::GetRawPayload - Returns the raw payload.
	* @param[in] nPayloadBufferSize - Number of elements in buffer
	* @param[out] pPayloadNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pPayloadBuffer - uint8 buffer of Raw payload data.
	*/
	virtual void GetRawPayload(LibOIE_uint64 nPayloadBufferSize, LibOIE_uint64* pPayloadNeededCount, LibOIE_uint8 * pPayloadBuffer) = 0;

	/**
	* IDataPackage::Release - Releases memory of the data package.
	*/
	virtual void Release() = 0;

};

typedef IBaseSharedPtr<IDataPackage> PIDataPackage;


/*************************************************************************************************************************
 Class interface for PyroDataPackage 
**************************************************************************************************************************/

class IPyroDataPackage : public virtual IDataPackage {
public:
};

typedef IBaseSharedPtr<IPyroDataPackage> PIPyroDataPackage;


/*************************************************************************************************************************
 Class interface for PyroDataPackageIterator 
**************************************************************************************************************************/

class IPyroDataPackageIterator : public virtual IIterator {
public:
	/**
	* IPyroDataPackageIterator::GetCurrentPyroDataPackage - Returns the data package the iterator points at.
	* @return returns the data package instance.
	*/
	virtual IPyroDataPackage * GetCurrentPyroDataPackage() = 0;

};

typedef IBaseSharedPtr<IPyroDataPackageIterator> PIPyroDataPackageIterator;


/*************************************************************************************************************************
 Class interface for OctDataPackage 
**************************************************************************************************************************/

class IOctDataPackage : public virtual IDataPackage {
public:
};

typedef IBaseSharedPtr<IOctDataPackage> PIOctDataPackage;


/*************************************************************************************************************************
 Class interface for OctDataPackageIterator 
**************************************************************************************************************************/

class IOctDataPackageIterator : public virtual IIterator {
public:
	/**
	* IOctDataPackageIterator::GetCurrentOctDataPackage - Returns the data package the iterator points at.
	* @return returns the data package instance.
	*/
	virtual IOctDataPackage * GetCurrentOctDataPackage() = 0;

};

typedef IBaseSharedPtr<IOctDataPackageIterator> PIOctDataPackageIterator;


/*************************************************************************************************************************
 Class interface for RemoteFunctionCall 
**************************************************************************************************************************/

class IRemoteFunctionCall : public virtual IBase {
public:
	/**
	* IRemoteFunctionCall::GetFunctionName - Returns function name
	* @return Function Name.
	*/
	virtual std::string GetFunctionName() = 0;

	/**
	* IRemoteFunctionCall::AddParameter - Adds a function call parameter
	* @param[in] sParameter - Parameter of the call.
	*/
	virtual void AddParameter(const std::string & sParameter) = 0;

	/**
	* IRemoteFunctionCall::Send - Sends a remote function call over its connection.
	* @return Returns result if successful.
	*/
	virtual std::string Send() = 0;

};

typedef IBaseSharedPtr<IRemoteFunctionCall> PIRemoteFunctionCall;


/*************************************************************************************************************************
 Class interface for Connection 
**************************************************************************************************************************/

class IConnection : public virtual IBase {
public:
	/**
	* IConnection::Disconnect - Disconnects and closes the connection
	*/
	virtual void Disconnect() = 0;

	/**
	* IConnection::SetRequestTimeout - Sets timeout value for each poll request below.
	* @param[in] nTimeout - Timeout in milliseconds. Default is 1000ms. Minimum 10ms, maximum 1000000ms.
	*/
	virtual void SetRequestTimeout(const LibOIE_uint32 nTimeout) = 0;

	/**
	* IConnection::SetMaxErrorCount - Sets the maximum error messages that can be received before the connection is terminated.
	* @param[in] nErrorCount - Max Error count. Default is 1024. Minimum 16, maximum 65535.
	*/
	virtual void SetMaxErrorCount(const LibOIE_uint32 nErrorCount) = 0;

	/**
	* IConnection::SetMaxMemoryCount - Sets the maximum memory buffer the data packets can use before the connection is terminated.
	* @param[in] nMaxMemoryCount - Max memory count in bytes. Default is 1MB. Minimum 1kB, maximum 1GB.
	*/
	virtual void SetMaxMemoryCount(const LibOIE_uint32 nMaxMemoryCount) = 0;

	/**
	* IConnection::SetBufferFile - Sets a temporary filename to which the packets are buffered.
	* @param[in] sFileName - Filename which should be used as buffer.
	* @param[in] nMaxMemoryCount - Max memory count in bytes. Default is 1MB. Minimum 1kB, maximum 1TB.
	*/
	virtual void SetBufferFile(const std::string & sFileName, const LibOIE_uint64 nMaxMemoryCount) = 0;

	/**
	* IConnection::UnsetBufferFile - Stops writing to disk.
	*/
	virtual void UnsetBufferFile() = 0;

	/**
	* IConnection::SetCheckAliveInterval - Sets check alive interval. 0ms means no check alive request is sent.
	* @param[in] nCheckAliveInterval - Timeout in milliseconds. Default is 1000ms. Max value is 1000000ms.
	*/
	virtual void SetCheckAliveInterval(const LibOIE_uint32 nCheckAliveInterval) = 0;

	/**
	* IConnection::RetrieveFirmwareVersion - Retrieves Firmware Version. Fails if firmware is not existing.
	* @param[in] sFirmwareName - Name of the firmware to retrieve.
	* @param[out] sFirmwareVersion - Version of the requested firmware.
	* @param[out] sFilename - Filename of the requested firmware.
	* @param[out] sFiledate - Timestamp of the requested firmware in ISO8601 Time.
	* @param[out] sSHA256 - Checksum of the requested firmware.
	*/
	virtual void RetrieveFirmwareVersion(const std::string & sFirmwareName, std::string & sFirmwareVersion, std::string & sFilename, std::string & sFiledate, std::string & sSHA256) = 0;

	/**
	* IConnection::UpdateFirmware - Retrieves Firmware Version. Fails if firmware is not existing.
	* @param[in] sFirmwareName - Name of the new firmware.
	* @param[in] sFirmwareVersion - Version of the new firmware.
	* @param[in] sFileName - Filename of the new firmware.
	* @param[in] sFileDate - Timestamp of the requested firmware in ISO8601 Time.
	* @param[in] sSHA256 - Checksum of the new firmware.
	* @param[in] nBinaryDataBufferSize - Number of elements in buffer
	* @param[in] pBinaryDataBuffer - Blob of new firmware.
	*/
	virtual void UpdateFirmware(const std::string & sFirmwareName, const std::string & sFirmwareVersion, const std::string & sFileName, const std::string & sFileDate, const std::string & sSHA256, const LibOIE_uint64 nBinaryDataBufferSize, const LibOIE_uint8 * pBinaryDataBuffer) = 0;

	/**
	* IConnection::StartFirmware - Starts firmware on Open Interface Extension.
	* @param[in] sFileName - Filename of the firmware to start.
	* @return Firmware successfully started.
	*/
	virtual bool StartFirmware(const std::string & sFileName) = 0;

	/**
	* IConnection::StopFirmware - Stops firmware on Open Interface Extension.
	* @param[in] sFileName - Filename of the firmware to stop.
	* @return Firmware successfully stopped.
	*/
	virtual bool StopFirmware(const std::string & sFileName) = 0;

	/**
	* IConnection::SetConnectionErrorCallback - sets a callback that triggers when a connection error occured.
	* @param[in] pCallback - callback function
	*/
	virtual void SetConnectionErrorCallback(const LibOIE::ConnectionErrorCallback pCallback) = 0;

	/**
	* IConnection::ClearErrors - clears the error log.
	*/
	virtual void ClearErrors() = 0;

	/**
	* IConnection::GetErrorCount - Returns the list of errors in the error log.
	* @return Errors in the error log.
	*/
	virtual LibOIE_uint32 GetErrorCount() = 0;

	/**
	* IConnection::GetError - Returns an error message of the error log
	* @param[in] nErrorIndex - Index of the error.
	* @param[out] sErrorMessage - Message of the error.
	* @param[out] sTimestamp - ISO8601 Time when the error was reported.
	*/
	virtual void GetError(const LibOIE_uint32 nErrorIndex, std::string & sErrorMessage, std::string & sTimestamp) = 0;

	/**
	* IConnection::CreateRemoteFunctionCall - Creates a new remote function call.
	* @param[in] sFunctionName - Function name.
	* @return Function call instance.
	*/
	virtual IRemoteFunctionCall * CreateRemoteFunctionCall(const std::string & sFunctionName) = 0;

	/**
	* IConnection::GetBufferedPyroPackages - Retrieves currently buffered pyro packages.
	* @return Iterator of buffered packages.
	*/
	virtual IPyroDataPackageIterator * GetBufferedPyroPackages() = 0;

	/**
	* IConnection::GetBufferedOctPackages - Retrieves currently buffered oct packages.
	* @return Iterator of buffered packages.
	*/
	virtual IOctDataPackageIterator * GetBufferedOctPackages() = 0;

};

typedef IBaseSharedPtr<IConnection> PIConnection;


/*************************************************************************************************************************
 Class interface for ConnectionIterator 
**************************************************************************************************************************/

class IConnectionIterator : public virtual IIterator {
public:
	/**
	* IConnectionIterator::GetCurrentConnection - Returns the connection the iterator points at.
	* @return returns the connection instance.
	*/
	virtual IConnection * GetCurrentConnection() = 0;

};

typedef IBaseSharedPtr<IConnectionIterator> PIConnectionIterator;


/*************************************************************************************************************************
 Class interface for Server 
**************************************************************************************************************************/

class IServer : public virtual IBase {
public:
	/**
	* IServer::Start - starts listening for connections.
	* @param[in] sIPAddress - IP Address to run on
	* @param[in] nPort - Port to run on
	* @param[in] bIPv6 - flag if IPv6 should be used
	*/
	virtual void Start(const std::string & sIPAddress, const LibOIE_uint32 nPort, const bool bIPv6) = 0;

	/**
	* IServer::Stop - stops listening for connections and disconnects existing ones.
	*/
	virtual void Stop() = 0;

	/**
	* IServer::CloseAllConnections - disconnects all connections but does not stop listening.
	*/
	virtual void CloseAllConnections() = 0;

	/**
	* IServer::SetThreadCount - sets the maximum thread count to use. Must be called before Start
	* @param[in] nThreadCount - Thread count to use (must be larger than 4, default is 32)
	*/
	virtual void SetThreadCount(const LibOIE_uint32 nThreadCount) = 0;

	/**
	* IServer::SetBufferSize - sets the receive buffer size
	* @param[in] nRCVBufferSize - Receive buffer size to use in bytes (must be between 4kB and 1GB, default is 1MB)
	*/
	virtual void SetBufferSize(const LibOIE_uint32 nRCVBufferSize) = 0;

	/**
	* IServer::AcceptDevice - adds an accepted device
	* @param[in] sDeviceName - Device name to be accepted. Empty string means all devices.
	* @param[in] sApplicationName - Application name to be accepted. Empty string means all applications.
	* @param[in] sVersionName - Version name to be accepted. Empty string means all versions.
	* @return Returns identifier of acceptance rule.
	*/
	virtual LibOIE_uint32 AcceptDevice(const std::string & sDeviceName, const std::string & sApplicationName, const std::string & sVersionName) = 0;

	/**
	* IServer::UnAcceptDevice - removes an accepted
	* @param[in] nRuleID - identifier of acceptance rule.
	*/
	virtual void UnAcceptDevice(const LibOIE_uint32 nRuleID) = 0;

	/**
	* IServer::ClearAcceptedDevices - clears all accepted device rules
	*/
	virtual void ClearAcceptedDevices() = 0;

	/**
	* IServer::ListConnections - lists all open connections
	* @return list of all open connections.
	*/
	virtual IConnectionIterator * ListConnections() = 0;

	/**
	* IServer::SetConnectionAcceptedCallback - sets a callback that triggers when a new connection was established.
	* @param[in] pCallback - callback function
	*/
	virtual void SetConnectionAcceptedCallback(const LibOIE::ConnectionAcceptedCallback pCallback) = 0;

	/**
	* IServer::SetConnectionRejectedCallback - sets a callback that triggers when a new connection was rejected.
	* @param[in] pCallback - callback function
	*/
	virtual void SetConnectionRejectedCallback(const LibOIE::ConnectionRejectedCallback pCallback) = 0;

};

typedef IBaseSharedPtr<IServer> PIServer;


/*************************************************************************************************************************
 Global functions declarations
**************************************************************************************************************************/
class CWrapper {
public:
	/**
	* Iliboie::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	static void GetVersion(LibOIE_uint32 & nMajor, LibOIE_uint32 & nMinor, LibOIE_uint32 & nMicro);

	/**
	* Iliboie::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	static bool GetLastError(IBase* pInstance, std::string & sErrorMessage);

	/**
	* Iliboie::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void ReleaseInstance(IBase* pInstance);

	/**
	* Iliboie::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void AcquireInstance(IBase* pInstance);

	/**
	* Iliboie::CreateServer - Creates a open interface extension server instance.
	* @return New Server instance
	*/
	static IServer * CreateServer();

};

LibOIEResult LibOIE_GetProcAddress (const char * pProcName, void ** ppProcAddress);

} // namespace Impl
} // namespace LibOIE

#endif // __LIBOIE_CPPINTERFACES
