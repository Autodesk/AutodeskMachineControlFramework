/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of ScanLab Open Interface Extension. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "liboie_abi.hpp"
#include "liboie_interfaces.hpp"
#include "liboie_interfaceexception.hpp"

#include <map>

using namespace LibOIE::Impl;

LibOIEResult handleLibOIEException(IBase * pIBaseClass, ELibOIEInterfaceException & Exception)
{
	LibOIEResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibOIEResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibOIEResult errorCode = LIBOIE_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibOIEResult handleUnhandledException(IBase * pIBaseClass)
{
	LibOIEResult errorCode = LIBOIE_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Iterator
**************************************************************************************************************************/
LibOIEResult liboie_iterator_movenext(LibOIE_Iterator pIterator, bool * pHasNext)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasNext == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		*pHasNext = pIIterator->MoveNext();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_iterator_moveprevious(LibOIE_Iterator pIterator, bool * pHasPrevious)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasPrevious == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		*pHasPrevious = pIIterator->MovePrevious();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_iterator_getcurrent(LibOIE_Iterator pIterator, LibOIE_Base * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIIterator->GetCurrent();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_iterator_clone(LibOIE_Iterator pIterator, LibOIE_Iterator * pOutIterator)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pOutIterator == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pBaseOutIterator(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pBaseOutIterator = pIIterator->Clone();

		*pOutIterator = (IBase*)(pBaseOutIterator);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_iterator_count(LibOIE_Iterator pIterator, LibOIE_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pCount == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		*pCount = pIIterator->Count();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for DataPackage
**************************************************************************************************************************/
LibOIEResult liboie_datapackage_getrawpayload(LibOIE_DataPackage pDataPackage, const LibOIE_uint64 nPayloadBufferSize, LibOIE_uint64* pPayloadNeededCount, LibOIE_uint8 * pPayloadBuffer)
{
	IBase* pIBaseClass = (IBase *)pDataPackage;

	try {
		if ((!pPayloadBuffer) && !(pPayloadNeededCount))
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IDataPackage* pIDataPackage = dynamic_cast<IDataPackage*>(pIBaseClass);
		if (!pIDataPackage)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIDataPackage->GetRawPayload(nPayloadBufferSize, pPayloadNeededCount, pPayloadBuffer);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_datapackage_release(LibOIE_DataPackage pDataPackage)
{
	IBase* pIBaseClass = (IBase *)pDataPackage;

	try {
		IDataPackage* pIDataPackage = dynamic_cast<IDataPackage*>(pIBaseClass);
		if (!pIDataPackage)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIDataPackage->Release();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for PyroDataPackage
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for PyroDataPackageIterator
**************************************************************************************************************************/
LibOIEResult liboie_pyrodatapackageiterator_getcurrentpyrodatapackage(LibOIE_PyroDataPackageIterator pPyroDataPackageIterator, LibOIE_PyroDataPackage * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pPyroDataPackageIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IPyroDataPackageIterator* pIPyroDataPackageIterator = dynamic_cast<IPyroDataPackageIterator*>(pIBaseClass);
		if (!pIPyroDataPackageIterator)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIPyroDataPackageIterator->GetCurrentPyroDataPackage();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for OctDataPackage
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for OctDataPackageIterator
**************************************************************************************************************************/
LibOIEResult liboie_octdatapackageiterator_getcurrentoctdatapackage(LibOIE_OctDataPackageIterator pOctDataPackageIterator, LibOIE_OctDataPackage * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pOctDataPackageIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IOctDataPackageIterator* pIOctDataPackageIterator = dynamic_cast<IOctDataPackageIterator*>(pIBaseClass);
		if (!pIOctDataPackageIterator)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIOctDataPackageIterator->GetCurrentOctDataPackage();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for RemoteFunctionCall
**************************************************************************************************************************/
LibOIEResult liboie_remotefunctioncall_getfunctionname(LibOIE_RemoteFunctionCall pRemoteFunctionCall, const LibOIE_uint32 nFunctionNameBufferSize, LibOIE_uint32* pFunctionNameNeededChars, char * pFunctionNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pRemoteFunctionCall;

	try {
		if ( (!pFunctionNameBuffer) && !(pFunctionNameNeededChars) )
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sFunctionName("");
		IRemoteFunctionCall* pIRemoteFunctionCall = dynamic_cast<IRemoteFunctionCall*>(pIBaseClass);
		if (!pIRemoteFunctionCall)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pFunctionNameBuffer == nullptr);
		if (isCacheCall) {
			sFunctionName = pIRemoteFunctionCall->GetFunctionName();

			pIRemoteFunctionCall->_setCache (new ParameterCache_1<std::string> (sFunctionName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIRemoteFunctionCall->_getCache ());
			if (cache == nullptr)
				throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
			cache->retrieveData (sFunctionName);
			pIRemoteFunctionCall->_setCache (nullptr);
		}
		
		if (pFunctionNameNeededChars)
			*pFunctionNameNeededChars = (LibOIE_uint32) (sFunctionName.size()+1);
		if (pFunctionNameBuffer) {
			if (sFunctionName.size() >= nFunctionNameBufferSize)
				throw ELibOIEInterfaceException (LIBOIE_ERROR_BUFFERTOOSMALL);
			for (size_t iFunctionName = 0; iFunctionName < sFunctionName.size(); iFunctionName++)
				pFunctionNameBuffer[iFunctionName] = sFunctionName[iFunctionName];
			pFunctionNameBuffer[sFunctionName.size()] = 0;
		}
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_remotefunctioncall_addparameter(LibOIE_RemoteFunctionCall pRemoteFunctionCall, const char * pParameter)
{
	IBase* pIBaseClass = (IBase *)pRemoteFunctionCall;

	try {
		if (pParameter == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sParameter(pParameter);
		IRemoteFunctionCall* pIRemoteFunctionCall = dynamic_cast<IRemoteFunctionCall*>(pIBaseClass);
		if (!pIRemoteFunctionCall)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIRemoteFunctionCall->AddParameter(sParameter);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_remotefunctioncall_send(LibOIE_RemoteFunctionCall pRemoteFunctionCall, const LibOIE_uint32 nResultStringBufferSize, LibOIE_uint32* pResultStringNeededChars, char * pResultStringBuffer)
{
	IBase* pIBaseClass = (IBase *)pRemoteFunctionCall;

	try {
		if ( (!pResultStringBuffer) && !(pResultStringNeededChars) )
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sResultString("");
		IRemoteFunctionCall* pIRemoteFunctionCall = dynamic_cast<IRemoteFunctionCall*>(pIBaseClass);
		if (!pIRemoteFunctionCall)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pResultStringBuffer == nullptr);
		if (isCacheCall) {
			sResultString = pIRemoteFunctionCall->Send();

			pIRemoteFunctionCall->_setCache (new ParameterCache_1<std::string> (sResultString));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIRemoteFunctionCall->_getCache ());
			if (cache == nullptr)
				throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
			cache->retrieveData (sResultString);
			pIRemoteFunctionCall->_setCache (nullptr);
		}
		
		if (pResultStringNeededChars)
			*pResultStringNeededChars = (LibOIE_uint32) (sResultString.size()+1);
		if (pResultStringBuffer) {
			if (sResultString.size() >= nResultStringBufferSize)
				throw ELibOIEInterfaceException (LIBOIE_ERROR_BUFFERTOOSMALL);
			for (size_t iResultString = 0; iResultString < sResultString.size(); iResultString++)
				pResultStringBuffer[iResultString] = sResultString[iResultString];
			pResultStringBuffer[sResultString.size()] = 0;
		}
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Connection
**************************************************************************************************************************/
LibOIEResult liboie_connection_disconnect(LibOIE_Connection pConnection)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->Disconnect();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_setrequesttimeout(LibOIE_Connection pConnection, LibOIE_uint32 nTimeout)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->SetRequestTimeout(nTimeout);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_setmaxerrorcount(LibOIE_Connection pConnection, LibOIE_uint32 nErrorCount)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->SetMaxErrorCount(nErrorCount);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_setmaxmemorycount(LibOIE_Connection pConnection, LibOIE_uint32 nMaxMemoryCount)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->SetMaxMemoryCount(nMaxMemoryCount);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_setbufferfile(LibOIE_Connection pConnection, const char * pFileName, LibOIE_uint64 nMaxMemoryCount)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if (pFileName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->SetBufferFile(sFileName, nMaxMemoryCount);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_unsetbufferfile(LibOIE_Connection pConnection)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->UnsetBufferFile();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_setcheckaliveinterval(LibOIE_Connection pConnection, LibOIE_uint32 nCheckAliveInterval)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->SetCheckAliveInterval(nCheckAliveInterval);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_retrievefirmwareversion(LibOIE_Connection pConnection, const char * pFirmwareName, const LibOIE_uint32 nFirmwareVersionBufferSize, LibOIE_uint32* pFirmwareVersionNeededChars, char * pFirmwareVersionBuffer, const LibOIE_uint32 nFilenameBufferSize, LibOIE_uint32* pFilenameNeededChars, char * pFilenameBuffer, const LibOIE_uint32 nFiledateBufferSize, LibOIE_uint32* pFiledateNeededChars, char * pFiledateBuffer, const LibOIE_uint32 nSHA256BufferSize, LibOIE_uint32* pSHA256NeededChars, char * pSHA256Buffer)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if (pFirmwareName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if ( (!pFirmwareVersionBuffer) && !(pFirmwareVersionNeededChars) )
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if ( (!pFilenameBuffer) && !(pFilenameNeededChars) )
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if ( (!pFiledateBuffer) && !(pFiledateNeededChars) )
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if ( (!pSHA256Buffer) && !(pSHA256NeededChars) )
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sFirmwareName(pFirmwareName);
		std::string sFirmwareVersion("");
		std::string sFilename("");
		std::string sFiledate("");
		std::string sSHA256("");
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pFirmwareVersionBuffer == nullptr) || (pFilenameBuffer == nullptr) || (pFiledateBuffer == nullptr) || (pSHA256Buffer == nullptr);
		if (isCacheCall) {
			pIConnection->RetrieveFirmwareVersion(sFirmwareName, sFirmwareVersion, sFilename, sFiledate, sSHA256);

			pIConnection->_setCache (new ParameterCache_4<std::string, std::string, std::string, std::string> (sFirmwareVersion, sFilename, sFiledate, sSHA256));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<std::string, std::string, std::string, std::string>*> (pIConnection->_getCache ());
			if (cache == nullptr)
				throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
			cache->retrieveData (sFirmwareVersion, sFilename, sFiledate, sSHA256);
			pIConnection->_setCache (nullptr);
		}
		
		if (pFirmwareVersionNeededChars)
			*pFirmwareVersionNeededChars = (LibOIE_uint32) (sFirmwareVersion.size()+1);
		if (pFirmwareVersionBuffer) {
			if (sFirmwareVersion.size() >= nFirmwareVersionBufferSize)
				throw ELibOIEInterfaceException (LIBOIE_ERROR_BUFFERTOOSMALL);
			for (size_t iFirmwareVersion = 0; iFirmwareVersion < sFirmwareVersion.size(); iFirmwareVersion++)
				pFirmwareVersionBuffer[iFirmwareVersion] = sFirmwareVersion[iFirmwareVersion];
			pFirmwareVersionBuffer[sFirmwareVersion.size()] = 0;
		}
		if (pFilenameNeededChars)
			*pFilenameNeededChars = (LibOIE_uint32) (sFilename.size()+1);
		if (pFilenameBuffer) {
			if (sFilename.size() >= nFilenameBufferSize)
				throw ELibOIEInterfaceException (LIBOIE_ERROR_BUFFERTOOSMALL);
			for (size_t iFilename = 0; iFilename < sFilename.size(); iFilename++)
				pFilenameBuffer[iFilename] = sFilename[iFilename];
			pFilenameBuffer[sFilename.size()] = 0;
		}
		if (pFiledateNeededChars)
			*pFiledateNeededChars = (LibOIE_uint32) (sFiledate.size()+1);
		if (pFiledateBuffer) {
			if (sFiledate.size() >= nFiledateBufferSize)
				throw ELibOIEInterfaceException (LIBOIE_ERROR_BUFFERTOOSMALL);
			for (size_t iFiledate = 0; iFiledate < sFiledate.size(); iFiledate++)
				pFiledateBuffer[iFiledate] = sFiledate[iFiledate];
			pFiledateBuffer[sFiledate.size()] = 0;
		}
		if (pSHA256NeededChars)
			*pSHA256NeededChars = (LibOIE_uint32) (sSHA256.size()+1);
		if (pSHA256Buffer) {
			if (sSHA256.size() >= nSHA256BufferSize)
				throw ELibOIEInterfaceException (LIBOIE_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA256 = 0; iSHA256 < sSHA256.size(); iSHA256++)
				pSHA256Buffer[iSHA256] = sSHA256[iSHA256];
			pSHA256Buffer[sSHA256.size()] = 0;
		}
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_updatefirmware(LibOIE_Connection pConnection, const char * pFirmwareName, const char * pFirmwareVersion, const char * pFileName, const char * pFileDate, const char * pSHA256, LibOIE_uint64 nBinaryDataBufferSize, const LibOIE_uint8 * pBinaryDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if (pFirmwareName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pFirmwareVersion == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pFileName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pFileDate == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pSHA256 == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if ( (!pBinaryDataBuffer) && (nBinaryDataBufferSize>0))
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sFirmwareName(pFirmwareName);
		std::string sFirmwareVersion(pFirmwareVersion);
		std::string sFileName(pFileName);
		std::string sFileDate(pFileDate);
		std::string sSHA256(pSHA256);
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->UpdateFirmware(sFirmwareName, sFirmwareVersion, sFileName, sFileDate, sSHA256, nBinaryDataBufferSize, pBinaryDataBuffer);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_startfirmware(LibOIE_Connection pConnection, const char * pFileName, bool * pSuccess)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if (pFileName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pSuccess == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		*pSuccess = pIConnection->StartFirmware(sFileName);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_stopfirmware(LibOIE_Connection pConnection, const char * pFileName, bool * pSuccess)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if (pFileName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pSuccess == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		*pSuccess = pIConnection->StopFirmware(sFileName);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_setconnectionerrorcallback(LibOIE_Connection pConnection, LibOIEConnectionErrorCallback pCallback)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->SetConnectionErrorCallback(pCallback);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_clearerrors(LibOIE_Connection pConnection)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIConnection->ClearErrors();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_geterrorcount(LibOIE_Connection pConnection, LibOIE_uint32 * pErrorCount)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if (pErrorCount == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		*pErrorCount = pIConnection->GetErrorCount();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_geterror(LibOIE_Connection pConnection, LibOIE_uint32 nErrorIndex, const LibOIE_uint32 nErrorMessageBufferSize, LibOIE_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, const LibOIE_uint32 nTimestampBufferSize, LibOIE_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sErrorMessage("");
		std::string sTimestamp("");
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pErrorMessageBuffer == nullptr) || (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			pIConnection->GetError(nErrorIndex, sErrorMessage, sTimestamp);

			pIConnection->_setCache (new ParameterCache_2<std::string, std::string> (sErrorMessage, sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pIConnection->_getCache ());
			if (cache == nullptr)
				throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
			cache->retrieveData (sErrorMessage, sTimestamp);
			pIConnection->_setCache (nullptr);
		}
		
		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibOIE_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibOIEInterfaceException (LIBOIE_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibOIE_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibOIEInterfaceException (LIBOIE_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_createremotefunctioncall(LibOIE_Connection pConnection, const char * pFunctionName, LibOIE_RemoteFunctionCall * pInstance)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if (pFunctionName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pInstance == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sFunctionName(pFunctionName);
		IBase* pBaseInstance(nullptr);
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pBaseInstance = pIConnection->CreateRemoteFunctionCall(sFunctionName);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_getbufferedpyropackages(LibOIE_Connection pConnection, LibOIE_PyroDataPackageIterator * pIterator)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if (pIterator == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pBaseIterator(nullptr);
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pBaseIterator = pIConnection->GetBufferedPyroPackages();

		*pIterator = (IBase*)(pBaseIterator);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_connection_getbufferedoctpackages(LibOIE_Connection pConnection, LibOIE_OctDataPackageIterator * pIterator)
{
	IBase* pIBaseClass = (IBase *)pConnection;

	try {
		if (pIterator == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pBaseIterator(nullptr);
		IConnection* pIConnection = dynamic_cast<IConnection*>(pIBaseClass);
		if (!pIConnection)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pBaseIterator = pIConnection->GetBufferedOctPackages();

		*pIterator = (IBase*)(pBaseIterator);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ConnectionIterator
**************************************************************************************************************************/
LibOIEResult liboie_connectioniterator_getcurrentconnection(LibOIE_ConnectionIterator pConnectionIterator, LibOIE_Connection * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pConnectionIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IConnectionIterator* pIConnectionIterator = dynamic_cast<IConnectionIterator*>(pIBaseClass);
		if (!pIConnectionIterator)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIConnectionIterator->GetCurrentConnection();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Server
**************************************************************************************************************************/
LibOIEResult liboie_server_start(LibOIE_Server pServer, const char * pIPAddress, LibOIE_uint32 nPort, bool bIPv6)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		if (pIPAddress == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sIPAddress(pIPAddress);
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIServer->Start(sIPAddress, nPort, bIPv6);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_stop(LibOIE_Server pServer)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIServer->Stop();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_closeallconnections(LibOIE_Server pServer)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIServer->CloseAllConnections();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_setthreadcount(LibOIE_Server pServer, LibOIE_uint32 nThreadCount)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIServer->SetThreadCount(nThreadCount);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_setbuffersize(LibOIE_Server pServer, LibOIE_uint32 nRCVBufferSize)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIServer->SetBufferSize(nRCVBufferSize);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_acceptdevice(LibOIE_Server pServer, const char * pDeviceName, const char * pApplicationName, const char * pVersionName, LibOIE_uint32 * pRuleID)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		if (pDeviceName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pApplicationName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pVersionName == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pRuleID == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		std::string sDeviceName(pDeviceName);
		std::string sApplicationName(pApplicationName);
		std::string sVersionName(pVersionName);
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		*pRuleID = pIServer->AcceptDevice(sDeviceName, sApplicationName, sVersionName);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_unacceptdevice(LibOIE_Server pServer, LibOIE_uint32 nRuleID)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIServer->UnAcceptDevice(nRuleID);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_clearaccepteddevices(LibOIE_Server pServer)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIServer->ClearAcceptedDevices();

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_listconnections(LibOIE_Server pServer, LibOIE_ConnectionIterator * pConnectionIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		if (pConnectionIteratorInstance == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pBaseConnectionIteratorInstance(nullptr);
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pBaseConnectionIteratorInstance = pIServer->ListConnections();

		*pConnectionIteratorInstance = (IBase*)(pBaseConnectionIteratorInstance);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_setconnectionacceptedcallback(LibOIE_Server pServer, LibOIEConnectionAcceptedCallback pCallback)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIServer->SetConnectionAcceptedCallback(pCallback);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_server_setconnectionrejectedcallback(LibOIE_Server pServer, LibOIEConnectionRejectedCallback pCallback)
{
	IBase* pIBaseClass = (IBase *)pServer;

	try {
		IServer* pIServer = dynamic_cast<IServer*>(pIBaseClass);
		if (!pIServer)
			throw ELibOIEInterfaceException(LIBOIE_ERROR_INVALIDCAST);
		
		pIServer->SetConnectionRejectedCallback(pCallback);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibOIEResult LibOIE::Impl::LibOIE_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBOIE_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBOIE_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "liboie_iterator_movenext") 
		*ppProcAddress = (void*) &liboie_iterator_movenext;
	if (sProcName == "liboie_iterator_moveprevious") 
		*ppProcAddress = (void*) &liboie_iterator_moveprevious;
	if (sProcName == "liboie_iterator_getcurrent") 
		*ppProcAddress = (void*) &liboie_iterator_getcurrent;
	if (sProcName == "liboie_iterator_clone") 
		*ppProcAddress = (void*) &liboie_iterator_clone;
	if (sProcName == "liboie_iterator_count") 
		*ppProcAddress = (void*) &liboie_iterator_count;
	if (sProcName == "liboie_datapackage_getrawpayload") 
		*ppProcAddress = (void*) &liboie_datapackage_getrawpayload;
	if (sProcName == "liboie_datapackage_release") 
		*ppProcAddress = (void*) &liboie_datapackage_release;
	if (sProcName == "liboie_pyrodatapackageiterator_getcurrentpyrodatapackage") 
		*ppProcAddress = (void*) &liboie_pyrodatapackageiterator_getcurrentpyrodatapackage;
	if (sProcName == "liboie_octdatapackageiterator_getcurrentoctdatapackage") 
		*ppProcAddress = (void*) &liboie_octdatapackageiterator_getcurrentoctdatapackage;
	if (sProcName == "liboie_remotefunctioncall_getfunctionname") 
		*ppProcAddress = (void*) &liboie_remotefunctioncall_getfunctionname;
	if (sProcName == "liboie_remotefunctioncall_addparameter") 
		*ppProcAddress = (void*) &liboie_remotefunctioncall_addparameter;
	if (sProcName == "liboie_remotefunctioncall_send") 
		*ppProcAddress = (void*) &liboie_remotefunctioncall_send;
	if (sProcName == "liboie_connection_disconnect") 
		*ppProcAddress = (void*) &liboie_connection_disconnect;
	if (sProcName == "liboie_connection_setrequesttimeout") 
		*ppProcAddress = (void*) &liboie_connection_setrequesttimeout;
	if (sProcName == "liboie_connection_setmaxerrorcount") 
		*ppProcAddress = (void*) &liboie_connection_setmaxerrorcount;
	if (sProcName == "liboie_connection_setmaxmemorycount") 
		*ppProcAddress = (void*) &liboie_connection_setmaxmemorycount;
	if (sProcName == "liboie_connection_setbufferfile") 
		*ppProcAddress = (void*) &liboie_connection_setbufferfile;
	if (sProcName == "liboie_connection_unsetbufferfile") 
		*ppProcAddress = (void*) &liboie_connection_unsetbufferfile;
	if (sProcName == "liboie_connection_setcheckaliveinterval") 
		*ppProcAddress = (void*) &liboie_connection_setcheckaliveinterval;
	if (sProcName == "liboie_connection_retrievefirmwareversion") 
		*ppProcAddress = (void*) &liboie_connection_retrievefirmwareversion;
	if (sProcName == "liboie_connection_updatefirmware") 
		*ppProcAddress = (void*) &liboie_connection_updatefirmware;
	if (sProcName == "liboie_connection_startfirmware") 
		*ppProcAddress = (void*) &liboie_connection_startfirmware;
	if (sProcName == "liboie_connection_stopfirmware") 
		*ppProcAddress = (void*) &liboie_connection_stopfirmware;
	if (sProcName == "liboie_connection_setconnectionerrorcallback") 
		*ppProcAddress = (void*) &liboie_connection_setconnectionerrorcallback;
	if (sProcName == "liboie_connection_clearerrors") 
		*ppProcAddress = (void*) &liboie_connection_clearerrors;
	if (sProcName == "liboie_connection_geterrorcount") 
		*ppProcAddress = (void*) &liboie_connection_geterrorcount;
	if (sProcName == "liboie_connection_geterror") 
		*ppProcAddress = (void*) &liboie_connection_geterror;
	if (sProcName == "liboie_connection_createremotefunctioncall") 
		*ppProcAddress = (void*) &liboie_connection_createremotefunctioncall;
	if (sProcName == "liboie_connection_getbufferedpyropackages") 
		*ppProcAddress = (void*) &liboie_connection_getbufferedpyropackages;
	if (sProcName == "liboie_connection_getbufferedoctpackages") 
		*ppProcAddress = (void*) &liboie_connection_getbufferedoctpackages;
	if (sProcName == "liboie_connectioniterator_getcurrentconnection") 
		*ppProcAddress = (void*) &liboie_connectioniterator_getcurrentconnection;
	if (sProcName == "liboie_server_start") 
		*ppProcAddress = (void*) &liboie_server_start;
	if (sProcName == "liboie_server_stop") 
		*ppProcAddress = (void*) &liboie_server_stop;
	if (sProcName == "liboie_server_closeallconnections") 
		*ppProcAddress = (void*) &liboie_server_closeallconnections;
	if (sProcName == "liboie_server_setthreadcount") 
		*ppProcAddress = (void*) &liboie_server_setthreadcount;
	if (sProcName == "liboie_server_setbuffersize") 
		*ppProcAddress = (void*) &liboie_server_setbuffersize;
	if (sProcName == "liboie_server_acceptdevice") 
		*ppProcAddress = (void*) &liboie_server_acceptdevice;
	if (sProcName == "liboie_server_unacceptdevice") 
		*ppProcAddress = (void*) &liboie_server_unacceptdevice;
	if (sProcName == "liboie_server_clearaccepteddevices") 
		*ppProcAddress = (void*) &liboie_server_clearaccepteddevices;
	if (sProcName == "liboie_server_listconnections") 
		*ppProcAddress = (void*) &liboie_server_listconnections;
	if (sProcName == "liboie_server_setconnectionacceptedcallback") 
		*ppProcAddress = (void*) &liboie_server_setconnectionacceptedcallback;
	if (sProcName == "liboie_server_setconnectionrejectedcallback") 
		*ppProcAddress = (void*) &liboie_server_setconnectionrejectedcallback;
	if (sProcName == "liboie_getversion") 
		*ppProcAddress = (void*) &liboie_getversion;
	if (sProcName == "liboie_getlasterror") 
		*ppProcAddress = (void*) &liboie_getlasterror;
	if (sProcName == "liboie_releaseinstance") 
		*ppProcAddress = (void*) &liboie_releaseinstance;
	if (sProcName == "liboie_acquireinstance") 
		*ppProcAddress = (void*) &liboie_acquireinstance;
	if (sProcName == "liboie_getsymbollookupmethod") 
		*ppProcAddress = (void*) &liboie_getsymbollookupmethod;
	if (sProcName == "liboie_createserver") 
		*ppProcAddress = (void*) &liboie_createserver;
	
	if (*ppProcAddress == nullptr) 
		return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBOIE_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibOIEResult liboie_getversion(LibOIE_uint32 * pMajor, LibOIE_uint32 * pMinor, LibOIE_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_getlasterror(LibOIE_Base pInstance, const LibOIE_uint32 nErrorMessageBufferSize, LibOIE_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibOIE_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibOIEInterfaceException (LIBOIE_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_releaseinstance(LibOIE_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_acquireinstance(LibOIE_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_getsymbollookupmethod(LibOIE_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibOIE::Impl::LibOIE_GetProcAddress;
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibOIEResult liboie_createserver(LibOIE_Server * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ELibOIEInterfaceException (LIBOIE_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateServer();

		*pInstance = (IBase*)(pBaseInstance);
		return LIBOIE_SUCCESS;
	}
	catch (ELibOIEInterfaceException & Exception) {
		return handleLibOIEException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


