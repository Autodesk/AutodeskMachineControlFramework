/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of ScanLab Open Interface Extension

Interface version: 1.0.0

*/

#ifndef __LIBOIE_CPPHEADER_DYNAMIC_CPP
#define __LIBOIE_CPPHEADER_DYNAMIC_CPP

#include "liboie_types.hpp"
#include "liboie_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibOIE {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CIterator;
class CDataPackage;
class CPyroDataPackage;
class CPyroDataPackageIterator;
class COctDataPackage;
class COctDataPackageIterator;
class CRemoteFunctionCall;
class CConnection;
class CConnectionIterator;
class CServer;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibOIEWrapper;
typedef CBase CLibOIEBase;
typedef CIterator CLibOIEIterator;
typedef CDataPackage CLibOIEDataPackage;
typedef CPyroDataPackage CLibOIEPyroDataPackage;
typedef CPyroDataPackageIterator CLibOIEPyroDataPackageIterator;
typedef COctDataPackage CLibOIEOctDataPackage;
typedef COctDataPackageIterator CLibOIEOctDataPackageIterator;
typedef CRemoteFunctionCall CLibOIERemoteFunctionCall;
typedef CConnection CLibOIEConnection;
typedef CConnectionIterator CLibOIEConnectionIterator;
typedef CServer CLibOIEServer;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CIterator> PIterator;
typedef std::shared_ptr<CDataPackage> PDataPackage;
typedef std::shared_ptr<CPyroDataPackage> PPyroDataPackage;
typedef std::shared_ptr<CPyroDataPackageIterator> PPyroDataPackageIterator;
typedef std::shared_ptr<COctDataPackage> POctDataPackage;
typedef std::shared_ptr<COctDataPackageIterator> POctDataPackageIterator;
typedef std::shared_ptr<CRemoteFunctionCall> PRemoteFunctionCall;
typedef std::shared_ptr<CConnection> PConnection;
typedef std::shared_ptr<CConnectionIterator> PConnectionIterator;
typedef std::shared_ptr<CServer> PServer;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibOIEWrapper;
typedef PBase PLibOIEBase;
typedef PIterator PLibOIEIterator;
typedef PDataPackage PLibOIEDataPackage;
typedef PPyroDataPackage PLibOIEPyroDataPackage;
typedef PPyroDataPackageIterator PLibOIEPyroDataPackageIterator;
typedef POctDataPackage PLibOIEOctDataPackage;
typedef POctDataPackageIterator PLibOIEOctDataPackageIterator;
typedef PRemoteFunctionCall PLibOIERemoteFunctionCall;
typedef PConnection PLibOIEConnection;
typedef PConnectionIterator PLibOIEConnectionIterator;
typedef PServer PLibOIEServer;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibOIEHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibOIEException 
**************************************************************************************************************************/
class ELibOIEException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibOIEResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibOIEException(LibOIEResult errorCode, const std::string & sErrorMessage)
		: m_errorMessage("LibOIE Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
	{
		m_errorCode = errorCode;
	}

	/**
	* Returns error code
	*/
	LibOIEResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector( const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector( const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibOIEInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibOIEResult nResult);

	inline void GetVersion(LibOIE_uint32 & nMajor, LibOIE_uint32 & nMinor, LibOIE_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline LibOIE_pvoid GetSymbolLookupMethod();
	inline PServer CreateServer();

private:
	sLibOIEDynamicWrapperTable m_WrapperTable;
	
	LibOIEResult checkBinaryVersion()
	{
		LibOIE_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != LIBOIE_VERSION_MAJOR) || (nMinor < LIBOIE_VERSION_MINOR) ) {
			return LIBOIE_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBOIE_SUCCESS;
	}
	LibOIEResult initWrapperTable(sLibOIEDynamicWrapperTable * pWrapperTable);
	LibOIEResult releaseWrapperTable(sLibOIEDynamicWrapperTable * pWrapperTable);
	LibOIEResult loadWrapperTable(sLibOIEDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibOIEResult loadWrapperTableFromSymbolLookupMethod(sLibOIEDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CIterator;
	friend class CDataPackage;
	friend class CPyroDataPackage;
	friend class CPyroDataPackageIterator;
	friend class COctDataPackage;
	friend class COctDataPackageIterator;
	friend class CRemoteFunctionCall;
	friend class CConnection;
	friend class CConnectionIterator;
	friend class CServer;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibOIEHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibOIEResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibOIEHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibOIEHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CIterator 
**************************************************************************************************************************/
class CIterator : public CBase {
public:
	
	/**
	* CIterator::CIterator - Constructor for Iterator class.
	*/
	CIterator(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MoveNext();
	inline bool MovePrevious();
	inline PBase GetCurrent();
	inline PIterator Clone();
	inline LibOIE_uint64 Count();
};
	
/*************************************************************************************************************************
 Class CDataPackage 
**************************************************************************************************************************/
class CDataPackage : public CBase {
public:
	
	/**
	* CDataPackage::CDataPackage - Constructor for DataPackage class.
	*/
	CDataPackage(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void GetRawPayload(std::vector<LibOIE_uint8> & PayloadBuffer);
	inline void Release();
};
	
/*************************************************************************************************************************
 Class CPyroDataPackage 
**************************************************************************************************************************/
class CPyroDataPackage : public CDataPackage {
public:
	
	/**
	* CPyroDataPackage::CPyroDataPackage - Constructor for PyroDataPackage class.
	*/
	CPyroDataPackage(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CDataPackage(pWrapper, pHandle)
	{
	}
	
};
	
/*************************************************************************************************************************
 Class CPyroDataPackageIterator 
**************************************************************************************************************************/
class CPyroDataPackageIterator : public CIterator {
public:
	
	/**
	* CPyroDataPackageIterator::CPyroDataPackageIterator - Constructor for PyroDataPackageIterator class.
	*/
	CPyroDataPackageIterator(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PPyroDataPackage GetCurrentPyroDataPackage();
};
	
/*************************************************************************************************************************
 Class COctDataPackage 
**************************************************************************************************************************/
class COctDataPackage : public CDataPackage {
public:
	
	/**
	* COctDataPackage::COctDataPackage - Constructor for OctDataPackage class.
	*/
	COctDataPackage(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CDataPackage(pWrapper, pHandle)
	{
	}
	
};
	
/*************************************************************************************************************************
 Class COctDataPackageIterator 
**************************************************************************************************************************/
class COctDataPackageIterator : public CIterator {
public:
	
	/**
	* COctDataPackageIterator::COctDataPackageIterator - Constructor for OctDataPackageIterator class.
	*/
	COctDataPackageIterator(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline POctDataPackage GetCurrentOctDataPackage();
};
	
/*************************************************************************************************************************
 Class CRemoteFunctionCall 
**************************************************************************************************************************/
class CRemoteFunctionCall : public CBase {
public:
	
	/**
	* CRemoteFunctionCall::CRemoteFunctionCall - Constructor for RemoteFunctionCall class.
	*/
	CRemoteFunctionCall(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetFunctionName();
	inline void AddParameter(const std::string & sParameter);
	inline std::string Send();
};
	
/*************************************************************************************************************************
 Class CConnection 
**************************************************************************************************************************/
class CConnection : public CBase {
public:
	
	/**
	* CConnection::CConnection - Constructor for Connection class.
	*/
	CConnection(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Disconnect();
	inline void SetRequestTimeout(const LibOIE_uint32 nTimeout);
	inline void SetMaxErrorCount(const LibOIE_uint32 nErrorCount);
	inline void SetMaxMemoryCount(const LibOIE_uint32 nMaxMemoryCount);
	inline void SetBufferFile(const std::string & sFileName, const LibOIE_uint64 nMaxMemoryCount);
	inline void UnsetBufferFile();
	inline void SetCheckAliveInterval(const LibOIE_uint32 nCheckAliveInterval);
	inline void RetrieveFirmwareVersion(const std::string & sFirmwareName, std::string & sFirmwareVersion, std::string & sFilename, std::string & sFiledate, std::string & sSHA256);
	inline void UpdateFirmware(const std::string & sFirmwareName, const std::string & sFirmwareVersion, const std::string & sFileName, const std::string & sFileDate, const std::string & sSHA256, const CInputVector<LibOIE_uint8> & BinaryDataBuffer);
	inline bool StartFirmware(const std::string & sFileName);
	inline bool StopFirmware(const std::string & sFileName);
	inline void SetConnectionErrorCallback(const ConnectionErrorCallback pCallback);
	inline void ClearErrors();
	inline LibOIE_uint32 GetErrorCount();
	inline void GetError(const LibOIE_uint32 nErrorIndex, std::string & sErrorMessage, std::string & sTimestamp);
	inline PRemoteFunctionCall CreateRemoteFunctionCall(const std::string & sFunctionName);
	inline PPyroDataPackageIterator GetBufferedPyroPackages();
	inline POctDataPackageIterator GetBufferedOctPackages();
};
	
/*************************************************************************************************************************
 Class CConnectionIterator 
**************************************************************************************************************************/
class CConnectionIterator : public CIterator {
public:
	
	/**
	* CConnectionIterator::CConnectionIterator - Constructor for ConnectionIterator class.
	*/
	CConnectionIterator(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PConnection GetCurrentConnection();
};
	
/*************************************************************************************************************************
 Class CServer 
**************************************************************************************************************************/
class CServer : public CBase {
public:
	
	/**
	* CServer::CServer - Constructor for Server class.
	*/
	CServer(CWrapper* pWrapper, LibOIEHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Start(const std::string & sIPAddress, const LibOIE_uint32 nPort, const bool bIPv6);
	inline void Stop();
	inline void CloseAllConnections();
	inline void SetThreadCount(const LibOIE_uint32 nThreadCount);
	inline void SetBufferSize(const LibOIE_uint32 nRCVBufferSize);
	inline LibOIE_uint32 AcceptDevice(const std::string & sDeviceName, const std::string & sApplicationName, const std::string & sVersionName);
	inline void UnAcceptDevice(const LibOIE_uint32 nRuleID);
	inline void ClearAcceptedDevices();
	inline PConnectionIterator ListConnections();
	inline void SetConnectionAcceptedCallback(const ConnectionAcceptedCallback pCallback, const LibOIE_pvoid pUserData);
	inline void SetConnectionRejectedCallback(const ConnectionRejectedCallback pCallback, const LibOIE_pvoid pUserData);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibOIE_uint32 & nMajor, LibOIE_uint32 & nMinor, LibOIE_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibOIEHandle hInstance = pInstance.GetHandle();
		LibOIE_uint32 bytesNeededErrorMessage = 0;
		LibOIE_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibOIEHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibOIEHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibOIE_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibOIE_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateServer - Creates a open interface extension server instance.
	* @return New Server instance
	*/
	inline PServer CWrapper::CreateServer()
	{
		LibOIEHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateServer(&hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CServer>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibOIEResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibOIEException(nResult, sErrorMessage);
		}
	}
	

	inline LibOIEResult CWrapper::initWrapperTable(sLibOIEDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBOIE_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Iterator_MoveNext = nullptr;
		pWrapperTable->m_Iterator_MovePrevious = nullptr;
		pWrapperTable->m_Iterator_GetCurrent = nullptr;
		pWrapperTable->m_Iterator_Clone = nullptr;
		pWrapperTable->m_Iterator_Count = nullptr;
		pWrapperTable->m_DataPackage_GetRawPayload = nullptr;
		pWrapperTable->m_DataPackage_Release = nullptr;
		pWrapperTable->m_PyroDataPackageIterator_GetCurrentPyroDataPackage = nullptr;
		pWrapperTable->m_OctDataPackageIterator_GetCurrentOctDataPackage = nullptr;
		pWrapperTable->m_RemoteFunctionCall_GetFunctionName = nullptr;
		pWrapperTable->m_RemoteFunctionCall_AddParameter = nullptr;
		pWrapperTable->m_RemoteFunctionCall_Send = nullptr;
		pWrapperTable->m_Connection_Disconnect = nullptr;
		pWrapperTable->m_Connection_SetRequestTimeout = nullptr;
		pWrapperTable->m_Connection_SetMaxErrorCount = nullptr;
		pWrapperTable->m_Connection_SetMaxMemoryCount = nullptr;
		pWrapperTable->m_Connection_SetBufferFile = nullptr;
		pWrapperTable->m_Connection_UnsetBufferFile = nullptr;
		pWrapperTable->m_Connection_SetCheckAliveInterval = nullptr;
		pWrapperTable->m_Connection_RetrieveFirmwareVersion = nullptr;
		pWrapperTable->m_Connection_UpdateFirmware = nullptr;
		pWrapperTable->m_Connection_StartFirmware = nullptr;
		pWrapperTable->m_Connection_StopFirmware = nullptr;
		pWrapperTable->m_Connection_SetConnectionErrorCallback = nullptr;
		pWrapperTable->m_Connection_ClearErrors = nullptr;
		pWrapperTable->m_Connection_GetErrorCount = nullptr;
		pWrapperTable->m_Connection_GetError = nullptr;
		pWrapperTable->m_Connection_CreateRemoteFunctionCall = nullptr;
		pWrapperTable->m_Connection_GetBufferedPyroPackages = nullptr;
		pWrapperTable->m_Connection_GetBufferedOctPackages = nullptr;
		pWrapperTable->m_ConnectionIterator_GetCurrentConnection = nullptr;
		pWrapperTable->m_Server_Start = nullptr;
		pWrapperTable->m_Server_Stop = nullptr;
		pWrapperTable->m_Server_CloseAllConnections = nullptr;
		pWrapperTable->m_Server_SetThreadCount = nullptr;
		pWrapperTable->m_Server_SetBufferSize = nullptr;
		pWrapperTable->m_Server_AcceptDevice = nullptr;
		pWrapperTable->m_Server_UnAcceptDevice = nullptr;
		pWrapperTable->m_Server_ClearAcceptedDevices = nullptr;
		pWrapperTable->m_Server_ListConnections = nullptr;
		pWrapperTable->m_Server_SetConnectionAcceptedCallback = nullptr;
		pWrapperTable->m_Server_SetConnectionRejectedCallback = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateServer = nullptr;
		
		return LIBOIE_SUCCESS;
	}

	inline LibOIEResult CWrapper::releaseWrapperTable(sLibOIEDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBOIE_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBOIE_SUCCESS;
	}

	inline LibOIEResult CWrapper::loadWrapperTable(sLibOIEDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBOIE_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBOIE_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = (int)strlen(pLibraryFileName);
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBOIE_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBOIE_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBOIE_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibOIEIterator_MoveNextPtr) GetProcAddress(hLibrary, "liboie_iterator_movenext");
		#else // _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibOIEIterator_MoveNextPtr) dlsym(hLibrary, "liboie_iterator_movenext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MoveNext == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibOIEIterator_MovePreviousPtr) GetProcAddress(hLibrary, "liboie_iterator_moveprevious");
		#else // _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibOIEIterator_MovePreviousPtr) dlsym(hLibrary, "liboie_iterator_moveprevious");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MovePrevious == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibOIEIterator_GetCurrentPtr) GetProcAddress(hLibrary, "liboie_iterator_getcurrent");
		#else // _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibOIEIterator_GetCurrentPtr) dlsym(hLibrary, "liboie_iterator_getcurrent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_GetCurrent == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibOIEIterator_ClonePtr) GetProcAddress(hLibrary, "liboie_iterator_clone");
		#else // _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibOIEIterator_ClonePtr) dlsym(hLibrary, "liboie_iterator_clone");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Clone == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Count = (PLibOIEIterator_CountPtr) GetProcAddress(hLibrary, "liboie_iterator_count");
		#else // _WIN32
		pWrapperTable->m_Iterator_Count = (PLibOIEIterator_CountPtr) dlsym(hLibrary, "liboie_iterator_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Count == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataPackage_GetRawPayload = (PLibOIEDataPackage_GetRawPayloadPtr) GetProcAddress(hLibrary, "liboie_datapackage_getrawpayload");
		#else // _WIN32
		pWrapperTable->m_DataPackage_GetRawPayload = (PLibOIEDataPackage_GetRawPayloadPtr) dlsym(hLibrary, "liboie_datapackage_getrawpayload");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataPackage_GetRawPayload == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataPackage_Release = (PLibOIEDataPackage_ReleasePtr) GetProcAddress(hLibrary, "liboie_datapackage_release");
		#else // _WIN32
		pWrapperTable->m_DataPackage_Release = (PLibOIEDataPackage_ReleasePtr) dlsym(hLibrary, "liboie_datapackage_release");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataPackage_Release == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PyroDataPackageIterator_GetCurrentPyroDataPackage = (PLibOIEPyroDataPackageIterator_GetCurrentPyroDataPackagePtr) GetProcAddress(hLibrary, "liboie_pyrodatapackageiterator_getcurrentpyrodatapackage");
		#else // _WIN32
		pWrapperTable->m_PyroDataPackageIterator_GetCurrentPyroDataPackage = (PLibOIEPyroDataPackageIterator_GetCurrentPyroDataPackagePtr) dlsym(hLibrary, "liboie_pyrodatapackageiterator_getcurrentpyrodatapackage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PyroDataPackageIterator_GetCurrentPyroDataPackage == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_OctDataPackageIterator_GetCurrentOctDataPackage = (PLibOIEOctDataPackageIterator_GetCurrentOctDataPackagePtr) GetProcAddress(hLibrary, "liboie_octdatapackageiterator_getcurrentoctdatapackage");
		#else // _WIN32
		pWrapperTable->m_OctDataPackageIterator_GetCurrentOctDataPackage = (PLibOIEOctDataPackageIterator_GetCurrentOctDataPackagePtr) dlsym(hLibrary, "liboie_octdatapackageiterator_getcurrentoctdatapackage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_OctDataPackageIterator_GetCurrentOctDataPackage == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RemoteFunctionCall_GetFunctionName = (PLibOIERemoteFunctionCall_GetFunctionNamePtr) GetProcAddress(hLibrary, "liboie_remotefunctioncall_getfunctionname");
		#else // _WIN32
		pWrapperTable->m_RemoteFunctionCall_GetFunctionName = (PLibOIERemoteFunctionCall_GetFunctionNamePtr) dlsym(hLibrary, "liboie_remotefunctioncall_getfunctionname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RemoteFunctionCall_GetFunctionName == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RemoteFunctionCall_AddParameter = (PLibOIERemoteFunctionCall_AddParameterPtr) GetProcAddress(hLibrary, "liboie_remotefunctioncall_addparameter");
		#else // _WIN32
		pWrapperTable->m_RemoteFunctionCall_AddParameter = (PLibOIERemoteFunctionCall_AddParameterPtr) dlsym(hLibrary, "liboie_remotefunctioncall_addparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RemoteFunctionCall_AddParameter == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_RemoteFunctionCall_Send = (PLibOIERemoteFunctionCall_SendPtr) GetProcAddress(hLibrary, "liboie_remotefunctioncall_send");
		#else // _WIN32
		pWrapperTable->m_RemoteFunctionCall_Send = (PLibOIERemoteFunctionCall_SendPtr) dlsym(hLibrary, "liboie_remotefunctioncall_send");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_RemoteFunctionCall_Send == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_Disconnect = (PLibOIEConnection_DisconnectPtr) GetProcAddress(hLibrary, "liboie_connection_disconnect");
		#else // _WIN32
		pWrapperTable->m_Connection_Disconnect = (PLibOIEConnection_DisconnectPtr) dlsym(hLibrary, "liboie_connection_disconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_Disconnect == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_SetRequestTimeout = (PLibOIEConnection_SetRequestTimeoutPtr) GetProcAddress(hLibrary, "liboie_connection_setrequesttimeout");
		#else // _WIN32
		pWrapperTable->m_Connection_SetRequestTimeout = (PLibOIEConnection_SetRequestTimeoutPtr) dlsym(hLibrary, "liboie_connection_setrequesttimeout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_SetRequestTimeout == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_SetMaxErrorCount = (PLibOIEConnection_SetMaxErrorCountPtr) GetProcAddress(hLibrary, "liboie_connection_setmaxerrorcount");
		#else // _WIN32
		pWrapperTable->m_Connection_SetMaxErrorCount = (PLibOIEConnection_SetMaxErrorCountPtr) dlsym(hLibrary, "liboie_connection_setmaxerrorcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_SetMaxErrorCount == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_SetMaxMemoryCount = (PLibOIEConnection_SetMaxMemoryCountPtr) GetProcAddress(hLibrary, "liboie_connection_setmaxmemorycount");
		#else // _WIN32
		pWrapperTable->m_Connection_SetMaxMemoryCount = (PLibOIEConnection_SetMaxMemoryCountPtr) dlsym(hLibrary, "liboie_connection_setmaxmemorycount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_SetMaxMemoryCount == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_SetBufferFile = (PLibOIEConnection_SetBufferFilePtr) GetProcAddress(hLibrary, "liboie_connection_setbufferfile");
		#else // _WIN32
		pWrapperTable->m_Connection_SetBufferFile = (PLibOIEConnection_SetBufferFilePtr) dlsym(hLibrary, "liboie_connection_setbufferfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_SetBufferFile == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_UnsetBufferFile = (PLibOIEConnection_UnsetBufferFilePtr) GetProcAddress(hLibrary, "liboie_connection_unsetbufferfile");
		#else // _WIN32
		pWrapperTable->m_Connection_UnsetBufferFile = (PLibOIEConnection_UnsetBufferFilePtr) dlsym(hLibrary, "liboie_connection_unsetbufferfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_UnsetBufferFile == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_SetCheckAliveInterval = (PLibOIEConnection_SetCheckAliveIntervalPtr) GetProcAddress(hLibrary, "liboie_connection_setcheckaliveinterval");
		#else // _WIN32
		pWrapperTable->m_Connection_SetCheckAliveInterval = (PLibOIEConnection_SetCheckAliveIntervalPtr) dlsym(hLibrary, "liboie_connection_setcheckaliveinterval");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_SetCheckAliveInterval == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_RetrieveFirmwareVersion = (PLibOIEConnection_RetrieveFirmwareVersionPtr) GetProcAddress(hLibrary, "liboie_connection_retrievefirmwareversion");
		#else // _WIN32
		pWrapperTable->m_Connection_RetrieveFirmwareVersion = (PLibOIEConnection_RetrieveFirmwareVersionPtr) dlsym(hLibrary, "liboie_connection_retrievefirmwareversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_RetrieveFirmwareVersion == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_UpdateFirmware = (PLibOIEConnection_UpdateFirmwarePtr) GetProcAddress(hLibrary, "liboie_connection_updatefirmware");
		#else // _WIN32
		pWrapperTable->m_Connection_UpdateFirmware = (PLibOIEConnection_UpdateFirmwarePtr) dlsym(hLibrary, "liboie_connection_updatefirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_UpdateFirmware == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_StartFirmware = (PLibOIEConnection_StartFirmwarePtr) GetProcAddress(hLibrary, "liboie_connection_startfirmware");
		#else // _WIN32
		pWrapperTable->m_Connection_StartFirmware = (PLibOIEConnection_StartFirmwarePtr) dlsym(hLibrary, "liboie_connection_startfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_StartFirmware == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_StopFirmware = (PLibOIEConnection_StopFirmwarePtr) GetProcAddress(hLibrary, "liboie_connection_stopfirmware");
		#else // _WIN32
		pWrapperTable->m_Connection_StopFirmware = (PLibOIEConnection_StopFirmwarePtr) dlsym(hLibrary, "liboie_connection_stopfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_StopFirmware == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_SetConnectionErrorCallback = (PLibOIEConnection_SetConnectionErrorCallbackPtr) GetProcAddress(hLibrary, "liboie_connection_setconnectionerrorcallback");
		#else // _WIN32
		pWrapperTable->m_Connection_SetConnectionErrorCallback = (PLibOIEConnection_SetConnectionErrorCallbackPtr) dlsym(hLibrary, "liboie_connection_setconnectionerrorcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_SetConnectionErrorCallback == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_ClearErrors = (PLibOIEConnection_ClearErrorsPtr) GetProcAddress(hLibrary, "liboie_connection_clearerrors");
		#else // _WIN32
		pWrapperTable->m_Connection_ClearErrors = (PLibOIEConnection_ClearErrorsPtr) dlsym(hLibrary, "liboie_connection_clearerrors");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_ClearErrors == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_GetErrorCount = (PLibOIEConnection_GetErrorCountPtr) GetProcAddress(hLibrary, "liboie_connection_geterrorcount");
		#else // _WIN32
		pWrapperTable->m_Connection_GetErrorCount = (PLibOIEConnection_GetErrorCountPtr) dlsym(hLibrary, "liboie_connection_geterrorcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_GetErrorCount == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_GetError = (PLibOIEConnection_GetErrorPtr) GetProcAddress(hLibrary, "liboie_connection_geterror");
		#else // _WIN32
		pWrapperTable->m_Connection_GetError = (PLibOIEConnection_GetErrorPtr) dlsym(hLibrary, "liboie_connection_geterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_GetError == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_CreateRemoteFunctionCall = (PLibOIEConnection_CreateRemoteFunctionCallPtr) GetProcAddress(hLibrary, "liboie_connection_createremotefunctioncall");
		#else // _WIN32
		pWrapperTable->m_Connection_CreateRemoteFunctionCall = (PLibOIEConnection_CreateRemoteFunctionCallPtr) dlsym(hLibrary, "liboie_connection_createremotefunctioncall");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_CreateRemoteFunctionCall == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_GetBufferedPyroPackages = (PLibOIEConnection_GetBufferedPyroPackagesPtr) GetProcAddress(hLibrary, "liboie_connection_getbufferedpyropackages");
		#else // _WIN32
		pWrapperTable->m_Connection_GetBufferedPyroPackages = (PLibOIEConnection_GetBufferedPyroPackagesPtr) dlsym(hLibrary, "liboie_connection_getbufferedpyropackages");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_GetBufferedPyroPackages == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Connection_GetBufferedOctPackages = (PLibOIEConnection_GetBufferedOctPackagesPtr) GetProcAddress(hLibrary, "liboie_connection_getbufferedoctpackages");
		#else // _WIN32
		pWrapperTable->m_Connection_GetBufferedOctPackages = (PLibOIEConnection_GetBufferedOctPackagesPtr) dlsym(hLibrary, "liboie_connection_getbufferedoctpackages");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Connection_GetBufferedOctPackages == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ConnectionIterator_GetCurrentConnection = (PLibOIEConnectionIterator_GetCurrentConnectionPtr) GetProcAddress(hLibrary, "liboie_connectioniterator_getcurrentconnection");
		#else // _WIN32
		pWrapperTable->m_ConnectionIterator_GetCurrentConnection = (PLibOIEConnectionIterator_GetCurrentConnectionPtr) dlsym(hLibrary, "liboie_connectioniterator_getcurrentconnection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ConnectionIterator_GetCurrentConnection == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_Start = (PLibOIEServer_StartPtr) GetProcAddress(hLibrary, "liboie_server_start");
		#else // _WIN32
		pWrapperTable->m_Server_Start = (PLibOIEServer_StartPtr) dlsym(hLibrary, "liboie_server_start");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_Start == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_Stop = (PLibOIEServer_StopPtr) GetProcAddress(hLibrary, "liboie_server_stop");
		#else // _WIN32
		pWrapperTable->m_Server_Stop = (PLibOIEServer_StopPtr) dlsym(hLibrary, "liboie_server_stop");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_Stop == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_CloseAllConnections = (PLibOIEServer_CloseAllConnectionsPtr) GetProcAddress(hLibrary, "liboie_server_closeallconnections");
		#else // _WIN32
		pWrapperTable->m_Server_CloseAllConnections = (PLibOIEServer_CloseAllConnectionsPtr) dlsym(hLibrary, "liboie_server_closeallconnections");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_CloseAllConnections == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_SetThreadCount = (PLibOIEServer_SetThreadCountPtr) GetProcAddress(hLibrary, "liboie_server_setthreadcount");
		#else // _WIN32
		pWrapperTable->m_Server_SetThreadCount = (PLibOIEServer_SetThreadCountPtr) dlsym(hLibrary, "liboie_server_setthreadcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_SetThreadCount == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_SetBufferSize = (PLibOIEServer_SetBufferSizePtr) GetProcAddress(hLibrary, "liboie_server_setbuffersize");
		#else // _WIN32
		pWrapperTable->m_Server_SetBufferSize = (PLibOIEServer_SetBufferSizePtr) dlsym(hLibrary, "liboie_server_setbuffersize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_SetBufferSize == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_AcceptDevice = (PLibOIEServer_AcceptDevicePtr) GetProcAddress(hLibrary, "liboie_server_acceptdevice");
		#else // _WIN32
		pWrapperTable->m_Server_AcceptDevice = (PLibOIEServer_AcceptDevicePtr) dlsym(hLibrary, "liboie_server_acceptdevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_AcceptDevice == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_UnAcceptDevice = (PLibOIEServer_UnAcceptDevicePtr) GetProcAddress(hLibrary, "liboie_server_unacceptdevice");
		#else // _WIN32
		pWrapperTable->m_Server_UnAcceptDevice = (PLibOIEServer_UnAcceptDevicePtr) dlsym(hLibrary, "liboie_server_unacceptdevice");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_UnAcceptDevice == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_ClearAcceptedDevices = (PLibOIEServer_ClearAcceptedDevicesPtr) GetProcAddress(hLibrary, "liboie_server_clearaccepteddevices");
		#else // _WIN32
		pWrapperTable->m_Server_ClearAcceptedDevices = (PLibOIEServer_ClearAcceptedDevicesPtr) dlsym(hLibrary, "liboie_server_clearaccepteddevices");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_ClearAcceptedDevices == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_ListConnections = (PLibOIEServer_ListConnectionsPtr) GetProcAddress(hLibrary, "liboie_server_listconnections");
		#else // _WIN32
		pWrapperTable->m_Server_ListConnections = (PLibOIEServer_ListConnectionsPtr) dlsym(hLibrary, "liboie_server_listconnections");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_ListConnections == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_SetConnectionAcceptedCallback = (PLibOIEServer_SetConnectionAcceptedCallbackPtr) GetProcAddress(hLibrary, "liboie_server_setconnectionacceptedcallback");
		#else // _WIN32
		pWrapperTable->m_Server_SetConnectionAcceptedCallback = (PLibOIEServer_SetConnectionAcceptedCallbackPtr) dlsym(hLibrary, "liboie_server_setconnectionacceptedcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_SetConnectionAcceptedCallback == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Server_SetConnectionRejectedCallback = (PLibOIEServer_SetConnectionRejectedCallbackPtr) GetProcAddress(hLibrary, "liboie_server_setconnectionrejectedcallback");
		#else // _WIN32
		pWrapperTable->m_Server_SetConnectionRejectedCallback = (PLibOIEServer_SetConnectionRejectedCallbackPtr) dlsym(hLibrary, "liboie_server_setconnectionrejectedcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Server_SetConnectionRejectedCallback == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibOIEGetVersionPtr) GetProcAddress(hLibrary, "liboie_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibOIEGetVersionPtr) dlsym(hLibrary, "liboie_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibOIEGetLastErrorPtr) GetProcAddress(hLibrary, "liboie_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibOIEGetLastErrorPtr) dlsym(hLibrary, "liboie_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibOIEReleaseInstancePtr) GetProcAddress(hLibrary, "liboie_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibOIEReleaseInstancePtr) dlsym(hLibrary, "liboie_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibOIEAcquireInstancePtr) GetProcAddress(hLibrary, "liboie_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibOIEAcquireInstancePtr) dlsym(hLibrary, "liboie_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibOIEGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "liboie_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibOIEGetSymbolLookupMethodPtr) dlsym(hLibrary, "liboie_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateServer = (PLibOIECreateServerPtr) GetProcAddress(hLibrary, "liboie_createserver");
		#else // _WIN32
		pWrapperTable->m_CreateServer = (PLibOIECreateServerPtr) dlsym(hLibrary, "liboie_createserver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateServer == nullptr)
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBOIE_SUCCESS;
	}

	inline LibOIEResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibOIEDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBOIE_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBOIE_ERROR_INVALIDPARAM;
		
		typedef LibOIEResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibOIEResult eLookupError = LIBOIE_SUCCESS;
		eLookupError = (*pLookup)("liboie_iterator_movenext", (void**)&(pWrapperTable->m_Iterator_MoveNext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MoveNext == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_iterator_moveprevious", (void**)&(pWrapperTable->m_Iterator_MovePrevious));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MovePrevious == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_iterator_getcurrent", (void**)&(pWrapperTable->m_Iterator_GetCurrent));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_GetCurrent == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_iterator_clone", (void**)&(pWrapperTable->m_Iterator_Clone));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Clone == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_iterator_count", (void**)&(pWrapperTable->m_Iterator_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Count == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_datapackage_getrawpayload", (void**)&(pWrapperTable->m_DataPackage_GetRawPayload));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataPackage_GetRawPayload == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_datapackage_release", (void**)&(pWrapperTable->m_DataPackage_Release));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataPackage_Release == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_pyrodatapackageiterator_getcurrentpyrodatapackage", (void**)&(pWrapperTable->m_PyroDataPackageIterator_GetCurrentPyroDataPackage));
		if ( (eLookupError != 0) || (pWrapperTable->m_PyroDataPackageIterator_GetCurrentPyroDataPackage == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_octdatapackageiterator_getcurrentoctdatapackage", (void**)&(pWrapperTable->m_OctDataPackageIterator_GetCurrentOctDataPackage));
		if ( (eLookupError != 0) || (pWrapperTable->m_OctDataPackageIterator_GetCurrentOctDataPackage == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_remotefunctioncall_getfunctionname", (void**)&(pWrapperTable->m_RemoteFunctionCall_GetFunctionName));
		if ( (eLookupError != 0) || (pWrapperTable->m_RemoteFunctionCall_GetFunctionName == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_remotefunctioncall_addparameter", (void**)&(pWrapperTable->m_RemoteFunctionCall_AddParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_RemoteFunctionCall_AddParameter == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_remotefunctioncall_send", (void**)&(pWrapperTable->m_RemoteFunctionCall_Send));
		if ( (eLookupError != 0) || (pWrapperTable->m_RemoteFunctionCall_Send == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_disconnect", (void**)&(pWrapperTable->m_Connection_Disconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_Disconnect == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_setrequesttimeout", (void**)&(pWrapperTable->m_Connection_SetRequestTimeout));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_SetRequestTimeout == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_setmaxerrorcount", (void**)&(pWrapperTable->m_Connection_SetMaxErrorCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_SetMaxErrorCount == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_setmaxmemorycount", (void**)&(pWrapperTable->m_Connection_SetMaxMemoryCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_SetMaxMemoryCount == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_setbufferfile", (void**)&(pWrapperTable->m_Connection_SetBufferFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_SetBufferFile == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_unsetbufferfile", (void**)&(pWrapperTable->m_Connection_UnsetBufferFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_UnsetBufferFile == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_setcheckaliveinterval", (void**)&(pWrapperTable->m_Connection_SetCheckAliveInterval));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_SetCheckAliveInterval == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_retrievefirmwareversion", (void**)&(pWrapperTable->m_Connection_RetrieveFirmwareVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_RetrieveFirmwareVersion == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_updatefirmware", (void**)&(pWrapperTable->m_Connection_UpdateFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_UpdateFirmware == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_startfirmware", (void**)&(pWrapperTable->m_Connection_StartFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_StartFirmware == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_stopfirmware", (void**)&(pWrapperTable->m_Connection_StopFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_StopFirmware == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_setconnectionerrorcallback", (void**)&(pWrapperTable->m_Connection_SetConnectionErrorCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_SetConnectionErrorCallback == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_clearerrors", (void**)&(pWrapperTable->m_Connection_ClearErrors));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_ClearErrors == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_geterrorcount", (void**)&(pWrapperTable->m_Connection_GetErrorCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_GetErrorCount == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_geterror", (void**)&(pWrapperTable->m_Connection_GetError));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_GetError == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_createremotefunctioncall", (void**)&(pWrapperTable->m_Connection_CreateRemoteFunctionCall));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_CreateRemoteFunctionCall == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_getbufferedpyropackages", (void**)&(pWrapperTable->m_Connection_GetBufferedPyroPackages));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_GetBufferedPyroPackages == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connection_getbufferedoctpackages", (void**)&(pWrapperTable->m_Connection_GetBufferedOctPackages));
		if ( (eLookupError != 0) || (pWrapperTable->m_Connection_GetBufferedOctPackages == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_connectioniterator_getcurrentconnection", (void**)&(pWrapperTable->m_ConnectionIterator_GetCurrentConnection));
		if ( (eLookupError != 0) || (pWrapperTable->m_ConnectionIterator_GetCurrentConnection == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_start", (void**)&(pWrapperTable->m_Server_Start));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_Start == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_stop", (void**)&(pWrapperTable->m_Server_Stop));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_Stop == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_closeallconnections", (void**)&(pWrapperTable->m_Server_CloseAllConnections));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_CloseAllConnections == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_setthreadcount", (void**)&(pWrapperTable->m_Server_SetThreadCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_SetThreadCount == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_setbuffersize", (void**)&(pWrapperTable->m_Server_SetBufferSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_SetBufferSize == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_acceptdevice", (void**)&(pWrapperTable->m_Server_AcceptDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_AcceptDevice == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_unacceptdevice", (void**)&(pWrapperTable->m_Server_UnAcceptDevice));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_UnAcceptDevice == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_clearaccepteddevices", (void**)&(pWrapperTable->m_Server_ClearAcceptedDevices));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_ClearAcceptedDevices == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_listconnections", (void**)&(pWrapperTable->m_Server_ListConnections));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_ListConnections == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_setconnectionacceptedcallback", (void**)&(pWrapperTable->m_Server_SetConnectionAcceptedCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_SetConnectionAcceptedCallback == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_server_setconnectionrejectedcallback", (void**)&(pWrapperTable->m_Server_SetConnectionRejectedCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_Server_SetConnectionRejectedCallback == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("liboie_createserver", (void**)&(pWrapperTable->m_CreateServer));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateServer == nullptr) )
			return LIBOIE_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBOIE_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CIterator
	 */
	
	/**
	* CIterator::MoveNext - Iterates to the next resource in the list.
	* @return Iterates to the next resource in the list.
	*/
	bool CIterator::MoveNext()
	{
		bool resultHasNext = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MoveNext(m_pHandle, &resultHasNext));
		
		return resultHasNext;
	}
	
	/**
	* CIterator::MovePrevious - Iterates to the previous resource in the list.
	* @return Iterates to the previous resource in the list.
	*/
	bool CIterator::MovePrevious()
	{
		bool resultHasPrevious = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MovePrevious(m_pHandle, &resultHasPrevious));
		
		return resultHasPrevious;
	}
	
	/**
	* CIterator::GetCurrent - Returns the resource the iterator points at.
	* @return returns the resource instance.
	*/
	PBase CIterator::GetCurrent()
	{
		LibOIEHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_GetCurrent(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBase>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	* CIterator::Clone - Creates a new resource iterator with the same resource list.
	* @return returns the cloned Iterator instance
	*/
	PIterator CIterator::Clone()
	{
		LibOIEHandle hOutIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Clone(m_pHandle, &hOutIterator));
		
		if (!hOutIterator) {
			CheckError(LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CIterator>(m_pWrapper, hOutIterator);
	}
	
	/**
	* CIterator::Count - Returns the number of resoucres the iterator captures.
	* @return returns the number of resources the iterator captures.
	*/
	LibOIE_uint64 CIterator::Count()
	{
		LibOIE_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CDataPackage
	 */
	
	/**
	* CDataPackage::GetRawPayload - Returns the raw payload.
	* @param[out] PayloadBuffer - Raw payload data.
	*/
	void CDataPackage::GetRawPayload(std::vector<LibOIE_uint8> & PayloadBuffer)
	{
		LibOIE_uint64 elementsNeededPayload = 0;
		LibOIE_uint64 elementsWrittenPayload = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataPackage_GetRawPayload(m_pHandle, 0, &elementsNeededPayload, nullptr));
		PayloadBuffer.resize((size_t) elementsNeededPayload);
		CheckError(m_pWrapper->m_WrapperTable.m_DataPackage_GetRawPayload(m_pHandle, elementsNeededPayload, &elementsWrittenPayload, PayloadBuffer.data()));
	}
	
	/**
	* CDataPackage::Release - Releases memory of the data package.
	*/
	void CDataPackage::Release()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataPackage_Release(m_pHandle));
	}
	
	/**
	 * Method definitions for class CPyroDataPackage
	 */
	
	/**
	 * Method definitions for class CPyroDataPackageIterator
	 */
	
	/**
	* CPyroDataPackageIterator::GetCurrentPyroDataPackage - Returns the data package the iterator points at.
	* @return returns the data package instance.
	*/
	PPyroDataPackage CPyroDataPackageIterator::GetCurrentPyroDataPackage()
	{
		LibOIEHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_PyroDataPackageIterator_GetCurrentPyroDataPackage(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPyroDataPackage>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class COctDataPackage
	 */
	
	/**
	 * Method definitions for class COctDataPackageIterator
	 */
	
	/**
	* COctDataPackageIterator::GetCurrentOctDataPackage - Returns the data package the iterator points at.
	* @return returns the data package instance.
	*/
	POctDataPackage COctDataPackageIterator::GetCurrentOctDataPackage()
	{
		LibOIEHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_OctDataPackageIterator_GetCurrentOctDataPackage(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COctDataPackage>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CRemoteFunctionCall
	 */
	
	/**
	* CRemoteFunctionCall::GetFunctionName - Returns function name
	* @return Function Name.
	*/
	std::string CRemoteFunctionCall::GetFunctionName()
	{
		LibOIE_uint32 bytesNeededFunctionName = 0;
		LibOIE_uint32 bytesWrittenFunctionName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RemoteFunctionCall_GetFunctionName(m_pHandle, 0, &bytesNeededFunctionName, nullptr));
		std::vector<char> bufferFunctionName(bytesNeededFunctionName);
		CheckError(m_pWrapper->m_WrapperTable.m_RemoteFunctionCall_GetFunctionName(m_pHandle, bytesNeededFunctionName, &bytesWrittenFunctionName, &bufferFunctionName[0]));
		
		return std::string(&bufferFunctionName[0]);
	}
	
	/**
	* CRemoteFunctionCall::AddParameter - Adds a function call parameter
	* @param[in] sParameter - Parameter of the call.
	*/
	void CRemoteFunctionCall::AddParameter(const std::string & sParameter)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_RemoteFunctionCall_AddParameter(m_pHandle, sParameter.c_str()));
	}
	
	/**
	* CRemoteFunctionCall::Send - Sends a remote function call over its connection.
	* @return Returns result if successful.
	*/
	std::string CRemoteFunctionCall::Send()
	{
		LibOIE_uint32 bytesNeededResultString = 0;
		LibOIE_uint32 bytesWrittenResultString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_RemoteFunctionCall_Send(m_pHandle, 0, &bytesNeededResultString, nullptr));
		std::vector<char> bufferResultString(bytesNeededResultString);
		CheckError(m_pWrapper->m_WrapperTable.m_RemoteFunctionCall_Send(m_pHandle, bytesNeededResultString, &bytesWrittenResultString, &bufferResultString[0]));
		
		return std::string(&bufferResultString[0]);
	}
	
	/**
	 * Method definitions for class CConnection
	 */
	
	/**
	* CConnection::Disconnect - Disconnects and closes the connection
	*/
	void CConnection::Disconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_Disconnect(m_pHandle));
	}
	
	/**
	* CConnection::SetRequestTimeout - Sets timeout value for each poll request below.
	* @param[in] nTimeout - Timeout in milliseconds. Default is 1000ms. Minimum 10ms, maximum 1000000ms.
	*/
	void CConnection::SetRequestTimeout(const LibOIE_uint32 nTimeout)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_SetRequestTimeout(m_pHandle, nTimeout));
	}
	
	/**
	* CConnection::SetMaxErrorCount - Sets the maximum error messages that can be received before the connection is terminated.
	* @param[in] nErrorCount - Max Error count. Default is 1024. Minimum 16, maximum 65535.
	*/
	void CConnection::SetMaxErrorCount(const LibOIE_uint32 nErrorCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_SetMaxErrorCount(m_pHandle, nErrorCount));
	}
	
	/**
	* CConnection::SetMaxMemoryCount - Sets the maximum memory buffer the data packets can use before the connection is terminated.
	* @param[in] nMaxMemoryCount - Max memory count in bytes. Default is 1MB. Minimum 1kB, maximum 1GB.
	*/
	void CConnection::SetMaxMemoryCount(const LibOIE_uint32 nMaxMemoryCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_SetMaxMemoryCount(m_pHandle, nMaxMemoryCount));
	}
	
	/**
	* CConnection::SetBufferFile - Sets a temporary filename to which the packets are buffered.
	* @param[in] sFileName - Filename which should be used as buffer.
	* @param[in] nMaxMemoryCount - Max memory count in bytes. Default is 1MB. Minimum 1kB, maximum 1TB.
	*/
	void CConnection::SetBufferFile(const std::string & sFileName, const LibOIE_uint64 nMaxMemoryCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_SetBufferFile(m_pHandle, sFileName.c_str(), nMaxMemoryCount));
	}
	
	/**
	* CConnection::UnsetBufferFile - Stops writing to disk.
	*/
	void CConnection::UnsetBufferFile()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_UnsetBufferFile(m_pHandle));
	}
	
	/**
	* CConnection::SetCheckAliveInterval - Sets check alive interval. 0ms means no check alive request is sent.
	* @param[in] nCheckAliveInterval - Timeout in milliseconds. Default is 1000ms. Max value is 1000000ms.
	*/
	void CConnection::SetCheckAliveInterval(const LibOIE_uint32 nCheckAliveInterval)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_SetCheckAliveInterval(m_pHandle, nCheckAliveInterval));
	}
	
	/**
	* CConnection::RetrieveFirmwareVersion - Retrieves Firmware Version. Fails if firmware is not existing.
	* @param[in] sFirmwareName - Name of the firmware to retrieve.
	* @param[out] sFirmwareVersion - Version of the requested firmware.
	* @param[out] sFilename - Filename of the requested firmware.
	* @param[out] sFiledate - Timestamp of the requested firmware in ISO8601 Time.
	* @param[out] sSHA256 - Checksum of the requested firmware.
	*/
	void CConnection::RetrieveFirmwareVersion(const std::string & sFirmwareName, std::string & sFirmwareVersion, std::string & sFilename, std::string & sFiledate, std::string & sSHA256)
	{
		LibOIE_uint32 bytesNeededFirmwareVersion = 0;
		LibOIE_uint32 bytesWrittenFirmwareVersion = 0;
		LibOIE_uint32 bytesNeededFilename = 0;
		LibOIE_uint32 bytesWrittenFilename = 0;
		LibOIE_uint32 bytesNeededFiledate = 0;
		LibOIE_uint32 bytesWrittenFiledate = 0;
		LibOIE_uint32 bytesNeededSHA256 = 0;
		LibOIE_uint32 bytesWrittenSHA256 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_RetrieveFirmwareVersion(m_pHandle, sFirmwareName.c_str(), 0, &bytesNeededFirmwareVersion, nullptr, 0, &bytesNeededFilename, nullptr, 0, &bytesNeededFiledate, nullptr, 0, &bytesNeededSHA256, nullptr));
		std::vector<char> bufferFirmwareVersion(bytesNeededFirmwareVersion);
		std::vector<char> bufferFilename(bytesNeededFilename);
		std::vector<char> bufferFiledate(bytesNeededFiledate);
		std::vector<char> bufferSHA256(bytesNeededSHA256);
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_RetrieveFirmwareVersion(m_pHandle, sFirmwareName.c_str(), bytesNeededFirmwareVersion, &bytesWrittenFirmwareVersion, &bufferFirmwareVersion[0], bytesNeededFilename, &bytesWrittenFilename, &bufferFilename[0], bytesNeededFiledate, &bytesWrittenFiledate, &bufferFiledate[0], bytesNeededSHA256, &bytesWrittenSHA256, &bufferSHA256[0]));
		sFirmwareVersion = std::string(&bufferFirmwareVersion[0]);
		sFilename = std::string(&bufferFilename[0]);
		sFiledate = std::string(&bufferFiledate[0]);
		sSHA256 = std::string(&bufferSHA256[0]);
	}
	
	/**
	* CConnection::UpdateFirmware - Retrieves Firmware Version. Fails if firmware is not existing.
	* @param[in] sFirmwareName - Name of the new firmware.
	* @param[in] sFirmwareVersion - Version of the new firmware.
	* @param[in] sFileName - Filename of the new firmware.
	* @param[in] sFileDate - Timestamp of the requested firmware in ISO8601 Time.
	* @param[in] sSHA256 - Checksum of the new firmware.
	* @param[in] BinaryDataBuffer - Blob of new firmware.
	*/
	void CConnection::UpdateFirmware(const std::string & sFirmwareName, const std::string & sFirmwareVersion, const std::string & sFileName, const std::string & sFileDate, const std::string & sSHA256, const CInputVector<LibOIE_uint8> & BinaryDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_UpdateFirmware(m_pHandle, sFirmwareName.c_str(), sFirmwareVersion.c_str(), sFileName.c_str(), sFileDate.c_str(), sSHA256.c_str(), (LibOIE_uint64)BinaryDataBuffer.size(), BinaryDataBuffer.data()));
	}
	
	/**
	* CConnection::StartFirmware - Starts firmware on Open Interface Extension.
	* @param[in] sFileName - Filename of the firmware to start.
	* @return Firmware successfully started.
	*/
	bool CConnection::StartFirmware(const std::string & sFileName)
	{
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_StartFirmware(m_pHandle, sFileName.c_str(), &resultSuccess));
		
		return resultSuccess;
	}
	
	/**
	* CConnection::StopFirmware - Stops firmware on Open Interface Extension.
	* @param[in] sFileName - Filename of the firmware to stop.
	* @return Firmware successfully stopped.
	*/
	bool CConnection::StopFirmware(const std::string & sFileName)
	{
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_StopFirmware(m_pHandle, sFileName.c_str(), &resultSuccess));
		
		return resultSuccess;
	}
	
	/**
	* CConnection::SetConnectionErrorCallback - sets a callback that triggers when a connection error occured.
	* @param[in] pCallback - callback pointer.
	*/
	void CConnection::SetConnectionErrorCallback(const ConnectionErrorCallback pCallback)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_SetConnectionErrorCallback(m_pHandle, pCallback));
	}
	
	/**
	* CConnection::ClearErrors - clears the error log.
	*/
	void CConnection::ClearErrors()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_ClearErrors(m_pHandle));
	}
	
	/**
	* CConnection::GetErrorCount - Returns the list of errors in the error log.
	* @return Errors in the error log.
	*/
	LibOIE_uint32 CConnection::GetErrorCount()
	{
		LibOIE_uint32 resultErrorCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_GetErrorCount(m_pHandle, &resultErrorCount));
		
		return resultErrorCount;
	}
	
	/**
	* CConnection::GetError - Returns an error message of the error log
	* @param[in] nErrorIndex - Index of the error.
	* @param[out] sErrorMessage - Message of the error.
	* @param[out] sTimestamp - ISO8601 Time when the error was reported.
	*/
	void CConnection::GetError(const LibOIE_uint32 nErrorIndex, std::string & sErrorMessage, std::string & sTimestamp)
	{
		LibOIE_uint32 bytesNeededErrorMessage = 0;
		LibOIE_uint32 bytesWrittenErrorMessage = 0;
		LibOIE_uint32 bytesNeededTimestamp = 0;
		LibOIE_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_GetError(m_pHandle, nErrorIndex, 0, &bytesNeededErrorMessage, nullptr, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_GetError(m_pHandle, nErrorIndex, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		sTimestamp = std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CConnection::CreateRemoteFunctionCall - Creates a new remote function call.
	* @param[in] sFunctionName - Function name.
	* @return Function call instance.
	*/
	PRemoteFunctionCall CConnection::CreateRemoteFunctionCall(const std::string & sFunctionName)
	{
		LibOIEHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_CreateRemoteFunctionCall(m_pHandle, sFunctionName.c_str(), &hInstance));
		
		if (!hInstance) {
			CheckError(LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRemoteFunctionCall>(m_pWrapper, hInstance);
	}
	
	/**
	* CConnection::GetBufferedPyroPackages - Retrieves currently buffered pyro packages.
	* @return Iterator of buffered packages.
	*/
	PPyroDataPackageIterator CConnection::GetBufferedPyroPackages()
	{
		LibOIEHandle hIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_GetBufferedPyroPackages(m_pHandle, &hIterator));
		
		if (!hIterator) {
			CheckError(LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPyroDataPackageIterator>(m_pWrapper, hIterator);
	}
	
	/**
	* CConnection::GetBufferedOctPackages - Retrieves currently buffered oct packages.
	* @return Iterator of buffered packages.
	*/
	POctDataPackageIterator CConnection::GetBufferedOctPackages()
	{
		LibOIEHandle hIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Connection_GetBufferedOctPackages(m_pHandle, &hIterator));
		
		if (!hIterator) {
			CheckError(LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COctDataPackageIterator>(m_pWrapper, hIterator);
	}
	
	/**
	 * Method definitions for class CConnectionIterator
	 */
	
	/**
	* CConnectionIterator::GetCurrentConnection - Returns the connection the iterator points at.
	* @return returns the connection instance.
	*/
	PConnection CConnectionIterator::GetCurrentConnection()
	{
		LibOIEHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ConnectionIterator_GetCurrentConnection(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CConnection>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CServer
	 */
	
	/**
	* CServer::Start - starts listening for connections.
	* @param[in] sIPAddress - IP Address to run on
	* @param[in] nPort - Port to run on
	* @param[in] bIPv6 - flag if IPv6 should be used
	*/
	void CServer::Start(const std::string & sIPAddress, const LibOIE_uint32 nPort, const bool bIPv6)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Server_Start(m_pHandle, sIPAddress.c_str(), nPort, bIPv6));
	}
	
	/**
	* CServer::Stop - stops listening for connections and disconnects existing ones.
	*/
	void CServer::Stop()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Server_Stop(m_pHandle));
	}
	
	/**
	* CServer::CloseAllConnections - disconnects all connections but does not stop listening.
	*/
	void CServer::CloseAllConnections()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Server_CloseAllConnections(m_pHandle));
	}
	
	/**
	* CServer::SetThreadCount - sets the maximum thread count to use. Must be called before Start
	* @param[in] nThreadCount - Thread count to use (must be larger than 4, default is 32)
	*/
	void CServer::SetThreadCount(const LibOIE_uint32 nThreadCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Server_SetThreadCount(m_pHandle, nThreadCount));
	}
	
	/**
	* CServer::SetBufferSize - sets the receive buffer size
	* @param[in] nRCVBufferSize - Receive buffer size to use in bytes (must be between 4kB and 1GB, default is 1MB)
	*/
	void CServer::SetBufferSize(const LibOIE_uint32 nRCVBufferSize)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Server_SetBufferSize(m_pHandle, nRCVBufferSize));
	}
	
	/**
	* CServer::AcceptDevice - adds an accepted device
	* @param[in] sDeviceName - Device name to be accepted. Empty string means all devices.
	* @param[in] sApplicationName - Application name to be accepted. Empty string means all applications.
	* @param[in] sVersionName - Version name to be accepted. Empty string means all versions.
	* @return Returns identifier of acceptance rule.
	*/
	LibOIE_uint32 CServer::AcceptDevice(const std::string & sDeviceName, const std::string & sApplicationName, const std::string & sVersionName)
	{
		LibOIE_uint32 resultRuleID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Server_AcceptDevice(m_pHandle, sDeviceName.c_str(), sApplicationName.c_str(), sVersionName.c_str(), &resultRuleID));
		
		return resultRuleID;
	}
	
	/**
	* CServer::UnAcceptDevice - removes an accepted
	* @param[in] nRuleID - identifier of acceptance rule.
	*/
	void CServer::UnAcceptDevice(const LibOIE_uint32 nRuleID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Server_UnAcceptDevice(m_pHandle, nRuleID));
	}
	
	/**
	* CServer::ClearAcceptedDevices - clears all accepted device rules
	*/
	void CServer::ClearAcceptedDevices()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Server_ClearAcceptedDevices(m_pHandle));
	}
	
	/**
	* CServer::ListConnections - lists all open connections
	* @return list of all open connections.
	*/
	PConnectionIterator CServer::ListConnections()
	{
		LibOIEHandle hConnectionIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Server_ListConnections(m_pHandle, &hConnectionIteratorInstance));
		
		if (!hConnectionIteratorInstance) {
			CheckError(LIBOIE_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CConnectionIterator>(m_pWrapper, hConnectionIteratorInstance);
	}
	
	/**
	* CServer::SetConnectionAcceptedCallback - sets a callback that triggers when a new connection was established.
	* @param[in] pCallback - callback pointer.
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CServer::SetConnectionAcceptedCallback(const ConnectionAcceptedCallback pCallback, const LibOIE_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Server_SetConnectionAcceptedCallback(m_pHandle, pCallback, pUserData));
	}
	
	/**
	* CServer::SetConnectionRejectedCallback - sets a callback that triggers when a new connection was rejected.
	* @param[in] pCallback - callback pointer.
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CServer::SetConnectionRejectedCallback(const ConnectionRejectedCallback pCallback, const LibOIE_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Server_SetConnectionRejectedCallback(m_pHandle, pCallback, pUserData));
	}

} // namespace LibOIE

#endif // __LIBOIE_CPPHEADER_DYNAMIC_CPP

