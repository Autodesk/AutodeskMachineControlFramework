/*++

Copyright (C) 2023 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Driver ScanLab SCANmotionControl

Interface version: 2.0.0

*/

#ifndef __LIBMCDRIVER_SCANLABSMC_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_SCANLABSMC_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_scanlabsmc_types.hpp"
#include "libmcdriver_scanlabsmc_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_ScanLabSMC {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CSMCJob;
class CSMCConfiguration;
class CSMCContext;
class CDriver_ScanLabSMC;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_ScanLabSMCWrapper;
typedef CBase CLibMCDriver_ScanLabSMCBase;
typedef CDriver CLibMCDriver_ScanLabSMCDriver;
typedef CSMCJob CLibMCDriver_ScanLabSMCSMCJob;
typedef CSMCConfiguration CLibMCDriver_ScanLabSMCSMCConfiguration;
typedef CSMCContext CLibMCDriver_ScanLabSMCSMCContext;
typedef CDriver_ScanLabSMC CLibMCDriver_ScanLabSMCDriver_ScanLabSMC;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CSMCJob> PSMCJob;
typedef std::shared_ptr<CSMCConfiguration> PSMCConfiguration;
typedef std::shared_ptr<CSMCContext> PSMCContext;
typedef std::shared_ptr<CDriver_ScanLabSMC> PDriver_ScanLabSMC;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_ScanLabSMCWrapper;
typedef PBase PLibMCDriver_ScanLabSMCBase;
typedef PDriver PLibMCDriver_ScanLabSMCDriver;
typedef PSMCJob PLibMCDriver_ScanLabSMCSMCJob;
typedef PSMCConfiguration PLibMCDriver_ScanLabSMCSMCConfiguration;
typedef PSMCContext PLibMCDriver_ScanLabSMCSMCContext;
typedef PDriver_ScanLabSMC PLibMCDriver_ScanLabSMCDriver_ScanLabSMC;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_ScanLabSMCHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_ScanLabSMCException 
**************************************************************************************************************************/
class ELibMCDriver_ScanLabSMCException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_ScanLabSMCResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_ScanLabSMCException(LibMCDriver_ScanLabSMCResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_ScanLabSMCResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLABSMC_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_SCANLABSMC_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_SCANLABSMC_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_SCANLABSMC_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_SCANLABSMC_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYCONFIGURATIONXML: return "EMPTYCONFIGURATIONXML";
			case LIBMCDRIVER_SCANLABSMC_ERROR_DRIVERERROR: return "DRIVERERROR";
			case LIBMCDRIVER_SCANLABSMC_ERROR_UNSUPPORTEDPLATFORM: return "UNSUPPORTEDPLATFORM";
			case LIBMCDRIVER_SCANLABSMC_ERROR_SDKALREADYLOADED: return "SDKALREADYLOADED";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYSMCDLLRESOURCENAME: return "EMPTYSMCDLLRESOURCENAME";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYRTCDLLRESOURCENAME: return "EMPTYRTCDLLRESOURCENAME";
			case LIBMCDRIVER_SCANLABSMC_ERROR_SMCSDKRESOURCENOTFOUND: return "SMCSDKRESOURCENOTFOUND";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTSTORESMCSDK: return "COULDNOTSTORESMCSDK";
			case LIBMCDRIVER_SCANLABSMC_ERROR_RTCSDKRESOURCENOTFOUND: return "RTCSDKRESOURCENOTFOUND";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTSTORERTCSDK: return "COULDNOTSTORERTCSDK";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYSMCDLLRESOURCEDATA: return "EMPTYSMCDLLRESOURCEDATA";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYRTCDLLRESOURCEDATA: return "EMPTYRTCDLLRESOURCEDATA";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYXERCESDLLRESOURCENAME: return "EMPTYXERCESDLLRESOURCENAME";
			case LIBMCDRIVER_SCANLABSMC_ERROR_XERCESRESOURCENOTFOUND: return "XERCESRESOURCENOTFOUND";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTSTOREXERCESDLL: return "COULDNOTSTOREXERCESDLL";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYXERCESRESOURCEDATA: return "EMPTYXERCESRESOURCEDATA";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_SCANLABSMC_SUCCESS: return "success";
			case LIBMCDRIVER_SCANLABSMC_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_SCANLABSMC_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_SCANLABSMC_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_SCANLABSMC_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYCONFIGURATIONXML: return "empty configuration XML";
			case LIBMCDRIVER_SCANLABSMC_ERROR_DRIVERERROR: return "a driver error occured";
			case LIBMCDRIVER_SCANLABSMC_ERROR_UNSUPPORTEDPLATFORM: return "Unsupported platform. SMC only works on Windows only for now.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_SDKALREADYLOADED: return "SDK has already been loaded.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYSMCDLLRESOURCENAME: return "Empty SMC DLL Resource Name.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYRTCDLLRESOURCENAME: return "Empty RTC DLL Resource Name.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_SMCSDKRESOURCENOTFOUND: return "SMC SDK Resource not found.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTSTORESMCSDK: return "Could not store SMC SDK.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_RTCSDKRESOURCENOTFOUND: return "RTC SDK Resource not found.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTSTORERTCSDK: return "Could not store RTC SDK.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYSMCDLLRESOURCEDATA: return "Empty SMC DLL Resource Data.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYRTCDLLRESOURCEDATA: return "Empty RTC DLL Resource Data.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYXERCESDLLRESOURCENAME: return "Empty Xerces Resource Name.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_XERCESRESOURCENOTFOUND: return "Xerces Resource not found.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTSTOREXERCESDLL: return "Could not store Xerces DLL.";
			case LIBMCDRIVER_SCANLABSMC_ERROR_EMPTYXERCESRESOURCEDATA: return "Empty Xerces Resource Data.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_ScanLabSMCInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_ScanLabSMCResult nResult);

	inline void GetVersion(LibMCDriver_ScanLabSMC_uint32 & nMajor, LibMCDriver_ScanLabSMC_uint32 & nMinor, LibMCDriver_ScanLabSMC_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLabSMC_pvoid pSymbolAddressMethod);
	inline LibMCDriver_ScanLabSMC_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_ScanLabSMCDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_ScanLabSMCResult checkBinaryVersion()
	{
		LibMCDriver_ScanLabSMC_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_SCANLABSMC_VERSION_MAJOR) {
			return LIBMCDRIVER_SCANLABSMC_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_SCANLABSMC_SUCCESS;
	}
	LibMCDriver_ScanLabSMCResult initWrapperTable(sLibMCDriver_ScanLabSMCDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabSMCResult releaseWrapperTable(sLibMCDriver_ScanLabSMCDynamicWrapperTable * pWrapperTable);
	LibMCDriver_ScanLabSMCResult loadWrapperTable(sLibMCDriver_ScanLabSMCDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_ScanLabSMCResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabSMCDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CSMCJob;
	friend class CSMCConfiguration;
	friend class CSMCContext;
	friend class CDriver_ScanLabSMC;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_ScanLabSMCHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_ScanLabSMCResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_ScanLabSMCHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_ScanLabSMCHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_ScanLabSMCHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_ScanLabSMC_uint32 & nMajor, LibMCDriver_ScanLabSMC_uint32 & nMinor, LibMCDriver_ScanLabSMC_uint32 & nMicro, std::string & sBuild);
	inline void QueryParameters();
	inline void QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance);
};
	
/*************************************************************************************************************************
 Class CSMCJob 
**************************************************************************************************************************/
class CSMCJob : public CBase {
public:
	
	/**
	* CSMCJob::CSMCJob - Constructor for SMCJob class.
	*/
	CSMCJob(CWrapper* pWrapper, LibMCDriver_ScanLabSMCHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCDriver_ScanLabSMC_uint64 GetJobID();
	inline void Finalize();
	inline bool IsFinalized();
	inline void DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLabSMC_double dMarkSpeed, const LibMCDriver_ScanLabSMC_double dMinimalMarkSpeed, const LibMCDriver_ScanLabSMC_double dJumpSpeed, const LibMCDriver_ScanLabSMC_double dPower, const LibMCDriver_ScanLabSMC_double dCornerTolerance, const LibMCDriver_ScanLabSMC_double dZValue);
	inline void DrawLoop(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLabSMC_double dMarkSpeed, const LibMCDriver_ScanLabSMC_double dMinimalMarkSpeed, const LibMCDriver_ScanLabSMC_double dJumpSpeed, const LibMCDriver_ScanLabSMC_double dPower, const LibMCDriver_ScanLabSMC_double dCornerTolerance, const LibMCDriver_ScanLabSMC_double dZValue);
	inline void DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLabSMC_double dMarkSpeed, const LibMCDriver_ScanLabSMC_double dJumpSpeed, const LibMCDriver_ScanLabSMC_double dPower, const LibMCDriver_ScanLabSMC_double dZValue);
	inline bool IsReady();
	inline void Execute(const bool bBlocking);
	inline bool IsExecuting();
	inline void WaitForExecution(const LibMCDriver_ScanLabSMC_uint32 nTimeOutInMilliseconds);
	inline void StopExecution();
};
	
/*************************************************************************************************************************
 Class CSMCConfiguration 
**************************************************************************************************************************/
class CSMCConfiguration : public CBase {
public:
	
	/**
	* CSMCConfiguration::CSMCConfiguration - Constructor for SMCConfiguration class.
	*/
	CSMCConfiguration(CWrapper* pWrapper, LibMCDriver_ScanLabSMCHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void SetDynamicViolationReaction(const eDynamicViolationReaction eValue);
	inline eDynamicViolationReaction GetDynamicViolationReaction();
	inline void SetWarnLevel(const eWarnLevel eValue);
	inline eWarnLevel GetWarnLevel();
};
	
/*************************************************************************************************************************
 Class CSMCContext 
**************************************************************************************************************************/
class CSMCContext : public CBase {
public:
	
	/**
	* CSMCContext::CSMCContext - Constructor for SMCContext class.
	*/
	CSMCContext(CWrapper* pWrapper, LibMCDriver_ScanLabSMCHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void SetToSimulationMode();
	inline bool IsSimulationMode();
	inline void SetFirmware(const CInputVector<LibMCDriver_ScanLabSMC_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLabSMC_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLabSMC_uint8> & AuxiliaryDataBuffer);
	inline void SetCorrectionFile(const CInputVector<LibMCDriver_ScanLabSMC_uint8> & CorrectionFileDataBuffer);
	inline void ReinitializeInstance();
	inline std::string GetIPAddress();
	inline std::string GetNetmask();
	inline LibMCDriver_ScanLabSMC_uint32 GetSerialNumber();
	inline LibMCDriver_ScanLabSMC_uint32 GetLaserIndex();
	inline void SetLaserOrigin(const LibMCDriver_ScanLabSMC_double dOriginX, const LibMCDriver_ScanLabSMC_double dOriginY);
	inline void GetLaserOrigin(LibMCDriver_ScanLabSMC_double & dOriginX, LibMCDriver_ScanLabSMC_double & dOriginY);
	inline void SetLaserField(const LibMCDriver_ScanLabSMC_double dMinX, const LibMCDriver_ScanLabSMC_double dMinY, const LibMCDriver_ScanLabSMC_double dMaxX, const LibMCDriver_ScanLabSMC_double dMaxY);
	inline void ResetLaserField();
	inline bool GetLaserField(LibMCDriver_ScanLabSMC_double & dMinX, LibMCDriver_ScanLabSMC_double & dMinY, LibMCDriver_ScanLabSMC_double & dMaxX, LibMCDriver_ScanLabSMC_double & dMaxY);
	inline PSMCJob BeginJob(const LibMCDriver_ScanLabSMC_double dStartPositionX, const LibMCDriver_ScanLabSMC_double dStartPositionY, const eBlendMode eBlendMode);
	inline PSMCJob GetUnfinishedJob();
};
	
/*************************************************************************************************************************
 Class CDriver_ScanLabSMC 
**************************************************************************************************************************/
class CDriver_ScanLabSMC : public CDriver {
public:
	
	/**
	* CDriver_ScanLabSMC::CDriver_ScanLabSMC - Constructor for Driver_ScanLabSMC class.
	*/
	CDriver_ScanLabSMC(CWrapper* pWrapper, LibMCDriver_ScanLabSMCHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline void SetDLLResources(const std::string & sSMCDLLResourceName, const std::string & sRTCDLLResourceName);
	inline void SetXercesDLLResource(const std::string & sXercesDLLResourceName);
	inline void SetCustomDLLData(const CInputVector<LibMCDriver_ScanLabSMC_uint8> & SMCDLLResourceDataBuffer, const CInputVector<LibMCDriver_ScanLabSMC_uint8> & RTCDLLResourceDataBuffer);
	inline void SetCustomXercesDLLData(const CInputVector<LibMCDriver_ScanLabSMC_uint8> & XercesDLLResourceDataBuffer);
	inline void LoadSDK();
	inline PSMCContext CreateContext(classParam<CSMCConfiguration> pSMCConfiguration);
	inline PSMCConfiguration CreateEmptyConfiguration();
	inline PSMCConfiguration CreateTemplateConfiguration(const std::string & sTemplateName);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_ScanLabSMC_uint32 & nMajor, LibMCDriver_ScanLabSMC_uint32 & nMinor, LibMCDriver_ScanLabSMC_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_ScanLabSMCHandle hInstance = pInstance.GetHandle();
		LibMCDriver_ScanLabSMC_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_ScanLabSMC_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabSMCHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_ScanLabSMCHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_ScanLabSMC_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_ScanLabSMCException(LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_ScanLabSMCException(LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_ScanLabSMC_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_ScanLabSMC_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_ScanLabSMCHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (hInstance) {
			return std::make_shared<CDriver>(this, hInstance);
		} else {
			return nullptr;
		}
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_ScanLabSMCResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_ScanLabSMCException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_ScanLabSMCResult CWrapper::initWrapperTable(sLibMCDriver_ScanLabSMCDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_Driver_QueryParametersEx = nullptr;
		pWrapperTable->m_SMCJob_GetJobID = nullptr;
		pWrapperTable->m_SMCJob_Finalize = nullptr;
		pWrapperTable->m_SMCJob_IsFinalized = nullptr;
		pWrapperTable->m_SMCJob_DrawPolyline = nullptr;
		pWrapperTable->m_SMCJob_DrawLoop = nullptr;
		pWrapperTable->m_SMCJob_DrawHatches = nullptr;
		pWrapperTable->m_SMCJob_IsReady = nullptr;
		pWrapperTable->m_SMCJob_Execute = nullptr;
		pWrapperTable->m_SMCJob_IsExecuting = nullptr;
		pWrapperTable->m_SMCJob_WaitForExecution = nullptr;
		pWrapperTable->m_SMCJob_StopExecution = nullptr;
		pWrapperTable->m_SMCConfiguration_SetDynamicViolationReaction = nullptr;
		pWrapperTable->m_SMCConfiguration_GetDynamicViolationReaction = nullptr;
		pWrapperTable->m_SMCConfiguration_SetWarnLevel = nullptr;
		pWrapperTable->m_SMCConfiguration_GetWarnLevel = nullptr;
		pWrapperTable->m_SMCContext_SetToSimulationMode = nullptr;
		pWrapperTable->m_SMCContext_IsSimulationMode = nullptr;
		pWrapperTable->m_SMCContext_SetFirmware = nullptr;
		pWrapperTable->m_SMCContext_SetCorrectionFile = nullptr;
		pWrapperTable->m_SMCContext_ReinitializeInstance = nullptr;
		pWrapperTable->m_SMCContext_GetIPAddress = nullptr;
		pWrapperTable->m_SMCContext_GetNetmask = nullptr;
		pWrapperTable->m_SMCContext_GetSerialNumber = nullptr;
		pWrapperTable->m_SMCContext_GetLaserIndex = nullptr;
		pWrapperTable->m_SMCContext_SetLaserOrigin = nullptr;
		pWrapperTable->m_SMCContext_GetLaserOrigin = nullptr;
		pWrapperTable->m_SMCContext_SetLaserField = nullptr;
		pWrapperTable->m_SMCContext_ResetLaserField = nullptr;
		pWrapperTable->m_SMCContext_GetLaserField = nullptr;
		pWrapperTable->m_SMCContext_BeginJob = nullptr;
		pWrapperTable->m_SMCContext_GetUnfinishedJob = nullptr;
		pWrapperTable->m_Driver_ScanLabSMC_SetDLLResources = nullptr;
		pWrapperTable->m_Driver_ScanLabSMC_SetXercesDLLResource = nullptr;
		pWrapperTable->m_Driver_ScanLabSMC_SetCustomDLLData = nullptr;
		pWrapperTable->m_Driver_ScanLabSMC_SetCustomXercesDLLData = nullptr;
		pWrapperTable->m_Driver_ScanLabSMC_LoadSDK = nullptr;
		pWrapperTable->m_Driver_ScanLabSMC_CreateContext = nullptr;
		pWrapperTable->m_Driver_ScanLabSMC_CreateEmptyConfiguration = nullptr;
		pWrapperTable->m_Driver_ScanLabSMC_CreateTemplateConfiguration = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_SCANLABSMC_SUCCESS;
	}

	inline LibMCDriver_ScanLabSMCResult CWrapper::releaseWrapperTable(sLibMCDriver_ScanLabSMCDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_SCANLABSMC_SUCCESS;
	}

	inline LibMCDriver_ScanLabSMCResult CWrapper::loadWrapperTable(sLibMCDriver_ScanLabSMCDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabSMCDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_ScanLabSMCDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabSMCDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_ScanLabSMCDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabSMCDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_ScanLabSMCDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabSMCDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_ScanLabSMCDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabSMCDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_ScanLabSMCDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_ScanLabSMCDriver_QueryParametersExPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_queryparametersex");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParametersEx = (PLibMCDriver_ScanLabSMCDriver_QueryParametersExPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_queryparametersex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParametersEx == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_GetJobID = (PLibMCDriver_ScanLabSMCSMCJob_GetJobIDPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_getjobid");
		#else // _WIN32
		pWrapperTable->m_SMCJob_GetJobID = (PLibMCDriver_ScanLabSMCSMCJob_GetJobIDPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_getjobid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_GetJobID == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_Finalize = (PLibMCDriver_ScanLabSMCSMCJob_FinalizePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_finalize");
		#else // _WIN32
		pWrapperTable->m_SMCJob_Finalize = (PLibMCDriver_ScanLabSMCSMCJob_FinalizePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_finalize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_Finalize == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_IsFinalized = (PLibMCDriver_ScanLabSMCSMCJob_IsFinalizedPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_isfinalized");
		#else // _WIN32
		pWrapperTable->m_SMCJob_IsFinalized = (PLibMCDriver_ScanLabSMCSMCJob_IsFinalizedPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_isfinalized");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_IsFinalized == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_DrawPolyline = (PLibMCDriver_ScanLabSMCSMCJob_DrawPolylinePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_drawpolyline");
		#else // _WIN32
		pWrapperTable->m_SMCJob_DrawPolyline = (PLibMCDriver_ScanLabSMCSMCJob_DrawPolylinePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_drawpolyline");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_DrawPolyline == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_DrawLoop = (PLibMCDriver_ScanLabSMCSMCJob_DrawLoopPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_drawloop");
		#else // _WIN32
		pWrapperTable->m_SMCJob_DrawLoop = (PLibMCDriver_ScanLabSMCSMCJob_DrawLoopPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_drawloop");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_DrawLoop == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_DrawHatches = (PLibMCDriver_ScanLabSMCSMCJob_DrawHatchesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_drawhatches");
		#else // _WIN32
		pWrapperTable->m_SMCJob_DrawHatches = (PLibMCDriver_ScanLabSMCSMCJob_DrawHatchesPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_drawhatches");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_DrawHatches == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_IsReady = (PLibMCDriver_ScanLabSMCSMCJob_IsReadyPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_isready");
		#else // _WIN32
		pWrapperTable->m_SMCJob_IsReady = (PLibMCDriver_ScanLabSMCSMCJob_IsReadyPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_isready");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_IsReady == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_Execute = (PLibMCDriver_ScanLabSMCSMCJob_ExecutePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_execute");
		#else // _WIN32
		pWrapperTable->m_SMCJob_Execute = (PLibMCDriver_ScanLabSMCSMCJob_ExecutePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_execute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_Execute == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_IsExecuting = (PLibMCDriver_ScanLabSMCSMCJob_IsExecutingPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_isexecuting");
		#else // _WIN32
		pWrapperTable->m_SMCJob_IsExecuting = (PLibMCDriver_ScanLabSMCSMCJob_IsExecutingPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_isexecuting");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_IsExecuting == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_WaitForExecution = (PLibMCDriver_ScanLabSMCSMCJob_WaitForExecutionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_waitforexecution");
		#else // _WIN32
		pWrapperTable->m_SMCJob_WaitForExecution = (PLibMCDriver_ScanLabSMCSMCJob_WaitForExecutionPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_waitforexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_WaitForExecution == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCJob_StopExecution = (PLibMCDriver_ScanLabSMCSMCJob_StopExecutionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcjob_stopexecution");
		#else // _WIN32
		pWrapperTable->m_SMCJob_StopExecution = (PLibMCDriver_ScanLabSMCSMCJob_StopExecutionPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcjob_stopexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCJob_StopExecution == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCConfiguration_SetDynamicViolationReaction = (PLibMCDriver_ScanLabSMCSMCConfiguration_SetDynamicViolationReactionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcconfiguration_setdynamicviolationreaction");
		#else // _WIN32
		pWrapperTable->m_SMCConfiguration_SetDynamicViolationReaction = (PLibMCDriver_ScanLabSMCSMCConfiguration_SetDynamicViolationReactionPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcconfiguration_setdynamicviolationreaction");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCConfiguration_SetDynamicViolationReaction == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCConfiguration_GetDynamicViolationReaction = (PLibMCDriver_ScanLabSMCSMCConfiguration_GetDynamicViolationReactionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcconfiguration_getdynamicviolationreaction");
		#else // _WIN32
		pWrapperTable->m_SMCConfiguration_GetDynamicViolationReaction = (PLibMCDriver_ScanLabSMCSMCConfiguration_GetDynamicViolationReactionPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcconfiguration_getdynamicviolationreaction");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCConfiguration_GetDynamicViolationReaction == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCConfiguration_SetWarnLevel = (PLibMCDriver_ScanLabSMCSMCConfiguration_SetWarnLevelPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcconfiguration_setwarnlevel");
		#else // _WIN32
		pWrapperTable->m_SMCConfiguration_SetWarnLevel = (PLibMCDriver_ScanLabSMCSMCConfiguration_SetWarnLevelPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcconfiguration_setwarnlevel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCConfiguration_SetWarnLevel == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCConfiguration_GetWarnLevel = (PLibMCDriver_ScanLabSMCSMCConfiguration_GetWarnLevelPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smcconfiguration_getwarnlevel");
		#else // _WIN32
		pWrapperTable->m_SMCConfiguration_GetWarnLevel = (PLibMCDriver_ScanLabSMCSMCConfiguration_GetWarnLevelPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smcconfiguration_getwarnlevel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCConfiguration_GetWarnLevel == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_SetToSimulationMode = (PLibMCDriver_ScanLabSMCSMCContext_SetToSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_settosimulationmode");
		#else // _WIN32
		pWrapperTable->m_SMCContext_SetToSimulationMode = (PLibMCDriver_ScanLabSMCSMCContext_SetToSimulationModePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_settosimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_SetToSimulationMode == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_IsSimulationMode = (PLibMCDriver_ScanLabSMCSMCContext_IsSimulationModePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_issimulationmode");
		#else // _WIN32
		pWrapperTable->m_SMCContext_IsSimulationMode = (PLibMCDriver_ScanLabSMCSMCContext_IsSimulationModePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_issimulationmode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_IsSimulationMode == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_SetFirmware = (PLibMCDriver_ScanLabSMCSMCContext_SetFirmwarePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_setfirmware");
		#else // _WIN32
		pWrapperTable->m_SMCContext_SetFirmware = (PLibMCDriver_ScanLabSMCSMCContext_SetFirmwarePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_setfirmware");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_SetFirmware == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_SetCorrectionFile = (PLibMCDriver_ScanLabSMCSMCContext_SetCorrectionFilePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_setcorrectionfile");
		#else // _WIN32
		pWrapperTable->m_SMCContext_SetCorrectionFile = (PLibMCDriver_ScanLabSMCSMCContext_SetCorrectionFilePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_setcorrectionfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_SetCorrectionFile == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_ReinitializeInstance = (PLibMCDriver_ScanLabSMCSMCContext_ReinitializeInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_reinitializeinstance");
		#else // _WIN32
		pWrapperTable->m_SMCContext_ReinitializeInstance = (PLibMCDriver_ScanLabSMCSMCContext_ReinitializeInstancePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_reinitializeinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_ReinitializeInstance == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_GetIPAddress = (PLibMCDriver_ScanLabSMCSMCContext_GetIPAddressPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_getipaddress");
		#else // _WIN32
		pWrapperTable->m_SMCContext_GetIPAddress = (PLibMCDriver_ScanLabSMCSMCContext_GetIPAddressPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_getipaddress");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_GetIPAddress == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_GetNetmask = (PLibMCDriver_ScanLabSMCSMCContext_GetNetmaskPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_getnetmask");
		#else // _WIN32
		pWrapperTable->m_SMCContext_GetNetmask = (PLibMCDriver_ScanLabSMCSMCContext_GetNetmaskPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_getnetmask");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_GetNetmask == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_GetSerialNumber = (PLibMCDriver_ScanLabSMCSMCContext_GetSerialNumberPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_getserialnumber");
		#else // _WIN32
		pWrapperTable->m_SMCContext_GetSerialNumber = (PLibMCDriver_ScanLabSMCSMCContext_GetSerialNumberPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_getserialnumber");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_GetSerialNumber == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_GetLaserIndex = (PLibMCDriver_ScanLabSMCSMCContext_GetLaserIndexPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_getlaserindex");
		#else // _WIN32
		pWrapperTable->m_SMCContext_GetLaserIndex = (PLibMCDriver_ScanLabSMCSMCContext_GetLaserIndexPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_getlaserindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_GetLaserIndex == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_SetLaserOrigin = (PLibMCDriver_ScanLabSMCSMCContext_SetLaserOriginPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_setlaserorigin");
		#else // _WIN32
		pWrapperTable->m_SMCContext_SetLaserOrigin = (PLibMCDriver_ScanLabSMCSMCContext_SetLaserOriginPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_setlaserorigin");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_SetLaserOrigin == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_GetLaserOrigin = (PLibMCDriver_ScanLabSMCSMCContext_GetLaserOriginPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_getlaserorigin");
		#else // _WIN32
		pWrapperTable->m_SMCContext_GetLaserOrigin = (PLibMCDriver_ScanLabSMCSMCContext_GetLaserOriginPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_getlaserorigin");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_GetLaserOrigin == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_SetLaserField = (PLibMCDriver_ScanLabSMCSMCContext_SetLaserFieldPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_setlaserfield");
		#else // _WIN32
		pWrapperTable->m_SMCContext_SetLaserField = (PLibMCDriver_ScanLabSMCSMCContext_SetLaserFieldPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_setlaserfield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_SetLaserField == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_ResetLaserField = (PLibMCDriver_ScanLabSMCSMCContext_ResetLaserFieldPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_resetlaserfield");
		#else // _WIN32
		pWrapperTable->m_SMCContext_ResetLaserField = (PLibMCDriver_ScanLabSMCSMCContext_ResetLaserFieldPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_resetlaserfield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_ResetLaserField == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_GetLaserField = (PLibMCDriver_ScanLabSMCSMCContext_GetLaserFieldPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_getlaserfield");
		#else // _WIN32
		pWrapperTable->m_SMCContext_GetLaserField = (PLibMCDriver_ScanLabSMCSMCContext_GetLaserFieldPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_getlaserfield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_GetLaserField == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_BeginJob = (PLibMCDriver_ScanLabSMCSMCContext_BeginJobPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_beginjob");
		#else // _WIN32
		pWrapperTable->m_SMCContext_BeginJob = (PLibMCDriver_ScanLabSMCSMCContext_BeginJobPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_beginjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_BeginJob == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SMCContext_GetUnfinishedJob = (PLibMCDriver_ScanLabSMCSMCContext_GetUnfinishedJobPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_smccontext_getunfinishedjob");
		#else // _WIN32
		pWrapperTable->m_SMCContext_GetUnfinishedJob = (PLibMCDriver_ScanLabSMCSMCContext_GetUnfinishedJobPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_smccontext_getunfinishedjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SMCContext_GetUnfinishedJob == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_SetDLLResources = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_SetDLLResourcesPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_setdllresources");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_SetDLLResources = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_SetDLLResourcesPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_setdllresources");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLabSMC_SetDLLResources == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_SetXercesDLLResource = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_SetXercesDLLResourcePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_setxercesdllresource");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_SetXercesDLLResource = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_SetXercesDLLResourcePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_setxercesdllresource");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLabSMC_SetXercesDLLResource == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_SetCustomDLLData = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_SetCustomDLLDataPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_setcustomdlldata");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_SetCustomDLLData = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_SetCustomDLLDataPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_setcustomdlldata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLabSMC_SetCustomDLLData == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_SetCustomXercesDLLData = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_SetCustomXercesDLLDataPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_setcustomxercesdlldata");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_SetCustomXercesDLLData = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_SetCustomXercesDLLDataPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_setcustomxercesdlldata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLabSMC_SetCustomXercesDLLData == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_LoadSDK = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_LoadSDKPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_loadsdk");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_LoadSDK = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_LoadSDKPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_loadsdk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLabSMC_LoadSDK == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_CreateContext = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_CreateContextPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_createcontext");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_CreateContext = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_CreateContextPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_createcontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLabSMC_CreateContext == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_CreateEmptyConfiguration = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_CreateEmptyConfigurationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_createemptyconfiguration");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_CreateEmptyConfiguration = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_CreateEmptyConfigurationPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_createemptyconfiguration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLabSMC_CreateEmptyConfiguration == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_CreateTemplateConfiguration = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_CreateTemplateConfigurationPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_createtemplateconfiguration");
		#else // _WIN32
		pWrapperTable->m_Driver_ScanLabSMC_CreateTemplateConfiguration = (PLibMCDriver_ScanLabSMCDriver_ScanLabSMC_CreateTemplateConfigurationPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_driver_scanlabsmc_createtemplateconfiguration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_ScanLabSMC_CreateTemplateConfiguration == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabSMCGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_ScanLabSMCGetVersionPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabSMCGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_ScanLabSMCGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabSMCReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_ScanLabSMCReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabSMCAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_ScanLabSMCAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabSMCInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_ScanLabSMCInjectComponentPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabSMCGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_ScanLabSMCGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabSMCCreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_scanlabsmc_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_ScanLabSMCCreateDriverPtr) dlsym(hLibrary, "libmcdriver_scanlabsmc_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_SCANLABSMC_SUCCESS;
	}

	inline LibMCDriver_ScanLabSMCResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_ScanLabSMCDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_ScanLabSMCResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_ScanLabSMCResult eLookupError = LIBMCDRIVER_SCANLABSMC_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_queryparametersex", (void**)&(pWrapperTable->m_Driver_QueryParametersEx));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParametersEx == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_getjobid", (void**)&(pWrapperTable->m_SMCJob_GetJobID));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_GetJobID == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_finalize", (void**)&(pWrapperTable->m_SMCJob_Finalize));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_Finalize == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_isfinalized", (void**)&(pWrapperTable->m_SMCJob_IsFinalized));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_IsFinalized == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_drawpolyline", (void**)&(pWrapperTable->m_SMCJob_DrawPolyline));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_DrawPolyline == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_drawloop", (void**)&(pWrapperTable->m_SMCJob_DrawLoop));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_DrawLoop == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_drawhatches", (void**)&(pWrapperTable->m_SMCJob_DrawHatches));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_DrawHatches == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_isready", (void**)&(pWrapperTable->m_SMCJob_IsReady));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_IsReady == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_execute", (void**)&(pWrapperTable->m_SMCJob_Execute));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_Execute == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_isexecuting", (void**)&(pWrapperTable->m_SMCJob_IsExecuting));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_IsExecuting == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_waitforexecution", (void**)&(pWrapperTable->m_SMCJob_WaitForExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_WaitForExecution == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcjob_stopexecution", (void**)&(pWrapperTable->m_SMCJob_StopExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCJob_StopExecution == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcconfiguration_setdynamicviolationreaction", (void**)&(pWrapperTable->m_SMCConfiguration_SetDynamicViolationReaction));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCConfiguration_SetDynamicViolationReaction == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcconfiguration_getdynamicviolationreaction", (void**)&(pWrapperTable->m_SMCConfiguration_GetDynamicViolationReaction));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCConfiguration_GetDynamicViolationReaction == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcconfiguration_setwarnlevel", (void**)&(pWrapperTable->m_SMCConfiguration_SetWarnLevel));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCConfiguration_SetWarnLevel == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smcconfiguration_getwarnlevel", (void**)&(pWrapperTable->m_SMCConfiguration_GetWarnLevel));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCConfiguration_GetWarnLevel == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_settosimulationmode", (void**)&(pWrapperTable->m_SMCContext_SetToSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_SetToSimulationMode == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_issimulationmode", (void**)&(pWrapperTable->m_SMCContext_IsSimulationMode));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_IsSimulationMode == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_setfirmware", (void**)&(pWrapperTable->m_SMCContext_SetFirmware));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_SetFirmware == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_setcorrectionfile", (void**)&(pWrapperTable->m_SMCContext_SetCorrectionFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_SetCorrectionFile == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_reinitializeinstance", (void**)&(pWrapperTable->m_SMCContext_ReinitializeInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_ReinitializeInstance == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_getipaddress", (void**)&(pWrapperTable->m_SMCContext_GetIPAddress));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_GetIPAddress == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_getnetmask", (void**)&(pWrapperTable->m_SMCContext_GetNetmask));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_GetNetmask == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_getserialnumber", (void**)&(pWrapperTable->m_SMCContext_GetSerialNumber));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_GetSerialNumber == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_getlaserindex", (void**)&(pWrapperTable->m_SMCContext_GetLaserIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_GetLaserIndex == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_setlaserorigin", (void**)&(pWrapperTable->m_SMCContext_SetLaserOrigin));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_SetLaserOrigin == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_getlaserorigin", (void**)&(pWrapperTable->m_SMCContext_GetLaserOrigin));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_GetLaserOrigin == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_setlaserfield", (void**)&(pWrapperTable->m_SMCContext_SetLaserField));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_SetLaserField == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_resetlaserfield", (void**)&(pWrapperTable->m_SMCContext_ResetLaserField));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_ResetLaserField == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_getlaserfield", (void**)&(pWrapperTable->m_SMCContext_GetLaserField));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_GetLaserField == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_beginjob", (void**)&(pWrapperTable->m_SMCContext_BeginJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_BeginJob == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_smccontext_getunfinishedjob", (void**)&(pWrapperTable->m_SMCContext_GetUnfinishedJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_SMCContext_GetUnfinishedJob == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_scanlabsmc_setdllresources", (void**)&(pWrapperTable->m_Driver_ScanLabSMC_SetDLLResources));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLabSMC_SetDLLResources == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_scanlabsmc_setxercesdllresource", (void**)&(pWrapperTable->m_Driver_ScanLabSMC_SetXercesDLLResource));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLabSMC_SetXercesDLLResource == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_scanlabsmc_setcustomdlldata", (void**)&(pWrapperTable->m_Driver_ScanLabSMC_SetCustomDLLData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLabSMC_SetCustomDLLData == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_scanlabsmc_setcustomxercesdlldata", (void**)&(pWrapperTable->m_Driver_ScanLabSMC_SetCustomXercesDLLData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLabSMC_SetCustomXercesDLLData == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_scanlabsmc_loadsdk", (void**)&(pWrapperTable->m_Driver_ScanLabSMC_LoadSDK));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLabSMC_LoadSDK == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_scanlabsmc_createcontext", (void**)&(pWrapperTable->m_Driver_ScanLabSMC_CreateContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLabSMC_CreateContext == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_scanlabsmc_createemptyconfiguration", (void**)&(pWrapperTable->m_Driver_ScanLabSMC_CreateEmptyConfiguration));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLabSMC_CreateEmptyConfiguration == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_driver_scanlabsmc_createtemplateconfiguration", (void**)&(pWrapperTable->m_Driver_ScanLabSMC_CreateTemplateConfiguration));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_ScanLabSMC_CreateTemplateConfiguration == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_scanlabsmc_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_SCANLABSMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_SCANLABSMC_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_ScanLabSMC_uint32 bytesNeededName = 0;
		LibMCDriver_ScanLabSMC_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_ScanLabSMC_uint32 bytesNeededType = 0;
		LibMCDriver_ScanLabSMC_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_ScanLabSMC_uint32 & nMajor, LibMCDriver_ScanLabSMC_uint32 & nMinor, LibMCDriver_ScanLabSMC_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_ScanLabSMC_uint32 bytesNeededBuild = 0;
		LibMCDriver_ScanLabSMC_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::QueryParameters - Updates the driver parameters in the driver environment. Should only be called in the driver thread.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	* CDriver::QueryParametersEx - Updates the driver parameters in the driver environment. Might be called out of thread. Implementation MUST be able to handle parallel calls.
	* @param[in] pDriverUpdateInstance - Status update instance.
	*/
	void CDriver::QueryParametersEx(classParam<LibMCEnv::CDriverStatusUpdateSession> pDriverUpdateInstance)
	{
		LibMCEnvHandle hDriverUpdateInstance = pDriverUpdateInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParametersEx(m_pHandle, hDriverUpdateInstance));
	}
	
	/**
	 * Method definitions for class CSMCJob
	 */
	
	/**
	* CSMCJob::GetJobID - Returns the Job ID
	* @return Job ID.
	*/
	LibMCDriver_ScanLabSMC_uint64 CSMCJob::GetJobID()
	{
		LibMCDriver_ScanLabSMC_uint64 resultJobID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_GetJobID(m_pHandle, &resultJobID));
		
		return resultJobID;
	}
	
	/**
	* CSMCJob::Finalize - Finalizes the job definition.
	*/
	void CSMCJob::Finalize()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_Finalize(m_pHandle));
	}
	
	/**
	* CSMCJob::IsFinalized - Returns if job is finalized.
	* @return If flag returns false, new data can be written to the job.
	*/
	bool CSMCJob::IsFinalized()
	{
		bool resultFinalized = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_IsFinalized(m_pHandle, &resultFinalized));
		
		return resultFinalized;
	}
	
	/**
	* CSMCJob::DrawPolyline - Writes a polyline into the open list
	* @param[in] PointsBuffer - Points of polyline to draw.
	* @param[in] dMarkSpeed - Mark speed in mm/s
	* @param[in] dMinimalMarkSpeed - Minimal allowed mark speed in mm/s
	* @param[in] dJumpSpeed - Jump speed in mm/s
	* @param[in] dPower - Laser power in percent
	* @param[in] dCornerTolerance - Allowed position deviation on corners (in mm.)
	* @param[in] dZValue - Focus Z Value
	*/
	void CSMCJob::DrawPolyline(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLabSMC_double dMarkSpeed, const LibMCDriver_ScanLabSMC_double dMinimalMarkSpeed, const LibMCDriver_ScanLabSMC_double dJumpSpeed, const LibMCDriver_ScanLabSMC_double dPower, const LibMCDriver_ScanLabSMC_double dCornerTolerance, const LibMCDriver_ScanLabSMC_double dZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_DrawPolyline(m_pHandle, (LibMCDriver_ScanLabSMC_uint64)PointsBuffer.size(), PointsBuffer.data(), dMarkSpeed, dMinimalMarkSpeed, dJumpSpeed, dPower, dCornerTolerance, dZValue));
	}
	
	/**
	* CSMCJob::DrawLoop - Writes a loop into the open list
	* @param[in] PointsBuffer - Points of polyline to draw.
	* @param[in] dMarkSpeed - Mark speed in mm/s
	* @param[in] dMinimalMarkSpeed - Minimal allowed mark speed in mm/s
	* @param[in] dJumpSpeed - Jump speed in mm/s
	* @param[in] dPower - Laser power in percent
	* @param[in] dCornerTolerance - Allowed position deviation on corners (in mm.)
	* @param[in] dZValue - Focus Z Value
	*/
	void CSMCJob::DrawLoop(const CInputVector<sPoint2D> & PointsBuffer, const LibMCDriver_ScanLabSMC_double dMarkSpeed, const LibMCDriver_ScanLabSMC_double dMinimalMarkSpeed, const LibMCDriver_ScanLabSMC_double dJumpSpeed, const LibMCDriver_ScanLabSMC_double dPower, const LibMCDriver_ScanLabSMC_double dCornerTolerance, const LibMCDriver_ScanLabSMC_double dZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_DrawLoop(m_pHandle, (LibMCDriver_ScanLabSMC_uint64)PointsBuffer.size(), PointsBuffer.data(), dMarkSpeed, dMinimalMarkSpeed, dJumpSpeed, dPower, dCornerTolerance, dZValue));
	}
	
	/**
	* CSMCJob::DrawHatches - Writes a list of hatches into the open list
	* @param[in] HatchesBuffer - Hatches to draw.
	* @param[in] dMarkSpeed - Mark speed in mm/s
	* @param[in] dJumpSpeed - Jump speed in mm/s
	* @param[in] dPower - Laser power in percent
	* @param[in] dZValue - Focus Z Value
	*/
	void CSMCJob::DrawHatches(const CInputVector<sHatch2D> & HatchesBuffer, const LibMCDriver_ScanLabSMC_double dMarkSpeed, const LibMCDriver_ScanLabSMC_double dJumpSpeed, const LibMCDriver_ScanLabSMC_double dPower, const LibMCDriver_ScanLabSMC_double dZValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_DrawHatches(m_pHandle, (LibMCDriver_ScanLabSMC_uint64)HatchesBuffer.size(), HatchesBuffer.data(), dMarkSpeed, dJumpSpeed, dPower, dZValue));
	}
	
	/**
	* CSMCJob::IsReady - Returns if the scanner is ready for execution.
	* @return Returns true if the scanner is executing.
	*/
	bool CSMCJob::IsReady()
	{
		bool resultIsExecuting = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_IsReady(m_pHandle, &resultIsExecuting));
		
		return resultIsExecuting;
	}
	
	/**
	* CSMCJob::Execute - Starts the list execution. Will fail if the scanner is not ready or the job is not finalized.
	* @param[in] bBlocking - If true, the method waits until the execution is finished.
	*/
	void CSMCJob::Execute(const bool bBlocking)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_Execute(m_pHandle, bBlocking));
	}
	
	/**
	* CSMCJob::IsExecuting - Returns if the scanner is executing.
	* @return Returns true if the scanner is executing.
	*/
	bool CSMCJob::IsExecuting()
	{
		bool resultIsExecuting = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_IsExecuting(m_pHandle, &resultIsExecuting));
		
		return resultIsExecuting;
	}
	
	/**
	* CSMCJob::WaitForExecution - Waits until the execution is finished. Will fail if an error occured or the timeout is reached.
	* @param[in] nTimeOutInMilliseconds - Timeout for the execution.
	*/
	void CSMCJob::WaitForExecution(const LibMCDriver_ScanLabSMC_uint32 nTimeOutInMilliseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_WaitForExecution(m_pHandle, nTimeOutInMilliseconds));
	}
	
	/**
	* CSMCJob::StopExecution - Stops the execution of the current list immediately.
	*/
	void CSMCJob::StopExecution()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCJob_StopExecution(m_pHandle));
	}
	
	/**
	 * Method definitions for class CSMCConfiguration
	 */
	
	/**
	* CSMCConfiguration::SetDynamicViolationReaction - Sets the response to a dynamic violation. Default is WarningOnly.
	* @param[in] eValue - Value to set.
	*/
	void CSMCConfiguration::SetDynamicViolationReaction(const eDynamicViolationReaction eValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCConfiguration_SetDynamicViolationReaction(m_pHandle, eValue));
	}
	
	/**
	* CSMCConfiguration::GetDynamicViolationReaction - Returns the response to a dynamic violation.
	* @return Current Value.
	*/
	eDynamicViolationReaction CSMCConfiguration::GetDynamicViolationReaction()
	{
		eDynamicViolationReaction resultValue = (eDynamicViolationReaction) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCConfiguration_GetDynamicViolationReaction(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSMCConfiguration::SetWarnLevel - Sets the log warning level.
	* @param[in] eValue - Value to set.
	*/
	void CSMCConfiguration::SetWarnLevel(const eWarnLevel eValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCConfiguration_SetWarnLevel(m_pHandle, eValue));
	}
	
	/**
	* CSMCConfiguration::GetWarnLevel - Returns the log warning level.
	* @return Current Value.
	*/
	eWarnLevel CSMCConfiguration::GetWarnLevel()
	{
		eWarnLevel resultValue = (eWarnLevel) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCConfiguration_GetWarnLevel(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	 * Method definitions for class CSMCContext
	 */
	
	/**
	* CSMCContext::SetToSimulationMode - Turns the driver into a simulation mode.
	*/
	void CSMCContext::SetToSimulationMode()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_SetToSimulationMode(m_pHandle));
	}
	
	/**
	* CSMCContext::IsSimulationMode - Returns if the driver is in simulation mode.
	* @return Flag if driver is in simulation mode.
	*/
	bool CSMCContext::IsSimulationMode()
	{
		bool resultSimulationModeEnabled = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_IsSimulationMode(m_pHandle, &resultSimulationModeEnabled));
		
		return resultSimulationModeEnabled;
	}
	
	/**
	* CSMCContext::SetFirmware - Sets card firmware from binary data.
	* @param[in] FirmwareDataBuffer - byte array of the firmware program file.
	* @param[in] FPGADataBuffer - byte array of the firmware FPGA file.
	* @param[in] AuxiliaryDataBuffer - byte array of the binary auxiliary file.
	*/
	void CSMCContext::SetFirmware(const CInputVector<LibMCDriver_ScanLabSMC_uint8> & FirmwareDataBuffer, const CInputVector<LibMCDriver_ScanLabSMC_uint8> & FPGADataBuffer, const CInputVector<LibMCDriver_ScanLabSMC_uint8> & AuxiliaryDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_SetFirmware(m_pHandle, (LibMCDriver_ScanLabSMC_uint64)FirmwareDataBuffer.size(), FirmwareDataBuffer.data(), (LibMCDriver_ScanLabSMC_uint64)FPGADataBuffer.size(), FPGADataBuffer.data(), (LibMCDriver_ScanLabSMC_uint64)AuxiliaryDataBuffer.size(), AuxiliaryDataBuffer.data()));
	}
	
	/**
	* CSMCContext::SetCorrectionFile - Sets correction file as binary data.
	* @param[in] CorrectionFileDataBuffer - byte array of the firmware program file.
	*/
	void CSMCContext::SetCorrectionFile(const CInputVector<LibMCDriver_ScanLabSMC_uint8> & CorrectionFileDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_SetCorrectionFile(m_pHandle, (LibMCDriver_ScanLabSMC_uint64)CorrectionFileDataBuffer.size(), CorrectionFileDataBuffer.data()));
	}
	
	/**
	* CSMCContext::ReinitializeInstance - Reinitializes an instance of SCANmotionControl. All created jobs will become invalid.
	*/
	void CSMCContext::ReinitializeInstance()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_ReinitializeInstance(m_pHandle));
	}
	
	/**
	* CSMCContext::GetIPAddress - Returns the IP Address of the RTC Card. Fails if driver has not been initialized.
	* @return IP Address Value.
	*/
	std::string CSMCContext::GetIPAddress()
	{
		LibMCDriver_ScanLabSMC_uint32 bytesNeededIPAddress = 0;
		LibMCDriver_ScanLabSMC_uint32 bytesWrittenIPAddress = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_GetIPAddress(m_pHandle, 0, &bytesNeededIPAddress, nullptr));
		std::vector<char> bufferIPAddress(bytesNeededIPAddress);
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_GetIPAddress(m_pHandle, bytesNeededIPAddress, &bytesWrittenIPAddress, &bufferIPAddress[0]));
		
		return std::string(&bufferIPAddress[0]);
	}
	
	/**
	* CSMCContext::GetNetmask - Returns the Netmask of the RTC Card. Fails if driver has not been initialized.
	* @return Netmask Value.
	*/
	std::string CSMCContext::GetNetmask()
	{
		LibMCDriver_ScanLabSMC_uint32 bytesNeededNetmask = 0;
		LibMCDriver_ScanLabSMC_uint32 bytesWrittenNetmask = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_GetNetmask(m_pHandle, 0, &bytesNeededNetmask, nullptr));
		std::vector<char> bufferNetmask(bytesNeededNetmask);
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_GetNetmask(m_pHandle, bytesNeededNetmask, &bytesWrittenNetmask, &bufferNetmask[0]));
		
		return std::string(&bufferNetmask[0]);
	}
	
	/**
	* CSMCContext::GetSerialNumber - Returns serial number of card
	* @return Returns serial number of board.
	*/
	LibMCDriver_ScanLabSMC_uint32 CSMCContext::GetSerialNumber()
	{
		LibMCDriver_ScanLabSMC_uint32 resultSerialNumber = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_GetSerialNumber(m_pHandle, &resultSerialNumber));
		
		return resultSerialNumber;
	}
	
	/**
	* CSMCContext::GetLaserIndex - Returns the laser index assigned to the card. This is the laser index that will be used to map the toolpath laser data to the according device.
	* @return Returns laser index of board.
	*/
	LibMCDriver_ScanLabSMC_uint32 CSMCContext::GetLaserIndex()
	{
		LibMCDriver_ScanLabSMC_uint32 resultLaserIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_GetLaserIndex(m_pHandle, &resultLaserIndex));
		
		return resultLaserIndex;
	}
	
	/**
	* CSMCContext::SetLaserOrigin - Sets the laser origin in absolute coordinates. This origin will be used to relatively position lasers to one another.
	* @param[in] dOriginX - Sets laser origin X coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
	* @param[in] dOriginY - Sets laser origin Y coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
	*/
	void CSMCContext::SetLaserOrigin(const LibMCDriver_ScanLabSMC_double dOriginX, const LibMCDriver_ScanLabSMC_double dOriginY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_SetLaserOrigin(m_pHandle, dOriginX, dOriginY));
	}
	
	/**
	* CSMCContext::GetLaserOrigin - Returns the laser origin in absolute coordinates. This origin will be used to relatively position lasers to one another.
	* @param[out] dOriginX - Laser origin X coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
	* @param[out] dOriginY - Laser origin Y coordinate of the laser in mm. All laser movements will be moved by that minus that amount in X.
	*/
	void CSMCContext::GetLaserOrigin(LibMCDriver_ScanLabSMC_double & dOriginX, LibMCDriver_ScanLabSMC_double & dOriginY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_GetLaserOrigin(m_pHandle, &dOriginX, &dOriginY));
	}
	
	/**
	* CSMCContext::SetLaserField - Sets the laser field limits in absolute coordinates.
	* @param[in] dMinX - Sets minimum laser X coordinate in mm.
	* @param[in] dMinY - Sets minimum laser Y coordinate in mm.
	* @param[in] dMaxX - Sets maximum laser X coordinate in mm.
	* @param[in] dMaxY - Sets maximum laser Y coordinate in mm.
	*/
	void CSMCContext::SetLaserField(const LibMCDriver_ScanLabSMC_double dMinX, const LibMCDriver_ScanLabSMC_double dMinY, const LibMCDriver_ScanLabSMC_double dMaxX, const LibMCDriver_ScanLabSMC_double dMaxY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_SetLaserField(m_pHandle, dMinX, dMinY, dMaxX, dMaxY));
	}
	
	/**
	* CSMCContext::ResetLaserField - Resets the laser field to default values.
	*/
	void CSMCContext::ResetLaserField()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_ResetLaserField(m_pHandle));
	}
	
	/**
	* CSMCContext::GetLaserField - Returns the laser field limits in absolute coordinates.
	* @param[out] dMinX - Sets minimum laser X coordinate in mm.
	* @param[out] dMinY - Sets minimum laser Y coordinate in mm.
	* @param[out] dMaxX - Sets maximum laser X coordinate in mm.
	* @param[out] dMaxY - Sets maximum laser Y coordinate in mm.
	* @return Returns true if a laser field has been set.
	*/
	bool CSMCContext::GetLaserField(LibMCDriver_ScanLabSMC_double & dMinX, LibMCDriver_ScanLabSMC_double & dMinY, LibMCDriver_ScanLabSMC_double & dMaxX, LibMCDriver_ScanLabSMC_double & dMaxY)
	{
		bool resultHasLaserField = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_GetLaserField(m_pHandle, &dMinX, &dMinY, &dMaxX, &dMaxY, &resultHasLaserField));
		
		return resultHasLaserField;
	}
	
	/**
	* CSMCContext::BeginJob - Starts a new job definition. Fails if another job is not finalized yet.
	* @param[in] dStartPositionX - Start position in X.
	* @param[in] dStartPositionY - Start position in Y.
	* @param[in] eBlendMode - Blend Mode that the job shall be drawn in.
	* @return SMC Job Instance.
	*/
	PSMCJob CSMCContext::BeginJob(const LibMCDriver_ScanLabSMC_double dStartPositionX, const LibMCDriver_ScanLabSMC_double dStartPositionY, const eBlendMode eBlendMode)
	{
		LibMCDriver_ScanLabSMCHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_BeginJob(m_pHandle, dStartPositionX, dStartPositionY, eBlendMode, &hJobInstance));
		
		if (!hJobInstance) {
			CheckError(LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSMCJob>(m_pWrapper, hJobInstance);
	}
	
	/**
	* CSMCContext::GetUnfinishedJob - Returns the job that is not finalized yet. Returns null if no job is active.
	* @return SMC Job Instance.
	*/
	PSMCJob CSMCContext::GetUnfinishedJob()
	{
		LibMCDriver_ScanLabSMCHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SMCContext_GetUnfinishedJob(m_pHandle, &hJobInstance));
		
		if (hJobInstance) {
			return std::make_shared<CSMCJob>(m_pWrapper, hJobInstance);
		} else {
			return nullptr;
		}
	}
	
	/**
	 * Method definitions for class CDriver_ScanLabSMC
	 */
	
	/**
	* CDriver_ScanLabSMC::SetDLLResources - Sets the default resource name of the SCANLAB DLLs. Overrides custom resource data if set before.
	* @param[in] sSMCDLLResourceName - Resource name of SCANmotionControl DLL
	* @param[in] sRTCDLLResourceName - Resource name of RTC DLL
	*/
	void CDriver_ScanLabSMC::SetDLLResources(const std::string & sSMCDLLResourceName, const std::string & sRTCDLLResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLabSMC_SetDLLResources(m_pHandle, sSMCDLLResourceName.c_str(), sRTCDLLResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLabSMC::SetXercesDLLResource - Sets the default resource name of auxiliary resource DLLs. Overrides custom resource data if set before.
	* @param[in] sXercesDLLResourceName - Resource name of the Xerces dependency DLL
	*/
	void CDriver_ScanLabSMC::SetXercesDLLResource(const std::string & sXercesDLLResourceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLabSMC_SetXercesDLLResource(m_pHandle, sXercesDLLResourceName.c_str()));
	}
	
	/**
	* CDriver_ScanLabSMC::SetCustomDLLData - Sets custom binaries for the needed SCANLAB DLLs. Overrides custom resource data if set before.
	* @param[in] SMCDLLResourceDataBuffer - Resource data of SCANmotionControl DLL
	* @param[in] RTCDLLResourceDataBuffer - Resource data of RTC DLL
	*/
	void CDriver_ScanLabSMC::SetCustomDLLData(const CInputVector<LibMCDriver_ScanLabSMC_uint8> & SMCDLLResourceDataBuffer, const CInputVector<LibMCDriver_ScanLabSMC_uint8> & RTCDLLResourceDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLabSMC_SetCustomDLLData(m_pHandle, (LibMCDriver_ScanLabSMC_uint64)SMCDLLResourceDataBuffer.size(), SMCDLLResourceDataBuffer.data(), (LibMCDriver_ScanLabSMC_uint64)RTCDLLResourceDataBuffer.size(), RTCDLLResourceDataBuffer.data()));
	}
	
	/**
	* CDriver_ScanLabSMC::SetCustomXercesDLLData - Sets the custom binary for auxiliary resource DLLs. Overrides custom resource data if set before.
	* @param[in] XercesDLLResourceDataBuffer - Resource data of the Xerces dependency DLL
	*/
	void CDriver_ScanLabSMC::SetCustomXercesDLLData(const CInputVector<LibMCDriver_ScanLabSMC_uint8> & XercesDLLResourceDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLabSMC_SetCustomXercesDLLData(m_pHandle, (LibMCDriver_ScanLabSMC_uint64)XercesDLLResourceDataBuffer.size(), XercesDLLResourceDataBuffer.data()));
	}
	
	/**
	* CDriver_ScanLabSMC::LoadSDK - Initializes the SCANmotionControl SDK.
	*/
	void CDriver_ScanLabSMC::LoadSDK()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLabSMC_LoadSDK(m_pHandle));
	}
	
	/**
	* CDriver_ScanLabSMC::CreateContext - Creates and initializes a new SMC context. Fails if Configuration Data is invalid.
	* @param[in] pSMCConfiguration - SMC Configuration Data.
	* @return New Context instance
	*/
	PSMCContext CDriver_ScanLabSMC::CreateContext(classParam<CSMCConfiguration> pSMCConfiguration)
	{
		LibMCDriver_ScanLabSMCHandle hSMCConfiguration = pSMCConfiguration.GetHandle();
		LibMCDriver_ScanLabSMCHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLabSMC_CreateContext(m_pHandle, hSMCConfiguration, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSMCContext>(m_pWrapper, hInstance);
	}
	
	/**
	* CDriver_ScanLabSMC::CreateEmptyConfiguration - Creates and initializes a SMC configuration with default values.
	* @return New Configuration instance
	*/
	PSMCConfiguration CDriver_ScanLabSMC::CreateEmptyConfiguration()
	{
		LibMCDriver_ScanLabSMCHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLabSMC_CreateEmptyConfiguration(m_pHandle, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSMCConfiguration>(m_pWrapper, hInstance);
	}
	
	/**
	* CDriver_ScanLabSMC::CreateTemplateConfiguration - Creates and initializes a SMC configuration with templated values.
	* @param[in] sTemplateName - Name of SMC Template.
	* @return New Configuration instance
	*/
	PSMCConfiguration CDriver_ScanLabSMC::CreateTemplateConfiguration(const std::string & sTemplateName)
	{
		LibMCDriver_ScanLabSMCHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_ScanLabSMC_CreateTemplateConfiguration(m_pHandle, sTemplateName.c_str(), &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCDRIVER_SCANLABSMC_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSMCConfiguration>(m_pWrapper, hInstance);
	}

} // namespace LibMCDriver_ScanLabSMC

#endif // __LIBMCDRIVER_SCANLABSMC_CPPHEADER_DYNAMIC_CPP

