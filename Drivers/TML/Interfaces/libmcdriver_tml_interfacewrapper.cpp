/*++

Copyright (C) 2024 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of MC Driver Technosoft Motion Library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 2.0.0

*/

#include "libmcdriver_tml_abi.hpp"
#include "libmcdriver_tml_interfaces.hpp"
#include "libmcdriver_tml_interfaceexception.hpp"

#include <map>

using namespace LibMCDriver_TML::Impl;

LibMCDriver_TMLResult handleLibMCDriver_TMLException(IBase * pIBaseClass, ELibMCDriver_TMLInterfaceException & Exception)
{
	LibMCDriver_TMLResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_TMLResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDriver_TMLResult errorCode = LIBMCDRIVER_TML_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_TMLResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDriver_TMLResult errorCode = LIBMCDRIVER_TML_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Driver
**************************************************************************************************************************/
LibMCDriver_TMLResult libmcdriver_tml_driver_configure(LibMCDriver_TML_Driver pDriver, const char * pConfigurationString)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (pConfigurationString == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sConfigurationString(pConfigurationString);
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pIDriver->Configure(sConfigurationString);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_getname(LibMCDriver_TML_Driver pDriver, const LibMCDriver_TML_uint32 nNameBufferSize, LibMCDriver_TML_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIDriver->GetName();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCDriver_TML_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_gettype(LibMCDriver_TML_Driver pDriver, const LibMCDriver_TML_uint32 nTypeBufferSize, LibMCDriver_TML_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sType("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIDriver->GetType();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIDriver->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (LibMCDriver_TML_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_getversion(LibMCDriver_TML_Driver pDriver, LibMCDriver_TML_uint32 * pMajor, LibMCDriver_TML_uint32 * pMinor, LibMCDriver_TML_uint32 * pMicro, const LibMCDriver_TML_uint32 nBuildBufferSize, LibMCDriver_TML_uint32* pBuildNeededChars, char * pBuildBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (!pMajor)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if ( (!pBuildBuffer) && !(pBuildNeededChars) )
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sBuild("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetVersion(*pMajor, *pMinor, *pMicro, sBuild);

			pIDriver->_setCache (new ParameterCache_4<LibMCDriver_TML_uint32, LibMCDriver_TML_uint32, LibMCDriver_TML_uint32, std::string> (*pMajor, *pMinor, *pMicro, sBuild));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<LibMCDriver_TML_uint32, LibMCDriver_TML_uint32, LibMCDriver_TML_uint32, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
			cache->retrieveData (*pMajor, *pMinor, *pMicro, sBuild);
			pIDriver->_setCache (nullptr);
		}
		
		if (pBuildNeededChars)
			*pBuildNeededChars = (LibMCDriver_TML_uint32) (sBuild.size()+1);
		if (pBuildBuffer) {
			if (sBuild.size() >= nBuildBufferSize)
				throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_BUFFERTOOSMALL);
			for (size_t iBuild = 0; iBuild < sBuild.size(); iBuild++)
				pBuildBuffer[iBuild] = sBuild[iBuild];
			pBuildBuffer[sBuild.size()] = 0;
		}
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_queryparameters(LibMCDriver_TML_Driver pDriver)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pIDriver->QueryParameters();

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_queryparametersex(LibMCDriver_TML_Driver pDriver, LibMCEnv_DriverStatusUpdateSession pDriverUpdateInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		LibMCEnv::PDriverStatusUpdateSession pIDriverUpdateInstance = std::make_shared<LibMCEnv::CDriverStatusUpdateSession>(CWrapper::sPLibMCEnvWrapper.get(), pDriverUpdateInstance);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverUpdateInstance.get());
		if (!pIDriverUpdateInstance)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pIDriver->QueryParametersEx(pIDriverUpdateInstance);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Axis
**************************************************************************************************************************/
LibMCDriver_TMLResult libmcdriver_tml_axis_moverelative(LibMCDriver_TML_Axis pAxis, LibMCDriver_TML_double dDistance, LibMCDriver_TML_double dSpeed, LibMCDriver_TML_double dAcceleration)
{
	IBase* pIBaseClass = (IBase *)pAxis;

	try {
		IAxis* pIAxis = dynamic_cast<IAxis*>(pIBaseClass);
		if (!pIAxis)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pIAxis->MoveRelative(dDistance, dSpeed, dAcceleration);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_axis_getidentifier(LibMCDriver_TML_Axis pAxis, const LibMCDriver_TML_uint32 nIdentifierBufferSize, LibMCDriver_TML_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pAxis;

	try {
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		IAxis* pIAxis = dynamic_cast<IAxis*>(pIBaseClass);
		if (!pIAxis)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pIAxis->GetIdentifier();

			pIAxis->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAxis->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pIAxis->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (LibMCDriver_TML_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_axis_getchannelidentifier(LibMCDriver_TML_Axis pAxis, const LibMCDriver_TML_uint32 nIdentifierBufferSize, LibMCDriver_TML_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pAxis;

	try {
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		IAxis* pIAxis = dynamic_cast<IAxis*>(pIBaseClass);
		if (!pIAxis)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pIAxis->GetChannelIdentifier();

			pIAxis->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAxis->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pIAxis->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (LibMCDriver_TML_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_axis_setpower(LibMCDriver_TML_Axis pAxis, bool bEnable)
{
	IBase* pIBaseClass = (IBase *)pAxis;

	try {
		IAxis* pIAxis = dynamic_cast<IAxis*>(pIBaseClass);
		if (!pIAxis)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pIAxis->SetPower(bEnable);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_axis_readregister(LibMCDriver_TML_Axis pAxis, LibMCDriver_TML_uint32 nRegister, LibMCDriver_TML_uint32 * pData)
{
	IBase* pIBaseClass = (IBase *)pAxis;

	try {
		if (pData == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		IAxis* pIAxis = dynamic_cast<IAxis*>(pIBaseClass);
		if (!pIAxis)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		*pData = pIAxis->ReadRegister(nRegister);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_axis_checkpower(LibMCDriver_TML_Axis pAxis, bool * pData)
{
	IBase* pIBaseClass = (IBase *)pAxis;

	try {
		if (pData == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		IAxis* pIAxis = dynamic_cast<IAxis*>(pIBaseClass);
		if (!pIAxis)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		*pData = pIAxis->CheckPower();

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Channel
**************************************************************************************************************************/
LibMCDriver_TMLResult libmcdriver_tml_channel_getidentifier(LibMCDriver_TML_Channel pChannel, const LibMCDriver_TML_uint32 nIdentifierBufferSize, LibMCDriver_TML_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pChannel;

	try {
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		IChannel* pIChannel = dynamic_cast<IChannel*>(pIBaseClass);
		if (!pIChannel)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pIChannel->GetIdentifier();

			pIChannel->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIChannel->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pIChannel->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (LibMCDriver_TML_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_channel_setupaxis(LibMCDriver_TML_Channel pChannel, const char * pIdentifier, LibMCDriver_TML_uint32 nAxisID, LibMCDriver_TML_uint64 nConfigurationBufferSize, const LibMCDriver_TML_uint8 * pConfigurationBuffer, LibMCDriver_TML_uint32 nCountsPerMM, LibMCDriver_TML_Axis * pAxisInstance)
{
	IBase* pIBaseClass = (IBase *)pChannel;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if ( (!pConfigurationBuffer) && (nConfigurationBufferSize>0))
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pAxisInstance == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseAxisInstance(nullptr);
		IChannel* pIChannel = dynamic_cast<IChannel*>(pIBaseClass);
		if (!pIChannel)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pBaseAxisInstance = pIChannel->SetupAxis(sIdentifier, nAxisID, nConfigurationBufferSize, pConfigurationBuffer, nCountsPerMM);

		*pAxisInstance = (IBase*)(pBaseAxisInstance);
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_channel_findaxis(LibMCDriver_TML_Channel pChannel, const char * pIdentifier, LibMCDriver_TML_Axis * pAxisInstance)
{
	IBase* pIBaseClass = (IBase *)pChannel;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pAxisInstance == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseAxisInstance(nullptr);
		IChannel* pIChannel = dynamic_cast<IChannel*>(pIBaseClass);
		if (!pIChannel)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pBaseAxisInstance = pIChannel->FindAxis(sIdentifier);

		*pAxisInstance = (IBase*)(pBaseAxisInstance);
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_channel_axisexists(LibMCDriver_TML_Channel pChannel, const char * pIdentifier, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pChannel;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IChannel* pIChannel = dynamic_cast<IChannel*>(pIBaseClass);
		if (!pIChannel)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		*pValue = pIChannel->AxisExists(sIdentifier);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_channel_close(LibMCDriver_TML_Channel pChannel)
{
	IBase* pIBaseClass = (IBase *)pChannel;

	try {
		IChannel* pIChannel = dynamic_cast<IChannel*>(pIBaseClass);
		if (!pIChannel)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pIChannel->Close();

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Driver_TML
**************************************************************************************************************************/
LibMCDriver_TMLResult libmcdriver_tml_driver_tml_settosimulationmode(LibMCDriver_TML_Driver_TML pDriver_TML)
{
	IBase* pIBaseClass = (IBase *)pDriver_TML;

	try {
		IDriver_TML* pIDriver_TML = dynamic_cast<IDriver_TML*>(pIBaseClass);
		if (!pIDriver_TML)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pIDriver_TML->SetToSimulationMode();

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_tml_issimulationmode(LibMCDriver_TML_Driver_TML pDriver_TML, bool * pSimulationModeEnabled)
{
	IBase* pIBaseClass = (IBase *)pDriver_TML;

	try {
		if (pSimulationModeEnabled == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		IDriver_TML* pIDriver_TML = dynamic_cast<IDriver_TML*>(pIBaseClass);
		if (!pIDriver_TML)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		*pSimulationModeEnabled = pIDriver_TML->IsSimulationMode();

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_tml_setcustomsdkresource(LibMCDriver_TML_Driver_TML pDriver_TML, const char * pLibResourceName, const char * pCommsResourceName)
{
	IBase* pIBaseClass = (IBase *)pDriver_TML;

	try {
		if (pLibResourceName == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pCommsResourceName == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sLibResourceName(pLibResourceName);
		std::string sCommsResourceName(pCommsResourceName);
		IDriver_TML* pIDriver_TML = dynamic_cast<IDriver_TML*>(pIBaseClass);
		if (!pIDriver_TML)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pIDriver_TML->SetCustomSDKResource(sLibResourceName, sCommsResourceName);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_tml_openchannel(LibMCDriver_TML_Driver_TML pDriver_TML, const char * pIdentifier, const char * pDeviceName, eLibMCDriver_TMLChannelType eChannelTypeToUse, eLibMCDriver_TMLProtocolType eProtocolTypeToUse, LibMCDriver_TML_uint32 nHostID, LibMCDriver_TML_uint32 nBaudrate, LibMCDriver_TML_Channel * pChannelInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_TML;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pDeviceName == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pChannelInstance == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		std::string sDeviceName(pDeviceName);
		IBase* pBaseChannelInstance(nullptr);
		IDriver_TML* pIDriver_TML = dynamic_cast<IDriver_TML*>(pIBaseClass);
		if (!pIDriver_TML)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pBaseChannelInstance = pIDriver_TML->OpenChannel(sIdentifier, sDeviceName, eChannelTypeToUse, eProtocolTypeToUse, nHostID, nBaudrate);

		*pChannelInstance = (IBase*)(pBaseChannelInstance);
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_tml_channelexists(LibMCDriver_TML_Driver_TML pDriver_TML, const char * pIdentifier, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_TML;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriver_TML* pIDriver_TML = dynamic_cast<IDriver_TML*>(pIBaseClass);
		if (!pIDriver_TML)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_TML->ChannelExists(sIdentifier);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_driver_tml_findchannel(LibMCDriver_TML_Driver_TML pDriver_TML, const char * pIdentifier, LibMCDriver_TML_Channel * pChannelInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_TML;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pChannelInstance == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseChannelInstance(nullptr);
		IDriver_TML* pIDriver_TML = dynamic_cast<IDriver_TML*>(pIBaseClass);
		if (!pIDriver_TML)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		pBaseChannelInstance = pIDriver_TML->FindChannel(sIdentifier);

		*pChannelInstance = (IBase*)(pBaseChannelInstance);
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDriver_TMLResult LibMCDriver_TML::Impl::LibMCDriver_TML_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDRIVER_TML_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDRIVER_TML_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdriver_tml_driver_configure") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_configure;
	if (sProcName == "libmcdriver_tml_driver_getname") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_getname;
	if (sProcName == "libmcdriver_tml_driver_gettype") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_gettype;
	if (sProcName == "libmcdriver_tml_driver_getversion") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_getversion;
	if (sProcName == "libmcdriver_tml_driver_queryparameters") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_queryparameters;
	if (sProcName == "libmcdriver_tml_driver_queryparametersex") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_queryparametersex;
	if (sProcName == "libmcdriver_tml_axis_moverelative") 
		*ppProcAddress = (void*) &libmcdriver_tml_axis_moverelative;
	if (sProcName == "libmcdriver_tml_axis_getidentifier") 
		*ppProcAddress = (void*) &libmcdriver_tml_axis_getidentifier;
	if (sProcName == "libmcdriver_tml_axis_getchannelidentifier") 
		*ppProcAddress = (void*) &libmcdriver_tml_axis_getchannelidentifier;
	if (sProcName == "libmcdriver_tml_axis_setpower") 
		*ppProcAddress = (void*) &libmcdriver_tml_axis_setpower;
	if (sProcName == "libmcdriver_tml_axis_readregister") 
		*ppProcAddress = (void*) &libmcdriver_tml_axis_readregister;
	if (sProcName == "libmcdriver_tml_axis_checkpower") 
		*ppProcAddress = (void*) &libmcdriver_tml_axis_checkpower;
	if (sProcName == "libmcdriver_tml_channel_getidentifier") 
		*ppProcAddress = (void*) &libmcdriver_tml_channel_getidentifier;
	if (sProcName == "libmcdriver_tml_channel_setupaxis") 
		*ppProcAddress = (void*) &libmcdriver_tml_channel_setupaxis;
	if (sProcName == "libmcdriver_tml_channel_findaxis") 
		*ppProcAddress = (void*) &libmcdriver_tml_channel_findaxis;
	if (sProcName == "libmcdriver_tml_channel_axisexists") 
		*ppProcAddress = (void*) &libmcdriver_tml_channel_axisexists;
	if (sProcName == "libmcdriver_tml_channel_close") 
		*ppProcAddress = (void*) &libmcdriver_tml_channel_close;
	if (sProcName == "libmcdriver_tml_driver_tml_settosimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_tml_settosimulationmode;
	if (sProcName == "libmcdriver_tml_driver_tml_issimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_tml_issimulationmode;
	if (sProcName == "libmcdriver_tml_driver_tml_setcustomsdkresource") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_tml_setcustomsdkresource;
	if (sProcName == "libmcdriver_tml_driver_tml_openchannel") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_tml_openchannel;
	if (sProcName == "libmcdriver_tml_driver_tml_channelexists") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_tml_channelexists;
	if (sProcName == "libmcdriver_tml_driver_tml_findchannel") 
		*ppProcAddress = (void*) &libmcdriver_tml_driver_tml_findchannel;
	if (sProcName == "libmcdriver_tml_getversion") 
		*ppProcAddress = (void*) &libmcdriver_tml_getversion;
	if (sProcName == "libmcdriver_tml_getlasterror") 
		*ppProcAddress = (void*) &libmcdriver_tml_getlasterror;
	if (sProcName == "libmcdriver_tml_releaseinstance") 
		*ppProcAddress = (void*) &libmcdriver_tml_releaseinstance;
	if (sProcName == "libmcdriver_tml_acquireinstance") 
		*ppProcAddress = (void*) &libmcdriver_tml_acquireinstance;
	if (sProcName == "libmcdriver_tml_injectcomponent") 
		*ppProcAddress = (void*) &libmcdriver_tml_injectcomponent;
	if (sProcName == "libmcdriver_tml_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdriver_tml_getsymbollookupmethod;
	if (sProcName == "libmcdriver_tml_createdriver") 
		*ppProcAddress = (void*) &libmcdriver_tml_createdriver;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDRIVER_TML_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDRIVER_TML_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDriver_TMLResult libmcdriver_tml_getversion(LibMCDriver_TML_uint32 * pMajor, LibMCDriver_TML_uint32 * pMinor, LibMCDriver_TML_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_getlasterror(LibMCDriver_TML_Base pInstance, const LibMCDriver_TML_uint32 nErrorMessageBufferSize, LibMCDriver_TML_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCDriver_TML_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_releaseinstance(LibMCDriver_TML_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_acquireinstance(LibMCDriver_TML_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_injectcomponent(const char * pNameSpace, LibMCDriver_TML_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCEnv") {
			if (CWrapper::sPLibMCEnvWrapper.get() != nullptr) {
				throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCDriver_TMLInterfaceException(LIBMCDRIVER_TML_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_getsymbollookupmethod(LibMCDriver_TML_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCDriver_TML::Impl::LibMCDriver_TML_GetProcAddress;
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_TMLResult libmcdriver_tml_createdriver(const char * pName, const char * pType, LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCDriver_TML_Driver * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pType == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		if (pInstance == nullptr)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sType(pType);
		LibMCEnv::PDriverEnvironment pIDriverEnvironment = std::make_shared<LibMCEnv::CDriverEnvironment>(CWrapper::sPLibMCEnvWrapper.get(), pDriverEnvironment);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverEnvironment.get());
		if (!pIDriverEnvironment)
			throw ELibMCDriver_TMLInterfaceException (LIBMCDRIVER_TML_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDriver(sName, sType, pIDriverEnvironment);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_TML_SUCCESS;
	}
	catch (ELibMCDriver_TMLInterfaceException & Exception) {
		return handleLibMCDriver_TMLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


