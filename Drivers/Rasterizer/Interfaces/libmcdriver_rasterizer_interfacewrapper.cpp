/*++

Copyright (C) 2022 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Generic Rasterizer Driver. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmcdriver_rasterizer_abi.hpp"
#include "libmcdriver_rasterizer_interfaces.hpp"
#include "libmcdriver_rasterizer_interfaceexception.hpp"

#include <map>

using namespace LibMCDriver_Rasterizer::Impl;

LibMCDriver_RasterizerResult handleLibMCDriver_RasterizerException(IBase * pIBaseClass, ELibMCDriver_RasterizerInterfaceException & Exception)
{
	LibMCDriver_RasterizerResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_RasterizerResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDriver_RasterizerResult errorCode = LIBMCDRIVER_RASTERIZER_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_RasterizerResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDriver_RasterizerResult errorCode = LIBMCDRIVER_RASTERIZER_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Driver
**************************************************************************************************************************/
LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_configure(LibMCDriver_Rasterizer_Driver pDriver, const char * pConfigurationString)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (pConfigurationString == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sConfigurationString(pConfigurationString);
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIDriver->Configure(sConfigurationString);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_getname(LibMCDriver_Rasterizer_Driver pDriver, const LibMCDriver_Rasterizer_uint32 nNameBufferSize, LibMCDriver_Rasterizer_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIDriver->GetName();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCDriver_Rasterizer_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_gettype(LibMCDriver_Rasterizer_Driver pDriver, const LibMCDriver_Rasterizer_uint32 nTypeBufferSize, LibMCDriver_Rasterizer_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sType("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIDriver->GetType();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIDriver->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (LibMCDriver_Rasterizer_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_getversion(LibMCDriver_Rasterizer_Driver pDriver, LibMCDriver_Rasterizer_uint32 * pMajor, LibMCDriver_Rasterizer_uint32 * pMinor, LibMCDriver_Rasterizer_uint32 * pMicro, const LibMCDriver_Rasterizer_uint32 nBuildBufferSize, LibMCDriver_Rasterizer_uint32* pBuildNeededChars, char * pBuildBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (!pMajor)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if ( (!pBuildBuffer) && !(pBuildNeededChars) )
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sBuild("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetVersion(*pMajor, *pMinor, *pMicro, sBuild);

			pIDriver->_setCache (new ParameterCache_4<LibMCDriver_Rasterizer_uint32, LibMCDriver_Rasterizer_uint32, LibMCDriver_Rasterizer_uint32, std::string> (*pMajor, *pMinor, *pMicro, sBuild));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<LibMCDriver_Rasterizer_uint32, LibMCDriver_Rasterizer_uint32, LibMCDriver_Rasterizer_uint32, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
			cache->retrieveData (*pMajor, *pMinor, *pMicro, sBuild);
			pIDriver->_setCache (nullptr);
		}
		
		if (pBuildNeededChars)
			*pBuildNeededChars = (LibMCDriver_Rasterizer_uint32) (sBuild.size()+1);
		if (pBuildBuffer) {
			if (sBuild.size() >= nBuildBufferSize)
				throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_BUFFERTOOSMALL);
			for (size_t iBuild = 0; iBuild < sBuild.size(); iBuild++)
				pBuildBuffer[iBuild] = sBuild[iBuild];
			pBuildBuffer[sBuild.size()] = 0;
		}
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_getheaderinformation(LibMCDriver_Rasterizer_Driver pDriver, const LibMCDriver_Rasterizer_uint32 nNameSpaceBufferSize, LibMCDriver_Rasterizer_uint32* pNameSpaceNeededChars, char * pNameSpaceBuffer, const LibMCDriver_Rasterizer_uint32 nBaseNameBufferSize, LibMCDriver_Rasterizer_uint32* pBaseNameNeededChars, char * pBaseNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameSpaceBuffer) && !(pNameSpaceNeededChars) )
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if ( (!pBaseNameBuffer) && !(pBaseNameNeededChars) )
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sNameSpace("");
		std::string sBaseName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameSpaceBuffer == nullptr) || (pBaseNameBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetHeaderInformation(sNameSpace, sBaseName);

			pIDriver->_setCache (new ParameterCache_2<std::string, std::string> (sNameSpace, sBaseName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
			cache->retrieveData (sNameSpace, sBaseName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameSpaceNeededChars)
			*pNameSpaceNeededChars = (LibMCDriver_Rasterizer_uint32) (sNameSpace.size()+1);
		if (pNameSpaceBuffer) {
			if (sNameSpace.size() >= nNameSpaceBufferSize)
				throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_BUFFERTOOSMALL);
			for (size_t iNameSpace = 0; iNameSpace < sNameSpace.size(); iNameSpace++)
				pNameSpaceBuffer[iNameSpace] = sNameSpace[iNameSpace];
			pNameSpaceBuffer[sNameSpace.size()] = 0;
		}
		if (pBaseNameNeededChars)
			*pBaseNameNeededChars = (LibMCDriver_Rasterizer_uint32) (sBaseName.size()+1);
		if (pBaseNameBuffer) {
			if (sBaseName.size() >= nBaseNameBufferSize)
				throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_BUFFERTOOSMALL);
			for (size_t iBaseName = 0; iBaseName < sBaseName.size(); iBaseName++)
				pBaseNameBuffer[iBaseName] = sBaseName[iBaseName];
			pBaseNameBuffer[sBaseName.size()] = 0;
		}
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_queryparameters(LibMCDriver_Rasterizer_Driver pDriver)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIDriver->QueryParameters();

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ImageObject
**************************************************************************************************************************/
LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_getdpi(LibMCDriver_Rasterizer_ImageObject pImageObject, LibMCDriver_Rasterizer_double * pDPIValueX, LibMCDriver_Rasterizer_double * pDPIValueY)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if (!pDPIValueX)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pDPIValueY)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->GetDPI(*pDPIValueX, *pDPIValueY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_getsize(LibMCDriver_Rasterizer_ImageObject pImageObject, LibMCDriver_Rasterizer_double * pSizeX, LibMCDriver_Rasterizer_double * pSizeY)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if (!pSizeX)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pSizeY)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->GetSize(*pSizeX, *pSizeY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_getpixelsize(LibMCDriver_Rasterizer_ImageObject pImageObject, LibMCDriver_Rasterizer_uint32 * pPixelSizeX, LibMCDriver_Rasterizer_uint32 * pPixelSizeY)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if (!pPixelSizeX)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pPixelSizeY)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->GetPixelSize(*pPixelSizeX, *pPixelSizeY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_encodepng(LibMCDriver_Rasterizer_ImageObject pImageObject)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->EncodePNG();

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_clearencodedpng(LibMCDriver_Rasterizer_ImageObject pImageObject)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->ClearEncodedPNG();

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_getencodedpngdata(LibMCDriver_Rasterizer_ImageObject pImageObject, const LibMCDriver_Rasterizer_uint64 nPNGDataBufferSize, LibMCDriver_Rasterizer_uint64* pPNGDataNeededCount, LibMCDriver_Rasterizer_uint8 * pPNGDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if ((!pPNGDataBuffer) && !(pPNGDataNeededCount))
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->GetEncodedPNGData(nPNGDataBufferSize, pPNGDataNeededCount, pPNGDataBuffer);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_clear(LibMCDriver_Rasterizer_ImageObject pImageObject, LibMCDriver_Rasterizer_uint8 nValue)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->Clear(nValue);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_getpixel(LibMCDriver_Rasterizer_ImageObject pImageObject, LibMCDriver_Rasterizer_uint32 nX, LibMCDriver_Rasterizer_uint32 nY, LibMCDriver_Rasterizer_uint8 * pValue)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if (pValue == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		*pValue = pIImageObject->GetPixel(nX, nY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_setpixel(LibMCDriver_Rasterizer_ImageObject pImageObject, LibMCDriver_Rasterizer_uint32 nX, LibMCDriver_Rasterizer_uint32 nY, LibMCDriver_Rasterizer_uint8 nValue)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->SetPixel(nX, nY, nValue);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_getpixelrange(LibMCDriver_Rasterizer_ImageObject pImageObject, LibMCDriver_Rasterizer_uint32 nXMin, LibMCDriver_Rasterizer_uint32 nYMin, LibMCDriver_Rasterizer_uint32 nXMax, LibMCDriver_Rasterizer_uint32 nYMax, const LibMCDriver_Rasterizer_uint64 nValueBufferSize, LibMCDriver_Rasterizer_uint64* pValueNeededCount, LibMCDriver_Rasterizer_uint8 * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if ((!pValueBuffer) && !(pValueNeededCount))
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->GetPixelRange(nXMin, nYMin, nXMax, nYMax, nValueBufferSize, pValueNeededCount, pValueBuffer);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_imageobject_setpixelrange(LibMCDriver_Rasterizer_ImageObject pImageObject, LibMCDriver_Rasterizer_uint32 nXMin, LibMCDriver_Rasterizer_uint32 nYMin, LibMCDriver_Rasterizer_uint32 nXMax, LibMCDriver_Rasterizer_uint32 nYMax, LibMCDriver_Rasterizer_uint64 nValueBufferSize, const LibMCDriver_Rasterizer_uint8 * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if ( (!pValueBuffer) && (nValueBufferSize>0))
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->SetPixelRange(nXMin, nYMin, nXMax, nYMax, nValueBufferSize, pValueBuffer);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for LayerObject
**************************************************************************************************************************/
LibMCDriver_RasterizerResult libmcdriver_rasterizer_layerobject_getentitycount(LibMCDriver_Rasterizer_LayerObject pLayerObject, LibMCDriver_Rasterizer_uint32 * pEntityCount)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pEntityCount == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		*pEntityCount = pILayerObject->GetEntityCount();

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_layerobject_getentity(LibMCDriver_Rasterizer_LayerObject pLayerObject, LibMCDriver_Rasterizer_uint32 nEntityIndex, eLibMCDriver_RasterizerGeometryType * pGeometryType, const LibMCDriver_Rasterizer_uint64 nPointsBufferSize, LibMCDriver_Rasterizer_uint64* pPointsNeededCount, sLibMCDriver_RasterizerPosition2D * pPointsBuffer)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (!pGeometryType)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if ((!pPointsBuffer) && !(pPointsNeededCount))
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pILayerObject->GetEntity(nEntityIndex, *pGeometryType, nPointsBufferSize, pPointsNeededCount, pPointsBuffer);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_layerobject_addentity(LibMCDriver_Rasterizer_LayerObject pLayerObject, LibMCDriver_Rasterizer_uint64 nPointsBufferSize, const sLibMCDriver_RasterizerPosition2D * pPointsBuffer, eLibMCDriver_RasterizerGeometryType eGeometryType, LibMCDriver_Rasterizer_uint32 * pEntityIndex)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if ( (!pPointsBuffer) && (nPointsBufferSize>0))
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (pEntityIndex == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		*pEntityIndex = pILayerObject->AddEntity(nPointsBufferSize, pPointsBuffer, eGeometryType);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_layerobject_removeselfintersections(LibMCDriver_Rasterizer_LayerObject pLayerObject, LibMCDriver_Rasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->RemoveSelfIntersections();

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_layerobject_mergeinto(LibMCDriver_Rasterizer_LayerObject pLayerObject, LibMCDriver_Rasterizer_LayerObject pOtherLayerObject)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		IBase* pIBaseClassOtherLayerObject = (IBase *)pOtherLayerObject;
		ILayerObject* pIOtherLayerObject = dynamic_cast<ILayerObject*>(pIBaseClassOtherLayerObject);
		if (!pIOtherLayerObject)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pILayerObject->MergeInto(pIOtherLayerObject);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_layerobject_calculateoffset(LibMCDriver_Rasterizer_LayerObject pLayerObject, LibMCDriver_Rasterizer_double dOffsetValue, LibMCDriver_Rasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->CalculateOffset(dOffsetValue);

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_layerobject_thickenpolylines(LibMCDriver_Rasterizer_LayerObject pLayerObject, LibMCDriver_Rasterizer_double dThickness, LibMCDriver_Rasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->ThickenPolylines(dThickness);

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_layerobject_thickenhatches(LibMCDriver_Rasterizer_LayerObject pLayerObject, LibMCDriver_Rasterizer_double dThickness, LibMCDriver_Rasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->ThickenHatches(dThickness);

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_layerobject_distortlayer(LibMCDriver_Rasterizer_LayerObject pLayerObject, LibMCDriver_Rasterizer_double dRefinementValue, LibMCDriver_RasterizerDistortionCallback pDistortionCallback, LibMCDriver_Rasterizer_pvoid pUserData, LibMCDriver_Rasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->DistortLayer(dRefinementValue, pDistortionCallback, pUserData);

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Rasterizer
**************************************************************************************************************************/
LibMCDriver_RasterizerResult libmcdriver_rasterizer_rasterizer_getdpi(LibMCDriver_Rasterizer_Rasterizer pRasterizer, LibMCDriver_Rasterizer_double * pDPIValueX, LibMCDriver_Rasterizer_double * pDPIValueY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pDPIValueX)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pDPIValueY)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetDPI(*pDPIValueX, *pDPIValueY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_rasterizer_getsize(LibMCDriver_Rasterizer_Rasterizer pRasterizer, LibMCDriver_Rasterizer_double * pSizeX, LibMCDriver_Rasterizer_double * pSizeY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pSizeX)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pSizeY)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetSize(*pSizeX, *pSizeY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_rasterizer_getpixelsize(LibMCDriver_Rasterizer_Rasterizer pRasterizer, LibMCDriver_Rasterizer_uint32 * pPixelSizeX, LibMCDriver_Rasterizer_uint32 * pPixelSizeY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pPixelSizeX)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pPixelSizeY)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetPixelSize(*pPixelSizeX, *pPixelSizeY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_rasterizer_getposition(LibMCDriver_Rasterizer_Rasterizer pRasterizer, LibMCDriver_Rasterizer_double * pPositionX, LibMCDriver_Rasterizer_double * pPositionY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pPositionX)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pPositionY)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetPosition(*pPositionX, *pPositionY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_rasterizer_setposition(LibMCDriver_Rasterizer_Rasterizer pRasterizer, LibMCDriver_Rasterizer_double dPositionX, LibMCDriver_Rasterizer_double dPositionY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->SetPosition(dPositionX, dPositionY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_rasterizer_setsubsampling(LibMCDriver_Rasterizer_Rasterizer pRasterizer, LibMCDriver_Rasterizer_uint32 nSubsamplingX, LibMCDriver_Rasterizer_uint32 nSubsamplingY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->SetSubsampling(nSubsamplingX, nSubsamplingY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_rasterizer_getsubsampling(LibMCDriver_Rasterizer_Rasterizer pRasterizer, LibMCDriver_Rasterizer_uint32 * pSubsamplingX, LibMCDriver_Rasterizer_uint32 * pSubsamplingY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pSubsamplingX)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pSubsamplingY)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetSubsampling(*pSubsamplingX, *pSubsamplingY);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_rasterizer_addlayer(LibMCDriver_Rasterizer_Rasterizer pRasterizer, LibMCDriver_Rasterizer_LayerObject pLayerObject)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		IBase* pIBaseClassLayerObject = (IBase *)pLayerObject;
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClassLayerObject);
		if (!pILayerObject)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->AddLayer(pILayerObject);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_rasterizer_calculateimage(LibMCDriver_Rasterizer_Rasterizer pRasterizer, bool bAntialiased, LibMCDriver_Rasterizer_ImageObject * pImageObject)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (pImageObject == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseImageObject(nullptr);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseImageObject = pIRasterizer->CalculateImage(bAntialiased);

		*pImageObject = (IBase*)(pBaseImageObject);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for SliceStack
**************************************************************************************************************************/
LibMCDriver_RasterizerResult libmcdriver_rasterizer_slicestack_getlayercount(LibMCDriver_Rasterizer_SliceStack pSliceStack, LibMCDriver_Rasterizer_uint32 * pLayerCount)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pLayerCount == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		*pLayerCount = pISliceStack->GetLayerCount();

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_slicestack_getlayerthickness(LibMCDriver_Rasterizer_SliceStack pSliceStack, LibMCDriver_Rasterizer_double * pLayerThickness)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pLayerThickness == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		*pLayerThickness = pISliceStack->GetLayerThickness();

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_slicestack_getbottomz(LibMCDriver_Rasterizer_SliceStack pSliceStack, LibMCDriver_Rasterizer_double * pZValue)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pZValue == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		*pZValue = pISliceStack->GetBottomZ();

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_slicestack_gettopz(LibMCDriver_Rasterizer_SliceStack pSliceStack, LibMCDriver_Rasterizer_double * pZValue)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pZValue == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		*pZValue = pISliceStack->GetTopZ();

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_slicestack_getlayer(LibMCDriver_Rasterizer_SliceStack pSliceStack, LibMCDriver_Rasterizer_uint32 nLayerIndex, LibMCDriver_Rasterizer_LayerObject * pLayerObject)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pLayerObject == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObject(nullptr);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObject = pISliceStack->GetLayer(nLayerIndex);

		*pLayerObject = (IBase*)(pBaseLayerObject);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Driver_Rasterizer
**************************************************************************************************************************/
LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_rasterizer_createslicestack(LibMCDriver_Rasterizer_Driver_Rasterizer pDriver_Rasterizer, LibMCDriver_Rasterizer_uint32 nLayerCount, LibMCDriver_Rasterizer_double dLayerThickness, LibMCDriver_Rasterizer_double dBottomZ, LibMCDriver_Rasterizer_SliceStack * pSliceStackInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_Rasterizer;

	try {
		if (pSliceStackInstance == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseSliceStackInstance(nullptr);
		IDriver_Rasterizer* pIDriver_Rasterizer = dynamic_cast<IDriver_Rasterizer*>(pIBaseClass);
		if (!pIDriver_Rasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseSliceStackInstance = pIDriver_Rasterizer->CreateSliceStack(nLayerCount, dLayerThickness, dBottomZ);

		*pSliceStackInstance = (IBase*)(pBaseSliceStackInstance);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_rasterizer_createemptylayer(LibMCDriver_Rasterizer_Driver_Rasterizer pDriver_Rasterizer, LibMCDriver_Rasterizer_LayerObject * pLayerObject)
{
	IBase* pIBaseClass = (IBase *)pDriver_Rasterizer;

	try {
		if (pLayerObject == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObject(nullptr);
		IDriver_Rasterizer* pIDriver_Rasterizer = dynamic_cast<IDriver_Rasterizer*>(pIBaseClass);
		if (!pIDriver_Rasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObject = pIDriver_Rasterizer->CreateEmptyLayer();

		*pLayerObject = (IBase*)(pBaseLayerObject);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_rasterizer_registerinstance(LibMCDriver_Rasterizer_Driver_Rasterizer pDriver_Rasterizer, const char * pIdentifier, LibMCDriver_Rasterizer_uint32 nPixelSizeX, LibMCDriver_Rasterizer_uint32 nPixelSizeY, LibMCDriver_Rasterizer_double dDPIX, LibMCDriver_Rasterizer_double dDPIY, LibMCDriver_Rasterizer_Rasterizer * pRasterizerInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_Rasterizer;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (pRasterizerInstance == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseRasterizerInstance(nullptr);
		IDriver_Rasterizer* pIDriver_Rasterizer = dynamic_cast<IDriver_Rasterizer*>(pIBaseClass);
		if (!pIDriver_Rasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseRasterizerInstance = pIDriver_Rasterizer->RegisterInstance(sIdentifier, nPixelSizeX, nPixelSizeY, dDPIX, dDPIY);

		*pRasterizerInstance = (IBase*)(pBaseRasterizerInstance);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_rasterizer_unregisterinstance(LibMCDriver_Rasterizer_Driver_Rasterizer pDriver_Rasterizer, const char * pIdentifier)
{
	IBase* pIBaseClass = (IBase *)pDriver_Rasterizer;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriver_Rasterizer* pIDriver_Rasterizer = dynamic_cast<IDriver_Rasterizer*>(pIBaseClass);
		if (!pIDriver_Rasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pIDriver_Rasterizer->UnregisterInstance(sIdentifier);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_rasterizer_hasinstance(LibMCDriver_Rasterizer_Driver_Rasterizer pDriver_Rasterizer, const char * pIdentifier, bool * pInstanceExists)
{
	IBase* pIBaseClass = (IBase *)pDriver_Rasterizer;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (pInstanceExists == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriver_Rasterizer* pIDriver_Rasterizer = dynamic_cast<IDriver_Rasterizer*>(pIBaseClass);
		if (!pIDriver_Rasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		*pInstanceExists = pIDriver_Rasterizer->HasInstance(sIdentifier);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_driver_rasterizer_getinstance(LibMCDriver_Rasterizer_Driver_Rasterizer pDriver_Rasterizer, const char * pIdentifier, LibMCDriver_Rasterizer_Rasterizer * pRasterizerInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_Rasterizer;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (pRasterizerInstance == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseRasterizerInstance(nullptr);
		IDriver_Rasterizer* pIDriver_Rasterizer = dynamic_cast<IDriver_Rasterizer*>(pIBaseClass);
		if (!pIDriver_Rasterizer)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		pBaseRasterizerInstance = pIDriver_Rasterizer->GetInstance(sIdentifier);

		*pRasterizerInstance = (IBase*)(pBaseRasterizerInstance);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDriver_RasterizerResult LibMCDriver_Rasterizer::Impl::LibMCDriver_Rasterizer_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdriver_rasterizer_driver_configure") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_configure;
	if (sProcName == "libmcdriver_rasterizer_driver_getname") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_getname;
	if (sProcName == "libmcdriver_rasterizer_driver_gettype") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_gettype;
	if (sProcName == "libmcdriver_rasterizer_driver_getversion") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_getversion;
	if (sProcName == "libmcdriver_rasterizer_driver_getheaderinformation") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_getheaderinformation;
	if (sProcName == "libmcdriver_rasterizer_driver_queryparameters") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_queryparameters;
	if (sProcName == "libmcdriver_rasterizer_imageobject_getdpi") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_getdpi;
	if (sProcName == "libmcdriver_rasterizer_imageobject_getsize") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_getsize;
	if (sProcName == "libmcdriver_rasterizer_imageobject_getpixelsize") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_getpixelsize;
	if (sProcName == "libmcdriver_rasterizer_imageobject_encodepng") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_encodepng;
	if (sProcName == "libmcdriver_rasterizer_imageobject_clearencodedpng") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_clearencodedpng;
	if (sProcName == "libmcdriver_rasterizer_imageobject_getencodedpngdata") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_getencodedpngdata;
	if (sProcName == "libmcdriver_rasterizer_imageobject_clear") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_clear;
	if (sProcName == "libmcdriver_rasterizer_imageobject_getpixel") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_getpixel;
	if (sProcName == "libmcdriver_rasterizer_imageobject_setpixel") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_setpixel;
	if (sProcName == "libmcdriver_rasterizer_imageobject_getpixelrange") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_getpixelrange;
	if (sProcName == "libmcdriver_rasterizer_imageobject_setpixelrange") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_imageobject_setpixelrange;
	if (sProcName == "libmcdriver_rasterizer_layerobject_getentitycount") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_layerobject_getentitycount;
	if (sProcName == "libmcdriver_rasterizer_layerobject_getentity") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_layerobject_getentity;
	if (sProcName == "libmcdriver_rasterizer_layerobject_addentity") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_layerobject_addentity;
	if (sProcName == "libmcdriver_rasterizer_layerobject_removeselfintersections") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_layerobject_removeselfintersections;
	if (sProcName == "libmcdriver_rasterizer_layerobject_mergeinto") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_layerobject_mergeinto;
	if (sProcName == "libmcdriver_rasterizer_layerobject_calculateoffset") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_layerobject_calculateoffset;
	if (sProcName == "libmcdriver_rasterizer_layerobject_thickenpolylines") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_layerobject_thickenpolylines;
	if (sProcName == "libmcdriver_rasterizer_layerobject_thickenhatches") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_layerobject_thickenhatches;
	if (sProcName == "libmcdriver_rasterizer_layerobject_distortlayer") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_layerobject_distortlayer;
	if (sProcName == "libmcdriver_rasterizer_rasterizer_getdpi") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_rasterizer_getdpi;
	if (sProcName == "libmcdriver_rasterizer_rasterizer_getsize") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_rasterizer_getsize;
	if (sProcName == "libmcdriver_rasterizer_rasterizer_getpixelsize") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_rasterizer_getpixelsize;
	if (sProcName == "libmcdriver_rasterizer_rasterizer_getposition") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_rasterizer_getposition;
	if (sProcName == "libmcdriver_rasterizer_rasterizer_setposition") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_rasterizer_setposition;
	if (sProcName == "libmcdriver_rasterizer_rasterizer_setsubsampling") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_rasterizer_setsubsampling;
	if (sProcName == "libmcdriver_rasterizer_rasterizer_getsubsampling") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_rasterizer_getsubsampling;
	if (sProcName == "libmcdriver_rasterizer_rasterizer_addlayer") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_rasterizer_addlayer;
	if (sProcName == "libmcdriver_rasterizer_rasterizer_calculateimage") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_rasterizer_calculateimage;
	if (sProcName == "libmcdriver_rasterizer_slicestack_getlayercount") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_slicestack_getlayercount;
	if (sProcName == "libmcdriver_rasterizer_slicestack_getlayerthickness") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_slicestack_getlayerthickness;
	if (sProcName == "libmcdriver_rasterizer_slicestack_getbottomz") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_slicestack_getbottomz;
	if (sProcName == "libmcdriver_rasterizer_slicestack_gettopz") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_slicestack_gettopz;
	if (sProcName == "libmcdriver_rasterizer_slicestack_getlayer") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_slicestack_getlayer;
	if (sProcName == "libmcdriver_rasterizer_driver_rasterizer_createslicestack") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_rasterizer_createslicestack;
	if (sProcName == "libmcdriver_rasterizer_driver_rasterizer_createemptylayer") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_rasterizer_createemptylayer;
	if (sProcName == "libmcdriver_rasterizer_driver_rasterizer_registerinstance") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_rasterizer_registerinstance;
	if (sProcName == "libmcdriver_rasterizer_driver_rasterizer_unregisterinstance") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_rasterizer_unregisterinstance;
	if (sProcName == "libmcdriver_rasterizer_driver_rasterizer_hasinstance") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_rasterizer_hasinstance;
	if (sProcName == "libmcdriver_rasterizer_driver_rasterizer_getinstance") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_driver_rasterizer_getinstance;
	if (sProcName == "libmcdriver_rasterizer_getversion") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_getversion;
	if (sProcName == "libmcdriver_rasterizer_getlasterror") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_getlasterror;
	if (sProcName == "libmcdriver_rasterizer_releaseinstance") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_releaseinstance;
	if (sProcName == "libmcdriver_rasterizer_acquireinstance") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_acquireinstance;
	if (sProcName == "libmcdriver_rasterizer_injectcomponent") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_injectcomponent;
	if (sProcName == "libmcdriver_rasterizer_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_getsymbollookupmethod;
	if (sProcName == "libmcdriver_rasterizer_createdriver") 
		*ppProcAddress = (void*) &libmcdriver_rasterizer_createdriver;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDRIVER_RASTERIZER_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDriver_RasterizerResult libmcdriver_rasterizer_getversion(LibMCDriver_Rasterizer_uint32 * pMajor, LibMCDriver_Rasterizer_uint32 * pMinor, LibMCDriver_Rasterizer_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_getlasterror(LibMCDriver_Rasterizer_Base pInstance, const LibMCDriver_Rasterizer_uint32 nErrorMessageBufferSize, LibMCDriver_Rasterizer_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCDriver_Rasterizer_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_releaseinstance(LibMCDriver_Rasterizer_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_acquireinstance(LibMCDriver_Rasterizer_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_injectcomponent(const char * pNameSpace, LibMCDriver_Rasterizer_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCEnv") {
			if (CWrapper::sPLibMCEnvWrapper.get() != nullptr) {
				throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCDriver_RasterizerInterfaceException(LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_getsymbollookupmethod(LibMCDriver_Rasterizer_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCDriver_Rasterizer::Impl::LibMCDriver_Rasterizer_GetProcAddress;
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_RasterizerResult libmcdriver_rasterizer_createdriver(const char * pName, const char * pType, LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCDriver_Rasterizer_Driver * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (pType == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		if (pInstance == nullptr)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sType(pType);
		LibMCEnv::PDriverEnvironment pIDriverEnvironment = std::make_shared<LibMCEnv::CDriverEnvironment>(CWrapper::sPLibMCEnvWrapper.get(), pDriverEnvironment);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverEnvironment.get());
		if (!pIDriverEnvironment)
			throw ELibMCDriver_RasterizerInterfaceException (LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDriver(sName, sType, pIDriverEnvironment);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	catch (ELibMCDriver_RasterizerInterfaceException & Exception) {
		return handleLibMCDriver_RasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


