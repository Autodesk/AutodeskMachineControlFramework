/*++

Copyright (C) 2022 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Generic Rasterizer Driver

Interface version: 1.0.0

*/

#ifndef __LIBMCDRIVER_RASTERIZER_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDRIVER_RASTERIZER_CPPHEADER_DYNAMIC_CPP

#include "libmcdriver_rasterizer_types.hpp"
#include "libmcdriver_rasterizer_dynamic.h"

#include "libmcenv_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCDriver_Rasterizer {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CDriver;
class CLayerObject;
class CRasterizer;
class CSliceStack;
class CDriver_Rasterizer;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDriver_RasterizerWrapper;
typedef CBase CLibMCDriver_RasterizerBase;
typedef CDriver CLibMCDriver_RasterizerDriver;
typedef CLayerObject CLibMCDriver_RasterizerLayerObject;
typedef CRasterizer CLibMCDriver_RasterizerRasterizer;
typedef CSliceStack CLibMCDriver_RasterizerSliceStack;
typedef CDriver_Rasterizer CLibMCDriver_RasterizerDriver_Rasterizer;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CDriver> PDriver;
typedef std::shared_ptr<CLayerObject> PLayerObject;
typedef std::shared_ptr<CRasterizer> PRasterizer;
typedef std::shared_ptr<CSliceStack> PSliceStack;
typedef std::shared_ptr<CDriver_Rasterizer> PDriver_Rasterizer;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDriver_RasterizerWrapper;
typedef PBase PLibMCDriver_RasterizerBase;
typedef PDriver PLibMCDriver_RasterizerDriver;
typedef PLayerObject PLibMCDriver_RasterizerLayerObject;
typedef PRasterizer PLibMCDriver_RasterizerRasterizer;
typedef PSliceStack PLibMCDriver_RasterizerSliceStack;
typedef PDriver_Rasterizer PLibMCDriver_RasterizerDriver_Rasterizer;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDriver_RasterizerHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDriver_RasterizerException 
**************************************************************************************************************************/
class ELibMCDriver_RasterizerException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDriver_RasterizerResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDriver_RasterizerException(LibMCDriver_RasterizerResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDriver_RasterizerResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_RASTERIZER_SUCCESS: return "SUCCESS";
			case LIBMCDRIVER_RASTERIZER_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDRIVER_RASTERIZER_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDRIVER_RASTERIZER_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDRIVER_RASTERIZER_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDSUBSAMPLING: return "INVALIDSUBSAMPLING";
			case LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTCOMPRESSPNGIMAGE: return "COULDNOTCOMPRESSPNGIMAGE";
			case LIBMCDRIVER_RASTERIZER_ERROR_EMPTYPNGIMAGEDATA: return "EMPTYPNGIMAGEDATA";
			case LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTSTOREPNGIMAGE: return "COULDNOTSTOREPNGIMAGE";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDXCOORDINATE: return "INVALIDXCOORDINATE";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDYCOORDINATE: return "INVALIDYCOORDINATE";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDXCOORDINATERANGE: return "INVALIDXCOORDINATERANGE";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDYCOORDINATERANGE: return "INVALIDYCOORDINATERANGE";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPIXELDATACOUNT: return "INVALIDPIXELDATACOUNT";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDLAYERCOUNT: return "INVALIDLAYERCOUNT";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDLAYERTHICKNESS: return "INVALIDLAYERTHICKNESS";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPIXELCOUNT: return "INVALIDPIXELCOUNT";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDDPIVALUE: return "INVALIDDPIVALUE";
			case LIBMCDRIVER_RASTERIZER_ERROR_DRIVERERROR: return "DRIVERERROR";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDIDENTIFIER: return "INVALIDIDENTIFIER";
			case LIBMCDRIVER_RASTERIZER_ERROR_IDENTIFIERNOTREGISTERED: return "IDENTIFIERNOTREGISTERED";
			case LIBMCDRIVER_RASTERIZER_ERROR_IDENTIFIERALREADYREGISTERED: return "IDENTIFIERALREADYREGISTERED";
			case LIBMCDRIVER_RASTERIZER_ERROR_PIXELFORMATSHOULDBEGREYSCALE: return "PIXELFORMATSHOULDBEGREYSCALE";
			case LIBMCDRIVER_RASTERIZER_ERROR_PIXELSIZEMISMATCH: return "PIXELSIZEMISMATCH";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDUNITSPERSUBPIXEL: return "INVALIDUNITSPERSUBPIXEL";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDSUBPIXELSPERPIXELS: return "INVALIDSUBPIXELSPERPIXELS";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPIXELSPERBLOCK: return "INVALIDPIXELSPERBLOCK";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDBLOCKCOUNT: return "INVALIDBLOCKCOUNT";
			case LIBMCDRIVER_RASTERIZER_ERROR_LINECOORDINATEOVERFLOW: return "LINECOORDINATEOVERFLOW";
			case LIBMCDRIVER_RASTERIZER_ERROR_TOOMANYLINESINLAYER: return "TOOMANYLINESINLAYER";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDHATCHCOUNT: return "INVALIDHATCHCOUNT";
			case LIBMCDRIVER_RASTERIZER_ERROR_RASTERIZATIONNOTINITIALIZED: return "RASTERIZATIONNOTINITIALIZED";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDRIVER_RASTERIZER_SUCCESS: return "success";
			case LIBMCDRIVER_RASTERIZER_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDRIVER_RASTERIZER_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDRIVER_RASTERIZER_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDRIVER_RASTERIZER_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDSUBSAMPLING: return "invalid subsampling";
			case LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTCOMPRESSPNGIMAGE: return "could not compress png image";
			case LIBMCDRIVER_RASTERIZER_ERROR_EMPTYPNGIMAGEDATA: return "empty png image data";
			case LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTSTOREPNGIMAGE: return "could not store png image";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDXCOORDINATE: return "invalid x coordinate";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDYCOORDINATE: return "invalid y coordinate";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDXCOORDINATERANGE: return "invalid x coordinate range";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDYCOORDINATERANGE: return "invalid y coordinate range";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPIXELDATACOUNT: return "invalid pixel data count";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDLAYERCOUNT: return "invalid layer count";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDLAYERTHICKNESS: return "invalid layer thickness";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPIXELCOUNT: return "invalid pixel count";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDDPIVALUE: return "invalid dpi value";
			case LIBMCDRIVER_RASTERIZER_ERROR_DRIVERERROR: return "driver error";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDIDENTIFIER: return "invalid identifier string";
			case LIBMCDRIVER_RASTERIZER_ERROR_IDENTIFIERNOTREGISTERED: return "identifier not registered";
			case LIBMCDRIVER_RASTERIZER_ERROR_IDENTIFIERALREADYREGISTERED: return "identifier already registered";
			case LIBMCDRIVER_RASTERIZER_ERROR_PIXELFORMATSHOULDBEGREYSCALE: return "pixel format should be greyscale";
			case LIBMCDRIVER_RASTERIZER_ERROR_PIXELSIZEMISMATCH: return "pixel size mismatch";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDUNITSPERSUBPIXEL: return "Invalid units per subpixel";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDSUBPIXELSPERPIXELS: return "Invalid subpixels per pixel";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPIXELSPERBLOCK: return "invalid pixels per block";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDBLOCKCOUNT: return "invalid block count";
			case LIBMCDRIVER_RASTERIZER_ERROR_LINECOORDINATEOVERFLOW: return "line coordinate overflow";
			case LIBMCDRIVER_RASTERIZER_ERROR_TOOMANYLINESINLAYER: return "too many lines in layer";
			case LIBMCDRIVER_RASTERIZER_ERROR_INVALIDHATCHCOUNT: return "invalid hatch count";
			case LIBMCDRIVER_RASTERIZER_ERROR_RASTERIZATIONNOTINITIALIZED: return "rasterization not initialized";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDriver_RasterizerInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDriver_RasterizerResult nResult);

	inline void GetVersion(LibMCDriver_Rasterizer_uint32 & nMajor, LibMCDriver_Rasterizer_uint32 & nMinor, LibMCDriver_Rasterizer_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMCDriver_Rasterizer_pvoid pSymbolAddressMethod);
	inline LibMCDriver_Rasterizer_pvoid GetSymbolLookupMethod();
	inline PDriver CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment);

private:
	sLibMCDriver_RasterizerDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCEnv::PWrapper m_pLibMCEnvWrapper;

	
	LibMCDriver_RasterizerResult checkBinaryVersion()
	{
		LibMCDriver_Rasterizer_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDRIVER_RASTERIZER_VERSION_MAJOR) {
			return LIBMCDRIVER_RASTERIZER_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}
	LibMCDriver_RasterizerResult initWrapperTable(sLibMCDriver_RasterizerDynamicWrapperTable * pWrapperTable);
	LibMCDriver_RasterizerResult releaseWrapperTable(sLibMCDriver_RasterizerDynamicWrapperTable * pWrapperTable);
	LibMCDriver_RasterizerResult loadWrapperTable(sLibMCDriver_RasterizerDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDriver_RasterizerResult loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_RasterizerDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CDriver;
	friend class CLayerObject;
	friend class CRasterizer;
	friend class CSliceStack;
	friend class CDriver_Rasterizer;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDriver_RasterizerHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDriver_RasterizerResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDriver_RasterizerHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDriver_RasterizerHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CDriver 
**************************************************************************************************************************/
class CDriver : public CBase {
public:
	
	/**
	* CDriver::CDriver - Constructor for Driver class.
	*/
	CDriver(CWrapper* pWrapper, LibMCDriver_RasterizerHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void Configure(const std::string & sConfigurationString);
	inline std::string GetName();
	inline std::string GetType();
	inline void GetVersion(LibMCDriver_Rasterizer_uint32 & nMajor, LibMCDriver_Rasterizer_uint32 & nMinor, LibMCDriver_Rasterizer_uint32 & nMicro, std::string & sBuild);
	inline void GetHeaderInformation(std::string & sNameSpace, std::string & sBaseName);
	inline void QueryParameters();
};
	
/*************************************************************************************************************************
 Class CLayerObject 
**************************************************************************************************************************/
class CLayerObject : public CBase {
public:
	
	/**
	* CLayerObject::CLayerObject - Constructor for LayerObject class.
	*/
	CLayerObject(CWrapper* pWrapper, LibMCDriver_RasterizerHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCDriver_Rasterizer_uint32 GetEntityCount();
	inline void GetEntity(const LibMCDriver_Rasterizer_uint32 nEntityIndex, eGeometryType & eGeometryType, std::vector<sPosition2D> & PointsBuffer);
	inline LibMCDriver_Rasterizer_uint32 AddEntity(const CInputVector<sPosition2D> & PointsBuffer, const eGeometryType eGeometryType);
	inline PLayerObject RemoveSelfIntersections();
	inline void MergeInto(classParam<CLayerObject> pOtherLayerObject);
	inline PLayerObject CalculateOffset(const LibMCDriver_Rasterizer_double dOffsetValue);
	inline PLayerObject ThickenPolylines(const LibMCDriver_Rasterizer_double dThickness);
	inline PLayerObject ThickenHatches(const LibMCDriver_Rasterizer_double dThickness);
	inline PLayerObject DistortLayer(const LibMCDriver_Rasterizer_double dRefinementValue, const DistortionCallback pDistortionCallback, const LibMCDriver_Rasterizer_pvoid pUserData);
};
	
/*************************************************************************************************************************
 Class CRasterizer 
**************************************************************************************************************************/
class CRasterizer : public CBase {
public:
	
	/**
	* CRasterizer::CRasterizer - Constructor for Rasterizer class.
	*/
	CRasterizer(CWrapper* pWrapper, LibMCDriver_RasterizerHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void GetDPI(LibMCDriver_Rasterizer_double & dDPIValueX, LibMCDriver_Rasterizer_double & dDPIValueY);
	inline void GetSize(LibMCDriver_Rasterizer_double & dSizeX, LibMCDriver_Rasterizer_double & dSizeY);
	inline void GetPixelSize(LibMCDriver_Rasterizer_uint32 & nPixelSizeX, LibMCDriver_Rasterizer_uint32 & nPixelSizeY);
	inline void GetPosition(LibMCDriver_Rasterizer_double & dPositionX, LibMCDriver_Rasterizer_double & dPositionY);
	inline void SetPosition(const LibMCDriver_Rasterizer_double dPositionX, const LibMCDriver_Rasterizer_double dPositionY);
	inline void SetSubsampling(const LibMCDriver_Rasterizer_uint32 nSubsamplingX, const LibMCDriver_Rasterizer_uint32 nSubsamplingY);
	inline void GetSubsampling(LibMCDriver_Rasterizer_uint32 & nSubsamplingX, LibMCDriver_Rasterizer_uint32 & nSubsamplingY);
	inline void SetSamplingParameters(const LibMCDriver_Rasterizer_uint32 nUnitsPerSubpixel, const LibMCDriver_Rasterizer_uint32 nPixelsPerBlock);
	inline void GetSamplingParameters(LibMCDriver_Rasterizer_uint32 & nUnitsPerSubpixel, LibMCDriver_Rasterizer_uint32 & nPixelsPerBlock);
	inline void AddLayer(classParam<CLayerObject> pLayerObject);
	inline void CalculateImage(classParam<LibMCEnv::CImageData> pImageObject, const bool bAntialiased);
};
	
/*************************************************************************************************************************
 Class CSliceStack 
**************************************************************************************************************************/
class CSliceStack : public CBase {
public:
	
	/**
	* CSliceStack::CSliceStack - Constructor for SliceStack class.
	*/
	CSliceStack(CWrapper* pWrapper, LibMCDriver_RasterizerHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCDriver_Rasterizer_uint32 GetLayerCount();
	inline LibMCDriver_Rasterizer_double GetLayerThickness();
	inline LibMCDriver_Rasterizer_double GetBottomZ();
	inline LibMCDriver_Rasterizer_double GetTopZ();
	inline PLayerObject GetLayer(const LibMCDriver_Rasterizer_uint32 nLayerIndex);
};
	
/*************************************************************************************************************************
 Class CDriver_Rasterizer 
**************************************************************************************************************************/
class CDriver_Rasterizer : public CDriver {
public:
	
	/**
	* CDriver_Rasterizer::CDriver_Rasterizer - Constructor for Driver_Rasterizer class.
	*/
	CDriver_Rasterizer(CWrapper* pWrapper, LibMCDriver_RasterizerHandle pHandle)
		: CDriver(pWrapper, pHandle)
	{
	}
	
	inline PSliceStack CreateSliceStack(const LibMCDriver_Rasterizer_uint32 nLayerCount, const LibMCDriver_Rasterizer_double dLayerThickness, const LibMCDriver_Rasterizer_double dBottomZ);
	inline PLayerObject CreateEmptyLayer();
	inline PRasterizer RegisterInstance(const std::string & sIdentifier, const LibMCDriver_Rasterizer_uint32 nPixelSizeX, const LibMCDriver_Rasterizer_uint32 nPixelSizeY, const LibMCDriver_Rasterizer_double dDPIX, const LibMCDriver_Rasterizer_double dDPIY);
	inline void UnregisterInstance(const std::string & sIdentifier);
	inline bool HasInstance(const std::string & sIdentifier);
	inline PRasterizer GetInstance(const std::string & sIdentifier);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCDriver_Rasterizer_uint32 & nMajor, LibMCDriver_Rasterizer_uint32 & nMinor, LibMCDriver_Rasterizer_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDriver_RasterizerHandle hInstance = pInstance.GetHandle();
		LibMCDriver_Rasterizer_uint32 bytesNeededErrorMessage = 0;
		LibMCDriver_Rasterizer_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_RasterizerHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDriver_RasterizerHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMCDriver_Rasterizer_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCEnv") {
			if (m_pLibMCEnvWrapper != nullptr) {
				throw ELibMCDriver_RasterizerException(LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCDriver_RasterizerException(LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCDriver_Rasterizer_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCDriver_Rasterizer_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDriver - Creates a driver instance with a specific name.
	* @param[in] sName - Name of driver to be created.
	* @param[in] sType - Type of driver to be created.
	* @param[in] pDriverEnvironment - Environment of this driver.
	* @return New Driver instance
	*/
	inline PDriver CWrapper::CreateDriver(const std::string & sName, const std::string & sType, classParam<LibMCEnv::CDriverEnvironment> pDriverEnvironment)
	{
		LibMCEnvHandle hDriverEnvironment = pDriverEnvironment.GetHandle();
		LibMCDriver_RasterizerHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDriver(sName.c_str(), sType.c_str(), hDriverEnvironment, &hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDriver>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDriver_RasterizerResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDriver_RasterizerException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDriver_RasterizerResult CWrapper::initWrapperTable(sLibMCDriver_RasterizerDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Driver_Configure = nullptr;
		pWrapperTable->m_Driver_GetName = nullptr;
		pWrapperTable->m_Driver_GetType = nullptr;
		pWrapperTable->m_Driver_GetVersion = nullptr;
		pWrapperTable->m_Driver_GetHeaderInformation = nullptr;
		pWrapperTable->m_Driver_QueryParameters = nullptr;
		pWrapperTable->m_LayerObject_GetEntityCount = nullptr;
		pWrapperTable->m_LayerObject_GetEntity = nullptr;
		pWrapperTable->m_LayerObject_AddEntity = nullptr;
		pWrapperTable->m_LayerObject_RemoveSelfIntersections = nullptr;
		pWrapperTable->m_LayerObject_MergeInto = nullptr;
		pWrapperTable->m_LayerObject_CalculateOffset = nullptr;
		pWrapperTable->m_LayerObject_ThickenPolylines = nullptr;
		pWrapperTable->m_LayerObject_ThickenHatches = nullptr;
		pWrapperTable->m_LayerObject_DistortLayer = nullptr;
		pWrapperTable->m_Rasterizer_GetDPI = nullptr;
		pWrapperTable->m_Rasterizer_GetSize = nullptr;
		pWrapperTable->m_Rasterizer_GetPixelSize = nullptr;
		pWrapperTable->m_Rasterizer_GetPosition = nullptr;
		pWrapperTable->m_Rasterizer_SetPosition = nullptr;
		pWrapperTable->m_Rasterizer_SetSubsampling = nullptr;
		pWrapperTable->m_Rasterizer_GetSubsampling = nullptr;
		pWrapperTable->m_Rasterizer_SetSamplingParameters = nullptr;
		pWrapperTable->m_Rasterizer_GetSamplingParameters = nullptr;
		pWrapperTable->m_Rasterizer_AddLayer = nullptr;
		pWrapperTable->m_Rasterizer_CalculateImage = nullptr;
		pWrapperTable->m_SliceStack_GetLayerCount = nullptr;
		pWrapperTable->m_SliceStack_GetLayerThickness = nullptr;
		pWrapperTable->m_SliceStack_GetBottomZ = nullptr;
		pWrapperTable->m_SliceStack_GetTopZ = nullptr;
		pWrapperTable->m_SliceStack_GetLayer = nullptr;
		pWrapperTable->m_Driver_Rasterizer_CreateSliceStack = nullptr;
		pWrapperTable->m_Driver_Rasterizer_CreateEmptyLayer = nullptr;
		pWrapperTable->m_Driver_Rasterizer_RegisterInstance = nullptr;
		pWrapperTable->m_Driver_Rasterizer_UnregisterInstance = nullptr;
		pWrapperTable->m_Driver_Rasterizer_HasInstance = nullptr;
		pWrapperTable->m_Driver_Rasterizer_GetInstance = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDriver = nullptr;
		
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}

	inline LibMCDriver_RasterizerResult CWrapper::releaseWrapperTable(sLibMCDriver_RasterizerDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}

	inline LibMCDriver_RasterizerResult CWrapper::loadWrapperTable(sLibMCDriver_RasterizerDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_RasterizerDriver_ConfigurePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_configure");
		#else // _WIN32
		pWrapperTable->m_Driver_Configure = (PLibMCDriver_RasterizerDriver_ConfigurePtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_configure");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Configure == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_RasterizerDriver_GetNamePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_getname");
		#else // _WIN32
		pWrapperTable->m_Driver_GetName = (PLibMCDriver_RasterizerDriver_GetNamePtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetName == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_RasterizerDriver_GetTypePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_gettype");
		#else // _WIN32
		pWrapperTable->m_Driver_GetType = (PLibMCDriver_RasterizerDriver_GetTypePtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_gettype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetType == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_RasterizerDriver_GetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_getversion");
		#else // _WIN32
		pWrapperTable->m_Driver_GetVersion = (PLibMCDriver_RasterizerDriver_GetVersionPtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetVersion == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_GetHeaderInformation = (PLibMCDriver_RasterizerDriver_GetHeaderInformationPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_getheaderinformation");
		#else // _WIN32
		pWrapperTable->m_Driver_GetHeaderInformation = (PLibMCDriver_RasterizerDriver_GetHeaderInformationPtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_getheaderinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_GetHeaderInformation == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_RasterizerDriver_QueryParametersPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_queryparameters");
		#else // _WIN32
		pWrapperTable->m_Driver_QueryParameters = (PLibMCDriver_RasterizerDriver_QueryParametersPtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_queryparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_QueryParameters == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_GetEntityCount = (PLibMCDriver_RasterizerLayerObject_GetEntityCountPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_layerobject_getentitycount");
		#else // _WIN32
		pWrapperTable->m_LayerObject_GetEntityCount = (PLibMCDriver_RasterizerLayerObject_GetEntityCountPtr) dlsym(hLibrary, "libmcdriver_rasterizer_layerobject_getentitycount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_GetEntityCount == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_GetEntity = (PLibMCDriver_RasterizerLayerObject_GetEntityPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_layerobject_getentity");
		#else // _WIN32
		pWrapperTable->m_LayerObject_GetEntity = (PLibMCDriver_RasterizerLayerObject_GetEntityPtr) dlsym(hLibrary, "libmcdriver_rasterizer_layerobject_getentity");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_GetEntity == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_AddEntity = (PLibMCDriver_RasterizerLayerObject_AddEntityPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_layerobject_addentity");
		#else // _WIN32
		pWrapperTable->m_LayerObject_AddEntity = (PLibMCDriver_RasterizerLayerObject_AddEntityPtr) dlsym(hLibrary, "libmcdriver_rasterizer_layerobject_addentity");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_AddEntity == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_RemoveSelfIntersections = (PLibMCDriver_RasterizerLayerObject_RemoveSelfIntersectionsPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_layerobject_removeselfintersections");
		#else // _WIN32
		pWrapperTable->m_LayerObject_RemoveSelfIntersections = (PLibMCDriver_RasterizerLayerObject_RemoveSelfIntersectionsPtr) dlsym(hLibrary, "libmcdriver_rasterizer_layerobject_removeselfintersections");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_RemoveSelfIntersections == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_MergeInto = (PLibMCDriver_RasterizerLayerObject_MergeIntoPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_layerobject_mergeinto");
		#else // _WIN32
		pWrapperTable->m_LayerObject_MergeInto = (PLibMCDriver_RasterizerLayerObject_MergeIntoPtr) dlsym(hLibrary, "libmcdriver_rasterizer_layerobject_mergeinto");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_MergeInto == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_CalculateOffset = (PLibMCDriver_RasterizerLayerObject_CalculateOffsetPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_layerobject_calculateoffset");
		#else // _WIN32
		pWrapperTable->m_LayerObject_CalculateOffset = (PLibMCDriver_RasterizerLayerObject_CalculateOffsetPtr) dlsym(hLibrary, "libmcdriver_rasterizer_layerobject_calculateoffset");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_CalculateOffset == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_ThickenPolylines = (PLibMCDriver_RasterizerLayerObject_ThickenPolylinesPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_layerobject_thickenpolylines");
		#else // _WIN32
		pWrapperTable->m_LayerObject_ThickenPolylines = (PLibMCDriver_RasterizerLayerObject_ThickenPolylinesPtr) dlsym(hLibrary, "libmcdriver_rasterizer_layerobject_thickenpolylines");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_ThickenPolylines == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_ThickenHatches = (PLibMCDriver_RasterizerLayerObject_ThickenHatchesPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_layerobject_thickenhatches");
		#else // _WIN32
		pWrapperTable->m_LayerObject_ThickenHatches = (PLibMCDriver_RasterizerLayerObject_ThickenHatchesPtr) dlsym(hLibrary, "libmcdriver_rasterizer_layerobject_thickenhatches");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_ThickenHatches == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_DistortLayer = (PLibMCDriver_RasterizerLayerObject_DistortLayerPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_layerobject_distortlayer");
		#else // _WIN32
		pWrapperTable->m_LayerObject_DistortLayer = (PLibMCDriver_RasterizerLayerObject_DistortLayerPtr) dlsym(hLibrary, "libmcdriver_rasterizer_layerobject_distortlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_DistortLayer == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetDPI = (PLibMCDriver_RasterizerRasterizer_GetDPIPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_getdpi");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetDPI = (PLibMCDriver_RasterizerRasterizer_GetDPIPtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_getdpi");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetDPI == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetSize = (PLibMCDriver_RasterizerRasterizer_GetSizePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_getsize");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetSize = (PLibMCDriver_RasterizerRasterizer_GetSizePtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetSize == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetPixelSize = (PLibMCDriver_RasterizerRasterizer_GetPixelSizePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_getpixelsize");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetPixelSize = (PLibMCDriver_RasterizerRasterizer_GetPixelSizePtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_getpixelsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetPixelSize == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetPosition = (PLibMCDriver_RasterizerRasterizer_GetPositionPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_getposition");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetPosition = (PLibMCDriver_RasterizerRasterizer_GetPositionPtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_getposition");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetPosition == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_SetPosition = (PLibMCDriver_RasterizerRasterizer_SetPositionPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_setposition");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_SetPosition = (PLibMCDriver_RasterizerRasterizer_SetPositionPtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_setposition");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_SetPosition == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_SetSubsampling = (PLibMCDriver_RasterizerRasterizer_SetSubsamplingPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_setsubsampling");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_SetSubsampling = (PLibMCDriver_RasterizerRasterizer_SetSubsamplingPtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_setsubsampling");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_SetSubsampling == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetSubsampling = (PLibMCDriver_RasterizerRasterizer_GetSubsamplingPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_getsubsampling");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetSubsampling = (PLibMCDriver_RasterizerRasterizer_GetSubsamplingPtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_getsubsampling");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetSubsampling == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_SetSamplingParameters = (PLibMCDriver_RasterizerRasterizer_SetSamplingParametersPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_setsamplingparameters");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_SetSamplingParameters = (PLibMCDriver_RasterizerRasterizer_SetSamplingParametersPtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_setsamplingparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_SetSamplingParameters == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetSamplingParameters = (PLibMCDriver_RasterizerRasterizer_GetSamplingParametersPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_getsamplingparameters");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetSamplingParameters = (PLibMCDriver_RasterizerRasterizer_GetSamplingParametersPtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_getsamplingparameters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetSamplingParameters == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_AddLayer = (PLibMCDriver_RasterizerRasterizer_AddLayerPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_addlayer");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_AddLayer = (PLibMCDriver_RasterizerRasterizer_AddLayerPtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_addlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_AddLayer == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_CalculateImage = (PLibMCDriver_RasterizerRasterizer_CalculateImagePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_rasterizer_calculateimage");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_CalculateImage = (PLibMCDriver_RasterizerRasterizer_CalculateImagePtr) dlsym(hLibrary, "libmcdriver_rasterizer_rasterizer_calculateimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_CalculateImage == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetLayerCount = (PLibMCDriver_RasterizerSliceStack_GetLayerCountPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_slicestack_getlayercount");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetLayerCount = (PLibMCDriver_RasterizerSliceStack_GetLayerCountPtr) dlsym(hLibrary, "libmcdriver_rasterizer_slicestack_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetLayerCount == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetLayerThickness = (PLibMCDriver_RasterizerSliceStack_GetLayerThicknessPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_slicestack_getlayerthickness");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetLayerThickness = (PLibMCDriver_RasterizerSliceStack_GetLayerThicknessPtr) dlsym(hLibrary, "libmcdriver_rasterizer_slicestack_getlayerthickness");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetLayerThickness == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetBottomZ = (PLibMCDriver_RasterizerSliceStack_GetBottomZPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_slicestack_getbottomz");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetBottomZ = (PLibMCDriver_RasterizerSliceStack_GetBottomZPtr) dlsym(hLibrary, "libmcdriver_rasterizer_slicestack_getbottomz");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetBottomZ == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetTopZ = (PLibMCDriver_RasterizerSliceStack_GetTopZPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_slicestack_gettopz");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetTopZ = (PLibMCDriver_RasterizerSliceStack_GetTopZPtr) dlsym(hLibrary, "libmcdriver_rasterizer_slicestack_gettopz");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetTopZ == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetLayer = (PLibMCDriver_RasterizerSliceStack_GetLayerPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_slicestack_getlayer");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetLayer = (PLibMCDriver_RasterizerSliceStack_GetLayerPtr) dlsym(hLibrary, "libmcdriver_rasterizer_slicestack_getlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetLayer == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Rasterizer_CreateSliceStack = (PLibMCDriver_RasterizerDriver_Rasterizer_CreateSliceStackPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_createslicestack");
		#else // _WIN32
		pWrapperTable->m_Driver_Rasterizer_CreateSliceStack = (PLibMCDriver_RasterizerDriver_Rasterizer_CreateSliceStackPtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_createslicestack");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Rasterizer_CreateSliceStack == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Rasterizer_CreateEmptyLayer = (PLibMCDriver_RasterizerDriver_Rasterizer_CreateEmptyLayerPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_createemptylayer");
		#else // _WIN32
		pWrapperTable->m_Driver_Rasterizer_CreateEmptyLayer = (PLibMCDriver_RasterizerDriver_Rasterizer_CreateEmptyLayerPtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_createemptylayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Rasterizer_CreateEmptyLayer == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Rasterizer_RegisterInstance = (PLibMCDriver_RasterizerDriver_Rasterizer_RegisterInstancePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_registerinstance");
		#else // _WIN32
		pWrapperTable->m_Driver_Rasterizer_RegisterInstance = (PLibMCDriver_RasterizerDriver_Rasterizer_RegisterInstancePtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_registerinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Rasterizer_RegisterInstance == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Rasterizer_UnregisterInstance = (PLibMCDriver_RasterizerDriver_Rasterizer_UnregisterInstancePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_unregisterinstance");
		#else // _WIN32
		pWrapperTable->m_Driver_Rasterizer_UnregisterInstance = (PLibMCDriver_RasterizerDriver_Rasterizer_UnregisterInstancePtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_unregisterinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Rasterizer_UnregisterInstance == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Rasterizer_HasInstance = (PLibMCDriver_RasterizerDriver_Rasterizer_HasInstancePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_hasinstance");
		#else // _WIN32
		pWrapperTable->m_Driver_Rasterizer_HasInstance = (PLibMCDriver_RasterizerDriver_Rasterizer_HasInstancePtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_hasinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Rasterizer_HasInstance == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Driver_Rasterizer_GetInstance = (PLibMCDriver_RasterizerDriver_Rasterizer_GetInstancePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_getinstance");
		#else // _WIN32
		pWrapperTable->m_Driver_Rasterizer_GetInstance = (PLibMCDriver_RasterizerDriver_Rasterizer_GetInstancePtr) dlsym(hLibrary, "libmcdriver_rasterizer_driver_rasterizer_getinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Driver_Rasterizer_GetInstance == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_RasterizerGetVersionPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDriver_RasterizerGetVersionPtr) dlsym(hLibrary, "libmcdriver_rasterizer_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_RasterizerGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDriver_RasterizerGetLastErrorPtr) dlsym(hLibrary, "libmcdriver_rasterizer_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_RasterizerReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDriver_RasterizerReleaseInstancePtr) dlsym(hLibrary, "libmcdriver_rasterizer_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_RasterizerAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDriver_RasterizerAcquireInstancePtr) dlsym(hLibrary, "libmcdriver_rasterizer_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_RasterizerInjectComponentPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCDriver_RasterizerInjectComponentPtr) dlsym(hLibrary, "libmcdriver_rasterizer_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_RasterizerGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDriver_RasterizerGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdriver_rasterizer_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_RasterizerCreateDriverPtr) GetProcAddress(hLibrary, "libmcdriver_rasterizer_createdriver");
		#else // _WIN32
		pWrapperTable->m_CreateDriver = (PLibMCDriver_RasterizerCreateDriverPtr) dlsym(hLibrary, "libmcdriver_rasterizer_createdriver");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDriver == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
	}

	inline LibMCDriver_RasterizerResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDriver_RasterizerDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM;
		
		typedef LibMCDriver_RasterizerResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDriver_RasterizerResult eLookupError = LIBMCDRIVER_RASTERIZER_SUCCESS;
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_configure", (void**)&(pWrapperTable->m_Driver_Configure));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Configure == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_getname", (void**)&(pWrapperTable->m_Driver_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetName == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_gettype", (void**)&(pWrapperTable->m_Driver_GetType));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetType == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_getversion", (void**)&(pWrapperTable->m_Driver_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetVersion == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_getheaderinformation", (void**)&(pWrapperTable->m_Driver_GetHeaderInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_GetHeaderInformation == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_queryparameters", (void**)&(pWrapperTable->m_Driver_QueryParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_QueryParameters == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_layerobject_getentitycount", (void**)&(pWrapperTable->m_LayerObject_GetEntityCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_GetEntityCount == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_layerobject_getentity", (void**)&(pWrapperTable->m_LayerObject_GetEntity));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_GetEntity == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_layerobject_addentity", (void**)&(pWrapperTable->m_LayerObject_AddEntity));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_AddEntity == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_layerobject_removeselfintersections", (void**)&(pWrapperTable->m_LayerObject_RemoveSelfIntersections));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_RemoveSelfIntersections == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_layerobject_mergeinto", (void**)&(pWrapperTable->m_LayerObject_MergeInto));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_MergeInto == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_layerobject_calculateoffset", (void**)&(pWrapperTable->m_LayerObject_CalculateOffset));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_CalculateOffset == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_layerobject_thickenpolylines", (void**)&(pWrapperTable->m_LayerObject_ThickenPolylines));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_ThickenPolylines == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_layerobject_thickenhatches", (void**)&(pWrapperTable->m_LayerObject_ThickenHatches));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_ThickenHatches == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_layerobject_distortlayer", (void**)&(pWrapperTable->m_LayerObject_DistortLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_DistortLayer == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_getdpi", (void**)&(pWrapperTable->m_Rasterizer_GetDPI));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetDPI == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_getsize", (void**)&(pWrapperTable->m_Rasterizer_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetSize == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_getpixelsize", (void**)&(pWrapperTable->m_Rasterizer_GetPixelSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetPixelSize == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_getposition", (void**)&(pWrapperTable->m_Rasterizer_GetPosition));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetPosition == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_setposition", (void**)&(pWrapperTable->m_Rasterizer_SetPosition));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_SetPosition == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_setsubsampling", (void**)&(pWrapperTable->m_Rasterizer_SetSubsampling));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_SetSubsampling == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_getsubsampling", (void**)&(pWrapperTable->m_Rasterizer_GetSubsampling));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetSubsampling == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_setsamplingparameters", (void**)&(pWrapperTable->m_Rasterizer_SetSamplingParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_SetSamplingParameters == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_getsamplingparameters", (void**)&(pWrapperTable->m_Rasterizer_GetSamplingParameters));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetSamplingParameters == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_addlayer", (void**)&(pWrapperTable->m_Rasterizer_AddLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_AddLayer == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_rasterizer_calculateimage", (void**)&(pWrapperTable->m_Rasterizer_CalculateImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_CalculateImage == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_slicestack_getlayercount", (void**)&(pWrapperTable->m_SliceStack_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetLayerCount == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_slicestack_getlayerthickness", (void**)&(pWrapperTable->m_SliceStack_GetLayerThickness));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetLayerThickness == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_slicestack_getbottomz", (void**)&(pWrapperTable->m_SliceStack_GetBottomZ));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetBottomZ == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_slicestack_gettopz", (void**)&(pWrapperTable->m_SliceStack_GetTopZ));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetTopZ == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_slicestack_getlayer", (void**)&(pWrapperTable->m_SliceStack_GetLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetLayer == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_rasterizer_createslicestack", (void**)&(pWrapperTable->m_Driver_Rasterizer_CreateSliceStack));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Rasterizer_CreateSliceStack == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_rasterizer_createemptylayer", (void**)&(pWrapperTable->m_Driver_Rasterizer_CreateEmptyLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Rasterizer_CreateEmptyLayer == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_rasterizer_registerinstance", (void**)&(pWrapperTable->m_Driver_Rasterizer_RegisterInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Rasterizer_RegisterInstance == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_rasterizer_unregisterinstance", (void**)&(pWrapperTable->m_Driver_Rasterizer_UnregisterInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Rasterizer_UnregisterInstance == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_rasterizer_hasinstance", (void**)&(pWrapperTable->m_Driver_Rasterizer_HasInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Rasterizer_HasInstance == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_driver_rasterizer_getinstance", (void**)&(pWrapperTable->m_Driver_Rasterizer_GetInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_Driver_Rasterizer_GetInstance == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdriver_rasterizer_createdriver", (void**)&(pWrapperTable->m_CreateDriver));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDriver == nullptr) )
			return LIBMCDRIVER_RASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDRIVER_RASTERIZER_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CDriver
	 */
	
	/**
	* CDriver::Configure - Configures a driver with its specific configuration data.
	* @param[in] sConfigurationString - Configuration data of driver.
	*/
	void CDriver::Configure(const std::string & sConfigurationString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Configure(m_pHandle, sConfigurationString.c_str()));
	}
	
	/**
	* CDriver::GetName - returns the name identifier of the driver
	* @return Name of the driver.
	*/
	std::string CDriver::GetName()
	{
		LibMCDriver_Rasterizer_uint32 bytesNeededName = 0;
		LibMCDriver_Rasterizer_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDriver::GetType - returns the type identifier of the driver
	* @return Type of the driver.
	*/
	std::string CDriver::GetType()
	{
		LibMCDriver_Rasterizer_uint32 bytesNeededType = 0;
		LibMCDriver_Rasterizer_uint32 bytesWrittenType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, 0, &bytesNeededType, nullptr));
		std::vector<char> bufferType(bytesNeededType);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetType(m_pHandle, bytesNeededType, &bytesWrittenType, &bufferType[0]));
		
		return std::string(&bufferType[0]);
	}
	
	/**
	* CDriver::GetVersion - returns the version identifiers of the driver
	* @param[out] nMajor - Major version.
	* @param[out] nMinor - Minor version.
	* @param[out] nMicro - Micro version.
	* @param[out] sBuild - Build identifier.
	*/
	void CDriver::GetVersion(LibMCDriver_Rasterizer_uint32 & nMajor, LibMCDriver_Rasterizer_uint32 & nMinor, LibMCDriver_Rasterizer_uint32 & nMicro, std::string & sBuild)
	{
		LibMCDriver_Rasterizer_uint32 bytesNeededBuild = 0;
		LibMCDriver_Rasterizer_uint32 bytesWrittenBuild = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, 0, &bytesNeededBuild, nullptr));
		std::vector<char> bufferBuild(bytesNeededBuild);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetVersion(m_pHandle, &nMajor, &nMinor, &nMicro, bytesNeededBuild, &bytesWrittenBuild, &bufferBuild[0]));
		sBuild = std::string(&bufferBuild[0]);
	}
	
	/**
	* CDriver::GetHeaderInformation - returns the header information
	* @param[out] sNameSpace - NameSpace of the driver.
	* @param[out] sBaseName - BaseName of the driver.
	*/
	void CDriver::GetHeaderInformation(std::string & sNameSpace, std::string & sBaseName)
	{
		LibMCDriver_Rasterizer_uint32 bytesNeededNameSpace = 0;
		LibMCDriver_Rasterizer_uint32 bytesWrittenNameSpace = 0;
		LibMCDriver_Rasterizer_uint32 bytesNeededBaseName = 0;
		LibMCDriver_Rasterizer_uint32 bytesWrittenBaseName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetHeaderInformation(m_pHandle, 0, &bytesNeededNameSpace, nullptr, 0, &bytesNeededBaseName, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		std::vector<char> bufferBaseName(bytesNeededBaseName);
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_GetHeaderInformation(m_pHandle, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0], bytesNeededBaseName, &bytesWrittenBaseName, &bufferBaseName[0]));
		sNameSpace = std::string(&bufferNameSpace[0]);
		sBaseName = std::string(&bufferBaseName[0]);
	}
	
	/**
	* CDriver::QueryParameters - Stores the driver parameters in the driver environment.
	*/
	void CDriver::QueryParameters()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_QueryParameters(m_pHandle));
	}
	
	/**
	 * Method definitions for class CLayerObject
	 */
	
	/**
	* CLayerObject::GetEntityCount - Returns count of Entity in Layer.
	* @return Number of entity in layer.
	*/
	LibMCDriver_Rasterizer_uint32 CLayerObject::GetEntityCount()
	{
		LibMCDriver_Rasterizer_uint32 resultEntityCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_GetEntityCount(m_pHandle, &resultEntityCount));
		
		return resultEntityCount;
	}
	
	/**
	* CLayerObject::GetEntity - Returns a entity in a layer.
	* @param[in] nEntityIndex - Index of entity in layer.
	* @param[out] eGeometryType - Geometry type of Entity.
	* @param[out] PointsBuffer - Points of Entity.
	*/
	void CLayerObject::GetEntity(const LibMCDriver_Rasterizer_uint32 nEntityIndex, eGeometryType & eGeometryType, std::vector<sPosition2D> & PointsBuffer)
	{
		LibMCDriver_Rasterizer_uint64 elementsNeededPoints = 0;
		LibMCDriver_Rasterizer_uint64 elementsWrittenPoints = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_GetEntity(m_pHandle, nEntityIndex, &eGeometryType, 0, &elementsNeededPoints, nullptr));
		PointsBuffer.resize((size_t) elementsNeededPoints);
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_GetEntity(m_pHandle, nEntityIndex, &eGeometryType, elementsNeededPoints, &elementsWrittenPoints, PointsBuffer.data()));
	}
	
	/**
	* CLayerObject::AddEntity - Adds a entity to a layer.
	* @param[in] PointsBuffer - Points of Entity.
	* @param[in] eGeometryType - Geometry type of Entity.
	* @return Index of entity in layer.
	*/
	LibMCDriver_Rasterizer_uint32 CLayerObject::AddEntity(const CInputVector<sPosition2D> & PointsBuffer, const eGeometryType eGeometryType)
	{
		LibMCDriver_Rasterizer_uint32 resultEntityIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_AddEntity(m_pHandle, (LibMCDriver_Rasterizer_uint64)PointsBuffer.size(), PointsBuffer.data(), eGeometryType, &resultEntityIndex));
		
		return resultEntityIndex;
	}
	
	/**
	* CLayerObject::RemoveSelfIntersections - Removes self-intersections of a layer.
	* @return New Layer Object Instance
	*/
	PLayerObject CLayerObject::RemoveSelfIntersections()
	{
		LibMCDriver_RasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_RemoveSelfIntersections(m_pHandle, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	* CLayerObject::MergeInto - Merges layer into another layer object.
	* @param[in] pOtherLayerObject - Layer object to modify.
	*/
	void CLayerObject::MergeInto(classParam<CLayerObject> pOtherLayerObject)
	{
		LibMCDriver_RasterizerHandle hOtherLayerObject = pOtherLayerObject.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_MergeInto(m_pHandle, hOtherLayerObject));
	}
	
	/**
	* CLayerObject::CalculateOffset - Calculates an offset to a layer.
	* @param[in] dOffsetValue - Offset in mm
	* @return Offsetted Layer Object Instance
	*/
	PLayerObject CLayerObject::CalculateOffset(const LibMCDriver_Rasterizer_double dOffsetValue)
	{
		LibMCDriver_RasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_CalculateOffset(m_pHandle, dOffsetValue, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	* CLayerObject::ThickenPolylines - Thickens up polylines of a layer.
	* @param[in] dThickness - Thickness in mm
	* @return Offsetted Layer Object Instance
	*/
	PLayerObject CLayerObject::ThickenPolylines(const LibMCDriver_Rasterizer_double dThickness)
	{
		LibMCDriver_RasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_ThickenPolylines(m_pHandle, dThickness, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	* CLayerObject::ThickenHatches - Thickens up hatches of a layer.
	* @param[in] dThickness - Thickness in mm
	* @return Offsetted Layer Object Instance
	*/
	PLayerObject CLayerObject::ThickenHatches(const LibMCDriver_Rasterizer_double dThickness)
	{
		LibMCDriver_RasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_ThickenHatches(m_pHandle, dThickness, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	* CLayerObject::DistortLayer - Distorts a layer with a callback function
	* @param[in] dRefinementValue - Lines longer than this value are split up in smaller segments to not loose distortion information.
	* @param[in] pDistortionCallback - pointer to the callback function.
	* @param[in] pUserData - pointer to arbitrary user data that is passed without modification to the callback.
	* @return Offsetted Layer Object Instance
	*/
	PLayerObject CLayerObject::DistortLayer(const LibMCDriver_Rasterizer_double dRefinementValue, const DistortionCallback pDistortionCallback, const LibMCDriver_Rasterizer_pvoid pUserData)
	{
		LibMCDriver_RasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_DistortLayer(m_pHandle, dRefinementValue, pDistortionCallback, pUserData, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	 * Method definitions for class CRasterizer
	 */
	
	/**
	* CRasterizer::GetDPI - Returns DPI values in X and Y.
	* @param[out] dDPIValueX - DPI value in X
	* @param[out] dDPIValueY - DPI value in Y
	*/
	void CRasterizer::GetDPI(LibMCDriver_Rasterizer_double & dDPIValueX, LibMCDriver_Rasterizer_double & dDPIValueY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetDPI(m_pHandle, &dDPIValueX, &dDPIValueY));
	}
	
	/**
	* CRasterizer::GetSize - Returns image sizes.
	* @param[out] dSizeX - Size in X in mm
	* @param[out] dSizeY - Size in Y in mm
	*/
	void CRasterizer::GetSize(LibMCDriver_Rasterizer_double & dSizeX, LibMCDriver_Rasterizer_double & dSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetSize(m_pHandle, &dSizeX, &dSizeY));
	}
	
	/**
	* CRasterizer::GetPixelSize - Returns image pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	void CRasterizer::GetPixelSize(LibMCDriver_Rasterizer_uint32 & nPixelSizeX, LibMCDriver_Rasterizer_uint32 & nPixelSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetPixelSize(m_pHandle, &nPixelSizeX, &nPixelSizeY));
	}
	
	/**
	* CRasterizer::GetPosition - Returns image position.
	* @param[out] dPositionX - Position in X in mm
	* @param[out] dPositionY - Position in Y in mm
	*/
	void CRasterizer::GetPosition(LibMCDriver_Rasterizer_double & dPositionX, LibMCDriver_Rasterizer_double & dPositionY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetPosition(m_pHandle, &dPositionX, &dPositionY));
	}
	
	/**
	* CRasterizer::SetPosition - Sets image position.
	* @param[in] dPositionX - Position in X in mm
	* @param[in] dPositionY - Position in Y in mm
	*/
	void CRasterizer::SetPosition(const LibMCDriver_Rasterizer_double dPositionX, const LibMCDriver_Rasterizer_double dPositionY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_SetPosition(m_pHandle, dPositionX, dPositionY));
	}
	
	/**
	* CRasterizer::SetSubsampling - Set subsampling values in X and Y.
	* @param[in] nSubsamplingX - Subsampling in X
	* @param[in] nSubsamplingY - Subsampling in Y
	*/
	void CRasterizer::SetSubsampling(const LibMCDriver_Rasterizer_uint32 nSubsamplingX, const LibMCDriver_Rasterizer_uint32 nSubsamplingY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_SetSubsampling(m_pHandle, nSubsamplingX, nSubsamplingY));
	}
	
	/**
	* CRasterizer::GetSubsampling - Returns subsampling values in X and Y.
	* @param[out] nSubsamplingX - Subsampling in X
	* @param[out] nSubsamplingY - Subsampling in Y
	*/
	void CRasterizer::GetSubsampling(LibMCDriver_Rasterizer_uint32 & nSubsamplingX, LibMCDriver_Rasterizer_uint32 & nSubsamplingY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetSubsampling(m_pHandle, &nSubsamplingX, &nSubsamplingY));
	}
	
	/**
	* CRasterizer::SetSamplingParameters - Set sampling parameters of algorithm.
	* @param[in] nUnitsPerSubpixel - Units per subpixel. Line coordinates will be discretized with this value. Minimum 4, Maximum 1048576. Must be even.
	* @param[in] nPixelsPerBlock - Pixels per lookup block. Improves calculation speed. Minimum 4, Maximum 1024.
	*/
	void CRasterizer::SetSamplingParameters(const LibMCDriver_Rasterizer_uint32 nUnitsPerSubpixel, const LibMCDriver_Rasterizer_uint32 nPixelsPerBlock)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_SetSamplingParameters(m_pHandle, nUnitsPerSubpixel, nPixelsPerBlock));
	}
	
	/**
	* CRasterizer::GetSamplingParameters - Returns sampling parameters of algorithm.
	* @param[out] nUnitsPerSubpixel - Units per subpixel. Line coordinates will be discretized with this value. Minimum 4, Maximum 1048576. Must be even.
	* @param[out] nPixelsPerBlock - Pixels per lookup block. Improves calculation speed. Minimum 4, Maximum 1024.
	*/
	void CRasterizer::GetSamplingParameters(LibMCDriver_Rasterizer_uint32 & nUnitsPerSubpixel, LibMCDriver_Rasterizer_uint32 & nPixelsPerBlock)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetSamplingParameters(m_pHandle, &nUnitsPerSubpixel, &nPixelsPerBlock));
	}
	
	/**
	* CRasterizer::AddLayer - Adds a layer object to subsample.
	* @param[in] pLayerObject - Layer object instance.
	*/
	void CRasterizer::AddLayer(classParam<CLayerObject> pLayerObject)
	{
		LibMCDriver_RasterizerHandle hLayerObject = pLayerObject.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_AddLayer(m_pHandle, hLayerObject));
	}
	
	/**
	* CRasterizer::CalculateImage - Calculates the image.
	* @param[in] pImageObject - ImageObject Instance to render into
	* @param[in] bAntialiased - Image output is greyscale if true, black and white with 0.5 threshold if false.
	*/
	void CRasterizer::CalculateImage(classParam<LibMCEnv::CImageData> pImageObject, const bool bAntialiased)
	{
		LibMCEnvHandle hImageObject = pImageObject.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_CalculateImage(m_pHandle, hImageObject, bAntialiased));
	}
	
	/**
	 * Method definitions for class CSliceStack
	 */
	
	/**
	* CSliceStack::GetLayerCount - Returns layer count of slice stack.
	* @return Returns number of layers
	*/
	LibMCDriver_Rasterizer_uint32 CSliceStack::GetLayerCount()
	{
		LibMCDriver_Rasterizer_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CSliceStack::GetLayerThickness - Returns layer thickness of slice stack.
	* @return Returns layer thickness in mm
	*/
	LibMCDriver_Rasterizer_double CSliceStack::GetLayerThickness()
	{
		LibMCDriver_Rasterizer_double resultLayerThickness = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetLayerThickness(m_pHandle, &resultLayerThickness));
		
		return resultLayerThickness;
	}
	
	/**
	* CSliceStack::GetBottomZ - Returns Z value of bottom of slice stack in mm.
	* @return Z-Value of bottom of slice stack
	*/
	LibMCDriver_Rasterizer_double CSliceStack::GetBottomZ()
	{
		LibMCDriver_Rasterizer_double resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetBottomZ(m_pHandle, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CSliceStack::GetTopZ - Returns Z value of top of slice stack in mm.
	* @return Z-Value of top of slice stack
	*/
	LibMCDriver_Rasterizer_double CSliceStack::GetTopZ()
	{
		LibMCDriver_Rasterizer_double resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetTopZ(m_pHandle, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CSliceStack::GetLayer - Returns layer object for a given Z Value.
	* @param[in] nLayerIndex - Index of layer.
	* @return LayerObject Instance
	*/
	PLayerObject CSliceStack::GetLayer(const LibMCDriver_Rasterizer_uint32 nLayerIndex)
	{
		LibMCDriver_RasterizerHandle hLayerObject = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetLayer(m_pHandle, nLayerIndex, &hLayerObject));
		
		if (!hLayerObject) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObject);
	}
	
	/**
	 * Method definitions for class CDriver_Rasterizer
	 */
	
	/**
	* CDriver_Rasterizer::CreateSliceStack - creates an empty slice stack.
	* @param[in] nLayerCount - Number of layers. MUST be positive.
	* @param[in] dLayerThickness - Layerthickness in mm. MUST be positive.
	* @param[in] dBottomZ - Bottom Z value in mm.
	* @return Instance of Slice Stack
	*/
	PSliceStack CDriver_Rasterizer::CreateSliceStack(const LibMCDriver_Rasterizer_uint32 nLayerCount, const LibMCDriver_Rasterizer_double dLayerThickness, const LibMCDriver_Rasterizer_double dBottomZ)
	{
		LibMCDriver_RasterizerHandle hSliceStackInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Rasterizer_CreateSliceStack(m_pHandle, nLayerCount, dLayerThickness, dBottomZ, &hSliceStackInstance));
		
		if (!hSliceStackInstance) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSliceStack>(m_pWrapper, hSliceStackInstance);
	}
	
	/**
	* CDriver_Rasterizer::CreateEmptyLayer - creates an empty layer object.
	* @return Instance of a Layer Object
	*/
	PLayerObject CDriver_Rasterizer::CreateEmptyLayer()
	{
		LibMCDriver_RasterizerHandle hLayerObject = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Rasterizer_CreateEmptyLayer(m_pHandle, &hLayerObject));
		
		if (!hLayerObject) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObject);
	}
	
	/**
	* CDriver_Rasterizer::RegisterInstance - creates a new rasterization instance.
	* @param[in] sIdentifier - Identifier object. MUST be unique.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIX - DPI in X. MUST be positive.
	* @param[in] dDPIY - DPI in Y. MUST be positive.
	* @return Instance of Rasterizer
	*/
	PRasterizer CDriver_Rasterizer::RegisterInstance(const std::string & sIdentifier, const LibMCDriver_Rasterizer_uint32 nPixelSizeX, const LibMCDriver_Rasterizer_uint32 nPixelSizeY, const LibMCDriver_Rasterizer_double dDPIX, const LibMCDriver_Rasterizer_double dDPIY)
	{
		LibMCDriver_RasterizerHandle hRasterizerInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Rasterizer_RegisterInstance(m_pHandle, sIdentifier.c_str(), nPixelSizeX, nPixelSizeY, dDPIX, dDPIY, &hRasterizerInstance));
		
		if (!hRasterizerInstance) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRasterizer>(m_pWrapper, hRasterizerInstance);
	}
	
	/**
	* CDriver_Rasterizer::UnregisterInstance - destroys a rasterization instance. Instance MUST exist.
	* @param[in] sIdentifier - Identifier object. MUST be unique.
	*/
	void CDriver_Rasterizer::UnregisterInstance(const std::string & sIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Rasterizer_UnregisterInstance(m_pHandle, sIdentifier.c_str()));
	}
	
	/**
	* CDriver_Rasterizer::HasInstance - Checks if a rasterization instance exists.
	* @param[in] sIdentifier - Identifier object. MUST be unique.
	* @return Flag if instance exists.
	*/
	bool CDriver_Rasterizer::HasInstance(const std::string & sIdentifier)
	{
		bool resultInstanceExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Rasterizer_HasInstance(m_pHandle, sIdentifier.c_str(), &resultInstanceExists));
		
		return resultInstanceExists;
	}
	
	/**
	* CDriver_Rasterizer::GetInstance - retrieves an existing rasterization instance.
	* @param[in] sIdentifier - Identifier object. MUST be unique.
	* @return Instance of Rasterizer
	*/
	PRasterizer CDriver_Rasterizer::GetInstance(const std::string & sIdentifier)
	{
		LibMCDriver_RasterizerHandle hRasterizerInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Driver_Rasterizer_GetInstance(m_pHandle, sIdentifier.c_str(), &hRasterizerInstance));
		
		if (!hRasterizerInstance) {
			CheckError(LIBMCDRIVER_RASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRasterizer>(m_pWrapper, hRasterizerInstance);
	}

} // namespace LibMCDriver_Rasterizer

#endif // __LIBMCDRIVER_RASTERIZER_CPPHEADER_DYNAMIC_CPP

