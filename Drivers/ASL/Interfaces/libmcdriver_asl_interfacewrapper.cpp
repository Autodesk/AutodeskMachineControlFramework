/*++

Copyright (C) 2024 ASL Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of ASL Inkjet Driver Interface. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 2.0.0

*/

#include "libmcdriver_asl_abi.hpp"
#include "libmcdriver_asl_interfaces.hpp"
#include "libmcdriver_asl_interfaceexception.hpp"

#include <map>

using namespace LibMCDriver_ASL::Impl;

LibMCDriver_ASLResult handleLibMCDriver_ASLException(IBase * pIBaseClass, ELibMCDriver_ASLInterfaceException & Exception)
{
	LibMCDriver_ASLResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_ASLResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDriver_ASLResult errorCode = LIBMCDRIVER_ASL_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDriver_ASLResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDriver_ASLResult errorCode = LIBMCDRIVER_ASL_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Driver
**************************************************************************************************************************/
LibMCDriver_ASLResult libmcdriver_asl_driver_configure(LibMCDriver_ASL_Driver pDriver, const char * pConfigurationString)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (pConfigurationString == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sConfigurationString(pConfigurationString);
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pIDriver->Configure(sConfigurationString);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_driver_getname(LibMCDriver_ASL_Driver pDriver, const LibMCDriver_ASL_uint32 nNameBufferSize, LibMCDriver_ASL_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sName("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIDriver->GetName();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIDriver->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCDriver_ASL_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_driver_gettype(LibMCDriver_ASL_Driver pDriver, const LibMCDriver_ASL_uint32 nTypeBufferSize, LibMCDriver_ASL_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sType("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIDriver->GetType();

			pIDriver->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIDriver->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (LibMCDriver_ASL_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_driver_getversion(LibMCDriver_ASL_Driver pDriver, LibMCDriver_ASL_uint32 * pMajor, LibMCDriver_ASL_uint32 * pMinor, LibMCDriver_ASL_uint32 * pMicro, const LibMCDriver_ASL_uint32 nBuildBufferSize, LibMCDriver_ASL_uint32* pBuildNeededChars, char * pBuildBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		if (!pMajor)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if ( (!pBuildBuffer) && !(pBuildNeededChars) )
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sBuild("");
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildBuffer == nullptr);
		if (isCacheCall) {
			pIDriver->GetVersion(*pMajor, *pMinor, *pMicro, sBuild);

			pIDriver->_setCache (new ParameterCache_4<LibMCDriver_ASL_uint32, LibMCDriver_ASL_uint32, LibMCDriver_ASL_uint32, std::string> (*pMajor, *pMinor, *pMicro, sBuild));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<LibMCDriver_ASL_uint32, LibMCDriver_ASL_uint32, LibMCDriver_ASL_uint32, std::string>*> (pIDriver->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
			cache->retrieveData (*pMajor, *pMinor, *pMicro, sBuild);
			pIDriver->_setCache (nullptr);
		}
		
		if (pBuildNeededChars)
			*pBuildNeededChars = (LibMCDriver_ASL_uint32) (sBuild.size()+1);
		if (pBuildBuffer) {
			if (sBuild.size() >= nBuildBufferSize)
				throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_BUFFERTOOSMALL);
			for (size_t iBuild = 0; iBuild < sBuild.size(); iBuild++)
				pBuildBuffer[iBuild] = sBuild[iBuild];
			pBuildBuffer[sBuild.size()] = 0;
		}
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_driver_queryparameters(LibMCDriver_ASL_Driver pDriver)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pIDriver->QueryParameters();

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_driver_queryparametersex(LibMCDriver_ASL_Driver pDriver, LibMCEnv_DriverStatusUpdateSession pDriverUpdateInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver;

	try {
		LibMCEnv::PDriverStatusUpdateSession pIDriverUpdateInstance = std::make_shared<LibMCEnv::CDriverStatusUpdateSession>(CWrapper::sPLibMCEnvWrapper.get(), pDriverUpdateInstance);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverUpdateInstance.get());
		if (!pIDriverUpdateInstance)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		IDriver* pIDriver = dynamic_cast<IDriver*>(pIBaseClass);
		if (!pIDriver)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pIDriver->QueryParametersEx(pIDriverUpdateInstance);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for DriverContext
**************************************************************************************************************************/
LibMCDriver_ASLResult libmcdriver_asl_drivercontext_getserialnumber(LibMCDriver_ASL_DriverContext pDriverContext, const LibMCDriver_ASL_uint32 nTypeBufferSize, LibMCDriver_ASL_uint32* pTypeNeededChars, char * pTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriverContext;

	try {
		if ( (!pTypeBuffer) && !(pTypeNeededChars) )
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sType("");
		IDriverContext* pIDriverContext = dynamic_cast<IDriverContext*>(pIBaseClass);
		if (!pIDriverContext)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTypeBuffer == nullptr);
		if (isCacheCall) {
			sType = pIDriverContext->GetSerialNumber();

			pIDriverContext->_setCache (new ParameterCache_1<std::string> (sType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDriverContext->_getCache ());
			if (cache == nullptr)
				throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
			cache->retrieveData (sType);
			pIDriverContext->_setCache (nullptr);
		}
		
		if (pTypeNeededChars)
			*pTypeNeededChars = (LibMCDriver_ASL_uint32) (sType.size()+1);
		if (pTypeBuffer) {
			if (sType.size() >= nTypeBufferSize)
				throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_BUFFERTOOSMALL);
			for (size_t iType = 0; iType < sType.size(); iType++)
				pTypeBuffer[iType] = sType[iType];
			pTypeBuffer[sType.size()] = 0;
		}
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_drivercontext_setpower(LibMCDriver_ASL_DriverContext pDriverContext, bool bPower)
{
	IBase* pIBaseClass = (IBase *)pDriverContext;

	try {
		IDriverContext* pIDriverContext = dynamic_cast<IDriverContext*>(pIBaseClass);
		if (!pIDriverContext)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pIDriverContext->SetPower(bPower);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_drivercontext_setprintheadmode(LibMCDriver_ASL_DriverContext pDriverContext, eLibMCDriver_ASLBoardMode eMode)
{
	IBase* pIBaseClass = (IBase *)pDriverContext;

	try {
		IDriverContext* pIDriverContext = dynamic_cast<IDriverContext*>(pIBaseClass);
		if (!pIDriverContext)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pIDriverContext->SetPrintheadMode(eMode);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_drivercontext_setfrequency(LibMCDriver_ASL_DriverContext pDriverContext, LibMCDriver_ASL_uint32 nFrequency)
{
	IBase* pIBaseClass = (IBase *)pDriverContext;

	try {
		IDriverContext* pIDriverContext = dynamic_cast<IDriverContext*>(pIBaseClass);
		if (!pIDriverContext)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pIDriverContext->SetFrequency(nFrequency);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_drivercontext_settemperature(LibMCDriver_ASL_DriverContext pDriverContext, LibMCDriver_ASL_uint8 nIndex, LibMCDriver_ASL_double dTemperature)
{
	IBase* pIBaseClass = (IBase *)pDriverContext;

	try {
		IDriverContext* pIDriverContext = dynamic_cast<IDriverContext*>(pIBaseClass);
		if (!pIDriverContext)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pIDriverContext->SetTemperature(nIndex, dTemperature);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_drivercontext_setprintstart(LibMCDriver_ASL_DriverContext pDriverContext, LibMCDriver_ASL_uint32 nStartLocation)
{
	IBase* pIBaseClass = (IBase *)pDriverContext;

	try {
		IDriverContext* pIDriverContext = dynamic_cast<IDriverContext*>(pIBaseClass);
		if (!pIDriverContext)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pIDriverContext->SetPrintStart(nStartLocation);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Driver_ASL
**************************************************************************************************************************/
LibMCDriver_ASLResult libmcdriver_asl_driver_asl_settosimulationmode(LibMCDriver_ASL_Driver_ASL pDriver_ASL)
{
	IBase* pIBaseClass = (IBase *)pDriver_ASL;

	try {
		IDriver_ASL* pIDriver_ASL = dynamic_cast<IDriver_ASL*>(pIBaseClass);
		if (!pIDriver_ASL)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pIDriver_ASL->SetToSimulationMode();

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_driver_asl_issimulationmode(LibMCDriver_ASL_Driver_ASL pDriver_ASL, bool * pSimulationModeEnabled)
{
	IBase* pIBaseClass = (IBase *)pDriver_ASL;

	try {
		if (pSimulationModeEnabled == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		IDriver_ASL* pIDriver_ASL = dynamic_cast<IDriver_ASL*>(pIBaseClass);
		if (!pIDriver_ASL)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		*pSimulationModeEnabled = pIDriver_ASL->IsSimulationMode();

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_driver_asl_connect(LibMCDriver_ASL_Driver_ASL pDriver_ASL, const char * pIdentifier, const char * pCOMPort, LibMCDriver_ASL_DriverContext * pChannelInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_ASL;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (pCOMPort == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (pChannelInstance == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		std::string sCOMPort(pCOMPort);
		IBase* pBaseChannelInstance(nullptr);
		IDriver_ASL* pIDriver_ASL = dynamic_cast<IDriver_ASL*>(pIBaseClass);
		if (!pIDriver_ASL)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pBaseChannelInstance = pIDriver_ASL->Connect(sIdentifier, sCOMPort);

		*pChannelInstance = (IBase*)(pBaseChannelInstance);
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_driver_asl_contextexists(LibMCDriver_ASL_Driver_ASL pDriver_ASL, const char * pIdentifier, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriver_ASL;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriver_ASL* pIDriver_ASL = dynamic_cast<IDriver_ASL*>(pIBaseClass);
		if (!pIDriver_ASL)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		*pValue = pIDriver_ASL->ContextExists(sIdentifier);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_driver_asl_findcontext(LibMCDriver_ASL_Driver_ASL pDriver_ASL, const char * pIdentifier, LibMCDriver_ASL_DriverContext * pChannelInstance)
{
	IBase* pIBaseClass = (IBase *)pDriver_ASL;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (pChannelInstance == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseChannelInstance(nullptr);
		IDriver_ASL* pIDriver_ASL = dynamic_cast<IDriver_ASL*>(pIBaseClass);
		if (!pIDriver_ASL)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		pBaseChannelInstance = pIDriver_ASL->FindContext(sIdentifier);

		*pChannelInstance = (IBase*)(pBaseChannelInstance);
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDriver_ASLResult LibMCDriver_ASL::Impl::LibMCDriver_ASL_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDRIVER_ASL_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDRIVER_ASL_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdriver_asl_driver_configure") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_configure;
	if (sProcName == "libmcdriver_asl_driver_getname") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_getname;
	if (sProcName == "libmcdriver_asl_driver_gettype") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_gettype;
	if (sProcName == "libmcdriver_asl_driver_getversion") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_getversion;
	if (sProcName == "libmcdriver_asl_driver_queryparameters") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_queryparameters;
	if (sProcName == "libmcdriver_asl_driver_queryparametersex") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_queryparametersex;
	if (sProcName == "libmcdriver_asl_drivercontext_getserialnumber") 
		*ppProcAddress = (void*) &libmcdriver_asl_drivercontext_getserialnumber;
	if (sProcName == "libmcdriver_asl_drivercontext_setpower") 
		*ppProcAddress = (void*) &libmcdriver_asl_drivercontext_setpower;
	if (sProcName == "libmcdriver_asl_drivercontext_setprintheadmode") 
		*ppProcAddress = (void*) &libmcdriver_asl_drivercontext_setprintheadmode;
	if (sProcName == "libmcdriver_asl_drivercontext_setfrequency") 
		*ppProcAddress = (void*) &libmcdriver_asl_drivercontext_setfrequency;
	if (sProcName == "libmcdriver_asl_drivercontext_settemperature") 
		*ppProcAddress = (void*) &libmcdriver_asl_drivercontext_settemperature;
	if (sProcName == "libmcdriver_asl_drivercontext_setprintstart") 
		*ppProcAddress = (void*) &libmcdriver_asl_drivercontext_setprintstart;
	if (sProcName == "libmcdriver_asl_driver_asl_settosimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_asl_settosimulationmode;
	if (sProcName == "libmcdriver_asl_driver_asl_issimulationmode") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_asl_issimulationmode;
	if (sProcName == "libmcdriver_asl_driver_asl_connect") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_asl_connect;
	if (sProcName == "libmcdriver_asl_driver_asl_contextexists") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_asl_contextexists;
	if (sProcName == "libmcdriver_asl_driver_asl_findcontext") 
		*ppProcAddress = (void*) &libmcdriver_asl_driver_asl_findcontext;
	if (sProcName == "libmcdriver_asl_getversion") 
		*ppProcAddress = (void*) &libmcdriver_asl_getversion;
	if (sProcName == "libmcdriver_asl_getlasterror") 
		*ppProcAddress = (void*) &libmcdriver_asl_getlasterror;
	if (sProcName == "libmcdriver_asl_releaseinstance") 
		*ppProcAddress = (void*) &libmcdriver_asl_releaseinstance;
	if (sProcName == "libmcdriver_asl_acquireinstance") 
		*ppProcAddress = (void*) &libmcdriver_asl_acquireinstance;
	if (sProcName == "libmcdriver_asl_injectcomponent") 
		*ppProcAddress = (void*) &libmcdriver_asl_injectcomponent;
	if (sProcName == "libmcdriver_asl_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdriver_asl_getsymbollookupmethod;
	if (sProcName == "libmcdriver_asl_createdriver") 
		*ppProcAddress = (void*) &libmcdriver_asl_createdriver;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDRIVER_ASL_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDRIVER_ASL_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDriver_ASLResult libmcdriver_asl_getversion(LibMCDriver_ASL_uint32 * pMajor, LibMCDriver_ASL_uint32 * pMinor, LibMCDriver_ASL_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_getlasterror(LibMCDriver_ASL_Base pInstance, const LibMCDriver_ASL_uint32 nErrorMessageBufferSize, LibMCDriver_ASL_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCDriver_ASL_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_releaseinstance(LibMCDriver_ASL_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_acquireinstance(LibMCDriver_ASL_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_injectcomponent(const char * pNameSpace, LibMCDriver_ASL_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCEnv") {
			if (CWrapper::sPLibMCEnvWrapper.get() != nullptr) {
				throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCEnvWrapper = LibMCEnv::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCDriver_ASLInterfaceException(LIBMCDRIVER_ASL_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_getsymbollookupmethod(LibMCDriver_ASL_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCDriver_ASL::Impl::LibMCDriver_ASL_GetProcAddress;
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDriver_ASLResult libmcdriver_asl_createdriver(const char * pName, const char * pType, LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCDriver_ASL_Driver * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pName == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (pType == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		if (pInstance == nullptr)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sType(pType);
		LibMCEnv::PDriverEnvironment pIDriverEnvironment = std::make_shared<LibMCEnv::CDriverEnvironment>(CWrapper::sPLibMCEnvWrapper.get(), pDriverEnvironment);
		CWrapper::sPLibMCEnvWrapper->AcquireInstance(pIDriverEnvironment.get());
		if (!pIDriverEnvironment)
			throw ELibMCDriver_ASLInterfaceException (LIBMCDRIVER_ASL_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDriver(sName, sType, pIDriverEnvironment);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDRIVER_ASL_SUCCESS;
	}
	catch (ELibMCDriver_ASLInterfaceException & Exception) {
		return handleLibMCDriver_ASLException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


