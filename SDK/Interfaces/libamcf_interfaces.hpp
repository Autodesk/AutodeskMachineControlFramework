/*++

Copyright (C) 2021 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ header file in order to allow easy
development of Autodesk Machine Control Framework SDK. The implementer of Autodesk Machine Control Framework SDK needs to
derive concrete classes from the abstract classes in this header.

Interface version: 1.0.0

*/


#ifndef __LIBAMCF_CPPINTERFACES
#define __LIBAMCF_CPPINTERFACES

#include <string>
#include <memory>

#include "libamcf_types.hpp"



namespace LibAMCF {
namespace Impl {

/**
 Forward declarations of class interfaces
*/
class IBase;
class IOperationResult;
class IDataStream;
class IStreamUpload;
class IConnection;



/*************************************************************************************************************************
 Parameter Cache definitions
**************************************************************************************************************************/

class ParameterCache {
	public:
		virtual ~ParameterCache() {}
};

template <class T1> class ParameterCache_1 : public ParameterCache {
	private:
		T1 m_param1;
	public:
		ParameterCache_1 (const T1 & param1)
			: m_param1 (param1)
		{
		}

		void retrieveData (T1 & param1)
		{
			param1 = m_param1;
		}
};

template <class T1, class T2> class ParameterCache_2 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
	public:
		ParameterCache_2 (const T1 & param1, const T2 & param2)
			: m_param1 (param1), m_param2 (param2)
		{
		}

		void retrieveData (T1 & param1, T2 & param2)
		{
			param1 = m_param1;
			param2 = m_param2;
		}
};

template <class T1, class T2, class T3> class ParameterCache_3 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
	public:
		ParameterCache_3 (const T1 & param1, const T2 & param2, const T3 & param3)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
		}
};

template <class T1, class T2, class T3, class T4> class ParameterCache_4 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
		T4 m_param4;
	public:
		ParameterCache_4 (const T1 & param1, const T2 & param2, const T3 & param3, const T4 & param4)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3), m_param4 (param4)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3, T4 & param4)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
			param4 = m_param4;
		}
};


/*************************************************************************************************************************
 Class interface for Base 
**************************************************************************************************************************/

class IBase {
private:
	std::unique_ptr<ParameterCache> m_ParameterCache;
public:
	/**
	* IBase::~IBase - virtual destructor of IBase
	*/
	virtual ~IBase() {};

	/**
	* IBase::ReleaseBaseClassInterface - Releases ownership of a base class interface. Deletes the reference, if necessary.
	* @param[in] pIBase - The base class instance to release
	*/
	static void ReleaseBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->DecRefCount();
		}
	};

	/**
	* IBase::AcquireBaseClassInterface - Acquires shared ownership of a base class interface.
	* @param[in] pIBase - The base class instance to acquire
	*/
	static void AcquireBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->IncRefCount();
		}
	};


	/**
	* IBase::GetLastErrorMessage - Returns the last error registered of this class instance
	* @param[out] sErrorMessage - Message of the last error registered
	* @return Has an error been registered already
	*/
	virtual bool GetLastErrorMessage(std::string & sErrorMessage) = 0;

	/**
	* IBase::ClearErrorMessages - Clears all registered messages of this class instance
	*/
	virtual void ClearErrorMessages() = 0;

	/**
	* IBase::RegisterErrorMessage - Registers an error message with this class instance
	* @param[in] sErrorMessage - Error message to register
	*/
	virtual void RegisterErrorMessage(const std::string & sErrorMessage) = 0;

	/**
	* IBase::IncRefCount - Increases the reference count of a class instance
	*/
	virtual void IncRefCount() = 0;

	/**
	* IBase::DecRefCount - Decreases the reference count of a class instance and free releases it, if the last reference has been removed
	* @return Has the object been released
	*/
	virtual bool DecRefCount() = 0;

	/**
	* IBase::_setCache - set parameter cache of object
	*/
	void _setCache(ParameterCache * pCache)
	{
		m_ParameterCache.reset(pCache);
	}

	/**
	* IBase::_getCache - returns parameter cache of object
	*/
	ParameterCache* _getCache()
	{
		return m_ParameterCache.get();
	}

};


/**
 Definition of a shared pointer class for IBase
*/
template<class T>
class IBaseSharedPtr : public std::shared_ptr<T>
{
public:
	explicit IBaseSharedPtr(T* t = nullptr)
		: std::shared_ptr<T>(t, IBase::ReleaseBaseClassInterface)
	{
		t->IncRefCount();
	}

	// Reset function, as it also needs to properly set the deleter.
	void reset(T* t = nullptr)
	{
		std::shared_ptr<T>::reset(t, IBase::ReleaseBaseClassInterface);
	}

	// Get-function that increases the Base class's reference count
	T* getCoOwningPtr()
	{
		T* t = this->get();
		t->IncRefCount();
		return t;
	}
};


typedef IBaseSharedPtr<IBase> PIBase;


/*************************************************************************************************************************
 Class interface for OperationResult 
**************************************************************************************************************************/

class IOperationResult : public virtual IBase {
public:
	/**
	* IOperationResult::WaitFor - Waits for operation to be finished.
	* @param[in] nTimeOut - Timeout value in Milliseconds. 0 means forever.
	* @return Returns if operation has been finished.
	*/
	virtual bool WaitFor(const LibAMCF_uint32 nTimeOut) = 0;

	/**
	* IOperationResult::EnsureSuccess - Waits for operation to be successfully finished. Throws an error if not successful.
	*/
	virtual void EnsureSuccess() = 0;

	/**
	* IOperationResult::InProgress - Checks if operation is in progress.
	* @return Flag if operation is in progress.
	*/
	virtual bool InProgress() = 0;

	/**
	* IOperationResult::Success - Checks if operation has been finished successfully. Waits for operation to finish.
	* @return Flag if operation has been finished successful.
	*/
	virtual bool Success() = 0;

	/**
	* IOperationResult::GetErrorMessage - Returns the error message, if the operation has not been successful. Fails if operation is in progress.
	* @return Returns error message of failed operation.
	*/
	virtual std::string GetErrorMessage() = 0;

};

typedef IBaseSharedPtr<IOperationResult> PIOperationResult;


/*************************************************************************************************************************
 Class interface for DataStream 
**************************************************************************************************************************/

class IDataStream : public virtual IBase {
public:
	/**
	* IDataStream::GetUUID - Returns the stream UUID.
	* @return Stream UUID String.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IDataStream::GetContext - Returns the stream's context type and owner UUID.
	* @param[out] eContextType - Stream Context Type.
	* @param[out] sOwnerUUID - Stream Context UUID String.
	*/
	virtual void GetContext(LibAMCF::eStreamContextType & eContextType, std::string & sOwnerUUID) = 0;

	/**
	* IDataStream::GetName - Returns the stream name.
	* @return Stream Name.
	*/
	virtual std::string GetName() = 0;

	/**
	* IDataStream::GetMimeType - Returns the stream's mime type.
	* @return Mime Type string.
	*/
	virtual std::string GetMimeType() = 0;

	/**
	* IDataStream::GetSHA256 - Returns the sha256 checksum of the stream.
	* @return SHA256 string.
	*/
	virtual std::string GetSHA256() = 0;

	/**
	* IDataStream::GetSize - Returns the stream size.
	* @return Stream size.
	*/
	virtual LibAMCF_uint64 GetSize() = 0;

	/**
	* IDataStream::GetTimestamp - Returns the timestamp of the stream.
	* @return Timestamp string.
	*/
	virtual std::string GetTimestamp() = 0;

};

typedef IBaseSharedPtr<IDataStream> PIDataStream;


/*************************************************************************************************************************
 Class interface for StreamUpload 
**************************************************************************************************************************/

class IStreamUpload : public virtual IBase {
public:
	/**
	* IStreamUpload::GetName - returns the name of the stream upload
	* @return Name String.
	*/
	virtual std::string GetName() = 0;

	/**
	* IStreamUpload::GetMimeType - returns the mimetype of the stream upload
	* @return MimeType String.
	*/
	virtual std::string GetMimeType() = 0;

	/**
	* IStreamUpload::GetContextType - returns the usage context of the stream upload
	* @return Stream Context Type.
	*/
	virtual LibAMCF::eStreamContextType GetContextType() = 0;

	/**
	* IStreamUpload::UploadData - uploads the passed data to the server. MUST only be called once.
	* @param[in] nDataBufferSize - Number of elements in buffer
	* @param[in] pDataBuffer - Data to be uploaded.
	* @param[in] nChunkSize - Chunk size to use in bytes. MUST be a multiple of 64kB. MUST be at least 64kB and less than 64MB.
	* @param[in] nThreadCount - How many concurrent threads shall be maximally used.
	* @return Returns if upload was successful.
	*/
	virtual IOperationResult * UploadData(const LibAMCF_uint64 nDataBufferSize, const LibAMCF_uint8 * pDataBuffer, const LibAMCF_uint32 nChunkSize, const LibAMCF_uint32 nThreadCount) = 0;

	/**
	* IStreamUpload::UploadFile - uploads a file to the server. MUST only be called once.
	* @param[in] sFileName - File to be uploaded.
	* @param[in] nChunkSize - Chunk size to use in bytes. MUST be a multiple of 64kB. MUST be at least 64kB and less than 64MB.
	* @param[in] nThreadCount - How many concurrent threads shall be maximally used.
	* @return Returns if upload was successful.
	*/
	virtual IOperationResult * UploadFile(const std::string & sFileName, const LibAMCF_uint32 nChunkSize, const LibAMCF_uint32 nThreadCount) = 0;

	/**
	* IStreamUpload::BeginChunking - Starts a chunked upload. MUST not be used together with uploadData or uploadFile
	* @param[in] nDataSize - Full data size to be uploaded.
	* @return Returns if request was successful.
	*/
	virtual IOperationResult * BeginChunking(const LibAMCF_uint64 nDataSize) = 0;

	/**
	* IStreamUpload::UploadChunk - Uploads another chunk to the server. Chunks are added sequentially together.
	* @param[in] nDataBufferSize - Number of elements in buffer
	* @param[in] pDataBuffer - Data to be uploaded. Any chunk that is not the last chunk MUST have the size of a multiple of 64kB. A chunk MUST be less than 64MB.
	* @return Returns if request was successful.
	*/
	virtual IOperationResult * UploadChunk(const LibAMCF_uint64 nDataBufferSize, const LibAMCF_uint8 * pDataBuffer) = 0;

	/**
	* IStreamUpload::FinishChunking - MUST only be called after all chunks have been uploaded.
	* @return Returns if request was successful.
	*/
	virtual IOperationResult * FinishChunking() = 0;

	/**
	* IStreamUpload::GetStatus - Retrieves current upload status.
	* @param[out] nUploadSize - Total target size of the upload. 0 if no upload has been started.
	* @param[out] nFinishedSize - Current bytes that have been successfully uploaded.
	* @param[out] nInProgressSize - Current bytes that have been uploaded or are currently in progress.
	* @param[out] bFinished - Flag if upload has successfully finished.
	*/
	virtual void GetStatus(LibAMCF_uint64 & nUploadSize, LibAMCF_uint64 & nFinishedSize, LibAMCF_uint64 & nInProgressSize, bool & bFinished) = 0;

	/**
	* IStreamUpload::GetDataStream - Retrieves the uploaded data stream object. Upload must have finished successfully.
	* @return Data stream instance.
	*/
	virtual IDataStream * GetDataStream() = 0;

};

typedef IBaseSharedPtr<IStreamUpload> PIStreamUpload;


/*************************************************************************************************************************
 Class interface for Connection 
**************************************************************************************************************************/

class IConnection : public virtual IBase {
public:
	/**
	* IConnection::GetBaseURL - returns the base url of the AMCF instance
	* @return Base URL of the AMCF instance.
	*/
	virtual std::string GetBaseURL() = 0;

	/**
	* IConnection::SetTimeouts - sets the timeout behaviour of the connection.
	* @param[in] nTimeout - Request timeout in milliseconds. Default is 1000.
	* @param[in] nRetryCount - How many retries should be done in an error case. Default is 3.
	*/
	virtual void SetTimeouts(const LibAMCF_uint32 nTimeout, const LibAMCF_uint32 nRetryCount) = 0;

	/**
	* IConnection::GetTimeout - gets the timeout behaviour of the connection.
	* @return Request timeout in milliseconds
	*/
	virtual LibAMCF_uint32 GetTimeout() = 0;

	/**
	* IConnection::GetRetryCount - gets the timeout behaviour of the connection.
	* @return How many retries should be done in an error case.
	*/
	virtual LibAMCF_uint32 GetRetryCount() = 0;

	/**
	* IConnection::AuthenticateWithPassword - Authenticates with the remote instance with username and password.
	* @param[in] sUserName - User name for authentication.
	* @param[in] sPassword - Password for authentication.
	* @return Returns if authentication was successful.
	*/
	virtual IOperationResult * AuthenticateWithPassword(const std::string & sUserName, const std::string & sPassword) = 0;

	/**
	* IConnection::IsAuthenticated - Authenticates with the remote instance with username and password
	* @return Returns if connection is authenticated.
	*/
	virtual bool IsAuthenticated() = 0;

	/**
	* IConnection::RefreshAuthentication - Refreshes authentication with server.
	* @return Returns if authentication refresh was successful.
	*/
	virtual IOperationResult * RefreshAuthentication() = 0;

	/**
	* IConnection::Ping - Detects if server is still reachable. Non-Blocking.
	* @return Returns if server is still reachable.
	*/
	virtual IOperationResult * Ping() = 0;

	/**
	* IConnection::GetAuthToken - Returns the authentication token of the current connection.
	* @return Token string.
	*/
	virtual std::string GetAuthToken() = 0;

	/**
	* IConnection::CreateUpload - Creates a file upload instance. Must be authenticated to make it work.
	* @param[in] sName - Name of the file to be uploaded.
	* @param[in] sMimeType - Mimetype of the file to be uploaded.
	* @param[in] eContextType - Stream Context Type.
	* @return File upload instance.
	*/
	virtual IStreamUpload * CreateUpload(const std::string & sName, const std::string & sMimeType, const LibAMCF::eStreamContextType eContextType) = 0;

	/**
	* IConnection::PrepareBuild - Prepares a build from an uploaded data stream. Must be authenticated to make it work.
	* @param[in] pDataStream - Data stream MUST have been created as build job context type.
	* @return Returns if build preparation was successful.
	*/
	virtual IOperationResult * PrepareBuild(IDataStream* pDataStream) = 0;

};

typedef IBaseSharedPtr<IConnection> PIConnection;


/*************************************************************************************************************************
 Global functions declarations
**************************************************************************************************************************/
class CWrapper {
public:
	/**
	* Ilibamcf::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	static void GetVersion(LibAMCF_uint32 & nMajor, LibAMCF_uint32 & nMinor, LibAMCF_uint32 & nMicro);

	/**
	* Ilibamcf::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	static bool GetLastError(IBase* pInstance, std::string & sErrorMessage);

	/**
	* Ilibamcf::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void ReleaseInstance(IBase* pInstance);

	/**
	* Ilibamcf::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void AcquireInstance(IBase* pInstance);

	/**
	* Ilibamcf::CreateConnection - Creates a AMCF connection instance.
	* @param[in] sBaseURL - Base URL of the AMCF Instance.
	* @return New Connection instance
	*/
	static IConnection * CreateConnection(const std::string & sBaseURL);

};

LibAMCFResult LibAMCF_GetProcAddress (const char * pProcName, void ** ppProcAddress);

} // namespace Impl
} // namespace LibAMCF

#endif // __LIBAMCF_CPPINTERFACES
