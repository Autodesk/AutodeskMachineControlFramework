/*++

Copyright (C) 2021 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated Go wrapper file in order to allow an easy
use of Autodesk Machine Control Framework SDK.

Interface version: 1.0.0

*/

// Code generated by Automatic Component Toolkit (ACT); DO NOT EDIT.

package libamcf

/*
#include "libamcf_dynamic.cc"


LibAMCFHandle loadLibAMCFLibrary (const char * pFileName)
{
	LibAMCFResult nResult;
	sLibAMCFDynamicWrapperTable * pWrapperTable = (sLibAMCFDynamicWrapperTable *) malloc (sizeof (sLibAMCFDynamicWrapperTable));
	if (pWrapperTable != NULL) {
		nResult = InitLibAMCFWrapperTable (pWrapperTable);
		if (nResult != LIBAMCF_SUCCESS) {
			free (pWrapperTable);
			return 0;
		}

		nResult = LoadLibAMCFWrapperTable (pWrapperTable, pFileName);
		if (nResult != LIBAMCF_SUCCESS) {
			free (pWrapperTable);
			return 0;
		}

		return (LibAMCFHandle) pWrapperTable;
	}
}

void unloadLibAMCFLibrary (LibAMCFHandle nLibraryHandle)
{
	sLibAMCFDynamicWrapperTable * pWrapperTable = (sLibAMCFDynamicWrapperTable *) malloc (sizeof (sLibAMCFDynamicWrapperTable));
	if (pWrapperTable != NULL) {
		ReleaseLibAMCFWrapperTable (pWrapperTable);
		free (pWrapperTable);
	}
}


LibAMCFResult CCall_libamcf_operationresult_waitfor(LibAMCFHandle libraryHandle, LibAMCF_OperationResult pOperationResult, LibAMCF_uint32 nTimeOut, bool * pOperationFinished)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_OperationResult_WaitFor (pOperationResult, nTimeOut, pOperationFinished);
}


LibAMCFResult CCall_libamcf_operationresult_inprogress(LibAMCFHandle libraryHandle, LibAMCF_OperationResult pOperationResult, bool * pOperationIsInProgress)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_OperationResult_InProgress (pOperationResult, pOperationIsInProgress);
}


LibAMCFResult CCall_libamcf_operationresult_success(LibAMCFHandle libraryHandle, LibAMCF_OperationResult pOperationResult, bool * pOperationSuccess)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_OperationResult_Success (pOperationResult, pOperationSuccess);
}


LibAMCFResult CCall_libamcf_operationresult_geterrormessage(LibAMCFHandle libraryHandle, LibAMCF_OperationResult pOperationResult, const LibAMCF_uint32 nErrorMessageBufferSize, LibAMCF_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_OperationResult_GetErrorMessage (pOperationResult, nErrorMessageBufferSize, pErrorMessageNeededChars, pErrorMessageBuffer);
}


LibAMCFResult CCall_libamcf_datastream_getuuid(LibAMCFHandle libraryHandle, LibAMCF_DataStream pDataStream, const LibAMCF_uint32 nUUIDBufferSize, LibAMCF_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataStream_GetUUID (pDataStream, nUUIDBufferSize, pUUIDNeededChars, pUUIDBuffer);
}


LibAMCFResult CCall_libamcf_datastream_getcontextuuid(LibAMCFHandle libraryHandle, LibAMCF_DataStream pDataStream, const LibAMCF_uint32 nContextUUIDBufferSize, LibAMCF_uint32* pContextUUIDNeededChars, char * pContextUUIDBuffer)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataStream_GetContextUUID (pDataStream, nContextUUIDBufferSize, pContextUUIDNeededChars, pContextUUIDBuffer);
}


LibAMCFResult CCall_libamcf_datastream_getname(LibAMCFHandle libraryHandle, LibAMCF_DataStream pDataStream, const LibAMCF_uint32 nNameBufferSize, LibAMCF_uint32* pNameNeededChars, char * pNameBuffer)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataStream_GetName (pDataStream, nNameBufferSize, pNameNeededChars, pNameBuffer);
}


LibAMCFResult CCall_libamcf_datastream_getmimetype(LibAMCFHandle libraryHandle, LibAMCF_DataStream pDataStream, const LibAMCF_uint32 nMimeTypeBufferSize, LibAMCF_uint32* pMimeTypeNeededChars, char * pMimeTypeBuffer)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataStream_GetMimeType (pDataStream, nMimeTypeBufferSize, pMimeTypeNeededChars, pMimeTypeBuffer);
}


LibAMCFResult CCall_libamcf_datastream_getsize(LibAMCFHandle libraryHandle, LibAMCF_DataStream pDataStream, LibAMCF_uint64 * pStreamSize)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataStream_GetSize (pDataStream, pStreamSize);
}


LibAMCFResult CCall_libamcf_streamupload_uploaddata(LibAMCFHandle libraryHandle, LibAMCF_StreamUpload pStreamUpload, LibAMCF_uint64 nDataBufferSize, const LibAMCF_uint8 * pDataBuffer, LibAMCF_uint32 nChunkSize, LibAMCF_OperationResult * pSuccess)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StreamUpload_UploadData (pStreamUpload, nDataBufferSize, pDataBuffer, nChunkSize, pSuccess);
}


LibAMCFResult CCall_libamcf_streamupload_uploadfile(LibAMCFHandle libraryHandle, LibAMCF_StreamUpload pStreamUpload, const char * pFileName, LibAMCF_uint32 nChunkSize, LibAMCF_OperationResult * pSuccess)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StreamUpload_UploadFile (pStreamUpload, pFileName, nChunkSize, pSuccess);
}


LibAMCFResult CCall_libamcf_streamupload_beginchunking(LibAMCFHandle libraryHandle, LibAMCF_StreamUpload pStreamUpload, LibAMCF_uint64 nDataSize)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StreamUpload_BeginChunking (pStreamUpload, nDataSize);
}


LibAMCFResult CCall_libamcf_streamupload_uploadchunk(LibAMCFHandle libraryHandle, LibAMCF_StreamUpload pStreamUpload, LibAMCF_uint64 nDataBufferSize, const LibAMCF_uint8 * pDataBuffer, LibAMCF_OperationResult * pSuccess)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StreamUpload_UploadChunk (pStreamUpload, nDataBufferSize, pDataBuffer, pSuccess);
}


LibAMCFResult CCall_libamcf_streamupload_finishchunking(LibAMCFHandle libraryHandle, LibAMCF_StreamUpload pStreamUpload, LibAMCF_uint64 nDataBufferSize, const LibAMCF_uint8 * pDataBuffer, LibAMCF_OperationResult * pSuccess)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StreamUpload_FinishChunking (pStreamUpload, nDataBufferSize, pDataBuffer, pSuccess);
}


LibAMCFResult CCall_libamcf_streamupload_getstatus(LibAMCFHandle libraryHandle, LibAMCF_StreamUpload pStreamUpload, LibAMCF_uint64 * pUploadSize, LibAMCF_uint64 * pUploadedBytes, bool * pFinished)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StreamUpload_GetStatus (pStreamUpload, pUploadSize, pUploadedBytes, pFinished);
}


LibAMCFResult CCall_libamcf_streamupload_getdatastream(LibAMCFHandle libraryHandle, LibAMCF_StreamUpload pStreamUpload, LibAMCF_DataStream * pDataStream)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StreamUpload_GetDataStream (pStreamUpload, pDataStream);
}


LibAMCFResult CCall_libamcf_connection_getbaseurl(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, const LibAMCF_uint32 nBaseURLBufferSize, LibAMCF_uint32* pBaseURLNeededChars, char * pBaseURLBuffer)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_GetBaseURL (pConnection, nBaseURLBufferSize, pBaseURLNeededChars, pBaseURLBuffer);
}


LibAMCFResult CCall_libamcf_connection_settimeouts(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, LibAMCF_uint32 nTimeout, LibAMCF_uint32 nRetryCount)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_SetTimeouts (pConnection, nTimeout, nRetryCount);
}


LibAMCFResult CCall_libamcf_connection_gettimeout(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, LibAMCF_uint32 * pTimeout)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_GetTimeout (pConnection, pTimeout);
}


LibAMCFResult CCall_libamcf_connection_getretrycount(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, LibAMCF_uint32 * pRetryCount)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_GetRetryCount (pConnection, pRetryCount);
}


LibAMCFResult CCall_libamcf_connection_authenticatewithpassword(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, const char * pUserName, const char * pPassword, LibAMCF_OperationResult * pSuccess)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_AuthenticateWithPassword (pConnection, pUserName, pPassword, pSuccess);
}


LibAMCFResult CCall_libamcf_connection_isauthenticated(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, bool * pIsAuthenticated)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_IsAuthenticated (pConnection, pIsAuthenticated);
}


LibAMCFResult CCall_libamcf_connection_refreshauthentication(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, LibAMCF_OperationResult * pSuccess)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_RefreshAuthentication (pConnection, pSuccess);
}


LibAMCFResult CCall_libamcf_connection_ping(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, LibAMCF_OperationResult * pSuccess)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_Ping (pConnection, pSuccess);
}


LibAMCFResult CCall_libamcf_connection_getauthtoken(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, const LibAMCF_uint32 nTokenBufferSize, LibAMCF_uint32* pTokenNeededChars, char * pTokenBuffer)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_GetAuthToken (pConnection, nTokenBufferSize, pTokenNeededChars, pTokenBuffer);
}


LibAMCFResult CCall_libamcf_connection_createupload(LibAMCFHandle libraryHandle, LibAMCF_Connection pConnection, const char * pName, const char * pMimeType, const char * pUsageContext, LibAMCF_StreamUpload * pInstance)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Connection_CreateUpload (pConnection, pName, pMimeType, pUsageContext, pInstance);
}


LibAMCFResult CCall_libamcf_getversion(LibAMCFHandle libraryHandle, LibAMCF_uint32 * pMajor, LibAMCF_uint32 * pMinor, LibAMCF_uint32 * pMicro)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_GetVersion (pMajor, pMinor, pMicro);
}


LibAMCFResult CCall_libamcf_getlasterror(LibAMCFHandle libraryHandle, LibAMCF_Base pInstance, const LibAMCF_uint32 nErrorMessageBufferSize, LibAMCF_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_GetLastError (pInstance, nErrorMessageBufferSize, pErrorMessageNeededChars, pErrorMessageBuffer, pHasError);
}


LibAMCFResult CCall_libamcf_releaseinstance(LibAMCFHandle libraryHandle, LibAMCF_Base pInstance)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_ReleaseInstance (pInstance);
}


LibAMCFResult CCall_libamcf_acquireinstance(LibAMCFHandle libraryHandle, LibAMCF_Base pInstance)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_AcquireInstance (pInstance);
}


LibAMCFResult CCall_libamcf_injectcomponent(LibAMCFHandle libraryHandle, const char * pNameSpace, LibAMCF_pvoid pSymbolAddressMethod)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_InjectComponent (pNameSpace, pSymbolAddressMethod);
}


LibAMCFResult CCall_libamcf_getsymbollookupmethod(LibAMCFHandle libraryHandle, LibAMCF_pvoid * pSymbolLookupMethod)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_GetSymbolLookupMethod (pSymbolLookupMethod);
}


LibAMCFResult CCall_libamcf_createconnection(LibAMCFHandle libraryHandle, const char * pBaseURL, LibAMCF_Connection * pInstance)
{
	if (libraryHandle == 0) 
		return LIBAMCF_ERROR_INVALIDCAST;
	sLibAMCFDynamicWrapperTable * wrapperTable = (sLibAMCFDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_CreateConnection (pBaseURL, pInstance);
}

*/
import "C"

import (
	"fmt"
	"unsafe"
	"runtime"
)

type ref = C.LibAMCFHandle

// Error constants for LibAMCF.
const LIBAMCF_ERROR_NOTIMPLEMENTED = 1;
const LIBAMCF_ERROR_INVALIDPARAM = 2;
const LIBAMCF_ERROR_INVALIDCAST = 3;
const LIBAMCF_ERROR_BUFFERTOOSMALL = 4;
const LIBAMCF_ERROR_GENERICEXCEPTION = 5;
const LIBAMCF_ERROR_COULDNOTLOADLIBRARY = 6;
const LIBAMCF_ERROR_COULDNOTFINDLIBRARYEXPORT = 7;
const LIBAMCF_ERROR_INCOMPATIBLEBINARYVERSION = 8;
const LIBAMCF_ERROR_INVALIDTIMEOUT = 9;
const LIBAMCF_ERROR_INVALIDRETRYCOUNT = 10;
const LIBAMCF_ERROR_INVALIDBASEURL = 11;
const LIBAMCF_ERROR_INVALIDKEYNAME = 12;
const LIBAMCF_ERROR_RESTRESPONSEISNOOBJECT = 13;
const LIBAMCF_ERROR_COULDNOTPARSERESTRESPONSE = 14;
const LIBAMCF_ERROR_RESTRESPONSETIMEOUT = 15;
const LIBAMCF_ERROR_INVALIDRESTRESPONSE = 16;
const LIBAMCF_ERROR_COULDNOTCREATESESSION = 17;
const LIBAMCF_ERROR_COULDNOTRECEIVETOKEN = 18;
const LIBAMCF_ERROR_OPERATIONRESULTNOTREADY = 19;
const LIBAMCF_ERROR_RESTERROR = 20;

// WrappedError is an error that wraps a LibAMCF error.
type WrappedError struct {
	Code uint32
	Message string
}

func (e *WrappedError) Error() string {
	return fmt.Sprintf("libamcf: %s (%d)", e.Message, e.Code)
}

func errorMessage(errorcode uint32) string {
	switch (errorcode) {
	case LIBAMCF_ERROR_NOTIMPLEMENTED:
		return "functionality not implemented";
	case LIBAMCF_ERROR_INVALIDPARAM:
		return "an invalid parameter was passed";
	case LIBAMCF_ERROR_INVALIDCAST:
		return "a type cast failed";
	case LIBAMCF_ERROR_BUFFERTOOSMALL:
		return "a provided buffer is too small";
	case LIBAMCF_ERROR_GENERICEXCEPTION:
		return "a generic exception occurred";
	case LIBAMCF_ERROR_COULDNOTLOADLIBRARY:
		return "the library could not be loaded";
	case LIBAMCF_ERROR_COULDNOTFINDLIBRARYEXPORT:
		return "a required exported symbol could not be found in the library";
	case LIBAMCF_ERROR_INCOMPATIBLEBINARYVERSION:
		return "the version of the binary interface does not match the bindings interface";
	case LIBAMCF_ERROR_INVALIDTIMEOUT:
		return "invalid timeout";
	case LIBAMCF_ERROR_INVALIDRETRYCOUNT:
		return "invalid retry count";
	case LIBAMCF_ERROR_INVALIDBASEURL:
		return "invalid base url";
	case LIBAMCF_ERROR_INVALIDKEYNAME:
		return "invalid key name";
	case LIBAMCF_ERROR_RESTRESPONSEISNOOBJECT:
		return "REST response is no object";
	case LIBAMCF_ERROR_COULDNOTPARSERESTRESPONSE:
		return "Could not parse REST response";
	case LIBAMCF_ERROR_RESTRESPONSETIMEOUT:
		return "REST response timeout";
	case LIBAMCF_ERROR_INVALIDRESTRESPONSE:
		return "Invalid REST response";
	case LIBAMCF_ERROR_COULDNOTCREATESESSION:
		return "Could not create session";
	case LIBAMCF_ERROR_COULDNOTRECEIVETOKEN:
		return "Could not retrieve token";
	case LIBAMCF_ERROR_OPERATIONRESULTNOTREADY:
		return "Operation result is not ready";
	case LIBAMCF_ERROR_RESTERROR:
		return "REST error:";
	default:
		return "unknown";
	}
}

func makeError(errorcode uint32) error {
	return &WrappedError{errorcode, errorMessage(uint32(errorcode))}
}

// Wrapper represents the number wrapper
type Wrapper struct {
	_ [0]func() // uncomparable; to make == not compile
	LibraryHandle C.LibMCHandle
}

// Base represents a LibAMCF class.
type Base struct {
	_     		[0]func() // uncomparable; to make == not compile
	Ref   		ref       // identifies a C value, see ref type
	wrapperRef Wrapper
	gcPtr 		*ref      // used to trigger the finalizer when the Value is not referenced any more
}

// NewBase creates a new Base.
// The wrapped C pointer will be freed when the Go pointer is finalized,
// but one can release it manually calling Release.
func (wrapper Wrapper) NewBase(r ref) Base {
	gcPtr := new(ref)
	*gcPtr = r
	runtime.SetFinalizer(gcPtr, wrapper.releaseC)
	return Base{Ref: r, gcPtr: gcPtr, wrapperRef: wrapper}
}

// Release releases the C pointer.
func (inst Base) Release() error {
	err := inst.wrapperRef.ReleaseInstance(inst)
	*inst.gcPtr = nil
	return err
}

// Equal reports whether inst and w refer to the same C pointer.
func (inst Base) Equal(w Base) bool {
	return inst.Ref == w.Ref
}

// OperationResult represents a LibAMCF class.
type OperationResult struct {
	Base
}

func (wrapper Wrapper) NewOperationResult(r ref) OperationResult {
	return OperationResult{wrapper.NewBase(r)}
}

// WaitFor waits for operation to be finished.
func (inst OperationResult) WaitFor(timeOut uint32) (bool, error) {
	var operationFinished C.bool
	returnValue := C.CCall_libamcf_operationresult_waitfor(inst.wrapperRef.LibraryHandle, inst.Ref, C.uint32_t(timeOut), &operationFinished)
	if returnValue != 0 {
		return false, makeError(uint32(returnValue))
	}
	return bool(operationFinished), nil
}

// InProgress checks if operation is in progress.
func (inst OperationResult) InProgress() (bool, error) {
	var operationIsInProgress C.bool
	returnValue := C.CCall_libamcf_operationresult_inprogress(inst.wrapperRef.LibraryHandle, inst.Ref, &operationIsInProgress)
	if returnValue != 0 {
		return false, makeError(uint32(returnValue))
	}
	return bool(operationIsInProgress), nil
}

// Success checks if operation has been finished successfully. Waits for operation to finish.
func (inst OperationResult) Success() (bool, error) {
	var operationSuccess C.bool
	returnValue := C.CCall_libamcf_operationresult_success(inst.wrapperRef.LibraryHandle, inst.Ref, &operationSuccess)
	if returnValue != 0 {
		return false, makeError(uint32(returnValue))
	}
	return bool(operationSuccess), nil
}

// GetErrorMessage returns the error message, if the operation has not been successful. Fails if operation is in progress.
func (inst OperationResult) GetErrorMessage() (string, error) {
	var neededforerrorMessage C.uint32_t
	var filledinerrorMessage C.uint32_t
	returnValue := C.CCall_libamcf_operationresult_geterrormessage(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforerrorMessage, nil)
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	bufferSizeerrorMessage := neededforerrorMessage
	buffererrorMessage := make([]byte, bufferSizeerrorMessage)
	returnValue = C.CCall_libamcf_operationresult_geterrormessage(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizeerrorMessage, &filledinerrorMessage, (*C.char)(unsafe.Pointer(&buffererrorMessage[0])))
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	return string(buffererrorMessage[:(filledinerrorMessage-1)]), nil
}


// DataStream represents a LibAMCF class.
type DataStream struct {
	Base
}

func (wrapper Wrapper) NewDataStream(r ref) DataStream {
	return DataStream{wrapper.NewBase(r)}
}

// GetUUID returns the stream UUID.
func (inst DataStream) GetUUID() (string, error) {
	var neededforuUID C.uint32_t
	var filledinuUID C.uint32_t
	returnValue := C.CCall_libamcf_datastream_getuuid(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforuUID, nil)
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	bufferSizeuUID := neededforuUID
	bufferuUID := make([]byte, bufferSizeuUID)
	returnValue = C.CCall_libamcf_datastream_getuuid(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizeuUID, &filledinuUID, (*C.char)(unsafe.Pointer(&bufferuUID[0])))
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	return string(bufferuUID[:(filledinuUID-1)]), nil
}

// GetContextUUID returns the stream's context UUID.
func (inst DataStream) GetContextUUID() (string, error) {
	var neededforcontextUUID C.uint32_t
	var filledincontextUUID C.uint32_t
	returnValue := C.CCall_libamcf_datastream_getcontextuuid(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforcontextUUID, nil)
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	bufferSizecontextUUID := neededforcontextUUID
	buffercontextUUID := make([]byte, bufferSizecontextUUID)
	returnValue = C.CCall_libamcf_datastream_getcontextuuid(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizecontextUUID, &filledincontextUUID, (*C.char)(unsafe.Pointer(&buffercontextUUID[0])))
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	return string(buffercontextUUID[:(filledincontextUUID-1)]), nil
}

// GetName returns the stream name.
func (inst DataStream) GetName() (string, error) {
	var neededforname C.uint32_t
	var filledinname C.uint32_t
	returnValue := C.CCall_libamcf_datastream_getname(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforname, nil)
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	bufferSizename := neededforname
	buffername := make([]byte, bufferSizename)
	returnValue = C.CCall_libamcf_datastream_getname(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizename, &filledinname, (*C.char)(unsafe.Pointer(&buffername[0])))
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	return string(buffername[:(filledinname-1)]), nil
}

// GetMimeType returns the stream's mime type.
func (inst DataStream) GetMimeType() (string, error) {
	var neededformimeType C.uint32_t
	var filledinmimeType C.uint32_t
	returnValue := C.CCall_libamcf_datastream_getmimetype(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededformimeType, nil)
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	bufferSizemimeType := neededformimeType
	buffermimeType := make([]byte, bufferSizemimeType)
	returnValue = C.CCall_libamcf_datastream_getmimetype(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizemimeType, &filledinmimeType, (*C.char)(unsafe.Pointer(&buffermimeType[0])))
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	return string(buffermimeType[:(filledinmimeType-1)]), nil
}

// GetSize returns the stream size.
func (inst DataStream) GetSize() (uint64, error) {
	var streamSize C.uint64_t
	returnValue := C.CCall_libamcf_datastream_getsize(inst.wrapperRef.LibraryHandle, inst.Ref, &streamSize)
	if returnValue != 0 {
		return 0, makeError(uint32(returnValue))
	}
	return uint64(streamSize), nil
}


// StreamUpload represents a LibAMCF class.
type StreamUpload struct {
	Base
}

func (wrapper Wrapper) NewStreamUpload(r ref) StreamUpload {
	return StreamUpload{wrapper.NewBase(r)}
}

// UploadData uploads the passed data to the server. MUST only be called once.
func (inst StreamUpload) UploadData(data []uint8, chunkSize uint32) (OperationResult, error) {
	var success ref
	returnValue := C.CCall_libamcf_streamupload_uploaddata(inst.wrapperRef.LibraryHandle, inst.Ref, C.uint64_t(len(data)), (*C.uint8_t)(unsafe.Pointer(&data[0])), C.uint32_t(chunkSize), &success)
	if returnValue != 0 {
		return OperationResult{}, makeError(uint32(returnValue))
	}
	return inst.wrapperRef.NewOperationResult(success), nil
}

// UploadFile uploads a file to the server. MUST only be called once.
func (inst StreamUpload) UploadFile(fileName string, chunkSize uint32) (OperationResult, error) {
	var success ref
	returnValue := C.CCall_libamcf_streamupload_uploadfile(inst.wrapperRef.LibraryHandle, inst.Ref, C.CString(fileName), C.uint32_t(chunkSize), &success)
	if returnValue != 0 {
		return OperationResult{}, makeError(uint32(returnValue))
	}
	return inst.wrapperRef.NewOperationResult(success), nil
}

// BeginChunking starts a chunked upload. MUST not be used together with uploadData or uploadFile.
func (inst StreamUpload) BeginChunking(dataSize uint64) error {
	returnValue := C.CCall_libamcf_streamupload_beginchunking(inst.wrapperRef.LibraryHandle, inst.Ref, C.uint64_t(dataSize))
	if returnValue != 0 {
		return makeError(uint32(returnValue))
	}
	return nil
}

// UploadChunk uploads another chunk to the server. Chunks are added sequentially together.
func (inst StreamUpload) UploadChunk(data []uint8) (OperationResult, error) {
	var success ref
	returnValue := C.CCall_libamcf_streamupload_uploadchunk(inst.wrapperRef.LibraryHandle, inst.Ref, C.uint64_t(len(data)), (*C.uint8_t)(unsafe.Pointer(&data[0])), &success)
	if returnValue != 0 {
		return OperationResult{}, makeError(uint32(returnValue))
	}
	return inst.wrapperRef.NewOperationResult(success), nil
}

// FinishChunking mUST only be called after all chunks have been uploaded.
func (inst StreamUpload) FinishChunking(data []uint8) (OperationResult, error) {
	var success ref
	returnValue := C.CCall_libamcf_streamupload_finishchunking(inst.wrapperRef.LibraryHandle, inst.Ref, C.uint64_t(len(data)), (*C.uint8_t)(unsafe.Pointer(&data[0])), &success)
	if returnValue != 0 {
		return OperationResult{}, makeError(uint32(returnValue))
	}
	return inst.wrapperRef.NewOperationResult(success), nil
}

// GetStatus retrieves current upload status.
func (inst StreamUpload) GetStatus() (uint64, uint64, bool, error) {
	var uploadSize C.uint64_t
	var uploadedBytes C.uint64_t
	var finished C.bool
	returnValue := C.CCall_libamcf_streamupload_getstatus(inst.wrapperRef.LibraryHandle, inst.Ref, &uploadSize, &uploadedBytes, &finished)
	if returnValue != 0 {
		return 0, 0, false, makeError(uint32(returnValue))
	}
	return uint64(uploadSize), uint64(uploadedBytes), bool(finished), nil
}

// GetDataStream retrieves the uploaded data stream object. Upload must have finished successfully.
func (inst StreamUpload) GetDataStream() (DataStream, error) {
	var dataStream ref
	returnValue := C.CCall_libamcf_streamupload_getdatastream(inst.wrapperRef.LibraryHandle, inst.Ref, &dataStream)
	if returnValue != 0 {
		return DataStream{}, makeError(uint32(returnValue))
	}
	return inst.wrapperRef.NewDataStream(dataStream), nil
}


// Connection represents a LibAMCF class.
type Connection struct {
	Base
}

func (wrapper Wrapper) NewConnection(r ref) Connection {
	return Connection{wrapper.NewBase(r)}
}

// GetBaseURL returns the base url of the AMCF instance.
func (inst Connection) GetBaseURL() (string, error) {
	var neededforbaseURL C.uint32_t
	var filledinbaseURL C.uint32_t
	returnValue := C.CCall_libamcf_connection_getbaseurl(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforbaseURL, nil)
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	bufferSizebaseURL := neededforbaseURL
	bufferbaseURL := make([]byte, bufferSizebaseURL)
	returnValue = C.CCall_libamcf_connection_getbaseurl(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizebaseURL, &filledinbaseURL, (*C.char)(unsafe.Pointer(&bufferbaseURL[0])))
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	return string(bufferbaseURL[:(filledinbaseURL-1)]), nil
}

// SetTimeouts sets the timeout behaviour of the connection.
func (inst Connection) SetTimeouts(timeout uint32, retryCount uint32) error {
	returnValue := C.CCall_libamcf_connection_settimeouts(inst.wrapperRef.LibraryHandle, inst.Ref, C.uint32_t(timeout), C.uint32_t(retryCount))
	if returnValue != 0 {
		return makeError(uint32(returnValue))
	}
	return nil
}

// GetTimeout gets the timeout behaviour of the connection.
func (inst Connection) GetTimeout() (uint32, error) {
	var timeout C.uint32_t
	returnValue := C.CCall_libamcf_connection_gettimeout(inst.wrapperRef.LibraryHandle, inst.Ref, &timeout)
	if returnValue != 0 {
		return 0, makeError(uint32(returnValue))
	}
	return uint32(timeout), nil
}

// GetRetryCount gets the timeout behaviour of the connection.
func (inst Connection) GetRetryCount() (uint32, error) {
	var retryCount C.uint32_t
	returnValue := C.CCall_libamcf_connection_getretrycount(inst.wrapperRef.LibraryHandle, inst.Ref, &retryCount)
	if returnValue != 0 {
		return 0, makeError(uint32(returnValue))
	}
	return uint32(retryCount), nil
}

// AuthenticateWithPassword authenticates with the remote instance with username and password.
func (inst Connection) AuthenticateWithPassword(userName string, password string) (OperationResult, error) {
	var success ref
	returnValue := C.CCall_libamcf_connection_authenticatewithpassword(inst.wrapperRef.LibraryHandle, inst.Ref, C.CString(userName), C.CString(password), &success)
	if returnValue != 0 {
		return OperationResult{}, makeError(uint32(returnValue))
	}
	return inst.wrapperRef.NewOperationResult(success), nil
}

// IsAuthenticated authenticates with the remote instance with username and password.
func (inst Connection) IsAuthenticated() (bool, error) {
	var isAuthenticated C.bool
	returnValue := C.CCall_libamcf_connection_isauthenticated(inst.wrapperRef.LibraryHandle, inst.Ref, &isAuthenticated)
	if returnValue != 0 {
		return false, makeError(uint32(returnValue))
	}
	return bool(isAuthenticated), nil
}

// RefreshAuthentication refreshes authentication with server.
func (inst Connection) RefreshAuthentication() (OperationResult, error) {
	var success ref
	returnValue := C.CCall_libamcf_connection_refreshauthentication(inst.wrapperRef.LibraryHandle, inst.Ref, &success)
	if returnValue != 0 {
		return OperationResult{}, makeError(uint32(returnValue))
	}
	return inst.wrapperRef.NewOperationResult(success), nil
}

// Ping detects if server is still reachable. Non-Blocking.
func (inst Connection) Ping() (OperationResult, error) {
	var success ref
	returnValue := C.CCall_libamcf_connection_ping(inst.wrapperRef.LibraryHandle, inst.Ref, &success)
	if returnValue != 0 {
		return OperationResult{}, makeError(uint32(returnValue))
	}
	return inst.wrapperRef.NewOperationResult(success), nil
}

// GetAuthToken returns the authentication token of the current connection.
func (inst Connection) GetAuthToken() (string, error) {
	var neededfortoken C.uint32_t
	var filledintoken C.uint32_t
	returnValue := C.CCall_libamcf_connection_getauthtoken(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededfortoken, nil)
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	bufferSizetoken := neededfortoken
	buffertoken := make([]byte, bufferSizetoken)
	returnValue = C.CCall_libamcf_connection_getauthtoken(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizetoken, &filledintoken, (*C.char)(unsafe.Pointer(&buffertoken[0])))
	if returnValue != 0 {
		return "", makeError(uint32(returnValue))
	}
	return string(buffertoken[:(filledintoken-1)]), nil
}

// CreateUpload creates a file upload instance. Must be authenticated to make it work.
func (inst Connection) CreateUpload(name string, mimeType string, usageContext string) (StreamUpload, error) {
	var instance ref
	returnValue := C.CCall_libamcf_connection_createupload(inst.wrapperRef.LibraryHandle, inst.Ref, C.CString(name), C.CString(mimeType), C.CString(usageContext), &instance)
	if returnValue != 0 {
		return StreamUpload{}, makeError(uint32(returnValue))
	}
	return inst.wrapperRef.NewStreamUpload(instance), nil
}


// GetVersion retrieves the binary version of this library.
func (wrapper Wrapper) GetVersion() (uint32, uint32, uint32, error) {
	var major C.uint32_t
	var minor C.uint32_t
	var micro C.uint32_t
	returnValue := C.CCall_libamcf_getversion(wrapper.LibraryHandle, &major, &minor, &micro)
	if returnValue != 0 {
		return 0, 0, 0, makeError(uint32(returnValue))
	}
	return uint32(major), uint32(minor), uint32(micro), nil
}

// GetLastError returns the last error recorded on this object.
func (wrapper Wrapper) GetLastError(instance Base) (string, bool, error) {
	var neededforerrorMessage C.uint32_t
	var filledinerrorMessage C.uint32_t
	var hasError C.bool
	returnValue := C.CCall_libamcf_getlasterror(wrapper.LibraryHandle, instance.Ref, 0, &neededforerrorMessage, nil, &hasError)
	if returnValue != 0 {
		return "", false, makeError(uint32(returnValue))
	}
	bufferSizeerrorMessage := neededforerrorMessage
	buffererrorMessage := make([]byte, bufferSizeerrorMessage)
	returnValue = C.CCall_libamcf_getlasterror(wrapper.LibraryHandle, instance.Ref, bufferSizeerrorMessage, &filledinerrorMessage, (*C.char)(unsafe.Pointer(&buffererrorMessage[0])), &hasError)
	if returnValue != 0 {
		return "", false, makeError(uint32(returnValue))
	}
	return string(buffererrorMessage[:(filledinerrorMessage-1)]), bool(hasError), nil
}

// ReleaseInstance releases shared ownership of an Instance.
func (wrapper Wrapper) ReleaseInstance(instance Base) error {
	returnValue := C.CCall_libamcf_releaseinstance(wrapper.LibraryHandle, instance.Ref)
	if returnValue != 0 {
		return makeError(uint32(returnValue))
	}
	return nil
}

// AcquireInstance acquires shared ownership of an Instance.
func (wrapper Wrapper) AcquireInstance(instance Base) error {
	returnValue := C.CCall_libamcf_acquireinstance(wrapper.LibraryHandle, instance.Ref)
	if returnValue != 0 {
		return makeError(uint32(returnValue))
	}
	return nil
}

// InjectComponent injects an imported component for usage within this component.
func (wrapper Wrapper) InjectComponent(nameSpace string, symbolAddressMethod uint64) error {
	returnValue := C.CCall_libamcf_injectcomponent(wrapper.LibraryHandle, C.CString(nameSpace), (C.uint64_t)(symbolAddressMethod))
	if returnValue != 0 {
		return makeError(uint32(returnValue))
	}
	return nil
}

// GetSymbolLookupMethod returns the address of the SymbolLookupMethod.
func (wrapper Wrapper) GetSymbolLookupMethod() (uint64, error) {
	var symbolLookupMethod C.uint64_t
	returnValue := C.CCall_libamcf_getsymbollookupmethod(wrapper.LibraryHandle, &symbolLookupMethod)
	if returnValue != 0 {
		return 0, makeError(uint32(returnValue))
	}
	return uint64(symbolLookupMethod), nil
}

// CreateConnection creates a AMCF connection instance.
func (wrapper Wrapper) CreateConnection(baseURL string) (Connection, error) {
	var instance ref
	returnValue := C.CCall_libamcf_createconnection(wrapper.LibraryHandle, C.CString(baseURL), &instance)
	if returnValue != 0 {
		return Connection{}, makeError(uint32(returnValue))
	}
	return wrapper.NewConnection(instance), nil
}

func (wrapper Wrapper) releaseC(r *ref) error {
	if r == nil || *r == nil {
		return nil
	}
	return wrapper.ReleaseInstance(Base{Ref: *r})
}

func (wrapper Wrapper) CheckBinaryVersion() error {
	var nBindingMajor uint32 = 1;
	var nBindingMinor uint32 = 0;
	nMajor, nMinor, _, err := wrapper.GetVersion()
	if err != nil {
		return err;
	}
	if (nMajor != nBindingMajor) || (nMinor < nBindingMinor) {
		return makeError(0)
	}
	return nil
}

func LoadLibrary (libraryPath string) (Wrapper, error) {
	var wrapper Wrapper;
	wrapper.LibraryHandle = C.loadLibAMCFLibrary (C.CString (libraryPath));
	if (wrapper.LibraryHandle == nil) {
		return wrapper, makeError (LIBAMCF_ERROR_COULDNOTLOADLIBRARY)
	}
	
	return wrapper, nil
	
}
