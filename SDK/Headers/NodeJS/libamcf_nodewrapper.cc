/*++

Copyright (C) 2021 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ Implementation file for the Node wrapper class 
 of Autodesk Machine Control Framework SDK

Interface version: 1.0.0

*/


#include <node.h>
#include "libamcf_nodewrapper.h"


using namespace v8;

Persistent<Function> CLibAMCFWrapper::constructor;
Persistent<Function> CLibAMCFBase::constructor;
Persistent<Function> CLibAMCFOperationResult::constructor;
Persistent<Function> CLibAMCFDataStream::constructor;
Persistent<Function> CLibAMCFStreamUpload::constructor;
Persistent<Function> CLibAMCFConnection::constructor;

/*************************************************************************************************************************
 Class CLibAMCFBaseClass Implementation
**************************************************************************************************************************/

CLibAMCFBaseClass::CLibAMCFBaseClass()
		: node::ObjectWrap()
{

}

void CLibAMCFBaseClass::RaiseError(v8::Isolate * isolate, std::string Message)
{
		if (isolate != nullptr) {
				isolate->ThrowException(Exception::TypeError(
						String::NewFromUtf8(isolate, Message.c_str() )));
		}
}
void CLibAMCFBaseClass::CheckError(v8::Isolate * isolate, sLibAMCFDynamicWrapperTable * sWrapperTable, LibAMCFHandle pInstance, LibAMCFResult errorCode)
{
		if (errorCode != 0) {
			std::string sMessage;
			if ((sWrapperTable != nullptr) && (pInstance != nullptr)) {
				if (sWrapperTable->m_GetLastError != nullptr) {
					uint32_t neededChars = 0;
					bool hasLastError = 0;
					if (sWrapperTable->m_GetLastError(pInstance, 0, &neededChars, nullptr, &hasLastError) == 0) {
						uint32_t dummyChars = 0;
						std::vector<char> Buffer;
						Buffer.resize(neededChars + 2);
						if (sWrapperTable->m_GetLastError(pInstance, neededChars + 1, &dummyChars, Buffer.data(), &hasLastError) == 0) {
							Buffer[neededChars + 1] = 0;
							sMessage = std::string(": ") + std::string(&Buffer[0]);
						}
					}
				}
			}
			throw std::runtime_error("LibAMCF Error" + sMessage + " (" + std::to_string(errorCode) + ")");
		}
}

void CLibAMCFBaseClass::setHandle(LibAMCFHandle pHandle)
{
		
}

LibAMCFHandle CLibAMCFBaseClass::getHandle(v8::Local<v8::Object> objecthandle)
{
		auto Field = objecthandle->GetInternalField(NODEWRAPPER_HANDLEINDEX);
		v8::Local<v8::External> externalField = Field.As<v8::External>();
		return (LibAMCFHandle *) externalField->Value();
}

sLibAMCFDynamicWrapperTable * CLibAMCFBaseClass::getDynamicWrapperTable(v8::Local<v8::Object> objecthandle)
{
		auto Field = objecthandle->GetInternalField(NODEWRAPPER_TABLEINDEX);
		v8::Local<v8::External> externalField = Field.As<v8::External>();
		return (sLibAMCFDynamicWrapperTable *) externalField->Value();
}


/*************************************************************************************************************************
 Class CLibAMCFBase Implementation
**************************************************************************************************************************/

CLibAMCFBase::CLibAMCFBase()
		: CLibAMCFBaseClass()
{
}

CLibAMCFBase::~CLibAMCFBase()
{
}

void CLibAMCFBase::Init()
{
		Isolate* isolate = Isolate::GetCurrent();

		// Prepare constructor template
		Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
		tpl->SetClassName(String::NewFromUtf8(isolate, "LibAMCFBase"));
		tpl->InstanceTemplate()->SetInternalFieldCount(NODEWRAPPER_FIELDCOUNT);

		// Prototype
		constructor.Reset(isolate, tpl->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());

}

void CLibAMCFBase::New(const FunctionCallbackInfo<Value>& args)
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);

		if (args.IsConstructCall()) {
				CLibAMCFBaseClass * holderObj = ObjectWrap::Unwrap<CLibAMCFBaseClass>(args.Holder());
				CLibAMCFBase * baseInstance = new CLibAMCFBase();
				baseInstance->Wrap(args.This());
				args.GetReturnValue().Set(args.This());
		} else {
				RaiseError(isolate, "LibAMCFBase: Invalid call to Constructor");
		}
}

Local<Object> CLibAMCFBase::NewInstance(Local<Object> pParent, LibAMCFHandle pHandle)
{
		Isolate* isolate = Isolate::GetCurrent();
		HandleScope scope(isolate);
		Local<Function> cons = Local<Function>::New(isolate, constructor);
		Local<Object> instance;
		if (cons->NewInstance(isolate->GetCurrentContext()).ToLocal(&instance)) {
			instance->SetInternalField(NODEWRAPPER_TABLEINDEX, External::New(isolate, CLibAMCFBaseClass::getDynamicWrapperTable(pParent)));
			instance->SetInternalField(NODEWRAPPER_HANDLEINDEX, External::New(isolate, pHandle));
		}
		return instance;
}

/*************************************************************************************************************************
 Class CLibAMCFOperationResult Implementation
**************************************************************************************************************************/

CLibAMCFOperationResult::CLibAMCFOperationResult()
		: CLibAMCFBaseClass()
{
}

CLibAMCFOperationResult::~CLibAMCFOperationResult()
{
}

void CLibAMCFOperationResult::Init()
{
		Isolate* isolate = Isolate::GetCurrent();

		// Prepare constructor template
		Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
		tpl->SetClassName(String::NewFromUtf8(isolate, "LibAMCFOperationResult"));
		tpl->InstanceTemplate()->SetInternalFieldCount(NODEWRAPPER_FIELDCOUNT);

		// Prototype
		NODE_SET_PROTOTYPE_METHOD(tpl, "WaitFor", WaitFor);
		NODE_SET_PROTOTYPE_METHOD(tpl, "EnsureSuccess", EnsureSuccess);
		NODE_SET_PROTOTYPE_METHOD(tpl, "InProgress", InProgress);
		NODE_SET_PROTOTYPE_METHOD(tpl, "Success", Success);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetErrorMessage", GetErrorMessage);
		constructor.Reset(isolate, tpl->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());

}

void CLibAMCFOperationResult::New(const FunctionCallbackInfo<Value>& args)
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);

		if (args.IsConstructCall()) {
				CLibAMCFBaseClass * holderObj = ObjectWrap::Unwrap<CLibAMCFBaseClass>(args.Holder());
				CLibAMCFOperationResult * operationresultInstance = new CLibAMCFOperationResult();
				operationresultInstance->Wrap(args.This());
				args.GetReturnValue().Set(args.This());
		} else {
				RaiseError(isolate, "LibAMCFOperationResult: Invalid call to Constructor");
		}
}

Local<Object> CLibAMCFOperationResult::NewInstance(Local<Object> pParent, LibAMCFHandle pHandle)
{
		Isolate* isolate = Isolate::GetCurrent();
		HandleScope scope(isolate);
		Local<Function> cons = Local<Function>::New(isolate, constructor);
		Local<Object> instance;
		if (cons->NewInstance(isolate->GetCurrentContext()).ToLocal(&instance)) {
			instance->SetInternalField(NODEWRAPPER_TABLEINDEX, External::New(isolate, CLibAMCFBaseClass::getDynamicWrapperTable(pParent)));
			instance->SetInternalField(NODEWRAPPER_HANDLEINDEX, External::New(isolate, pHandle));
		}
		return instance;
}


void CLibAMCFOperationResult::WaitFor(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsUint32()) {
            throw std::runtime_error("Expected uint32 parameter 0 (TimeOut)");
        }
        unsigned int nTimeOut = (unsigned int) args[0]->IntegerValue(isolate->GetCurrentContext()).ToChecked();
        bool bReturnOperationFinished = false;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method WaitFor.");
        if (wrapperTable->m_OperationResult_WaitFor == nullptr)
            throw std::runtime_error("Could not call LibAMCF method OperationResult::WaitFor.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_OperationResult_WaitFor(instanceHandle, nTimeOut, &bReturnOperationFinished);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(Boolean::New(isolate, bReturnOperationFinished));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFOperationResult::EnsureSuccess(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method EnsureSuccess.");
        if (wrapperTable->m_OperationResult_EnsureSuccess == nullptr)
            throw std::runtime_error("Could not call LibAMCF method OperationResult::EnsureSuccess.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_OperationResult_EnsureSuccess(instanceHandle);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFOperationResult::InProgress(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        bool bReturnOperationIsInProgress = false;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method InProgress.");
        if (wrapperTable->m_OperationResult_InProgress == nullptr)
            throw std::runtime_error("Could not call LibAMCF method OperationResult::InProgress.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_OperationResult_InProgress(instanceHandle, &bReturnOperationIsInProgress);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(Boolean::New(isolate, bReturnOperationIsInProgress));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFOperationResult::Success(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        bool bReturnOperationSuccess = false;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method Success.");
        if (wrapperTable->m_OperationResult_Success == nullptr)
            throw std::runtime_error("Could not call LibAMCF method OperationResult::Success.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_OperationResult_Success(instanceHandle, &bReturnOperationSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(Boolean::New(isolate, bReturnOperationSuccess));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFOperationResult::GetErrorMessage(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededErrorMessage = 0;
        unsigned int bytesWrittenErrorMessage = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetErrorMessage.");
        if (wrapperTable->m_OperationResult_GetErrorMessage == nullptr)
            throw std::runtime_error("Could not call LibAMCF method OperationResult::GetErrorMessage.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_OperationResult_GetErrorMessage(instanceHandle, 0, &bytesNeededErrorMessage, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferErrorMessage;
        bufferErrorMessage.resize(bytesNeededErrorMessage);
        LibAMCFResult errorCode = wrapperTable->m_OperationResult_GetErrorMessage(instanceHandle, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferErrorMessage[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}

/*************************************************************************************************************************
 Class CLibAMCFDataStream Implementation
**************************************************************************************************************************/

CLibAMCFDataStream::CLibAMCFDataStream()
		: CLibAMCFBaseClass()
{
}

CLibAMCFDataStream::~CLibAMCFDataStream()
{
}

void CLibAMCFDataStream::Init()
{
		Isolate* isolate = Isolate::GetCurrent();

		// Prepare constructor template
		Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
		tpl->SetClassName(String::NewFromUtf8(isolate, "LibAMCFDataStream"));
		tpl->InstanceTemplate()->SetInternalFieldCount(NODEWRAPPER_FIELDCOUNT);

		// Prototype
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetUUID", GetUUID);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetContext", GetContext);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetName", GetName);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetMimeType", GetMimeType);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetSHA256", GetSHA256);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetSize", GetSize);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetTimestamp", GetTimestamp);
		constructor.Reset(isolate, tpl->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());

}

void CLibAMCFDataStream::New(const FunctionCallbackInfo<Value>& args)
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);

		if (args.IsConstructCall()) {
				CLibAMCFBaseClass * holderObj = ObjectWrap::Unwrap<CLibAMCFBaseClass>(args.Holder());
				CLibAMCFDataStream * datastreamInstance = new CLibAMCFDataStream();
				datastreamInstance->Wrap(args.This());
				args.GetReturnValue().Set(args.This());
		} else {
				RaiseError(isolate, "LibAMCFDataStream: Invalid call to Constructor");
		}
}

Local<Object> CLibAMCFDataStream::NewInstance(Local<Object> pParent, LibAMCFHandle pHandle)
{
		Isolate* isolate = Isolate::GetCurrent();
		HandleScope scope(isolate);
		Local<Function> cons = Local<Function>::New(isolate, constructor);
		Local<Object> instance;
		if (cons->NewInstance(isolate->GetCurrentContext()).ToLocal(&instance)) {
			instance->SetInternalField(NODEWRAPPER_TABLEINDEX, External::New(isolate, CLibAMCFBaseClass::getDynamicWrapperTable(pParent)));
			instance->SetInternalField(NODEWRAPPER_HANDLEINDEX, External::New(isolate, pHandle));
		}
		return instance;
}


void CLibAMCFDataStream::GetUUID(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededUUID = 0;
        unsigned int bytesWrittenUUID = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetUUID.");
        if (wrapperTable->m_DataStream_GetUUID == nullptr)
            throw std::runtime_error("Could not call LibAMCF method DataStream::GetUUID.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_DataStream_GetUUID(instanceHandle, 0, &bytesNeededUUID, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferUUID;
        bufferUUID.resize(bytesNeededUUID);
        LibAMCFResult errorCode = wrapperTable->m_DataStream_GetUUID(instanceHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferUUID[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFDataStream::GetContext(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        Local<Object> outObject = Object::New(isolate);
        eLibAMCFStreamContextType eReturnContextType;
        unsigned int bytesNeededOwnerUUID = 0;
        unsigned int bytesWrittenOwnerUUID = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetContext.");
        if (wrapperTable->m_DataStream_GetContext == nullptr)
            throw std::runtime_error("Could not call LibAMCF method DataStream::GetContext.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_DataStream_GetContext(instanceHandle, &eReturnContextType, 0, &bytesNeededOwnerUUID, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferOwnerUUID;
        bufferOwnerUUID.resize(bytesNeededOwnerUUID);
        LibAMCFResult errorCode = wrapperTable->m_DataStream_GetContext(instanceHandle, &eReturnContextType, bytesNeededOwnerUUID, &bytesWrittenOwnerUUID, &bufferOwnerUUID[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "ContextType"), Integer::New(isolate, (int)eReturnContextType));
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "OwnerUUID"), String::NewFromUtf8(isolate, &bufferOwnerUUID[0]));
        args.GetReturnValue().Set(outObject);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFDataStream::GetName(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededName = 0;
        unsigned int bytesWrittenName = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetName.");
        if (wrapperTable->m_DataStream_GetName == nullptr)
            throw std::runtime_error("Could not call LibAMCF method DataStream::GetName.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_DataStream_GetName(instanceHandle, 0, &bytesNeededName, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferName;
        bufferName.resize(bytesNeededName);
        LibAMCFResult errorCode = wrapperTable->m_DataStream_GetName(instanceHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferName[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFDataStream::GetMimeType(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededMimeType = 0;
        unsigned int bytesWrittenMimeType = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetMimeType.");
        if (wrapperTable->m_DataStream_GetMimeType == nullptr)
            throw std::runtime_error("Could not call LibAMCF method DataStream::GetMimeType.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_DataStream_GetMimeType(instanceHandle, 0, &bytesNeededMimeType, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferMimeType;
        bufferMimeType.resize(bytesNeededMimeType);
        LibAMCFResult errorCode = wrapperTable->m_DataStream_GetMimeType(instanceHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferMimeType[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFDataStream::GetSHA256(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededSHA256 = 0;
        unsigned int bytesWrittenSHA256 = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetSHA256.");
        if (wrapperTable->m_DataStream_GetSHA256 == nullptr)
            throw std::runtime_error("Could not call LibAMCF method DataStream::GetSHA256.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_DataStream_GetSHA256(instanceHandle, 0, &bytesNeededSHA256, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferSHA256;
        bufferSHA256.resize(bytesNeededSHA256);
        LibAMCFResult errorCode = wrapperTable->m_DataStream_GetSHA256(instanceHandle, bytesNeededSHA256, &bytesWrittenSHA256, &bufferSHA256[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferSHA256[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFDataStream::GetSize(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        uint64_t nReturnStreamSize = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetSize.");
        if (wrapperTable->m_DataStream_GetSize == nullptr)
            throw std::runtime_error("Could not call LibAMCF method DataStream::GetSize.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_DataStream_GetSize(instanceHandle, &nReturnStreamSize);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, std::to_string(nReturnStreamSize).c_str()));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFDataStream::GetTimestamp(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededTimestamp = 0;
        unsigned int bytesWrittenTimestamp = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetTimestamp.");
        if (wrapperTable->m_DataStream_GetTimestamp == nullptr)
            throw std::runtime_error("Could not call LibAMCF method DataStream::GetTimestamp.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_DataStream_GetTimestamp(instanceHandle, 0, &bytesNeededTimestamp, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferTimestamp;
        bufferTimestamp.resize(bytesNeededTimestamp);
        LibAMCFResult errorCode = wrapperTable->m_DataStream_GetTimestamp(instanceHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferTimestamp[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}

/*************************************************************************************************************************
 Class CLibAMCFStreamUpload Implementation
**************************************************************************************************************************/

CLibAMCFStreamUpload::CLibAMCFStreamUpload()
		: CLibAMCFBaseClass()
{
}

CLibAMCFStreamUpload::~CLibAMCFStreamUpload()
{
}

void CLibAMCFStreamUpload::Init()
{
		Isolate* isolate = Isolate::GetCurrent();

		// Prepare constructor template
		Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
		tpl->SetClassName(String::NewFromUtf8(isolate, "LibAMCFStreamUpload"));
		tpl->InstanceTemplate()->SetInternalFieldCount(NODEWRAPPER_FIELDCOUNT);

		// Prototype
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetName", GetName);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetMimeType", GetMimeType);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetContextType", GetContextType);
		NODE_SET_PROTOTYPE_METHOD(tpl, "UploadData", UploadData);
		NODE_SET_PROTOTYPE_METHOD(tpl, "UploadFile", UploadFile);
		NODE_SET_PROTOTYPE_METHOD(tpl, "BeginChunking", BeginChunking);
		NODE_SET_PROTOTYPE_METHOD(tpl, "UploadChunk", UploadChunk);
		NODE_SET_PROTOTYPE_METHOD(tpl, "FinishChunking", FinishChunking);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetStatus", GetStatus);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetDataStream", GetDataStream);
		constructor.Reset(isolate, tpl->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());

}

void CLibAMCFStreamUpload::New(const FunctionCallbackInfo<Value>& args)
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);

		if (args.IsConstructCall()) {
				CLibAMCFBaseClass * holderObj = ObjectWrap::Unwrap<CLibAMCFBaseClass>(args.Holder());
				CLibAMCFStreamUpload * streamuploadInstance = new CLibAMCFStreamUpload();
				streamuploadInstance->Wrap(args.This());
				args.GetReturnValue().Set(args.This());
		} else {
				RaiseError(isolate, "LibAMCFStreamUpload: Invalid call to Constructor");
		}
}

Local<Object> CLibAMCFStreamUpload::NewInstance(Local<Object> pParent, LibAMCFHandle pHandle)
{
		Isolate* isolate = Isolate::GetCurrent();
		HandleScope scope(isolate);
		Local<Function> cons = Local<Function>::New(isolate, constructor);
		Local<Object> instance;
		if (cons->NewInstance(isolate->GetCurrentContext()).ToLocal(&instance)) {
			instance->SetInternalField(NODEWRAPPER_TABLEINDEX, External::New(isolate, CLibAMCFBaseClass::getDynamicWrapperTable(pParent)));
			instance->SetInternalField(NODEWRAPPER_HANDLEINDEX, External::New(isolate, pHandle));
		}
		return instance;
}


void CLibAMCFStreamUpload::GetName(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededName = 0;
        unsigned int bytesWrittenName = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetName.");
        if (wrapperTable->m_StreamUpload_GetName == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::GetName.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_StreamUpload_GetName(instanceHandle, 0, &bytesNeededName, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferName;
        bufferName.resize(bytesNeededName);
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_GetName(instanceHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferName[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFStreamUpload::GetMimeType(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededMimeType = 0;
        unsigned int bytesWrittenMimeType = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetMimeType.");
        if (wrapperTable->m_StreamUpload_GetMimeType == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::GetMimeType.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_StreamUpload_GetMimeType(instanceHandle, 0, &bytesNeededMimeType, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferMimeType;
        bufferMimeType.resize(bytesNeededMimeType);
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_GetMimeType(instanceHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferMimeType[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFStreamUpload::GetContextType(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        eLibAMCFStreamContextType eReturnContextType;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetContextType.");
        if (wrapperTable->m_StreamUpload_GetContextType == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::GetContextType.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_GetContextType(instanceHandle, &eReturnContextType);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(Integer::New(isolate, (int)eReturnContextType));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFStreamUpload::UploadData(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[1]->IsUint32()) {
            throw std::runtime_error("Expected uint32 parameter 1 (ChunkSize)");
        }
        if (!args[2]->IsUint32()) {
            throw std::runtime_error("Expected uint32 parameter 2 (ThreadCount)");
        }
        unsigned int nChunkSize = (unsigned int) args[1]->IntegerValue(isolate->GetCurrentContext()).ToChecked();
        unsigned int nThreadCount = (unsigned int) args[2]->IntegerValue(isolate->GetCurrentContext()).ToChecked();
        LibAMCFHandle hReturnSuccess = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method UploadData.");
        if (wrapperTable->m_StreamUpload_UploadData == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::UploadData.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_UploadData(instanceHandle, 0, nullptr, nChunkSize, nThreadCount, &hReturnSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjSuccess = CLibAMCFOperationResult::NewInstance(args.Holder(), hReturnSuccess);
        args.GetReturnValue().Set(instanceObjSuccess);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFStreamUpload::UploadFile(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsString()) {
            throw std::runtime_error("Expected string parameter 0 (FileName)");
        }
        if (!args[1]->IsUint32()) {
            throw std::runtime_error("Expected uint32 parameter 1 (ChunkSize)");
        }
        if (!args[2]->IsUint32()) {
            throw std::runtime_error("Expected uint32 parameter 2 (ThreadCount)");
        }
        v8::String::Utf8Value sutf8FileName(isolate, args[0]);
        std::string sFileName = *sutf8FileName;
        unsigned int nChunkSize = (unsigned int) args[1]->IntegerValue(isolate->GetCurrentContext()).ToChecked();
        unsigned int nThreadCount = (unsigned int) args[2]->IntegerValue(isolate->GetCurrentContext()).ToChecked();
        LibAMCFHandle hReturnSuccess = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method UploadFile.");
        if (wrapperTable->m_StreamUpload_UploadFile == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::UploadFile.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_UploadFile(instanceHandle, sFileName.c_str(), nChunkSize, nThreadCount, &hReturnSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjSuccess = CLibAMCFOperationResult::NewInstance(args.Holder(), hReturnSuccess);
        args.GetReturnValue().Set(instanceObjSuccess);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFStreamUpload::BeginChunking(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsString()) {
            throw std::runtime_error("Expected uint64 parameter 0 (DataSize)");
        }
        v8::String::Utf8Value sutf8DataSize(isolate, args[0]);
        std::string sDataSize = *sutf8DataSize;
        uint64_t nDataSize = stoull(sDataSize);
        LibAMCFHandle hReturnSuccess = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method BeginChunking.");
        if (wrapperTable->m_StreamUpload_BeginChunking == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::BeginChunking.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_BeginChunking(instanceHandle, nDataSize, &hReturnSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjSuccess = CLibAMCFOperationResult::NewInstance(args.Holder(), hReturnSuccess);
        args.GetReturnValue().Set(instanceObjSuccess);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFStreamUpload::UploadChunk(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        LibAMCFHandle hReturnSuccess = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method UploadChunk.");
        if (wrapperTable->m_StreamUpload_UploadChunk == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::UploadChunk.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_UploadChunk(instanceHandle, 0, nullptr, &hReturnSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjSuccess = CLibAMCFOperationResult::NewInstance(args.Holder(), hReturnSuccess);
        args.GetReturnValue().Set(instanceObjSuccess);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFStreamUpload::FinishChunking(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        LibAMCFHandle hReturnSuccess = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method FinishChunking.");
        if (wrapperTable->m_StreamUpload_FinishChunking == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::FinishChunking.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_FinishChunking(instanceHandle, &hReturnSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjSuccess = CLibAMCFOperationResult::NewInstance(args.Holder(), hReturnSuccess);
        args.GetReturnValue().Set(instanceObjSuccess);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFStreamUpload::GetStatus(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        Local<Object> outObject = Object::New(isolate);
        uint64_t nReturnUploadSize = 0;
        uint64_t nReturnFinishedSize = 0;
        uint64_t nReturnInProgressSize = 0;
        bool bReturnFinished = false;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetStatus.");
        if (wrapperTable->m_StreamUpload_GetStatus == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::GetStatus.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_GetStatus(instanceHandle, &nReturnUploadSize, &nReturnFinishedSize, &nReturnInProgressSize, &bReturnFinished);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "UploadSize"), String::NewFromUtf8(isolate, std::to_string(nReturnUploadSize).c_str()));
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "FinishedSize"), String::NewFromUtf8(isolate, std::to_string(nReturnFinishedSize).c_str()));
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "InProgressSize"), String::NewFromUtf8(isolate, std::to_string(nReturnInProgressSize).c_str()));
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "Finished"), Boolean::New(isolate, bReturnFinished));
        args.GetReturnValue().Set(outObject);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFStreamUpload::GetDataStream(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        LibAMCFHandle hReturnDataStream = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetDataStream.");
        if (wrapperTable->m_StreamUpload_GetDataStream == nullptr)
            throw std::runtime_error("Could not call LibAMCF method StreamUpload::GetDataStream.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_StreamUpload_GetDataStream(instanceHandle, &hReturnDataStream);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjDataStream = CLibAMCFDataStream::NewInstance(args.Holder(), hReturnDataStream);
        args.GetReturnValue().Set(instanceObjDataStream);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}

/*************************************************************************************************************************
 Class CLibAMCFConnection Implementation
**************************************************************************************************************************/

CLibAMCFConnection::CLibAMCFConnection()
		: CLibAMCFBaseClass()
{
}

CLibAMCFConnection::~CLibAMCFConnection()
{
}

void CLibAMCFConnection::Init()
{
		Isolate* isolate = Isolate::GetCurrent();

		// Prepare constructor template
		Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
		tpl->SetClassName(String::NewFromUtf8(isolate, "LibAMCFConnection"));
		tpl->InstanceTemplate()->SetInternalFieldCount(NODEWRAPPER_FIELDCOUNT);

		// Prototype
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetBaseURL", GetBaseURL);
		NODE_SET_PROTOTYPE_METHOD(tpl, "SetTimeouts", SetTimeouts);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetTimeout", GetTimeout);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetRetryCount", GetRetryCount);
		NODE_SET_PROTOTYPE_METHOD(tpl, "AuthenticateWithPassword", AuthenticateWithPassword);
		NODE_SET_PROTOTYPE_METHOD(tpl, "IsAuthenticated", IsAuthenticated);
		NODE_SET_PROTOTYPE_METHOD(tpl, "RefreshAuthentication", RefreshAuthentication);
		NODE_SET_PROTOTYPE_METHOD(tpl, "Ping", Ping);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetAuthToken", GetAuthToken);
		NODE_SET_PROTOTYPE_METHOD(tpl, "CreateUpload", CreateUpload);
		NODE_SET_PROTOTYPE_METHOD(tpl, "PrepareBuild", PrepareBuild);
		constructor.Reset(isolate, tpl->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());

}

void CLibAMCFConnection::New(const FunctionCallbackInfo<Value>& args)
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);

		if (args.IsConstructCall()) {
				CLibAMCFBaseClass * holderObj = ObjectWrap::Unwrap<CLibAMCFBaseClass>(args.Holder());
				CLibAMCFConnection * connectionInstance = new CLibAMCFConnection();
				connectionInstance->Wrap(args.This());
				args.GetReturnValue().Set(args.This());
		} else {
				RaiseError(isolate, "LibAMCFConnection: Invalid call to Constructor");
		}
}

Local<Object> CLibAMCFConnection::NewInstance(Local<Object> pParent, LibAMCFHandle pHandle)
{
		Isolate* isolate = Isolate::GetCurrent();
		HandleScope scope(isolate);
		Local<Function> cons = Local<Function>::New(isolate, constructor);
		Local<Object> instance;
		if (cons->NewInstance(isolate->GetCurrentContext()).ToLocal(&instance)) {
			instance->SetInternalField(NODEWRAPPER_TABLEINDEX, External::New(isolate, CLibAMCFBaseClass::getDynamicWrapperTable(pParent)));
			instance->SetInternalField(NODEWRAPPER_HANDLEINDEX, External::New(isolate, pHandle));
		}
		return instance;
}


void CLibAMCFConnection::GetBaseURL(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededBaseURL = 0;
        unsigned int bytesWrittenBaseURL = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetBaseURL.");
        if (wrapperTable->m_Connection_GetBaseURL == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::GetBaseURL.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_Connection_GetBaseURL(instanceHandle, 0, &bytesNeededBaseURL, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferBaseURL;
        bufferBaseURL.resize(bytesNeededBaseURL);
        LibAMCFResult errorCode = wrapperTable->m_Connection_GetBaseURL(instanceHandle, bytesNeededBaseURL, &bytesWrittenBaseURL, &bufferBaseURL[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferBaseURL[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::SetTimeouts(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsUint32()) {
            throw std::runtime_error("Expected uint32 parameter 0 (Timeout)");
        }
        if (!args[1]->IsUint32()) {
            throw std::runtime_error("Expected uint32 parameter 1 (RetryCount)");
        }
        unsigned int nTimeout = (unsigned int) args[0]->IntegerValue(isolate->GetCurrentContext()).ToChecked();
        unsigned int nRetryCount = (unsigned int) args[1]->IntegerValue(isolate->GetCurrentContext()).ToChecked();
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method SetTimeouts.");
        if (wrapperTable->m_Connection_SetTimeouts == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::SetTimeouts.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_Connection_SetTimeouts(instanceHandle, nTimeout, nRetryCount);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::GetTimeout(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int nReturnTimeout = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetTimeout.");
        if (wrapperTable->m_Connection_GetTimeout == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::GetTimeout.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_Connection_GetTimeout(instanceHandle, &nReturnTimeout);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(Integer::NewFromUnsigned(isolate, nReturnTimeout));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::GetRetryCount(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int nReturnRetryCount = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetRetryCount.");
        if (wrapperTable->m_Connection_GetRetryCount == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::GetRetryCount.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_Connection_GetRetryCount(instanceHandle, &nReturnRetryCount);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(Integer::NewFromUnsigned(isolate, nReturnRetryCount));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::AuthenticateWithPassword(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsString()) {
            throw std::runtime_error("Expected string parameter 0 (UserName)");
        }
        if (!args[1]->IsString()) {
            throw std::runtime_error("Expected string parameter 1 (Password)");
        }
        v8::String::Utf8Value sutf8UserName(isolate, args[0]);
        std::string sUserName = *sutf8UserName;
        v8::String::Utf8Value sutf8Password(isolate, args[1]);
        std::string sPassword = *sutf8Password;
        LibAMCFHandle hReturnSuccess = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method AuthenticateWithPassword.");
        if (wrapperTable->m_Connection_AuthenticateWithPassword == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::AuthenticateWithPassword.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_Connection_AuthenticateWithPassword(instanceHandle, sUserName.c_str(), sPassword.c_str(), &hReturnSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjSuccess = CLibAMCFOperationResult::NewInstance(args.Holder(), hReturnSuccess);
        args.GetReturnValue().Set(instanceObjSuccess);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::IsAuthenticated(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        bool bReturnIsAuthenticated = false;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method IsAuthenticated.");
        if (wrapperTable->m_Connection_IsAuthenticated == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::IsAuthenticated.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_Connection_IsAuthenticated(instanceHandle, &bReturnIsAuthenticated);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(Boolean::New(isolate, bReturnIsAuthenticated));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::RefreshAuthentication(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        LibAMCFHandle hReturnSuccess = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method RefreshAuthentication.");
        if (wrapperTable->m_Connection_RefreshAuthentication == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::RefreshAuthentication.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_Connection_RefreshAuthentication(instanceHandle, &hReturnSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjSuccess = CLibAMCFOperationResult::NewInstance(args.Holder(), hReturnSuccess);
        args.GetReturnValue().Set(instanceObjSuccess);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::Ping(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        LibAMCFHandle hReturnSuccess = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method Ping.");
        if (wrapperTable->m_Connection_Ping == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::Ping.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_Connection_Ping(instanceHandle, &hReturnSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjSuccess = CLibAMCFOperationResult::NewInstance(args.Holder(), hReturnSuccess);
        args.GetReturnValue().Set(instanceObjSuccess);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::GetAuthToken(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        unsigned int bytesNeededToken = 0;
        unsigned int bytesWrittenToken = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetAuthToken.");
        if (wrapperTable->m_Connection_GetAuthToken == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::GetAuthToken.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult initErrorCode = wrapperTable->m_Connection_GetAuthToken(instanceHandle, 0, &bytesNeededToken, nullptr);
        CheckError(isolate, wrapperTable, instanceHandle, initErrorCode);
        std::vector<char> bufferToken;
        bufferToken.resize(bytesNeededToken);
        LibAMCFResult errorCode = wrapperTable->m_Connection_GetAuthToken(instanceHandle, bytesNeededToken, &bytesWrittenToken, &bufferToken[0]);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, &bufferToken[0]));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::CreateUpload(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsString()) {
            throw std::runtime_error("Expected string parameter 0 (Name)");
        }
        if (!args[1]->IsString()) {
            throw std::runtime_error("Expected string parameter 1 (MimeType)");
        }
        if (!args[2]->IsUint32()) {
            throw std::runtime_error("Expected enum parameter 2 (ContextType)");
        }
        v8::String::Utf8Value sutf8Name(isolate, args[0]);
        std::string sName = *sutf8Name;
        v8::String::Utf8Value sutf8MimeType(isolate, args[1]);
        std::string sMimeType = *sutf8MimeType;
        unsigned int eContextType = (unsigned int) args[2]->IntegerValue(isolate->GetCurrentContext()).ToChecked();
        LibAMCFHandle hReturnInstance = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method CreateUpload.");
        if (wrapperTable->m_Connection_CreateUpload == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::CreateUpload.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_Connection_CreateUpload(instanceHandle, sName.c_str(), sMimeType.c_str(), (eLibAMCFStreamContextType) eContextType, &hReturnInstance);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjInstance = CLibAMCFStreamUpload::NewInstance(args.Holder(), hReturnInstance);
        args.GetReturnValue().Set(instanceObjInstance);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFConnection::PrepareBuild(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsObject()) {
            throw std::runtime_error("Expected class parameter 0 (DataStream)");
        }
        Local<Object> objDataStream = args[0]->ToObject(isolate->GetCurrentContext()).ToLocalChecked();
        CLibAMCFDataStream * instanceDataStream = ObjectWrap::Unwrap<CLibAMCFDataStream>(objDataStream);
        if (instanceDataStream == nullptr)
            throw std::runtime_error("Invalid Object parameter 0 (DataStream)");
        LibAMCFHandle hDataStream = instanceDataStream->getHandle( objDataStream );
        LibAMCFHandle hReturnSuccess = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method PrepareBuild.");
        if (wrapperTable->m_Connection_PrepareBuild == nullptr)
            throw std::runtime_error("Could not call LibAMCF method Connection::PrepareBuild.");
        LibAMCFHandle instanceHandle = CLibAMCFBaseClass::getHandle(args.Holder());
        LibAMCFResult errorCode = wrapperTable->m_Connection_PrepareBuild(instanceHandle, hDataStream, &hReturnSuccess);
        CheckError(isolate, wrapperTable, instanceHandle, errorCode);
        Local<Object> instanceObjSuccess = CLibAMCFOperationResult::NewInstance(args.Holder(), hReturnSuccess);
        args.GetReturnValue().Set(instanceObjSuccess);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}

/*************************************************************************************************************************
 Class CLibAMCFWrapper Implementation
**************************************************************************************************************************/

CLibAMCFWrapper::CLibAMCFWrapper()
		: CLibAMCFBaseClass()
{
}

CLibAMCFWrapper::~CLibAMCFWrapper()
{

}

void CLibAMCFWrapper::Init()
{
		Isolate* isolate = Isolate::GetCurrent();
		// Prepare constructor template
		Local<FunctionTemplate> tpl = FunctionTemplate::New(isolate, New);
		tpl->SetClassName(String::NewFromUtf8(isolate, "LibAMCFWrapper"));
		tpl->InstanceTemplate()->SetInternalFieldCount(NODEWRAPPER_FIELDCOUNT);
		
		// Prototype
		
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetVersion", GetVersion);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetLastError", GetLastError);
		NODE_SET_PROTOTYPE_METHOD(tpl, "ReleaseInstance", ReleaseInstance);
		NODE_SET_PROTOTYPE_METHOD(tpl, "AcquireInstance", AcquireInstance);
		NODE_SET_PROTOTYPE_METHOD(tpl, "InjectComponent", InjectComponent);
		NODE_SET_PROTOTYPE_METHOD(tpl, "GetSymbolLookupMethod", GetSymbolLookupMethod);
		NODE_SET_PROTOTYPE_METHOD(tpl, "CreateConnection", CreateConnection);
		constructor.Reset(isolate, tpl->GetFunction(isolate->GetCurrentContext()).ToLocalChecked());
}

void CLibAMCFWrapper::New(const FunctionCallbackInfo<Value>& args)
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);

		try {
				if (args.IsConstructCall()) {
						// Get Library Name as Argument
						#ifdef _WIN32
						std::string sLibraryName = "libamcf.dll";
						#elif __APPLE__
						std::string sLibraryName = "libamcf.dylib";
						#elif __linux__
						std::string sLibraryName = "libamcf.so";
						#endif
						if (args[0]->IsString()) {
								v8::String::Utf8Value stringParam(isolate, args[0]);
								sLibraryName = *stringParam;
						}
						// Invoked as constructor: `new LibAMCFWrapper(...)`
						CLibAMCFWrapper* obj = new CLibAMCFWrapper();
						Local<Object> newObject = args.This();
						std::auto_ptr<sLibAMCFDynamicWrapperTable> wrapperTable( new sLibAMCFDynamicWrapperTable );
						CheckError(isolate, nullptr, nullptr, LoadLibAMCFWrapperTable(wrapperTable.get(), sLibraryName.c_str()));
						newObject->SetInternalField(NODEWRAPPER_TABLEINDEX, External::New(isolate, wrapperTable.release()));
						newObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "eStreamContextType_Unknown"), Integer::New(isolate, 0));
						newObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "eStreamContextType_NewBuildJob"), Integer::New(isolate, 1));
						obj->Wrap(newObject);
						args.GetReturnValue().Set(newObject);
				} else {
						// Invoked as plain function `LibAMCFWrapper(...)`, turn into construct call.
						const int argc = 1;
						Local<Value> argv[argc] = { args[0] };
						Local<Function> cons = Local<Function>::New(isolate, constructor);
						args.GetReturnValue().Set(cons->NewInstance(isolate->GetCurrentContext(), argc, argv).ToLocalChecked());
				}
		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}

Local<Object> CLibAMCFWrapper::NewInstance(const FunctionCallbackInfo<Value>& args)
{
		Isolate* isolate = Isolate::GetCurrent();
		HandleScope scope(isolate);
		Local<Function> cons = Local<Function>::New(isolate, constructor);
		Local<Object> instance;
		const int argc = 1;
		Local<Value> argv[argc] = { args[0] };
		cons->NewInstance(isolate->GetCurrentContext(), argc, argv).ToLocal(&instance);
		return instance;
}


void CLibAMCFWrapper::GetVersion(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        Local<Object> outObject = Object::New(isolate);
        unsigned int nReturnMajor = 0;
        unsigned int nReturnMinor = 0;
        unsigned int nReturnMicro = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetVersion.");
        if (wrapperTable->m_GetVersion == nullptr)
            throw std::runtime_error("Could not call LibAMCF method GetVersion.");
        LibAMCFResult errorCode = wrapperTable->m_GetVersion(&nReturnMajor, &nReturnMinor, &nReturnMicro);
        CheckError(isolate, wrapperTable, nullptr, errorCode);
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "Major"), Integer::NewFromUnsigned(isolate, nReturnMajor));
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "Minor"), Integer::NewFromUnsigned(isolate, nReturnMinor));
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "Micro"), Integer::NewFromUnsigned(isolate, nReturnMicro));
        args.GetReturnValue().Set(outObject);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFWrapper::GetLastError(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsObject()) {
            throw std::runtime_error("Expected class parameter 0 (Instance)");
        }
        Local<Object> outObject = Object::New(isolate);
        Local<Object> objInstance = args[0]->ToObject(isolate->GetCurrentContext()).ToLocalChecked();
        CLibAMCFBase * instanceInstance = ObjectWrap::Unwrap<CLibAMCFBase>(objInstance);
        if (instanceInstance == nullptr)
            throw std::runtime_error("Invalid Object parameter 0 (Instance)");
        LibAMCFHandle hInstance = instanceInstance->getHandle( objInstance );
        unsigned int bytesNeededErrorMessage = 0;
        unsigned int bytesWrittenErrorMessage = 0;
        bool bReturnHasError = false;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetLastError.");
        if (wrapperTable->m_GetLastError == nullptr)
            throw std::runtime_error("Could not call LibAMCF method GetLastError.");
        LibAMCFResult initErrorCode = wrapperTable->m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &bReturnHasError);
        CheckError(isolate, wrapperTable, nullptr, initErrorCode);
        std::vector<char> bufferErrorMessage;
        bufferErrorMessage.resize(bytesNeededErrorMessage);
        LibAMCFResult errorCode = wrapperTable->m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &bReturnHasError);
        CheckError(isolate, wrapperTable, nullptr, errorCode);
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "ErrorMessage"), String::NewFromUtf8(isolate, &bufferErrorMessage[0]));
        outObject->Set(isolate->GetCurrentContext(), String::NewFromUtf8(isolate, "HasError"), Boolean::New(isolate, bReturnHasError));
        args.GetReturnValue().Set(outObject);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFWrapper::ReleaseInstance(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsObject()) {
            throw std::runtime_error("Expected class parameter 0 (Instance)");
        }
        Local<Object> objInstance = args[0]->ToObject(isolate->GetCurrentContext()).ToLocalChecked();
        CLibAMCFBase * instanceInstance = ObjectWrap::Unwrap<CLibAMCFBase>(objInstance);
        if (instanceInstance == nullptr)
            throw std::runtime_error("Invalid Object parameter 0 (Instance)");
        LibAMCFHandle hInstance = instanceInstance->getHandle( objInstance );
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method ReleaseInstance.");
        if (wrapperTable->m_ReleaseInstance == nullptr)
            throw std::runtime_error("Could not call LibAMCF method ReleaseInstance.");
        LibAMCFResult errorCode = wrapperTable->m_ReleaseInstance(hInstance);
        CheckError(isolate, wrapperTable, nullptr, errorCode);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFWrapper::AcquireInstance(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsObject()) {
            throw std::runtime_error("Expected class parameter 0 (Instance)");
        }
        Local<Object> objInstance = args[0]->ToObject(isolate->GetCurrentContext()).ToLocalChecked();
        CLibAMCFBase * instanceInstance = ObjectWrap::Unwrap<CLibAMCFBase>(objInstance);
        if (instanceInstance == nullptr)
            throw std::runtime_error("Invalid Object parameter 0 (Instance)");
        LibAMCFHandle hInstance = instanceInstance->getHandle( objInstance );
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method AcquireInstance.");
        if (wrapperTable->m_AcquireInstance == nullptr)
            throw std::runtime_error("Could not call LibAMCF method AcquireInstance.");
        LibAMCFResult errorCode = wrapperTable->m_AcquireInstance(hInstance);
        CheckError(isolate, wrapperTable, nullptr, errorCode);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFWrapper::InjectComponent(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsString()) {
            throw std::runtime_error("Expected string parameter 0 (NameSpace)");
        }
        if (!args[1]->IsString()) {
            throw std::runtime_error("Expected pointer parameter 1 (SymbolAddressMethod)");
        }
        v8::String::Utf8Value sutf8NameSpace(isolate, args[0]);
        std::string sNameSpace = *sutf8NameSpace;
        v8::String::Utf8Value sutf8SymbolAddressMethod(isolate, args[1]);
        std::string sSymbolAddressMethod = *sutf8SymbolAddressMethod;
        uint64_t nSymbolAddressMethod = stoull(sSymbolAddressMethod);
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method InjectComponent.");
        if (wrapperTable->m_InjectComponent == nullptr)
            throw std::runtime_error("Could not call LibAMCF method InjectComponent.");
        LibAMCFResult errorCode = wrapperTable->m_InjectComponent(sNameSpace.c_str(), (void*) nSymbolAddressMethod);
        CheckError(isolate, wrapperTable, nullptr, errorCode);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFWrapper::GetSymbolLookupMethod(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        uint64_t nReturnSymbolLookupMethod = 0;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method GetSymbolLookupMethod.");
        if (wrapperTable->m_GetSymbolLookupMethod == nullptr)
            throw std::runtime_error("Could not call LibAMCF method GetSymbolLookupMethod.");
        LibAMCFResult errorCode = wrapperTable->m_GetSymbolLookupMethod(&nReturnSymbolLookupMethod);
        CheckError(isolate, wrapperTable, nullptr, errorCode);
        args.GetReturnValue().Set(String::NewFromUtf8(isolate, std::to_string(nReturnSymbolLookupMethod).c_str()));

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


void CLibAMCFWrapper::CreateConnection(const FunctionCallbackInfo<Value>& args) 
{
		Isolate* isolate = args.GetIsolate();
		HandleScope scope(isolate);
		try {
        if (!args[0]->IsString()) {
            throw std::runtime_error("Expected string parameter 0 (BaseURL)");
        }
        v8::String::Utf8Value sutf8BaseURL(isolate, args[0]);
        std::string sBaseURL = *sutf8BaseURL;
        LibAMCFHandle hReturnInstance = nullptr;
        sLibAMCFDynamicWrapperTable * wrapperTable = CLibAMCFBaseClass::getDynamicWrapperTable(args.Holder());
        if (wrapperTable == nullptr)
            throw std::runtime_error("Could not get wrapper table for LibAMCF method CreateConnection.");
        if (wrapperTable->m_CreateConnection == nullptr)
            throw std::runtime_error("Could not call LibAMCF method CreateConnection.");
        LibAMCFResult errorCode = wrapperTable->m_CreateConnection(sBaseURL.c_str(), &hReturnInstance);
        CheckError(isolate, wrapperTable, nullptr, errorCode);
        Local<Object> instanceObjInstance = CLibAMCFConnection::NewInstance(args.Holder(), hReturnInstance);
        args.GetReturnValue().Set(instanceObjInstance);

		} catch (std::exception & E) {
				RaiseError(isolate, E.what());
		}
}


