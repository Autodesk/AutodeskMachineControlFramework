'''++

Copyright (C) 2021 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated Python file in order to allow an easy
 use of Autodesk Machine Control Framework SDK

Interface version: 1.0.0

'''


import ctypes
import platform
import enum
import os

name = "libamcf"

'''Definition of domain specific exception
'''
class ELibAMCFException(Exception):
	def __init__(self, code, message = ''):
		self._code = code
		self._message = message
	
	def __str__(self):
		if self._message:
			return 'LibAMCFException ' + str(self._code) + ': '+ str(self._message)
		return 'LibAMCFException ' + str(self._code)

'''Definition of binding API version
'''
class BindingVersion(enum.IntEnum):
	MAJOR = 1
	MINOR = 0
	MICRO = 0

'''Definition Error Codes
'''
class ErrorCodes(enum.IntEnum):
	SUCCESS = 0
	NOTIMPLEMENTED = 1
	INVALIDPARAM = 2
	INVALIDCAST = 3
	BUFFERTOOSMALL = 4
	GENERICEXCEPTION = 5
	COULDNOTLOADLIBRARY = 6
	COULDNOTFINDLIBRARYEXPORT = 7
	INCOMPATIBLEBINARYVERSION = 8
	INVALIDTIMEOUT = 9
	INVALIDRETRYCOUNT = 10
	INVALIDBASEURL = 11
	INVALIDKEYNAME = 12
	RESTRESPONSEISNOOBJECT = 13
	COULDNOTPARSERESTRESPONSE = 14
	RESTRESPONSETIMEOUT = 15
	INVALIDRESTRESPONSE = 16
	COULDNOTCREATESESSION = 17
	COULDNOTRECEIVETOKEN = 18
	OPERATIONRESULTNOTREADY = 19
	RESTERROR = 20

'''Definition of Function Table
'''
class FunctionTable:
	libamcf_getversion = None
	libamcf_getlasterror = None
	libamcf_releaseinstance = None
	libamcf_acquireinstance = None
	libamcf_injectcomponent = None
	libamcf_getsymbollookupmethod = None
	libamcf_createconnection = None
	libamcf_operationresult_waitfor = None
	libamcf_operationresult_inprogress = None
	libamcf_operationresult_success = None
	libamcf_operationresult_geterrormessage = None
	libamcf_datastream_getuuid = None
	libamcf_datastream_getcontextuuid = None
	libamcf_datastream_getname = None
	libamcf_datastream_getmimetype = None
	libamcf_datastream_getsize = None
	libamcf_streamupload_uploaddata = None
	libamcf_streamupload_uploadfile = None
	libamcf_streamupload_beginchunking = None
	libamcf_streamupload_uploadchunk = None
	libamcf_streamupload_finishchunking = None
	libamcf_streamupload_getstatus = None
	libamcf_streamupload_getdatastream = None
	libamcf_connection_getbaseurl = None
	libamcf_connection_settimeouts = None
	libamcf_connection_gettimeout = None
	libamcf_connection_getretrycount = None
	libamcf_connection_authenticatewithpassword = None
	libamcf_connection_isauthenticated = None
	libamcf_connection_refreshauthentication = None
	libamcf_connection_ping = None
	libamcf_connection_getauthtoken = None
	libamcf_connection_createupload = None


'''Wrapper Class Implementation
'''
class Wrapper:

	def __init__(self, libraryName = None, symbolLookupMethodAddress = None):
		ending = ''
		if platform.system() == 'Windows':
			ending = 'dll'
		elif platform.system() == 'Linux':
			ending = 'so'
		elif platform.system() == 'Darwin':
			ending = 'dylib'
		else:
			raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY)
		
		if (not libraryName) and (not symbolLookupMethodAddress):
			libraryName = os.path.join(os.path.dirname(os.path.realpath(__file__)),'libamcf')
		
		if libraryName is not None:
			path = libraryName + '.' + ending
			try:
				self.lib = ctypes.CDLL(path)
			except Exception as e:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(e) + '| "'+path + '"' )
			
			self._loadFunctionTable()
		elif symbolLookupMethodAddress is not None:
				self.lib = FunctionTable()
				self._loadFunctionTableFromMethod(symbolLookupMethodAddress)
		else:
			raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(e))
		
		self._checkBinaryVersion()
	
	def _loadFunctionTableFromMethod(self, symbolLookupMethodAddress):
		try:
			symbolLookupMethodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
			symbolLookupMethod = symbolLookupMethodType(int(symbolLookupMethodAddress))
			
			methodAddress = ctypes.c_void_p()
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_getversion")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32))
			self.lib.libamcf_getversion = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_getlasterror")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.libamcf_getlasterror = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_releaseinstance")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p)
			self.lib.libamcf_releaseinstance = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_acquireinstance")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p)
			self.lib.libamcf_acquireinstance = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_injectcomponent")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_char_p, ctypes.c_void_p)
			self.lib.libamcf_injectcomponent = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_getsymbollookupmethod")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_getsymbollookupmethod = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_createconnection")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_createconnection = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_operationresult_waitfor")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint32, ctypes.POINTER(ctypes.c_bool))
			self.lib.libamcf_operationresult_waitfor = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_operationresult_inprogress")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.libamcf_operationresult_inprogress = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_operationresult_success")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.libamcf_operationresult_success = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_operationresult_geterrormessage")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.libamcf_operationresult_geterrormessage = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_datastream_getuuid")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.libamcf_datastream_getuuid = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_datastream_getcontextuuid")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.libamcf_datastream_getcontextuuid = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_datastream_getname")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.libamcf_datastream_getname = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_datastream_getmimetype")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.libamcf_datastream_getmimetype = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_datastream_getsize")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint64))
			self.lib.libamcf_datastream_getsize = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_streamupload_uploaddata")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32, ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_streamupload_uploaddata = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_streamupload_uploadfile")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_uint32, ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_streamupload_uploadfile = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_streamupload_beginchunking")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64)
			self.lib.libamcf_streamupload_beginchunking = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_streamupload_uploadchunk")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint8), ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_streamupload_uploadchunk = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_streamupload_finishchunking")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint8), ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_streamupload_finishchunking = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_streamupload_getstatus")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(ctypes.c_bool))
			self.lib.libamcf_streamupload_getstatus = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_streamupload_getdatastream")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_streamupload_getdatastream = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_getbaseurl")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.libamcf_connection_getbaseurl = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_settimeouts")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32)
			self.lib.libamcf_connection_settimeouts = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_gettimeout")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint32))
			self.lib.libamcf_connection_gettimeout = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_getretrycount")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint32))
			self.lib.libamcf_connection_getretrycount = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_authenticatewithpassword")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_connection_authenticatewithpassword = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_isauthenticated")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool))
			self.lib.libamcf_connection_isauthenticated = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_refreshauthentication")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_connection_refreshauthentication = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_ping")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_connection_ping = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_getauthtoken")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p)
			self.lib.libamcf_connection_getauthtoken = methodType(int(methodAddress.value))
			
			err = symbolLookupMethod(ctypes.c_char_p(str.encode("libamcf_connection_createupload")), methodAddress)
			if err != 0:
				raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, str(err))
			methodType = ctypes.CFUNCTYPE(ctypes.c_int32, ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p))
			self.lib.libamcf_connection_createupload = methodType(int(methodAddress.value))
			
		except AttributeError as ae:
			raise ELibAMCFException(ErrorCodes.COULDNOTFINDLIBRARYEXPORT, ae.args[0])
		
	def _loadFunctionTable(self):
		try:
			self.lib.libamcf_getversion.restype = ctypes.c_int32
			self.lib.libamcf_getversion.argtypes = [ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32), ctypes.POINTER(ctypes.c_uint32)]
			
			self.lib.libamcf_getlasterror.restype = ctypes.c_int32
			self.lib.libamcf_getlasterror.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.libamcf_releaseinstance.restype = ctypes.c_int32
			self.lib.libamcf_releaseinstance.argtypes = [ctypes.c_void_p]
			
			self.lib.libamcf_acquireinstance.restype = ctypes.c_int32
			self.lib.libamcf_acquireinstance.argtypes = [ctypes.c_void_p]
			
			self.lib.libamcf_injectcomponent.restype = ctypes.c_int32
			self.lib.libamcf_injectcomponent.argtypes = [ctypes.c_char_p, ctypes.c_void_p]
			
			self.lib.libamcf_getsymbollookupmethod.restype = ctypes.c_int32
			self.lib.libamcf_getsymbollookupmethod.argtypes = [ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_createconnection.restype = ctypes.c_int32
			self.lib.libamcf_createconnection.argtypes = [ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_operationresult_waitfor.restype = ctypes.c_int32
			self.lib.libamcf_operationresult_waitfor.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.libamcf_operationresult_inprogress.restype = ctypes.c_int32
			self.lib.libamcf_operationresult_inprogress.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.libamcf_operationresult_success.restype = ctypes.c_int32
			self.lib.libamcf_operationresult_success.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.libamcf_operationresult_geterrormessage.restype = ctypes.c_int32
			self.lib.libamcf_operationresult_geterrormessage.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.libamcf_datastream_getuuid.restype = ctypes.c_int32
			self.lib.libamcf_datastream_getuuid.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.libamcf_datastream_getcontextuuid.restype = ctypes.c_int32
			self.lib.libamcf_datastream_getcontextuuid.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.libamcf_datastream_getname.restype = ctypes.c_int32
			self.lib.libamcf_datastream_getname.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.libamcf_datastream_getmimetype.restype = ctypes.c_int32
			self.lib.libamcf_datastream_getmimetype.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.libamcf_datastream_getsize.restype = ctypes.c_int32
			self.lib.libamcf_datastream_getsize.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint64)]
			
			self.lib.libamcf_streamupload_uploaddata.restype = ctypes.c_int32
			self.lib.libamcf_streamupload_uploaddata.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint8), ctypes.c_uint32, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_streamupload_uploadfile.restype = ctypes.c_int32
			self.lib.libamcf_streamupload_uploadfile.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_uint32, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_streamupload_beginchunking.restype = ctypes.c_int32
			self.lib.libamcf_streamupload_beginchunking.argtypes = [ctypes.c_void_p, ctypes.c_uint64]
			
			self.lib.libamcf_streamupload_uploadchunk.restype = ctypes.c_int32
			self.lib.libamcf_streamupload_uploadchunk.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint8), ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_streamupload_finishchunking.restype = ctypes.c_int32
			self.lib.libamcf_streamupload_finishchunking.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint8), ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_streamupload_getstatus.restype = ctypes.c_int32
			self.lib.libamcf_streamupload_getstatus.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(ctypes.c_uint64), ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.libamcf_streamupload_getdatastream.restype = ctypes.c_int32
			self.lib.libamcf_streamupload_getdatastream.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_connection_getbaseurl.restype = ctypes.c_int32
			self.lib.libamcf_connection_getbaseurl.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.libamcf_connection_settimeouts.restype = ctypes.c_int32
			self.lib.libamcf_connection_settimeouts.argtypes = [ctypes.c_void_p, ctypes.c_uint32, ctypes.c_uint32]
			
			self.lib.libamcf_connection_gettimeout.restype = ctypes.c_int32
			self.lib.libamcf_connection_gettimeout.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint32)]
			
			self.lib.libamcf_connection_getretrycount.restype = ctypes.c_int32
			self.lib.libamcf_connection_getretrycount.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_uint32)]
			
			self.lib.libamcf_connection_authenticatewithpassword.restype = ctypes.c_int32
			self.lib.libamcf_connection_authenticatewithpassword.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_connection_isauthenticated.restype = ctypes.c_int32
			self.lib.libamcf_connection_isauthenticated.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_bool)]
			
			self.lib.libamcf_connection_refreshauthentication.restype = ctypes.c_int32
			self.lib.libamcf_connection_refreshauthentication.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_connection_ping.restype = ctypes.c_int32
			self.lib.libamcf_connection_ping.argtypes = [ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p)]
			
			self.lib.libamcf_connection_getauthtoken.restype = ctypes.c_int32
			self.lib.libamcf_connection_getauthtoken.argtypes = [ctypes.c_void_p, ctypes.c_uint64, ctypes.POINTER(ctypes.c_uint64), ctypes.c_char_p]
			
			self.lib.libamcf_connection_createupload.restype = ctypes.c_int32
			self.lib.libamcf_connection_createupload.argtypes = [ctypes.c_void_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.c_char_p, ctypes.POINTER(ctypes.c_void_p)]
			
		except AttributeError as ae:
			raise ELibAMCFException(ErrorCodes.COULDNOTFINDLIBRARYEXPORT, ae.args[0])
	
	def _checkBinaryVersion(self):
		nMajor, nMinor, _ = self.GetVersion()
		if (nMajor != BindingVersion.MAJOR) or (nMinor < BindingVersion.MINOR):
			raise ELibAMCFException(ErrorCodes.INCOMPATIBLEBINARYVERSION)
	
	def checkError(self, instance, errorCode):
		if errorCode != ErrorCodes.SUCCESS.value:
			if instance:
				if instance._wrapper != self:
					raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'invalid wrapper call')
			message,_ = self.GetLastError(instance)
			raise ELibAMCFException(errorCode, message)
	
	def GetVersion(self):
		pMajor = ctypes.c_uint32()
		pMinor = ctypes.c_uint32()
		pMicro = ctypes.c_uint32()
		self.checkError(None, self.lib.libamcf_getversion(pMajor, pMinor, pMicro))
		
		return pMajor.value, pMinor.value, pMicro.value
	
	def GetLastError(self, InstanceObject):
		InstanceHandle = None
		if InstanceObject:
			InstanceHandle = InstanceObject._handle
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDPARAM, 'Invalid return/output value')
		nErrorMessageBufferSize = ctypes.c_uint64(0)
		nErrorMessageNeededChars = ctypes.c_uint64(0)
		pErrorMessageBuffer = ctypes.c_char_p(None)
		pHasError = ctypes.c_bool()
		self.checkError(None, self.lib.libamcf_getlasterror(InstanceHandle, nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer, pHasError))
		nErrorMessageBufferSize = ctypes.c_uint64(nErrorMessageNeededChars.value)
		pErrorMessageBuffer = (ctypes.c_char * (nErrorMessageNeededChars.value))()
		self.checkError(None, self.lib.libamcf_getlasterror(InstanceHandle, nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer, pHasError))
		
		return pErrorMessageBuffer.value.decode(), pHasError.value
	
	def ReleaseInstance(self, InstanceObject):
		InstanceHandle = None
		if InstanceObject:
			InstanceHandle = InstanceObject._handle
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDPARAM, 'Invalid return/output value')
		self.checkError(None, self.lib.libamcf_releaseinstance(InstanceHandle))
		
	
	def AcquireInstance(self, InstanceObject):
		InstanceHandle = None
		if InstanceObject:
			InstanceHandle = InstanceObject._handle
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDPARAM, 'Invalid return/output value')
		self.checkError(None, self.lib.libamcf_acquireinstance(InstanceHandle))
		
	
	def InjectComponent(self, NameSpace, SymbolAddressMethod):
		pNameSpace = ctypes.c_char_p(str.encode(NameSpace))
		pSymbolAddressMethod = ctypes.c_void_p(SymbolAddressMethod)
		self.checkError(None, self.lib.libamcf_injectcomponent(pNameSpace, pSymbolAddressMethod))
		
		bNameSpaceFound = False
		if not bNameSpaceFound:
			raise ELibAMCFException(ErrorCodes.COULDNOTLOADLIBRARY, "Unknown namespace " + NameSpace)
		
	
	def GetSymbolLookupMethod(self):
		pSymbolLookupMethod = ctypes.c_void_p()
		self.checkError(None, self.lib.libamcf_getsymbollookupmethod(pSymbolLookupMethod))
		
		return pSymbolLookupMethod.value
	
	def CreateConnection(self, BaseURL):
		pBaseURL = ctypes.c_char_p(str.encode(BaseURL))
		InstanceHandle = ctypes.c_void_p()
		self.checkError(None, self.lib.libamcf_createconnection(pBaseURL, InstanceHandle))
		if InstanceHandle:
			InstanceObject = Connection(InstanceHandle, self)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return InstanceObject
	


''' Class Implementation for Base
'''
class Base:
	def __init__(self, handle, wrapper):
		if not handle or not wrapper:
			raise ELibAMCFException(ErrorCodes.INVALIDPARAM)
		self._handle = handle
		self._wrapper = wrapper
	
	def __del__(self):
		self._wrapper.ReleaseInstance(self)


''' Class Implementation for OperationResult
'''
class OperationResult(Base):
	def __init__(self, handle, wrapper):
		Base.__init__(self, handle, wrapper)
	def WaitFor(self, TimeOut):
		nTimeOut = ctypes.c_uint32(TimeOut)
		pOperationFinished = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_operationresult_waitfor(self._handle, nTimeOut, pOperationFinished))
		
		return pOperationFinished.value
	
	def InProgress(self):
		pOperationIsInProgress = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_operationresult_inprogress(self._handle, pOperationIsInProgress))
		
		return pOperationIsInProgress.value
	
	def Success(self):
		pOperationSuccess = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_operationresult_success(self._handle, pOperationSuccess))
		
		return pOperationSuccess.value
	
	def GetErrorMessage(self):
		nErrorMessageBufferSize = ctypes.c_uint64(0)
		nErrorMessageNeededChars = ctypes.c_uint64(0)
		pErrorMessageBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_operationresult_geterrormessage(self._handle, nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer))
		nErrorMessageBufferSize = ctypes.c_uint64(nErrorMessageNeededChars.value)
		pErrorMessageBuffer = (ctypes.c_char * (nErrorMessageNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_operationresult_geterrormessage(self._handle, nErrorMessageBufferSize, nErrorMessageNeededChars, pErrorMessageBuffer))
		
		return pErrorMessageBuffer.value.decode()
	


''' Class Implementation for DataStream
'''
class DataStream(Base):
	def __init__(self, handle, wrapper):
		Base.__init__(self, handle, wrapper)
	def GetUUID(self):
		nUUIDBufferSize = ctypes.c_uint64(0)
		nUUIDNeededChars = ctypes.c_uint64(0)
		pUUIDBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_datastream_getuuid(self._handle, nUUIDBufferSize, nUUIDNeededChars, pUUIDBuffer))
		nUUIDBufferSize = ctypes.c_uint64(nUUIDNeededChars.value)
		pUUIDBuffer = (ctypes.c_char * (nUUIDNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_datastream_getuuid(self._handle, nUUIDBufferSize, nUUIDNeededChars, pUUIDBuffer))
		
		return pUUIDBuffer.value.decode()
	
	def GetContextUUID(self):
		nContextUUIDBufferSize = ctypes.c_uint64(0)
		nContextUUIDNeededChars = ctypes.c_uint64(0)
		pContextUUIDBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_datastream_getcontextuuid(self._handle, nContextUUIDBufferSize, nContextUUIDNeededChars, pContextUUIDBuffer))
		nContextUUIDBufferSize = ctypes.c_uint64(nContextUUIDNeededChars.value)
		pContextUUIDBuffer = (ctypes.c_char * (nContextUUIDNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_datastream_getcontextuuid(self._handle, nContextUUIDBufferSize, nContextUUIDNeededChars, pContextUUIDBuffer))
		
		return pContextUUIDBuffer.value.decode()
	
	def GetName(self):
		nNameBufferSize = ctypes.c_uint64(0)
		nNameNeededChars = ctypes.c_uint64(0)
		pNameBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_datastream_getname(self._handle, nNameBufferSize, nNameNeededChars, pNameBuffer))
		nNameBufferSize = ctypes.c_uint64(nNameNeededChars.value)
		pNameBuffer = (ctypes.c_char * (nNameNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_datastream_getname(self._handle, nNameBufferSize, nNameNeededChars, pNameBuffer))
		
		return pNameBuffer.value.decode()
	
	def GetMimeType(self):
		nMimeTypeBufferSize = ctypes.c_uint64(0)
		nMimeTypeNeededChars = ctypes.c_uint64(0)
		pMimeTypeBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_datastream_getmimetype(self._handle, nMimeTypeBufferSize, nMimeTypeNeededChars, pMimeTypeBuffer))
		nMimeTypeBufferSize = ctypes.c_uint64(nMimeTypeNeededChars.value)
		pMimeTypeBuffer = (ctypes.c_char * (nMimeTypeNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_datastream_getmimetype(self._handle, nMimeTypeBufferSize, nMimeTypeNeededChars, pMimeTypeBuffer))
		
		return pMimeTypeBuffer.value.decode()
	
	def GetSize(self):
		pStreamSize = ctypes.c_uint64()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_datastream_getsize(self._handle, pStreamSize))
		
		return pStreamSize.value
	


''' Class Implementation for StreamUpload
'''
class StreamUpload(Base):
	def __init__(self, handle, wrapper):
		Base.__init__(self, handle, wrapper)
	def UploadData(self, Data, ChunkSize):
		nDataCount = ctypes.c_uint64(len(Data))
		pDataBuffer = (ctypes.c_uint8*len(Data))(*Data)
		nChunkSize = ctypes.c_uint32(ChunkSize)
		SuccessHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_streamupload_uploaddata(self._handle, nDataCount, pDataBuffer, nChunkSize, SuccessHandle))
		if SuccessHandle:
			SuccessObject = OperationResult(SuccessHandle, self._wrapper)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return SuccessObject
	
	def UploadFile(self, FileName, ChunkSize):
		pFileName = ctypes.c_char_p(str.encode(FileName))
		nChunkSize = ctypes.c_uint32(ChunkSize)
		SuccessHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_streamupload_uploadfile(self._handle, pFileName, nChunkSize, SuccessHandle))
		if SuccessHandle:
			SuccessObject = OperationResult(SuccessHandle, self._wrapper)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return SuccessObject
	
	def BeginChunking(self, DataSize):
		nDataSize = ctypes.c_uint64(DataSize)
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_streamupload_beginchunking(self._handle, nDataSize))
		
	
	def UploadChunk(self, Data):
		nDataCount = ctypes.c_uint64(len(Data))
		pDataBuffer = (ctypes.c_uint8*len(Data))(*Data)
		SuccessHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_streamupload_uploadchunk(self._handle, nDataCount, pDataBuffer, SuccessHandle))
		if SuccessHandle:
			SuccessObject = OperationResult(SuccessHandle, self._wrapper)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return SuccessObject
	
	def FinishChunking(self, Data):
		nDataCount = ctypes.c_uint64(len(Data))
		pDataBuffer = (ctypes.c_uint8*len(Data))(*Data)
		SuccessHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_streamupload_finishchunking(self._handle, nDataCount, pDataBuffer, SuccessHandle))
		if SuccessHandle:
			SuccessObject = OperationResult(SuccessHandle, self._wrapper)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return SuccessObject
	
	def GetStatus(self):
		pUploadSize = ctypes.c_uint64()
		pUploadedBytes = ctypes.c_uint64()
		pFinished = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_streamupload_getstatus(self._handle, pUploadSize, pUploadedBytes, pFinished))
		
		return pUploadSize.value, pUploadedBytes.value, pFinished.value
	
	def GetDataStream(self):
		DataStreamHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_streamupload_getdatastream(self._handle, DataStreamHandle))
		if DataStreamHandle:
			DataStreamObject = DataStream(DataStreamHandle, self._wrapper)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return DataStreamObject
	


''' Class Implementation for Connection
'''
class Connection(Base):
	def __init__(self, handle, wrapper):
		Base.__init__(self, handle, wrapper)
	def GetBaseURL(self):
		nBaseURLBufferSize = ctypes.c_uint64(0)
		nBaseURLNeededChars = ctypes.c_uint64(0)
		pBaseURLBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_getbaseurl(self._handle, nBaseURLBufferSize, nBaseURLNeededChars, pBaseURLBuffer))
		nBaseURLBufferSize = ctypes.c_uint64(nBaseURLNeededChars.value)
		pBaseURLBuffer = (ctypes.c_char * (nBaseURLNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_getbaseurl(self._handle, nBaseURLBufferSize, nBaseURLNeededChars, pBaseURLBuffer))
		
		return pBaseURLBuffer.value.decode()
	
	def SetTimeouts(self, Timeout, RetryCount):
		nTimeout = ctypes.c_uint32(Timeout)
		nRetryCount = ctypes.c_uint32(RetryCount)
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_settimeouts(self._handle, nTimeout, nRetryCount))
		
	
	def GetTimeout(self):
		pTimeout = ctypes.c_uint32()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_gettimeout(self._handle, pTimeout))
		
		return pTimeout.value
	
	def GetRetryCount(self):
		pRetryCount = ctypes.c_uint32()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_getretrycount(self._handle, pRetryCount))
		
		return pRetryCount.value
	
	def AuthenticateWithPassword(self, UserName, Password):
		pUserName = ctypes.c_char_p(str.encode(UserName))
		pPassword = ctypes.c_char_p(str.encode(Password))
		SuccessHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_authenticatewithpassword(self._handle, pUserName, pPassword, SuccessHandle))
		if SuccessHandle:
			SuccessObject = OperationResult(SuccessHandle, self._wrapper)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return SuccessObject
	
	def IsAuthenticated(self):
		pIsAuthenticated = ctypes.c_bool()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_isauthenticated(self._handle, pIsAuthenticated))
		
		return pIsAuthenticated.value
	
	def RefreshAuthentication(self):
		SuccessHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_refreshauthentication(self._handle, SuccessHandle))
		if SuccessHandle:
			SuccessObject = OperationResult(SuccessHandle, self._wrapper)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return SuccessObject
	
	def Ping(self):
		SuccessHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_ping(self._handle, SuccessHandle))
		if SuccessHandle:
			SuccessObject = OperationResult(SuccessHandle, self._wrapper)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return SuccessObject
	
	def GetAuthToken(self):
		nTokenBufferSize = ctypes.c_uint64(0)
		nTokenNeededChars = ctypes.c_uint64(0)
		pTokenBuffer = ctypes.c_char_p(None)
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_getauthtoken(self._handle, nTokenBufferSize, nTokenNeededChars, pTokenBuffer))
		nTokenBufferSize = ctypes.c_uint64(nTokenNeededChars.value)
		pTokenBuffer = (ctypes.c_char * (nTokenNeededChars.value))()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_getauthtoken(self._handle, nTokenBufferSize, nTokenNeededChars, pTokenBuffer))
		
		return pTokenBuffer.value.decode()
	
	def CreateUpload(self, Name, MimeType, UsageContext):
		pName = ctypes.c_char_p(str.encode(Name))
		pMimeType = ctypes.c_char_p(str.encode(MimeType))
		pUsageContext = ctypes.c_char_p(str.encode(UsageContext))
		InstanceHandle = ctypes.c_void_p()
		self._wrapper.checkError(self, self._wrapper.lib.libamcf_connection_createupload(self._handle, pName, pMimeType, pUsageContext, InstanceHandle))
		if InstanceHandle:
			InstanceObject = StreamUpload(InstanceHandle, self._wrapper)
		else:
			raise ELibAMCFException(ErrorCodes.INVALIDCAST, 'Invalid return/output value')
		
		return InstanceObject
	
		
