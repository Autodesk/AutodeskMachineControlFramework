/*++

Copyright (C) 2021 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Autodesk Machine Control Framework SDK

Interface version: 1.0.0

*/

#ifndef __LIBAMCF_CPPHEADER_IMPLICIT_CPP
#define __LIBAMCF_CPPHEADER_IMPLICIT_CPP

#include "libamcf_types.hpp"
#include "libamcf_abi.hpp"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibAMCF {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class COperationResult;
class CDataStream;
class CStreamUpload;
class CConnection;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibAMCFWrapper;
typedef CBase CLibAMCFBase;
typedef COperationResult CLibAMCFOperationResult;
typedef CDataStream CLibAMCFDataStream;
typedef CStreamUpload CLibAMCFStreamUpload;
typedef CConnection CLibAMCFConnection;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<COperationResult> POperationResult;
typedef std::shared_ptr<CDataStream> PDataStream;
typedef std::shared_ptr<CStreamUpload> PStreamUpload;
typedef std::shared_ptr<CConnection> PConnection;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibAMCFWrapper;
typedef PBase PLibAMCFBase;
typedef POperationResult PLibAMCFOperationResult;
typedef PDataStream PLibAMCFDataStream;
typedef PStreamUpload PLibAMCFStreamUpload;
typedef PConnection PLibAMCFConnection;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibAMCFHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibAMCFException 
**************************************************************************************************************************/
class ELibAMCFException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibAMCFResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibAMCFException(LibAMCFResult errorCode, const std::string & sErrorMessage)
		: m_errorMessage("LibAMCF Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
	{
		m_errorCode = errorCode;
	}

	/**
	* Returns error code
	*/
	LibAMCFResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector( const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector( const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibAMCFInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	CWrapper()
	{
	}
	
	~CWrapper()
	{
	}
	static inline PWrapper loadLibrary()
	{
		return std::make_shared<CWrapper>();
	}
	
	inline void CheckError(CBase * pBaseClass, LibAMCFResult nResult);

	inline void GetVersion(LibAMCF_uint32 & nMajor, LibAMCF_uint32 & nMinor, LibAMCF_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibAMCF_pvoid pSymbolAddressMethod);
	inline LibAMCF_pvoid GetSymbolLookupMethod();
	inline PConnection CreateConnection(const std::string & sBaseURL);

private:
	
	LibAMCFResult checkBinaryVersion()
	{
		LibAMCF_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != LIBAMCF_VERSION_MAJOR) || (nMinor < LIBAMCF_VERSION_MINOR) ) {
			return LIBAMCF_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBAMCF_SUCCESS;
	}

	friend class CBase;
	friend class COperationResult;
	friend class CDataStream;
	friend class CStreamUpload;
	friend class CConnection;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibAMCFHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibAMCFResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibAMCFHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibAMCFHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class COperationResult 
**************************************************************************************************************************/
class COperationResult : public CBase {
public:
	
	/**
	* COperationResult::COperationResult - Constructor for OperationResult class.
	*/
	COperationResult(CWrapper* pWrapper, LibAMCFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool WaitFor(const LibAMCF_uint32 nTimeOut);
	inline void EnsureSuccess();
	inline bool InProgress();
	inline bool Success();
	inline std::string GetErrorMessage();
};
	
/*************************************************************************************************************************
 Class CDataStream 
**************************************************************************************************************************/
class CDataStream : public CBase {
public:
	
	/**
	* CDataStream::CDataStream - Constructor for DataStream class.
	*/
	CDataStream(CWrapper* pWrapper, LibAMCFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline void GetContext(eStreamContextType & eContextType, std::string & sOwnerUUID);
	inline std::string GetName();
	inline std::string GetMimeType();
	inline std::string GetSHA256();
	inline LibAMCF_uint64 GetSize();
	inline std::string GetTimestamp();
};
	
/*************************************************************************************************************************
 Class CStreamUpload 
**************************************************************************************************************************/
class CStreamUpload : public CBase {
public:
	
	/**
	* CStreamUpload::CStreamUpload - Constructor for StreamUpload class.
	*/
	CStreamUpload(CWrapper* pWrapper, LibAMCFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetMimeType();
	inline eStreamContextType GetContextType();
	inline POperationResult UploadData(const CInputVector<LibAMCF_uint8> & DataBuffer, const LibAMCF_uint32 nChunkSize, const LibAMCF_uint32 nThreadCount);
	inline POperationResult UploadFile(const std::string & sFileName, const LibAMCF_uint32 nChunkSize, const LibAMCF_uint32 nThreadCount);
	inline POperationResult BeginChunking(const LibAMCF_uint64 nDataSize);
	inline POperationResult UploadChunk(const CInputVector<LibAMCF_uint8> & DataBuffer);
	inline POperationResult FinishChunking();
	inline void GetStatus(LibAMCF_uint64 & nUploadSize, LibAMCF_uint64 & nFinishedSize, LibAMCF_uint64 & nInProgressSize, bool & bFinished);
	inline PDataStream GetDataStream();
};
	
/*************************************************************************************************************************
 Class CConnection 
**************************************************************************************************************************/
class CConnection : public CBase {
public:
	
	/**
	* CConnection::CConnection - Constructor for Connection class.
	*/
	CConnection(CWrapper* pWrapper, LibAMCFHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetBaseURL();
	inline void SetTimeouts(const LibAMCF_uint32 nTimeout, const LibAMCF_uint32 nRetryCount);
	inline LibAMCF_uint32 GetTimeout();
	inline LibAMCF_uint32 GetRetryCount();
	inline POperationResult AuthenticateWithPassword(const std::string & sUserName, const std::string & sPassword);
	inline bool IsAuthenticated();
	inline POperationResult RefreshAuthentication();
	inline POperationResult Ping();
	inline std::string GetAuthToken();
	inline PStreamUpload CreateUpload(const std::string & sName, const std::string & sMimeType, const eStreamContextType eContextType);
	inline POperationResult PrepareBuild(classParam<CDataStream> pDataStream);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibAMCF_uint32 & nMajor, LibAMCF_uint32 & nMinor, LibAMCF_uint32 & nMicro)
	{
		CheckError(nullptr,libamcf_getversion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibAMCFHandle hInstance = pInstance.GetHandle();
		LibAMCF_uint32 bytesNeededErrorMessage = 0;
		LibAMCF_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,libamcf_getlasterror(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,libamcf_getlasterror(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibAMCFHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,libamcf_releaseinstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibAMCFHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,libamcf_acquireinstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibAMCF_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,libamcf_injectcomponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (!bNameSpaceFound)
			throw ELibAMCFException(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibAMCF_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibAMCF_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,libamcf_getsymbollookupmethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateConnection - Creates a AMCF connection instance.
	* @param[in] sBaseURL - Base URL of the AMCF Instance.
	* @return New Connection instance
	*/
	inline PConnection CWrapper::CreateConnection(const std::string & sBaseURL)
	{
		LibAMCFHandle hInstance = nullptr;
		CheckError(nullptr,libamcf_createconnection(sBaseURL.c_str(), &hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CConnection>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibAMCFResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibAMCFException(nResult, sErrorMessage);
		}
	}
	

	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class COperationResult
	 */
	
	/**
	* COperationResult::WaitFor - Waits for operation to be finished.
	* @param[in] nTimeOut - Timeout value in Milliseconds. 0 means forever.
	* @return Returns if operation has been finished.
	*/
	bool COperationResult::WaitFor(const LibAMCF_uint32 nTimeOut)
	{
		bool resultOperationFinished = 0;
		CheckError(libamcf_operationresult_waitfor(m_pHandle, nTimeOut, &resultOperationFinished));
		
		return resultOperationFinished;
	}
	
	/**
	* COperationResult::EnsureSuccess - Waits for operation to be successfully finished. Throws an error if not successful.
	*/
	void COperationResult::EnsureSuccess()
	{
		CheckError(libamcf_operationresult_ensuresuccess(m_pHandle));
	}
	
	/**
	* COperationResult::InProgress - Checks if operation is in progress.
	* @return Flag if operation is in progress.
	*/
	bool COperationResult::InProgress()
	{
		bool resultOperationIsInProgress = 0;
		CheckError(libamcf_operationresult_inprogress(m_pHandle, &resultOperationIsInProgress));
		
		return resultOperationIsInProgress;
	}
	
	/**
	* COperationResult::Success - Checks if operation has been finished successfully. Waits for operation to finish.
	* @return Flag if operation has been finished successful.
	*/
	bool COperationResult::Success()
	{
		bool resultOperationSuccess = 0;
		CheckError(libamcf_operationresult_success(m_pHandle, &resultOperationSuccess));
		
		return resultOperationSuccess;
	}
	
	/**
	* COperationResult::GetErrorMessage - Returns the error message, if the operation has not been successful. Fails if operation is in progress.
	* @return Returns error message of failed operation.
	*/
	std::string COperationResult::GetErrorMessage()
	{
		LibAMCF_uint32 bytesNeededErrorMessage = 0;
		LibAMCF_uint32 bytesWrittenErrorMessage = 0;
		CheckError(libamcf_operationresult_geterrormessage(m_pHandle, 0, &bytesNeededErrorMessage, nullptr));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(libamcf_operationresult_geterrormessage(m_pHandle, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0]));
		
		return std::string(&bufferErrorMessage[0]);
	}
	
	/**
	 * Method definitions for class CDataStream
	 */
	
	/**
	* CDataStream::GetUUID - Returns the stream UUID.
	* @return Stream UUID String.
	*/
	std::string CDataStream::GetUUID()
	{
		LibAMCF_uint32 bytesNeededUUID = 0;
		LibAMCF_uint32 bytesWrittenUUID = 0;
		CheckError(libamcf_datastream_getuuid(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(libamcf_datastream_getuuid(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CDataStream::GetContext - Returns the stream's context type and owner UUID.
	* @param[out] eContextType - Stream Context Type.
	* @param[out] sOwnerUUID - Stream Context UUID String.
	*/
	void CDataStream::GetContext(eStreamContextType & eContextType, std::string & sOwnerUUID)
	{
		LibAMCF_uint32 bytesNeededOwnerUUID = 0;
		LibAMCF_uint32 bytesWrittenOwnerUUID = 0;
		CheckError(libamcf_datastream_getcontext(m_pHandle, &eContextType, 0, &bytesNeededOwnerUUID, nullptr));
		std::vector<char> bufferOwnerUUID(bytesNeededOwnerUUID);
		CheckError(libamcf_datastream_getcontext(m_pHandle, &eContextType, bytesNeededOwnerUUID, &bytesWrittenOwnerUUID, &bufferOwnerUUID[0]));
		sOwnerUUID = std::string(&bufferOwnerUUID[0]);
	}
	
	/**
	* CDataStream::GetName - Returns the stream name.
	* @return Stream Name.
	*/
	std::string CDataStream::GetName()
	{
		LibAMCF_uint32 bytesNeededName = 0;
		LibAMCF_uint32 bytesWrittenName = 0;
		CheckError(libamcf_datastream_getname(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(libamcf_datastream_getname(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDataStream::GetMimeType - Returns the stream's mime type.
	* @return Mime Type string.
	*/
	std::string CDataStream::GetMimeType()
	{
		LibAMCF_uint32 bytesNeededMimeType = 0;
		LibAMCF_uint32 bytesWrittenMimeType = 0;
		CheckError(libamcf_datastream_getmimetype(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(libamcf_datastream_getmimetype(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	* CDataStream::GetSHA256 - Returns the sha256 checksum of the stream.
	* @return SHA256 string.
	*/
	std::string CDataStream::GetSHA256()
	{
		LibAMCF_uint32 bytesNeededSHA256 = 0;
		LibAMCF_uint32 bytesWrittenSHA256 = 0;
		CheckError(libamcf_datastream_getsha256(m_pHandle, 0, &bytesNeededSHA256, nullptr));
		std::vector<char> bufferSHA256(bytesNeededSHA256);
		CheckError(libamcf_datastream_getsha256(m_pHandle, bytesNeededSHA256, &bytesWrittenSHA256, &bufferSHA256[0]));
		
		return std::string(&bufferSHA256[0]);
	}
	
	/**
	* CDataStream::GetSize - Returns the stream size.
	* @return Stream size.
	*/
	LibAMCF_uint64 CDataStream::GetSize()
	{
		LibAMCF_uint64 resultStreamSize = 0;
		CheckError(libamcf_datastream_getsize(m_pHandle, &resultStreamSize));
		
		return resultStreamSize;
	}
	
	/**
	* CDataStream::GetTimestamp - Returns the timestamp of the stream.
	* @return Timestamp string.
	*/
	std::string CDataStream::GetTimestamp()
	{
		LibAMCF_uint32 bytesNeededTimestamp = 0;
		LibAMCF_uint32 bytesWrittenTimestamp = 0;
		CheckError(libamcf_datastream_gettimestamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(libamcf_datastream_gettimestamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	 * Method definitions for class CStreamUpload
	 */
	
	/**
	* CStreamUpload::GetName - returns the name of the stream upload
	* @return Name String.
	*/
	std::string CStreamUpload::GetName()
	{
		LibAMCF_uint32 bytesNeededName = 0;
		LibAMCF_uint32 bytesWrittenName = 0;
		CheckError(libamcf_streamupload_getname(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(libamcf_streamupload_getname(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CStreamUpload::GetMimeType - returns the mimetype of the stream upload
	* @return MimeType String.
	*/
	std::string CStreamUpload::GetMimeType()
	{
		LibAMCF_uint32 bytesNeededMimeType = 0;
		LibAMCF_uint32 bytesWrittenMimeType = 0;
		CheckError(libamcf_streamupload_getmimetype(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(libamcf_streamupload_getmimetype(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	* CStreamUpload::GetContextType - returns the usage context of the stream upload
	* @return Stream Context Type.
	*/
	eStreamContextType CStreamUpload::GetContextType()
	{
		eStreamContextType resultContextType = (eStreamContextType) 0;
		CheckError(libamcf_streamupload_getcontexttype(m_pHandle, &resultContextType));
		
		return resultContextType;
	}
	
	/**
	* CStreamUpload::UploadData - uploads the passed data to the server. MUST only be called once.
	* @param[in] DataBuffer - Data to be uploaded.
	* @param[in] nChunkSize - Chunk size to use in bytes. MUST be a multiple of 64kB. MUST be at least 64kB and less than 64MB.
	* @param[in] nThreadCount - How many concurrent threads shall be maximally used.
	* @return Returns if upload was successful.
	*/
	POperationResult CStreamUpload::UploadData(const CInputVector<LibAMCF_uint8> & DataBuffer, const LibAMCF_uint32 nChunkSize, const LibAMCF_uint32 nThreadCount)
	{
		LibAMCFHandle hSuccess = nullptr;
		CheckError(libamcf_streamupload_uploaddata(m_pHandle, (LibAMCF_uint64)DataBuffer.size(), DataBuffer.data(), nChunkSize, nThreadCount, &hSuccess));
		
		if (!hSuccess) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COperationResult>(m_pWrapper, hSuccess);
	}
	
	/**
	* CStreamUpload::UploadFile - uploads a file to the server. MUST only be called once.
	* @param[in] sFileName - File to be uploaded.
	* @param[in] nChunkSize - Chunk size to use in bytes. MUST be a multiple of 64kB. MUST be at least 64kB and less than 64MB.
	* @param[in] nThreadCount - How many concurrent threads shall be maximally used.
	* @return Returns if upload was successful.
	*/
	POperationResult CStreamUpload::UploadFile(const std::string & sFileName, const LibAMCF_uint32 nChunkSize, const LibAMCF_uint32 nThreadCount)
	{
		LibAMCFHandle hSuccess = nullptr;
		CheckError(libamcf_streamupload_uploadfile(m_pHandle, sFileName.c_str(), nChunkSize, nThreadCount, &hSuccess));
		
		if (!hSuccess) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COperationResult>(m_pWrapper, hSuccess);
	}
	
	/**
	* CStreamUpload::BeginChunking - Starts a chunked upload. MUST not be used together with uploadData or uploadFile
	* @param[in] nDataSize - Full data size to be uploaded.
	* @return Returns if request was successful.
	*/
	POperationResult CStreamUpload::BeginChunking(const LibAMCF_uint64 nDataSize)
	{
		LibAMCFHandle hSuccess = nullptr;
		CheckError(libamcf_streamupload_beginchunking(m_pHandle, nDataSize, &hSuccess));
		
		if (!hSuccess) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COperationResult>(m_pWrapper, hSuccess);
	}
	
	/**
	* CStreamUpload::UploadChunk - Uploads another chunk to the server. Chunks are added sequentially together.
	* @param[in] DataBuffer - Data to be uploaded. Any chunk that is not the last chunk MUST have the size of a multiple of 64kB. A chunk MUST be less than 64MB.
	* @return Returns if request was successful.
	*/
	POperationResult CStreamUpload::UploadChunk(const CInputVector<LibAMCF_uint8> & DataBuffer)
	{
		LibAMCFHandle hSuccess = nullptr;
		CheckError(libamcf_streamupload_uploadchunk(m_pHandle, (LibAMCF_uint64)DataBuffer.size(), DataBuffer.data(), &hSuccess));
		
		if (!hSuccess) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COperationResult>(m_pWrapper, hSuccess);
	}
	
	/**
	* CStreamUpload::FinishChunking - MUST only be called after all chunks have been uploaded.
	* @return Returns if request was successful.
	*/
	POperationResult CStreamUpload::FinishChunking()
	{
		LibAMCFHandle hSuccess = nullptr;
		CheckError(libamcf_streamupload_finishchunking(m_pHandle, &hSuccess));
		
		if (!hSuccess) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COperationResult>(m_pWrapper, hSuccess);
	}
	
	/**
	* CStreamUpload::GetStatus - Retrieves current upload status.
	* @param[out] nUploadSize - Total target size of the upload. 0 if no upload has been started.
	* @param[out] nFinishedSize - Current bytes that have been successfully uploaded.
	* @param[out] nInProgressSize - Current bytes that have been uploaded or are currently in progress.
	* @param[out] bFinished - Flag if upload has successfully finished.
	*/
	void CStreamUpload::GetStatus(LibAMCF_uint64 & nUploadSize, LibAMCF_uint64 & nFinishedSize, LibAMCF_uint64 & nInProgressSize, bool & bFinished)
	{
		CheckError(libamcf_streamupload_getstatus(m_pHandle, &nUploadSize, &nFinishedSize, &nInProgressSize, &bFinished));
	}
	
	/**
	* CStreamUpload::GetDataStream - Retrieves the uploaded data stream object. Upload must have finished successfully.
	* @return Data stream instance.
	*/
	PDataStream CStreamUpload::GetDataStream()
	{
		LibAMCFHandle hDataStream = nullptr;
		CheckError(libamcf_streamupload_getdatastream(m_pHandle, &hDataStream));
		
		if (!hDataStream) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataStream>(m_pWrapper, hDataStream);
	}
	
	/**
	 * Method definitions for class CConnection
	 */
	
	/**
	* CConnection::GetBaseURL - returns the base url of the AMCF instance
	* @return Base URL of the AMCF instance.
	*/
	std::string CConnection::GetBaseURL()
	{
		LibAMCF_uint32 bytesNeededBaseURL = 0;
		LibAMCF_uint32 bytesWrittenBaseURL = 0;
		CheckError(libamcf_connection_getbaseurl(m_pHandle, 0, &bytesNeededBaseURL, nullptr));
		std::vector<char> bufferBaseURL(bytesNeededBaseURL);
		CheckError(libamcf_connection_getbaseurl(m_pHandle, bytesNeededBaseURL, &bytesWrittenBaseURL, &bufferBaseURL[0]));
		
		return std::string(&bufferBaseURL[0]);
	}
	
	/**
	* CConnection::SetTimeouts - sets the timeout behaviour of the connection.
	* @param[in] nTimeout - Request timeout in milliseconds. Default is 1000.
	* @param[in] nRetryCount - How many retries should be done in an error case. Default is 3.
	*/
	void CConnection::SetTimeouts(const LibAMCF_uint32 nTimeout, const LibAMCF_uint32 nRetryCount)
	{
		CheckError(libamcf_connection_settimeouts(m_pHandle, nTimeout, nRetryCount));
	}
	
	/**
	* CConnection::GetTimeout - gets the timeout behaviour of the connection.
	* @return Request timeout in milliseconds
	*/
	LibAMCF_uint32 CConnection::GetTimeout()
	{
		LibAMCF_uint32 resultTimeout = 0;
		CheckError(libamcf_connection_gettimeout(m_pHandle, &resultTimeout));
		
		return resultTimeout;
	}
	
	/**
	* CConnection::GetRetryCount - gets the timeout behaviour of the connection.
	* @return How many retries should be done in an error case.
	*/
	LibAMCF_uint32 CConnection::GetRetryCount()
	{
		LibAMCF_uint32 resultRetryCount = 0;
		CheckError(libamcf_connection_getretrycount(m_pHandle, &resultRetryCount));
		
		return resultRetryCount;
	}
	
	/**
	* CConnection::AuthenticateWithPassword - Authenticates with the remote instance with username and password.
	* @param[in] sUserName - User name for authentication.
	* @param[in] sPassword - Password for authentication.
	* @return Returns if authentication was successful.
	*/
	POperationResult CConnection::AuthenticateWithPassword(const std::string & sUserName, const std::string & sPassword)
	{
		LibAMCFHandle hSuccess = nullptr;
		CheckError(libamcf_connection_authenticatewithpassword(m_pHandle, sUserName.c_str(), sPassword.c_str(), &hSuccess));
		
		if (!hSuccess) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COperationResult>(m_pWrapper, hSuccess);
	}
	
	/**
	* CConnection::IsAuthenticated - Authenticates with the remote instance with username and password
	* @return Returns if connection is authenticated.
	*/
	bool CConnection::IsAuthenticated()
	{
		bool resultIsAuthenticated = 0;
		CheckError(libamcf_connection_isauthenticated(m_pHandle, &resultIsAuthenticated));
		
		return resultIsAuthenticated;
	}
	
	/**
	* CConnection::RefreshAuthentication - Refreshes authentication with server.
	* @return Returns if authentication refresh was successful.
	*/
	POperationResult CConnection::RefreshAuthentication()
	{
		LibAMCFHandle hSuccess = nullptr;
		CheckError(libamcf_connection_refreshauthentication(m_pHandle, &hSuccess));
		
		if (!hSuccess) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COperationResult>(m_pWrapper, hSuccess);
	}
	
	/**
	* CConnection::Ping - Detects if server is still reachable. Non-Blocking.
	* @return Returns if server is still reachable.
	*/
	POperationResult CConnection::Ping()
	{
		LibAMCFHandle hSuccess = nullptr;
		CheckError(libamcf_connection_ping(m_pHandle, &hSuccess));
		
		if (!hSuccess) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COperationResult>(m_pWrapper, hSuccess);
	}
	
	/**
	* CConnection::GetAuthToken - Returns the authentication token of the current connection.
	* @return Token string.
	*/
	std::string CConnection::GetAuthToken()
	{
		LibAMCF_uint32 bytesNeededToken = 0;
		LibAMCF_uint32 bytesWrittenToken = 0;
		CheckError(libamcf_connection_getauthtoken(m_pHandle, 0, &bytesNeededToken, nullptr));
		std::vector<char> bufferToken(bytesNeededToken);
		CheckError(libamcf_connection_getauthtoken(m_pHandle, bytesNeededToken, &bytesWrittenToken, &bufferToken[0]));
		
		return std::string(&bufferToken[0]);
	}
	
	/**
	* CConnection::CreateUpload - Creates a file upload instance. Must be authenticated to make it work.
	* @param[in] sName - Name of the file to be uploaded.
	* @param[in] sMimeType - Mimetype of the file to be uploaded.
	* @param[in] eContextType - Stream Context Type.
	* @return File upload instance.
	*/
	PStreamUpload CConnection::CreateUpload(const std::string & sName, const std::string & sMimeType, const eStreamContextType eContextType)
	{
		LibAMCFHandle hInstance = nullptr;
		CheckError(libamcf_connection_createupload(m_pHandle, sName.c_str(), sMimeType.c_str(), eContextType, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStreamUpload>(m_pWrapper, hInstance);
	}
	
	/**
	* CConnection::PrepareBuild - Prepares a build from an uploaded data stream. Must be authenticated to make it work.
	* @param[in] pDataStream - Data stream MUST have been created as build job context type.
	* @return Returns if build preparation was successful.
	*/
	POperationResult CConnection::PrepareBuild(classParam<CDataStream> pDataStream)
	{
		LibAMCFHandle hDataStream = pDataStream.GetHandle();
		LibAMCFHandle hSuccess = nullptr;
		CheckError(libamcf_connection_preparebuild(m_pHandle, hDataStream, &hSuccess));
		
		if (!hSuccess) {
			CheckError(LIBAMCF_ERROR_INVALIDPARAM);
		}
		return std::make_shared<COperationResult>(m_pWrapper, hSuccess);
	}

} // namespace LibAMCF

#endif // __LIBAMCF_CPPHEADER_IMPLICIT_CPP

