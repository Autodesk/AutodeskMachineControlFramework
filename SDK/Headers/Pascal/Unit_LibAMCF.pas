{$IFDEF FPC}{$MODE DELPHI}{$ENDIF}
(*++

Copyright (C) 2021 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated Pascal Header file in order to allow an easy
 use of Autodesk Machine Control Framework SDK

Interface version: 1.0.0

*)

unit Unit_LibAMCF;

interface

uses
	{$IFDEF WINDOWS}
		Windows,
	{$ELSE}
		dynlibs,
	{$ENDIF}
	Types,
	Classes,
	SysUtils;

(*************************************************************************************************************************
 Version definition for LibAMCF
**************************************************************************************************************************)

const
	LIBAMCF_VERSION_MAJOR = 1;
	LIBAMCF_VERSION_MINOR = 0;
	LIBAMCF_VERSION_MICRO = 0;
	LIBAMCF_VERSION_PRERELEASEINFO = '';
	LIBAMCF_VERSION_BUILDINFO = '';


(*************************************************************************************************************************
 General type definitions
**************************************************************************************************************************)

type
	TLibAMCFResult = Cardinal;
	TLibAMCFHandle = Pointer;

	PLibAMCFResult = ^TLibAMCFResult;
	PLibAMCFHandle = ^TLibAMCFHandle;

(*************************************************************************************************************************
 Error Constants for LibAMCF
**************************************************************************************************************************)

const
	LIBAMCF_SUCCESS = 0;
	LIBAMCF_ERROR_NOTIMPLEMENTED = 1;
	LIBAMCF_ERROR_INVALIDPARAM = 2;
	LIBAMCF_ERROR_INVALIDCAST = 3;
	LIBAMCF_ERROR_BUFFERTOOSMALL = 4;
	LIBAMCF_ERROR_GENERICEXCEPTION = 5;
	LIBAMCF_ERROR_COULDNOTLOADLIBRARY = 6;
	LIBAMCF_ERROR_COULDNOTFINDLIBRARYEXPORT = 7;
	LIBAMCF_ERROR_INCOMPATIBLEBINARYVERSION = 8;
	LIBAMCF_ERROR_INVALIDTIMEOUT = 9;
	LIBAMCF_ERROR_INVALIDRETRYCOUNT = 10;
	LIBAMCF_ERROR_INVALIDBASEURL = 11;
	LIBAMCF_ERROR_INVALIDKEYNAME = 12;
	LIBAMCF_ERROR_RESTRESPONSEISNOOBJECT = 13;
	LIBAMCF_ERROR_COULDNOTPARSERESTRESPONSE = 14;
	LIBAMCF_ERROR_RESTRESPONSETIMEOUT = 15;
	LIBAMCF_ERROR_INVALIDRESTRESPONSE = 16;
	LIBAMCF_ERROR_COULDNOTCREATESESSION = 17;
	LIBAMCF_ERROR_COULDNOTRECEIVETOKEN = 18;
	LIBAMCF_ERROR_OPERATIONRESULTNOTREADY = 19;
	LIBAMCF_ERROR_RESTERROR = 20;
	LIBAMCF_ERROR_INVALIDUPLOADCHUNKSIZE = 21;
	LIBAMCF_ERROR_CANNOTUPLOADEMPTYDATA = 22;
	LIBAMCF_ERROR_COULDNOTBEGINSTREAMUPLOAD = 23;
	LIBAMCF_ERROR_BEGINCHUNKINGALREADYCALLED = 24;
	LIBAMCF_ERROR_BEGINCHUNKINGNOTCALLED = 25;
	LIBAMCF_ERROR_UPLOADDATAEXCEEDSTOTALSIZE = 26;
	LIBAMCF_ERROR_BEGINCHUNKINGFAILED = 27;


(*************************************************************************************************************************
 Declaration of handle classes 
**************************************************************************************************************************)

type
	TLibAMCFWrapper = class;
	TLibAMCFBase = class;
	TLibAMCFOperationResult = class;
	TLibAMCFDataStream = class;
	TLibAMCFStreamUpload = class;
	TLibAMCFConnection = class;


(*************************************************************************************************************************
 Function type definitions for Base
**************************************************************************************************************************)


(*************************************************************************************************************************
 Function type definitions for OperationResult
**************************************************************************************************************************)

	(**
	* Waits for operation to be finished.
	*
	* @param[in] pOperationResult - OperationResult instance.
	* @param[in] nTimeOut - Timeout value in Milliseconds. 0 means forever.
	* @param[out] pOperationFinished - Returns if operation has been finished.
	* @return error code or 0 (success)
	*)
	TLibAMCFOperationResult_WaitForFunc = function(pOperationResult: TLibAMCFHandle; const nTimeOut: Cardinal; out pOperationFinished: Byte): TLibAMCFResult; cdecl;
	
	(**
	* Checks if operation is in progress.
	*
	* @param[in] pOperationResult - OperationResult instance.
	* @param[out] pOperationIsInProgress - Flag if operation is in progress.
	* @return error code or 0 (success)
	*)
	TLibAMCFOperationResult_InProgressFunc = function(pOperationResult: TLibAMCFHandle; out pOperationIsInProgress: Byte): TLibAMCFResult; cdecl;
	
	(**
	* Checks if operation has been finished successfully. Waits for operation to finish.
	*
	* @param[in] pOperationResult - OperationResult instance.
	* @param[out] pOperationSuccess - Flag if operation has been finished successful.
	* @return error code or 0 (success)
	*)
	TLibAMCFOperationResult_SuccessFunc = function(pOperationResult: TLibAMCFHandle; out pOperationSuccess: Byte): TLibAMCFResult; cdecl;
	
	(**
	* Returns the error message, if the operation has not been successful. Fails if operation is in progress.
	*
	* @param[in] pOperationResult - OperationResult instance.
	* @param[in] nErrorMessageBufferSize - size of the buffer (including trailing 0)
	* @param[out] pErrorMessageNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pErrorMessageBuffer -  buffer of Returns error message of failed operation., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFOperationResult_GetErrorMessageFunc = function(pOperationResult: TLibAMCFHandle; const nErrorMessageBufferSize: Cardinal; out pErrorMessageNeededChars: Cardinal; pErrorMessageBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	

(*************************************************************************************************************************
 Function type definitions for DataStream
**************************************************************************************************************************)

	(**
	* Returns the stream UUID.
	*
	* @param[in] pDataStream - DataStream instance.
	* @param[in] nUUIDBufferSize - size of the buffer (including trailing 0)
	* @param[out] pUUIDNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pUUIDBuffer -  buffer of Stream UUID String., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFDataStream_GetUUIDFunc = function(pDataStream: TLibAMCFHandle; const nUUIDBufferSize: Cardinal; out pUUIDNeededChars: Cardinal; pUUIDBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	
	(**
	* Returns the stream's context UUID.
	*
	* @param[in] pDataStream - DataStream instance.
	* @param[in] nContextUUIDBufferSize - size of the buffer (including trailing 0)
	* @param[out] pContextUUIDNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pContextUUIDBuffer -  buffer of Stream Context UUID String., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFDataStream_GetContextUUIDFunc = function(pDataStream: TLibAMCFHandle; const nContextUUIDBufferSize: Cardinal; out pContextUUIDNeededChars: Cardinal; pContextUUIDBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	
	(**
	* Returns the stream name.
	*
	* @param[in] pDataStream - DataStream instance.
	* @param[in] nNameBufferSize - size of the buffer (including trailing 0)
	* @param[out] pNameNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pNameBuffer -  buffer of Stream Name., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFDataStream_GetNameFunc = function(pDataStream: TLibAMCFHandle; const nNameBufferSize: Cardinal; out pNameNeededChars: Cardinal; pNameBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	
	(**
	* Returns the stream's mime type.
	*
	* @param[in] pDataStream - DataStream instance.
	* @param[in] nMimeTypeBufferSize - size of the buffer (including trailing 0)
	* @param[out] pMimeTypeNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pMimeTypeBuffer -  buffer of Mime Type string., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFDataStream_GetMimeTypeFunc = function(pDataStream: TLibAMCFHandle; const nMimeTypeBufferSize: Cardinal; out pMimeTypeNeededChars: Cardinal; pMimeTypeBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	
	(**
	* Returns the stream size.
	*
	* @param[in] pDataStream - DataStream instance.
	* @param[out] pStreamSize - Stream size.
	* @return error code or 0 (success)
	*)
	TLibAMCFDataStream_GetSizeFunc = function(pDataStream: TLibAMCFHandle; out pStreamSize: QWord): TLibAMCFResult; cdecl;
	

(*************************************************************************************************************************
 Function type definitions for StreamUpload
**************************************************************************************************************************)

	(**
	* returns the name of the stream upload
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[in] nNameBufferSize - size of the buffer (including trailing 0)
	* @param[out] pNameNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pNameBuffer -  buffer of Name String., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_GetNameFunc = function(pStreamUpload: TLibAMCFHandle; const nNameBufferSize: Cardinal; out pNameNeededChars: Cardinal; pNameBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	
	(**
	* returns the mimetype of the stream upload
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[in] nMimeTypeBufferSize - size of the buffer (including trailing 0)
	* @param[out] pMimeTypeNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pMimeTypeBuffer -  buffer of MimeType String., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_GetMimeTypeFunc = function(pStreamUpload: TLibAMCFHandle; const nMimeTypeBufferSize: Cardinal; out pMimeTypeNeededChars: Cardinal; pMimeTypeBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	
	(**
	* returns the usage context of the stream upload
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[in] nUsageContextBufferSize - size of the buffer (including trailing 0)
	* @param[out] pUsageContextNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pUsageContextBuffer -  buffer of UsageContext String., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_GetUsageContextFunc = function(pStreamUpload: TLibAMCFHandle; const nUsageContextBufferSize: Cardinal; out pUsageContextNeededChars: Cardinal; pUsageContextBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	
	(**
	* uploads the passed data to the server. MUST only be called once.
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[in] nDataCount - Number of elements in buffer
	* @param[in] pDataBuffer - uint8 buffer of Data to be uploaded.
	* @param[in] nChunkSize - Chunk size to use in bytes. MUST be a multiple of 64kB. MUST be at least 64kB and less than 64MB.
	* @param[out] pSuccess - Returns if upload was successful.
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_UploadDataFunc = function(pStreamUpload: TLibAMCFHandle; const nDataCount: QWord; const pDataBuffer: PByte; const nChunkSize: Cardinal; out pSuccess: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* uploads a file to the server. MUST only be called once.
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[in] pFileName - File to be uploaded.
	* @param[in] nChunkSize - Chunk size to use in bytes. MUST be a multiple of 64kB. MUST be at least 64kB and less than 64MB.
	* @param[out] pSuccess - Returns if upload was successful.
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_UploadFileFunc = function(pStreamUpload: TLibAMCFHandle; const pFileName: PAnsiChar; const nChunkSize: Cardinal; out pSuccess: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* Starts a chunked upload. MUST not be used together with uploadData or uploadFile
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[in] nDataSize - Full data size to be uploaded.
	* @param[out] pSuccess - Returns if request was successful.
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_BeginChunkingFunc = function(pStreamUpload: TLibAMCFHandle; const nDataSize: QWord; out pSuccess: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* Uploads another chunk to the server. Chunks are added sequentially together.
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[in] nDataCount - Number of elements in buffer
	* @param[in] pDataBuffer - uint8 buffer of Data to be uploaded. Any chunk that is not the last chunk MUST have the size of a multiple of 64kB. A chunk MUST be less than 64MB.
	* @param[out] pSuccess - Returns if request was successful.
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_UploadChunkFunc = function(pStreamUpload: TLibAMCFHandle; const nDataCount: QWord; const pDataBuffer: PByte; out pSuccess: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* MUST only be called after all chunks have been uploaded.
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[out] pSuccess - Returns if request was successful.
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_FinishChunkingFunc = function(pStreamUpload: TLibAMCFHandle; out pSuccess: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* Retrieves current upload status.
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[out] pUploadSize - Total size of the upload.
	* @param[out] pUploadedBytes - Current uploaded data.
	* @param[out] pFinished - Upload has been finished.
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_GetStatusFunc = function(pStreamUpload: TLibAMCFHandle; out pUploadSize: QWord; out pUploadedBytes: QWord; out pFinished: Byte): TLibAMCFResult; cdecl;
	
	(**
	* Retrieves the uploaded data stream object. Upload must have finished successfully.
	*
	* @param[in] pStreamUpload - StreamUpload instance.
	* @param[out] pDataStream - Data stream instance.
	* @return error code or 0 (success)
	*)
	TLibAMCFStreamUpload_GetDataStreamFunc = function(pStreamUpload: TLibAMCFHandle; out pDataStream: TLibAMCFHandle): TLibAMCFResult; cdecl;
	

(*************************************************************************************************************************
 Function type definitions for Connection
**************************************************************************************************************************)

	(**
	* returns the base url of the AMCF instance
	*
	* @param[in] pConnection - Connection instance.
	* @param[in] nBaseURLBufferSize - size of the buffer (including trailing 0)
	* @param[out] pBaseURLNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pBaseURLBuffer -  buffer of Base URL of the AMCF instance., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_GetBaseURLFunc = function(pConnection: TLibAMCFHandle; const nBaseURLBufferSize: Cardinal; out pBaseURLNeededChars: Cardinal; pBaseURLBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	
	(**
	* sets the timeout behaviour of the connection.
	*
	* @param[in] pConnection - Connection instance.
	* @param[in] nTimeout - Request timeout in milliseconds. Default is 1000.
	* @param[in] nRetryCount - How many retries should be done in an error case. Default is 3.
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_SetTimeoutsFunc = function(pConnection: TLibAMCFHandle; const nTimeout: Cardinal; const nRetryCount: Cardinal): TLibAMCFResult; cdecl;
	
	(**
	* gets the timeout behaviour of the connection.
	*
	* @param[in] pConnection - Connection instance.
	* @param[out] pTimeout - Request timeout in milliseconds
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_GetTimeoutFunc = function(pConnection: TLibAMCFHandle; out pTimeout: Cardinal): TLibAMCFResult; cdecl;
	
	(**
	* gets the timeout behaviour of the connection.
	*
	* @param[in] pConnection - Connection instance.
	* @param[out] pRetryCount - How many retries should be done in an error case.
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_GetRetryCountFunc = function(pConnection: TLibAMCFHandle; out pRetryCount: Cardinal): TLibAMCFResult; cdecl;
	
	(**
	* Authenticates with the remote instance with username and password.
	*
	* @param[in] pConnection - Connection instance.
	* @param[in] pUserName - User name for authentication.
	* @param[in] pPassword - Password for authentication.
	* @param[out] pSuccess - Returns if authentication was successful.
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_AuthenticateWithPasswordFunc = function(pConnection: TLibAMCFHandle; const pUserName: PAnsiChar; const pPassword: PAnsiChar; out pSuccess: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* Authenticates with the remote instance with username and password
	*
	* @param[in] pConnection - Connection instance.
	* @param[out] pIsAuthenticated - Returns if connection is authenticated.
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_IsAuthenticatedFunc = function(pConnection: TLibAMCFHandle; out pIsAuthenticated: Byte): TLibAMCFResult; cdecl;
	
	(**
	* Refreshes authentication with server.
	*
	* @param[in] pConnection - Connection instance.
	* @param[out] pSuccess - Returns if authentication refresh was successful.
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_RefreshAuthenticationFunc = function(pConnection: TLibAMCFHandle; out pSuccess: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* Detects if server is still reachable. Non-Blocking.
	*
	* @param[in] pConnection - Connection instance.
	* @param[out] pSuccess - Returns if server is still reachable.
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_PingFunc = function(pConnection: TLibAMCFHandle; out pSuccess: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* Returns the authentication token of the current connection.
	*
	* @param[in] pConnection - Connection instance.
	* @param[in] nTokenBufferSize - size of the buffer (including trailing 0)
	* @param[out] pTokenNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pTokenBuffer -  buffer of Token string., may be NULL
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_GetAuthTokenFunc = function(pConnection: TLibAMCFHandle; const nTokenBufferSize: Cardinal; out pTokenNeededChars: Cardinal; pTokenBuffer: PAnsiChar): TLibAMCFResult; cdecl;
	
	(**
	* Creates a file upload instance. Must be authenticated to make it work.
	*
	* @param[in] pConnection - Connection instance.
	* @param[in] pName - Name of the file to be uploaded.
	* @param[in] pMimeType - Mimetype of the file to be uploaded.
	* @param[in] pUsageContext - Context string for the usage type of the file.
	* @param[out] pInstance - File upload instance.
	* @return error code or 0 (success)
	*)
	TLibAMCFConnection_CreateUploadFunc = function(pConnection: TLibAMCFHandle; const pName: PAnsiChar; const pMimeType: PAnsiChar; const pUsageContext: PAnsiChar; out pInstance: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
(*************************************************************************************************************************
 Global function definitions 
**************************************************************************************************************************)

	(**
	* retrieves the binary version of this library.
	*
	* @param[out] pMajor - returns the major version of this library
	* @param[out] pMinor - returns the minor version of this library
	* @param[out] pMicro - returns the micro version of this library
	* @return error code or 0 (success)
	*)
	TLibAMCFGetVersionFunc = function(out pMajor: Cardinal; out pMinor: Cardinal; out pMicro: Cardinal): TLibAMCFResult; cdecl;
	
	(**
	* Returns the last error recorded on this object
	*
	* @param[in] pInstance - Instance Handle
	* @param[in] nErrorMessageBufferSize - size of the buffer (including trailing 0)
	* @param[out] pErrorMessageNeededChars - will be filled with the count of the written bytes, or needed buffer size.
	* @param[out] pErrorMessageBuffer -  buffer of Message of the last error, may be NULL
	* @param[out] pHasError - Is there a last error to query
	* @return error code or 0 (success)
	*)
	TLibAMCFGetLastErrorFunc = function(const pInstance: TLibAMCFHandle; const nErrorMessageBufferSize: Cardinal; out pErrorMessageNeededChars: Cardinal; pErrorMessageBuffer: PAnsiChar; out pHasError: Byte): TLibAMCFResult; cdecl;
	
	(**
	* Releases shared ownership of an Instance
	*
	* @param[in] pInstance - Instance Handle
	* @return error code or 0 (success)
	*)
	TLibAMCFReleaseInstanceFunc = function(const pInstance: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* Acquires shared ownership of an Instance
	*
	* @param[in] pInstance - Instance Handle
	* @return error code or 0 (success)
	*)
	TLibAMCFAcquireInstanceFunc = function(const pInstance: TLibAMCFHandle): TLibAMCFResult; cdecl;
	
	(**
	* Injects an imported component for usage within this component
	*
	* @param[in] pNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	* @return error code or 0 (success)
	*)
	TLibAMCFInjectComponentFunc = function(const pNameSpace: PAnsiChar; const pSymbolAddressMethod: Pointer): TLibAMCFResult; cdecl;
	
	(**
	* Returns the address of the SymbolLookupMethod
	*
	* @param[out] pSymbolLookupMethod - Address of the SymbolAddressMethod
	* @return error code or 0 (success)
	*)
	TLibAMCFGetSymbolLookupMethodFunc = function(out pSymbolLookupMethod: Pointer): TLibAMCFResult; cdecl;
	
	(**
	* Creates a AMCF connection instance.
	*
	* @param[in] pBaseURL - Base URL of the AMCF Instance.
	* @param[out] pInstance - New Connection instance
	* @return error code or 0 (success)
	*)
	TLibAMCFCreateConnectionFunc = function(const pBaseURL: PAnsiChar; out pInstance: TLibAMCFHandle): TLibAMCFResult; cdecl;
	

(*************************************************************************************************************************
 Helper function pointer definitions 
**************************************************************************************************************************)
TLibAMCFSymbolLookupMethod = function(const pSymbolName: PAnsiChar; out pValue: Pointer): TLibAMCFResult; cdecl;

(*************************************************************************************************************************
 Exception definition
**************************************************************************************************************************)

	ELibAMCFException = class(Exception)
	private
		FErrorCode: TLibAMCFResult;
		FCustomMessage: String;
	public
		property ErrorCode: TLibAMCFResult read FErrorCode;
		property CustomMessage: String read FCustomMessage;
		constructor Create(AErrorCode: TLibAMCFResult; AMessage: String);
		constructor CreateCustomMessage(AErrorCode: TLibAMCFResult; AMessage: String);
	end;


(*************************************************************************************************************************
 Class definition for Base
**************************************************************************************************************************)

 TLibAMCFBase = class(TObject)
	private
		FWrapper: TLibAMCFWrapper;
		FHandle: TLibAMCFHandle;
	public
		constructor Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
		destructor Destroy; override;
		property TheHandle: TLibAMCFHandle read FHandle;
	end;


(*************************************************************************************************************************
 Class definition for OperationResult
**************************************************************************************************************************)

	TLibAMCFOperationResult = class(TLibAMCFBase)
	public
		constructor Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
		destructor Destroy; override;
		function WaitFor(const ATimeOut: Cardinal): Boolean;
		function InProgress(): Boolean;
		function Success(): Boolean;
		function GetErrorMessage(): String;
	end;


(*************************************************************************************************************************
 Class definition for DataStream
**************************************************************************************************************************)

	TLibAMCFDataStream = class(TLibAMCFBase)
	public
		constructor Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
		destructor Destroy; override;
		function GetUUID(): String;
		function GetContextUUID(): String;
		function GetName(): String;
		function GetMimeType(): String;
		function GetSize(): QWord;
	end;


(*************************************************************************************************************************
 Class definition for StreamUpload
**************************************************************************************************************************)

	TLibAMCFStreamUpload = class(TLibAMCFBase)
	public
		constructor Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
		destructor Destroy; override;
		function GetName(): String;
		function GetMimeType(): String;
		function GetUsageContext(): String;
		function UploadData(const AData: TByteDynArray; const AChunkSize: Cardinal): TLibAMCFOperationResult;
		function UploadFile(const AFileName: String; const AChunkSize: Cardinal): TLibAMCFOperationResult;
		function BeginChunking(const ADataSize: QWord): TLibAMCFOperationResult;
		function UploadChunk(const AData: TByteDynArray): TLibAMCFOperationResult;
		function FinishChunking(): TLibAMCFOperationResult;
		procedure GetStatus(out AUploadSize: QWord; out AUploadedBytes: QWord; out AFinished: Boolean);
		function GetDataStream(): TLibAMCFDataStream;
	end;


(*************************************************************************************************************************
 Class definition for Connection
**************************************************************************************************************************)

	TLibAMCFConnection = class(TLibAMCFBase)
	public
		constructor Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
		destructor Destroy; override;
		function GetBaseURL(): String;
		procedure SetTimeouts(const ATimeout: Cardinal; const ARetryCount: Cardinal);
		function GetTimeout(): Cardinal;
		function GetRetryCount(): Cardinal;
		function AuthenticateWithPassword(const AUserName: String; const APassword: String): TLibAMCFOperationResult;
		function IsAuthenticated(): Boolean;
		function RefreshAuthentication(): TLibAMCFOperationResult;
		function Ping(): TLibAMCFOperationResult;
		function GetAuthToken(): String;
		function CreateUpload(const AName: String; const AMimeType: String; const AUsageContext: String): TLibAMCFStreamUpload;
	end;

(*************************************************************************************************************************
 Wrapper definition
**************************************************************************************************************************)

	TLibAMCFWrapper = class(TObject)
	private
		FModule: HMODULE;
		FLibAMCFOperationResult_WaitForFunc: TLibAMCFOperationResult_WaitForFunc;
		FLibAMCFOperationResult_InProgressFunc: TLibAMCFOperationResult_InProgressFunc;
		FLibAMCFOperationResult_SuccessFunc: TLibAMCFOperationResult_SuccessFunc;
		FLibAMCFOperationResult_GetErrorMessageFunc: TLibAMCFOperationResult_GetErrorMessageFunc;
		FLibAMCFDataStream_GetUUIDFunc: TLibAMCFDataStream_GetUUIDFunc;
		FLibAMCFDataStream_GetContextUUIDFunc: TLibAMCFDataStream_GetContextUUIDFunc;
		FLibAMCFDataStream_GetNameFunc: TLibAMCFDataStream_GetNameFunc;
		FLibAMCFDataStream_GetMimeTypeFunc: TLibAMCFDataStream_GetMimeTypeFunc;
		FLibAMCFDataStream_GetSizeFunc: TLibAMCFDataStream_GetSizeFunc;
		FLibAMCFStreamUpload_GetNameFunc: TLibAMCFStreamUpload_GetNameFunc;
		FLibAMCFStreamUpload_GetMimeTypeFunc: TLibAMCFStreamUpload_GetMimeTypeFunc;
		FLibAMCFStreamUpload_GetUsageContextFunc: TLibAMCFStreamUpload_GetUsageContextFunc;
		FLibAMCFStreamUpload_UploadDataFunc: TLibAMCFStreamUpload_UploadDataFunc;
		FLibAMCFStreamUpload_UploadFileFunc: TLibAMCFStreamUpload_UploadFileFunc;
		FLibAMCFStreamUpload_BeginChunkingFunc: TLibAMCFStreamUpload_BeginChunkingFunc;
		FLibAMCFStreamUpload_UploadChunkFunc: TLibAMCFStreamUpload_UploadChunkFunc;
		FLibAMCFStreamUpload_FinishChunkingFunc: TLibAMCFStreamUpload_FinishChunkingFunc;
		FLibAMCFStreamUpload_GetStatusFunc: TLibAMCFStreamUpload_GetStatusFunc;
		FLibAMCFStreamUpload_GetDataStreamFunc: TLibAMCFStreamUpload_GetDataStreamFunc;
		FLibAMCFConnection_GetBaseURLFunc: TLibAMCFConnection_GetBaseURLFunc;
		FLibAMCFConnection_SetTimeoutsFunc: TLibAMCFConnection_SetTimeoutsFunc;
		FLibAMCFConnection_GetTimeoutFunc: TLibAMCFConnection_GetTimeoutFunc;
		FLibAMCFConnection_GetRetryCountFunc: TLibAMCFConnection_GetRetryCountFunc;
		FLibAMCFConnection_AuthenticateWithPasswordFunc: TLibAMCFConnection_AuthenticateWithPasswordFunc;
		FLibAMCFConnection_IsAuthenticatedFunc: TLibAMCFConnection_IsAuthenticatedFunc;
		FLibAMCFConnection_RefreshAuthenticationFunc: TLibAMCFConnection_RefreshAuthenticationFunc;
		FLibAMCFConnection_PingFunc: TLibAMCFConnection_PingFunc;
		FLibAMCFConnection_GetAuthTokenFunc: TLibAMCFConnection_GetAuthTokenFunc;
		FLibAMCFConnection_CreateUploadFunc: TLibAMCFConnection_CreateUploadFunc;
		FLibAMCFGetVersionFunc: TLibAMCFGetVersionFunc;
		FLibAMCFGetLastErrorFunc: TLibAMCFGetLastErrorFunc;
		FLibAMCFReleaseInstanceFunc: TLibAMCFReleaseInstanceFunc;
		FLibAMCFAcquireInstanceFunc: TLibAMCFAcquireInstanceFunc;
		FLibAMCFInjectComponentFunc: TLibAMCFInjectComponentFunc;
		FLibAMCFGetSymbolLookupMethodFunc: TLibAMCFGetSymbolLookupMethodFunc;
		FLibAMCFCreateConnectionFunc: TLibAMCFCreateConnectionFunc;

		{$IFDEF MSWINDOWS}
		function LoadFunction(AFunctionName: AnsiString; FailIfNotExistent: Boolean = True): FARPROC;
		{$ELSE}
		function LoadFunction(AFunctionName: AnsiString; FailIfNotExistent: Boolean = True): Pointer;
		{$ENDIF MSWINDOWS}

		procedure checkBinaryVersion();

	protected
		property LibAMCFOperationResult_WaitForFunc: TLibAMCFOperationResult_WaitForFunc read FLibAMCFOperationResult_WaitForFunc;
		property LibAMCFOperationResult_InProgressFunc: TLibAMCFOperationResult_InProgressFunc read FLibAMCFOperationResult_InProgressFunc;
		property LibAMCFOperationResult_SuccessFunc: TLibAMCFOperationResult_SuccessFunc read FLibAMCFOperationResult_SuccessFunc;
		property LibAMCFOperationResult_GetErrorMessageFunc: TLibAMCFOperationResult_GetErrorMessageFunc read FLibAMCFOperationResult_GetErrorMessageFunc;
		property LibAMCFDataStream_GetUUIDFunc: TLibAMCFDataStream_GetUUIDFunc read FLibAMCFDataStream_GetUUIDFunc;
		property LibAMCFDataStream_GetContextUUIDFunc: TLibAMCFDataStream_GetContextUUIDFunc read FLibAMCFDataStream_GetContextUUIDFunc;
		property LibAMCFDataStream_GetNameFunc: TLibAMCFDataStream_GetNameFunc read FLibAMCFDataStream_GetNameFunc;
		property LibAMCFDataStream_GetMimeTypeFunc: TLibAMCFDataStream_GetMimeTypeFunc read FLibAMCFDataStream_GetMimeTypeFunc;
		property LibAMCFDataStream_GetSizeFunc: TLibAMCFDataStream_GetSizeFunc read FLibAMCFDataStream_GetSizeFunc;
		property LibAMCFStreamUpload_GetNameFunc: TLibAMCFStreamUpload_GetNameFunc read FLibAMCFStreamUpload_GetNameFunc;
		property LibAMCFStreamUpload_GetMimeTypeFunc: TLibAMCFStreamUpload_GetMimeTypeFunc read FLibAMCFStreamUpload_GetMimeTypeFunc;
		property LibAMCFStreamUpload_GetUsageContextFunc: TLibAMCFStreamUpload_GetUsageContextFunc read FLibAMCFStreamUpload_GetUsageContextFunc;
		property LibAMCFStreamUpload_UploadDataFunc: TLibAMCFStreamUpload_UploadDataFunc read FLibAMCFStreamUpload_UploadDataFunc;
		property LibAMCFStreamUpload_UploadFileFunc: TLibAMCFStreamUpload_UploadFileFunc read FLibAMCFStreamUpload_UploadFileFunc;
		property LibAMCFStreamUpload_BeginChunkingFunc: TLibAMCFStreamUpload_BeginChunkingFunc read FLibAMCFStreamUpload_BeginChunkingFunc;
		property LibAMCFStreamUpload_UploadChunkFunc: TLibAMCFStreamUpload_UploadChunkFunc read FLibAMCFStreamUpload_UploadChunkFunc;
		property LibAMCFStreamUpload_FinishChunkingFunc: TLibAMCFStreamUpload_FinishChunkingFunc read FLibAMCFStreamUpload_FinishChunkingFunc;
		property LibAMCFStreamUpload_GetStatusFunc: TLibAMCFStreamUpload_GetStatusFunc read FLibAMCFStreamUpload_GetStatusFunc;
		property LibAMCFStreamUpload_GetDataStreamFunc: TLibAMCFStreamUpload_GetDataStreamFunc read FLibAMCFStreamUpload_GetDataStreamFunc;
		property LibAMCFConnection_GetBaseURLFunc: TLibAMCFConnection_GetBaseURLFunc read FLibAMCFConnection_GetBaseURLFunc;
		property LibAMCFConnection_SetTimeoutsFunc: TLibAMCFConnection_SetTimeoutsFunc read FLibAMCFConnection_SetTimeoutsFunc;
		property LibAMCFConnection_GetTimeoutFunc: TLibAMCFConnection_GetTimeoutFunc read FLibAMCFConnection_GetTimeoutFunc;
		property LibAMCFConnection_GetRetryCountFunc: TLibAMCFConnection_GetRetryCountFunc read FLibAMCFConnection_GetRetryCountFunc;
		property LibAMCFConnection_AuthenticateWithPasswordFunc: TLibAMCFConnection_AuthenticateWithPasswordFunc read FLibAMCFConnection_AuthenticateWithPasswordFunc;
		property LibAMCFConnection_IsAuthenticatedFunc: TLibAMCFConnection_IsAuthenticatedFunc read FLibAMCFConnection_IsAuthenticatedFunc;
		property LibAMCFConnection_RefreshAuthenticationFunc: TLibAMCFConnection_RefreshAuthenticationFunc read FLibAMCFConnection_RefreshAuthenticationFunc;
		property LibAMCFConnection_PingFunc: TLibAMCFConnection_PingFunc read FLibAMCFConnection_PingFunc;
		property LibAMCFConnection_GetAuthTokenFunc: TLibAMCFConnection_GetAuthTokenFunc read FLibAMCFConnection_GetAuthTokenFunc;
		property LibAMCFConnection_CreateUploadFunc: TLibAMCFConnection_CreateUploadFunc read FLibAMCFConnection_CreateUploadFunc;
		property LibAMCFGetVersionFunc: TLibAMCFGetVersionFunc read FLibAMCFGetVersionFunc;
		property LibAMCFGetLastErrorFunc: TLibAMCFGetLastErrorFunc read FLibAMCFGetLastErrorFunc;
		property LibAMCFReleaseInstanceFunc: TLibAMCFReleaseInstanceFunc read FLibAMCFReleaseInstanceFunc;
		property LibAMCFAcquireInstanceFunc: TLibAMCFAcquireInstanceFunc read FLibAMCFAcquireInstanceFunc;
		property LibAMCFInjectComponentFunc: TLibAMCFInjectComponentFunc read FLibAMCFInjectComponentFunc;
		property LibAMCFGetSymbolLookupMethodFunc: TLibAMCFGetSymbolLookupMethodFunc read FLibAMCFGetSymbolLookupMethodFunc;
		property LibAMCFCreateConnectionFunc: TLibAMCFCreateConnectionFunc read FLibAMCFCreateConnectionFunc;
		procedure CheckError(AInstance: TLibAMCFBase; AErrorCode: TLibAMCFResult);
	public
		constructor Create(ADLLName: String);
		constructor CreateFromSymbolLookupMethod(ALookupMethod: TLibAMCFSymbolLookupMethod);
		destructor Destroy; override;
		procedure GetVersion(out AMajor: Cardinal; out AMinor: Cardinal; out AMicro: Cardinal);
		function GetLastError(const AInstance: TLibAMCFBase; out AErrorMessage: String): Boolean;
		procedure ReleaseInstance(const AInstance: TLibAMCFBase);
		procedure AcquireInstance(const AInstance: TLibAMCFBase);
		procedure InjectComponent(const ANameSpace: String; const ASymbolAddressMethod: Pointer);
		function GetSymbolLookupMethod(): Pointer;
		function CreateConnection(const ABaseURL: String): TLibAMCFConnection;
	end;


implementation


(*************************************************************************************************************************
 Exception implementation
**************************************************************************************************************************)

	constructor ELibAMCFException.Create(AErrorCode: TLibAMCFResult; AMessage: String);
	var
		ADescription: String;
	begin
		FErrorCode := AErrorCode;
		case FErrorCode of
			LIBAMCF_ERROR_NOTIMPLEMENTED: ADescription := 'functionality not implemented';
			LIBAMCF_ERROR_INVALIDPARAM: ADescription := 'an invalid parameter was passed';
			LIBAMCF_ERROR_INVALIDCAST: ADescription := 'a type cast failed';
			LIBAMCF_ERROR_BUFFERTOOSMALL: ADescription := 'a provided buffer is too small';
			LIBAMCF_ERROR_GENERICEXCEPTION: ADescription := 'a generic exception occurred';
			LIBAMCF_ERROR_COULDNOTLOADLIBRARY: ADescription := 'the library could not be loaded';
			LIBAMCF_ERROR_COULDNOTFINDLIBRARYEXPORT: ADescription := 'a required exported symbol could not be found in the library';
			LIBAMCF_ERROR_INCOMPATIBLEBINARYVERSION: ADescription := 'the version of the binary interface does not match the bindings interface';
			LIBAMCF_ERROR_INVALIDTIMEOUT: ADescription := 'invalid timeout';
			LIBAMCF_ERROR_INVALIDRETRYCOUNT: ADescription := 'invalid retry count';
			LIBAMCF_ERROR_INVALIDBASEURL: ADescription := 'invalid base url';
			LIBAMCF_ERROR_INVALIDKEYNAME: ADescription := 'invalid key name';
			LIBAMCF_ERROR_RESTRESPONSEISNOOBJECT: ADescription := 'REST response is no object';
			LIBAMCF_ERROR_COULDNOTPARSERESTRESPONSE: ADescription := 'Could not parse REST response';
			LIBAMCF_ERROR_RESTRESPONSETIMEOUT: ADescription := 'REST response timeout';
			LIBAMCF_ERROR_INVALIDRESTRESPONSE: ADescription := 'Invalid REST response';
			LIBAMCF_ERROR_COULDNOTCREATESESSION: ADescription := 'Could not create session';
			LIBAMCF_ERROR_COULDNOTRECEIVETOKEN: ADescription := 'Could not retrieve token';
			LIBAMCF_ERROR_OPERATIONRESULTNOTREADY: ADescription := 'Operation result is not ready';
			LIBAMCF_ERROR_RESTERROR: ADescription := 'REST error:';
			LIBAMCF_ERROR_INVALIDUPLOADCHUNKSIZE: ADescription := 'Invalid upload chunk size';
			LIBAMCF_ERROR_CANNOTUPLOADEMPTYDATA: ADescription := 'Can not upload empty data';
			LIBAMCF_ERROR_COULDNOTBEGINSTREAMUPLOAD: ADescription := 'Could not begin stream upload';
			LIBAMCF_ERROR_BEGINCHUNKINGALREADYCALLED: ADescription := 'Begin chunking already called';
			LIBAMCF_ERROR_BEGINCHUNKINGNOTCALLED: ADescription := 'Begin chunking not called';
			LIBAMCF_ERROR_UPLOADDATAEXCEEDSTOTALSIZE: ADescription := 'Upload exceeds total size';
			LIBAMCF_ERROR_BEGINCHUNKINGFAILED: ADescription := 'Begin chunking failed';
			else
				ADescription := 'unknown';
		end;

		inherited Create(Format('Autodesk Machine Control Framework SDK Error - %s (#%d, %s)', [ ADescription, AErrorCode, AMessage ]));
	end;

	constructor ELibAMCFException.CreateCustomMessage(AErrorCode: TLibAMCFResult; AMessage: String);
	begin
		FCustomMessage := AMessage;
		FErrorCode := AErrorCode;
		inherited Create(Format('%s (%d)', [FCustomMessage, AErrorCode]));
	end;

(*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************)

	constructor TLibAMCFBase.Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
	begin
		if not Assigned(AWrapper) then
			raise ELibAMCFException.Create(LIBAMCF_ERROR_INVALIDPARAM, '');
		if not Assigned(AHandle) then
			raise ELibAMCFException.Create(LIBAMCF_ERROR_INVALIDPARAM, '');

		inherited Create();
		FWrapper := AWrapper;
		FHandle := AHandle;
	end;

	destructor TLibAMCFBase.Destroy;
	begin
		FWrapper.ReleaseInstance(self);
		inherited;
	end;

(*************************************************************************************************************************
 Class implementation for OperationResult
**************************************************************************************************************************)

	constructor TLibAMCFOperationResult.Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
	begin
		inherited Create(AWrapper, AHandle);
	end;

	destructor TLibAMCFOperationResult.Destroy;
	begin
		inherited;
	end;

	function TLibAMCFOperationResult.WaitFor(const ATimeOut: Cardinal): Boolean;
	var
		ResultOperationFinished: Byte;
	begin
		ResultOperationFinished := 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFOperationResult_WaitForFunc(FHandle, ATimeOut, ResultOperationFinished));
		Result := (ResultOperationFinished <> 0);
	end;

	function TLibAMCFOperationResult.InProgress(): Boolean;
	var
		ResultOperationIsInProgress: Byte;
	begin
		ResultOperationIsInProgress := 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFOperationResult_InProgressFunc(FHandle, ResultOperationIsInProgress));
		Result := (ResultOperationIsInProgress <> 0);
	end;

	function TLibAMCFOperationResult.Success(): Boolean;
	var
		ResultOperationSuccess: Byte;
	begin
		ResultOperationSuccess := 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFOperationResult_SuccessFunc(FHandle, ResultOperationSuccess));
		Result := (ResultOperationSuccess <> 0);
	end;

	function TLibAMCFOperationResult.GetErrorMessage(): String;
	var
		bytesNeededErrorMessage: Cardinal;
		bytesWrittenErrorMessage: Cardinal;
		bufferErrorMessage: array of Char;
	begin
		bytesNeededErrorMessage:= 0;
		bytesWrittenErrorMessage:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFOperationResult_GetErrorMessageFunc(FHandle, 0, bytesNeededErrorMessage, nil));
		SetLength(bufferErrorMessage, bytesNeededErrorMessage);
		FWrapper.CheckError(Self, FWrapper.LibAMCFOperationResult_GetErrorMessageFunc(FHandle, bytesNeededErrorMessage, bytesWrittenErrorMessage, @bufferErrorMessage[0]));
		Result := StrPas(@bufferErrorMessage[0]);
	end;

(*************************************************************************************************************************
 Class implementation for DataStream
**************************************************************************************************************************)

	constructor TLibAMCFDataStream.Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
	begin
		inherited Create(AWrapper, AHandle);
	end;

	destructor TLibAMCFDataStream.Destroy;
	begin
		inherited;
	end;

	function TLibAMCFDataStream.GetUUID(): String;
	var
		bytesNeededUUID: Cardinal;
		bytesWrittenUUID: Cardinal;
		bufferUUID: array of Char;
	begin
		bytesNeededUUID:= 0;
		bytesWrittenUUID:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFDataStream_GetUUIDFunc(FHandle, 0, bytesNeededUUID, nil));
		SetLength(bufferUUID, bytesNeededUUID);
		FWrapper.CheckError(Self, FWrapper.LibAMCFDataStream_GetUUIDFunc(FHandle, bytesNeededUUID, bytesWrittenUUID, @bufferUUID[0]));
		Result := StrPas(@bufferUUID[0]);
	end;

	function TLibAMCFDataStream.GetContextUUID(): String;
	var
		bytesNeededContextUUID: Cardinal;
		bytesWrittenContextUUID: Cardinal;
		bufferContextUUID: array of Char;
	begin
		bytesNeededContextUUID:= 0;
		bytesWrittenContextUUID:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFDataStream_GetContextUUIDFunc(FHandle, 0, bytesNeededContextUUID, nil));
		SetLength(bufferContextUUID, bytesNeededContextUUID);
		FWrapper.CheckError(Self, FWrapper.LibAMCFDataStream_GetContextUUIDFunc(FHandle, bytesNeededContextUUID, bytesWrittenContextUUID, @bufferContextUUID[0]));
		Result := StrPas(@bufferContextUUID[0]);
	end;

	function TLibAMCFDataStream.GetName(): String;
	var
		bytesNeededName: Cardinal;
		bytesWrittenName: Cardinal;
		bufferName: array of Char;
	begin
		bytesNeededName:= 0;
		bytesWrittenName:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFDataStream_GetNameFunc(FHandle, 0, bytesNeededName, nil));
		SetLength(bufferName, bytesNeededName);
		FWrapper.CheckError(Self, FWrapper.LibAMCFDataStream_GetNameFunc(FHandle, bytesNeededName, bytesWrittenName, @bufferName[0]));
		Result := StrPas(@bufferName[0]);
	end;

	function TLibAMCFDataStream.GetMimeType(): String;
	var
		bytesNeededMimeType: Cardinal;
		bytesWrittenMimeType: Cardinal;
		bufferMimeType: array of Char;
	begin
		bytesNeededMimeType:= 0;
		bytesWrittenMimeType:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFDataStream_GetMimeTypeFunc(FHandle, 0, bytesNeededMimeType, nil));
		SetLength(bufferMimeType, bytesNeededMimeType);
		FWrapper.CheckError(Self, FWrapper.LibAMCFDataStream_GetMimeTypeFunc(FHandle, bytesNeededMimeType, bytesWrittenMimeType, @bufferMimeType[0]));
		Result := StrPas(@bufferMimeType[0]);
	end;

	function TLibAMCFDataStream.GetSize(): QWord;
	begin
		FWrapper.CheckError(Self, FWrapper.LibAMCFDataStream_GetSizeFunc(FHandle, Result));
	end;

(*************************************************************************************************************************
 Class implementation for StreamUpload
**************************************************************************************************************************)

	constructor TLibAMCFStreamUpload.Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
	begin
		inherited Create(AWrapper, AHandle);
	end;

	destructor TLibAMCFStreamUpload.Destroy;
	begin
		inherited;
	end;

	function TLibAMCFStreamUpload.GetName(): String;
	var
		bytesNeededName: Cardinal;
		bytesWrittenName: Cardinal;
		bufferName: array of Char;
	begin
		bytesNeededName:= 0;
		bytesWrittenName:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_GetNameFunc(FHandle, 0, bytesNeededName, nil));
		SetLength(bufferName, bytesNeededName);
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_GetNameFunc(FHandle, bytesNeededName, bytesWrittenName, @bufferName[0]));
		Result := StrPas(@bufferName[0]);
	end;

	function TLibAMCFStreamUpload.GetMimeType(): String;
	var
		bytesNeededMimeType: Cardinal;
		bytesWrittenMimeType: Cardinal;
		bufferMimeType: array of Char;
	begin
		bytesNeededMimeType:= 0;
		bytesWrittenMimeType:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_GetMimeTypeFunc(FHandle, 0, bytesNeededMimeType, nil));
		SetLength(bufferMimeType, bytesNeededMimeType);
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_GetMimeTypeFunc(FHandle, bytesNeededMimeType, bytesWrittenMimeType, @bufferMimeType[0]));
		Result := StrPas(@bufferMimeType[0]);
	end;

	function TLibAMCFStreamUpload.GetUsageContext(): String;
	var
		bytesNeededUsageContext: Cardinal;
		bytesWrittenUsageContext: Cardinal;
		bufferUsageContext: array of Char;
	begin
		bytesNeededUsageContext:= 0;
		bytesWrittenUsageContext:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_GetUsageContextFunc(FHandle, 0, bytesNeededUsageContext, nil));
		SetLength(bufferUsageContext, bytesNeededUsageContext);
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_GetUsageContextFunc(FHandle, bytesNeededUsageContext, bytesWrittenUsageContext, @bufferUsageContext[0]));
		Result := StrPas(@bufferUsageContext[0]);
	end;

	function TLibAMCFStreamUpload.UploadData(const AData: TByteDynArray; const AChunkSize: Cardinal): TLibAMCFOperationResult;
	var
		PtrData: PByte;
		LenData: QWord;
		HSuccess: TLibAMCFHandle;
	begin
		LenData := Length(AData);
		if LenData > $FFFFFFFF then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_INVALIDPARAM, 'array has too many entries.');
		if LenData > 0 then
			PtrData := @AData[0]
		else
			PtrData := nil;
		
		Result := nil;
		HSuccess := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_UploadDataFunc(FHandle, QWord(LenData), PtrData, AChunkSize, HSuccess));
		if Assigned(HSuccess) then
			Result := TLibAMCFOperationResult.Create(FWrapper, HSuccess);
	end;

	function TLibAMCFStreamUpload.UploadFile(const AFileName: String; const AChunkSize: Cardinal): TLibAMCFOperationResult;
	var
		HSuccess: TLibAMCFHandle;
	begin
		Result := nil;
		HSuccess := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_UploadFileFunc(FHandle, PAnsiChar(AFileName), AChunkSize, HSuccess));
		if Assigned(HSuccess) then
			Result := TLibAMCFOperationResult.Create(FWrapper, HSuccess);
	end;

	function TLibAMCFStreamUpload.BeginChunking(const ADataSize: QWord): TLibAMCFOperationResult;
	var
		HSuccess: TLibAMCFHandle;
	begin
		Result := nil;
		HSuccess := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_BeginChunkingFunc(FHandle, ADataSize, HSuccess));
		if Assigned(HSuccess) then
			Result := TLibAMCFOperationResult.Create(FWrapper, HSuccess);
	end;

	function TLibAMCFStreamUpload.UploadChunk(const AData: TByteDynArray): TLibAMCFOperationResult;
	var
		PtrData: PByte;
		LenData: QWord;
		HSuccess: TLibAMCFHandle;
	begin
		LenData := Length(AData);
		if LenData > $FFFFFFFF then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_INVALIDPARAM, 'array has too many entries.');
		if LenData > 0 then
			PtrData := @AData[0]
		else
			PtrData := nil;
		
		Result := nil;
		HSuccess := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_UploadChunkFunc(FHandle, QWord(LenData), PtrData, HSuccess));
		if Assigned(HSuccess) then
			Result := TLibAMCFOperationResult.Create(FWrapper, HSuccess);
	end;

	function TLibAMCFStreamUpload.FinishChunking(): TLibAMCFOperationResult;
	var
		HSuccess: TLibAMCFHandle;
	begin
		Result := nil;
		HSuccess := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_FinishChunkingFunc(FHandle, HSuccess));
		if Assigned(HSuccess) then
			Result := TLibAMCFOperationResult.Create(FWrapper, HSuccess);
	end;

	procedure TLibAMCFStreamUpload.GetStatus(out AUploadSize: QWord; out AUploadedBytes: QWord; out AFinished: Boolean);
	var
		ResultFinished: Byte;
	begin
		ResultFinished := 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_GetStatusFunc(FHandle, AUploadSize, AUploadedBytes, ResultFinished));
		AFinished := ResultFinished <> 0;
	end;

	function TLibAMCFStreamUpload.GetDataStream(): TLibAMCFDataStream;
	var
		HDataStream: TLibAMCFHandle;
	begin
		Result := nil;
		HDataStream := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFStreamUpload_GetDataStreamFunc(FHandle, HDataStream));
		if Assigned(HDataStream) then
			Result := TLibAMCFDataStream.Create(FWrapper, HDataStream);
	end;

(*************************************************************************************************************************
 Class implementation for Connection
**************************************************************************************************************************)

	constructor TLibAMCFConnection.Create(AWrapper: TLibAMCFWrapper; AHandle: TLibAMCFHandle);
	begin
		inherited Create(AWrapper, AHandle);
	end;

	destructor TLibAMCFConnection.Destroy;
	begin
		inherited;
	end;

	function TLibAMCFConnection.GetBaseURL(): String;
	var
		bytesNeededBaseURL: Cardinal;
		bytesWrittenBaseURL: Cardinal;
		bufferBaseURL: array of Char;
	begin
		bytesNeededBaseURL:= 0;
		bytesWrittenBaseURL:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_GetBaseURLFunc(FHandle, 0, bytesNeededBaseURL, nil));
		SetLength(bufferBaseURL, bytesNeededBaseURL);
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_GetBaseURLFunc(FHandle, bytesNeededBaseURL, bytesWrittenBaseURL, @bufferBaseURL[0]));
		Result := StrPas(@bufferBaseURL[0]);
	end;

	procedure TLibAMCFConnection.SetTimeouts(const ATimeout: Cardinal; const ARetryCount: Cardinal);
	begin
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_SetTimeoutsFunc(FHandle, ATimeout, ARetryCount));
	end;

	function TLibAMCFConnection.GetTimeout(): Cardinal;
	begin
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_GetTimeoutFunc(FHandle, Result));
	end;

	function TLibAMCFConnection.GetRetryCount(): Cardinal;
	begin
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_GetRetryCountFunc(FHandle, Result));
	end;

	function TLibAMCFConnection.AuthenticateWithPassword(const AUserName: String; const APassword: String): TLibAMCFOperationResult;
	var
		HSuccess: TLibAMCFHandle;
	begin
		Result := nil;
		HSuccess := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_AuthenticateWithPasswordFunc(FHandle, PAnsiChar(AUserName), PAnsiChar(APassword), HSuccess));
		if Assigned(HSuccess) then
			Result := TLibAMCFOperationResult.Create(FWrapper, HSuccess);
	end;

	function TLibAMCFConnection.IsAuthenticated(): Boolean;
	var
		ResultIsAuthenticated: Byte;
	begin
		ResultIsAuthenticated := 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_IsAuthenticatedFunc(FHandle, ResultIsAuthenticated));
		Result := (ResultIsAuthenticated <> 0);
	end;

	function TLibAMCFConnection.RefreshAuthentication(): TLibAMCFOperationResult;
	var
		HSuccess: TLibAMCFHandle;
	begin
		Result := nil;
		HSuccess := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_RefreshAuthenticationFunc(FHandle, HSuccess));
		if Assigned(HSuccess) then
			Result := TLibAMCFOperationResult.Create(FWrapper, HSuccess);
	end;

	function TLibAMCFConnection.Ping(): TLibAMCFOperationResult;
	var
		HSuccess: TLibAMCFHandle;
	begin
		Result := nil;
		HSuccess := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_PingFunc(FHandle, HSuccess));
		if Assigned(HSuccess) then
			Result := TLibAMCFOperationResult.Create(FWrapper, HSuccess);
	end;

	function TLibAMCFConnection.GetAuthToken(): String;
	var
		bytesNeededToken: Cardinal;
		bytesWrittenToken: Cardinal;
		bufferToken: array of Char;
	begin
		bytesNeededToken:= 0;
		bytesWrittenToken:= 0;
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_GetAuthTokenFunc(FHandle, 0, bytesNeededToken, nil));
		SetLength(bufferToken, bytesNeededToken);
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_GetAuthTokenFunc(FHandle, bytesNeededToken, bytesWrittenToken, @bufferToken[0]));
		Result := StrPas(@bufferToken[0]);
	end;

	function TLibAMCFConnection.CreateUpload(const AName: String; const AMimeType: String; const AUsageContext: String): TLibAMCFStreamUpload;
	var
		HInstance: TLibAMCFHandle;
	begin
		Result := nil;
		HInstance := nil;
		FWrapper.CheckError(Self, FWrapper.LibAMCFConnection_CreateUploadFunc(FHandle, PAnsiChar(AName), PAnsiChar(AMimeType), PAnsiChar(AUsageContext), HInstance));
		if Assigned(HInstance) then
			Result := TLibAMCFStreamUpload.Create(FWrapper, HInstance);
	end;

(*************************************************************************************************************************
 Wrapper class implementation
**************************************************************************************************************************)

	constructor TLibAMCFWrapper.Create(ADLLName: String);
	{$IFDEF MSWINDOWS}
	var
		AWideString: WideString;
	{$ENDIF MSWINDOWS}
	begin
		inherited Create;
		
		
		{$IFDEF MSWINDOWS}
			AWideString := UTF8Decode(ADLLName + #0);
			FModule := LoadLibraryW(PWideChar(AWideString));
		{$ELSE}
			FModule := dynlibs.LoadLibrary(ADLLName);
		{$ENDIF MSWINDOWS}
		if FModule = 0 then
			raise ELibAMCFException.Create(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');

		FLibAMCFOperationResult_WaitForFunc := LoadFunction('libamcf_operationresult_waitfor');
		FLibAMCFOperationResult_InProgressFunc := LoadFunction('libamcf_operationresult_inprogress');
		FLibAMCFOperationResult_SuccessFunc := LoadFunction('libamcf_operationresult_success');
		FLibAMCFOperationResult_GetErrorMessageFunc := LoadFunction('libamcf_operationresult_geterrormessage');
		FLibAMCFDataStream_GetUUIDFunc := LoadFunction('libamcf_datastream_getuuid');
		FLibAMCFDataStream_GetContextUUIDFunc := LoadFunction('libamcf_datastream_getcontextuuid');
		FLibAMCFDataStream_GetNameFunc := LoadFunction('libamcf_datastream_getname');
		FLibAMCFDataStream_GetMimeTypeFunc := LoadFunction('libamcf_datastream_getmimetype');
		FLibAMCFDataStream_GetSizeFunc := LoadFunction('libamcf_datastream_getsize');
		FLibAMCFStreamUpload_GetNameFunc := LoadFunction('libamcf_streamupload_getname');
		FLibAMCFStreamUpload_GetMimeTypeFunc := LoadFunction('libamcf_streamupload_getmimetype');
		FLibAMCFStreamUpload_GetUsageContextFunc := LoadFunction('libamcf_streamupload_getusagecontext');
		FLibAMCFStreamUpload_UploadDataFunc := LoadFunction('libamcf_streamupload_uploaddata');
		FLibAMCFStreamUpload_UploadFileFunc := LoadFunction('libamcf_streamupload_uploadfile');
		FLibAMCFStreamUpload_BeginChunkingFunc := LoadFunction('libamcf_streamupload_beginchunking');
		FLibAMCFStreamUpload_UploadChunkFunc := LoadFunction('libamcf_streamupload_uploadchunk');
		FLibAMCFStreamUpload_FinishChunkingFunc := LoadFunction('libamcf_streamupload_finishchunking');
		FLibAMCFStreamUpload_GetStatusFunc := LoadFunction('libamcf_streamupload_getstatus');
		FLibAMCFStreamUpload_GetDataStreamFunc := LoadFunction('libamcf_streamupload_getdatastream');
		FLibAMCFConnection_GetBaseURLFunc := LoadFunction('libamcf_connection_getbaseurl');
		FLibAMCFConnection_SetTimeoutsFunc := LoadFunction('libamcf_connection_settimeouts');
		FLibAMCFConnection_GetTimeoutFunc := LoadFunction('libamcf_connection_gettimeout');
		FLibAMCFConnection_GetRetryCountFunc := LoadFunction('libamcf_connection_getretrycount');
		FLibAMCFConnection_AuthenticateWithPasswordFunc := LoadFunction('libamcf_connection_authenticatewithpassword');
		FLibAMCFConnection_IsAuthenticatedFunc := LoadFunction('libamcf_connection_isauthenticated');
		FLibAMCFConnection_RefreshAuthenticationFunc := LoadFunction('libamcf_connection_refreshauthentication');
		FLibAMCFConnection_PingFunc := LoadFunction('libamcf_connection_ping');
		FLibAMCFConnection_GetAuthTokenFunc := LoadFunction('libamcf_connection_getauthtoken');
		FLibAMCFConnection_CreateUploadFunc := LoadFunction('libamcf_connection_createupload');
		FLibAMCFGetVersionFunc := LoadFunction('libamcf_getversion');
		FLibAMCFGetLastErrorFunc := LoadFunction('libamcf_getlasterror');
		FLibAMCFReleaseInstanceFunc := LoadFunction('libamcf_releaseinstance');
		FLibAMCFAcquireInstanceFunc := LoadFunction('libamcf_acquireinstance');
		FLibAMCFInjectComponentFunc := LoadFunction('libamcf_injectcomponent');
		FLibAMCFGetSymbolLookupMethodFunc := LoadFunction('libamcf_getsymbollookupmethod');
		FLibAMCFCreateConnectionFunc := LoadFunction('libamcf_createconnection');
		
		checkBinaryVersion();
	end;

	constructor TLibAMCFWrapper.CreateFromSymbolLookupMethod(ALookupMethod: TLibAMCFSymbolLookupMethod);
	var
		AResult : TLibAMCFResult;
	begin
		inherited Create;
		
		
		AResult := ALookupMethod(PAnsiChar('libamcf_operationresult_waitfor'), @FLibAMCFOperationResult_WaitForFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_operationresult_inprogress'), @FLibAMCFOperationResult_InProgressFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_operationresult_success'), @FLibAMCFOperationResult_SuccessFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_operationresult_geterrormessage'), @FLibAMCFOperationResult_GetErrorMessageFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_datastream_getuuid'), @FLibAMCFDataStream_GetUUIDFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_datastream_getcontextuuid'), @FLibAMCFDataStream_GetContextUUIDFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_datastream_getname'), @FLibAMCFDataStream_GetNameFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_datastream_getmimetype'), @FLibAMCFDataStream_GetMimeTypeFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_datastream_getsize'), @FLibAMCFDataStream_GetSizeFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_getname'), @FLibAMCFStreamUpload_GetNameFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_getmimetype'), @FLibAMCFStreamUpload_GetMimeTypeFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_getusagecontext'), @FLibAMCFStreamUpload_GetUsageContextFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_uploaddata'), @FLibAMCFStreamUpload_UploadDataFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_uploadfile'), @FLibAMCFStreamUpload_UploadFileFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_beginchunking'), @FLibAMCFStreamUpload_BeginChunkingFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_uploadchunk'), @FLibAMCFStreamUpload_UploadChunkFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_finishchunking'), @FLibAMCFStreamUpload_FinishChunkingFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_getstatus'), @FLibAMCFStreamUpload_GetStatusFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_streamupload_getdatastream'), @FLibAMCFStreamUpload_GetDataStreamFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_getbaseurl'), @FLibAMCFConnection_GetBaseURLFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_settimeouts'), @FLibAMCFConnection_SetTimeoutsFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_gettimeout'), @FLibAMCFConnection_GetTimeoutFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_getretrycount'), @FLibAMCFConnection_GetRetryCountFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_authenticatewithpassword'), @FLibAMCFConnection_AuthenticateWithPasswordFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_isauthenticated'), @FLibAMCFConnection_IsAuthenticatedFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_refreshauthentication'), @FLibAMCFConnection_RefreshAuthenticationFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_ping'), @FLibAMCFConnection_PingFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_getauthtoken'), @FLibAMCFConnection_GetAuthTokenFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_connection_createupload'), @FLibAMCFConnection_CreateUploadFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_getversion'), @FLibAMCFGetVersionFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_getlasterror'), @FLibAMCFGetLastErrorFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_releaseinstance'), @FLibAMCFReleaseInstanceFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_acquireinstance'), @FLibAMCFAcquireInstanceFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_injectcomponent'), @FLibAMCFInjectComponentFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_getsymbollookupmethod'), @FLibAMCFGetSymbolLookupMethodFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		AResult := ALookupMethod(PAnsiChar('libamcf_createconnection'), @FLibAMCFCreateConnectionFunc);
		if AResult <> LIBAMCF_SUCCESS then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, '');
		
		checkBinaryVersion();
	end;

	destructor TLibAMCFWrapper.Destroy;
	begin
		{$IFDEF MSWINDOWS}
			if FModule <> 0 then
				FreeLibrary(FModule);
		{$ELSE}
			if FModule <> 0 then
				UnloadLibrary(FModule);
		{$ENDIF MSWINDOWS}
		inherited;
	end;

	procedure TLibAMCFWrapper.CheckError(AInstance: TLibAMCFBase; AErrorCode: TLibAMCFResult);
	var
		AErrorMessage: String;
	begin
		if AInstance <> nil then begin
			if AInstance.FWrapper <> Self then
				raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_INVALIDCAST, 'invalid wrapper call');
		end;
		if AErrorCode <> LIBAMCF_SUCCESS then begin
			AErrorMessage := '';
			if Assigned(AInstance) then
				GetLastError(AInstance, AErrorMessage);
			raise ELibAMCFException.Create(AErrorCode, AErrorMessage);
		end;
	end;

	{$IFDEF MSWINDOWS}
	function TLibAMCFWrapper.LoadFunction(AFunctionName: AnsiString; FailIfNotExistent: Boolean): FARPROC;
	begin
		Result := GetProcAddress(FModule, PAnsiChar(AFunctionName));
		if FailIfNotExistent and not Assigned(Result) then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTFINDLIBRARYEXPORT, 'could not find function ' + AFunctionName);
	end;
	{$ELSE}
	function TLibAMCFWrapper.LoadFunction(AFunctionName: AnsiString; FailIfNotExistent: Boolean): Pointer;
	begin
		Result := dynlibs.GetProcAddress(FModule, AFunctionName);
		if FailIfNotExistent and not Assigned(Result) then
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_COULDNOTFINDLIBRARYEXPORT, 'could not find function ' + AFunctionName);
	end;
	{$ENDIF MSWINDOWS}

	procedure TLibAMCFWrapper.checkBinaryVersion();
	var
		AMajor, AMinor, AMicro: Cardinal;
	begin
		GetVersion(AMajor, AMinor, AMicro);
		if (AMajor <> LIBAMCF_VERSION_MAJOR) then
			raise ELibAMCFException.Create(LIBAMCF_ERROR_INCOMPATIBLEBINARYVERSION, '');
	end;
	
	procedure TLibAMCFWrapper.GetVersion(out AMajor: Cardinal; out AMinor: Cardinal; out AMicro: Cardinal);
	begin
		CheckError(nil, LibAMCFGetVersionFunc(AMajor, AMinor, AMicro));
	end;

	function TLibAMCFWrapper.GetLastError(const AInstance: TLibAMCFBase; out AErrorMessage: String): Boolean;
	var
		AInstanceHandle: TLibAMCFHandle;
		bytesNeededErrorMessage: Cardinal;
		bytesWrittenErrorMessage: Cardinal;
		bufferErrorMessage: array of Char;
		ResultHasError: Byte;
	begin
		if Assigned(AInstance) then
		AInstanceHandle := AInstance.TheHandle
		else
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_INVALIDPARAM, 'AInstance is a nil value.');
		bytesNeededErrorMessage:= 0;
		bytesWrittenErrorMessage:= 0;
		ResultHasError := 0;
		CheckError(nil, LibAMCFGetLastErrorFunc(AInstanceHandle, 0, bytesNeededErrorMessage, nil, ResultHasError));
		SetLength(bufferErrorMessage, bytesNeededErrorMessage);
		CheckError(nil, LibAMCFGetLastErrorFunc(AInstanceHandle, bytesNeededErrorMessage, bytesWrittenErrorMessage, @bufferErrorMessage[0], ResultHasError));
		AErrorMessage := StrPas(@bufferErrorMessage[0]);
		Result := (ResultHasError <> 0);
	end;

	procedure TLibAMCFWrapper.ReleaseInstance(const AInstance: TLibAMCFBase);
	var
		AInstanceHandle: TLibAMCFHandle;
	begin
		if Assigned(AInstance) then
		AInstanceHandle := AInstance.TheHandle
		else
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_INVALIDPARAM, 'AInstance is a nil value.');
		CheckError(nil, LibAMCFReleaseInstanceFunc(AInstanceHandle));
	end;

	procedure TLibAMCFWrapper.AcquireInstance(const AInstance: TLibAMCFBase);
	var
		AInstanceHandle: TLibAMCFHandle;
	begin
		if Assigned(AInstance) then
		AInstanceHandle := AInstance.TheHandle
		else
			raise ELibAMCFException.CreateCustomMessage(LIBAMCF_ERROR_INVALIDPARAM, 'AInstance is a nil value.');
		CheckError(nil, LibAMCFAcquireInstanceFunc(AInstanceHandle));
	end;

	procedure TLibAMCFWrapper.InjectComponent(const ANameSpace: String; const ASymbolAddressMethod: Pointer);
	begin
		CheckError(nil, LibAMCFInjectComponentFunc(PAnsiChar(ANameSpace), ASymbolAddressMethod));
		if not ANameSpaceFound then
			raise ELibAMCFException.Create(LIBAMCF_ERROR_COULDNOTLOADLIBRARY, 'Unknown namespace ' + ANameSpace);
	 
	end;

	function TLibAMCFWrapper.GetSymbolLookupMethod(): Pointer;
	begin
		CheckError(nil, LibAMCFGetSymbolLookupMethodFunc(Result));
	end;

	function TLibAMCFWrapper.CreateConnection(const ABaseURL: String): TLibAMCFConnection;
	var
		HInstance: TLibAMCFHandle;
	begin
		Result := nil;
		HInstance := nil;
		CheckError(nil, LibAMCFCreateConnectionFunc(PAnsiChar(ABaseURL), HInstance));
		if Assigned(HInstance) then
			Result := TLibAMCFConnection.Create(Self, HInstance);
	end;


end.
