/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Environment Interface

Interface version: 1.0.0

*/

#ifndef __LIBMCENV_CPPHEADER_DYNAMIC_CPP
#define __LIBMCENV_CPPHEADER_DYNAMIC_CPP

#include "libmcenv_types.hpp"
#include "libmcenv_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCEnv {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CIterator;
class CTestEnvironment;
class CCryptoContext;
class CPNGImageStoreOptions;
class CPNGImageData;
class CImageData;
class CDiscreteFieldData2DStoreOptions;
class CDiscreteFieldData2D;
class CDataTableWriteOptions;
class CDataTableCSVWriteOptions;
class CDataTable;
class CDataSeries;
class CDateTimeDifference;
class CDateTime;
class CMeshObject;
class CPersistentMeshObject;
class CModelDataMeshInstance;
class CModelDataComponentInstance;
class CMeshSceneItem;
class CMeshScene;
class CSceneHandler;
class CToolpathPart;
class CToolpathLayer;
class CToolpathAccessor;
class CBuildExecution;
class CBuildExecutionIterator;
class CBuild;
class CWorkingFileExecution;
class CWorkingFile;
class CWorkingFileIterator;
class CWorkingDirectory;
class CXMLDocumentAttribute;
class CXMLDocumentNode;
class CXMLDocumentNodes;
class CXMLDocument;
class CTCPIPPacket;
class CTCPIPConnection;
class CModbusTCPDigitalIOStatus;
class CModbusTCPRegisterStatus;
class CModbusTCPConnection;
class CDriverStatusUpdateSession;
class CDriverEnvironment;
class CSignalTrigger;
class CSignalHandler;
class CBaseTempStreamWriter;
class CTempStreamWriter;
class CZIPStreamWriter;
class CStreamReader;
class CUniformJournalSampling;
class CJournalVariable;
class CAlert;
class CAlertIterator;
class CLogEntryList;
class CJournalHandler;
class CUserDetailList;
class CUserManagementHandler;
class CStateEnvironment;
class CUIItem;
class CUIEnvironment;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCEnvWrapper;
typedef CBase CLibMCEnvBase;
typedef CIterator CLibMCEnvIterator;
typedef CTestEnvironment CLibMCEnvTestEnvironment;
typedef CCryptoContext CLibMCEnvCryptoContext;
typedef CPNGImageStoreOptions CLibMCEnvPNGImageStoreOptions;
typedef CPNGImageData CLibMCEnvPNGImageData;
typedef CImageData CLibMCEnvImageData;
typedef CDiscreteFieldData2DStoreOptions CLibMCEnvDiscreteFieldData2DStoreOptions;
typedef CDiscreteFieldData2D CLibMCEnvDiscreteFieldData2D;
typedef CDataTableWriteOptions CLibMCEnvDataTableWriteOptions;
typedef CDataTableCSVWriteOptions CLibMCEnvDataTableCSVWriteOptions;
typedef CDataTable CLibMCEnvDataTable;
typedef CDataSeries CLibMCEnvDataSeries;
typedef CDateTimeDifference CLibMCEnvDateTimeDifference;
typedef CDateTime CLibMCEnvDateTime;
typedef CMeshObject CLibMCEnvMeshObject;
typedef CPersistentMeshObject CLibMCEnvPersistentMeshObject;
typedef CModelDataMeshInstance CLibMCEnvModelDataMeshInstance;
typedef CModelDataComponentInstance CLibMCEnvModelDataComponentInstance;
typedef CMeshSceneItem CLibMCEnvMeshSceneItem;
typedef CMeshScene CLibMCEnvMeshScene;
typedef CSceneHandler CLibMCEnvSceneHandler;
typedef CToolpathPart CLibMCEnvToolpathPart;
typedef CToolpathLayer CLibMCEnvToolpathLayer;
typedef CToolpathAccessor CLibMCEnvToolpathAccessor;
typedef CBuildExecution CLibMCEnvBuildExecution;
typedef CBuildExecutionIterator CLibMCEnvBuildExecutionIterator;
typedef CBuild CLibMCEnvBuild;
typedef CWorkingFileExecution CLibMCEnvWorkingFileExecution;
typedef CWorkingFile CLibMCEnvWorkingFile;
typedef CWorkingFileIterator CLibMCEnvWorkingFileIterator;
typedef CWorkingDirectory CLibMCEnvWorkingDirectory;
typedef CXMLDocumentAttribute CLibMCEnvXMLDocumentAttribute;
typedef CXMLDocumentNode CLibMCEnvXMLDocumentNode;
typedef CXMLDocumentNodes CLibMCEnvXMLDocumentNodes;
typedef CXMLDocument CLibMCEnvXMLDocument;
typedef CTCPIPPacket CLibMCEnvTCPIPPacket;
typedef CTCPIPConnection CLibMCEnvTCPIPConnection;
typedef CModbusTCPDigitalIOStatus CLibMCEnvModbusTCPDigitalIOStatus;
typedef CModbusTCPRegisterStatus CLibMCEnvModbusTCPRegisterStatus;
typedef CModbusTCPConnection CLibMCEnvModbusTCPConnection;
typedef CDriverStatusUpdateSession CLibMCEnvDriverStatusUpdateSession;
typedef CDriverEnvironment CLibMCEnvDriverEnvironment;
typedef CSignalTrigger CLibMCEnvSignalTrigger;
typedef CSignalHandler CLibMCEnvSignalHandler;
typedef CBaseTempStreamWriter CLibMCEnvBaseTempStreamWriter;
typedef CTempStreamWriter CLibMCEnvTempStreamWriter;
typedef CZIPStreamWriter CLibMCEnvZIPStreamWriter;
typedef CStreamReader CLibMCEnvStreamReader;
typedef CUniformJournalSampling CLibMCEnvUniformJournalSampling;
typedef CJournalVariable CLibMCEnvJournalVariable;
typedef CAlert CLibMCEnvAlert;
typedef CAlertIterator CLibMCEnvAlertIterator;
typedef CLogEntryList CLibMCEnvLogEntryList;
typedef CJournalHandler CLibMCEnvJournalHandler;
typedef CUserDetailList CLibMCEnvUserDetailList;
typedef CUserManagementHandler CLibMCEnvUserManagementHandler;
typedef CStateEnvironment CLibMCEnvStateEnvironment;
typedef CUIItem CLibMCEnvUIItem;
typedef CUIEnvironment CLibMCEnvUIEnvironment;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CIterator> PIterator;
typedef std::shared_ptr<CTestEnvironment> PTestEnvironment;
typedef std::shared_ptr<CCryptoContext> PCryptoContext;
typedef std::shared_ptr<CPNGImageStoreOptions> PPNGImageStoreOptions;
typedef std::shared_ptr<CPNGImageData> PPNGImageData;
typedef std::shared_ptr<CImageData> PImageData;
typedef std::shared_ptr<CDiscreteFieldData2DStoreOptions> PDiscreteFieldData2DStoreOptions;
typedef std::shared_ptr<CDiscreteFieldData2D> PDiscreteFieldData2D;
typedef std::shared_ptr<CDataTableWriteOptions> PDataTableWriteOptions;
typedef std::shared_ptr<CDataTableCSVWriteOptions> PDataTableCSVWriteOptions;
typedef std::shared_ptr<CDataTable> PDataTable;
typedef std::shared_ptr<CDataSeries> PDataSeries;
typedef std::shared_ptr<CDateTimeDifference> PDateTimeDifference;
typedef std::shared_ptr<CDateTime> PDateTime;
typedef std::shared_ptr<CMeshObject> PMeshObject;
typedef std::shared_ptr<CPersistentMeshObject> PPersistentMeshObject;
typedef std::shared_ptr<CModelDataMeshInstance> PModelDataMeshInstance;
typedef std::shared_ptr<CModelDataComponentInstance> PModelDataComponentInstance;
typedef std::shared_ptr<CMeshSceneItem> PMeshSceneItem;
typedef std::shared_ptr<CMeshScene> PMeshScene;
typedef std::shared_ptr<CSceneHandler> PSceneHandler;
typedef std::shared_ptr<CToolpathPart> PToolpathPart;
typedef std::shared_ptr<CToolpathLayer> PToolpathLayer;
typedef std::shared_ptr<CToolpathAccessor> PToolpathAccessor;
typedef std::shared_ptr<CBuildExecution> PBuildExecution;
typedef std::shared_ptr<CBuildExecutionIterator> PBuildExecutionIterator;
typedef std::shared_ptr<CBuild> PBuild;
typedef std::shared_ptr<CWorkingFileExecution> PWorkingFileExecution;
typedef std::shared_ptr<CWorkingFile> PWorkingFile;
typedef std::shared_ptr<CWorkingFileIterator> PWorkingFileIterator;
typedef std::shared_ptr<CWorkingDirectory> PWorkingDirectory;
typedef std::shared_ptr<CXMLDocumentAttribute> PXMLDocumentAttribute;
typedef std::shared_ptr<CXMLDocumentNode> PXMLDocumentNode;
typedef std::shared_ptr<CXMLDocumentNodes> PXMLDocumentNodes;
typedef std::shared_ptr<CXMLDocument> PXMLDocument;
typedef std::shared_ptr<CTCPIPPacket> PTCPIPPacket;
typedef std::shared_ptr<CTCPIPConnection> PTCPIPConnection;
typedef std::shared_ptr<CModbusTCPDigitalIOStatus> PModbusTCPDigitalIOStatus;
typedef std::shared_ptr<CModbusTCPRegisterStatus> PModbusTCPRegisterStatus;
typedef std::shared_ptr<CModbusTCPConnection> PModbusTCPConnection;
typedef std::shared_ptr<CDriverStatusUpdateSession> PDriverStatusUpdateSession;
typedef std::shared_ptr<CDriverEnvironment> PDriverEnvironment;
typedef std::shared_ptr<CSignalTrigger> PSignalTrigger;
typedef std::shared_ptr<CSignalHandler> PSignalHandler;
typedef std::shared_ptr<CBaseTempStreamWriter> PBaseTempStreamWriter;
typedef std::shared_ptr<CTempStreamWriter> PTempStreamWriter;
typedef std::shared_ptr<CZIPStreamWriter> PZIPStreamWriter;
typedef std::shared_ptr<CStreamReader> PStreamReader;
typedef std::shared_ptr<CUniformJournalSampling> PUniformJournalSampling;
typedef std::shared_ptr<CJournalVariable> PJournalVariable;
typedef std::shared_ptr<CAlert> PAlert;
typedef std::shared_ptr<CAlertIterator> PAlertIterator;
typedef std::shared_ptr<CLogEntryList> PLogEntryList;
typedef std::shared_ptr<CJournalHandler> PJournalHandler;
typedef std::shared_ptr<CUserDetailList> PUserDetailList;
typedef std::shared_ptr<CUserManagementHandler> PUserManagementHandler;
typedef std::shared_ptr<CStateEnvironment> PStateEnvironment;
typedef std::shared_ptr<CUIItem> PUIItem;
typedef std::shared_ptr<CUIEnvironment> PUIEnvironment;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCEnvWrapper;
typedef PBase PLibMCEnvBase;
typedef PIterator PLibMCEnvIterator;
typedef PTestEnvironment PLibMCEnvTestEnvironment;
typedef PCryptoContext PLibMCEnvCryptoContext;
typedef PPNGImageStoreOptions PLibMCEnvPNGImageStoreOptions;
typedef PPNGImageData PLibMCEnvPNGImageData;
typedef PImageData PLibMCEnvImageData;
typedef PDiscreteFieldData2DStoreOptions PLibMCEnvDiscreteFieldData2DStoreOptions;
typedef PDiscreteFieldData2D PLibMCEnvDiscreteFieldData2D;
typedef PDataTableWriteOptions PLibMCEnvDataTableWriteOptions;
typedef PDataTableCSVWriteOptions PLibMCEnvDataTableCSVWriteOptions;
typedef PDataTable PLibMCEnvDataTable;
typedef PDataSeries PLibMCEnvDataSeries;
typedef PDateTimeDifference PLibMCEnvDateTimeDifference;
typedef PDateTime PLibMCEnvDateTime;
typedef PMeshObject PLibMCEnvMeshObject;
typedef PPersistentMeshObject PLibMCEnvPersistentMeshObject;
typedef PModelDataMeshInstance PLibMCEnvModelDataMeshInstance;
typedef PModelDataComponentInstance PLibMCEnvModelDataComponentInstance;
typedef PMeshSceneItem PLibMCEnvMeshSceneItem;
typedef PMeshScene PLibMCEnvMeshScene;
typedef PSceneHandler PLibMCEnvSceneHandler;
typedef PToolpathPart PLibMCEnvToolpathPart;
typedef PToolpathLayer PLibMCEnvToolpathLayer;
typedef PToolpathAccessor PLibMCEnvToolpathAccessor;
typedef PBuildExecution PLibMCEnvBuildExecution;
typedef PBuildExecutionIterator PLibMCEnvBuildExecutionIterator;
typedef PBuild PLibMCEnvBuild;
typedef PWorkingFileExecution PLibMCEnvWorkingFileExecution;
typedef PWorkingFile PLibMCEnvWorkingFile;
typedef PWorkingFileIterator PLibMCEnvWorkingFileIterator;
typedef PWorkingDirectory PLibMCEnvWorkingDirectory;
typedef PXMLDocumentAttribute PLibMCEnvXMLDocumentAttribute;
typedef PXMLDocumentNode PLibMCEnvXMLDocumentNode;
typedef PXMLDocumentNodes PLibMCEnvXMLDocumentNodes;
typedef PXMLDocument PLibMCEnvXMLDocument;
typedef PTCPIPPacket PLibMCEnvTCPIPPacket;
typedef PTCPIPConnection PLibMCEnvTCPIPConnection;
typedef PModbusTCPDigitalIOStatus PLibMCEnvModbusTCPDigitalIOStatus;
typedef PModbusTCPRegisterStatus PLibMCEnvModbusTCPRegisterStatus;
typedef PModbusTCPConnection PLibMCEnvModbusTCPConnection;
typedef PDriverStatusUpdateSession PLibMCEnvDriverStatusUpdateSession;
typedef PDriverEnvironment PLibMCEnvDriverEnvironment;
typedef PSignalTrigger PLibMCEnvSignalTrigger;
typedef PSignalHandler PLibMCEnvSignalHandler;
typedef PBaseTempStreamWriter PLibMCEnvBaseTempStreamWriter;
typedef PTempStreamWriter PLibMCEnvTempStreamWriter;
typedef PZIPStreamWriter PLibMCEnvZIPStreamWriter;
typedef PStreamReader PLibMCEnvStreamReader;
typedef PUniformJournalSampling PLibMCEnvUniformJournalSampling;
typedef PJournalVariable PLibMCEnvJournalVariable;
typedef PAlert PLibMCEnvAlert;
typedef PAlertIterator PLibMCEnvAlertIterator;
typedef PLogEntryList PLibMCEnvLogEntryList;
typedef PJournalHandler PLibMCEnvJournalHandler;
typedef PUserDetailList PLibMCEnvUserDetailList;
typedef PUserManagementHandler PLibMCEnvUserManagementHandler;
typedef PStateEnvironment PLibMCEnvStateEnvironment;
typedef PUIItem PLibMCEnvUIItem;
typedef PUIEnvironment PLibMCEnvUIEnvironment;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCEnvHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCEnvException 
**************************************************************************************************************************/
class ELibMCEnvException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCEnvResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCEnvException(LibMCEnvResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCEnvResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCENV_SUCCESS: return "SUCCESS";
			case LIBMCENV_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCENV_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCENV_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCENV_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCENV_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCENV_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCENV_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCENV_ERROR_PARAMETERGROUPNOTFOUND: return "PARAMETERGROUPNOTFOUND";
			case LIBMCENV_ERROR_PARAMETERNOTFOUND: return "PARAMETERNOTFOUND";
			case LIBMCENV_ERROR_COULDNOTFINDSIGNALDEFINITON: return "COULDNOTFINDSIGNALDEFINITON";
			case LIBMCENV_ERROR_COULDNOTTRIGGERSIGNAL: return "COULDNOTTRIGGERSIGNAL";
			case LIBMCENV_ERROR_SIGNALNOTFOUND: return "SIGNALNOTFOUND";
			case LIBMCENV_ERROR_TERMINATED: return "TERMINATED";
			case LIBMCENV_ERROR_SIGNALHASTRIGGEREDTWICE: return "SIGNALHASTRIGGEREDTWICE";
			case LIBMCENV_ERROR_SIGNALHASNOTBEENTRIGGERED: return "SIGNALHASNOTBEENTRIGGERED";
			case LIBMCENV_ERROR_DRIVERISNOTINITIALISING: return "DRIVERISNOTINITIALISING";
			case LIBMCENV_ERROR_RESOURCEENTRYNOTFOUND: return "RESOURCEENTRYNOTFOUND";
			case LIBMCENV_ERROR_INTERNALERROR: return "INTERNALERROR";
			case LIBMCENV_ERROR_INVALIDCHARACTERINFILENAME: return "INVALIDCHARACTERINFILENAME";
			case LIBMCENV_ERROR_WORKINGDIRECTORYHASBEENCLEANED: return "WORKINGDIRECTORYHASBEENCLEANED";
			case LIBMCENV_ERROR_INVALIDITERATOR: return "INVALIDITERATOR";
			case LIBMCENV_ERROR_FORMVALUENOTFOUND: return "FORMVALUENOTFOUND";
			case LIBMCENV_ERROR_INVALIDDOUBLEFORMVALUE: return "INVALIDDOUBLEFORMVALUE";
			case LIBMCENV_ERROR_INVALIDINTEGERFORMVALUE: return "INVALIDINTEGERFORMVALUE";
			case LIBMCENV_ERROR_COULDNNOTACCESSCLIENTVARIABLES: return "COULDNNOTACCESSCLIENTVARIABLES";
			case LIBMCENV_ERROR_INVALIDPIXELCOUNT: return "INVALIDPIXELCOUNT";
			case LIBMCENV_ERROR_INVALIDDPIVALUE: return "INVALIDDPIVALUE";
			case LIBMCENV_ERROR_COULDNOTCOMPRESSPNGIMAGE: return "COULDNOTCOMPRESSPNGIMAGE";
			case LIBMCENV_ERROR_COULDNOTSTOREPNGIMAGE: return "COULDNOTSTOREPNGIMAGE";
			case LIBMCENV_ERROR_EMPTYPNGIMAGEDATA: return "EMPTYPNGIMAGEDATA";
			case LIBMCENV_ERROR_INVALIDXCOORDINATE: return "INVALIDXCOORDINATE";
			case LIBMCENV_ERROR_INVALIDYCOORDINATE: return "INVALIDYCOORDINATE";
			case LIBMCENV_ERROR_INVALIDXCOORDINATERANGE: return "INVALIDXCOORDINATERANGE";
			case LIBMCENV_ERROR_INVALIDYCOORDINATERANGE: return "INVALIDYCOORDINATERANGE";
			case LIBMCENV_ERROR_INVALIDPIXELDATACOUNT: return "INVALIDPIXELDATACOUNT";
			case LIBMCENV_ERROR_INVALIDIMAGEBUFFER: return "INVALIDIMAGEBUFFER";
			case LIBMCENV_ERROR_INVALIDPIXELFORMAT: return "INVALIDPIXELFORMAT";
			case LIBMCENV_ERROR_INVALIDTESTOUTPUTNAME: return "INVALIDTESTOUTPUTNAME";
			case LIBMCENV_ERROR_TOOLPATHNOTLOADED: return "TOOLPATHNOTLOADED";
			case LIBMCENV_ERROR_INVALIDLAYERINDEX: return "INVALIDLAYERINDEX";
			case LIBMCENV_ERROR_INVALIDHATCHCOUNT: return "INVALIDHATCHCOUNT";
			case LIBMCENV_ERROR_SEGMENTISNOTOFTYPEHATCH: return "SEGMENTISNOTOFTYPEHATCH";
			case LIBMCENV_ERROR_TEMPFILEEXTENSIONEXCEEDS64CHARACTERS: return "TEMPFILEEXTENSIONEXCEEDS64CHARACTERS";
			case LIBMCENV_ERROR_TEMPFILEEXTENSIONCONTAINSINVALIDCHARACTERS: return "TEMPFILEEXTENSIONCONTAINSINVALIDCHARACTERS";
			case LIBMCENV_ERROR_COULDNOTGENERATETEMPFILENAME: return "COULDNOTGENERATETEMPFILENAME";
			case LIBMCENV_ERROR_EMPTYTCPIPPACKET: return "EMPTYTCPIPPACKET";
			case LIBMCENV_ERROR_COULDNOTGETADDRESSINFO: return "COULDNOTGETADDRESSINFO";
			case LIBMCENV_ERROR_COULDNOTCREATESOCKET: return "COULDNOTCREATESOCKET";
			case LIBMCENV_ERROR_COULDNOTCONNECT: return "COULDNOTCONNECT";
			case LIBMCENV_ERROR_SENDERROR: return "SENDERROR";
			case LIBMCENV_ERROR_RECEIVECOUNTEXCEEDSMAXIMUM: return "RECEIVECOUNTEXCEEDSMAXIMUM";
			case LIBMCENV_ERROR_CONNECTIONCLOSED: return "CONNECTIONCLOSED";
			case LIBMCENV_ERROR_RECEIVEERROR: return "RECEIVEERROR";
			case LIBMCENV_ERROR_SENDCOUNTEXCEEDSMAXIMUM: return "SENDCOUNTEXCEEDSMAXIMUM";
			case LIBMCENV_ERROR_SOCKETNOTCONNECTED: return "SOCKETNOTCONNECTED";
			case LIBMCENV_ERROR_INVALIDSENDBUFFER: return "INVALIDSENDBUFFER";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPPAYLOADSIZE: return "INVALIDMODBUSTCPPAYLOADSIZE";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPREQUEST: return "INVALIDMODBUSTCPREQUEST";
			case LIBMCENV_ERROR_INSUFFICIENTMODBUSTCPRESPONSEHEADER: return "INSUFFICIENTMODBUSTCPRESPONSEHEADER";
			case LIBMCENV_ERROR_MODBUSTCPRESPONSEOVERFLOW: return "MODBUSTCPRESPONSEOVERFLOW";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPTRANSACTIONIDRESPONSE: return "INVALIDMODBUSTCPTRANSACTIONIDRESPONSE";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPPROTOCOLIDRESPONSE: return "INVALIDMODBUSTCPPROTOCOLIDRESPONSE";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPUNITIDENTIFIERRESPONSE: return "INVALIDMODBUSTCPUNITIDENTIFIERRESPONSE";
			case LIBMCENV_ERROR_MODBUSTCPRESPONSELENGTHMISMATCH: return "MODBUSTCPRESPONSELENGTHMISMATCH";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSBITCOUNT: return "MODBUSTCPINVALIDCOILSTATUSBITCOUNT";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSRESPONSE: return "MODBUSTCPINVALIDCOILSTATUSRESPONSE";
			case LIBMCENV_ERROR_MODBUSTCPCOILSTATUSRESPONSEEMPTY: return "MODBUSTCPCOILSTATUSRESPONSEEMPTY";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSRESPONSESIZE: return "MODBUSTCPINVALIDCOILSTATUSRESPONSESIZE";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSBITCOUNT: return "MODBUSTCPINVALIDINPUTSTATUSBITCOUNT";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSRESPONSE: return "MODBUSTCPINVALIDINPUTSTATUSRESPONSE";
			case LIBMCENV_ERROR_MODBUSTCPINPUTSTATUSRESPONSEEMPTY: return "MODBUSTCPINPUTSTATUSRESPONSEEMPTY";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSRESPONSESIZE: return "MODBUSTCPINVALIDINPUTSTATUSRESPONSESIZE";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPCOILCOUNT: return "INVALIDMODBUSTCPCOILCOUNT";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPREGISTERCOUNT: return "INVALIDMODBUSTCPREGISTERCOUNT";
			case LIBMCENV_ERROR_INVALIDMODBUSIOINDEX: return "INVALIDMODBUSIOINDEX";
			case LIBMCENV_ERROR_MODBUSIOSTATUSEMPTY: return "MODBUSIOSTATUSEMPTY";
			case LIBMCENV_ERROR_INVALIDMODBUSREGISTERINDEX: return "INVALIDMODBUSREGISTERINDEX";
			case LIBMCENV_ERROR_MODBUSREGISTERSTATUSEMPTY: return "MODBUSREGISTERSTATUSEMPTY";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTREGISTERSRESPONSE: return "MODBUSTCPINVALIDINPUTREGISTERSRESPONSE";
			case LIBMCENV_ERROR_MODBUSTCPINPUTREGISTERSRESPONSEEMPTY: return "MODBUSTCPINPUTREGISTERSRESPONSEEMPTY";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTREGISTERSRESPONSESIZE: return "MODBUSTCPINVALIDINPUTREGISTERSRESPONSESIZE";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSE: return "MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSE";
			case LIBMCENV_ERROR_MODBUSTCPHOLDINGREGISTERSRESPONSEEMPTY: return "MODBUSTCPHOLDINGREGISTERSRESPONSEEMPTY";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSESIZE: return "MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSESIZE";
			case LIBMCENV_ERROR_SIGNALUUIDNOTACTIVE: return "SIGNALUUIDNOTACTIVE";
			case LIBMCENV_ERROR_COULDNOTPARSEXMLSTRING: return "COULDNOTPARSEXMLSTRING";
			case LIBMCENV_ERROR_COULDNOTPARSEXMLDATA: return "COULDNOTPARSEXMLDATA";
			case LIBMCENV_ERROR_INVALIDPROFILEVALUETYPE: return "INVALIDPROFILEVALUETYPE";
			case LIBMCENV_ERROR_XMLDOCUMENTMISMATCH: return "XMLDOCUMENTMISMATCH";
			case LIBMCENV_ERROR_INVALIDINTEGERVALUEATTRIBUTE: return "INVALIDINTEGERVALUEATTRIBUTE";
			case LIBMCENV_ERROR_INTEGERVALUEATTRIBUTEOUTOFRANGE: return "INTEGERVALUEATTRIBUTEOUTOFRANGE";
			case LIBMCENV_ERROR_INVALIDDOUBLEVALUEATTRIBUTE: return "INVALIDDOUBLEVALUEATTRIBUTE";
			case LIBMCENV_ERROR_DOUBLEVALUEATTRIBUTEOUTOFRANGE: return "DOUBLEVALUEATTRIBUTEOUTOFRANGE";
			case LIBMCENV_ERROR_INVALIDDEFAULTIMAGEVALUE: return "INVALIDDEFAULTIMAGEVALUE";
			case LIBMCENV_ERROR_INVALIDPIXELMEMORYSIZE: return "INVALIDPIXELMEMORYSIZE";
			case LIBMCENV_ERROR_INVALIDFIELDBUFFER: return "INVALIDFIELDBUFFER";
			case LIBMCENV_ERROR_INTERNALFIELDSIZEERROR: return "INTERNALFIELDSIZEERROR";
			case LIBMCENV_ERROR_INVALIDFIELDSIZE: return "INVALIDFIELDSIZE";
			case LIBMCENV_ERROR_INVALIDFIELDSCALINGFACTOR: return "INVALIDFIELDSCALINGFACTOR";
			case LIBMCENV_ERROR_SCALINGEXCEEDSMAXIMUMPIXELCOUNT: return "SCALINGEXCEEDSMAXIMUMPIXELCOUNT";
			case LIBMCENV_ERROR_INTERNALSCALINGERROR: return "INTERNALSCALINGERROR";
			case LIBMCENV_ERROR_INVALIDCOLORRANGE: return "INVALIDCOLORRANGE";
			case LIBMCENV_ERROR_EMPTYJOURNALVARIABLENAME: return "EMPTYJOURNALVARIABLENAME";
			case LIBMCENV_ERROR_INVALIDJOURNALVARIABLEINTERVAL: return "INVALIDJOURNALVARIABLEINTERVAL";
			case LIBMCENV_ERROR_JOURNALVARIABLENOTFOUND: return "JOURNALVARIABLENOTFOUND";
			case LIBMCENV_ERROR_COMPUTATIONOUTSIDEOFJOURNALDATA: return "COMPUTATIONOUTSIDEOFJOURNALDATA";
			case LIBMCENV_ERROR_INVALIDJOURNALCOMPUTEINTERVAL: return "INVALIDJOURNALCOMPUTEINTERVAL";
			case LIBMCENV_ERROR_INVALIDJOURNALCOMPUTEDATA: return "INVALIDJOURNALCOMPUTEDATA";
			case LIBMCENV_ERROR_INVALIDSEGMENTATTRIBUTETYPE: return "INVALIDSEGMENTATTRIBUTETYPE";
			case LIBMCENV_ERROR_SEGMENTATTRIBUTENOTFOUND: return "SEGMENTATTRIBUTENOTFOUND";
			case LIBMCENV_ERROR_UNSUPPORTEDFIELDSAMPLINGMODE: return "UNSUPPORTEDFIELDSAMPLINGMODE";
			case LIBMCENV_ERROR_SAMPLEPOINTCOUNTEXCEEDSMAXIMUM: return "SAMPLEPOINTCOUNTEXCEEDSMAXIMUM";
			case LIBMCENV_ERROR_INVALIDCLAMPINTERVAL: return "INVALIDCLAMPINTERVAL";
			case LIBMCENV_ERROR_COULDNOTRETRIEVEPNGSTREAM: return "COULDNOTRETRIEVEPNGSTREAM";
			case LIBMCENV_ERROR_COULDNOTSTOREFIELDDATA: return "COULDNOTSTOREFIELDDATA";
			case LIBMCENV_ERROR_DISCRETEFIELDDATANOTFOUND: return "DISCRETEFIELDDATANOTFOUND";
			case LIBMCENV_ERROR_EMPTYUSERLOGIN: return "EMPTYUSERLOGIN";
			case LIBMCENV_ERROR_INVALIDUSERLOGIN: return "INVALIDUSERLOGIN";
			case LIBMCENV_ERROR_EMPTYPERMISSIONIDENTIFIER: return "EMPTYPERMISSIONIDENTIFIER";
			case LIBMCENV_ERROR_INVALIDPERMISSIONIDENTIFIER: return "INVALIDPERMISSIONIDENTIFIER";
			case LIBMCENV_ERROR_EMPTYUSERROLE: return "EMPTYUSERROLE";
			case LIBMCENV_ERROR_INVALIDUSERROLE: return "INVALIDUSERROLE";
			case LIBMCENV_ERROR_EMPTYUSERLANGUAGE: return "EMPTYUSERLANGUAGE";
			case LIBMCENV_ERROR_INVALIDUSERLANGUAGE: return "INVALIDUSERLANGUAGE";
			case LIBMCENV_ERROR_ORIGINOUTOFRANGE: return "ORIGINOUTOFRANGE";
			case LIBMCENV_ERROR_RAWPIXELDATASIZEMISMATCH: return "RAWPIXELDATASIZEMISMATCH";
			case LIBMCENV_ERROR_EMPTYPNGSTREAM: return "EMPTYPNGSTREAM";
			case LIBMCENV_ERROR_COULDNOTLOADPNGIMAGE: return "COULDNOTLOADPNGIMAGE";
			case LIBMCENV_ERROR_INVALIDPIXELSIZE: return "INVALIDPIXELSIZE";
			case LIBMCENV_ERROR_MESHISNOTREGISTERED: return "MESHISNOTREGISTERED";
			case LIBMCENV_ERROR_INVALIDUSERINDEX: return "INVALIDUSERINDEX";
			case LIBMCENV_ERROR_DATASERIESTIMESTAMPSNOTINCREMENTING: return "DATASERIESTIMESTAMPSNOTINCREMENTING";
			case LIBMCENV_ERROR_INVALIDNUMBEROFSAMPLES: return "INVALIDNUMBEROFSAMPLES";
			case LIBMCENV_ERROR_EMPTYALERTIDENTIFIER: return "EMPTYALERTIDENTIFIER";
			case LIBMCENV_ERROR_INVALIDALERTIDENTIFIER: return "INVALIDALERTIDENTIFIER";
			case LIBMCENV_ERROR_ALERTNOTFOUND: return "ALERTNOTFOUND";
			case LIBMCENV_ERROR_USERDOESNOTEXIST: return "USERDOESNOTEXIST";
			case LIBMCENV_ERROR_EMPTYSHA256SOURCE: return "EMPTYSHA256SOURCE";
			case LIBMCENV_ERROR_ALERTHASNOUSERCONTEXT: return "ALERTHASNOUSERCONTEXT";
			case LIBMCENV_ERROR_EMPTYJOURNALSTREAMNAME: return "EMPTYJOURNALSTREAMNAME";
			case LIBMCENV_ERROR_EMPTYJOURNALSTREAMMIMETYPE: return "EMPTYJOURNALSTREAMMIMETYPE";
			case LIBMCENV_ERROR_INVALIDSTREAMREADCALLBACK: return "INVALIDSTREAMREADCALLBACK";
			case LIBMCENV_ERROR_INVALIDSTREAMSEEKCALLBACK: return "INVALIDSTREAMSEEKCALLBACK";
			case LIBMCENV_ERROR_INVALIDSTREAMCALLBACKUSERDATA: return "INVALIDSTREAMCALLBACKUSERDATA";
			case LIBMCENV_ERROR_STREAMREADEXCEEDSSTREAMSIZE: return "STREAMREADEXCEEDSSTREAMSIZE";
			case LIBMCENV_ERROR_INVALIDSTREAMREADSIZE: return "INVALIDSTREAMREADSIZE";
			case LIBMCENV_ERROR_INVALIDSTREAMSEEKPOSITION: return "INVALIDSTREAMSEEKPOSITION";
			case LIBMCENV_ERROR_STORAGESTREAMNOTFOUND: return "STORAGESTREAMNOTFOUND";
			case LIBMCENV_ERROR_DOWNLOADSTREAMDOESNOTEXIST: return "DOWNLOADSTREAMDOESNOTEXIST";
			case LIBMCENV_ERROR_EMPTYDOWNLOADSTREAMFILENAME: return "EMPTYDOWNLOADSTREAMFILENAME";
			case LIBMCENV_ERROR_INVALIDDOWNLOADSTREAMFILENAME: return "INVALIDDOWNLOADSTREAMFILENAME";
			case LIBMCENV_ERROR_USERISNOTAUTHORIZED: return "USERISNOTAUTHORIZED";
			case LIBMCENV_ERROR_INVALIDMETADATAKEY: return "INVALIDMETADATAKEY";
			case LIBMCENV_ERROR_CANNOTCHANGESTATUSOFBUILDEXECUTION: return "CANNOTCHANGESTATUSOFBUILDEXECUTION";
			case LIBMCENV_ERROR_BUILDEXECUTIONHASNOATTACHEDUSER: return "BUILDEXECUTIONHASNOATTACHEDUSER";
			case LIBMCENV_ERROR_UNITSAREOUTOFRANGE: return "UNITSAREOUTOFRANGE";
			case LIBMCENV_ERROR_COLUMNIDENTIFIEREMPTY: return "COLUMNIDENTIFIEREMPTY";
			case LIBMCENV_ERROR_INVALIDCOLUMNIDENTIFIER: return "INVALIDCOLUMNIDENTIFIER";
			case LIBMCENV_ERROR_DUPLICATECOLUMNIDENTIFIER: return "DUPLICATECOLUMNIDENTIFIER";
			case LIBMCENV_ERROR_INVALIDCOLUMNDATATYPE: return "INVALIDCOLUMNDATATYPE";
			case LIBMCENV_ERROR_DATATABLEHASTOOMANYCOLUMS: return "DATATABLEHASTOOMANYCOLUMS";
			case LIBMCENV_ERROR_COLUMNIDENTIFIERNOTFOUND: return "COLUMNIDENTIFIERNOTFOUND";
			case LIBMCENV_ERROR_INVALIDCOLUMNINDEX: return "INVALIDCOLUMNINDEX";
			case LIBMCENV_ERROR_COLUMNBUFFERISNULL: return "COLUMNBUFFERISNULL";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEDOUBLE: return "COLUMNISNOTOFTYPEDOUBLE";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEUINT32: return "COLUMNISNOTOFTYPEUINT32";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEUINT64: return "COLUMNISNOTOFTYPEUINT64";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEINT32: return "COLUMNISNOTOFTYPEINT32";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEINT64: return "COLUMNISNOTOFTYPEINT64";
			case LIBMCENV_ERROR_INVALIDCSVSEPARATOR: return "INVALIDCSVSEPARATOR";
			case LIBMCENV_ERROR_DATATABLECSVBUFFEROVERFLOW: return "DATATABLECSVBUFFEROVERFLOW";
			case LIBMCENV_ERROR_DATETIMEDIFFERENCEISINVALID: return "DATETIMEDIFFERENCEISINVALID";
			case LIBMCENV_ERROR_DATETIMEISINVALID: return "DATETIMEISINVALID";
			case LIBMCENV_ERROR_DATETIMEOUTOFBOUNDS: return "DATETIMEOUTOFBOUNDS";
			case LIBMCENV_ERROR_EMPTYPNGBUFFER: return "EMPTYPNGBUFFER";
			case LIBMCENV_ERROR_CANNOTSEEKZIPSTREAM: return "CANNOTSEEKZIPSTREAM";
			case LIBMCENV_ERROR_GLOBALTIMERNOTCONTINUOUS: return "GLOBALTIMERNOTCONTINUOUS";
			case LIBMCENV_ERROR_STREAMWRITERISNOTFINISHED: return "STREAMWRITERISNOTFINISHED";
			case LIBMCENV_ERROR_CANNOTREADFROMZIPSTREAM: return "CANNOTREADFROMZIPSTREAM";
			case LIBMCENV_ERROR_EMPTYDATATABLENAME: return "EMPTYDATATABLENAME";
			case LIBMCENV_ERROR_EMPTYDATATABLEIDENTIFIER: return "EMPTYDATATABLEIDENTIFIER";
			case LIBMCENV_ERROR_INVALIDDATATABLEIDENTIFIER: return "INVALIDDATATABLEIDENTIFIER";
			case LIBMCENV_ERROR_INVALIDDATATABLESIGNATURE: return "INVALIDDATATABLESIGNATURE";
			case LIBMCENV_ERROR_INVALIDSUPPORTINDEX: return "INVALIDSUPPORTINDEX";
			case LIBMCENV_ERROR_INVALIDSOLIDINDEX: return "INVALIDSOLIDINDEX";
			case LIBMCENV_ERROR_INVALIDCOMPONENTINDEX: return "INVALIDCOMPONENTINDEX";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCENV_SUCCESS: return "success";
			case LIBMCENV_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCENV_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCENV_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCENV_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCENV_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCENV_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCENV_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCENV_ERROR_PARAMETERGROUPNOTFOUND: return "Parameter group not found";
			case LIBMCENV_ERROR_PARAMETERNOTFOUND: return "Parameter not found";
			case LIBMCENV_ERROR_COULDNOTFINDSIGNALDEFINITON: return "Could not find signal definition";
			case LIBMCENV_ERROR_COULDNOTTRIGGERSIGNAL: return "Could not trigger signal";
			case LIBMCENV_ERROR_SIGNALNOTFOUND: return "Signal not found";
			case LIBMCENV_ERROR_TERMINATED: return "operation has been terminated.";
			case LIBMCENV_ERROR_SIGNALHASTRIGGEREDTWICE: return "signal has been triggered twice.";
			case LIBMCENV_ERROR_SIGNALHASNOTBEENTRIGGERED: return "signal has not been triggered.";
			case LIBMCENV_ERROR_DRIVERISNOTINITIALISING: return "driver is not in initialisation mode.";
			case LIBMCENV_ERROR_RESOURCEENTRYNOTFOUND: return "resource entry not found.";
			case LIBMCENV_ERROR_INTERNALERROR: return "internal error.";
			case LIBMCENV_ERROR_INVALIDCHARACTERINFILENAME: return "invalid character in filename.";
			case LIBMCENV_ERROR_WORKINGDIRECTORYHASBEENCLEANED: return "working directory has been cleaned.";
			case LIBMCENV_ERROR_INVALIDITERATOR: return "invalid iterator.";
			case LIBMCENV_ERROR_FORMVALUENOTFOUND: return "Form value not found.";
			case LIBMCENV_ERROR_INVALIDDOUBLEFORMVALUE: return "Invalid double form value.";
			case LIBMCENV_ERROR_INVALIDINTEGERFORMVALUE: return "Invalid integer form value.";
			case LIBMCENV_ERROR_COULDNNOTACCESSCLIENTVARIABLES: return "Could not access client variables.";
			case LIBMCENV_ERROR_INVALIDPIXELCOUNT: return "Invalid pixel count.";
			case LIBMCENV_ERROR_INVALIDDPIVALUE: return "Invalid dpi value.";
			case LIBMCENV_ERROR_COULDNOTCOMPRESSPNGIMAGE: return "Could not compress PNG image.";
			case LIBMCENV_ERROR_COULDNOTSTOREPNGIMAGE: return "Could not store PNG image.";
			case LIBMCENV_ERROR_EMPTYPNGIMAGEDATA: return "Empty PNG image data.";
			case LIBMCENV_ERROR_INVALIDXCOORDINATE: return "Invalid X coordinate.";
			case LIBMCENV_ERROR_INVALIDYCOORDINATE: return "Invalid Y coordinate.";
			case LIBMCENV_ERROR_INVALIDXCOORDINATERANGE: return "Invalid X coordinate range.";
			case LIBMCENV_ERROR_INVALIDYCOORDINATERANGE: return "Invalid Y coordinate range.";
			case LIBMCENV_ERROR_INVALIDPIXELDATACOUNT: return "Invalid pixel data count.";
			case LIBMCENV_ERROR_INVALIDIMAGEBUFFER: return "Invalid image buffer.";
			case LIBMCENV_ERROR_INVALIDPIXELFORMAT: return "Invalid pixel format.";
			case LIBMCENV_ERROR_INVALIDTESTOUTPUTNAME: return "Invalid test output name.";
			case LIBMCENV_ERROR_TOOLPATHNOTLOADED: return "Toolpath has not been loaded.";
			case LIBMCENV_ERROR_INVALIDLAYERINDEX: return "Invalid layer index.";
			case LIBMCENV_ERROR_INVALIDHATCHCOUNT: return "Invalid hatch count.";
			case LIBMCENV_ERROR_SEGMENTISNOTOFTYPEHATCH: return "Segment is not of type hatch.";
			case LIBMCENV_ERROR_TEMPFILEEXTENSIONEXCEEDS64CHARACTERS: return "Temp file extension exceeds 64 characters.";
			case LIBMCENV_ERROR_TEMPFILEEXTENSIONCONTAINSINVALIDCHARACTERS: return "Temp file extension contains invalid characters.";
			case LIBMCENV_ERROR_COULDNOTGENERATETEMPFILENAME: return "Could not generate temp file name.";
			case LIBMCENV_ERROR_EMPTYTCPIPPACKET: return "Empty TCP/IP Packet.";
			case LIBMCENV_ERROR_COULDNOTGETADDRESSINFO: return "Could not get address info.";
			case LIBMCENV_ERROR_COULDNOTCREATESOCKET: return "Could not create socket.";
			case LIBMCENV_ERROR_COULDNOTCONNECT: return "Could not connect.";
			case LIBMCENV_ERROR_SENDERROR: return "Send error.";
			case LIBMCENV_ERROR_RECEIVECOUNTEXCEEDSMAXIMUM: return "Receive count exceeds maximum.";
			case LIBMCENV_ERROR_CONNECTIONCLOSED: return "Connection closed.";
			case LIBMCENV_ERROR_RECEIVEERROR: return "Receive error.";
			case LIBMCENV_ERROR_SENDCOUNTEXCEEDSMAXIMUM: return "Send count exceeds maximum.";
			case LIBMCENV_ERROR_SOCKETNOTCONNECTED: return "Socket not connected.";
			case LIBMCENV_ERROR_INVALIDSENDBUFFER: return "Invalid send buffer.";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPPAYLOADSIZE: return "Invalid modbus TCP payload size";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPREQUEST: return "Invalid modbus TCP request";
			case LIBMCENV_ERROR_INSUFFICIENTMODBUSTCPRESPONSEHEADER: return "Insufficient modbus tcp response header";
			case LIBMCENV_ERROR_MODBUSTCPRESPONSEOVERFLOW: return "modbus tcp response overflow";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPTRANSACTIONIDRESPONSE: return "invalid modbus tcp transaction ID response";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPPROTOCOLIDRESPONSE: return "invalid modbus tcp protocol ID response";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPUNITIDENTIFIERRESPONSE: return "invalid modbus tcp unit identifier response";
			case LIBMCENV_ERROR_MODBUSTCPRESPONSELENGTHMISMATCH: return "modbus tcp response length mismatch";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSBITCOUNT: return "modbus TCP Invalid coils status bit count.";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSRESPONSE: return "modbus TCP Invalid coils status response.";
			case LIBMCENV_ERROR_MODBUSTCPCOILSTATUSRESPONSEEMPTY: return "modbus TCP coils status response empty.";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSRESPONSESIZE: return "modbus TCP invalid coil status response size.";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSBITCOUNT: return "modbus TCP invalid input status bit count.";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSRESPONSE: return "modbus TCP invalid input status response.";
			case LIBMCENV_ERROR_MODBUSTCPINPUTSTATUSRESPONSEEMPTY: return "modbus TCP input status response empty.";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSRESPONSESIZE: return "modbus TCP invalid input status response size.";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPCOILCOUNT: return "invalid modbus tcp coil count.";
			case LIBMCENV_ERROR_INVALIDMODBUSTCPREGISTERCOUNT: return "invalid modbus tcp register count.";
			case LIBMCENV_ERROR_INVALIDMODBUSIOINDEX: return "invalid modbus IO index.";
			case LIBMCENV_ERROR_MODBUSIOSTATUSEMPTY: return "modbus io status empty.";
			case LIBMCENV_ERROR_INVALIDMODBUSREGISTERINDEX: return "invalid modbus register index.";
			case LIBMCENV_ERROR_MODBUSREGISTERSTATUSEMPTY: return "modbus register status empty.";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTREGISTERSRESPONSE: return "modbus TCP invalid input registers response";
			case LIBMCENV_ERROR_MODBUSTCPINPUTREGISTERSRESPONSEEMPTY: return "modbus TCP input registers response empty";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTREGISTERSRESPONSESIZE: return "modbus TCP invalid input registers response size";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSE: return "modbus TCP invalid holding registers response";
			case LIBMCENV_ERROR_MODBUSTCPHOLDINGREGISTERSRESPONSEEMPTY: return "modbus TCP holding registers response empty";
			case LIBMCENV_ERROR_MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSESIZE: return "modbus TCP invalid holding registers response size";
			case LIBMCENV_ERROR_SIGNALUUIDNOTACTIVE: return "signal UUID not active.";
			case LIBMCENV_ERROR_COULDNOTPARSEXMLSTRING: return "could not parse XML string.";
			case LIBMCENV_ERROR_COULDNOTPARSEXMLDATA: return "could not parse XML data.";
			case LIBMCENV_ERROR_INVALIDPROFILEVALUETYPE: return "Invalid profile value type.";
			case LIBMCENV_ERROR_XMLDOCUMENTMISMATCH: return "XML Document mismatch.";
			case LIBMCENV_ERROR_INVALIDINTEGERVALUEATTRIBUTE: return "Invalid integer value attribute.";
			case LIBMCENV_ERROR_INTEGERVALUEATTRIBUTEOUTOFRANGE: return "Integer value attribute out of range.";
			case LIBMCENV_ERROR_INVALIDDOUBLEVALUEATTRIBUTE: return "Invalid double value attribute.";
			case LIBMCENV_ERROR_DOUBLEVALUEATTRIBUTEOUTOFRANGE: return "Double value attribute out of range.";
			case LIBMCENV_ERROR_INVALIDDEFAULTIMAGEVALUE: return "Invalid default image value.";
			case LIBMCENV_ERROR_INVALIDPIXELMEMORYSIZE: return "Invalid pixel memory size.";
			case LIBMCENV_ERROR_INVALIDFIELDBUFFER: return "Invalid field buffer.";
			case LIBMCENV_ERROR_INTERNALFIELDSIZEERROR: return "Internal field size error.";
			case LIBMCENV_ERROR_INVALIDFIELDSIZE: return "Invalid field size.";
			case LIBMCENV_ERROR_INVALIDFIELDSCALINGFACTOR: return "Invalid field scaling factor.";
			case LIBMCENV_ERROR_SCALINGEXCEEDSMAXIMUMPIXELCOUNT: return "Scaling exceeds maximum pixel count.";
			case LIBMCENV_ERROR_INTERNALSCALINGERROR: return "Internal scaling error.";
			case LIBMCENV_ERROR_INVALIDCOLORRANGE: return "Invalid color range.";
			case LIBMCENV_ERROR_EMPTYJOURNALVARIABLENAME: return "Empty journal variable name.";
			case LIBMCENV_ERROR_INVALIDJOURNALVARIABLEINTERVAL: return "Invalid journal variable interval.";
			case LIBMCENV_ERROR_JOURNALVARIABLENOTFOUND: return "Journal variable not found.";
			case LIBMCENV_ERROR_COMPUTATIONOUTSIDEOFJOURNALDATA: return "Computation outside of journal data.";
			case LIBMCENV_ERROR_INVALIDJOURNALCOMPUTEINTERVAL: return "Invalid Journal compute interval.";
			case LIBMCENV_ERROR_INVALIDJOURNALCOMPUTEDATA: return "Invalid Journal compute data.";
			case LIBMCENV_ERROR_INVALIDSEGMENTATTRIBUTETYPE: return "Invalid Segment Attribute Type.";
			case LIBMCENV_ERROR_SEGMENTATTRIBUTENOTFOUND: return "Segment Attribute not Found.";
			case LIBMCENV_ERROR_UNSUPPORTEDFIELDSAMPLINGMODE: return "Unsupported field sampling mode.";
			case LIBMCENV_ERROR_SAMPLEPOINTCOUNTEXCEEDSMAXIMUM: return "Sample point count exceeds maximum";
			case LIBMCENV_ERROR_INVALIDCLAMPINTERVAL: return "Invalid clamp interval";
			case LIBMCENV_ERROR_COULDNOTRETRIEVEPNGSTREAM: return "Could not retrieve PNG stream";
			case LIBMCENV_ERROR_COULDNOTSTOREFIELDDATA: return "Could not store field data";
			case LIBMCENV_ERROR_DISCRETEFIELDDATANOTFOUND: return "Discrete field data not found";
			case LIBMCENV_ERROR_EMPTYUSERLOGIN: return "Empty user login";
			case LIBMCENV_ERROR_INVALIDUSERLOGIN: return "Invalid user login";
			case LIBMCENV_ERROR_EMPTYPERMISSIONIDENTIFIER: return "Empty permission identifier";
			case LIBMCENV_ERROR_INVALIDPERMISSIONIDENTIFIER: return "Invalid permission identifier";
			case LIBMCENV_ERROR_EMPTYUSERROLE: return "Empty user role";
			case LIBMCENV_ERROR_INVALIDUSERROLE: return "Invalid user role";
			case LIBMCENV_ERROR_EMPTYUSERLANGUAGE: return "Empty user language";
			case LIBMCENV_ERROR_INVALIDUSERLANGUAGE: return "Invalid user language";
			case LIBMCENV_ERROR_ORIGINOUTOFRANGE: return "Origin out of range";
			case LIBMCENV_ERROR_RAWPIXELDATASIZEMISMATCH: return "Raw pixel data size mismatch";
			case LIBMCENV_ERROR_EMPTYPNGSTREAM: return "Empty PNG Stream";
			case LIBMCENV_ERROR_COULDNOTLOADPNGIMAGE: return "Could not load PNG image";
			case LIBMCENV_ERROR_INVALIDPIXELSIZE: return "Invalid pixel size";
			case LIBMCENV_ERROR_MESHISNOTREGISTERED: return "Mesh is not registered";
			case LIBMCENV_ERROR_INVALIDUSERINDEX: return "Invalid user index";
			case LIBMCENV_ERROR_DATASERIESTIMESTAMPSNOTINCREMENTING: return "Data series time stamps not incrementing";
			case LIBMCENV_ERROR_INVALIDNUMBEROFSAMPLES: return "Invalid number of samples";
			case LIBMCENV_ERROR_EMPTYALERTIDENTIFIER: return "Empty alert identifier";
			case LIBMCENV_ERROR_INVALIDALERTIDENTIFIER: return "Invalid alert identifier";
			case LIBMCENV_ERROR_ALERTNOTFOUND: return "Alert not found.";
			case LIBMCENV_ERROR_USERDOESNOTEXIST: return "User does not exist.";
			case LIBMCENV_ERROR_EMPTYSHA256SOURCE: return "Empty SHA256 Source.";
			case LIBMCENV_ERROR_ALERTHASNOUSERCONTEXT: return "Alert has no user context.";
			case LIBMCENV_ERROR_EMPTYJOURNALSTREAMNAME: return "Empty journal stream name.";
			case LIBMCENV_ERROR_EMPTYJOURNALSTREAMMIMETYPE: return "Empty journal stream mime type.";
			case LIBMCENV_ERROR_INVALIDSTREAMREADCALLBACK: return "Invalid stream read callback.";
			case LIBMCENV_ERROR_INVALIDSTREAMSEEKCALLBACK: return "Invalid stream seek callback.";
			case LIBMCENV_ERROR_INVALIDSTREAMCALLBACKUSERDATA: return "Invalid stream callback user data.";
			case LIBMCENV_ERROR_STREAMREADEXCEEDSSTREAMSIZE: return "Stream read exceeds stream size.";
			case LIBMCENV_ERROR_INVALIDSTREAMREADSIZE: return "Invalid stream read size.";
			case LIBMCENV_ERROR_INVALIDSTREAMSEEKPOSITION: return "Invalid stream seek position.";
			case LIBMCENV_ERROR_STORAGESTREAMNOTFOUND: return "Storage Stream not found.";
			case LIBMCENV_ERROR_DOWNLOADSTREAMDOESNOTEXIST: return "Download stream does not exist.";
			case LIBMCENV_ERROR_EMPTYDOWNLOADSTREAMFILENAME: return "Empty download stream filename.";
			case LIBMCENV_ERROR_INVALIDDOWNLOADSTREAMFILENAME: return "Invalid download stream filename.";
			case LIBMCENV_ERROR_USERISNOTAUTHORIZED: return "User is not authorized.";
			case LIBMCENV_ERROR_INVALIDMETADATAKEY: return "Invalid Metadata Key.";
			case LIBMCENV_ERROR_CANNOTCHANGESTATUSOFBUILDEXECUTION: return "Can not change status of build execution.";
			case LIBMCENV_ERROR_BUILDEXECUTIONHASNOATTACHEDUSER: return "Build execution has no attached user.";
			case LIBMCENV_ERROR_UNITSAREOUTOFRANGE: return "Units are out of range.";
			case LIBMCENV_ERROR_COLUMNIDENTIFIEREMPTY: return "Column identifier is empty.";
			case LIBMCENV_ERROR_INVALIDCOLUMNIDENTIFIER: return "Invalid column identifier.";
			case LIBMCENV_ERROR_DUPLICATECOLUMNIDENTIFIER: return "Duplicate column identifier.";
			case LIBMCENV_ERROR_INVALIDCOLUMNDATATYPE: return "Invalid column data type.";
			case LIBMCENV_ERROR_DATATABLEHASTOOMANYCOLUMS: return "Data table has too many columns.";
			case LIBMCENV_ERROR_COLUMNIDENTIFIERNOTFOUND: return "Column identifier not found.";
			case LIBMCENV_ERROR_INVALIDCOLUMNINDEX: return "Invalid column index.";
			case LIBMCENV_ERROR_COLUMNBUFFERISNULL: return "Column buffer is null.";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEDOUBLE: return "Column is not of type double.";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEUINT32: return "Column is not of type uint32.";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEUINT64: return "Column is not of type uint64.";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEINT32: return "Column is not of type int32.";
			case LIBMCENV_ERROR_COLUMNISNOTOFTYPEINT64: return "Column is not of type int64";
			case LIBMCENV_ERROR_INVALIDCSVSEPARATOR: return "Invalid CSV Separator";
			case LIBMCENV_ERROR_DATATABLECSVBUFFEROVERFLOW: return "Data Table CSV buffer overflow";
			case LIBMCENV_ERROR_DATETIMEDIFFERENCEISINVALID: return "Date Time difference is invalid";
			case LIBMCENV_ERROR_DATETIMEISINVALID: return "Date Time is invalid";
			case LIBMCENV_ERROR_DATETIMEOUTOFBOUNDS: return "Date Time out of bounds";
			case LIBMCENV_ERROR_EMPTYPNGBUFFER: return "Empty PNG buffer";
			case LIBMCENV_ERROR_CANNOTSEEKZIPSTREAM: return "Cannot seek ZIP stream";
			case LIBMCENV_ERROR_GLOBALTIMERNOTCONTINUOUS: return "Global Timer is not continuous.";
			case LIBMCENV_ERROR_STREAMWRITERISNOTFINISHED: return "Stream writer is not finished";
			case LIBMCENV_ERROR_CANNOTREADFROMZIPSTREAM: return "Cannot read from ZIP stream";
			case LIBMCENV_ERROR_EMPTYDATATABLENAME: return "Empty datatable name";
			case LIBMCENV_ERROR_EMPTYDATATABLEIDENTIFIER: return "Empty datatable identifier";
			case LIBMCENV_ERROR_INVALIDDATATABLEIDENTIFIER: return "Invalid datatable identifier";
			case LIBMCENV_ERROR_INVALIDDATATABLESIGNATURE: return "Invalid datatable signature";
			case LIBMCENV_ERROR_INVALIDSUPPORTINDEX: return "Invalid support index";
			case LIBMCENV_ERROR_INVALIDSOLIDINDEX: return "Invalid solid index";
			case LIBMCENV_ERROR_INVALIDCOMPONENTINDEX: return "Invalid component index";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCEnvInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCEnvResult nResult);

	inline void GetVersion(LibMCEnv_uint32 & nMajor, LibMCEnv_uint32 & nMinor, LibMCEnv_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline LibMCEnv_pvoid GetSymbolLookupMethod();

private:
	sLibMCEnvDynamicWrapperTable m_WrapperTable;
	
	LibMCEnvResult checkBinaryVersion()
	{
		LibMCEnv_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCENV_VERSION_MAJOR) {
			return LIBMCENV_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCENV_SUCCESS;
	}
	LibMCEnvResult initWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable);
	LibMCEnvResult releaseWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable);
	LibMCEnvResult loadWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCEnvResult loadWrapperTableFromSymbolLookupMethod(sLibMCEnvDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CIterator;
	friend class CTestEnvironment;
	friend class CCryptoContext;
	friend class CPNGImageStoreOptions;
	friend class CPNGImageData;
	friend class CImageData;
	friend class CDiscreteFieldData2DStoreOptions;
	friend class CDiscreteFieldData2D;
	friend class CDataTableWriteOptions;
	friend class CDataTableCSVWriteOptions;
	friend class CDataTable;
	friend class CDataSeries;
	friend class CDateTimeDifference;
	friend class CDateTime;
	friend class CMeshObject;
	friend class CPersistentMeshObject;
	friend class CModelDataMeshInstance;
	friend class CModelDataComponentInstance;
	friend class CMeshSceneItem;
	friend class CMeshScene;
	friend class CSceneHandler;
	friend class CToolpathPart;
	friend class CToolpathLayer;
	friend class CToolpathAccessor;
	friend class CBuildExecution;
	friend class CBuildExecutionIterator;
	friend class CBuild;
	friend class CWorkingFileExecution;
	friend class CWorkingFile;
	friend class CWorkingFileIterator;
	friend class CWorkingDirectory;
	friend class CXMLDocumentAttribute;
	friend class CXMLDocumentNode;
	friend class CXMLDocumentNodes;
	friend class CXMLDocument;
	friend class CTCPIPPacket;
	friend class CTCPIPConnection;
	friend class CModbusTCPDigitalIOStatus;
	friend class CModbusTCPRegisterStatus;
	friend class CModbusTCPConnection;
	friend class CDriverStatusUpdateSession;
	friend class CDriverEnvironment;
	friend class CSignalTrigger;
	friend class CSignalHandler;
	friend class CBaseTempStreamWriter;
	friend class CTempStreamWriter;
	friend class CZIPStreamWriter;
	friend class CStreamReader;
	friend class CUniformJournalSampling;
	friend class CJournalVariable;
	friend class CAlert;
	friend class CAlertIterator;
	friend class CLogEntryList;
	friend class CJournalHandler;
	friend class CUserDetailList;
	friend class CUserManagementHandler;
	friend class CStateEnvironment;
	friend class CUIItem;
	friend class CUIEnvironment;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCEnvHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCEnvResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCEnvHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCEnvHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CIterator 
**************************************************************************************************************************/
class CIterator : public CBase {
public:
	
	/**
	* CIterator::CIterator - Constructor for Iterator class.
	*/
	CIterator(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MoveNext();
	inline bool MovePrevious();
	inline PBase GetCurrent();
	inline PIterator Clone();
	inline LibMCEnv_uint64 Count();
};
	
/*************************************************************************************************************************
 Class CTestEnvironment 
**************************************************************************************************************************/
class CTestEnvironment : public CBase {
public:
	
	/**
	* CTestEnvironment::CTestEnvironment - Constructor for TestEnvironment class.
	*/
	CTestEnvironment(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void WriteTestOutput(const std::string & sOutputName, const CInputVector<LibMCEnv_uint8> & DataBuffer);
};
	
/*************************************************************************************************************************
 Class CCryptoContext 
**************************************************************************************************************************/
class CCryptoContext : public CBase {
public:
	
	/**
	* CCryptoContext::CCryptoContext - Constructor for CryptoContext class.
	*/
	CCryptoContext(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string CalculateSHA256FromString(const std::string & sValue);
	inline std::string CalculateSHA256FromBytes(const CInputVector<LibMCEnv_uint8> & ValueBuffer);
	inline std::string NormalizeSHA256String(const std::string & sValue);
	inline std::string CreateRandomSHA256Hash();
	inline std::string CreateUUID();
	inline std::string NormalizeUUIDString(const std::string & sValue);
};
	
/*************************************************************************************************************************
 Class CPNGImageStoreOptions 
**************************************************************************************************************************/
class CPNGImageStoreOptions : public CBase {
public:
	
	/**
	* CPNGImageStoreOptions::CPNGImageStoreOptions - Constructor for PNGImageStoreOptions class.
	*/
	CPNGImageStoreOptions(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void ResetToDefaults();
};
	
/*************************************************************************************************************************
 Class CPNGImageData 
**************************************************************************************************************************/
class CPNGImageData : public CBase {
public:
	
	/**
	* CPNGImageData::CPNGImageData - Constructor for PNGImageData class.
	*/
	CPNGImageData(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY);
	inline void GetPNGDataStream(std::vector<LibMCEnv_uint8> & PNGDataBuffer);
};
	
/*************************************************************************************************************************
 Class CImageData 
**************************************************************************************************************************/
class CImageData : public CBase {
public:
	
	/**
	* CImageData::CImageData - Constructor for ImageData class.
	*/
	CImageData(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline eImagePixelFormat GetPixelFormat();
	inline void ChangePixelFormat(const eImagePixelFormat ePixelFormat);
	inline void GetDPI(LibMCEnv_double & dDPIValueX, LibMCEnv_double & dDPIValueY);
	inline void SetDPI(const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY);
	inline void GetSizeInMM(LibMCEnv_double & dSizeX, LibMCEnv_double & dSizeY);
	inline void GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY);
	inline void ResizeImage(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY);
	inline PPNGImageData CreatePNGImage(classParam<CPNGImageStoreOptions> pPNGStorageOptions);
	inline void EncodePNG();
	inline void GetEncodedPNGData(std::vector<LibMCEnv_uint8> & PNGDataBuffer);
	inline void ClearEncodedPNGData();
	inline void Clear(const LibMCEnv_uint32 nValue);
	inline LibMCEnv_uint32 GetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY);
	inline void SetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY, const LibMCEnv_uint32 nValue);
	inline void GetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, std::vector<LibMCEnv_uint8> & ValueBuffer);
	inline void SetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, const CInputVector<LibMCEnv_uint8> & ValueBuffer);
};
	
/*************************************************************************************************************************
 Class CDiscreteFieldData2DStoreOptions 
**************************************************************************************************************************/
class CDiscreteFieldData2DStoreOptions : public CBase {
public:
	
	/**
	* CDiscreteFieldData2DStoreOptions::CDiscreteFieldData2DStoreOptions - Constructor for DiscreteFieldData2DStoreOptions class.
	*/
	CDiscreteFieldData2DStoreOptions(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void ResetToDefaults();
};
	
/*************************************************************************************************************************
 Class CDiscreteFieldData2D 
**************************************************************************************************************************/
class CDiscreteFieldData2D : public CBase {
public:
	
	/**
	* CDiscreteFieldData2D::CDiscreteFieldData2D - Constructor for DiscreteFieldData2D class.
	*/
	CDiscreteFieldData2D(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void GetDPI(LibMCEnv_double & dDPIValueX, LibMCEnv_double & dDPIValueY);
	inline void SetDPI(const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY);
	inline void GetOriginInMM(LibMCEnv_double & dOriginX, LibMCEnv_double & dOriginY);
	inline void SetOriginInMM(const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY);
	inline void GetSizeInMM(LibMCEnv_double & dSizeX, LibMCEnv_double & dSizeY);
	inline void GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY);
	inline void ResizeField(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDefaultValue);
	inline void Clear(const LibMCEnv_double dValue);
	inline void Clamp(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue);
	inline LibMCEnv_double GetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY);
	inline void SetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY, const LibMCEnv_double dValue);
	inline void GetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, std::vector<LibMCEnv_double> & ValueBuffer);
	inline void SetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, const CInputVector<LibMCEnv_double> & ValueBuffer);
	inline void RenderAveragePointValues(const LibMCEnv_double dDefaultValue, const eFieldSamplingMode eSamplingMode, const LibMCEnv_double dSampleSizeX, const LibMCEnv_double dSampleSizeY, const CInputVector<sFieldData2DPoint> & PointValuesBuffer);
	inline PDiscreteFieldData2D ScaleFieldDown(const LibMCEnv_uint32 nFactorX, const LibMCEnv_uint32 nFactorY);
	inline PDiscreteFieldData2D ScaleFieldUp(const LibMCEnv_uint32 nFactorX, const LibMCEnv_uint32 nFactorY);
	inline void Discretize(const CInputVector<LibMCEnv_double> & DiscreteValuesBuffer);
	inline void DiscretizeWithMapping(const CInputVector<LibMCEnv_double> & DiscreteValuesBuffer, const CInputVector<LibMCEnv_double> & NewValuesBuffer);
	inline PImageData RenderToImageRaw(const LibMCEnv_double dMinValue, const sColorRGB & MinColor, const LibMCEnv_double dMidValue, const sColorRGB & MidColor, const LibMCEnv_double dMaxValue, const sColorRGB & MaxColor);
	inline void TransformField(const LibMCEnv_double dScale, const LibMCEnv_double dOffset);
	inline void AddField(classParam<CDiscreteFieldData2D> pOtherField, const LibMCEnv_double dScale, const LibMCEnv_double dOffset);
	inline PDiscreteFieldData2D Duplicate();
};
	
/*************************************************************************************************************************
 Class CDataTableWriteOptions 
**************************************************************************************************************************/
class CDataTableWriteOptions : public CBase {
public:
	
	/**
	* CDataTableWriteOptions::CDataTableWriteOptions - Constructor for DataTableWriteOptions class.
	*/
	CDataTableWriteOptions(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
};
	
/*************************************************************************************************************************
 Class CDataTableCSVWriteOptions 
**************************************************************************************************************************/
class CDataTableCSVWriteOptions : public CBase {
public:
	
	/**
	* CDataTableCSVWriteOptions::CDataTableCSVWriteOptions - Constructor for DataTableCSVWriteOptions class.
	*/
	CDataTableCSVWriteOptions(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetSeparator();
	inline void SetSeparator(const std::string & sSeparator);
};
	
/*************************************************************************************************************************
 Class CDataTable 
**************************************************************************************************************************/
class CDataTable : public CBase {
public:
	
	/**
	* CDataTable::CDataTable - Constructor for DataTable class.
	*/
	CDataTable(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void AddColumn(const std::string & sIdentifier, const std::string & sDescription, const eDataTableColumnType eColumnType);
	inline void RemoveColumn(const std::string & sIdentifier);
	inline void Clear();
	inline bool HasColumn(const std::string & sIdentifier);
	inline LibMCEnv_uint32 GetRowCount();
	inline LibMCEnv_uint32 GetColumnCount();
	inline std::string GetColumnIdentifier(const LibMCEnv_uint32 nColumnIndex);
	inline std::string GetColumnDescription(const LibMCEnv_uint32 nColumnIndex);
	inline eDataTableColumnType GetColumnType(const LibMCEnv_uint32 nColumnIndex);
	inline void GetColumnInformation(const std::string & sIdentifier, std::string & sDescription, eDataTableColumnType & eColumnType);
	inline void GetDoubleColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_double> & ValuesBuffer);
	inline void GetInt32ColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_int32> & ValuesBuffer);
	inline void GetInt64ColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_int64> & ValuesBuffer);
	inline void GetUint32ColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_uint32> & ValuesBuffer);
	inline void GetUint64ColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_uint64> & ValuesBuffer);
	inline void SetDoubleColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_double> & ValuesBuffer);
	inline void SetInt32ColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_int32> & ValuesBuffer);
	inline void SetInt64ColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_int64> & ValuesBuffer);
	inline void SetUint32ColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_uint32> & ValuesBuffer);
	inline void SetUint64ColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_uint64> & ValuesBuffer);
	inline PDataTableWriteOptions CreateWriteOptions();
	inline PDataTableCSVWriteOptions CreateCSVWriteOptions();
	inline void WriteCSVToStream(classParam<CTempStreamWriter> pWriter, classParam<CDataTableCSVWriteOptions> pOptions);
	inline void WriteDataToStream(classParam<CTempStreamWriter> pWriter, classParam<CDataTableWriteOptions> pOptions);
	inline void LoadFromStream(classParam<CStreamReader> pStream);
};
	
/*************************************************************************************************************************
 Class CDataSeries 
**************************************************************************************************************************/
class CDataSeries : public CBase {
public:
	
	/**
	* CDataSeries::CDataSeries - Constructor for DataSeries class.
	*/
	CDataSeries(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetUUID();
	inline void Clear();
	inline bool IsEmpty();
	inline LibMCEnv_uint64 GetMinimum();
	inline LibMCEnv_uint64 GetMaximum();
	inline void GetAllEntries(std::vector<sTimeStreamEntry> & EntryArrayBuffer);
	inline void SetAllEntries(const CInputVector<sTimeStreamEntry> & EntryArrayBuffer);
	inline void SampleJournalVariable(classParam<CJournalVariable> pJournalVariable, const LibMCEnv_uint32 nNumberOfSamples, const LibMCEnv_double dMovingAverageDelta);
	inline LibMCEnv_uint32 GetVersion();
	inline void IncreaseVersion();
};
	
/*************************************************************************************************************************
 Class CDateTimeDifference 
**************************************************************************************************************************/
class CDateTimeDifference : public CBase {
public:
	
	/**
	* CDateTimeDifference::CDateTimeDifference - Constructor for DateTimeDifference class.
	*/
	CDateTimeDifference(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCEnv_uint64 ToMicroseconds();
	inline LibMCEnv_uint64 ToMilliseconds();
	inline LibMCEnv_uint64 ToSeconds();
	inline LibMCEnv_uint64 ToMinutes();
	inline LibMCEnv_uint64 ToHours();
	inline LibMCEnv_uint64 ToDays();
	inline void RoundDownToDay();
	inline void RoundDownToHour();
	inline void RoundDownToMinute();
	inline void RoundDownToSeconds();
	inline void RoundDownToMilliseconds();
	inline void RoundUpToDay();
	inline void RoundUpToHour();
	inline void RoundUpToMinute();
	inline void RoundUpToSeconds();
	inline void RoundupToMilliseconds();
};
	
/*************************************************************************************************************************
 Class CDateTime 
**************************************************************************************************************************/
class CDateTime : public CBase {
public:
	
	/**
	* CDateTime::CDateTime - Constructor for DateTime class.
	*/
	CDateTime(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCEnv_uint64 ToMicrosecondsSince1970();
	inline LibMCEnv_uint64 ToUnixTimestamp();
	inline std::string ToUTCDateTime();
	inline std::string ToUTCDateTimeInMilliseconds();
	inline std::string ToUTCDateTimeInMicroseconds();
	inline void GetDate(LibMCEnv_uint32 & nYear, LibMCEnv_uint32 & nMonth, LibMCEnv_uint32 & nDay);
	inline void GetTime(LibMCEnv_uint32 & nHour, LibMCEnv_uint32 & nMinute, LibMCEnv_uint32 & nSecond, LibMCEnv_uint32 & nMicrosecond);
	inline PDateTime Duplicate();
	inline bool IsLeapYear();
	inline bool IsLaterThan(classParam<CDateTime> pOtherTimeStamp);
	inline bool IsEarlierThan(classParam<CDateTime> pOtherTimeStamp);
	inline bool IsEqualTo(classParam<CDateTime> pOtherTimeStamp);
	inline PDateTimeDifference GetTimeDifference(classParam<CDateTime> pOtherTimeStamp);
	inline void AddDuration(classParam<CDateTimeDifference> pDuration);
	inline void SubtractDuration(classParam<CDateTimeDifference> pDuration);
	inline void ShiftByYears(const LibMCEnv_int64 nDeltaYears);
	inline void ShiftByDays(const LibMCEnv_int64 nDeltaDays);
	inline void ShiftByHours(const LibMCEnv_int64 nDeltaHours);
	inline void ShiftByMinutes(const LibMCEnv_int64 nDeltaMinutes);
	inline void ShiftBySeconds(const LibMCEnv_int64 nDeltaSeconds);
	inline void ShiftByMilliseconds(const LibMCEnv_int64 nDeltaMilliseconds);
	inline void ShiftByMicroseconds(const LibMCEnv_int64 nDeltaMicroseconds);
	inline void RoundDownToYear();
	inline void RoundDownToMonth();
	inline void RoundDownToDay();
	inline void RoundDownToHour();
	inline void RoundDownToMinute();
	inline void RoundDownToSeconds();
	inline void RoundDownToMilliseconds();
	inline void RoundUpToYear();
	inline void RoundUpToMonth();
	inline void RoundUpToDay();
	inline void RoundUpToHour();
	inline void RoundUpToMinute();
	inline void RoundUpToSeconds();
	inline void RoundUpToMilliseconds();
};
	
/*************************************************************************************************************************
 Class CMeshObject 
**************************************************************************************************************************/
class CMeshObject : public CBase {
public:
	
	/**
	* CMeshObject::CMeshObject - Constructor for MeshObject class.
	*/
	CMeshObject(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetUUID();
	inline LibMCEnv_uint32 GetTriangleCount();
	inline LibMCEnv_uint32 GetVertexCount();
	inline bool IsManifold();
	inline bool IsOriented();
	inline bool IsWatertight();
	inline LibMCEnv_uint32 GetMaxVertexID();
	inline bool VertexExists(const LibMCEnv_uint32 nVertexID);
	inline bool GetVertex(const LibMCEnv_uint32 nVertexID, LibMCEnv_double & dX, LibMCEnv_double & dY, LibMCEnv_double & dZ);
	inline void GetVertexIDs(std::vector<LibMCEnv_uint32> & VertexIDsBuffer);
	inline void GetAllVertices(std::vector<sMeshVertex3D> & VerticesBuffer);
	inline LibMCEnv_uint32 GetMaxTriangleID();
	inline bool TriangeExists(const LibMCEnv_uint32 nTriangleID);
	inline bool GetTriangle(const LibMCEnv_uint32 nTriangleID, LibMCEnv_uint32 & nVertex1ID, LibMCEnv_uint32 & nVertex2ID, LibMCEnv_uint32 & nVertex3ID);
	inline void GetTriangleIDs(std::vector<LibMCEnv_uint32> & TriangleIDsBuffer);
	inline void GetAllTriangles(std::vector<sMeshTriangle3D> & TrianglesBuffer);
	inline bool IsPersistent();
	inline PPersistentMeshObject MakePersistent(const bool bBoundToLoginSession);
};
	
/*************************************************************************************************************************
 Class CPersistentMeshObject 
**************************************************************************************************************************/
class CPersistentMeshObject : public CMeshObject {
public:
	
	/**
	* CPersistentMeshObject::CPersistentMeshObject - Constructor for PersistentMeshObject class.
	*/
	CPersistentMeshObject(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CMeshObject(pWrapper, pHandle)
	{
	}
	
	inline bool IsBoundToLoginSession();
};
	
/*************************************************************************************************************************
 Class CModelDataMeshInstance 
**************************************************************************************************************************/
class CModelDataMeshInstance : public CBase {
public:
	
	/**
	* CModelDataMeshInstance::CModelDataMeshInstance - Constructor for ModelDataMeshInstance class.
	*/
	CModelDataMeshInstance(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetUUID();
	inline sModelDataTransform GetLocalTransform();
	inline sModelDataTransform GetAbsoluteTransform();
	inline PMeshObject CreateCopiedMesh();
	inline PPersistentMeshObject CreatePersistentMesh(const bool bBoundToLoginSession);
};
	
/*************************************************************************************************************************
 Class CModelDataComponentInstance 
**************************************************************************************************************************/
class CModelDataComponentInstance : public CBase {
public:
	
	/**
	* CModelDataComponentInstance::CModelDataComponentInstance - Constructor for ModelDataComponentInstance class.
	*/
	CModelDataComponentInstance(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetUUID();
	inline sModelDataTransform GetLocalTransform();
	inline sModelDataTransform GetAbsoluteTransform();
	inline LibMCEnv_uint32 GetSolidCount();
	inline PModelDataMeshInstance GetSolidMesh(const LibMCEnv_uint32 nIndex);
	inline LibMCEnv_uint32 GetSupportCount();
	inline PModelDataMeshInstance GetSupportMesh(const LibMCEnv_uint32 nIndex);
	inline LibMCEnv_uint32 GetSubComponentCount();
	inline PModelDataComponentInstance GetSubComponent(const LibMCEnv_uint32 nIndex);
};
	
/*************************************************************************************************************************
 Class CMeshSceneItem 
**************************************************************************************************************************/
class CMeshSceneItem : public CBase {
public:
	
	/**
	* CMeshSceneItem::CMeshSceneItem - Constructor for MeshSceneItem class.
	*/
	CMeshSceneItem(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetItemUUID();
	inline std::string GetSceneUUID();
	inline sModelDataTransform GetTransform();
	inline void UpdateTransform(const sModelDataTransform & AbsoluteTransform);
	inline PPersistentMeshObject GetMeshObject();
	inline bool ReferenceIsValid();
};
	
/*************************************************************************************************************************
 Class CMeshScene 
**************************************************************************************************************************/
class CMeshScene : public CBase {
public:
	
	/**
	* CMeshScene::CMeshScene - Constructor for MeshScene class.
	*/
	CMeshScene(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetSceneUUID();
	inline bool IsBoundToLoginSession();
	inline PMeshSceneItem AddSceneItem(classParam<CPersistentMeshObject> pMesh, const sModelDataTransform & AbsoluteTransform);
	inline PMeshSceneItem AddModelDataMeshAsSceneItem(classParam<CModelDataMeshInstance> pModelDataMesh);
	inline LibMCEnv_uint32 GetSceneItemCount();
	inline PMeshSceneItem GetSceneItem(const LibMCEnv_uint32 nIndex);
	inline PMeshSceneItem FindSceneItem(const std::string & sUUID, const bool bMustExist);
	inline bool HasSceneItem(const std::string & sUUID);
	inline void RemoveSceneItem(classParam<CMeshSceneItem> pSceneItem);
};
	
/*************************************************************************************************************************
 Class CSceneHandler 
**************************************************************************************************************************/
class CSceneHandler : public CBase {
public:
	
	/**
	* CSceneHandler::CSceneHandler - Constructor for SceneHandler class.
	*/
	CSceneHandler(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MeshIsPersistent(const std::string & sMeshUUID);
	inline PPersistentMeshObject FindPersistentMesh(const std::string & sMeshUUID);
	inline PMeshScene CreateEmptyMeshScene(const std::string & sUUID, const bool bBoundToLoginSession);
	inline PMeshScene ReleaseMeshScene();
	inline PModelDataComponentInstance Load3MFFromResource(const std::string & sResourceName);
	inline PModelDataComponentInstance Load3MFFromMemory(const CInputVector<LibMCEnv_uint8> & DataBuffer);
	inline PModelDataComponentInstance Load3MFFromStream(classParam<CStreamReader> pReaderInstance);
};
	
/*************************************************************************************************************************
 Class CToolpathPart 
**************************************************************************************************************************/
class CToolpathPart : public CBase {
public:
	
	/**
	* CToolpathPart::CToolpathPart - Constructor for ToolpathPart class.
	*/
	CToolpathPart(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetUUID();
	inline PModelDataComponentInstance GetRootComponent();
};
	
/*************************************************************************************************************************
 Class CToolpathLayer 
**************************************************************************************************************************/
class CToolpathLayer : public CBase {
public:
	
	/**
	* CToolpathLayer::CToolpathLayer - Constructor for ToolpathLayer class.
	*/
	CToolpathLayer(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetLayerDataUUID();
	inline LibMCEnv_uint32 GetSegmentCount();
	inline void GetSegmentInfo(const LibMCEnv_uint32 nIndex, eToolpathSegmentType & eType, LibMCEnv_uint32 & nPointCount);
	inline eToolpathSegmentType GetSegmentType(const LibMCEnv_uint32 nIndex);
	inline bool SegmentIsLoop(const LibMCEnv_uint32 nIndex);
	inline bool SegmentIsPolyline(const LibMCEnv_uint32 nIndex);
	inline bool SegmentIsHatchSegment(const LibMCEnv_uint32 nIndex);
	inline LibMCEnv_int64 GetSegmentIntegerAttribute(const LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nAttributeID);
	inline LibMCEnv_double GetSegmentDoubleAttribute(const LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nAttributeID);
	inline bool HasCustomSegmentAttribute(const std::string & sNamespace, const std::string & sAttributeName);
	inline LibMCEnv_uint32 FindCustomSegmentAttributeID(const std::string & sNamespace, const std::string & sAttributeName);
	inline eToolpathAttributeType FindCustomSegmentAttributeType(const std::string & sNamespace, const std::string & sAttributeName);
	inline void FindCustomSegmentAttributeInfo(const std::string & sNamespace, const std::string & sAttributeName, LibMCEnv_uint32 & nAttributeID, eToolpathAttributeType & eAttributeType);
	inline LibMCEnv_uint32 GetSegmentPointCount(const LibMCEnv_uint32 nIndex);
	inline LibMCEnv_uint32 GetSegmentHatchCount(const LibMCEnv_uint32 nIndex);
	inline std::string GetSegmentProfileUUID(const LibMCEnv_uint32 nIndex);
	inline bool SegmentProfileHasValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName);
	inline std::string GetSegmentProfileValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName);
	inline std::string GetSegmentProfileValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const std::string & sDefaultValue);
	inline LibMCEnv_double GetSegmentProfileDoubleValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName);
	inline LibMCEnv_double GetSegmentProfileDoubleValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const LibMCEnv_double dDefaultValue);
	inline LibMCEnv_int64 GetSegmentProfileIntegerValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName);
	inline LibMCEnv_int64 GetSegmentProfileIntegerValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const LibMCEnv_int64 nDefaultValue);
	inline bool GetSegmentProfileBoolValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName);
	inline bool GetSegmentProfileBoolValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const bool bDefaultValue);
	inline LibMCEnv_double GetSegmentProfileTypedValue(const LibMCEnv_uint32 nIndex, const eToolpathProfileValueType eValueType);
	inline LibMCEnv_double GetSegmentProfileTypedValueDef(const LibMCEnv_uint32 nIndex, const eToolpathProfileValueType eValueType, const LibMCEnv_double dDefaultValue);
	inline std::string GetSegmentPartUUID(const LibMCEnv_uint32 nIndex);
	inline void GetSegmentPointData(const LibMCEnv_uint32 nIndex, std::vector<sPosition2D> & PointDataBuffer);
	inline void GetSegmentHatchData(const LibMCEnv_uint32 nIndex, std::vector<sHatch2D> & HatchDataBuffer);
	inline void GetSegmentPointDataInMM(const LibMCEnv_uint32 nIndex, std::vector<sFloatPosition2D> & PointDataBuffer);
	inline void GetSegmentHatchDataInMM(const LibMCEnv_uint32 nIndex, std::vector<sFloatHatch2D> & HatchDataBuffer);
	inline LibMCEnv_int32 GetZValue();
	inline LibMCEnv_double GetZValueInMM();
	inline LibMCEnv_double GetUnits();
	inline LibMCEnv_uint32 GetMetaDataCount();
	inline void GetMetaDataInfo(const LibMCEnv_uint32 nMetaDataIndex, std::string & sNamespace, std::string & sName);
	inline PXMLDocumentNode GetMetaDataContent(const LibMCEnv_uint32 nMetaDataIndex);
	inline bool HasUniqueMetaData(const std::string & sNamespace, const std::string & sName);
	inline PXMLDocumentNode FindUniqueMetaData(const std::string & sNamespace, const std::string & sName);
	inline void CalculateExtents(LibMCEnv_int32 & nMinX, LibMCEnv_int32 & nMinY, LibMCEnv_int32 & nMaxX, LibMCEnv_int32 & nMaxY);
	inline void CalculateExtentsInMM(LibMCEnv_double & dMinX, LibMCEnv_double & dMinY, LibMCEnv_double & dMaxX, LibMCEnv_double & dMaxY);
};
	
/*************************************************************************************************************************
 Class CToolpathAccessor 
**************************************************************************************************************************/
class CToolpathAccessor : public CBase {
public:
	
	/**
	* CToolpathAccessor::CToolpathAccessor - Constructor for ToolpathAccessor class.
	*/
	CToolpathAccessor(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetStorageUUID();
	inline std::string GetBuildUUID();
	inline LibMCEnv_uint32 GetLayerCount();
	inline void RegisterCustomSegmentAttribute(const std::string & sNameSpace, const std::string & sAttributeName, const eToolpathAttributeType eAttributeType);
	inline PToolpathLayer LoadLayer(const LibMCEnv_uint32 nLayerIndex);
	inline LibMCEnv_double GetUnits();
	inline LibMCEnv_uint32 GetPartCount();
	inline PToolpathPart GetPart(const LibMCEnv_uint32 nPartIndex);
	inline PToolpathPart FindPartByUUID(const std::string & sPartUUID);
	inline LibMCEnv_int32 GetBuildHeightInUnits();
	inline LibMCEnv_int32 GetZValueInUnits(const LibMCEnv_uint32 nLayerIndex);
	inline LibMCEnv_double GetBuildHeightInMM();
	inline LibMCEnv_double GetZValueInMM(const LibMCEnv_uint32 nLayerIndex);
	inline LibMCEnv_uint32 GetMetaDataCount();
	inline void GetMetaDataInfo(const LibMCEnv_uint32 nMetaDataIndex, std::string & sNamespace, std::string & sName);
	inline PXMLDocumentNode GetMetaDataContent(const LibMCEnv_uint32 nMetaDataIndex);
	inline bool HasUniqueMetaData(const std::string & sNamespace, const std::string & sName);
	inline PXMLDocumentNode FindUniqueMetaData(const std::string & sNamespace, const std::string & sName);
};
	
/*************************************************************************************************************************
 Class CBuildExecution 
**************************************************************************************************************************/
class CBuildExecution : public CBase {
public:
	
	/**
	* CBuildExecution::CBuildExecution - Constructor for BuildExecution class.
	*/
	CBuildExecution(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetBuildUUID();
	inline PBuild GetBuild();
	inline eBuildExecutionStatus GetExecutionStatus();
	inline bool IsInProcess();
	inline bool IsFinished();
	inline bool IsFailed();
	inline void SetStatusToFinished();
	inline void SetStatusToFailed();
	inline std::string GetDescription();
	inline void SetDescription(const std::string & sDescription);
	inline std::string GetJournalUUID();
	inline bool HasAttachedUser();
	inline std::string GetUserUUID();
	inline LibMCEnv_uint64 GetStartTimeStampInMilliseconds();
	inline LibMCEnv_uint64 GetStartTimeStampInMicroseconds();
	inline LibMCEnv_uint64 GetEndTimeStampInMilliseconds();
	inline LibMCEnv_uint64 GetEndTimeStampInMicroseconds();
	inline LibMCEnv_uint64 GetElapsedTimeInMilliseconds();
	inline LibMCEnv_uint64 GetElapsedTimeInMicroseconds();
	inline bool HasAttachment(const std::string & sDataUUID);
	inline bool HasAttachmentIdentifier(const std::string & sIdentifier);
	inline std::string AddBinaryData(const std::string & sIdentifier, const std::string & sName, const std::string & sMIMEType, const std::string & sUserUUID, const CInputVector<LibMCEnv_uint8> & ContentBuffer);
	inline std::string AttachTempStream(const std::string & sIdentifier, const std::string & sName, const std::string & sUserUUID, classParam<CBaseTempStreamWriter> pStreamWriterInstance);
	inline PStreamReader LoadStreamByIdentifier(const std::string & sIdentifier);
	inline PStreamReader LoadStreamByUUID(const std::string & sDataUUID);
	inline PDiscreteFieldData2D LoadDiscreteField2DByIdentifier(const std::string & sIdentifier);
	inline PDiscreteFieldData2D LoadDiscreteField2DByUUID(const std::string & sDataUUID);
	inline std::string StoreDiscreteField2D(const std::string & sIdentifier, const std::string & sName, classParam<CDiscreteFieldData2D> pFieldDataInstance, classParam<CDiscreteFieldData2DStoreOptions> pStoreOptions, const std::string & sUserUUID);
	inline PDataTable LoadDataTableByIdentifier(const std::string & sIdentifier);
	inline PDataTable LoadDataTableByUUID(const std::string & sDataUUID);
	inline std::string StoreDataTable(const std::string & sIdentifier, const std::string & sName, classParam<CDataTable> pFieldDataInstance, classParam<CDataTableWriteOptions> pStoreOptions, const std::string & sUserUUID);
	inline PImageData LoadPNGImageByIdentifier(const std::string & sIdentifier, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline PImageData LoadPNGImageByUUID(const std::string & sDataUUID, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline std::string StorePNGImage(const std::string & sIdentifier, const std::string & sName, classParam<CImageData> pImageDataInstance, classParam<CPNGImageStoreOptions> pStoreOptions, const std::string & sUserUUID);
	inline void StoreMetaDataString(const std::string & sKey, const std::string & sValue);
	inline bool HasMetaDataString(const std::string & sKey);
	inline std::string GetMetaDataString(const std::string & sKey);
	inline PJournalHandler LoadAttachedJournal();
};
	
/*************************************************************************************************************************
 Class CBuildExecutionIterator 
**************************************************************************************************************************/
class CBuildExecutionIterator : public CIterator {
public:
	
	/**
	* CBuildExecutionIterator::CBuildExecutionIterator - Constructor for BuildExecutionIterator class.
	*/
	CBuildExecutionIterator(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildExecution GetCurrentExecution();
};
	
/*************************************************************************************************************************
 Class CBuild 
**************************************************************************************************************************/
class CBuild : public CBase {
public:
	
	/**
	* CBuild::CBuild - Constructor for Build class.
	*/
	CBuild(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetBuildUUID();
	inline std::string GetStorageUUID();
	inline std::string GetStorageSHA256();
	inline LibMCEnv_uint32 GetLayerCount();
	inline LibMCEnv_double GetBuildHeightInMM();
	inline LibMCEnv_double GetZValueInMM(const LibMCEnv_uint32 nLayerIndex);
	inline void LoadToolpath();
	inline void UnloadToolpath();
	inline bool ToolpathIsLoaded();
	inline PToolpathAccessor CreateToolpathAccessor();
	inline bool HasAttachment(const std::string & sDataUUID);
	inline bool HasAttachmentIdentifier(const std::string & sIdentifier);
	inline std::string AddBinaryData(const std::string & sIdentifier, const std::string & sName, const std::string & sMIMEType, const std::string & sUserUUID, const CInputVector<LibMCEnv_uint8> & ContentBuffer);
	inline std::string AttachTempStream(const std::string & sIdentifier, const std::string & sName, const std::string & sUserUUID, classParam<CBaseTempStreamWriter> pStreamWriterInstance);
	inline PStreamReader LoadStreamByIdentifier(const std::string & sIdentifier);
	inline PStreamReader LoadStreamByUUID(const std::string & sDataUUID);
	inline PDiscreteFieldData2D LoadDiscreteField2DByIdentifier(const std::string & sIdentifier);
	inline PDiscreteFieldData2D LoadDiscreteField2DByUUID(const std::string & sDataUUID);
	inline std::string StoreDiscreteField2D(const std::string & sIdentifier, const std::string & sName, classParam<CDiscreteFieldData2D> pFieldDataInstance, classParam<CDiscreteFieldData2DStoreOptions> pStoreOptions, const std::string & sUserUUID);
	inline PDataTable LoadDataTableByIdentifier(const std::string & sIdentifier);
	inline PDataTable LoadDataTableByUUID(const std::string & sDataUUID);
	inline std::string StoreDataTable(const std::string & sIdentifier, const std::string & sName, classParam<CDataTable> pDataTableInstance, classParam<CDataTableWriteOptions> pStoreOptions, const std::string & sUserUUID);
	inline PImageData LoadPNGImageByIdentifier(const std::string & sIdentifier, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline PImageData LoadPNGImageByUUID(const std::string & sDataUUID, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline std::string StorePNGImage(const std::string & sIdentifier, const std::string & sName, classParam<CImageData> pImageDataInstance, classParam<CPNGImageStoreOptions> pStoreOptions, const std::string & sUserUUID);
	inline PBuildExecution StartExecution(const std::string & sDescription, const std::string & sUserUUID);
	inline bool HasExecution(const std::string & sExecutionUUID);
	inline PBuildExecution FindExecution(const std::string & sExecutionUUID);
	inline PBuildExecutionIterator ListExecutions(const bool bOnlyCurrentJournalSession);
	inline PBuildExecutionIterator ListExecutionsByStatus(const eBuildExecutionStatus eExecutionStatus, const bool bOnlyCurrentJournalSession);
	inline void StoreMetaDataString(const std::string & sKey, const std::string & sValue);
	inline bool HasMetaDataString(const std::string & sKey);
	inline std::string GetMetaDataString(const std::string & sKey);
};
	
/*************************************************************************************************************************
 Class CWorkingFileExecution 
**************************************************************************************************************************/
class CWorkingFileExecution : public CBase {
public:
	
	/**
	* CWorkingFileExecution::CWorkingFileExecution - Constructor for WorkingFileExecution class.
	*/
	CWorkingFileExecution(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void GetStatus();
	inline std::string ReturnStdOut();
};
	
/*************************************************************************************************************************
 Class CWorkingFile 
**************************************************************************************************************************/
class CWorkingFile : public CBase {
public:
	
	/**
	* CWorkingFile::CWorkingFile - Constructor for WorkingFile class.
	*/
	CWorkingFile(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetAbsoluteFileName();
	inline LibMCEnv_uint64 GetSize();
	inline std::string CalculateSHA2();
	inline PWorkingFileExecution ExecuteFile();
	inline bool IsManaged();
	inline void MakeManaged();
	inline bool FileExists();
	inline bool DeleteFromDisk();
};
	
/*************************************************************************************************************************
 Class CWorkingFileIterator 
**************************************************************************************************************************/
class CWorkingFileIterator : public CIterator {
public:
	
	/**
	* CWorkingFileIterator::CWorkingFileIterator - Constructor for WorkingFileIterator class.
	*/
	CWorkingFileIterator(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PWorkingFile GetCurrentFile();
};
	
/*************************************************************************************************************************
 Class CWorkingDirectory 
**************************************************************************************************************************/
class CWorkingDirectory : public CBase {
public:
	
	/**
	* CWorkingDirectory::CWorkingDirectory - Constructor for WorkingDirectory class.
	*/
	CWorkingDirectory(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool IsActive();
	inline std::string GetAbsoluteFilePath();
	inline PWorkingFile StoreCustomData(const std::string & sFileName, const CInputVector<LibMCEnv_uint8> & DataBufferBuffer);
	inline PWorkingFile StoreCustomString(const std::string & sFileName, const std::string & sDataString);
	inline PWorkingFile StoreDriverData(const std::string & sFileName, const std::string & sIdentifier);
	inline PWorkingFile StoreCustomDataInTempFile(const std::string & sExtension, const CInputVector<LibMCEnv_uint8> & DataBufferBuffer);
	inline PWorkingFile StoreCustomStringInTempFile(const std::string & sExtension, const std::string & sDataString);
	inline PWorkingFile StoreDriverDataInTempFile(const std::string & sExtension, const std::string & sIdentifier);
	inline bool CleanUp();
	inline PWorkingFile AddManagedFile(const std::string & sFileName);
	inline bool HasUnmanagedFiles();
	inline PWorkingFileIterator RetrieveUnmanagedFiles();
	inline PWorkingFileIterator RetrieveManagedFiles();
	inline PWorkingFileIterator RetrieveAllFiles();
};
	
/*************************************************************************************************************************
 Class CXMLDocumentAttribute 
**************************************************************************************************************************/
class CXMLDocumentAttribute : public CBase {
public:
	
	/**
	* CXMLDocumentAttribute::CXMLDocumentAttribute - Constructor for XMLDocumentAttribute class.
	*/
	CXMLDocumentAttribute(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetNameSpace();
	inline std::string GetName();
	inline std::string GetValue();
	inline bool IsValidUUID();
	inline std::string GetUUIDValue();
	inline bool IsValidInteger(const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue);
	inline LibMCEnv_int64 GetIntegerValue(const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue);
	inline bool IsValidDouble(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue);
	inline LibMCEnv_double GetDoubleValue(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue);
	inline bool IsValidBool();
	inline bool GetBoolValue();
	inline void SetValue(const std::string & sValue);
	inline void SetUUIDValue(const std::string & sValue);
	inline void SetIntegerValue(const LibMCEnv_int64 nValue);
	inline void SetDoubleValue(const LibMCEnv_double dValue);
	inline void SetBoolValue(const bool bValue);
	inline void Remove();
};
	
/*************************************************************************************************************************
 Class CXMLDocumentNode 
**************************************************************************************************************************/
class CXMLDocumentNode : public CBase {
public:
	
	/**
	* CXMLDocumentNode::CXMLDocumentNode - Constructor for XMLDocumentNode class.
	*/
	CXMLDocumentNode(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetNameSpace();
	inline std::string GetTextContent();
	inline void SetTextContent(const std::string & sTextContent);
	inline LibMCEnv_uint64 GetAttributeCount();
	inline PXMLDocumentAttribute GetAttribute(const LibMCEnv_uint64 nIndex);
	inline bool HasAttribute(const std::string & sNameSpace, const std::string & sName);
	inline PXMLDocumentAttribute FindAttribute(const std::string & sNameSpace, const std::string & sName, const bool bMustExist);
	inline std::string GetAttributeValue(const std::string & sNameSpace, const std::string & sName);
	inline LibMCEnv_int64 GetAttributeIntegerValue(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue);
	inline LibMCEnv_double GetAttributeDoubleValue(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue);
	inline bool GetAttributeBoolValue(const std::string & sNameSpace, const std::string & sName);
	inline std::string GetAttributeUUIDValue(const std::string & sNameSpace, const std::string & sName);
	inline std::string GetAttributeValueDef(const std::string & sNameSpace, const std::string & sName, const std::string & sDefaultValue);
	inline LibMCEnv_int64 GetAttributeIntegerValueDef(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue, const LibMCEnv_int64 nDefaultValue);
	inline LibMCEnv_double GetAttributeDoubleValueDef(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue, const LibMCEnv_double dDefaultValue);
	inline bool GetAttributeBoolValueDef(const std::string & sNameSpace, const std::string & sName, const bool bDefaultValue);
	inline std::string GetAttributeUUIDValueDef(const std::string & sNameSpace, const std::string & sName, const std::string & sDefaultValue);
	inline void RemoveAttribute(const std::string & sNameSpace, const std::string & sName);
	inline void RemoveAttributeByIndex(const LibMCEnv_uint64 nIndex);
	inline void AddAttribute(const std::string & sNameSpace, const std::string & sName, const std::string & sValue);
	inline void AddIntegerAttribute(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nValue);
	inline void AddDoubleAttribute(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dValue);
	inline void AddBoolAttribute(const std::string & sNameSpace, const std::string & sName, const bool bValue);
	inline PXMLDocumentNodes GetChildren();
	inline LibMCEnv_uint64 CountChildrenByName(const std::string & sNameSpace, const std::string & sName);
	inline PXMLDocumentNodes GetChildrenByName(const std::string & sNameSpace, const std::string & sName);
	inline bool HasChild(const std::string & sNameSpace, const std::string & sName);
	inline bool HasUniqueChild(const std::string & sNameSpace, const std::string & sName);
	inline PXMLDocumentNode FindChild(const std::string & sNameSpace, const std::string & sName, const bool bMustExist);
	inline PXMLDocumentNode AddChild(const std::string & sNameSpace, const std::string & sName);
	inline PXMLDocumentNode AddChildText(const std::string & sNameSpace, const std::string & sName, const std::string & sTextContent);
	inline void RemoveChild(classParam<CXMLDocumentNode> pChildInstance);
	inline void RemoveChildrenWithName(const std::string & sNameSpace, const std::string & sName);
	inline void Remove();
};
	
/*************************************************************************************************************************
 Class CXMLDocumentNodes 
**************************************************************************************************************************/
class CXMLDocumentNodes : public CBase {
public:
	
	/**
	* CXMLDocumentNodes::CXMLDocumentNodes - Constructor for XMLDocumentNodes class.
	*/
	CXMLDocumentNodes(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCEnv_uint64 GetNodeCount();
	inline PXMLDocumentNode GetNode(const LibMCEnv_uint64 nIndex);
	inline LibMCEnv_uint64 CountNodesByName(const std::string & sNameSpace, const std::string & sName);
	inline PXMLDocumentNodes GetNodesByName(const std::string & sNameSpace, const std::string & sName);
	inline bool HasNode(const std::string & sNameSpace, const std::string & sName);
	inline bool HasUniqueNode(const std::string & sNameSpace, const std::string & sName);
	inline PXMLDocumentNode FindNode(const std::string & sNameSpace, const std::string & sName, const bool bMustExist);
};
	
/*************************************************************************************************************************
 Class CXMLDocument 
**************************************************************************************************************************/
class CXMLDocument : public CBase {
public:
	
	/**
	* CXMLDocument::CXMLDocument - Constructor for XMLDocument class.
	*/
	CXMLDocument(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetDefaultNamespace();
	inline LibMCEnv_uint64 GetNamespaceCount();
	inline void GetNamespace(const LibMCEnv_uint64 nIndex, std::string & sNamespace, std::string & sNamespacePrefix);
	inline bool HasNamespace(const std::string & sNamespace);
	inline std::string GetNamespacePrefix(const std::string & sNamespace);
	inline void RegisterNamespace(const std::string & sNamespace, const std::string & sNamespacePrefix);
	inline void ChangeNamespacePrefix(const std::string & sOldNamespacePrefix, const std::string & sNewNamespacePrefix);
	inline PXMLDocumentNode GetRootNode();
	inline std::string SaveToString(const bool bAddLineBreaks);
};
	
/*************************************************************************************************************************
 Class CTCPIPPacket 
**************************************************************************************************************************/
class CTCPIPPacket : public CBase {
public:
	
	/**
	* CTCPIPPacket::CTCPIPPacket - Constructor for TCPIPPacket class.
	*/
	CTCPIPPacket(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool IsEmpty();
	inline LibMCEnv_uint32 GetSize();
	inline void GetData(std::vector<LibMCEnv_uint8> & BufferBuffer);
};
	
/*************************************************************************************************************************
 Class CTCPIPConnection 
**************************************************************************************************************************/
class CTCPIPConnection : public CBase {
public:
	
	/**
	* CTCPIPConnection::CTCPIPConnection - Constructor for TCPIPConnection class.
	*/
	CTCPIPConnection(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetIPAddress();
	inline LibMCEnv_uint32 GetPort();
	inline LibMCEnv_uint32 GetTimeout();
	inline bool IsConnected();
	inline void Disconnect();
	inline void Reconnect();
	inline void SendBuffer(const CInputVector<LibMCEnv_uint8> & BufferBuffer);
	inline bool WaitForData(const LibMCEnv_uint32 nTimeOutInMS);
	inline PTCPIPPacket ReceiveFixedPacket(const LibMCEnv_uint32 nPacketSize, const LibMCEnv_uint32 nTimeOutInMS);
	inline PTCPIPPacket ReceiveData(const LibMCEnv_uint32 nDataSize, const LibMCEnv_uint32 nTimeOutInMS);
};
	
/*************************************************************************************************************************
 Class CModbusTCPDigitalIOStatus 
**************************************************************************************************************************/
class CModbusTCPDigitalIOStatus : public CBase {
public:
	
	/**
	* CModbusTCPDigitalIOStatus::CModbusTCPDigitalIOStatus - Constructor for ModbusTCPDigitalIOStatus class.
	*/
	CModbusTCPDigitalIOStatus(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCEnv_uint32 GetCount();
	inline LibMCEnv_uint32 GetBaseAddress();
	inline bool GetValue(const LibMCEnv_uint32 nIndex);
	inline void GetValues(std::vector<LibMCEnv_uint8> & StateArrayBuffer);
};
	
/*************************************************************************************************************************
 Class CModbusTCPRegisterStatus 
**************************************************************************************************************************/
class CModbusTCPRegisterStatus : public CBase {
public:
	
	/**
	* CModbusTCPRegisterStatus::CModbusTCPRegisterStatus - Constructor for ModbusTCPRegisterStatus class.
	*/
	CModbusTCPRegisterStatus(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCEnv_uint32 GetCount();
	inline LibMCEnv_uint32 GetBaseAddress();
	inline LibMCEnv_uint16 GetValue(const LibMCEnv_uint32 nIndex);
	inline void GetValues(std::vector<LibMCEnv_uint16> & StateArrayBuffer);
};
	
/*************************************************************************************************************************
 Class CModbusTCPConnection 
**************************************************************************************************************************/
class CModbusTCPConnection : public CBase {
public:
	
	/**
	* CModbusTCPConnection::CModbusTCPConnection - Constructor for ModbusTCPConnection class.
	*/
	CModbusTCPConnection(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetIPAddress();
	inline LibMCEnv_uint32 GetPort();
	inline LibMCEnv_uint32 GetTimeout();
	inline bool IsConnected();
	inline void Disconnect();
	inline void Reconnect();
	inline LibMCEnv_uint16 DiagnosisCall(const LibMCEnv_uint16 nSubFunction, const LibMCEnv_uint16 nDataField);
	inline PModbusTCPDigitalIOStatus ReadCoilStatus(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nBitCount);
	inline PModbusTCPDigitalIOStatus ReadInputStatus(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nBitCount);
	inline PModbusTCPRegisterStatus ReadHoldingRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nRegisterCount);
	inline PModbusTCPRegisterStatus ReadInputRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nRegisterCount);
	inline void ForceMultipleCoils(const LibMCEnv_uint32 nStartAddress, const CInputVector<LibMCEnv_uint8> & BufferBuffer);
	inline void PresetMultipleRegisters(const LibMCEnv_uint32 nStartAddress, const CInputVector<LibMCEnv_uint16> & BufferBuffer);
};
	
/*************************************************************************************************************************
 Class CDriverStatusUpdateSession 
**************************************************************************************************************************/
class CDriverStatusUpdateSession : public CBase {
public:
	
	/**
	* CDriverStatusUpdateSession::CDriverStatusUpdateSession - Constructor for DriverStatusUpdateSession class.
	*/
	CDriverStatusUpdateSession(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void SetStringParameter(const std::string & sParameterName, const std::string & sValue);
	inline void SetUUIDParameter(const std::string & sParameterName, const std::string & sValue);
	inline void SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue);
	inline void SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue);
	inline void SetBoolParameter(const std::string & sParameterName, const bool bValue);
	inline void LogMessage(const std::string & sLogString);
	inline void LogWarning(const std::string & sLogString);
	inline void LogInfo(const std::string & sLogString);
	inline void Sleep(const LibMCEnv_uint32 nDelay);
};
	
/*************************************************************************************************************************
 Class CDriverEnvironment 
**************************************************************************************************************************/
class CDriverEnvironment : public CBase {
public:
	
	/**
	* CDriverEnvironment::CDriverEnvironment - Constructor for DriverEnvironment class.
	*/
	CDriverEnvironment(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PDriverStatusUpdateSession CreateStatusUpdateSession();
	inline PWorkingDirectory CreateWorkingDirectory();
	inline PTCPIPConnection CreateTCPIPConnection(const std::string & sIPAddress, const LibMCEnv_uint32 nPort, const LibMCEnv_uint32 nTimeOutInMS);
	inline PModbusTCPConnection CreateModbusTCPConnection(const std::string & sIPAddress, const LibMCEnv_uint32 nPort, const LibMCEnv_uint32 nTimeOutInMS);
	inline PXMLDocument CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace);
	inline PXMLDocument ParseXMLString(const std::string & sXMLString);
	inline PXMLDocument ParseXMLData(const CInputVector<LibMCEnv_uint8> & XMLDataBuffer);
	inline PDataTable CreateDataTable();
	inline bool DriverHasResourceData(const std::string & sIdentifier);
	inline bool MachineHasResourceData(const std::string & sIdentifier);
	inline void RetrieveDriverData(const std::string & sIdentifier, std::vector<LibMCEnv_uint8> & DataBufferBuffer);
	inline void RetrieveDriverResourceData(const std::string & sIdentifier, std::vector<LibMCEnv_uint8> & DataBufferBuffer);
	inline void RetrieveMachineResourceData(const std::string & sIdentifier, std::vector<LibMCEnv_uint8> & DataBufferBuffer);
	inline PToolpathAccessor CreateToolpathAccessor(const std::string & sStreamUUID);
	inline bool ParameterNameIsValid(const std::string & sParameterName);
	inline void RegisterStringParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue);
	inline void RegisterUUIDParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue);
	inline void RegisterDoubleParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_double dDefaultValue);
	inline void RegisterDoubleParameterWithUnits(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_double dDefaultValue, const LibMCEnv_double dUnits);
	inline void RegisterIntegerParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_int64 nDefaultValue);
	inline void RegisterBoolParameter(const std::string & sParameterName, const std::string & sDescription, const bool bDefaultValue);
	inline void SetStringParameter(const std::string & sParameterName, const std::string & sValue);
	inline void SetUUIDParameter(const std::string & sParameterName, const std::string & sValue);
	inline void SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue);
	inline void SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue);
	inline void SetBoolParameter(const std::string & sParameterName, const bool bValue);
	inline void Sleep(const LibMCEnv_uint32 nDelay);
	inline LibMCEnv_uint64 GetGlobalTimerInMilliseconds();
	inline LibMCEnv_uint64 GetGlobalTimerInMicroseconds();
	inline void LogMessage(const std::string & sLogString);
	inline void LogWarning(const std::string & sLogString);
	inline void LogInfo(const std::string & sLogString);
	inline PImageData CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline PImageData LoadPNGImage(const CInputVector<LibMCEnv_uint8> & PNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline PDiscreteFieldData2D CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue);
	inline PDiscreteFieldData2D CreateDiscreteField2DFromImage(classParam<CImageData> pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY);
	inline bool HasBuildJob(const std::string & sBuildUUID);
	inline PBuild GetBuildJob(const std::string & sBuildUUID);
	inline bool HasBuildExecution(const std::string & sExecutionUUID);
	inline PBuildExecution GetBuildExecution(const std::string & sExecutionUUID);
	inline PCryptoContext CreateCryptoContext();
	inline PDateTime GetCurrentDateTime();
	inline PDateTime GetCustomDateTime(const LibMCEnv_uint32 nYear, const LibMCEnv_uint32 nMonth, const LibMCEnv_uint32 nDay, const LibMCEnv_uint32 nHour, const LibMCEnv_uint32 nMinute, const LibMCEnv_uint32 nSecond, const LibMCEnv_uint32 nMicrosecond);
	inline PDateTime GetStartDateTime();
};
	
/*************************************************************************************************************************
 Class CSignalTrigger 
**************************************************************************************************************************/
class CSignalTrigger : public CBase {
public:
	
	/**
	* CSignalTrigger::CSignalTrigger - Constructor for SignalTrigger class.
	*/
	CSignalTrigger(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool CanTrigger();
	inline void Trigger();
	inline bool WaitForHandling(const LibMCEnv_uint32 nTimeOut);
	inline std::string GetName();
	inline std::string GetStateMachine();
	inline void SetString(const std::string & sName, const std::string & sValue);
	inline void SetUUID(const std::string & sName, const std::string & sValue);
	inline void SetDouble(const std::string & sName, const LibMCEnv_double dValue);
	inline void SetInteger(const std::string & sName, const LibMCEnv_int64 nValue);
	inline void SetBool(const std::string & sName, const bool bValue);
	inline std::string GetStringResult(const std::string & sName);
	inline std::string GetUUIDResult(const std::string & sName);
	inline LibMCEnv_double GetDoubleResult(const std::string & sName);
	inline LibMCEnv_int64 GetIntegerResult(const std::string & sName);
	inline bool GetBoolResult(const std::string & sName);
};
	
/*************************************************************************************************************************
 Class CSignalHandler 
**************************************************************************************************************************/
class CSignalHandler : public CBase {
public:
	
	/**
	* CSignalHandler::CSignalHandler - Constructor for SignalHandler class.
	*/
	CSignalHandler(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void SignalHandled();
	inline std::string GetName();
	inline std::string GetSignalID();
	inline std::string GetSignalUUID();
	inline std::string GetStateMachine();
	inline std::string GetString(const std::string & sName);
	inline std::string GetUUID(const std::string & sName);
	inline LibMCEnv_double GetDouble(const std::string & sName);
	inline LibMCEnv_int64 GetInteger(const std::string & sName);
	inline bool GetBool(const std::string & sName);
	inline void SetStringResult(const std::string & sName, const std::string & sValue);
	inline void SetUUIDResult(const std::string & sName, const std::string & sValue);
	inline void SetDoubleResult(const std::string & sName, const LibMCEnv_double dValue);
	inline void SetIntegerResult(const std::string & sName, const LibMCEnv_int64 nValue);
	inline void SetBoolResult(const std::string & sName, const bool bValue);
};
	
/*************************************************************************************************************************
 Class CBaseTempStreamWriter 
**************************************************************************************************************************/
class CBaseTempStreamWriter : public CBase {
public:
	
	/**
	* CBaseTempStreamWriter::CBaseTempStreamWriter - Constructor for BaseTempStreamWriter class.
	*/
	CBaseTempStreamWriter(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetName();
	inline std::string GetMIMEType();
	inline LibMCEnv_uint64 GetSize();
	inline void Finish();
	inline bool IsFinished();
	inline PStreamReader GetStreamReader();
};
	
/*************************************************************************************************************************
 Class CTempStreamWriter 
**************************************************************************************************************************/
class CTempStreamWriter : public CBaseTempStreamWriter {
public:
	
	/**
	* CTempStreamWriter::CTempStreamWriter - Constructor for TempStreamWriter class.
	*/
	CTempStreamWriter(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBaseTempStreamWriter(pWrapper, pHandle)
	{
	}
	
	inline LibMCEnv_uint64 GetWritePosition();
	inline void Seek(const LibMCEnv_uint64 nWritePosition);
	inline void WriteData(const CInputVector<LibMCEnv_uint8> & DataBuffer);
	inline void WriteString(const std::string & sData);
	inline void WriteLine(const std::string & sLine);
	inline void CopyFrom(classParam<CStreamReader> pStreamReader);
};
	
/*************************************************************************************************************************
 Class CZIPStreamWriter 
**************************************************************************************************************************/
class CZIPStreamWriter : public CBaseTempStreamWriter {
public:
	
	/**
	* CZIPStreamWriter::CZIPStreamWriter - Constructor for ZIPStreamWriter class.
	*/
	CZIPStreamWriter(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBaseTempStreamWriter(pWrapper, pHandle)
	{
	}
	
	inline PTempStreamWriter CreateZIPEntry(const std::string & sFileName);
	inline void CreateZIPEntryFromStream(const std::string & sFileName, classParam<CStreamReader> pStreamReader);
};
	
/*************************************************************************************************************************
 Class CStreamReader 
**************************************************************************************************************************/
class CStreamReader : public CBase {
public:
	
	/**
	* CStreamReader::CStreamReader - Constructor for StreamReader class.
	*/
	CStreamReader(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetName();
	inline std::string GetMIMEType();
	inline LibMCEnv_uint64 GetSize();
	inline LibMCEnv_uint64 GetReadPosition();
	inline void Seek(const LibMCEnv_uint64 nReadPosition);
	inline void ReadData(const LibMCEnv_uint64 nSizeToRead, std::vector<LibMCEnv_uint8> & DataBuffer);
	inline void ReadAllData(std::vector<LibMCEnv_uint8> & DataBuffer);
};
	
/*************************************************************************************************************************
 Class CUniformJournalSampling 
**************************************************************************************************************************/
class CUniformJournalSampling : public CBase {
public:
	
	/**
	* CUniformJournalSampling::CUniformJournalSampling - Constructor for UniformJournalSampling class.
	*/
	CUniformJournalSampling(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetVariableName();
	inline LibMCEnv_uint32 GetNumberOfSamples();
	inline LibMCEnv_uint64 GetStartTimeStamp();
	inline LibMCEnv_uint64 GetEndTimeStamp();
	inline void GetSample(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 & nTimeStamp, LibMCEnv_double & dValue);
	inline void GetAllSamples(std::vector<sTimeStreamEntry> & SamplesBuffer);
};
	
/*************************************************************************************************************************
 Class CJournalVariable 
**************************************************************************************************************************/
class CJournalVariable : public CBase {
public:
	
	/**
	* CJournalVariable::CJournalVariable - Constructor for JournalVariable class.
	*/
	CJournalVariable(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetVariableName();
	inline LibMCEnv_uint64 GetStartTimeStamp();
	inline LibMCEnv_uint64 GetEndTimeStamp();
	inline LibMCEnv_double ComputeFullAverage();
	inline LibMCEnv_double ComputeAverage(const LibMCEnv_uint64 nStartTimeInMicroSeconds, const LibMCEnv_uint64 nEndTimeInMicroSeconds, const bool bClampInterval);
	inline LibMCEnv_double ComputeSample(const LibMCEnv_uint64 nTimeInMicroSeconds);
	inline PUniformJournalSampling ComputeUniformAverageSamples(const LibMCEnv_uint64 nStartTimeInMicroSeconds, const LibMCEnv_uint64 nIntervalIncrement, const LibMCEnv_uint32 nNumberOfSamples, const LibMCEnv_double dMovingAverageDelta, const bool bClampInterval);
	inline PUniformJournalSampling ComputeEquidistantSamples(const LibMCEnv_uint64 nStartTimeInMicroSeconds, const LibMCEnv_uint64 nIntervalIncrement, const LibMCEnv_uint32 nNumberOfSamples);
	inline void ReceiveRawTimeStream(std::vector<sTimeStreamEntry> & TimeStreamEntriesBuffer);
};
	
/*************************************************************************************************************************
 Class CAlert 
**************************************************************************************************************************/
class CAlert : public CBase {
public:
	
	/**
	* CAlert::CAlert - Constructor for Alert class.
	*/
	CAlert(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline bool IsActive();
	inline eAlertLevel GetAlertLevel();
	inline std::string GetIdentifier();
	inline std::string GetReadableContextInformation();
	inline bool NeedsAcknowledgement();
	inline bool HasBeenAcknowledged();
	inline void GetAcknowledgementInformation(std::string & sUserUUID, std::string & sUserComment, std::string & sAckTime);
	inline PDateTime GetAcknowledgementTime();
	inline void AcknowledgeForUser(const std::string & sUserUUID, const std::string & sUserComment);
	inline void AcknowledgeAlertForCurrentUser(const std::string & sUserComment);
	inline void DeactivateAlert();
};
	
/*************************************************************************************************************************
 Class CAlertIterator 
**************************************************************************************************************************/
class CAlertIterator : public CIterator {
public:
	
	/**
	* CAlertIterator::CAlertIterator - Constructor for AlertIterator class.
	*/
	CAlertIterator(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PAlert GetCurrentAlert();
};
	
/*************************************************************************************************************************
 Class CLogEntryList 
**************************************************************************************************************************/
class CLogEntryList : public CBase {
public:
	
	/**
	* CLogEntryList::CLogEntryList - Constructor for LogEntryList class.
	*/
	CLogEntryList(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCEnv_uint32 GetCount();
	inline void GetEntry(const LibMCEnv_uint32 nIndex, std::string & sMessage, std::string & sSubSystem, LibMCEnv_uint32 & nLogID, eLogLevel & eLogLevel);
	inline PDateTime GetEntryTime(const LibMCEnv_uint32 nIndex);
};
	
/*************************************************************************************************************************
 Class CJournalHandler 
**************************************************************************************************************************/
class CJournalHandler : public CBase {
public:
	
	/**
	* CJournalHandler::CJournalHandler - Constructor for JournalHandler class.
	*/
	CJournalHandler(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PJournalVariable RetrieveJournalVariable(const std::string & sVariableName, const LibMCEnv_uint64 nTimeDeltaInMicroseconds);
	inline PJournalVariable RetrieveJournalVariableFromTimeInterval(const std::string & sVariableName, const LibMCEnv_uint64 nStartTimeInMicroseconds, const LibMCEnv_uint64 nEndTimeInMicroseconds);
	inline PDateTime GetStartTime();
	inline PLogEntryList RetrieveLogEntries(const LibMCEnv_uint64 nTimeDeltaInMicroseconds, eLogLevel & eMinLogLevel);
	inline PLogEntryList RetrieveLogEntriesFromTimeInterval(const LibMCEnv_uint64 nStartTimeInMicroseconds, const LibMCEnv_uint64 nEndTimeInMicroseconds, eLogLevel & eMinLogLevel);
	inline PAlertIterator RetrieveAlerts(const LibMCEnv_uint64 nTimeDeltaInMicroseconds);
	inline PAlertIterator RetrieveAlertsFromTimeInterval(const LibMCEnv_uint64 nStartTimeInMicroseconds, const LibMCEnv_uint64 nEndTimeInMicroseconds);
};
	
/*************************************************************************************************************************
 Class CUserDetailList 
**************************************************************************************************************************/
class CUserDetailList : public CBase {
public:
	
	/**
	* CUserDetailList::CUserDetailList - Constructor for UserDetailList class.
	*/
	CUserDetailList(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCEnv_uint32 Count();
	inline void GetUserProperties(const LibMCEnv_uint32 nUserIndex, std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier);
	inline std::string GetUsername(const LibMCEnv_uint32 nUserIndex);
	inline std::string GetUUID(const LibMCEnv_uint32 nUserIndex);
	inline std::string GetDescription(const LibMCEnv_uint32 nUserIndex);
	inline std::string GetRole(const LibMCEnv_uint32 nUserIndex);
	inline std::string GetLanguage(const LibMCEnv_uint32 nUserIndex);
};
	
/*************************************************************************************************************************
 Class CUserManagementHandler 
**************************************************************************************************************************/
class CUserManagementHandler : public CBase {
public:
	
	/**
	* CUserManagementHandler::CUserManagementHandler - Constructor for UserManagementHandler class.
	*/
	CUserManagementHandler(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool UserExists(const std::string & sUsername);
	inline bool UserUUIDExists(const std::string & sUUID);
	inline void GetUserProperties(const std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier);
	inline void GetUserPropertiesByUUID(const std::string & sUUID, std::string & sUsername, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier);
	inline std::string GetUsernameByUUID(const std::string & sUUID);
	inline std::string GetUserUUID(const std::string & sUsername);
	inline std::string GetUserDescription(const std::string & sUsername);
	inline std::string GetUserDescriptionByUUID(const std::string & sUUID);
	inline std::string GetUserRole(const std::string & sUsername);
	inline std::string GetUserRoleByUUID(const std::string & sUUID);
	inline std::string GetUserLanguage(const std::string & sUsername);
	inline std::string GetUserLanguageByUUID(const std::string & sUUID);
	inline std::string CreateUser(const std::string & sUsername, const std::string & sRole, const std::string & sSalt, const std::string & sHashedPassword, const std::string & sDescription);
	inline void SetUserLanguage(const std::string & sUsername, const std::string & sLanguageIdentifier);
	inline void SetUserRole(const std::string & sUsername, const std::string & sUserRole);
	inline void SetUserDescription(const std::string & sUsername, const std::string & sDescription);
	inline void SetUserPassword(const std::string & sUsername, const std::string & sSalt, const std::string & sHashedPassword);
	inline void SetUserLanguageByUUID(const std::string & sUUID, const std::string & sLanguageIdentifier);
	inline void SetUserRoleByUUID(const std::string & sUUID, const std::string & sUserRole);
	inline void SetUserDescriptionByUUID(const std::string & sUUID, const std::string & sDescription);
	inline void SetUserPasswordByUUID(const std::string & sUUID, const std::string & sSalt, const std::string & sHashedPassword);
	inline PUserDetailList GetActiveUsers();
};
	
/*************************************************************************************************************************
 Class CStateEnvironment 
**************************************************************************************************************************/
class CStateEnvironment : public CBase {
public:
	
	/**
	* CStateEnvironment::CStateEnvironment - Constructor for StateEnvironment class.
	*/
	CStateEnvironment(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetMachineState(const std::string & sMachineInstance);
	inline std::string GetPreviousState();
	inline PSignalTrigger PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName);
	inline bool WaitForSignal(const std::string & sSignalName, const LibMCEnv_uint32 nTimeOut, PSignalHandler & pHandlerInstance);
	inline PSignalHandler GetUnhandledSignal(const std::string & sSignalTypeName);
	inline PSignalHandler GetUnhandledSignalByUUID(const std::string & sUUID, const bool bMustExist);
	inline void GetDriverLibrary(const std::string & sDriverName, std::string & sDriverType, LibMCEnv_pvoid & pDriverLookup);
	inline void CreateDriverAccess(const std::string & sDriverName, LibMCEnv_pvoid & pDriverHandle);
	inline bool HasBuildJob(const std::string & sBuildUUID);
	inline PBuild GetBuildJob(const std::string & sBuildUUID);
	inline bool HasBuildExecution(const std::string & sExecutionUUID);
	inline PBuildExecution GetBuildExecution(const std::string & sExecutionUUID);
	inline void UnloadAllToolpathes();
	inline void SetNextState(const std::string & sStateName);
	inline void LogMessage(const std::string & sLogString);
	inline void LogWarning(const std::string & sLogString);
	inline void LogInfo(const std::string & sLogString);
	inline void Sleep(const LibMCEnv_uint32 nDelay);
	inline bool CheckForTermination();
	inline void StoreSignal(const std::string & sName, classParam<CSignalHandler> pHandler);
	inline PSignalHandler RetrieveSignal(const std::string & sName);
	inline void ClearStoredValue(const std::string & sName);
	inline void SetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue);
	inline void SetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue);
	inline void SetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_double dValue);
	inline void SetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_int64 nValue);
	inline void SetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName, const bool bValue);
	inline std::string GetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline std::string GetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline LibMCEnv_double GetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline LibMCEnv_int64 GetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline bool GetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline void LoadResourceData(const std::string & sResourceName, std::vector<LibMCEnv_uint8> & ResourceDataBuffer);
	inline std::string LoadResourceString(const std::string & sResourceName);
	inline PImageData CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline PImageData LoadPNGImage(const CInputVector<LibMCEnv_uint8> & PNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline PDiscreteFieldData2D CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue);
	inline PDiscreteFieldData2D CreateDiscreteField2DFromImage(classParam<CImageData> pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY);
	inline LibMCEnv_uint64 GetGlobalTimerInMilliseconds();
	inline LibMCEnv_uint64 GetGlobalTimerInMicroseconds();
	inline LibMCEnv_uint64 GetStartTimeOfStateInMilliseconds();
	inline LibMCEnv_uint64 GetStartTimeOfStateInMicroseconds();
	inline LibMCEnv_uint64 GetEndTimeOfPreviousStateInMicroseconds();
	inline LibMCEnv_uint64 GetEndTimeOfPreviousStateInMilliseconds();
	inline LibMCEnv_uint64 GetElapsedTimeInStateInMilliseconds();
	inline LibMCEnv_uint64 GetElapsedTimeInStateInMicroseconds();
	inline PDateTime GetCurrentDateTime();
	inline PDateTime GetCustomDateTime(const LibMCEnv_uint32 nYear, const LibMCEnv_uint32 nMonth, const LibMCEnv_uint32 nDay, const LibMCEnv_uint32 nHour, const LibMCEnv_uint32 nMinute, const LibMCEnv_uint32 nSecond, const LibMCEnv_uint32 nMicrosecond);
	inline PDateTime GetStartDateTime();
	inline PTestEnvironment GetTestEnvironment();
	inline PXMLDocument CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace);
	inline PXMLDocument ParseXMLString(const std::string & sXMLString);
	inline PXMLDocument ParseXMLData(const CInputVector<LibMCEnv_uint8> & XMLDataBuffer);
	inline PDataTable CreateDataTable();
	inline bool CheckUserPermission(const std::string & sUserLogin, const std::string & sPermissionIdentifier);
	inline PUserManagementHandler CreateUserManagement();
	inline PJournalHandler GetCurrentJournal();
	inline PSceneHandler CreateSceneHandler();
	inline PDataSeries CreateDataSeries(const std::string & sName);
	inline bool HasDataSeries(const std::string & sDataSeriesUUID);
	inline PDataSeries FindDataSeries(const std::string & sDataSeriesUUID);
	inline void ReleaseDataSeries(const std::string & sDataSeriesUUID);
	inline PAlert CreateAlert(const std::string & sIdentifier, const std::string & sReadableContextInformation, const bool bAutomaticLogEntry);
	inline PAlert FindAlert(const std::string & sUUID);
	inline bool AlertExists(const std::string & sUUID);
	inline PAlertIterator RetrieveAlerts(const bool bOnlyActive);
	inline PAlertIterator RetrieveAlertsByType(const std::string & sIdentifier, const bool bOnlyActive);
	inline bool HasAlertOfType(const std::string & sIdentifier, const bool bOnlyActive);
	inline PCryptoContext CreateCryptoContext();
	inline PTempStreamWriter CreateTemporaryStream(const std::string & sName, const std::string & sMIMEType);
	inline PZIPStreamWriter CreateZIPStream(const std::string & sName);
	inline PStreamReader LoadStream(const std::string & sUUID, const bool bMustExist);
};
	
/*************************************************************************************************************************
 Class CUIItem 
**************************************************************************************************************************/
class CUIItem : public CBase {
public:
	
	/**
	* CUIItem::CUIItem - Constructor for UIItem class.
	*/
	CUIItem(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetPath();
	inline std::string GetUUID();
};
	
/*************************************************************************************************************************
 Class CUIEnvironment 
**************************************************************************************************************************/
class CUIEnvironment : public CBase {
public:
	
	/**
	* CUIEnvironment::CUIEnvironment - Constructor for UIEnvironment class.
	*/
	CUIEnvironment(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void ActivateModalDialog(const std::string & sDialogName);
	inline void CloseModalDialog();
	inline void ActivatePage(const std::string & sPageName);
	inline void LogOut();
	inline void ShowHint(const std::string & sHint, const LibMCEnv_uint32 nTimeoutInMS);
	inline void ShowHintColored(const std::string & sHint, const LibMCEnv_uint32 nTimeoutInMS, const sColorRGB & Color, const sColorRGB & FontColor);
	inline void HideHint();
	inline void StartStreamDownload(const std::string & sUUID, const std::string & sFilename);
	inline std::string ShowMessageDlg(const std::string & sCaption, const std::string & sTitle, const eMessageDialogType eDialogType, const std::string & sYesEvent, const std::string & sNoEvent, const std::string & sCancelEvent);
	inline std::string RetrieveEventSender();
	inline std::string RetrieveEventSenderPage();
	inline std::string RetrieveEventSenderUUID();
	inline PSignalTrigger PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName);
	inline std::string GetMachineState(const std::string & sMachineInstance);
	inline void LogMessage(const std::string & sLogString);
	inline void LogWarning(const std::string & sLogString);
	inline void LogInfo(const std::string & sLogString);
	inline std::string GetMachineParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline std::string GetMachineParameterAsUUID(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline LibMCEnv_double GetMachineParameterAsDouble(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline LibMCEnv_int64 GetMachineParameterAsInteger(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline bool GetMachineParameterAsBool(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline std::string GetUIProperty(const std::string & sElementPath, const std::string & sPropertyName);
	inline std::string GetUIPropertyAsUUID(const std::string & sElementPath, const std::string & sPropertyName);
	inline LibMCEnv_double GetUIPropertyAsDouble(const std::string & sElementPath, const std::string & sPropertyName);
	inline LibMCEnv_int64 GetUIPropertyAsInteger(const std::string & sElementPath, const std::string & sPropertyName);
	inline bool GetUIPropertyAsBool(const std::string & sElementPath, const std::string & sPropertyName);
	inline void SetUIProperty(const std::string & sElementPath, const std::string & sPropertyName, const std::string & sValue);
	inline void SetUIPropertyAsUUID(const std::string & sElementPath, const std::string & sPropertyName, const std::string & sValue);
	inline void SetUIPropertyAsDouble(const std::string & sElementPath, const std::string & sPropertyName, const LibMCEnv_double dValue);
	inline void SetUIPropertyAsInteger(const std::string & sElementPath, const std::string & sPropertyName, const LibMCEnv_int64 nValue);
	inline void SetUIPropertyAsBool(const std::string & sElementPath, const std::string & sPropertyName, const bool bValue);
	inline PImageData CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline PImageData LoadPNGImage(const CInputVector<LibMCEnv_uint8> & PNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat);
	inline LibMCEnv_uint64 GetGlobalTimerInMilliseconds();
	inline LibMCEnv_uint64 GetGlobalTimerInMicroseconds();
	inline PTestEnvironment GetTestEnvironment();
	inline PXMLDocument CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace);
	inline PXMLDocument ParseXMLString(const std::string & sXMLString);
	inline PXMLDocument ParseXMLData(const CInputVector<LibMCEnv_uint8> & XMLDataBuffer);
	inline PDataTable CreateDataTable();
	inline bool HasBuildJob(const std::string & sBuildUUID);
	inline PBuild GetBuildJob(const std::string & sBuildUUID);
	inline bool HasBuildExecution(const std::string & sExecutionUUID);
	inline PBuildExecution GetBuildExecution(const std::string & sExecutionUUID);
	inline PDiscreteFieldData2D CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue);
	inline PDiscreteFieldData2D CreateDiscreteField2DFromImage(classParam<CImageData> pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY);
	inline bool CheckPermission(const std::string & sPermissionIdentifier);
	inline std::string GetCurrentUserLogin();
	inline std::string GetCurrentUserDescription();
	inline std::string GetCurrentUserRole();
	inline std::string GetCurrentUserLanguage();
	inline std::string GetCurrentUserUUID();
	inline PUserManagementHandler CreateUserManagement();
	inline PJournalHandler GetCurrentJournal();
	inline PSceneHandler CreateSceneHandler();
	inline PDataSeries CreateDataSeries(const std::string & sName, const bool bBoundToLogin);
	inline bool HasDataSeries(const std::string & sDataSeriesUUID);
	inline PDataSeries FindDataSeries(const std::string & sDataSeriesUUID);
	inline void ReleaseDataSeries(const std::string & sDataSeriesUUID);
	inline PAlert CreateAlert(const std::string & sIdentifier, const std::string & sReadableContextInformation, const bool bAutomaticLogEntry);
	inline PAlert FindAlert(const std::string & sUUID);
	inline bool AlertExists(const std::string & sUUID);
	inline PAlertIterator RetrieveAlerts(const bool bOnlyActive);
	inline PAlertIterator RetrieveAlertsByType(const std::string & sIdentifier, const bool bOnlyActive);
	inline bool HasAlertOfType(const std::string & sIdentifier, const bool bOnlyActive);
	inline PCryptoContext CreateCryptoContext();
	inline PTempStreamWriter CreateTemporaryStream(const std::string & sName, const std::string & sMIMEType);
	inline PZIPStreamWriter CreateZIPStream(const std::string & sName);
	inline PStreamReader LoadStream(const std::string & sUUID, const bool bMustExist);
	inline PDateTime GetCurrentDateTime();
	inline PDateTime GetCustomDateTime(const LibMCEnv_uint32 nYear, const LibMCEnv_uint32 nMonth, const LibMCEnv_uint32 nDay, const LibMCEnv_uint32 nHour, const LibMCEnv_uint32 nMinute, const LibMCEnv_uint32 nSecond, const LibMCEnv_uint32 nMicrosecond);
	inline PDateTime GetStartDateTime();
	inline void Sleep(const LibMCEnv_uint32 nDelay);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCEnv_uint32 & nMajor, LibMCEnv_uint32 & nMinor, LibMCEnv_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCEnvHandle hInstance = pInstance.GetHandle();
		LibMCEnv_uint32 bytesNeededErrorMessage = 0;
		LibMCEnv_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCEnvHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCEnvHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCEnv_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCEnv_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCEnvResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCEnvException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCEnvResult CWrapper::initWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Iterator_MoveNext = nullptr;
		pWrapperTable->m_Iterator_MovePrevious = nullptr;
		pWrapperTable->m_Iterator_GetCurrent = nullptr;
		pWrapperTable->m_Iterator_Clone = nullptr;
		pWrapperTable->m_Iterator_Count = nullptr;
		pWrapperTable->m_TestEnvironment_WriteTestOutput = nullptr;
		pWrapperTable->m_CryptoContext_CalculateSHA256FromString = nullptr;
		pWrapperTable->m_CryptoContext_CalculateSHA256FromBytes = nullptr;
		pWrapperTable->m_CryptoContext_NormalizeSHA256String = nullptr;
		pWrapperTable->m_CryptoContext_CreateRandomSHA256Hash = nullptr;
		pWrapperTable->m_CryptoContext_CreateUUID = nullptr;
		pWrapperTable->m_CryptoContext_NormalizeUUIDString = nullptr;
		pWrapperTable->m_PNGImageStoreOptions_ResetToDefaults = nullptr;
		pWrapperTable->m_PNGImageData_GetSizeInPixels = nullptr;
		pWrapperTable->m_PNGImageData_GetPNGDataStream = nullptr;
		pWrapperTable->m_ImageData_GetPixelFormat = nullptr;
		pWrapperTable->m_ImageData_ChangePixelFormat = nullptr;
		pWrapperTable->m_ImageData_GetDPI = nullptr;
		pWrapperTable->m_ImageData_SetDPI = nullptr;
		pWrapperTable->m_ImageData_GetSizeInMM = nullptr;
		pWrapperTable->m_ImageData_GetSizeInPixels = nullptr;
		pWrapperTable->m_ImageData_ResizeImage = nullptr;
		pWrapperTable->m_ImageData_CreatePNGImage = nullptr;
		pWrapperTable->m_ImageData_EncodePNG = nullptr;
		pWrapperTable->m_ImageData_GetEncodedPNGData = nullptr;
		pWrapperTable->m_ImageData_ClearEncodedPNGData = nullptr;
		pWrapperTable->m_ImageData_Clear = nullptr;
		pWrapperTable->m_ImageData_GetPixel = nullptr;
		pWrapperTable->m_ImageData_SetPixel = nullptr;
		pWrapperTable->m_ImageData_GetPixelRange = nullptr;
		pWrapperTable->m_ImageData_SetPixelRange = nullptr;
		pWrapperTable->m_DiscreteFieldData2DStoreOptions_ResetToDefaults = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_GetDPI = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_SetDPI = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_GetOriginInMM = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_SetOriginInMM = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_GetSizeInMM = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_GetSizeInPixels = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_ResizeField = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_Clear = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_Clamp = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_GetPixel = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_SetPixel = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_GetPixelRange = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_SetPixelRange = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_RenderAveragePointValues = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_ScaleFieldDown = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_ScaleFieldUp = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_Discretize = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_DiscretizeWithMapping = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_RenderToImageRaw = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_TransformField = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_AddField = nullptr;
		pWrapperTable->m_DiscreteFieldData2D_Duplicate = nullptr;
		pWrapperTable->m_DataTableCSVWriteOptions_GetSeparator = nullptr;
		pWrapperTable->m_DataTableCSVWriteOptions_SetSeparator = nullptr;
		pWrapperTable->m_DataTable_AddColumn = nullptr;
		pWrapperTable->m_DataTable_RemoveColumn = nullptr;
		pWrapperTable->m_DataTable_Clear = nullptr;
		pWrapperTable->m_DataTable_HasColumn = nullptr;
		pWrapperTable->m_DataTable_GetRowCount = nullptr;
		pWrapperTable->m_DataTable_GetColumnCount = nullptr;
		pWrapperTable->m_DataTable_GetColumnIdentifier = nullptr;
		pWrapperTable->m_DataTable_GetColumnDescription = nullptr;
		pWrapperTable->m_DataTable_GetColumnType = nullptr;
		pWrapperTable->m_DataTable_GetColumnInformation = nullptr;
		pWrapperTable->m_DataTable_GetDoubleColumnValues = nullptr;
		pWrapperTable->m_DataTable_GetInt32ColumnValues = nullptr;
		pWrapperTable->m_DataTable_GetInt64ColumnValues = nullptr;
		pWrapperTable->m_DataTable_GetUint32ColumnValues = nullptr;
		pWrapperTable->m_DataTable_GetUint64ColumnValues = nullptr;
		pWrapperTable->m_DataTable_SetDoubleColumnValues = nullptr;
		pWrapperTable->m_DataTable_SetInt32ColumnValues = nullptr;
		pWrapperTable->m_DataTable_SetInt64ColumnValues = nullptr;
		pWrapperTable->m_DataTable_SetUint32ColumnValues = nullptr;
		pWrapperTable->m_DataTable_SetUint64ColumnValues = nullptr;
		pWrapperTable->m_DataTable_CreateWriteOptions = nullptr;
		pWrapperTable->m_DataTable_CreateCSVWriteOptions = nullptr;
		pWrapperTable->m_DataTable_WriteCSVToStream = nullptr;
		pWrapperTable->m_DataTable_WriteDataToStream = nullptr;
		pWrapperTable->m_DataTable_LoadFromStream = nullptr;
		pWrapperTable->m_DataSeries_GetName = nullptr;
		pWrapperTable->m_DataSeries_GetUUID = nullptr;
		pWrapperTable->m_DataSeries_Clear = nullptr;
		pWrapperTable->m_DataSeries_IsEmpty = nullptr;
		pWrapperTable->m_DataSeries_GetMinimum = nullptr;
		pWrapperTable->m_DataSeries_GetMaximum = nullptr;
		pWrapperTable->m_DataSeries_GetAllEntries = nullptr;
		pWrapperTable->m_DataSeries_SetAllEntries = nullptr;
		pWrapperTable->m_DataSeries_SampleJournalVariable = nullptr;
		pWrapperTable->m_DataSeries_GetVersion = nullptr;
		pWrapperTable->m_DataSeries_IncreaseVersion = nullptr;
		pWrapperTable->m_DateTimeDifference_ToMicroseconds = nullptr;
		pWrapperTable->m_DateTimeDifference_ToMilliseconds = nullptr;
		pWrapperTable->m_DateTimeDifference_ToSeconds = nullptr;
		pWrapperTable->m_DateTimeDifference_ToMinutes = nullptr;
		pWrapperTable->m_DateTimeDifference_ToHours = nullptr;
		pWrapperTable->m_DateTimeDifference_ToDays = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundDownToDay = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundDownToHour = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundDownToMinute = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundDownToSeconds = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundDownToMilliseconds = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundUpToDay = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundUpToHour = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundUpToMinute = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundUpToSeconds = nullptr;
		pWrapperTable->m_DateTimeDifference_RoundupToMilliseconds = nullptr;
		pWrapperTable->m_DateTime_ToMicrosecondsSince1970 = nullptr;
		pWrapperTable->m_DateTime_ToUnixTimestamp = nullptr;
		pWrapperTable->m_DateTime_ToUTCDateTime = nullptr;
		pWrapperTable->m_DateTime_ToUTCDateTimeInMilliseconds = nullptr;
		pWrapperTable->m_DateTime_ToUTCDateTimeInMicroseconds = nullptr;
		pWrapperTable->m_DateTime_GetDate = nullptr;
		pWrapperTable->m_DateTime_GetTime = nullptr;
		pWrapperTable->m_DateTime_Duplicate = nullptr;
		pWrapperTable->m_DateTime_IsLeapYear = nullptr;
		pWrapperTable->m_DateTime_IsLaterThan = nullptr;
		pWrapperTable->m_DateTime_IsEarlierThan = nullptr;
		pWrapperTable->m_DateTime_IsEqualTo = nullptr;
		pWrapperTable->m_DateTime_GetTimeDifference = nullptr;
		pWrapperTable->m_DateTime_AddDuration = nullptr;
		pWrapperTable->m_DateTime_SubtractDuration = nullptr;
		pWrapperTable->m_DateTime_ShiftByYears = nullptr;
		pWrapperTable->m_DateTime_ShiftByDays = nullptr;
		pWrapperTable->m_DateTime_ShiftByHours = nullptr;
		pWrapperTable->m_DateTime_ShiftByMinutes = nullptr;
		pWrapperTable->m_DateTime_ShiftBySeconds = nullptr;
		pWrapperTable->m_DateTime_ShiftByMilliseconds = nullptr;
		pWrapperTable->m_DateTime_ShiftByMicroseconds = nullptr;
		pWrapperTable->m_DateTime_RoundDownToYear = nullptr;
		pWrapperTable->m_DateTime_RoundDownToMonth = nullptr;
		pWrapperTable->m_DateTime_RoundDownToDay = nullptr;
		pWrapperTable->m_DateTime_RoundDownToHour = nullptr;
		pWrapperTable->m_DateTime_RoundDownToMinute = nullptr;
		pWrapperTable->m_DateTime_RoundDownToSeconds = nullptr;
		pWrapperTable->m_DateTime_RoundDownToMilliseconds = nullptr;
		pWrapperTable->m_DateTime_RoundUpToYear = nullptr;
		pWrapperTable->m_DateTime_RoundUpToMonth = nullptr;
		pWrapperTable->m_DateTime_RoundUpToDay = nullptr;
		pWrapperTable->m_DateTime_RoundUpToHour = nullptr;
		pWrapperTable->m_DateTime_RoundUpToMinute = nullptr;
		pWrapperTable->m_DateTime_RoundUpToSeconds = nullptr;
		pWrapperTable->m_DateTime_RoundUpToMilliseconds = nullptr;
		pWrapperTable->m_MeshObject_GetName = nullptr;
		pWrapperTable->m_MeshObject_GetUUID = nullptr;
		pWrapperTable->m_MeshObject_GetTriangleCount = nullptr;
		pWrapperTable->m_MeshObject_GetVertexCount = nullptr;
		pWrapperTable->m_MeshObject_IsManifold = nullptr;
		pWrapperTable->m_MeshObject_IsOriented = nullptr;
		pWrapperTable->m_MeshObject_IsWatertight = nullptr;
		pWrapperTable->m_MeshObject_GetMaxVertexID = nullptr;
		pWrapperTable->m_MeshObject_VertexExists = nullptr;
		pWrapperTable->m_MeshObject_GetVertex = nullptr;
		pWrapperTable->m_MeshObject_GetVertexIDs = nullptr;
		pWrapperTable->m_MeshObject_GetAllVertices = nullptr;
		pWrapperTable->m_MeshObject_GetMaxTriangleID = nullptr;
		pWrapperTable->m_MeshObject_TriangeExists = nullptr;
		pWrapperTable->m_MeshObject_GetTriangle = nullptr;
		pWrapperTable->m_MeshObject_GetTriangleIDs = nullptr;
		pWrapperTable->m_MeshObject_GetAllTriangles = nullptr;
		pWrapperTable->m_MeshObject_IsPersistent = nullptr;
		pWrapperTable->m_MeshObject_MakePersistent = nullptr;
		pWrapperTable->m_PersistentMeshObject_IsBoundToLoginSession = nullptr;
		pWrapperTable->m_ModelDataMeshInstance_GetName = nullptr;
		pWrapperTable->m_ModelDataMeshInstance_GetUUID = nullptr;
		pWrapperTable->m_ModelDataMeshInstance_GetLocalTransform = nullptr;
		pWrapperTable->m_ModelDataMeshInstance_GetAbsoluteTransform = nullptr;
		pWrapperTable->m_ModelDataMeshInstance_CreateCopiedMesh = nullptr;
		pWrapperTable->m_ModelDataMeshInstance_CreatePersistentMesh = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetName = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetUUID = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetLocalTransform = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetAbsoluteTransform = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetSolidCount = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetSolidMesh = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetSupportCount = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetSupportMesh = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetSubComponentCount = nullptr;
		pWrapperTable->m_ModelDataComponentInstance_GetSubComponent = nullptr;
		pWrapperTable->m_MeshSceneItem_GetItemUUID = nullptr;
		pWrapperTable->m_MeshSceneItem_GetSceneUUID = nullptr;
		pWrapperTable->m_MeshSceneItem_GetTransform = nullptr;
		pWrapperTable->m_MeshSceneItem_UpdateTransform = nullptr;
		pWrapperTable->m_MeshSceneItem_GetMeshObject = nullptr;
		pWrapperTable->m_MeshSceneItem_ReferenceIsValid = nullptr;
		pWrapperTable->m_MeshScene_GetSceneUUID = nullptr;
		pWrapperTable->m_MeshScene_IsBoundToLoginSession = nullptr;
		pWrapperTable->m_MeshScene_AddSceneItem = nullptr;
		pWrapperTable->m_MeshScene_AddModelDataMeshAsSceneItem = nullptr;
		pWrapperTable->m_MeshScene_GetSceneItemCount = nullptr;
		pWrapperTable->m_MeshScene_GetSceneItem = nullptr;
		pWrapperTable->m_MeshScene_FindSceneItem = nullptr;
		pWrapperTable->m_MeshScene_HasSceneItem = nullptr;
		pWrapperTable->m_MeshScene_RemoveSceneItem = nullptr;
		pWrapperTable->m_SceneHandler_MeshIsPersistent = nullptr;
		pWrapperTable->m_SceneHandler_FindPersistentMesh = nullptr;
		pWrapperTable->m_SceneHandler_CreateEmptyMeshScene = nullptr;
		pWrapperTable->m_SceneHandler_ReleaseMeshScene = nullptr;
		pWrapperTable->m_SceneHandler_Load3MFFromResource = nullptr;
		pWrapperTable->m_SceneHandler_Load3MFFromMemory = nullptr;
		pWrapperTable->m_SceneHandler_Load3MFFromStream = nullptr;
		pWrapperTable->m_ToolpathPart_GetName = nullptr;
		pWrapperTable->m_ToolpathPart_GetUUID = nullptr;
		pWrapperTable->m_ToolpathPart_GetRootComponent = nullptr;
		pWrapperTable->m_ToolpathLayer_GetLayerDataUUID = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentCount = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentInfo = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentType = nullptr;
		pWrapperTable->m_ToolpathLayer_SegmentIsLoop = nullptr;
		pWrapperTable->m_ToolpathLayer_SegmentIsPolyline = nullptr;
		pWrapperTable->m_ToolpathLayer_SegmentIsHatchSegment = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentIntegerAttribute = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentDoubleAttribute = nullptr;
		pWrapperTable->m_ToolpathLayer_HasCustomSegmentAttribute = nullptr;
		pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeID = nullptr;
		pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeType = nullptr;
		pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeInfo = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentPointCount = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentHatchCount = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID = nullptr;
		pWrapperTable->m_ToolpathLayer_SegmentProfileHasValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileValueDef = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValueDef = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValueDef = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValueDef = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValueDef = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentPointData = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentHatchData = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentPointDataInMM = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentHatchDataInMM = nullptr;
		pWrapperTable->m_ToolpathLayer_GetZValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetZValueInMM = nullptr;
		pWrapperTable->m_ToolpathLayer_GetUnits = nullptr;
		pWrapperTable->m_ToolpathLayer_GetMetaDataCount = nullptr;
		pWrapperTable->m_ToolpathLayer_GetMetaDataInfo = nullptr;
		pWrapperTable->m_ToolpathLayer_GetMetaDataContent = nullptr;
		pWrapperTable->m_ToolpathLayer_HasUniqueMetaData = nullptr;
		pWrapperTable->m_ToolpathLayer_FindUniqueMetaData = nullptr;
		pWrapperTable->m_ToolpathLayer_CalculateExtents = nullptr;
		pWrapperTable->m_ToolpathLayer_CalculateExtentsInMM = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetStorageUUID = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetBuildUUID = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetLayerCount = nullptr;
		pWrapperTable->m_ToolpathAccessor_RegisterCustomSegmentAttribute = nullptr;
		pWrapperTable->m_ToolpathAccessor_LoadLayer = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetUnits = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetPartCount = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetPart = nullptr;
		pWrapperTable->m_ToolpathAccessor_FindPartByUUID = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetBuildHeightInUnits = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetZValueInUnits = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetBuildHeightInMM = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetZValueInMM = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetMetaDataCount = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetMetaDataInfo = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetMetaDataContent = nullptr;
		pWrapperTable->m_ToolpathAccessor_HasUniqueMetaData = nullptr;
		pWrapperTable->m_ToolpathAccessor_FindUniqueMetaData = nullptr;
		pWrapperTable->m_BuildExecution_GetUUID = nullptr;
		pWrapperTable->m_BuildExecution_GetBuildUUID = nullptr;
		pWrapperTable->m_BuildExecution_GetBuild = nullptr;
		pWrapperTable->m_BuildExecution_GetExecutionStatus = nullptr;
		pWrapperTable->m_BuildExecution_IsInProcess = nullptr;
		pWrapperTable->m_BuildExecution_IsFinished = nullptr;
		pWrapperTable->m_BuildExecution_IsFailed = nullptr;
		pWrapperTable->m_BuildExecution_SetStatusToFinished = nullptr;
		pWrapperTable->m_BuildExecution_SetStatusToFailed = nullptr;
		pWrapperTable->m_BuildExecution_GetDescription = nullptr;
		pWrapperTable->m_BuildExecution_SetDescription = nullptr;
		pWrapperTable->m_BuildExecution_GetJournalUUID = nullptr;
		pWrapperTable->m_BuildExecution_HasAttachedUser = nullptr;
		pWrapperTable->m_BuildExecution_GetUserUUID = nullptr;
		pWrapperTable->m_BuildExecution_GetStartTimeStampInMilliseconds = nullptr;
		pWrapperTable->m_BuildExecution_GetStartTimeStampInMicroseconds = nullptr;
		pWrapperTable->m_BuildExecution_GetEndTimeStampInMilliseconds = nullptr;
		pWrapperTable->m_BuildExecution_GetEndTimeStampInMicroseconds = nullptr;
		pWrapperTable->m_BuildExecution_GetElapsedTimeInMilliseconds = nullptr;
		pWrapperTable->m_BuildExecution_GetElapsedTimeInMicroseconds = nullptr;
		pWrapperTable->m_BuildExecution_HasAttachment = nullptr;
		pWrapperTable->m_BuildExecution_HasAttachmentIdentifier = nullptr;
		pWrapperTable->m_BuildExecution_AddBinaryData = nullptr;
		pWrapperTable->m_BuildExecution_AttachTempStream = nullptr;
		pWrapperTable->m_BuildExecution_LoadStreamByIdentifier = nullptr;
		pWrapperTable->m_BuildExecution_LoadStreamByUUID = nullptr;
		pWrapperTable->m_BuildExecution_LoadDiscreteField2DByIdentifier = nullptr;
		pWrapperTable->m_BuildExecution_LoadDiscreteField2DByUUID = nullptr;
		pWrapperTable->m_BuildExecution_StoreDiscreteField2D = nullptr;
		pWrapperTable->m_BuildExecution_LoadDataTableByIdentifier = nullptr;
		pWrapperTable->m_BuildExecution_LoadDataTableByUUID = nullptr;
		pWrapperTable->m_BuildExecution_StoreDataTable = nullptr;
		pWrapperTable->m_BuildExecution_LoadPNGImageByIdentifier = nullptr;
		pWrapperTable->m_BuildExecution_LoadPNGImageByUUID = nullptr;
		pWrapperTable->m_BuildExecution_StorePNGImage = nullptr;
		pWrapperTable->m_BuildExecution_StoreMetaDataString = nullptr;
		pWrapperTable->m_BuildExecution_HasMetaDataString = nullptr;
		pWrapperTable->m_BuildExecution_GetMetaDataString = nullptr;
		pWrapperTable->m_BuildExecution_LoadAttachedJournal = nullptr;
		pWrapperTable->m_BuildExecutionIterator_GetCurrentExecution = nullptr;
		pWrapperTable->m_Build_GetName = nullptr;
		pWrapperTable->m_Build_GetBuildUUID = nullptr;
		pWrapperTable->m_Build_GetStorageUUID = nullptr;
		pWrapperTable->m_Build_GetStorageSHA256 = nullptr;
		pWrapperTable->m_Build_GetLayerCount = nullptr;
		pWrapperTable->m_Build_GetBuildHeightInMM = nullptr;
		pWrapperTable->m_Build_GetZValueInMM = nullptr;
		pWrapperTable->m_Build_LoadToolpath = nullptr;
		pWrapperTable->m_Build_UnloadToolpath = nullptr;
		pWrapperTable->m_Build_ToolpathIsLoaded = nullptr;
		pWrapperTable->m_Build_CreateToolpathAccessor = nullptr;
		pWrapperTable->m_Build_HasAttachment = nullptr;
		pWrapperTable->m_Build_HasAttachmentIdentifier = nullptr;
		pWrapperTable->m_Build_AddBinaryData = nullptr;
		pWrapperTable->m_Build_AttachTempStream = nullptr;
		pWrapperTable->m_Build_LoadStreamByIdentifier = nullptr;
		pWrapperTable->m_Build_LoadStreamByUUID = nullptr;
		pWrapperTable->m_Build_LoadDiscreteField2DByIdentifier = nullptr;
		pWrapperTable->m_Build_LoadDiscreteField2DByUUID = nullptr;
		pWrapperTable->m_Build_StoreDiscreteField2D = nullptr;
		pWrapperTable->m_Build_LoadDataTableByIdentifier = nullptr;
		pWrapperTable->m_Build_LoadDataTableByUUID = nullptr;
		pWrapperTable->m_Build_StoreDataTable = nullptr;
		pWrapperTable->m_Build_LoadPNGImageByIdentifier = nullptr;
		pWrapperTable->m_Build_LoadPNGImageByUUID = nullptr;
		pWrapperTable->m_Build_StorePNGImage = nullptr;
		pWrapperTable->m_Build_StartExecution = nullptr;
		pWrapperTable->m_Build_HasExecution = nullptr;
		pWrapperTable->m_Build_FindExecution = nullptr;
		pWrapperTable->m_Build_ListExecutions = nullptr;
		pWrapperTable->m_Build_ListExecutionsByStatus = nullptr;
		pWrapperTable->m_Build_StoreMetaDataString = nullptr;
		pWrapperTable->m_Build_HasMetaDataString = nullptr;
		pWrapperTable->m_Build_GetMetaDataString = nullptr;
		pWrapperTable->m_WorkingFileExecution_GetStatus = nullptr;
		pWrapperTable->m_WorkingFileExecution_ReturnStdOut = nullptr;
		pWrapperTable->m_WorkingFile_GetAbsoluteFileName = nullptr;
		pWrapperTable->m_WorkingFile_GetSize = nullptr;
		pWrapperTable->m_WorkingFile_CalculateSHA2 = nullptr;
		pWrapperTable->m_WorkingFile_ExecuteFile = nullptr;
		pWrapperTable->m_WorkingFile_IsManaged = nullptr;
		pWrapperTable->m_WorkingFile_MakeManaged = nullptr;
		pWrapperTable->m_WorkingFile_FileExists = nullptr;
		pWrapperTable->m_WorkingFile_DeleteFromDisk = nullptr;
		pWrapperTable->m_WorkingFileIterator_GetCurrentFile = nullptr;
		pWrapperTable->m_WorkingDirectory_IsActive = nullptr;
		pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath = nullptr;
		pWrapperTable->m_WorkingDirectory_StoreCustomData = nullptr;
		pWrapperTable->m_WorkingDirectory_StoreCustomString = nullptr;
		pWrapperTable->m_WorkingDirectory_StoreDriverData = nullptr;
		pWrapperTable->m_WorkingDirectory_StoreCustomDataInTempFile = nullptr;
		pWrapperTable->m_WorkingDirectory_StoreCustomStringInTempFile = nullptr;
		pWrapperTable->m_WorkingDirectory_StoreDriverDataInTempFile = nullptr;
		pWrapperTable->m_WorkingDirectory_CleanUp = nullptr;
		pWrapperTable->m_WorkingDirectory_AddManagedFile = nullptr;
		pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles = nullptr;
		pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles = nullptr;
		pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles = nullptr;
		pWrapperTable->m_WorkingDirectory_RetrieveAllFiles = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_GetNameSpace = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_GetName = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_GetValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_IsValidUUID = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_GetUUIDValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_IsValidInteger = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_GetIntegerValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_IsValidDouble = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_GetDoubleValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_IsValidBool = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_GetBoolValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_SetValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_SetUUIDValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_SetIntegerValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_SetDoubleValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_SetBoolValue = nullptr;
		pWrapperTable->m_XMLDocumentAttribute_Remove = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetName = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetNameSpace = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetTextContent = nullptr;
		pWrapperTable->m_XMLDocumentNode_SetTextContent = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeCount = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttribute = nullptr;
		pWrapperTable->m_XMLDocumentNode_HasAttribute = nullptr;
		pWrapperTable->m_XMLDocumentNode_FindAttribute = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeValue = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValue = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValue = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValue = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValue = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeValueDef = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValueDef = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValueDef = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValueDef = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValueDef = nullptr;
		pWrapperTable->m_XMLDocumentNode_RemoveAttribute = nullptr;
		pWrapperTable->m_XMLDocumentNode_RemoveAttributeByIndex = nullptr;
		pWrapperTable->m_XMLDocumentNode_AddAttribute = nullptr;
		pWrapperTable->m_XMLDocumentNode_AddIntegerAttribute = nullptr;
		pWrapperTable->m_XMLDocumentNode_AddDoubleAttribute = nullptr;
		pWrapperTable->m_XMLDocumentNode_AddBoolAttribute = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetChildren = nullptr;
		pWrapperTable->m_XMLDocumentNode_CountChildrenByName = nullptr;
		pWrapperTable->m_XMLDocumentNode_GetChildrenByName = nullptr;
		pWrapperTable->m_XMLDocumentNode_HasChild = nullptr;
		pWrapperTable->m_XMLDocumentNode_HasUniqueChild = nullptr;
		pWrapperTable->m_XMLDocumentNode_FindChild = nullptr;
		pWrapperTable->m_XMLDocumentNode_AddChild = nullptr;
		pWrapperTable->m_XMLDocumentNode_AddChildText = nullptr;
		pWrapperTable->m_XMLDocumentNode_RemoveChild = nullptr;
		pWrapperTable->m_XMLDocumentNode_RemoveChildrenWithName = nullptr;
		pWrapperTable->m_XMLDocumentNode_Remove = nullptr;
		pWrapperTable->m_XMLDocumentNodes_GetNodeCount = nullptr;
		pWrapperTable->m_XMLDocumentNodes_GetNode = nullptr;
		pWrapperTable->m_XMLDocumentNodes_CountNodesByName = nullptr;
		pWrapperTable->m_XMLDocumentNodes_GetNodesByName = nullptr;
		pWrapperTable->m_XMLDocumentNodes_HasNode = nullptr;
		pWrapperTable->m_XMLDocumentNodes_HasUniqueNode = nullptr;
		pWrapperTable->m_XMLDocumentNodes_FindNode = nullptr;
		pWrapperTable->m_XMLDocument_GetDefaultNamespace = nullptr;
		pWrapperTable->m_XMLDocument_GetNamespaceCount = nullptr;
		pWrapperTable->m_XMLDocument_GetNamespace = nullptr;
		pWrapperTable->m_XMLDocument_HasNamespace = nullptr;
		pWrapperTable->m_XMLDocument_GetNamespacePrefix = nullptr;
		pWrapperTable->m_XMLDocument_RegisterNamespace = nullptr;
		pWrapperTable->m_XMLDocument_ChangeNamespacePrefix = nullptr;
		pWrapperTable->m_XMLDocument_GetRootNode = nullptr;
		pWrapperTable->m_XMLDocument_SaveToString = nullptr;
		pWrapperTable->m_TCPIPPacket_IsEmpty = nullptr;
		pWrapperTable->m_TCPIPPacket_GetSize = nullptr;
		pWrapperTable->m_TCPIPPacket_GetData = nullptr;
		pWrapperTable->m_TCPIPConnection_GetIPAddress = nullptr;
		pWrapperTable->m_TCPIPConnection_GetPort = nullptr;
		pWrapperTable->m_TCPIPConnection_GetTimeout = nullptr;
		pWrapperTable->m_TCPIPConnection_IsConnected = nullptr;
		pWrapperTable->m_TCPIPConnection_Disconnect = nullptr;
		pWrapperTable->m_TCPIPConnection_Reconnect = nullptr;
		pWrapperTable->m_TCPIPConnection_SendBuffer = nullptr;
		pWrapperTable->m_TCPIPConnection_WaitForData = nullptr;
		pWrapperTable->m_TCPIPConnection_ReceiveFixedPacket = nullptr;
		pWrapperTable->m_TCPIPConnection_ReceiveData = nullptr;
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetCount = nullptr;
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetBaseAddress = nullptr;
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValue = nullptr;
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValues = nullptr;
		pWrapperTable->m_ModbusTCPRegisterStatus_GetCount = nullptr;
		pWrapperTable->m_ModbusTCPRegisterStatus_GetBaseAddress = nullptr;
		pWrapperTable->m_ModbusTCPRegisterStatus_GetValue = nullptr;
		pWrapperTable->m_ModbusTCPRegisterStatus_GetValues = nullptr;
		pWrapperTable->m_ModbusTCPConnection_GetIPAddress = nullptr;
		pWrapperTable->m_ModbusTCPConnection_GetPort = nullptr;
		pWrapperTable->m_ModbusTCPConnection_GetTimeout = nullptr;
		pWrapperTable->m_ModbusTCPConnection_IsConnected = nullptr;
		pWrapperTable->m_ModbusTCPConnection_Disconnect = nullptr;
		pWrapperTable->m_ModbusTCPConnection_Reconnect = nullptr;
		pWrapperTable->m_ModbusTCPConnection_DiagnosisCall = nullptr;
		pWrapperTable->m_ModbusTCPConnection_ReadCoilStatus = nullptr;
		pWrapperTable->m_ModbusTCPConnection_ReadInputStatus = nullptr;
		pWrapperTable->m_ModbusTCPConnection_ReadHoldingRegisters = nullptr;
		pWrapperTable->m_ModbusTCPConnection_ReadInputRegisters = nullptr;
		pWrapperTable->m_ModbusTCPConnection_ForceMultipleCoils = nullptr;
		pWrapperTable->m_ModbusTCPConnection_PresetMultipleRegisters = nullptr;
		pWrapperTable->m_DriverStatusUpdateSession_SetStringParameter = nullptr;
		pWrapperTable->m_DriverStatusUpdateSession_SetUUIDParameter = nullptr;
		pWrapperTable->m_DriverStatusUpdateSession_SetDoubleParameter = nullptr;
		pWrapperTable->m_DriverStatusUpdateSession_SetIntegerParameter = nullptr;
		pWrapperTable->m_DriverStatusUpdateSession_SetBoolParameter = nullptr;
		pWrapperTable->m_DriverStatusUpdateSession_LogMessage = nullptr;
		pWrapperTable->m_DriverStatusUpdateSession_LogWarning = nullptr;
		pWrapperTable->m_DriverStatusUpdateSession_LogInfo = nullptr;
		pWrapperTable->m_DriverStatusUpdateSession_Sleep = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateStatusUpdateSession = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateTCPIPConnection = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateModbusTCPConnection = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateXMLDocument = nullptr;
		pWrapperTable->m_DriverEnvironment_ParseXMLString = nullptr;
		pWrapperTable->m_DriverEnvironment_ParseXMLData = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateDataTable = nullptr;
		pWrapperTable->m_DriverEnvironment_DriverHasResourceData = nullptr;
		pWrapperTable->m_DriverEnvironment_MachineHasResourceData = nullptr;
		pWrapperTable->m_DriverEnvironment_RetrieveDriverData = nullptr;
		pWrapperTable->m_DriverEnvironment_RetrieveDriverResourceData = nullptr;
		pWrapperTable->m_DriverEnvironment_RetrieveMachineResourceData = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor = nullptr;
		pWrapperTable->m_DriverEnvironment_ParameterNameIsValid = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterStringParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterDoubleParameterWithUnits = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterBoolParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetStringParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetUUIDParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetDoubleParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetIntegerParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetBoolParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_Sleep = nullptr;
		pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMilliseconds = nullptr;
		pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMicroseconds = nullptr;
		pWrapperTable->m_DriverEnvironment_LogMessage = nullptr;
		pWrapperTable->m_DriverEnvironment_LogWarning = nullptr;
		pWrapperTable->m_DriverEnvironment_LogInfo = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateEmptyImage = nullptr;
		pWrapperTable->m_DriverEnvironment_LoadPNGImage = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateDiscreteField2D = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateDiscreteField2DFromImage = nullptr;
		pWrapperTable->m_DriverEnvironment_HasBuildJob = nullptr;
		pWrapperTable->m_DriverEnvironment_GetBuildJob = nullptr;
		pWrapperTable->m_DriverEnvironment_HasBuildExecution = nullptr;
		pWrapperTable->m_DriverEnvironment_GetBuildExecution = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateCryptoContext = nullptr;
		pWrapperTable->m_DriverEnvironment_GetCurrentDateTime = nullptr;
		pWrapperTable->m_DriverEnvironment_GetCustomDateTime = nullptr;
		pWrapperTable->m_DriverEnvironment_GetStartDateTime = nullptr;
		pWrapperTable->m_SignalTrigger_CanTrigger = nullptr;
		pWrapperTable->m_SignalTrigger_Trigger = nullptr;
		pWrapperTable->m_SignalTrigger_WaitForHandling = nullptr;
		pWrapperTable->m_SignalTrigger_GetName = nullptr;
		pWrapperTable->m_SignalTrigger_GetStateMachine = nullptr;
		pWrapperTable->m_SignalTrigger_SetString = nullptr;
		pWrapperTable->m_SignalTrigger_SetUUID = nullptr;
		pWrapperTable->m_SignalTrigger_SetDouble = nullptr;
		pWrapperTable->m_SignalTrigger_SetInteger = nullptr;
		pWrapperTable->m_SignalTrigger_SetBool = nullptr;
		pWrapperTable->m_SignalTrigger_GetStringResult = nullptr;
		pWrapperTable->m_SignalTrigger_GetUUIDResult = nullptr;
		pWrapperTable->m_SignalTrigger_GetDoubleResult = nullptr;
		pWrapperTable->m_SignalTrigger_GetIntegerResult = nullptr;
		pWrapperTable->m_SignalTrigger_GetBoolResult = nullptr;
		pWrapperTable->m_SignalHandler_SignalHandled = nullptr;
		pWrapperTable->m_SignalHandler_GetName = nullptr;
		pWrapperTable->m_SignalHandler_GetSignalID = nullptr;
		pWrapperTable->m_SignalHandler_GetSignalUUID = nullptr;
		pWrapperTable->m_SignalHandler_GetStateMachine = nullptr;
		pWrapperTable->m_SignalHandler_GetString = nullptr;
		pWrapperTable->m_SignalHandler_GetUUID = nullptr;
		pWrapperTable->m_SignalHandler_GetDouble = nullptr;
		pWrapperTable->m_SignalHandler_GetInteger = nullptr;
		pWrapperTable->m_SignalHandler_GetBool = nullptr;
		pWrapperTable->m_SignalHandler_SetStringResult = nullptr;
		pWrapperTable->m_SignalHandler_SetUUIDResult = nullptr;
		pWrapperTable->m_SignalHandler_SetDoubleResult = nullptr;
		pWrapperTable->m_SignalHandler_SetIntegerResult = nullptr;
		pWrapperTable->m_SignalHandler_SetBoolResult = nullptr;
		pWrapperTable->m_BaseTempStreamWriter_GetUUID = nullptr;
		pWrapperTable->m_BaseTempStreamWriter_GetName = nullptr;
		pWrapperTable->m_BaseTempStreamWriter_GetMIMEType = nullptr;
		pWrapperTable->m_BaseTempStreamWriter_GetSize = nullptr;
		pWrapperTable->m_BaseTempStreamWriter_Finish = nullptr;
		pWrapperTable->m_BaseTempStreamWriter_IsFinished = nullptr;
		pWrapperTable->m_BaseTempStreamWriter_GetStreamReader = nullptr;
		pWrapperTable->m_TempStreamWriter_GetWritePosition = nullptr;
		pWrapperTable->m_TempStreamWriter_Seek = nullptr;
		pWrapperTable->m_TempStreamWriter_WriteData = nullptr;
		pWrapperTable->m_TempStreamWriter_WriteString = nullptr;
		pWrapperTable->m_TempStreamWriter_WriteLine = nullptr;
		pWrapperTable->m_TempStreamWriter_CopyFrom = nullptr;
		pWrapperTable->m_ZIPStreamWriter_CreateZIPEntry = nullptr;
		pWrapperTable->m_ZIPStreamWriter_CreateZIPEntryFromStream = nullptr;
		pWrapperTable->m_StreamReader_GetUUID = nullptr;
		pWrapperTable->m_StreamReader_GetName = nullptr;
		pWrapperTable->m_StreamReader_GetMIMEType = nullptr;
		pWrapperTable->m_StreamReader_GetSize = nullptr;
		pWrapperTable->m_StreamReader_GetReadPosition = nullptr;
		pWrapperTable->m_StreamReader_Seek = nullptr;
		pWrapperTable->m_StreamReader_ReadData = nullptr;
		pWrapperTable->m_StreamReader_ReadAllData = nullptr;
		pWrapperTable->m_UniformJournalSampling_GetVariableName = nullptr;
		pWrapperTable->m_UniformJournalSampling_GetNumberOfSamples = nullptr;
		pWrapperTable->m_UniformJournalSampling_GetStartTimeStamp = nullptr;
		pWrapperTable->m_UniformJournalSampling_GetEndTimeStamp = nullptr;
		pWrapperTable->m_UniformJournalSampling_GetSample = nullptr;
		pWrapperTable->m_UniformJournalSampling_GetAllSamples = nullptr;
		pWrapperTable->m_JournalVariable_GetVariableName = nullptr;
		pWrapperTable->m_JournalVariable_GetStartTimeStamp = nullptr;
		pWrapperTable->m_JournalVariable_GetEndTimeStamp = nullptr;
		pWrapperTable->m_JournalVariable_ComputeFullAverage = nullptr;
		pWrapperTable->m_JournalVariable_ComputeAverage = nullptr;
		pWrapperTable->m_JournalVariable_ComputeSample = nullptr;
		pWrapperTable->m_JournalVariable_ComputeUniformAverageSamples = nullptr;
		pWrapperTable->m_JournalVariable_ComputeEquidistantSamples = nullptr;
		pWrapperTable->m_JournalVariable_ReceiveRawTimeStream = nullptr;
		pWrapperTable->m_Alert_GetUUID = nullptr;
		pWrapperTable->m_Alert_IsActive = nullptr;
		pWrapperTable->m_Alert_GetAlertLevel = nullptr;
		pWrapperTable->m_Alert_GetIdentifier = nullptr;
		pWrapperTable->m_Alert_GetReadableContextInformation = nullptr;
		pWrapperTable->m_Alert_NeedsAcknowledgement = nullptr;
		pWrapperTable->m_Alert_HasBeenAcknowledged = nullptr;
		pWrapperTable->m_Alert_GetAcknowledgementInformation = nullptr;
		pWrapperTable->m_Alert_GetAcknowledgementTime = nullptr;
		pWrapperTable->m_Alert_AcknowledgeForUser = nullptr;
		pWrapperTable->m_Alert_AcknowledgeAlertForCurrentUser = nullptr;
		pWrapperTable->m_Alert_DeactivateAlert = nullptr;
		pWrapperTable->m_AlertIterator_GetCurrentAlert = nullptr;
		pWrapperTable->m_LogEntryList_GetCount = nullptr;
		pWrapperTable->m_LogEntryList_GetEntry = nullptr;
		pWrapperTable->m_LogEntryList_GetEntryTime = nullptr;
		pWrapperTable->m_JournalHandler_RetrieveJournalVariable = nullptr;
		pWrapperTable->m_JournalHandler_RetrieveJournalVariableFromTimeInterval = nullptr;
		pWrapperTable->m_JournalHandler_GetStartTime = nullptr;
		pWrapperTable->m_JournalHandler_RetrieveLogEntries = nullptr;
		pWrapperTable->m_JournalHandler_RetrieveLogEntriesFromTimeInterval = nullptr;
		pWrapperTable->m_JournalHandler_RetrieveAlerts = nullptr;
		pWrapperTable->m_JournalHandler_RetrieveAlertsFromTimeInterval = nullptr;
		pWrapperTable->m_UserDetailList_Count = nullptr;
		pWrapperTable->m_UserDetailList_GetUserProperties = nullptr;
		pWrapperTable->m_UserDetailList_GetUsername = nullptr;
		pWrapperTable->m_UserDetailList_GetUUID = nullptr;
		pWrapperTable->m_UserDetailList_GetDescription = nullptr;
		pWrapperTable->m_UserDetailList_GetRole = nullptr;
		pWrapperTable->m_UserDetailList_GetLanguage = nullptr;
		pWrapperTable->m_UserManagementHandler_UserExists = nullptr;
		pWrapperTable->m_UserManagementHandler_UserUUIDExists = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUserProperties = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUserPropertiesByUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUsernameByUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUserUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUserDescription = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUserDescriptionByUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUserRole = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUserRoleByUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUserLanguage = nullptr;
		pWrapperTable->m_UserManagementHandler_GetUserLanguageByUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_CreateUser = nullptr;
		pWrapperTable->m_UserManagementHandler_SetUserLanguage = nullptr;
		pWrapperTable->m_UserManagementHandler_SetUserRole = nullptr;
		pWrapperTable->m_UserManagementHandler_SetUserDescription = nullptr;
		pWrapperTable->m_UserManagementHandler_SetUserPassword = nullptr;
		pWrapperTable->m_UserManagementHandler_SetUserLanguageByUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_SetUserRoleByUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_SetUserDescriptionByUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_SetUserPasswordByUUID = nullptr;
		pWrapperTable->m_UserManagementHandler_GetActiveUsers = nullptr;
		pWrapperTable->m_StateEnvironment_GetMachineState = nullptr;
		pWrapperTable->m_StateEnvironment_GetPreviousState = nullptr;
		pWrapperTable->m_StateEnvironment_PrepareSignal = nullptr;
		pWrapperTable->m_StateEnvironment_WaitForSignal = nullptr;
		pWrapperTable->m_StateEnvironment_GetUnhandledSignal = nullptr;
		pWrapperTable->m_StateEnvironment_GetUnhandledSignalByUUID = nullptr;
		pWrapperTable->m_StateEnvironment_GetDriverLibrary = nullptr;
		pWrapperTable->m_StateEnvironment_CreateDriverAccess = nullptr;
		pWrapperTable->m_StateEnvironment_HasBuildJob = nullptr;
		pWrapperTable->m_StateEnvironment_GetBuildJob = nullptr;
		pWrapperTable->m_StateEnvironment_HasBuildExecution = nullptr;
		pWrapperTable->m_StateEnvironment_GetBuildExecution = nullptr;
		pWrapperTable->m_StateEnvironment_UnloadAllToolpathes = nullptr;
		pWrapperTable->m_StateEnvironment_SetNextState = nullptr;
		pWrapperTable->m_StateEnvironment_LogMessage = nullptr;
		pWrapperTable->m_StateEnvironment_LogWarning = nullptr;
		pWrapperTable->m_StateEnvironment_LogInfo = nullptr;
		pWrapperTable->m_StateEnvironment_Sleep = nullptr;
		pWrapperTable->m_StateEnvironment_CheckForTermination = nullptr;
		pWrapperTable->m_StateEnvironment_StoreSignal = nullptr;
		pWrapperTable->m_StateEnvironment_RetrieveSignal = nullptr;
		pWrapperTable->m_StateEnvironment_ClearStoredValue = nullptr;
		pWrapperTable->m_StateEnvironment_SetStringParameter = nullptr;
		pWrapperTable->m_StateEnvironment_SetUUIDParameter = nullptr;
		pWrapperTable->m_StateEnvironment_SetDoubleParameter = nullptr;
		pWrapperTable->m_StateEnvironment_SetIntegerParameter = nullptr;
		pWrapperTable->m_StateEnvironment_SetBoolParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetStringParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetUUIDParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetDoubleParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetIntegerParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetBoolParameter = nullptr;
		pWrapperTable->m_StateEnvironment_LoadResourceData = nullptr;
		pWrapperTable->m_StateEnvironment_LoadResourceString = nullptr;
		pWrapperTable->m_StateEnvironment_CreateEmptyImage = nullptr;
		pWrapperTable->m_StateEnvironment_LoadPNGImage = nullptr;
		pWrapperTable->m_StateEnvironment_CreateDiscreteField2D = nullptr;
		pWrapperTable->m_StateEnvironment_CreateDiscreteField2DFromImage = nullptr;
		pWrapperTable->m_StateEnvironment_GetGlobalTimerInMilliseconds = nullptr;
		pWrapperTable->m_StateEnvironment_GetGlobalTimerInMicroseconds = nullptr;
		pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMilliseconds = nullptr;
		pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMicroseconds = nullptr;
		pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMicroseconds = nullptr;
		pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMilliseconds = nullptr;
		pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMilliseconds = nullptr;
		pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMicroseconds = nullptr;
		pWrapperTable->m_StateEnvironment_GetCurrentDateTime = nullptr;
		pWrapperTable->m_StateEnvironment_GetCustomDateTime = nullptr;
		pWrapperTable->m_StateEnvironment_GetStartDateTime = nullptr;
		pWrapperTable->m_StateEnvironment_GetTestEnvironment = nullptr;
		pWrapperTable->m_StateEnvironment_CreateXMLDocument = nullptr;
		pWrapperTable->m_StateEnvironment_ParseXMLString = nullptr;
		pWrapperTable->m_StateEnvironment_ParseXMLData = nullptr;
		pWrapperTable->m_StateEnvironment_CreateDataTable = nullptr;
		pWrapperTable->m_StateEnvironment_CheckUserPermission = nullptr;
		pWrapperTable->m_StateEnvironment_CreateUserManagement = nullptr;
		pWrapperTable->m_StateEnvironment_GetCurrentJournal = nullptr;
		pWrapperTable->m_StateEnvironment_CreateSceneHandler = nullptr;
		pWrapperTable->m_StateEnvironment_CreateDataSeries = nullptr;
		pWrapperTable->m_StateEnvironment_HasDataSeries = nullptr;
		pWrapperTable->m_StateEnvironment_FindDataSeries = nullptr;
		pWrapperTable->m_StateEnvironment_ReleaseDataSeries = nullptr;
		pWrapperTable->m_StateEnvironment_CreateAlert = nullptr;
		pWrapperTable->m_StateEnvironment_FindAlert = nullptr;
		pWrapperTable->m_StateEnvironment_AlertExists = nullptr;
		pWrapperTable->m_StateEnvironment_RetrieveAlerts = nullptr;
		pWrapperTable->m_StateEnvironment_RetrieveAlertsByType = nullptr;
		pWrapperTable->m_StateEnvironment_HasAlertOfType = nullptr;
		pWrapperTable->m_StateEnvironment_CreateCryptoContext = nullptr;
		pWrapperTable->m_StateEnvironment_CreateTemporaryStream = nullptr;
		pWrapperTable->m_StateEnvironment_CreateZIPStream = nullptr;
		pWrapperTable->m_StateEnvironment_LoadStream = nullptr;
		pWrapperTable->m_UIItem_GetName = nullptr;
		pWrapperTable->m_UIItem_GetPath = nullptr;
		pWrapperTable->m_UIItem_GetUUID = nullptr;
		pWrapperTable->m_UIEnvironment_ActivateModalDialog = nullptr;
		pWrapperTable->m_UIEnvironment_CloseModalDialog = nullptr;
		pWrapperTable->m_UIEnvironment_ActivatePage = nullptr;
		pWrapperTable->m_UIEnvironment_LogOut = nullptr;
		pWrapperTable->m_UIEnvironment_ShowHint = nullptr;
		pWrapperTable->m_UIEnvironment_ShowHintColored = nullptr;
		pWrapperTable->m_UIEnvironment_HideHint = nullptr;
		pWrapperTable->m_UIEnvironment_StartStreamDownload = nullptr;
		pWrapperTable->m_UIEnvironment_ShowMessageDlg = nullptr;
		pWrapperTable->m_UIEnvironment_RetrieveEventSender = nullptr;
		pWrapperTable->m_UIEnvironment_RetrieveEventSenderPage = nullptr;
		pWrapperTable->m_UIEnvironment_RetrieveEventSenderUUID = nullptr;
		pWrapperTable->m_UIEnvironment_PrepareSignal = nullptr;
		pWrapperTable->m_UIEnvironment_GetMachineState = nullptr;
		pWrapperTable->m_UIEnvironment_LogMessage = nullptr;
		pWrapperTable->m_UIEnvironment_LogWarning = nullptr;
		pWrapperTable->m_UIEnvironment_LogInfo = nullptr;
		pWrapperTable->m_UIEnvironment_GetMachineParameter = nullptr;
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsUUID = nullptr;
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsDouble = nullptr;
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsInteger = nullptr;
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsBool = nullptr;
		pWrapperTable->m_UIEnvironment_GetUIProperty = nullptr;
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsUUID = nullptr;
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsDouble = nullptr;
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsInteger = nullptr;
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsBool = nullptr;
		pWrapperTable->m_UIEnvironment_SetUIProperty = nullptr;
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsUUID = nullptr;
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsDouble = nullptr;
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsInteger = nullptr;
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsBool = nullptr;
		pWrapperTable->m_UIEnvironment_CreateEmptyImage = nullptr;
		pWrapperTable->m_UIEnvironment_LoadPNGImage = nullptr;
		pWrapperTable->m_UIEnvironment_GetGlobalTimerInMilliseconds = nullptr;
		pWrapperTable->m_UIEnvironment_GetGlobalTimerInMicroseconds = nullptr;
		pWrapperTable->m_UIEnvironment_GetTestEnvironment = nullptr;
		pWrapperTable->m_UIEnvironment_CreateXMLDocument = nullptr;
		pWrapperTable->m_UIEnvironment_ParseXMLString = nullptr;
		pWrapperTable->m_UIEnvironment_ParseXMLData = nullptr;
		pWrapperTable->m_UIEnvironment_CreateDataTable = nullptr;
		pWrapperTable->m_UIEnvironment_HasBuildJob = nullptr;
		pWrapperTable->m_UIEnvironment_GetBuildJob = nullptr;
		pWrapperTable->m_UIEnvironment_HasBuildExecution = nullptr;
		pWrapperTable->m_UIEnvironment_GetBuildExecution = nullptr;
		pWrapperTable->m_UIEnvironment_CreateDiscreteField2D = nullptr;
		pWrapperTable->m_UIEnvironment_CreateDiscreteField2DFromImage = nullptr;
		pWrapperTable->m_UIEnvironment_CheckPermission = nullptr;
		pWrapperTable->m_UIEnvironment_GetCurrentUserLogin = nullptr;
		pWrapperTable->m_UIEnvironment_GetCurrentUserDescription = nullptr;
		pWrapperTable->m_UIEnvironment_GetCurrentUserRole = nullptr;
		pWrapperTable->m_UIEnvironment_GetCurrentUserLanguage = nullptr;
		pWrapperTable->m_UIEnvironment_GetCurrentUserUUID = nullptr;
		pWrapperTable->m_UIEnvironment_CreateUserManagement = nullptr;
		pWrapperTable->m_UIEnvironment_GetCurrentJournal = nullptr;
		pWrapperTable->m_UIEnvironment_CreateSceneHandler = nullptr;
		pWrapperTable->m_UIEnvironment_CreateDataSeries = nullptr;
		pWrapperTable->m_UIEnvironment_HasDataSeries = nullptr;
		pWrapperTable->m_UIEnvironment_FindDataSeries = nullptr;
		pWrapperTable->m_UIEnvironment_ReleaseDataSeries = nullptr;
		pWrapperTable->m_UIEnvironment_CreateAlert = nullptr;
		pWrapperTable->m_UIEnvironment_FindAlert = nullptr;
		pWrapperTable->m_UIEnvironment_AlertExists = nullptr;
		pWrapperTable->m_UIEnvironment_RetrieveAlerts = nullptr;
		pWrapperTable->m_UIEnvironment_RetrieveAlertsByType = nullptr;
		pWrapperTable->m_UIEnvironment_HasAlertOfType = nullptr;
		pWrapperTable->m_UIEnvironment_CreateCryptoContext = nullptr;
		pWrapperTable->m_UIEnvironment_CreateTemporaryStream = nullptr;
		pWrapperTable->m_UIEnvironment_CreateZIPStream = nullptr;
		pWrapperTable->m_UIEnvironment_LoadStream = nullptr;
		pWrapperTable->m_UIEnvironment_GetCurrentDateTime = nullptr;
		pWrapperTable->m_UIEnvironment_GetCustomDateTime = nullptr;
		pWrapperTable->m_UIEnvironment_GetStartDateTime = nullptr;
		pWrapperTable->m_UIEnvironment_Sleep = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		
		return LIBMCENV_SUCCESS;
	}

	inline LibMCEnvResult CWrapper::releaseWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCENV_SUCCESS;
	}

	inline LibMCEnvResult CWrapper::loadWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCENV_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCENV_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCENV_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCEnvIterator_MoveNextPtr) GetProcAddress(hLibrary, "libmcenv_iterator_movenext");
		#else // _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCEnvIterator_MoveNextPtr) dlsym(hLibrary, "libmcenv_iterator_movenext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MoveNext == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCEnvIterator_MovePreviousPtr) GetProcAddress(hLibrary, "libmcenv_iterator_moveprevious");
		#else // _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCEnvIterator_MovePreviousPtr) dlsym(hLibrary, "libmcenv_iterator_moveprevious");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MovePrevious == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCEnvIterator_GetCurrentPtr) GetProcAddress(hLibrary, "libmcenv_iterator_getcurrent");
		#else // _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCEnvIterator_GetCurrentPtr) dlsym(hLibrary, "libmcenv_iterator_getcurrent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_GetCurrent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCEnvIterator_ClonePtr) GetProcAddress(hLibrary, "libmcenv_iterator_clone");
		#else // _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCEnvIterator_ClonePtr) dlsym(hLibrary, "libmcenv_iterator_clone");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Clone == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCEnvIterator_CountPtr) GetProcAddress(hLibrary, "libmcenv_iterator_count");
		#else // _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCEnvIterator_CountPtr) dlsym(hLibrary, "libmcenv_iterator_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Count == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TestEnvironment_WriteTestOutput = (PLibMCEnvTestEnvironment_WriteTestOutputPtr) GetProcAddress(hLibrary, "libmcenv_testenvironment_writetestoutput");
		#else // _WIN32
		pWrapperTable->m_TestEnvironment_WriteTestOutput = (PLibMCEnvTestEnvironment_WriteTestOutputPtr) dlsym(hLibrary, "libmcenv_testenvironment_writetestoutput");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TestEnvironment_WriteTestOutput == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CryptoContext_CalculateSHA256FromString = (PLibMCEnvCryptoContext_CalculateSHA256FromStringPtr) GetProcAddress(hLibrary, "libmcenv_cryptocontext_calculatesha256fromstring");
		#else // _WIN32
		pWrapperTable->m_CryptoContext_CalculateSHA256FromString = (PLibMCEnvCryptoContext_CalculateSHA256FromStringPtr) dlsym(hLibrary, "libmcenv_cryptocontext_calculatesha256fromstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CryptoContext_CalculateSHA256FromString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CryptoContext_CalculateSHA256FromBytes = (PLibMCEnvCryptoContext_CalculateSHA256FromBytesPtr) GetProcAddress(hLibrary, "libmcenv_cryptocontext_calculatesha256frombytes");
		#else // _WIN32
		pWrapperTable->m_CryptoContext_CalculateSHA256FromBytes = (PLibMCEnvCryptoContext_CalculateSHA256FromBytesPtr) dlsym(hLibrary, "libmcenv_cryptocontext_calculatesha256frombytes");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CryptoContext_CalculateSHA256FromBytes == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CryptoContext_NormalizeSHA256String = (PLibMCEnvCryptoContext_NormalizeSHA256StringPtr) GetProcAddress(hLibrary, "libmcenv_cryptocontext_normalizesha256string");
		#else // _WIN32
		pWrapperTable->m_CryptoContext_NormalizeSHA256String = (PLibMCEnvCryptoContext_NormalizeSHA256StringPtr) dlsym(hLibrary, "libmcenv_cryptocontext_normalizesha256string");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CryptoContext_NormalizeSHA256String == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CryptoContext_CreateRandomSHA256Hash = (PLibMCEnvCryptoContext_CreateRandomSHA256HashPtr) GetProcAddress(hLibrary, "libmcenv_cryptocontext_createrandomsha256hash");
		#else // _WIN32
		pWrapperTable->m_CryptoContext_CreateRandomSHA256Hash = (PLibMCEnvCryptoContext_CreateRandomSHA256HashPtr) dlsym(hLibrary, "libmcenv_cryptocontext_createrandomsha256hash");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CryptoContext_CreateRandomSHA256Hash == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CryptoContext_CreateUUID = (PLibMCEnvCryptoContext_CreateUUIDPtr) GetProcAddress(hLibrary, "libmcenv_cryptocontext_createuuid");
		#else // _WIN32
		pWrapperTable->m_CryptoContext_CreateUUID = (PLibMCEnvCryptoContext_CreateUUIDPtr) dlsym(hLibrary, "libmcenv_cryptocontext_createuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CryptoContext_CreateUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CryptoContext_NormalizeUUIDString = (PLibMCEnvCryptoContext_NormalizeUUIDStringPtr) GetProcAddress(hLibrary, "libmcenv_cryptocontext_normalizeuuidstring");
		#else // _WIN32
		pWrapperTable->m_CryptoContext_NormalizeUUIDString = (PLibMCEnvCryptoContext_NormalizeUUIDStringPtr) dlsym(hLibrary, "libmcenv_cryptocontext_normalizeuuidstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CryptoContext_NormalizeUUIDString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PNGImageStoreOptions_ResetToDefaults = (PLibMCEnvPNGImageStoreOptions_ResetToDefaultsPtr) GetProcAddress(hLibrary, "libmcenv_pngimagestoreoptions_resettodefaults");
		#else // _WIN32
		pWrapperTable->m_PNGImageStoreOptions_ResetToDefaults = (PLibMCEnvPNGImageStoreOptions_ResetToDefaultsPtr) dlsym(hLibrary, "libmcenv_pngimagestoreoptions_resettodefaults");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PNGImageStoreOptions_ResetToDefaults == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PNGImageData_GetSizeInPixels = (PLibMCEnvPNGImageData_GetSizeInPixelsPtr) GetProcAddress(hLibrary, "libmcenv_pngimagedata_getsizeinpixels");
		#else // _WIN32
		pWrapperTable->m_PNGImageData_GetSizeInPixels = (PLibMCEnvPNGImageData_GetSizeInPixelsPtr) dlsym(hLibrary, "libmcenv_pngimagedata_getsizeinpixels");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PNGImageData_GetSizeInPixels == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PNGImageData_GetPNGDataStream = (PLibMCEnvPNGImageData_GetPNGDataStreamPtr) GetProcAddress(hLibrary, "libmcenv_pngimagedata_getpngdatastream");
		#else // _WIN32
		pWrapperTable->m_PNGImageData_GetPNGDataStream = (PLibMCEnvPNGImageData_GetPNGDataStreamPtr) dlsym(hLibrary, "libmcenv_pngimagedata_getpngdatastream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PNGImageData_GetPNGDataStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_GetPixelFormat = (PLibMCEnvImageData_GetPixelFormatPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_getpixelformat");
		#else // _WIN32
		pWrapperTable->m_ImageData_GetPixelFormat = (PLibMCEnvImageData_GetPixelFormatPtr) dlsym(hLibrary, "libmcenv_imagedata_getpixelformat");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_GetPixelFormat == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_ChangePixelFormat = (PLibMCEnvImageData_ChangePixelFormatPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_changepixelformat");
		#else // _WIN32
		pWrapperTable->m_ImageData_ChangePixelFormat = (PLibMCEnvImageData_ChangePixelFormatPtr) dlsym(hLibrary, "libmcenv_imagedata_changepixelformat");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_ChangePixelFormat == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_GetDPI = (PLibMCEnvImageData_GetDPIPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_getdpi");
		#else // _WIN32
		pWrapperTable->m_ImageData_GetDPI = (PLibMCEnvImageData_GetDPIPtr) dlsym(hLibrary, "libmcenv_imagedata_getdpi");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_GetDPI == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_SetDPI = (PLibMCEnvImageData_SetDPIPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_setdpi");
		#else // _WIN32
		pWrapperTable->m_ImageData_SetDPI = (PLibMCEnvImageData_SetDPIPtr) dlsym(hLibrary, "libmcenv_imagedata_setdpi");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_SetDPI == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_GetSizeInMM = (PLibMCEnvImageData_GetSizeInMMPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_getsizeinmm");
		#else // _WIN32
		pWrapperTable->m_ImageData_GetSizeInMM = (PLibMCEnvImageData_GetSizeInMMPtr) dlsym(hLibrary, "libmcenv_imagedata_getsizeinmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_GetSizeInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_GetSizeInPixels = (PLibMCEnvImageData_GetSizeInPixelsPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_getsizeinpixels");
		#else // _WIN32
		pWrapperTable->m_ImageData_GetSizeInPixels = (PLibMCEnvImageData_GetSizeInPixelsPtr) dlsym(hLibrary, "libmcenv_imagedata_getsizeinpixels");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_GetSizeInPixels == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_ResizeImage = (PLibMCEnvImageData_ResizeImagePtr) GetProcAddress(hLibrary, "libmcenv_imagedata_resizeimage");
		#else // _WIN32
		pWrapperTable->m_ImageData_ResizeImage = (PLibMCEnvImageData_ResizeImagePtr) dlsym(hLibrary, "libmcenv_imagedata_resizeimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_ResizeImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_CreatePNGImage = (PLibMCEnvImageData_CreatePNGImagePtr) GetProcAddress(hLibrary, "libmcenv_imagedata_createpngimage");
		#else // _WIN32
		pWrapperTable->m_ImageData_CreatePNGImage = (PLibMCEnvImageData_CreatePNGImagePtr) dlsym(hLibrary, "libmcenv_imagedata_createpngimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_CreatePNGImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_EncodePNG = (PLibMCEnvImageData_EncodePNGPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_encodepng");
		#else // _WIN32
		pWrapperTable->m_ImageData_EncodePNG = (PLibMCEnvImageData_EncodePNGPtr) dlsym(hLibrary, "libmcenv_imagedata_encodepng");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_EncodePNG == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_GetEncodedPNGData = (PLibMCEnvImageData_GetEncodedPNGDataPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_getencodedpngdata");
		#else // _WIN32
		pWrapperTable->m_ImageData_GetEncodedPNGData = (PLibMCEnvImageData_GetEncodedPNGDataPtr) dlsym(hLibrary, "libmcenv_imagedata_getencodedpngdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_GetEncodedPNGData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_ClearEncodedPNGData = (PLibMCEnvImageData_ClearEncodedPNGDataPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_clearencodedpngdata");
		#else // _WIN32
		pWrapperTable->m_ImageData_ClearEncodedPNGData = (PLibMCEnvImageData_ClearEncodedPNGDataPtr) dlsym(hLibrary, "libmcenv_imagedata_clearencodedpngdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_ClearEncodedPNGData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_Clear = (PLibMCEnvImageData_ClearPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_clear");
		#else // _WIN32
		pWrapperTable->m_ImageData_Clear = (PLibMCEnvImageData_ClearPtr) dlsym(hLibrary, "libmcenv_imagedata_clear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_Clear == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_GetPixel = (PLibMCEnvImageData_GetPixelPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_getpixel");
		#else // _WIN32
		pWrapperTable->m_ImageData_GetPixel = (PLibMCEnvImageData_GetPixelPtr) dlsym(hLibrary, "libmcenv_imagedata_getpixel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_GetPixel == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_SetPixel = (PLibMCEnvImageData_SetPixelPtr) GetProcAddress(hLibrary, "libmcenv_imagedata_setpixel");
		#else // _WIN32
		pWrapperTable->m_ImageData_SetPixel = (PLibMCEnvImageData_SetPixelPtr) dlsym(hLibrary, "libmcenv_imagedata_setpixel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_SetPixel == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_GetPixelRange = (PLibMCEnvImageData_GetPixelRangePtr) GetProcAddress(hLibrary, "libmcenv_imagedata_getpixelrange");
		#else // _WIN32
		pWrapperTable->m_ImageData_GetPixelRange = (PLibMCEnvImageData_GetPixelRangePtr) dlsym(hLibrary, "libmcenv_imagedata_getpixelrange");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_GetPixelRange == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageData_SetPixelRange = (PLibMCEnvImageData_SetPixelRangePtr) GetProcAddress(hLibrary, "libmcenv_imagedata_setpixelrange");
		#else // _WIN32
		pWrapperTable->m_ImageData_SetPixelRange = (PLibMCEnvImageData_SetPixelRangePtr) dlsym(hLibrary, "libmcenv_imagedata_setpixelrange");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageData_SetPixelRange == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2DStoreOptions_ResetToDefaults = (PLibMCEnvDiscreteFieldData2DStoreOptions_ResetToDefaultsPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2dstoreoptions_resettodefaults");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2DStoreOptions_ResetToDefaults = (PLibMCEnvDiscreteFieldData2DStoreOptions_ResetToDefaultsPtr) dlsym(hLibrary, "libmcenv_discretefielddata2dstoreoptions_resettodefaults");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2DStoreOptions_ResetToDefaults == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetDPI = (PLibMCEnvDiscreteFieldData2D_GetDPIPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_getdpi");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetDPI = (PLibMCEnvDiscreteFieldData2D_GetDPIPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_getdpi");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_GetDPI == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_SetDPI = (PLibMCEnvDiscreteFieldData2D_SetDPIPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_setdpi");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_SetDPI = (PLibMCEnvDiscreteFieldData2D_SetDPIPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_setdpi");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_SetDPI == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetOriginInMM = (PLibMCEnvDiscreteFieldData2D_GetOriginInMMPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_getorigininmm");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetOriginInMM = (PLibMCEnvDiscreteFieldData2D_GetOriginInMMPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_getorigininmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_GetOriginInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_SetOriginInMM = (PLibMCEnvDiscreteFieldData2D_SetOriginInMMPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_setorigininmm");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_SetOriginInMM = (PLibMCEnvDiscreteFieldData2D_SetOriginInMMPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_setorigininmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_SetOriginInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetSizeInMM = (PLibMCEnvDiscreteFieldData2D_GetSizeInMMPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_getsizeinmm");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetSizeInMM = (PLibMCEnvDiscreteFieldData2D_GetSizeInMMPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_getsizeinmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_GetSizeInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetSizeInPixels = (PLibMCEnvDiscreteFieldData2D_GetSizeInPixelsPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_getsizeinpixels");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetSizeInPixels = (PLibMCEnvDiscreteFieldData2D_GetSizeInPixelsPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_getsizeinpixels");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_GetSizeInPixels == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_ResizeField = (PLibMCEnvDiscreteFieldData2D_ResizeFieldPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_resizefield");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_ResizeField = (PLibMCEnvDiscreteFieldData2D_ResizeFieldPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_resizefield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_ResizeField == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_Clear = (PLibMCEnvDiscreteFieldData2D_ClearPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_clear");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_Clear = (PLibMCEnvDiscreteFieldData2D_ClearPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_clear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_Clear == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_Clamp = (PLibMCEnvDiscreteFieldData2D_ClampPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_clamp");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_Clamp = (PLibMCEnvDiscreteFieldData2D_ClampPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_clamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_Clamp == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetPixel = (PLibMCEnvDiscreteFieldData2D_GetPixelPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_getpixel");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetPixel = (PLibMCEnvDiscreteFieldData2D_GetPixelPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_getpixel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_GetPixel == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_SetPixel = (PLibMCEnvDiscreteFieldData2D_SetPixelPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_setpixel");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_SetPixel = (PLibMCEnvDiscreteFieldData2D_SetPixelPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_setpixel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_SetPixel == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetPixelRange = (PLibMCEnvDiscreteFieldData2D_GetPixelRangePtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_getpixelrange");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_GetPixelRange = (PLibMCEnvDiscreteFieldData2D_GetPixelRangePtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_getpixelrange");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_GetPixelRange == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_SetPixelRange = (PLibMCEnvDiscreteFieldData2D_SetPixelRangePtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_setpixelrange");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_SetPixelRange = (PLibMCEnvDiscreteFieldData2D_SetPixelRangePtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_setpixelrange");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_SetPixelRange == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_RenderAveragePointValues = (PLibMCEnvDiscreteFieldData2D_RenderAveragePointValuesPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_renderaveragepointvalues");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_RenderAveragePointValues = (PLibMCEnvDiscreteFieldData2D_RenderAveragePointValuesPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_renderaveragepointvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_RenderAveragePointValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_ScaleFieldDown = (PLibMCEnvDiscreteFieldData2D_ScaleFieldDownPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_scalefielddown");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_ScaleFieldDown = (PLibMCEnvDiscreteFieldData2D_ScaleFieldDownPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_scalefielddown");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_ScaleFieldDown == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_ScaleFieldUp = (PLibMCEnvDiscreteFieldData2D_ScaleFieldUpPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_scalefieldup");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_ScaleFieldUp = (PLibMCEnvDiscreteFieldData2D_ScaleFieldUpPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_scalefieldup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_ScaleFieldUp == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_Discretize = (PLibMCEnvDiscreteFieldData2D_DiscretizePtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_discretize");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_Discretize = (PLibMCEnvDiscreteFieldData2D_DiscretizePtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_discretize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_Discretize == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_DiscretizeWithMapping = (PLibMCEnvDiscreteFieldData2D_DiscretizeWithMappingPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_discretizewithmapping");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_DiscretizeWithMapping = (PLibMCEnvDiscreteFieldData2D_DiscretizeWithMappingPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_discretizewithmapping");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_DiscretizeWithMapping == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_RenderToImageRaw = (PLibMCEnvDiscreteFieldData2D_RenderToImageRawPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_rendertoimageraw");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_RenderToImageRaw = (PLibMCEnvDiscreteFieldData2D_RenderToImageRawPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_rendertoimageraw");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_RenderToImageRaw == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_TransformField = (PLibMCEnvDiscreteFieldData2D_TransformFieldPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_transformfield");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_TransformField = (PLibMCEnvDiscreteFieldData2D_TransformFieldPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_transformfield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_TransformField == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_AddField = (PLibMCEnvDiscreteFieldData2D_AddFieldPtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_addfield");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_AddField = (PLibMCEnvDiscreteFieldData2D_AddFieldPtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_addfield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_AddField == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DiscreteFieldData2D_Duplicate = (PLibMCEnvDiscreteFieldData2D_DuplicatePtr) GetProcAddress(hLibrary, "libmcenv_discretefielddata2d_duplicate");
		#else // _WIN32
		pWrapperTable->m_DiscreteFieldData2D_Duplicate = (PLibMCEnvDiscreteFieldData2D_DuplicatePtr) dlsym(hLibrary, "libmcenv_discretefielddata2d_duplicate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DiscreteFieldData2D_Duplicate == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTableCSVWriteOptions_GetSeparator = (PLibMCEnvDataTableCSVWriteOptions_GetSeparatorPtr) GetProcAddress(hLibrary, "libmcenv_datatablecsvwriteoptions_getseparator");
		#else // _WIN32
		pWrapperTable->m_DataTableCSVWriteOptions_GetSeparator = (PLibMCEnvDataTableCSVWriteOptions_GetSeparatorPtr) dlsym(hLibrary, "libmcenv_datatablecsvwriteoptions_getseparator");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTableCSVWriteOptions_GetSeparator == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTableCSVWriteOptions_SetSeparator = (PLibMCEnvDataTableCSVWriteOptions_SetSeparatorPtr) GetProcAddress(hLibrary, "libmcenv_datatablecsvwriteoptions_setseparator");
		#else // _WIN32
		pWrapperTable->m_DataTableCSVWriteOptions_SetSeparator = (PLibMCEnvDataTableCSVWriteOptions_SetSeparatorPtr) dlsym(hLibrary, "libmcenv_datatablecsvwriteoptions_setseparator");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTableCSVWriteOptions_SetSeparator == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_AddColumn = (PLibMCEnvDataTable_AddColumnPtr) GetProcAddress(hLibrary, "libmcenv_datatable_addcolumn");
		#else // _WIN32
		pWrapperTable->m_DataTable_AddColumn = (PLibMCEnvDataTable_AddColumnPtr) dlsym(hLibrary, "libmcenv_datatable_addcolumn");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_AddColumn == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_RemoveColumn = (PLibMCEnvDataTable_RemoveColumnPtr) GetProcAddress(hLibrary, "libmcenv_datatable_removecolumn");
		#else // _WIN32
		pWrapperTable->m_DataTable_RemoveColumn = (PLibMCEnvDataTable_RemoveColumnPtr) dlsym(hLibrary, "libmcenv_datatable_removecolumn");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_RemoveColumn == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_Clear = (PLibMCEnvDataTable_ClearPtr) GetProcAddress(hLibrary, "libmcenv_datatable_clear");
		#else // _WIN32
		pWrapperTable->m_DataTable_Clear = (PLibMCEnvDataTable_ClearPtr) dlsym(hLibrary, "libmcenv_datatable_clear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_Clear == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_HasColumn = (PLibMCEnvDataTable_HasColumnPtr) GetProcAddress(hLibrary, "libmcenv_datatable_hascolumn");
		#else // _WIN32
		pWrapperTable->m_DataTable_HasColumn = (PLibMCEnvDataTable_HasColumnPtr) dlsym(hLibrary, "libmcenv_datatable_hascolumn");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_HasColumn == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetRowCount = (PLibMCEnvDataTable_GetRowCountPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getrowcount");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetRowCount = (PLibMCEnvDataTable_GetRowCountPtr) dlsym(hLibrary, "libmcenv_datatable_getrowcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetRowCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetColumnCount = (PLibMCEnvDataTable_GetColumnCountPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getcolumncount");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetColumnCount = (PLibMCEnvDataTable_GetColumnCountPtr) dlsym(hLibrary, "libmcenv_datatable_getcolumncount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetColumnCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetColumnIdentifier = (PLibMCEnvDataTable_GetColumnIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getcolumnidentifier");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetColumnIdentifier = (PLibMCEnvDataTable_GetColumnIdentifierPtr) dlsym(hLibrary, "libmcenv_datatable_getcolumnidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetColumnIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetColumnDescription = (PLibMCEnvDataTable_GetColumnDescriptionPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getcolumndescription");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetColumnDescription = (PLibMCEnvDataTable_GetColumnDescriptionPtr) dlsym(hLibrary, "libmcenv_datatable_getcolumndescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetColumnDescription == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetColumnType = (PLibMCEnvDataTable_GetColumnTypePtr) GetProcAddress(hLibrary, "libmcenv_datatable_getcolumntype");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetColumnType = (PLibMCEnvDataTable_GetColumnTypePtr) dlsym(hLibrary, "libmcenv_datatable_getcolumntype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetColumnType == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetColumnInformation = (PLibMCEnvDataTable_GetColumnInformationPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getcolumninformation");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetColumnInformation = (PLibMCEnvDataTable_GetColumnInformationPtr) dlsym(hLibrary, "libmcenv_datatable_getcolumninformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetColumnInformation == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetDoubleColumnValues = (PLibMCEnvDataTable_GetDoubleColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getdoublecolumnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetDoubleColumnValues = (PLibMCEnvDataTable_GetDoubleColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_getdoublecolumnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetDoubleColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetInt32ColumnValues = (PLibMCEnvDataTable_GetInt32ColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getint32columnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetInt32ColumnValues = (PLibMCEnvDataTable_GetInt32ColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_getint32columnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetInt32ColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetInt64ColumnValues = (PLibMCEnvDataTable_GetInt64ColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getint64columnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetInt64ColumnValues = (PLibMCEnvDataTable_GetInt64ColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_getint64columnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetInt64ColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetUint32ColumnValues = (PLibMCEnvDataTable_GetUint32ColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getuint32columnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetUint32ColumnValues = (PLibMCEnvDataTable_GetUint32ColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_getuint32columnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetUint32ColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_GetUint64ColumnValues = (PLibMCEnvDataTable_GetUint64ColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_getuint64columnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_GetUint64ColumnValues = (PLibMCEnvDataTable_GetUint64ColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_getuint64columnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_GetUint64ColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_SetDoubleColumnValues = (PLibMCEnvDataTable_SetDoubleColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_setdoublecolumnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_SetDoubleColumnValues = (PLibMCEnvDataTable_SetDoubleColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_setdoublecolumnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_SetDoubleColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_SetInt32ColumnValues = (PLibMCEnvDataTable_SetInt32ColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_setint32columnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_SetInt32ColumnValues = (PLibMCEnvDataTable_SetInt32ColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_setint32columnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_SetInt32ColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_SetInt64ColumnValues = (PLibMCEnvDataTable_SetInt64ColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_setint64columnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_SetInt64ColumnValues = (PLibMCEnvDataTable_SetInt64ColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_setint64columnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_SetInt64ColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_SetUint32ColumnValues = (PLibMCEnvDataTable_SetUint32ColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_setuint32columnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_SetUint32ColumnValues = (PLibMCEnvDataTable_SetUint32ColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_setuint32columnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_SetUint32ColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_SetUint64ColumnValues = (PLibMCEnvDataTable_SetUint64ColumnValuesPtr) GetProcAddress(hLibrary, "libmcenv_datatable_setuint64columnvalues");
		#else // _WIN32
		pWrapperTable->m_DataTable_SetUint64ColumnValues = (PLibMCEnvDataTable_SetUint64ColumnValuesPtr) dlsym(hLibrary, "libmcenv_datatable_setuint64columnvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_SetUint64ColumnValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_CreateWriteOptions = (PLibMCEnvDataTable_CreateWriteOptionsPtr) GetProcAddress(hLibrary, "libmcenv_datatable_createwriteoptions");
		#else // _WIN32
		pWrapperTable->m_DataTable_CreateWriteOptions = (PLibMCEnvDataTable_CreateWriteOptionsPtr) dlsym(hLibrary, "libmcenv_datatable_createwriteoptions");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_CreateWriteOptions == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_CreateCSVWriteOptions = (PLibMCEnvDataTable_CreateCSVWriteOptionsPtr) GetProcAddress(hLibrary, "libmcenv_datatable_createcsvwriteoptions");
		#else // _WIN32
		pWrapperTable->m_DataTable_CreateCSVWriteOptions = (PLibMCEnvDataTable_CreateCSVWriteOptionsPtr) dlsym(hLibrary, "libmcenv_datatable_createcsvwriteoptions");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_CreateCSVWriteOptions == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_WriteCSVToStream = (PLibMCEnvDataTable_WriteCSVToStreamPtr) GetProcAddress(hLibrary, "libmcenv_datatable_writecsvtostream");
		#else // _WIN32
		pWrapperTable->m_DataTable_WriteCSVToStream = (PLibMCEnvDataTable_WriteCSVToStreamPtr) dlsym(hLibrary, "libmcenv_datatable_writecsvtostream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_WriteCSVToStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_WriteDataToStream = (PLibMCEnvDataTable_WriteDataToStreamPtr) GetProcAddress(hLibrary, "libmcenv_datatable_writedatatostream");
		#else // _WIN32
		pWrapperTable->m_DataTable_WriteDataToStream = (PLibMCEnvDataTable_WriteDataToStreamPtr) dlsym(hLibrary, "libmcenv_datatable_writedatatostream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_WriteDataToStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataTable_LoadFromStream = (PLibMCEnvDataTable_LoadFromStreamPtr) GetProcAddress(hLibrary, "libmcenv_datatable_loadfromstream");
		#else // _WIN32
		pWrapperTable->m_DataTable_LoadFromStream = (PLibMCEnvDataTable_LoadFromStreamPtr) dlsym(hLibrary, "libmcenv_datatable_loadfromstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataTable_LoadFromStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_GetName = (PLibMCEnvDataSeries_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_dataseries_getname");
		#else // _WIN32
		pWrapperTable->m_DataSeries_GetName = (PLibMCEnvDataSeries_GetNamePtr) dlsym(hLibrary, "libmcenv_dataseries_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_GetUUID = (PLibMCEnvDataSeries_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_dataseries_getuuid");
		#else // _WIN32
		pWrapperTable->m_DataSeries_GetUUID = (PLibMCEnvDataSeries_GetUUIDPtr) dlsym(hLibrary, "libmcenv_dataseries_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_Clear = (PLibMCEnvDataSeries_ClearPtr) GetProcAddress(hLibrary, "libmcenv_dataseries_clear");
		#else // _WIN32
		pWrapperTable->m_DataSeries_Clear = (PLibMCEnvDataSeries_ClearPtr) dlsym(hLibrary, "libmcenv_dataseries_clear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_Clear == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_IsEmpty = (PLibMCEnvDataSeries_IsEmptyPtr) GetProcAddress(hLibrary, "libmcenv_dataseries_isempty");
		#else // _WIN32
		pWrapperTable->m_DataSeries_IsEmpty = (PLibMCEnvDataSeries_IsEmptyPtr) dlsym(hLibrary, "libmcenv_dataseries_isempty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_IsEmpty == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_GetMinimum = (PLibMCEnvDataSeries_GetMinimumPtr) GetProcAddress(hLibrary, "libmcenv_dataseries_getminimum");
		#else // _WIN32
		pWrapperTable->m_DataSeries_GetMinimum = (PLibMCEnvDataSeries_GetMinimumPtr) dlsym(hLibrary, "libmcenv_dataseries_getminimum");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_GetMinimum == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_GetMaximum = (PLibMCEnvDataSeries_GetMaximumPtr) GetProcAddress(hLibrary, "libmcenv_dataseries_getmaximum");
		#else // _WIN32
		pWrapperTable->m_DataSeries_GetMaximum = (PLibMCEnvDataSeries_GetMaximumPtr) dlsym(hLibrary, "libmcenv_dataseries_getmaximum");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_GetMaximum == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_GetAllEntries = (PLibMCEnvDataSeries_GetAllEntriesPtr) GetProcAddress(hLibrary, "libmcenv_dataseries_getallentries");
		#else // _WIN32
		pWrapperTable->m_DataSeries_GetAllEntries = (PLibMCEnvDataSeries_GetAllEntriesPtr) dlsym(hLibrary, "libmcenv_dataseries_getallentries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_GetAllEntries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_SetAllEntries = (PLibMCEnvDataSeries_SetAllEntriesPtr) GetProcAddress(hLibrary, "libmcenv_dataseries_setallentries");
		#else // _WIN32
		pWrapperTable->m_DataSeries_SetAllEntries = (PLibMCEnvDataSeries_SetAllEntriesPtr) dlsym(hLibrary, "libmcenv_dataseries_setallentries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_SetAllEntries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_SampleJournalVariable = (PLibMCEnvDataSeries_SampleJournalVariablePtr) GetProcAddress(hLibrary, "libmcenv_dataseries_samplejournalvariable");
		#else // _WIN32
		pWrapperTable->m_DataSeries_SampleJournalVariable = (PLibMCEnvDataSeries_SampleJournalVariablePtr) dlsym(hLibrary, "libmcenv_dataseries_samplejournalvariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_SampleJournalVariable == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_GetVersion = (PLibMCEnvDataSeries_GetVersionPtr) GetProcAddress(hLibrary, "libmcenv_dataseries_getversion");
		#else // _WIN32
		pWrapperTable->m_DataSeries_GetVersion = (PLibMCEnvDataSeries_GetVersionPtr) dlsym(hLibrary, "libmcenv_dataseries_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_GetVersion == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataSeries_IncreaseVersion = (PLibMCEnvDataSeries_IncreaseVersionPtr) GetProcAddress(hLibrary, "libmcenv_dataseries_increaseversion");
		#else // _WIN32
		pWrapperTable->m_DataSeries_IncreaseVersion = (PLibMCEnvDataSeries_IncreaseVersionPtr) dlsym(hLibrary, "libmcenv_dataseries_increaseversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataSeries_IncreaseVersion == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_ToMicroseconds = (PLibMCEnvDateTimeDifference_ToMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_tomicroseconds");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_ToMicroseconds = (PLibMCEnvDateTimeDifference_ToMicrosecondsPtr) dlsym(hLibrary, "libmcenv_datetimedifference_tomicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_ToMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_ToMilliseconds = (PLibMCEnvDateTimeDifference_ToMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_tomilliseconds");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_ToMilliseconds = (PLibMCEnvDateTimeDifference_ToMillisecondsPtr) dlsym(hLibrary, "libmcenv_datetimedifference_tomilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_ToMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_ToSeconds = (PLibMCEnvDateTimeDifference_ToSecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_toseconds");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_ToSeconds = (PLibMCEnvDateTimeDifference_ToSecondsPtr) dlsym(hLibrary, "libmcenv_datetimedifference_toseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_ToSeconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_ToMinutes = (PLibMCEnvDateTimeDifference_ToMinutesPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_tominutes");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_ToMinutes = (PLibMCEnvDateTimeDifference_ToMinutesPtr) dlsym(hLibrary, "libmcenv_datetimedifference_tominutes");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_ToMinutes == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_ToHours = (PLibMCEnvDateTimeDifference_ToHoursPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_tohours");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_ToHours = (PLibMCEnvDateTimeDifference_ToHoursPtr) dlsym(hLibrary, "libmcenv_datetimedifference_tohours");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_ToHours == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_ToDays = (PLibMCEnvDateTimeDifference_ToDaysPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_todays");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_ToDays = (PLibMCEnvDateTimeDifference_ToDaysPtr) dlsym(hLibrary, "libmcenv_datetimedifference_todays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_ToDays == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToDay = (PLibMCEnvDateTimeDifference_RoundDownToDayPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounddowntoday");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToDay = (PLibMCEnvDateTimeDifference_RoundDownToDayPtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounddowntoday");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundDownToDay == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToHour = (PLibMCEnvDateTimeDifference_RoundDownToHourPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounddowntohour");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToHour = (PLibMCEnvDateTimeDifference_RoundDownToHourPtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounddowntohour");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundDownToHour == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToMinute = (PLibMCEnvDateTimeDifference_RoundDownToMinutePtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounddowntominute");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToMinute = (PLibMCEnvDateTimeDifference_RoundDownToMinutePtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounddowntominute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundDownToMinute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToSeconds = (PLibMCEnvDateTimeDifference_RoundDownToSecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounddowntoseconds");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToSeconds = (PLibMCEnvDateTimeDifference_RoundDownToSecondsPtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounddowntoseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundDownToSeconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToMilliseconds = (PLibMCEnvDateTimeDifference_RoundDownToMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounddowntomilliseconds");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundDownToMilliseconds = (PLibMCEnvDateTimeDifference_RoundDownToMillisecondsPtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounddowntomilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundDownToMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundUpToDay = (PLibMCEnvDateTimeDifference_RoundUpToDayPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounduptoday");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundUpToDay = (PLibMCEnvDateTimeDifference_RoundUpToDayPtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounduptoday");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundUpToDay == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundUpToHour = (PLibMCEnvDateTimeDifference_RoundUpToHourPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounduptohour");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundUpToHour = (PLibMCEnvDateTimeDifference_RoundUpToHourPtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounduptohour");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundUpToHour == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundUpToMinute = (PLibMCEnvDateTimeDifference_RoundUpToMinutePtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounduptominute");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundUpToMinute = (PLibMCEnvDateTimeDifference_RoundUpToMinutePtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounduptominute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundUpToMinute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundUpToSeconds = (PLibMCEnvDateTimeDifference_RoundUpToSecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounduptoseconds");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundUpToSeconds = (PLibMCEnvDateTimeDifference_RoundUpToSecondsPtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounduptoseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundUpToSeconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTimeDifference_RoundupToMilliseconds = (PLibMCEnvDateTimeDifference_RoundupToMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetimedifference_rounduptomilliseconds");
		#else // _WIN32
		pWrapperTable->m_DateTimeDifference_RoundupToMilliseconds = (PLibMCEnvDateTimeDifference_RoundupToMillisecondsPtr) dlsym(hLibrary, "libmcenv_datetimedifference_rounduptomilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTimeDifference_RoundupToMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ToMicrosecondsSince1970 = (PLibMCEnvDateTime_ToMicrosecondsSince1970Ptr) GetProcAddress(hLibrary, "libmcenv_datetime_tomicrosecondssince1970");
		#else // _WIN32
		pWrapperTable->m_DateTime_ToMicrosecondsSince1970 = (PLibMCEnvDateTime_ToMicrosecondsSince1970Ptr) dlsym(hLibrary, "libmcenv_datetime_tomicrosecondssince1970");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ToMicrosecondsSince1970 == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ToUnixTimestamp = (PLibMCEnvDateTime_ToUnixTimestampPtr) GetProcAddress(hLibrary, "libmcenv_datetime_tounixtimestamp");
		#else // _WIN32
		pWrapperTable->m_DateTime_ToUnixTimestamp = (PLibMCEnvDateTime_ToUnixTimestampPtr) dlsym(hLibrary, "libmcenv_datetime_tounixtimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ToUnixTimestamp == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ToUTCDateTime = (PLibMCEnvDateTime_ToUTCDateTimePtr) GetProcAddress(hLibrary, "libmcenv_datetime_toutcdatetime");
		#else // _WIN32
		pWrapperTable->m_DateTime_ToUTCDateTime = (PLibMCEnvDateTime_ToUTCDateTimePtr) dlsym(hLibrary, "libmcenv_datetime_toutcdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ToUTCDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ToUTCDateTimeInMilliseconds = (PLibMCEnvDateTime_ToUTCDateTimeInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_toutcdatetimeinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_DateTime_ToUTCDateTimeInMilliseconds = (PLibMCEnvDateTime_ToUTCDateTimeInMillisecondsPtr) dlsym(hLibrary, "libmcenv_datetime_toutcdatetimeinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ToUTCDateTimeInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ToUTCDateTimeInMicroseconds = (PLibMCEnvDateTime_ToUTCDateTimeInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_toutcdatetimeinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_DateTime_ToUTCDateTimeInMicroseconds = (PLibMCEnvDateTime_ToUTCDateTimeInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_datetime_toutcdatetimeinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ToUTCDateTimeInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_GetDate = (PLibMCEnvDateTime_GetDatePtr) GetProcAddress(hLibrary, "libmcenv_datetime_getdate");
		#else // _WIN32
		pWrapperTable->m_DateTime_GetDate = (PLibMCEnvDateTime_GetDatePtr) dlsym(hLibrary, "libmcenv_datetime_getdate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_GetDate == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_GetTime = (PLibMCEnvDateTime_GetTimePtr) GetProcAddress(hLibrary, "libmcenv_datetime_gettime");
		#else // _WIN32
		pWrapperTable->m_DateTime_GetTime = (PLibMCEnvDateTime_GetTimePtr) dlsym(hLibrary, "libmcenv_datetime_gettime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_GetTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_Duplicate = (PLibMCEnvDateTime_DuplicatePtr) GetProcAddress(hLibrary, "libmcenv_datetime_duplicate");
		#else // _WIN32
		pWrapperTable->m_DateTime_Duplicate = (PLibMCEnvDateTime_DuplicatePtr) dlsym(hLibrary, "libmcenv_datetime_duplicate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_Duplicate == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_IsLeapYear = (PLibMCEnvDateTime_IsLeapYearPtr) GetProcAddress(hLibrary, "libmcenv_datetime_isleapyear");
		#else // _WIN32
		pWrapperTable->m_DateTime_IsLeapYear = (PLibMCEnvDateTime_IsLeapYearPtr) dlsym(hLibrary, "libmcenv_datetime_isleapyear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_IsLeapYear == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_IsLaterThan = (PLibMCEnvDateTime_IsLaterThanPtr) GetProcAddress(hLibrary, "libmcenv_datetime_islaterthan");
		#else // _WIN32
		pWrapperTable->m_DateTime_IsLaterThan = (PLibMCEnvDateTime_IsLaterThanPtr) dlsym(hLibrary, "libmcenv_datetime_islaterthan");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_IsLaterThan == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_IsEarlierThan = (PLibMCEnvDateTime_IsEarlierThanPtr) GetProcAddress(hLibrary, "libmcenv_datetime_isearlierthan");
		#else // _WIN32
		pWrapperTable->m_DateTime_IsEarlierThan = (PLibMCEnvDateTime_IsEarlierThanPtr) dlsym(hLibrary, "libmcenv_datetime_isearlierthan");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_IsEarlierThan == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_IsEqualTo = (PLibMCEnvDateTime_IsEqualToPtr) GetProcAddress(hLibrary, "libmcenv_datetime_isequalto");
		#else // _WIN32
		pWrapperTable->m_DateTime_IsEqualTo = (PLibMCEnvDateTime_IsEqualToPtr) dlsym(hLibrary, "libmcenv_datetime_isequalto");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_IsEqualTo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_GetTimeDifference = (PLibMCEnvDateTime_GetTimeDifferencePtr) GetProcAddress(hLibrary, "libmcenv_datetime_gettimedifference");
		#else // _WIN32
		pWrapperTable->m_DateTime_GetTimeDifference = (PLibMCEnvDateTime_GetTimeDifferencePtr) dlsym(hLibrary, "libmcenv_datetime_gettimedifference");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_GetTimeDifference == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_AddDuration = (PLibMCEnvDateTime_AddDurationPtr) GetProcAddress(hLibrary, "libmcenv_datetime_addduration");
		#else // _WIN32
		pWrapperTable->m_DateTime_AddDuration = (PLibMCEnvDateTime_AddDurationPtr) dlsym(hLibrary, "libmcenv_datetime_addduration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_AddDuration == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_SubtractDuration = (PLibMCEnvDateTime_SubtractDurationPtr) GetProcAddress(hLibrary, "libmcenv_datetime_subtractduration");
		#else // _WIN32
		pWrapperTable->m_DateTime_SubtractDuration = (PLibMCEnvDateTime_SubtractDurationPtr) dlsym(hLibrary, "libmcenv_datetime_subtractduration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_SubtractDuration == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ShiftByYears = (PLibMCEnvDateTime_ShiftByYearsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_shiftbyyears");
		#else // _WIN32
		pWrapperTable->m_DateTime_ShiftByYears = (PLibMCEnvDateTime_ShiftByYearsPtr) dlsym(hLibrary, "libmcenv_datetime_shiftbyyears");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ShiftByYears == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ShiftByDays = (PLibMCEnvDateTime_ShiftByDaysPtr) GetProcAddress(hLibrary, "libmcenv_datetime_shiftbydays");
		#else // _WIN32
		pWrapperTable->m_DateTime_ShiftByDays = (PLibMCEnvDateTime_ShiftByDaysPtr) dlsym(hLibrary, "libmcenv_datetime_shiftbydays");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ShiftByDays == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ShiftByHours = (PLibMCEnvDateTime_ShiftByHoursPtr) GetProcAddress(hLibrary, "libmcenv_datetime_shiftbyhours");
		#else // _WIN32
		pWrapperTable->m_DateTime_ShiftByHours = (PLibMCEnvDateTime_ShiftByHoursPtr) dlsym(hLibrary, "libmcenv_datetime_shiftbyhours");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ShiftByHours == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ShiftByMinutes = (PLibMCEnvDateTime_ShiftByMinutesPtr) GetProcAddress(hLibrary, "libmcenv_datetime_shiftbyminutes");
		#else // _WIN32
		pWrapperTable->m_DateTime_ShiftByMinutes = (PLibMCEnvDateTime_ShiftByMinutesPtr) dlsym(hLibrary, "libmcenv_datetime_shiftbyminutes");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ShiftByMinutes == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ShiftBySeconds = (PLibMCEnvDateTime_ShiftBySecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_shiftbyseconds");
		#else // _WIN32
		pWrapperTable->m_DateTime_ShiftBySeconds = (PLibMCEnvDateTime_ShiftBySecondsPtr) dlsym(hLibrary, "libmcenv_datetime_shiftbyseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ShiftBySeconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ShiftByMilliseconds = (PLibMCEnvDateTime_ShiftByMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_shiftbymilliseconds");
		#else // _WIN32
		pWrapperTable->m_DateTime_ShiftByMilliseconds = (PLibMCEnvDateTime_ShiftByMillisecondsPtr) dlsym(hLibrary, "libmcenv_datetime_shiftbymilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ShiftByMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_ShiftByMicroseconds = (PLibMCEnvDateTime_ShiftByMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_shiftbymicroseconds");
		#else // _WIN32
		pWrapperTable->m_DateTime_ShiftByMicroseconds = (PLibMCEnvDateTime_ShiftByMicrosecondsPtr) dlsym(hLibrary, "libmcenv_datetime_shiftbymicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_ShiftByMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundDownToYear = (PLibMCEnvDateTime_RoundDownToYearPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounddowntoyear");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundDownToYear = (PLibMCEnvDateTime_RoundDownToYearPtr) dlsym(hLibrary, "libmcenv_datetime_rounddowntoyear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundDownToYear == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundDownToMonth = (PLibMCEnvDateTime_RoundDownToMonthPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounddowntomonth");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundDownToMonth = (PLibMCEnvDateTime_RoundDownToMonthPtr) dlsym(hLibrary, "libmcenv_datetime_rounddowntomonth");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundDownToMonth == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundDownToDay = (PLibMCEnvDateTime_RoundDownToDayPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounddowntoday");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundDownToDay = (PLibMCEnvDateTime_RoundDownToDayPtr) dlsym(hLibrary, "libmcenv_datetime_rounddowntoday");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundDownToDay == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundDownToHour = (PLibMCEnvDateTime_RoundDownToHourPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounddowntohour");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundDownToHour = (PLibMCEnvDateTime_RoundDownToHourPtr) dlsym(hLibrary, "libmcenv_datetime_rounddowntohour");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundDownToHour == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundDownToMinute = (PLibMCEnvDateTime_RoundDownToMinutePtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounddowntominute");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundDownToMinute = (PLibMCEnvDateTime_RoundDownToMinutePtr) dlsym(hLibrary, "libmcenv_datetime_rounddowntominute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundDownToMinute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundDownToSeconds = (PLibMCEnvDateTime_RoundDownToSecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounddowntoseconds");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundDownToSeconds = (PLibMCEnvDateTime_RoundDownToSecondsPtr) dlsym(hLibrary, "libmcenv_datetime_rounddowntoseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundDownToSeconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundDownToMilliseconds = (PLibMCEnvDateTime_RoundDownToMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounddowntomilliseconds");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundDownToMilliseconds = (PLibMCEnvDateTime_RoundDownToMillisecondsPtr) dlsym(hLibrary, "libmcenv_datetime_rounddowntomilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundDownToMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundUpToYear = (PLibMCEnvDateTime_RoundUpToYearPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounduptoyear");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundUpToYear = (PLibMCEnvDateTime_RoundUpToYearPtr) dlsym(hLibrary, "libmcenv_datetime_rounduptoyear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundUpToYear == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundUpToMonth = (PLibMCEnvDateTime_RoundUpToMonthPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounduptomonth");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundUpToMonth = (PLibMCEnvDateTime_RoundUpToMonthPtr) dlsym(hLibrary, "libmcenv_datetime_rounduptomonth");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundUpToMonth == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundUpToDay = (PLibMCEnvDateTime_RoundUpToDayPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounduptoday");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundUpToDay = (PLibMCEnvDateTime_RoundUpToDayPtr) dlsym(hLibrary, "libmcenv_datetime_rounduptoday");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundUpToDay == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundUpToHour = (PLibMCEnvDateTime_RoundUpToHourPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounduptohour");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundUpToHour = (PLibMCEnvDateTime_RoundUpToHourPtr) dlsym(hLibrary, "libmcenv_datetime_rounduptohour");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundUpToHour == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundUpToMinute = (PLibMCEnvDateTime_RoundUpToMinutePtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounduptominute");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundUpToMinute = (PLibMCEnvDateTime_RoundUpToMinutePtr) dlsym(hLibrary, "libmcenv_datetime_rounduptominute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundUpToMinute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundUpToSeconds = (PLibMCEnvDateTime_RoundUpToSecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounduptoseconds");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundUpToSeconds = (PLibMCEnvDateTime_RoundUpToSecondsPtr) dlsym(hLibrary, "libmcenv_datetime_rounduptoseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundUpToSeconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DateTime_RoundUpToMilliseconds = (PLibMCEnvDateTime_RoundUpToMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_datetime_rounduptomilliseconds");
		#else // _WIN32
		pWrapperTable->m_DateTime_RoundUpToMilliseconds = (PLibMCEnvDateTime_RoundUpToMillisecondsPtr) dlsym(hLibrary, "libmcenv_datetime_rounduptomilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DateTime_RoundUpToMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetName = (PLibMCEnvMeshObject_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_meshobject_getname");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetName = (PLibMCEnvMeshObject_GetNamePtr) dlsym(hLibrary, "libmcenv_meshobject_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetUUID = (PLibMCEnvMeshObject_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_getuuid");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetUUID = (PLibMCEnvMeshObject_GetUUIDPtr) dlsym(hLibrary, "libmcenv_meshobject_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetTriangleCount = (PLibMCEnvMeshObject_GetTriangleCountPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_gettrianglecount");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetTriangleCount = (PLibMCEnvMeshObject_GetTriangleCountPtr) dlsym(hLibrary, "libmcenv_meshobject_gettrianglecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetTriangleCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetVertexCount = (PLibMCEnvMeshObject_GetVertexCountPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_getvertexcount");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetVertexCount = (PLibMCEnvMeshObject_GetVertexCountPtr) dlsym(hLibrary, "libmcenv_meshobject_getvertexcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetVertexCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_IsManifold = (PLibMCEnvMeshObject_IsManifoldPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_ismanifold");
		#else // _WIN32
		pWrapperTable->m_MeshObject_IsManifold = (PLibMCEnvMeshObject_IsManifoldPtr) dlsym(hLibrary, "libmcenv_meshobject_ismanifold");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_IsManifold == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_IsOriented = (PLibMCEnvMeshObject_IsOrientedPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_isoriented");
		#else // _WIN32
		pWrapperTable->m_MeshObject_IsOriented = (PLibMCEnvMeshObject_IsOrientedPtr) dlsym(hLibrary, "libmcenv_meshobject_isoriented");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_IsOriented == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_IsWatertight = (PLibMCEnvMeshObject_IsWatertightPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_iswatertight");
		#else // _WIN32
		pWrapperTable->m_MeshObject_IsWatertight = (PLibMCEnvMeshObject_IsWatertightPtr) dlsym(hLibrary, "libmcenv_meshobject_iswatertight");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_IsWatertight == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetMaxVertexID = (PLibMCEnvMeshObject_GetMaxVertexIDPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_getmaxvertexid");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetMaxVertexID = (PLibMCEnvMeshObject_GetMaxVertexIDPtr) dlsym(hLibrary, "libmcenv_meshobject_getmaxvertexid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetMaxVertexID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_VertexExists = (PLibMCEnvMeshObject_VertexExistsPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_vertexexists");
		#else // _WIN32
		pWrapperTable->m_MeshObject_VertexExists = (PLibMCEnvMeshObject_VertexExistsPtr) dlsym(hLibrary, "libmcenv_meshobject_vertexexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_VertexExists == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetVertex = (PLibMCEnvMeshObject_GetVertexPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_getvertex");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetVertex = (PLibMCEnvMeshObject_GetVertexPtr) dlsym(hLibrary, "libmcenv_meshobject_getvertex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetVertex == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetVertexIDs = (PLibMCEnvMeshObject_GetVertexIDsPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_getvertexids");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetVertexIDs = (PLibMCEnvMeshObject_GetVertexIDsPtr) dlsym(hLibrary, "libmcenv_meshobject_getvertexids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetVertexIDs == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetAllVertices = (PLibMCEnvMeshObject_GetAllVerticesPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_getallvertices");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetAllVertices = (PLibMCEnvMeshObject_GetAllVerticesPtr) dlsym(hLibrary, "libmcenv_meshobject_getallvertices");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetAllVertices == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetMaxTriangleID = (PLibMCEnvMeshObject_GetMaxTriangleIDPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_getmaxtriangleid");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetMaxTriangleID = (PLibMCEnvMeshObject_GetMaxTriangleIDPtr) dlsym(hLibrary, "libmcenv_meshobject_getmaxtriangleid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetMaxTriangleID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_TriangeExists = (PLibMCEnvMeshObject_TriangeExistsPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_triangeexists");
		#else // _WIN32
		pWrapperTable->m_MeshObject_TriangeExists = (PLibMCEnvMeshObject_TriangeExistsPtr) dlsym(hLibrary, "libmcenv_meshobject_triangeexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_TriangeExists == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetTriangle = (PLibMCEnvMeshObject_GetTrianglePtr) GetProcAddress(hLibrary, "libmcenv_meshobject_gettriangle");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetTriangle = (PLibMCEnvMeshObject_GetTrianglePtr) dlsym(hLibrary, "libmcenv_meshobject_gettriangle");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetTriangle == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetTriangleIDs = (PLibMCEnvMeshObject_GetTriangleIDsPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_gettriangleids");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetTriangleIDs = (PLibMCEnvMeshObject_GetTriangleIDsPtr) dlsym(hLibrary, "libmcenv_meshobject_gettriangleids");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetTriangleIDs == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_GetAllTriangles = (PLibMCEnvMeshObject_GetAllTrianglesPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_getalltriangles");
		#else // _WIN32
		pWrapperTable->m_MeshObject_GetAllTriangles = (PLibMCEnvMeshObject_GetAllTrianglesPtr) dlsym(hLibrary, "libmcenv_meshobject_getalltriangles");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_GetAllTriangles == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_IsPersistent = (PLibMCEnvMeshObject_IsPersistentPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_ispersistent");
		#else // _WIN32
		pWrapperTable->m_MeshObject_IsPersistent = (PLibMCEnvMeshObject_IsPersistentPtr) dlsym(hLibrary, "libmcenv_meshobject_ispersistent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_IsPersistent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshObject_MakePersistent = (PLibMCEnvMeshObject_MakePersistentPtr) GetProcAddress(hLibrary, "libmcenv_meshobject_makepersistent");
		#else // _WIN32
		pWrapperTable->m_MeshObject_MakePersistent = (PLibMCEnvMeshObject_MakePersistentPtr) dlsym(hLibrary, "libmcenv_meshobject_makepersistent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshObject_MakePersistent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistentMeshObject_IsBoundToLoginSession = (PLibMCEnvPersistentMeshObject_IsBoundToLoginSessionPtr) GetProcAddress(hLibrary, "libmcenv_persistentmeshobject_isboundtologinsession");
		#else // _WIN32
		pWrapperTable->m_PersistentMeshObject_IsBoundToLoginSession = (PLibMCEnvPersistentMeshObject_IsBoundToLoginSessionPtr) dlsym(hLibrary, "libmcenv_persistentmeshobject_isboundtologinsession");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistentMeshObject_IsBoundToLoginSession == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataMeshInstance_GetName = (PLibMCEnvModelDataMeshInstance_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_modeldatameshinstance_getname");
		#else // _WIN32
		pWrapperTable->m_ModelDataMeshInstance_GetName = (PLibMCEnvModelDataMeshInstance_GetNamePtr) dlsym(hLibrary, "libmcenv_modeldatameshinstance_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataMeshInstance_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataMeshInstance_GetUUID = (PLibMCEnvModelDataMeshInstance_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_modeldatameshinstance_getuuid");
		#else // _WIN32
		pWrapperTable->m_ModelDataMeshInstance_GetUUID = (PLibMCEnvModelDataMeshInstance_GetUUIDPtr) dlsym(hLibrary, "libmcenv_modeldatameshinstance_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataMeshInstance_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataMeshInstance_GetLocalTransform = (PLibMCEnvModelDataMeshInstance_GetLocalTransformPtr) GetProcAddress(hLibrary, "libmcenv_modeldatameshinstance_getlocaltransform");
		#else // _WIN32
		pWrapperTable->m_ModelDataMeshInstance_GetLocalTransform = (PLibMCEnvModelDataMeshInstance_GetLocalTransformPtr) dlsym(hLibrary, "libmcenv_modeldatameshinstance_getlocaltransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataMeshInstance_GetLocalTransform == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataMeshInstance_GetAbsoluteTransform = (PLibMCEnvModelDataMeshInstance_GetAbsoluteTransformPtr) GetProcAddress(hLibrary, "libmcenv_modeldatameshinstance_getabsolutetransform");
		#else // _WIN32
		pWrapperTable->m_ModelDataMeshInstance_GetAbsoluteTransform = (PLibMCEnvModelDataMeshInstance_GetAbsoluteTransformPtr) dlsym(hLibrary, "libmcenv_modeldatameshinstance_getabsolutetransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataMeshInstance_GetAbsoluteTransform == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataMeshInstance_CreateCopiedMesh = (PLibMCEnvModelDataMeshInstance_CreateCopiedMeshPtr) GetProcAddress(hLibrary, "libmcenv_modeldatameshinstance_createcopiedmesh");
		#else // _WIN32
		pWrapperTable->m_ModelDataMeshInstance_CreateCopiedMesh = (PLibMCEnvModelDataMeshInstance_CreateCopiedMeshPtr) dlsym(hLibrary, "libmcenv_modeldatameshinstance_createcopiedmesh");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataMeshInstance_CreateCopiedMesh == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataMeshInstance_CreatePersistentMesh = (PLibMCEnvModelDataMeshInstance_CreatePersistentMeshPtr) GetProcAddress(hLibrary, "libmcenv_modeldatameshinstance_createpersistentmesh");
		#else // _WIN32
		pWrapperTable->m_ModelDataMeshInstance_CreatePersistentMesh = (PLibMCEnvModelDataMeshInstance_CreatePersistentMeshPtr) dlsym(hLibrary, "libmcenv_modeldatameshinstance_createpersistentmesh");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataMeshInstance_CreatePersistentMesh == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetName = (PLibMCEnvModelDataComponentInstance_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getname");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetName = (PLibMCEnvModelDataComponentInstance_GetNamePtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetUUID = (PLibMCEnvModelDataComponentInstance_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getuuid");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetUUID = (PLibMCEnvModelDataComponentInstance_GetUUIDPtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetLocalTransform = (PLibMCEnvModelDataComponentInstance_GetLocalTransformPtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getlocaltransform");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetLocalTransform = (PLibMCEnvModelDataComponentInstance_GetLocalTransformPtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getlocaltransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetLocalTransform == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetAbsoluteTransform = (PLibMCEnvModelDataComponentInstance_GetAbsoluteTransformPtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getabsolutetransform");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetAbsoluteTransform = (PLibMCEnvModelDataComponentInstance_GetAbsoluteTransformPtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getabsolutetransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetAbsoluteTransform == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSolidCount = (PLibMCEnvModelDataComponentInstance_GetSolidCountPtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getsolidcount");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSolidCount = (PLibMCEnvModelDataComponentInstance_GetSolidCountPtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getsolidcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetSolidCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSolidMesh = (PLibMCEnvModelDataComponentInstance_GetSolidMeshPtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getsolidmesh");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSolidMesh = (PLibMCEnvModelDataComponentInstance_GetSolidMeshPtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getsolidmesh");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetSolidMesh == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSupportCount = (PLibMCEnvModelDataComponentInstance_GetSupportCountPtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getsupportcount");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSupportCount = (PLibMCEnvModelDataComponentInstance_GetSupportCountPtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getsupportcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetSupportCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSupportMesh = (PLibMCEnvModelDataComponentInstance_GetSupportMeshPtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getsupportmesh");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSupportMesh = (PLibMCEnvModelDataComponentInstance_GetSupportMeshPtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getsupportmesh");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetSupportMesh == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSubComponentCount = (PLibMCEnvModelDataComponentInstance_GetSubComponentCountPtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getsubcomponentcount");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSubComponentCount = (PLibMCEnvModelDataComponentInstance_GetSubComponentCountPtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getsubcomponentcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetSubComponentCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSubComponent = (PLibMCEnvModelDataComponentInstance_GetSubComponentPtr) GetProcAddress(hLibrary, "libmcenv_modeldatacomponentinstance_getsubcomponent");
		#else // _WIN32
		pWrapperTable->m_ModelDataComponentInstance_GetSubComponent = (PLibMCEnvModelDataComponentInstance_GetSubComponentPtr) dlsym(hLibrary, "libmcenv_modeldatacomponentinstance_getsubcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModelDataComponentInstance_GetSubComponent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshSceneItem_GetItemUUID = (PLibMCEnvMeshSceneItem_GetItemUUIDPtr) GetProcAddress(hLibrary, "libmcenv_meshsceneitem_getitemuuid");
		#else // _WIN32
		pWrapperTable->m_MeshSceneItem_GetItemUUID = (PLibMCEnvMeshSceneItem_GetItemUUIDPtr) dlsym(hLibrary, "libmcenv_meshsceneitem_getitemuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshSceneItem_GetItemUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshSceneItem_GetSceneUUID = (PLibMCEnvMeshSceneItem_GetSceneUUIDPtr) GetProcAddress(hLibrary, "libmcenv_meshsceneitem_getsceneuuid");
		#else // _WIN32
		pWrapperTable->m_MeshSceneItem_GetSceneUUID = (PLibMCEnvMeshSceneItem_GetSceneUUIDPtr) dlsym(hLibrary, "libmcenv_meshsceneitem_getsceneuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshSceneItem_GetSceneUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshSceneItem_GetTransform = (PLibMCEnvMeshSceneItem_GetTransformPtr) GetProcAddress(hLibrary, "libmcenv_meshsceneitem_gettransform");
		#else // _WIN32
		pWrapperTable->m_MeshSceneItem_GetTransform = (PLibMCEnvMeshSceneItem_GetTransformPtr) dlsym(hLibrary, "libmcenv_meshsceneitem_gettransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshSceneItem_GetTransform == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshSceneItem_UpdateTransform = (PLibMCEnvMeshSceneItem_UpdateTransformPtr) GetProcAddress(hLibrary, "libmcenv_meshsceneitem_updatetransform");
		#else // _WIN32
		pWrapperTable->m_MeshSceneItem_UpdateTransform = (PLibMCEnvMeshSceneItem_UpdateTransformPtr) dlsym(hLibrary, "libmcenv_meshsceneitem_updatetransform");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshSceneItem_UpdateTransform == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshSceneItem_GetMeshObject = (PLibMCEnvMeshSceneItem_GetMeshObjectPtr) GetProcAddress(hLibrary, "libmcenv_meshsceneitem_getmeshobject");
		#else // _WIN32
		pWrapperTable->m_MeshSceneItem_GetMeshObject = (PLibMCEnvMeshSceneItem_GetMeshObjectPtr) dlsym(hLibrary, "libmcenv_meshsceneitem_getmeshobject");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshSceneItem_GetMeshObject == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshSceneItem_ReferenceIsValid = (PLibMCEnvMeshSceneItem_ReferenceIsValidPtr) GetProcAddress(hLibrary, "libmcenv_meshsceneitem_referenceisvalid");
		#else // _WIN32
		pWrapperTable->m_MeshSceneItem_ReferenceIsValid = (PLibMCEnvMeshSceneItem_ReferenceIsValidPtr) dlsym(hLibrary, "libmcenv_meshsceneitem_referenceisvalid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshSceneItem_ReferenceIsValid == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshScene_GetSceneUUID = (PLibMCEnvMeshScene_GetSceneUUIDPtr) GetProcAddress(hLibrary, "libmcenv_meshscene_getsceneuuid");
		#else // _WIN32
		pWrapperTable->m_MeshScene_GetSceneUUID = (PLibMCEnvMeshScene_GetSceneUUIDPtr) dlsym(hLibrary, "libmcenv_meshscene_getsceneuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshScene_GetSceneUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshScene_IsBoundToLoginSession = (PLibMCEnvMeshScene_IsBoundToLoginSessionPtr) GetProcAddress(hLibrary, "libmcenv_meshscene_isboundtologinsession");
		#else // _WIN32
		pWrapperTable->m_MeshScene_IsBoundToLoginSession = (PLibMCEnvMeshScene_IsBoundToLoginSessionPtr) dlsym(hLibrary, "libmcenv_meshscene_isboundtologinsession");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshScene_IsBoundToLoginSession == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshScene_AddSceneItem = (PLibMCEnvMeshScene_AddSceneItemPtr) GetProcAddress(hLibrary, "libmcenv_meshscene_addsceneitem");
		#else // _WIN32
		pWrapperTable->m_MeshScene_AddSceneItem = (PLibMCEnvMeshScene_AddSceneItemPtr) dlsym(hLibrary, "libmcenv_meshscene_addsceneitem");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshScene_AddSceneItem == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshScene_AddModelDataMeshAsSceneItem = (PLibMCEnvMeshScene_AddModelDataMeshAsSceneItemPtr) GetProcAddress(hLibrary, "libmcenv_meshscene_addmodeldatameshassceneitem");
		#else // _WIN32
		pWrapperTable->m_MeshScene_AddModelDataMeshAsSceneItem = (PLibMCEnvMeshScene_AddModelDataMeshAsSceneItemPtr) dlsym(hLibrary, "libmcenv_meshscene_addmodeldatameshassceneitem");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshScene_AddModelDataMeshAsSceneItem == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshScene_GetSceneItemCount = (PLibMCEnvMeshScene_GetSceneItemCountPtr) GetProcAddress(hLibrary, "libmcenv_meshscene_getsceneitemcount");
		#else // _WIN32
		pWrapperTable->m_MeshScene_GetSceneItemCount = (PLibMCEnvMeshScene_GetSceneItemCountPtr) dlsym(hLibrary, "libmcenv_meshscene_getsceneitemcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshScene_GetSceneItemCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshScene_GetSceneItem = (PLibMCEnvMeshScene_GetSceneItemPtr) GetProcAddress(hLibrary, "libmcenv_meshscene_getsceneitem");
		#else // _WIN32
		pWrapperTable->m_MeshScene_GetSceneItem = (PLibMCEnvMeshScene_GetSceneItemPtr) dlsym(hLibrary, "libmcenv_meshscene_getsceneitem");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshScene_GetSceneItem == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshScene_FindSceneItem = (PLibMCEnvMeshScene_FindSceneItemPtr) GetProcAddress(hLibrary, "libmcenv_meshscene_findsceneitem");
		#else // _WIN32
		pWrapperTable->m_MeshScene_FindSceneItem = (PLibMCEnvMeshScene_FindSceneItemPtr) dlsym(hLibrary, "libmcenv_meshscene_findsceneitem");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshScene_FindSceneItem == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshScene_HasSceneItem = (PLibMCEnvMeshScene_HasSceneItemPtr) GetProcAddress(hLibrary, "libmcenv_meshscene_hassceneitem");
		#else // _WIN32
		pWrapperTable->m_MeshScene_HasSceneItem = (PLibMCEnvMeshScene_HasSceneItemPtr) dlsym(hLibrary, "libmcenv_meshscene_hassceneitem");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshScene_HasSceneItem == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MeshScene_RemoveSceneItem = (PLibMCEnvMeshScene_RemoveSceneItemPtr) GetProcAddress(hLibrary, "libmcenv_meshscene_removesceneitem");
		#else // _WIN32
		pWrapperTable->m_MeshScene_RemoveSceneItem = (PLibMCEnvMeshScene_RemoveSceneItemPtr) dlsym(hLibrary, "libmcenv_meshscene_removesceneitem");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MeshScene_RemoveSceneItem == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SceneHandler_MeshIsPersistent = (PLibMCEnvSceneHandler_MeshIsPersistentPtr) GetProcAddress(hLibrary, "libmcenv_scenehandler_meshispersistent");
		#else // _WIN32
		pWrapperTable->m_SceneHandler_MeshIsPersistent = (PLibMCEnvSceneHandler_MeshIsPersistentPtr) dlsym(hLibrary, "libmcenv_scenehandler_meshispersistent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SceneHandler_MeshIsPersistent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SceneHandler_FindPersistentMesh = (PLibMCEnvSceneHandler_FindPersistentMeshPtr) GetProcAddress(hLibrary, "libmcenv_scenehandler_findpersistentmesh");
		#else // _WIN32
		pWrapperTable->m_SceneHandler_FindPersistentMesh = (PLibMCEnvSceneHandler_FindPersistentMeshPtr) dlsym(hLibrary, "libmcenv_scenehandler_findpersistentmesh");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SceneHandler_FindPersistentMesh == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SceneHandler_CreateEmptyMeshScene = (PLibMCEnvSceneHandler_CreateEmptyMeshScenePtr) GetProcAddress(hLibrary, "libmcenv_scenehandler_createemptymeshscene");
		#else // _WIN32
		pWrapperTable->m_SceneHandler_CreateEmptyMeshScene = (PLibMCEnvSceneHandler_CreateEmptyMeshScenePtr) dlsym(hLibrary, "libmcenv_scenehandler_createemptymeshscene");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SceneHandler_CreateEmptyMeshScene == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SceneHandler_ReleaseMeshScene = (PLibMCEnvSceneHandler_ReleaseMeshScenePtr) GetProcAddress(hLibrary, "libmcenv_scenehandler_releasemeshscene");
		#else // _WIN32
		pWrapperTable->m_SceneHandler_ReleaseMeshScene = (PLibMCEnvSceneHandler_ReleaseMeshScenePtr) dlsym(hLibrary, "libmcenv_scenehandler_releasemeshscene");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SceneHandler_ReleaseMeshScene == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SceneHandler_Load3MFFromResource = (PLibMCEnvSceneHandler_Load3MFFromResourcePtr) GetProcAddress(hLibrary, "libmcenv_scenehandler_load3mffromresource");
		#else // _WIN32
		pWrapperTable->m_SceneHandler_Load3MFFromResource = (PLibMCEnvSceneHandler_Load3MFFromResourcePtr) dlsym(hLibrary, "libmcenv_scenehandler_load3mffromresource");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SceneHandler_Load3MFFromResource == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SceneHandler_Load3MFFromMemory = (PLibMCEnvSceneHandler_Load3MFFromMemoryPtr) GetProcAddress(hLibrary, "libmcenv_scenehandler_load3mffrommemory");
		#else // _WIN32
		pWrapperTable->m_SceneHandler_Load3MFFromMemory = (PLibMCEnvSceneHandler_Load3MFFromMemoryPtr) dlsym(hLibrary, "libmcenv_scenehandler_load3mffrommemory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SceneHandler_Load3MFFromMemory == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SceneHandler_Load3MFFromStream = (PLibMCEnvSceneHandler_Load3MFFromStreamPtr) GetProcAddress(hLibrary, "libmcenv_scenehandler_load3mffromstream");
		#else // _WIN32
		pWrapperTable->m_SceneHandler_Load3MFFromStream = (PLibMCEnvSceneHandler_Load3MFFromStreamPtr) dlsym(hLibrary, "libmcenv_scenehandler_load3mffromstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SceneHandler_Load3MFFromStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathPart_GetName = (PLibMCEnvToolpathPart_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_toolpathpart_getname");
		#else // _WIN32
		pWrapperTable->m_ToolpathPart_GetName = (PLibMCEnvToolpathPart_GetNamePtr) dlsym(hLibrary, "libmcenv_toolpathpart_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathPart_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathPart_GetUUID = (PLibMCEnvToolpathPart_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathpart_getuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathPart_GetUUID = (PLibMCEnvToolpathPart_GetUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathpart_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathPart_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathPart_GetRootComponent = (PLibMCEnvToolpathPart_GetRootComponentPtr) GetProcAddress(hLibrary, "libmcenv_toolpathpart_getrootcomponent");
		#else // _WIN32
		pWrapperTable->m_ToolpathPart_GetRootComponent = (PLibMCEnvToolpathPart_GetRootComponentPtr) dlsym(hLibrary, "libmcenv_toolpathpart_getrootcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathPart_GetRootComponent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetLayerDataUUID = (PLibMCEnvToolpathLayer_GetLayerDataUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getlayerdatauuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetLayerDataUUID = (PLibMCEnvToolpathLayer_GetLayerDataUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getlayerdatauuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetLayerDataUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentCount = (PLibMCEnvToolpathLayer_GetSegmentCountPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentcount");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentCount = (PLibMCEnvToolpathLayer_GetSegmentCountPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentInfo = (PLibMCEnvToolpathLayer_GetSegmentInfoPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentinfo");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentInfo = (PLibMCEnvToolpathLayer_GetSegmentInfoPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentinfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentType = (PLibMCEnvToolpathLayer_GetSegmentTypePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmenttype");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentType = (PLibMCEnvToolpathLayer_GetSegmentTypePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmenttype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentType == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_SegmentIsLoop = (PLibMCEnvToolpathLayer_SegmentIsLoopPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_segmentisloop");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_SegmentIsLoop = (PLibMCEnvToolpathLayer_SegmentIsLoopPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_segmentisloop");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_SegmentIsLoop == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_SegmentIsPolyline = (PLibMCEnvToolpathLayer_SegmentIsPolylinePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_segmentispolyline");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_SegmentIsPolyline = (PLibMCEnvToolpathLayer_SegmentIsPolylinePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_segmentispolyline");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_SegmentIsPolyline == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_SegmentIsHatchSegment = (PLibMCEnvToolpathLayer_SegmentIsHatchSegmentPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_segmentishatchsegment");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_SegmentIsHatchSegment = (PLibMCEnvToolpathLayer_SegmentIsHatchSegmentPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_segmentishatchsegment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_SegmentIsHatchSegment == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentIntegerAttribute = (PLibMCEnvToolpathLayer_GetSegmentIntegerAttributePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentintegerattribute");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentIntegerAttribute = (PLibMCEnvToolpathLayer_GetSegmentIntegerAttributePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentintegerattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentIntegerAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentDoubleAttribute = (PLibMCEnvToolpathLayer_GetSegmentDoubleAttributePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentdoubleattribute");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentDoubleAttribute = (PLibMCEnvToolpathLayer_GetSegmentDoubleAttributePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentdoubleattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentDoubleAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_HasCustomSegmentAttribute = (PLibMCEnvToolpathLayer_HasCustomSegmentAttributePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_hascustomsegmentattribute");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_HasCustomSegmentAttribute = (PLibMCEnvToolpathLayer_HasCustomSegmentAttributePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_hascustomsegmentattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_HasCustomSegmentAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeID = (PLibMCEnvToolpathLayer_FindCustomSegmentAttributeIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_findcustomsegmentattributeid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeID = (PLibMCEnvToolpathLayer_FindCustomSegmentAttributeIDPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_findcustomsegmentattributeid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeType = (PLibMCEnvToolpathLayer_FindCustomSegmentAttributeTypePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_findcustomsegmentattributetype");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeType = (PLibMCEnvToolpathLayer_FindCustomSegmentAttributeTypePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_findcustomsegmentattributetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeType == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeInfo = (PLibMCEnvToolpathLayer_FindCustomSegmentAttributeInfoPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_findcustomsegmentattributeinfo");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeInfo = (PLibMCEnvToolpathLayer_FindCustomSegmentAttributeInfoPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_findcustomsegmentattributeinfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPointCount = (PLibMCEnvToolpathLayer_GetSegmentPointCountPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentpointcount");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPointCount = (PLibMCEnvToolpathLayer_GetSegmentPointCountPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentpointcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentPointCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentHatchCount = (PLibMCEnvToolpathLayer_GetSegmentHatchCountPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmenthatchcount");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentHatchCount = (PLibMCEnvToolpathLayer_GetSegmentHatchCountPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmenthatchcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentHatchCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID = (PLibMCEnvToolpathLayer_GetSegmentProfileUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID = (PLibMCEnvToolpathLayer_GetSegmentProfileUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_SegmentProfileHasValue = (PLibMCEnvToolpathLayer_SegmentProfileHasValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_segmentprofilehasvalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_SegmentProfileHasValue = (PLibMCEnvToolpathLayer_SegmentProfileHasValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_segmentprofilehasvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_SegmentProfileHasValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue = (PLibMCEnvToolpathLayer_GetSegmentProfileValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofilevalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue = (PLibMCEnvToolpathLayer_GetSegmentProfileValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofilevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileValueDefPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofilevaluedef");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileValueDefPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofilevaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValue = (PLibMCEnvToolpathLayer_GetSegmentProfileDoubleValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiledoublevalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValue = (PLibMCEnvToolpathLayer_GetSegmentProfileDoubleValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiledoublevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileDoubleValueDefPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiledoublevaluedef");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileDoubleValueDefPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiledoublevaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValue = (PLibMCEnvToolpathLayer_GetSegmentProfileIntegerValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileintegervalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValue = (PLibMCEnvToolpathLayer_GetSegmentProfileIntegerValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileintegervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileIntegerValueDefPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileintegervaluedef");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileIntegerValueDefPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileintegervaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValue = (PLibMCEnvToolpathLayer_GetSegmentProfileBoolValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileboolvalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValue = (PLibMCEnvToolpathLayer_GetSegmentProfileBoolValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileboolvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileBoolValueDefPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileboolvaluedef");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileBoolValueDefPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileboolvaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue = (PLibMCEnvToolpathLayer_GetSegmentProfileTypedValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiletypedvalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue = (PLibMCEnvToolpathLayer_GetSegmentProfileTypedValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiletypedvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileTypedValueDefPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiletypedvaluedef");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValueDef = (PLibMCEnvToolpathLayer_GetSegmentProfileTypedValueDefPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiletypedvaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID = (PLibMCEnvToolpathLayer_GetSegmentPartUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentpartuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID = (PLibMCEnvToolpathLayer_GetSegmentPartUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentpartuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPointData = (PLibMCEnvToolpathLayer_GetSegmentPointDataPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentpointdata");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPointData = (PLibMCEnvToolpathLayer_GetSegmentPointDataPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentpointdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentPointData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentHatchData = (PLibMCEnvToolpathLayer_GetSegmentHatchDataPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmenthatchdata");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentHatchData = (PLibMCEnvToolpathLayer_GetSegmentHatchDataPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmenthatchdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentHatchData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPointDataInMM = (PLibMCEnvToolpathLayer_GetSegmentPointDataInMMPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentpointdatainmm");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPointDataInMM = (PLibMCEnvToolpathLayer_GetSegmentPointDataInMMPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentpointdatainmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentPointDataInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentHatchDataInMM = (PLibMCEnvToolpathLayer_GetSegmentHatchDataInMMPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmenthatchdatainmm");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentHatchDataInMM = (PLibMCEnvToolpathLayer_GetSegmentHatchDataInMMPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmenthatchdatainmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentHatchDataInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetZValue = (PLibMCEnvToolpathLayer_GetZValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getzvalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetZValue = (PLibMCEnvToolpathLayer_GetZValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getzvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetZValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetZValueInMM = (PLibMCEnvToolpathLayer_GetZValueInMMPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getzvalueinmm");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetZValueInMM = (PLibMCEnvToolpathLayer_GetZValueInMMPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getzvalueinmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetZValueInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetUnits = (PLibMCEnvToolpathLayer_GetUnitsPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getunits");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetUnits = (PLibMCEnvToolpathLayer_GetUnitsPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getunits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetUnits == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetMetaDataCount = (PLibMCEnvToolpathLayer_GetMetaDataCountPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getmetadatacount");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetMetaDataCount = (PLibMCEnvToolpathLayer_GetMetaDataCountPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getmetadatacount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetMetaDataCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetMetaDataInfo = (PLibMCEnvToolpathLayer_GetMetaDataInfoPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getmetadatainfo");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetMetaDataInfo = (PLibMCEnvToolpathLayer_GetMetaDataInfoPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getmetadatainfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetMetaDataInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetMetaDataContent = (PLibMCEnvToolpathLayer_GetMetaDataContentPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getmetadatacontent");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetMetaDataContent = (PLibMCEnvToolpathLayer_GetMetaDataContentPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getmetadatacontent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetMetaDataContent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_HasUniqueMetaData = (PLibMCEnvToolpathLayer_HasUniqueMetaDataPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_hasuniquemetadata");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_HasUniqueMetaData = (PLibMCEnvToolpathLayer_HasUniqueMetaDataPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_hasuniquemetadata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_HasUniqueMetaData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_FindUniqueMetaData = (PLibMCEnvToolpathLayer_FindUniqueMetaDataPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_finduniquemetadata");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_FindUniqueMetaData = (PLibMCEnvToolpathLayer_FindUniqueMetaDataPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_finduniquemetadata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_FindUniqueMetaData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_CalculateExtents = (PLibMCEnvToolpathLayer_CalculateExtentsPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_calculateextents");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_CalculateExtents = (PLibMCEnvToolpathLayer_CalculateExtentsPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_calculateextents");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_CalculateExtents == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_CalculateExtentsInMM = (PLibMCEnvToolpathLayer_CalculateExtentsInMMPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_calculateextentsinmm");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_CalculateExtentsInMM = (PLibMCEnvToolpathLayer_CalculateExtentsInMMPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_calculateextentsinmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_CalculateExtentsInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetStorageUUID = (PLibMCEnvToolpathAccessor_GetStorageUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getstorageuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetStorageUUID = (PLibMCEnvToolpathAccessor_GetStorageUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getstorageuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetStorageUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetBuildUUID = (PLibMCEnvToolpathAccessor_GetBuildUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getbuilduuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetBuildUUID = (PLibMCEnvToolpathAccessor_GetBuildUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getbuilduuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetBuildUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetLayerCount = (PLibMCEnvToolpathAccessor_GetLayerCountPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getlayercount");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetLayerCount = (PLibMCEnvToolpathAccessor_GetLayerCountPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetLayerCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_RegisterCustomSegmentAttribute = (PLibMCEnvToolpathAccessor_RegisterCustomSegmentAttributePtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_registercustomsegmentattribute");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_RegisterCustomSegmentAttribute = (PLibMCEnvToolpathAccessor_RegisterCustomSegmentAttributePtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_registercustomsegmentattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_RegisterCustomSegmentAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_LoadLayer = (PLibMCEnvToolpathAccessor_LoadLayerPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_loadlayer");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_LoadLayer = (PLibMCEnvToolpathAccessor_LoadLayerPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_loadlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_LoadLayer == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetUnits = (PLibMCEnvToolpathAccessor_GetUnitsPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getunits");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetUnits = (PLibMCEnvToolpathAccessor_GetUnitsPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getunits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetUnits == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetPartCount = (PLibMCEnvToolpathAccessor_GetPartCountPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getpartcount");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetPartCount = (PLibMCEnvToolpathAccessor_GetPartCountPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getpartcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetPartCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetPart = (PLibMCEnvToolpathAccessor_GetPartPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getpart");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetPart = (PLibMCEnvToolpathAccessor_GetPartPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getpart");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetPart == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_FindPartByUUID = (PLibMCEnvToolpathAccessor_FindPartByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_findpartbyuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_FindPartByUUID = (PLibMCEnvToolpathAccessor_FindPartByUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_findpartbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_FindPartByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetBuildHeightInUnits = (PLibMCEnvToolpathAccessor_GetBuildHeightInUnitsPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getbuildheightinunits");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetBuildHeightInUnits = (PLibMCEnvToolpathAccessor_GetBuildHeightInUnitsPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getbuildheightinunits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetBuildHeightInUnits == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetZValueInUnits = (PLibMCEnvToolpathAccessor_GetZValueInUnitsPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getzvalueinunits");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetZValueInUnits = (PLibMCEnvToolpathAccessor_GetZValueInUnitsPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getzvalueinunits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetZValueInUnits == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetBuildHeightInMM = (PLibMCEnvToolpathAccessor_GetBuildHeightInMMPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getbuildheightinmm");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetBuildHeightInMM = (PLibMCEnvToolpathAccessor_GetBuildHeightInMMPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getbuildheightinmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetBuildHeightInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetZValueInMM = (PLibMCEnvToolpathAccessor_GetZValueInMMPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getzvalueinmm");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetZValueInMM = (PLibMCEnvToolpathAccessor_GetZValueInMMPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getzvalueinmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetZValueInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetMetaDataCount = (PLibMCEnvToolpathAccessor_GetMetaDataCountPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getmetadatacount");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetMetaDataCount = (PLibMCEnvToolpathAccessor_GetMetaDataCountPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getmetadatacount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetMetaDataCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetMetaDataInfo = (PLibMCEnvToolpathAccessor_GetMetaDataInfoPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getmetadatainfo");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetMetaDataInfo = (PLibMCEnvToolpathAccessor_GetMetaDataInfoPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getmetadatainfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetMetaDataInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetMetaDataContent = (PLibMCEnvToolpathAccessor_GetMetaDataContentPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getmetadatacontent");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetMetaDataContent = (PLibMCEnvToolpathAccessor_GetMetaDataContentPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getmetadatacontent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetMetaDataContent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_HasUniqueMetaData = (PLibMCEnvToolpathAccessor_HasUniqueMetaDataPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_hasuniquemetadata");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_HasUniqueMetaData = (PLibMCEnvToolpathAccessor_HasUniqueMetaDataPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_hasuniquemetadata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_HasUniqueMetaData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_FindUniqueMetaData = (PLibMCEnvToolpathAccessor_FindUniqueMetaDataPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_finduniquemetadata");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_FindUniqueMetaData = (PLibMCEnvToolpathAccessor_FindUniqueMetaDataPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_finduniquemetadata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_FindUniqueMetaData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetUUID = (PLibMCEnvBuildExecution_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getuuid");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetUUID = (PLibMCEnvBuildExecution_GetUUIDPtr) dlsym(hLibrary, "libmcenv_buildexecution_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetBuildUUID = (PLibMCEnvBuildExecution_GetBuildUUIDPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getbuilduuid");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetBuildUUID = (PLibMCEnvBuildExecution_GetBuildUUIDPtr) dlsym(hLibrary, "libmcenv_buildexecution_getbuilduuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetBuildUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetBuild = (PLibMCEnvBuildExecution_GetBuildPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getbuild");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetBuild = (PLibMCEnvBuildExecution_GetBuildPtr) dlsym(hLibrary, "libmcenv_buildexecution_getbuild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetBuild == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetExecutionStatus = (PLibMCEnvBuildExecution_GetExecutionStatusPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getexecutionstatus");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetExecutionStatus = (PLibMCEnvBuildExecution_GetExecutionStatusPtr) dlsym(hLibrary, "libmcenv_buildexecution_getexecutionstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetExecutionStatus == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_IsInProcess = (PLibMCEnvBuildExecution_IsInProcessPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_isinprocess");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_IsInProcess = (PLibMCEnvBuildExecution_IsInProcessPtr) dlsym(hLibrary, "libmcenv_buildexecution_isinprocess");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_IsInProcess == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_IsFinished = (PLibMCEnvBuildExecution_IsFinishedPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_isfinished");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_IsFinished = (PLibMCEnvBuildExecution_IsFinishedPtr) dlsym(hLibrary, "libmcenv_buildexecution_isfinished");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_IsFinished == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_IsFailed = (PLibMCEnvBuildExecution_IsFailedPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_isfailed");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_IsFailed = (PLibMCEnvBuildExecution_IsFailedPtr) dlsym(hLibrary, "libmcenv_buildexecution_isfailed");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_IsFailed == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_SetStatusToFinished = (PLibMCEnvBuildExecution_SetStatusToFinishedPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_setstatustofinished");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_SetStatusToFinished = (PLibMCEnvBuildExecution_SetStatusToFinishedPtr) dlsym(hLibrary, "libmcenv_buildexecution_setstatustofinished");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_SetStatusToFinished == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_SetStatusToFailed = (PLibMCEnvBuildExecution_SetStatusToFailedPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_setstatustofailed");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_SetStatusToFailed = (PLibMCEnvBuildExecution_SetStatusToFailedPtr) dlsym(hLibrary, "libmcenv_buildexecution_setstatustofailed");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_SetStatusToFailed == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetDescription = (PLibMCEnvBuildExecution_GetDescriptionPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getdescription");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetDescription = (PLibMCEnvBuildExecution_GetDescriptionPtr) dlsym(hLibrary, "libmcenv_buildexecution_getdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetDescription == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_SetDescription = (PLibMCEnvBuildExecution_SetDescriptionPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_setdescription");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_SetDescription = (PLibMCEnvBuildExecution_SetDescriptionPtr) dlsym(hLibrary, "libmcenv_buildexecution_setdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_SetDescription == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetJournalUUID = (PLibMCEnvBuildExecution_GetJournalUUIDPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getjournaluuid");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetJournalUUID = (PLibMCEnvBuildExecution_GetJournalUUIDPtr) dlsym(hLibrary, "libmcenv_buildexecution_getjournaluuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetJournalUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_HasAttachedUser = (PLibMCEnvBuildExecution_HasAttachedUserPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_hasattacheduser");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_HasAttachedUser = (PLibMCEnvBuildExecution_HasAttachedUserPtr) dlsym(hLibrary, "libmcenv_buildexecution_hasattacheduser");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_HasAttachedUser == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetUserUUID = (PLibMCEnvBuildExecution_GetUserUUIDPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getuseruuid");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetUserUUID = (PLibMCEnvBuildExecution_GetUserUUIDPtr) dlsym(hLibrary, "libmcenv_buildexecution_getuseruuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetUserUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetStartTimeStampInMilliseconds = (PLibMCEnvBuildExecution_GetStartTimeStampInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getstarttimestampinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetStartTimeStampInMilliseconds = (PLibMCEnvBuildExecution_GetStartTimeStampInMillisecondsPtr) dlsym(hLibrary, "libmcenv_buildexecution_getstarttimestampinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetStartTimeStampInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetStartTimeStampInMicroseconds = (PLibMCEnvBuildExecution_GetStartTimeStampInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getstarttimestampinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetStartTimeStampInMicroseconds = (PLibMCEnvBuildExecution_GetStartTimeStampInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_buildexecution_getstarttimestampinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetStartTimeStampInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetEndTimeStampInMilliseconds = (PLibMCEnvBuildExecution_GetEndTimeStampInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getendtimestampinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetEndTimeStampInMilliseconds = (PLibMCEnvBuildExecution_GetEndTimeStampInMillisecondsPtr) dlsym(hLibrary, "libmcenv_buildexecution_getendtimestampinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetEndTimeStampInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetEndTimeStampInMicroseconds = (PLibMCEnvBuildExecution_GetEndTimeStampInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getendtimestampinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetEndTimeStampInMicroseconds = (PLibMCEnvBuildExecution_GetEndTimeStampInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_buildexecution_getendtimestampinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetEndTimeStampInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetElapsedTimeInMilliseconds = (PLibMCEnvBuildExecution_GetElapsedTimeInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getelapsedtimeinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetElapsedTimeInMilliseconds = (PLibMCEnvBuildExecution_GetElapsedTimeInMillisecondsPtr) dlsym(hLibrary, "libmcenv_buildexecution_getelapsedtimeinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetElapsedTimeInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetElapsedTimeInMicroseconds = (PLibMCEnvBuildExecution_GetElapsedTimeInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getelapsedtimeinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetElapsedTimeInMicroseconds = (PLibMCEnvBuildExecution_GetElapsedTimeInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_buildexecution_getelapsedtimeinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetElapsedTimeInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_HasAttachment = (PLibMCEnvBuildExecution_HasAttachmentPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_hasattachment");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_HasAttachment = (PLibMCEnvBuildExecution_HasAttachmentPtr) dlsym(hLibrary, "libmcenv_buildexecution_hasattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_HasAttachment == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_HasAttachmentIdentifier = (PLibMCEnvBuildExecution_HasAttachmentIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_hasattachmentidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_HasAttachmentIdentifier = (PLibMCEnvBuildExecution_HasAttachmentIdentifierPtr) dlsym(hLibrary, "libmcenv_buildexecution_hasattachmentidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_HasAttachmentIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_AddBinaryData = (PLibMCEnvBuildExecution_AddBinaryDataPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_addbinarydata");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_AddBinaryData = (PLibMCEnvBuildExecution_AddBinaryDataPtr) dlsym(hLibrary, "libmcenv_buildexecution_addbinarydata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_AddBinaryData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_AttachTempStream = (PLibMCEnvBuildExecution_AttachTempStreamPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_attachtempstream");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_AttachTempStream = (PLibMCEnvBuildExecution_AttachTempStreamPtr) dlsym(hLibrary, "libmcenv_buildexecution_attachtempstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_AttachTempStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_LoadStreamByIdentifier = (PLibMCEnvBuildExecution_LoadStreamByIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_loadstreambyidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_LoadStreamByIdentifier = (PLibMCEnvBuildExecution_LoadStreamByIdentifierPtr) dlsym(hLibrary, "libmcenv_buildexecution_loadstreambyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_LoadStreamByIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_LoadStreamByUUID = (PLibMCEnvBuildExecution_LoadStreamByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_loadstreambyuuid");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_LoadStreamByUUID = (PLibMCEnvBuildExecution_LoadStreamByUUIDPtr) dlsym(hLibrary, "libmcenv_buildexecution_loadstreambyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_LoadStreamByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_LoadDiscreteField2DByIdentifier = (PLibMCEnvBuildExecution_LoadDiscreteField2DByIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_loaddiscretefield2dbyidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_LoadDiscreteField2DByIdentifier = (PLibMCEnvBuildExecution_LoadDiscreteField2DByIdentifierPtr) dlsym(hLibrary, "libmcenv_buildexecution_loaddiscretefield2dbyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_LoadDiscreteField2DByIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_LoadDiscreteField2DByUUID = (PLibMCEnvBuildExecution_LoadDiscreteField2DByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_loaddiscretefield2dbyuuid");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_LoadDiscreteField2DByUUID = (PLibMCEnvBuildExecution_LoadDiscreteField2DByUUIDPtr) dlsym(hLibrary, "libmcenv_buildexecution_loaddiscretefield2dbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_LoadDiscreteField2DByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_StoreDiscreteField2D = (PLibMCEnvBuildExecution_StoreDiscreteField2DPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_storediscretefield2d");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_StoreDiscreteField2D = (PLibMCEnvBuildExecution_StoreDiscreteField2DPtr) dlsym(hLibrary, "libmcenv_buildexecution_storediscretefield2d");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_StoreDiscreteField2D == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_LoadDataTableByIdentifier = (PLibMCEnvBuildExecution_LoadDataTableByIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_loaddatatablebyidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_LoadDataTableByIdentifier = (PLibMCEnvBuildExecution_LoadDataTableByIdentifierPtr) dlsym(hLibrary, "libmcenv_buildexecution_loaddatatablebyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_LoadDataTableByIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_LoadDataTableByUUID = (PLibMCEnvBuildExecution_LoadDataTableByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_loaddatatablebyuuid");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_LoadDataTableByUUID = (PLibMCEnvBuildExecution_LoadDataTableByUUIDPtr) dlsym(hLibrary, "libmcenv_buildexecution_loaddatatablebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_LoadDataTableByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_StoreDataTable = (PLibMCEnvBuildExecution_StoreDataTablePtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_storedatatable");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_StoreDataTable = (PLibMCEnvBuildExecution_StoreDataTablePtr) dlsym(hLibrary, "libmcenv_buildexecution_storedatatable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_StoreDataTable == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_LoadPNGImageByIdentifier = (PLibMCEnvBuildExecution_LoadPNGImageByIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_loadpngimagebyidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_LoadPNGImageByIdentifier = (PLibMCEnvBuildExecution_LoadPNGImageByIdentifierPtr) dlsym(hLibrary, "libmcenv_buildexecution_loadpngimagebyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_LoadPNGImageByIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_LoadPNGImageByUUID = (PLibMCEnvBuildExecution_LoadPNGImageByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_loadpngimagebyuuid");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_LoadPNGImageByUUID = (PLibMCEnvBuildExecution_LoadPNGImageByUUIDPtr) dlsym(hLibrary, "libmcenv_buildexecution_loadpngimagebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_LoadPNGImageByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_StorePNGImage = (PLibMCEnvBuildExecution_StorePNGImagePtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_storepngimage");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_StorePNGImage = (PLibMCEnvBuildExecution_StorePNGImagePtr) dlsym(hLibrary, "libmcenv_buildexecution_storepngimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_StorePNGImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_StoreMetaDataString = (PLibMCEnvBuildExecution_StoreMetaDataStringPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_storemetadatastring");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_StoreMetaDataString = (PLibMCEnvBuildExecution_StoreMetaDataStringPtr) dlsym(hLibrary, "libmcenv_buildexecution_storemetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_StoreMetaDataString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_HasMetaDataString = (PLibMCEnvBuildExecution_HasMetaDataStringPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_hasmetadatastring");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_HasMetaDataString = (PLibMCEnvBuildExecution_HasMetaDataStringPtr) dlsym(hLibrary, "libmcenv_buildexecution_hasmetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_HasMetaDataString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_GetMetaDataString = (PLibMCEnvBuildExecution_GetMetaDataStringPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_getmetadatastring");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_GetMetaDataString = (PLibMCEnvBuildExecution_GetMetaDataStringPtr) dlsym(hLibrary, "libmcenv_buildexecution_getmetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_GetMetaDataString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecution_LoadAttachedJournal = (PLibMCEnvBuildExecution_LoadAttachedJournalPtr) GetProcAddress(hLibrary, "libmcenv_buildexecution_loadattachedjournal");
		#else // _WIN32
		pWrapperTable->m_BuildExecution_LoadAttachedJournal = (PLibMCEnvBuildExecution_LoadAttachedJournalPtr) dlsym(hLibrary, "libmcenv_buildexecution_loadattachedjournal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecution_LoadAttachedJournal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildExecutionIterator_GetCurrentExecution = (PLibMCEnvBuildExecutionIterator_GetCurrentExecutionPtr) GetProcAddress(hLibrary, "libmcenv_buildexecutioniterator_getcurrentexecution");
		#else // _WIN32
		pWrapperTable->m_BuildExecutionIterator_GetCurrentExecution = (PLibMCEnvBuildExecutionIterator_GetCurrentExecutionPtr) dlsym(hLibrary, "libmcenv_buildexecutioniterator_getcurrentexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildExecutionIterator_GetCurrentExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetName = (PLibMCEnvBuild_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_build_getname");
		#else // _WIN32
		pWrapperTable->m_Build_GetName = (PLibMCEnvBuild_GetNamePtr) dlsym(hLibrary, "libmcenv_build_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetBuildUUID = (PLibMCEnvBuild_GetBuildUUIDPtr) GetProcAddress(hLibrary, "libmcenv_build_getbuilduuid");
		#else // _WIN32
		pWrapperTable->m_Build_GetBuildUUID = (PLibMCEnvBuild_GetBuildUUIDPtr) dlsym(hLibrary, "libmcenv_build_getbuilduuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetBuildUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetStorageUUID = (PLibMCEnvBuild_GetStorageUUIDPtr) GetProcAddress(hLibrary, "libmcenv_build_getstorageuuid");
		#else // _WIN32
		pWrapperTable->m_Build_GetStorageUUID = (PLibMCEnvBuild_GetStorageUUIDPtr) dlsym(hLibrary, "libmcenv_build_getstorageuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetStorageUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetStorageSHA256 = (PLibMCEnvBuild_GetStorageSHA256Ptr) GetProcAddress(hLibrary, "libmcenv_build_getstoragesha256");
		#else // _WIN32
		pWrapperTable->m_Build_GetStorageSHA256 = (PLibMCEnvBuild_GetStorageSHA256Ptr) dlsym(hLibrary, "libmcenv_build_getstoragesha256");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetStorageSHA256 == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetLayerCount = (PLibMCEnvBuild_GetLayerCountPtr) GetProcAddress(hLibrary, "libmcenv_build_getlayercount");
		#else // _WIN32
		pWrapperTable->m_Build_GetLayerCount = (PLibMCEnvBuild_GetLayerCountPtr) dlsym(hLibrary, "libmcenv_build_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetLayerCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetBuildHeightInMM = (PLibMCEnvBuild_GetBuildHeightInMMPtr) GetProcAddress(hLibrary, "libmcenv_build_getbuildheightinmm");
		#else // _WIN32
		pWrapperTable->m_Build_GetBuildHeightInMM = (PLibMCEnvBuild_GetBuildHeightInMMPtr) dlsym(hLibrary, "libmcenv_build_getbuildheightinmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetBuildHeightInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetZValueInMM = (PLibMCEnvBuild_GetZValueInMMPtr) GetProcAddress(hLibrary, "libmcenv_build_getzvalueinmm");
		#else // _WIN32
		pWrapperTable->m_Build_GetZValueInMM = (PLibMCEnvBuild_GetZValueInMMPtr) dlsym(hLibrary, "libmcenv_build_getzvalueinmm");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetZValueInMM == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadToolpath = (PLibMCEnvBuild_LoadToolpathPtr) GetProcAddress(hLibrary, "libmcenv_build_loadtoolpath");
		#else // _WIN32
		pWrapperTable->m_Build_LoadToolpath = (PLibMCEnvBuild_LoadToolpathPtr) dlsym(hLibrary, "libmcenv_build_loadtoolpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadToolpath == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_UnloadToolpath = (PLibMCEnvBuild_UnloadToolpathPtr) GetProcAddress(hLibrary, "libmcenv_build_unloadtoolpath");
		#else // _WIN32
		pWrapperTable->m_Build_UnloadToolpath = (PLibMCEnvBuild_UnloadToolpathPtr) dlsym(hLibrary, "libmcenv_build_unloadtoolpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_UnloadToolpath == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_ToolpathIsLoaded = (PLibMCEnvBuild_ToolpathIsLoadedPtr) GetProcAddress(hLibrary, "libmcenv_build_toolpathisloaded");
		#else // _WIN32
		pWrapperTable->m_Build_ToolpathIsLoaded = (PLibMCEnvBuild_ToolpathIsLoadedPtr) dlsym(hLibrary, "libmcenv_build_toolpathisloaded");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_ToolpathIsLoaded == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_CreateToolpathAccessor = (PLibMCEnvBuild_CreateToolpathAccessorPtr) GetProcAddress(hLibrary, "libmcenv_build_createtoolpathaccessor");
		#else // _WIN32
		pWrapperTable->m_Build_CreateToolpathAccessor = (PLibMCEnvBuild_CreateToolpathAccessorPtr) dlsym(hLibrary, "libmcenv_build_createtoolpathaccessor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_CreateToolpathAccessor == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_HasAttachment = (PLibMCEnvBuild_HasAttachmentPtr) GetProcAddress(hLibrary, "libmcenv_build_hasattachment");
		#else // _WIN32
		pWrapperTable->m_Build_HasAttachment = (PLibMCEnvBuild_HasAttachmentPtr) dlsym(hLibrary, "libmcenv_build_hasattachment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_HasAttachment == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_HasAttachmentIdentifier = (PLibMCEnvBuild_HasAttachmentIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_build_hasattachmentidentifier");
		#else // _WIN32
		pWrapperTable->m_Build_HasAttachmentIdentifier = (PLibMCEnvBuild_HasAttachmentIdentifierPtr) dlsym(hLibrary, "libmcenv_build_hasattachmentidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_HasAttachmentIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_AddBinaryData = (PLibMCEnvBuild_AddBinaryDataPtr) GetProcAddress(hLibrary, "libmcenv_build_addbinarydata");
		#else // _WIN32
		pWrapperTable->m_Build_AddBinaryData = (PLibMCEnvBuild_AddBinaryDataPtr) dlsym(hLibrary, "libmcenv_build_addbinarydata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_AddBinaryData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_AttachTempStream = (PLibMCEnvBuild_AttachTempStreamPtr) GetProcAddress(hLibrary, "libmcenv_build_attachtempstream");
		#else // _WIN32
		pWrapperTable->m_Build_AttachTempStream = (PLibMCEnvBuild_AttachTempStreamPtr) dlsym(hLibrary, "libmcenv_build_attachtempstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_AttachTempStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadStreamByIdentifier = (PLibMCEnvBuild_LoadStreamByIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_build_loadstreambyidentifier");
		#else // _WIN32
		pWrapperTable->m_Build_LoadStreamByIdentifier = (PLibMCEnvBuild_LoadStreamByIdentifierPtr) dlsym(hLibrary, "libmcenv_build_loadstreambyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadStreamByIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadStreamByUUID = (PLibMCEnvBuild_LoadStreamByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_build_loadstreambyuuid");
		#else // _WIN32
		pWrapperTable->m_Build_LoadStreamByUUID = (PLibMCEnvBuild_LoadStreamByUUIDPtr) dlsym(hLibrary, "libmcenv_build_loadstreambyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadStreamByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadDiscreteField2DByIdentifier = (PLibMCEnvBuild_LoadDiscreteField2DByIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_build_loaddiscretefield2dbyidentifier");
		#else // _WIN32
		pWrapperTable->m_Build_LoadDiscreteField2DByIdentifier = (PLibMCEnvBuild_LoadDiscreteField2DByIdentifierPtr) dlsym(hLibrary, "libmcenv_build_loaddiscretefield2dbyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadDiscreteField2DByIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadDiscreteField2DByUUID = (PLibMCEnvBuild_LoadDiscreteField2DByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_build_loaddiscretefield2dbyuuid");
		#else // _WIN32
		pWrapperTable->m_Build_LoadDiscreteField2DByUUID = (PLibMCEnvBuild_LoadDiscreteField2DByUUIDPtr) dlsym(hLibrary, "libmcenv_build_loaddiscretefield2dbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadDiscreteField2DByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_StoreDiscreteField2D = (PLibMCEnvBuild_StoreDiscreteField2DPtr) GetProcAddress(hLibrary, "libmcenv_build_storediscretefield2d");
		#else // _WIN32
		pWrapperTable->m_Build_StoreDiscreteField2D = (PLibMCEnvBuild_StoreDiscreteField2DPtr) dlsym(hLibrary, "libmcenv_build_storediscretefield2d");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_StoreDiscreteField2D == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadDataTableByIdentifier = (PLibMCEnvBuild_LoadDataTableByIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_build_loaddatatablebyidentifier");
		#else // _WIN32
		pWrapperTable->m_Build_LoadDataTableByIdentifier = (PLibMCEnvBuild_LoadDataTableByIdentifierPtr) dlsym(hLibrary, "libmcenv_build_loaddatatablebyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadDataTableByIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadDataTableByUUID = (PLibMCEnvBuild_LoadDataTableByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_build_loaddatatablebyuuid");
		#else // _WIN32
		pWrapperTable->m_Build_LoadDataTableByUUID = (PLibMCEnvBuild_LoadDataTableByUUIDPtr) dlsym(hLibrary, "libmcenv_build_loaddatatablebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadDataTableByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_StoreDataTable = (PLibMCEnvBuild_StoreDataTablePtr) GetProcAddress(hLibrary, "libmcenv_build_storedatatable");
		#else // _WIN32
		pWrapperTable->m_Build_StoreDataTable = (PLibMCEnvBuild_StoreDataTablePtr) dlsym(hLibrary, "libmcenv_build_storedatatable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_StoreDataTable == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadPNGImageByIdentifier = (PLibMCEnvBuild_LoadPNGImageByIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_build_loadpngimagebyidentifier");
		#else // _WIN32
		pWrapperTable->m_Build_LoadPNGImageByIdentifier = (PLibMCEnvBuild_LoadPNGImageByIdentifierPtr) dlsym(hLibrary, "libmcenv_build_loadpngimagebyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadPNGImageByIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadPNGImageByUUID = (PLibMCEnvBuild_LoadPNGImageByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_build_loadpngimagebyuuid");
		#else // _WIN32
		pWrapperTable->m_Build_LoadPNGImageByUUID = (PLibMCEnvBuild_LoadPNGImageByUUIDPtr) dlsym(hLibrary, "libmcenv_build_loadpngimagebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadPNGImageByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_StorePNGImage = (PLibMCEnvBuild_StorePNGImagePtr) GetProcAddress(hLibrary, "libmcenv_build_storepngimage");
		#else // _WIN32
		pWrapperTable->m_Build_StorePNGImage = (PLibMCEnvBuild_StorePNGImagePtr) dlsym(hLibrary, "libmcenv_build_storepngimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_StorePNGImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_StartExecution = (PLibMCEnvBuild_StartExecutionPtr) GetProcAddress(hLibrary, "libmcenv_build_startexecution");
		#else // _WIN32
		pWrapperTable->m_Build_StartExecution = (PLibMCEnvBuild_StartExecutionPtr) dlsym(hLibrary, "libmcenv_build_startexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_StartExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_HasExecution = (PLibMCEnvBuild_HasExecutionPtr) GetProcAddress(hLibrary, "libmcenv_build_hasexecution");
		#else // _WIN32
		pWrapperTable->m_Build_HasExecution = (PLibMCEnvBuild_HasExecutionPtr) dlsym(hLibrary, "libmcenv_build_hasexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_HasExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_FindExecution = (PLibMCEnvBuild_FindExecutionPtr) GetProcAddress(hLibrary, "libmcenv_build_findexecution");
		#else // _WIN32
		pWrapperTable->m_Build_FindExecution = (PLibMCEnvBuild_FindExecutionPtr) dlsym(hLibrary, "libmcenv_build_findexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_FindExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_ListExecutions = (PLibMCEnvBuild_ListExecutionsPtr) GetProcAddress(hLibrary, "libmcenv_build_listexecutions");
		#else // _WIN32
		pWrapperTable->m_Build_ListExecutions = (PLibMCEnvBuild_ListExecutionsPtr) dlsym(hLibrary, "libmcenv_build_listexecutions");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_ListExecutions == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_ListExecutionsByStatus = (PLibMCEnvBuild_ListExecutionsByStatusPtr) GetProcAddress(hLibrary, "libmcenv_build_listexecutionsbystatus");
		#else // _WIN32
		pWrapperTable->m_Build_ListExecutionsByStatus = (PLibMCEnvBuild_ListExecutionsByStatusPtr) dlsym(hLibrary, "libmcenv_build_listexecutionsbystatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_ListExecutionsByStatus == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_StoreMetaDataString = (PLibMCEnvBuild_StoreMetaDataStringPtr) GetProcAddress(hLibrary, "libmcenv_build_storemetadatastring");
		#else // _WIN32
		pWrapperTable->m_Build_StoreMetaDataString = (PLibMCEnvBuild_StoreMetaDataStringPtr) dlsym(hLibrary, "libmcenv_build_storemetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_StoreMetaDataString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_HasMetaDataString = (PLibMCEnvBuild_HasMetaDataStringPtr) GetProcAddress(hLibrary, "libmcenv_build_hasmetadatastring");
		#else // _WIN32
		pWrapperTable->m_Build_HasMetaDataString = (PLibMCEnvBuild_HasMetaDataStringPtr) dlsym(hLibrary, "libmcenv_build_hasmetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_HasMetaDataString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetMetaDataString = (PLibMCEnvBuild_GetMetaDataStringPtr) GetProcAddress(hLibrary, "libmcenv_build_getmetadatastring");
		#else // _WIN32
		pWrapperTable->m_Build_GetMetaDataString = (PLibMCEnvBuild_GetMetaDataStringPtr) dlsym(hLibrary, "libmcenv_build_getmetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetMetaDataString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFileExecution_GetStatus = (PLibMCEnvWorkingFileExecution_GetStatusPtr) GetProcAddress(hLibrary, "libmcenv_workingfileexecution_getstatus");
		#else // _WIN32
		pWrapperTable->m_WorkingFileExecution_GetStatus = (PLibMCEnvWorkingFileExecution_GetStatusPtr) dlsym(hLibrary, "libmcenv_workingfileexecution_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFileExecution_GetStatus == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFileExecution_ReturnStdOut = (PLibMCEnvWorkingFileExecution_ReturnStdOutPtr) GetProcAddress(hLibrary, "libmcenv_workingfileexecution_returnstdout");
		#else // _WIN32
		pWrapperTable->m_WorkingFileExecution_ReturnStdOut = (PLibMCEnvWorkingFileExecution_ReturnStdOutPtr) dlsym(hLibrary, "libmcenv_workingfileexecution_returnstdout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFileExecution_ReturnStdOut == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_GetAbsoluteFileName = (PLibMCEnvWorkingFile_GetAbsoluteFileNamePtr) GetProcAddress(hLibrary, "libmcenv_workingfile_getabsolutefilename");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_GetAbsoluteFileName = (PLibMCEnvWorkingFile_GetAbsoluteFileNamePtr) dlsym(hLibrary, "libmcenv_workingfile_getabsolutefilename");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_GetAbsoluteFileName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_GetSize = (PLibMCEnvWorkingFile_GetSizePtr) GetProcAddress(hLibrary, "libmcenv_workingfile_getsize");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_GetSize = (PLibMCEnvWorkingFile_GetSizePtr) dlsym(hLibrary, "libmcenv_workingfile_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_GetSize == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_CalculateSHA2 = (PLibMCEnvWorkingFile_CalculateSHA2Ptr) GetProcAddress(hLibrary, "libmcenv_workingfile_calculatesha2");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_CalculateSHA2 = (PLibMCEnvWorkingFile_CalculateSHA2Ptr) dlsym(hLibrary, "libmcenv_workingfile_calculatesha2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_CalculateSHA2 == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_ExecuteFile = (PLibMCEnvWorkingFile_ExecuteFilePtr) GetProcAddress(hLibrary, "libmcenv_workingfile_executefile");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_ExecuteFile = (PLibMCEnvWorkingFile_ExecuteFilePtr) dlsym(hLibrary, "libmcenv_workingfile_executefile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_ExecuteFile == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_IsManaged = (PLibMCEnvWorkingFile_IsManagedPtr) GetProcAddress(hLibrary, "libmcenv_workingfile_ismanaged");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_IsManaged = (PLibMCEnvWorkingFile_IsManagedPtr) dlsym(hLibrary, "libmcenv_workingfile_ismanaged");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_IsManaged == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_MakeManaged = (PLibMCEnvWorkingFile_MakeManagedPtr) GetProcAddress(hLibrary, "libmcenv_workingfile_makemanaged");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_MakeManaged = (PLibMCEnvWorkingFile_MakeManagedPtr) dlsym(hLibrary, "libmcenv_workingfile_makemanaged");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_MakeManaged == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_FileExists = (PLibMCEnvWorkingFile_FileExistsPtr) GetProcAddress(hLibrary, "libmcenv_workingfile_fileexists");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_FileExists = (PLibMCEnvWorkingFile_FileExistsPtr) dlsym(hLibrary, "libmcenv_workingfile_fileexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_FileExists == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_DeleteFromDisk = (PLibMCEnvWorkingFile_DeleteFromDiskPtr) GetProcAddress(hLibrary, "libmcenv_workingfile_deletefromdisk");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_DeleteFromDisk = (PLibMCEnvWorkingFile_DeleteFromDiskPtr) dlsym(hLibrary, "libmcenv_workingfile_deletefromdisk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_DeleteFromDisk == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFileIterator_GetCurrentFile = (PLibMCEnvWorkingFileIterator_GetCurrentFilePtr) GetProcAddress(hLibrary, "libmcenv_workingfileiterator_getcurrentfile");
		#else // _WIN32
		pWrapperTable->m_WorkingFileIterator_GetCurrentFile = (PLibMCEnvWorkingFileIterator_GetCurrentFilePtr) dlsym(hLibrary, "libmcenv_workingfileiterator_getcurrentfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFileIterator_GetCurrentFile == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_IsActive = (PLibMCEnvWorkingDirectory_IsActivePtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_isactive");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_IsActive = (PLibMCEnvWorkingDirectory_IsActivePtr) dlsym(hLibrary, "libmcenv_workingdirectory_isactive");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_IsActive == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath = (PLibMCEnvWorkingDirectory_GetAbsoluteFilePathPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_getabsolutefilepath");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath = (PLibMCEnvWorkingDirectory_GetAbsoluteFilePathPtr) dlsym(hLibrary, "libmcenv_workingdirectory_getabsolutefilepath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomData = (PLibMCEnvWorkingDirectory_StoreCustomDataPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_storecustomdata");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomData = (PLibMCEnvWorkingDirectory_StoreCustomDataPtr) dlsym(hLibrary, "libmcenv_workingdirectory_storecustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_StoreCustomData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomString = (PLibMCEnvWorkingDirectory_StoreCustomStringPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_storecustomstring");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomString = (PLibMCEnvWorkingDirectory_StoreCustomStringPtr) dlsym(hLibrary, "libmcenv_workingdirectory_storecustomstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_StoreCustomString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_StoreDriverData = (PLibMCEnvWorkingDirectory_StoreDriverDataPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_storedriverdata");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_StoreDriverData = (PLibMCEnvWorkingDirectory_StoreDriverDataPtr) dlsym(hLibrary, "libmcenv_workingdirectory_storedriverdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_StoreDriverData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomDataInTempFile = (PLibMCEnvWorkingDirectory_StoreCustomDataInTempFilePtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_storecustomdataintempfile");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomDataInTempFile = (PLibMCEnvWorkingDirectory_StoreCustomDataInTempFilePtr) dlsym(hLibrary, "libmcenv_workingdirectory_storecustomdataintempfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_StoreCustomDataInTempFile == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomStringInTempFile = (PLibMCEnvWorkingDirectory_StoreCustomStringInTempFilePtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_storecustomstringintempfile");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomStringInTempFile = (PLibMCEnvWorkingDirectory_StoreCustomStringInTempFilePtr) dlsym(hLibrary, "libmcenv_workingdirectory_storecustomstringintempfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_StoreCustomStringInTempFile == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_StoreDriverDataInTempFile = (PLibMCEnvWorkingDirectory_StoreDriverDataInTempFilePtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_storedriverdataintempfile");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_StoreDriverDataInTempFile = (PLibMCEnvWorkingDirectory_StoreDriverDataInTempFilePtr) dlsym(hLibrary, "libmcenv_workingdirectory_storedriverdataintempfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_StoreDriverDataInTempFile == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_CleanUp = (PLibMCEnvWorkingDirectory_CleanUpPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_cleanup");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_CleanUp = (PLibMCEnvWorkingDirectory_CleanUpPtr) dlsym(hLibrary, "libmcenv_workingdirectory_cleanup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_CleanUp == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_AddManagedFile = (PLibMCEnvWorkingDirectory_AddManagedFilePtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_addmanagedfile");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_AddManagedFile = (PLibMCEnvWorkingDirectory_AddManagedFilePtr) dlsym(hLibrary, "libmcenv_workingdirectory_addmanagedfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_AddManagedFile == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles = (PLibMCEnvWorkingDirectory_HasUnmanagedFilesPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_hasunmanagedfiles");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles = (PLibMCEnvWorkingDirectory_HasUnmanagedFilesPtr) dlsym(hLibrary, "libmcenv_workingdirectory_hasunmanagedfiles");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles = (PLibMCEnvWorkingDirectory_RetrieveUnmanagedFilesPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_retrieveunmanagedfiles");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles = (PLibMCEnvWorkingDirectory_RetrieveUnmanagedFilesPtr) dlsym(hLibrary, "libmcenv_workingdirectory_retrieveunmanagedfiles");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles = (PLibMCEnvWorkingDirectory_RetrieveManagedFilesPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_retrievemanagedfiles");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles = (PLibMCEnvWorkingDirectory_RetrieveManagedFilesPtr) dlsym(hLibrary, "libmcenv_workingdirectory_retrievemanagedfiles");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveAllFiles = (PLibMCEnvWorkingDirectory_RetrieveAllFilesPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_retrieveallfiles");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveAllFiles = (PLibMCEnvWorkingDirectory_RetrieveAllFilesPtr) dlsym(hLibrary, "libmcenv_workingdirectory_retrieveallfiles");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_RetrieveAllFiles == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetNameSpace = (PLibMCEnvXMLDocumentAttribute_GetNameSpacePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_getnamespace");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetNameSpace = (PLibMCEnvXMLDocumentAttribute_GetNameSpacePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_getnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_GetNameSpace == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetName = (PLibMCEnvXMLDocumentAttribute_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_getname");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetName = (PLibMCEnvXMLDocumentAttribute_GetNamePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetValue = (PLibMCEnvXMLDocumentAttribute_GetValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_getvalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetValue = (PLibMCEnvXMLDocumentAttribute_GetValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_getvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_GetValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_IsValidUUID = (PLibMCEnvXMLDocumentAttribute_IsValidUUIDPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_isvaliduuid");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_IsValidUUID = (PLibMCEnvXMLDocumentAttribute_IsValidUUIDPtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_isvaliduuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_IsValidUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetUUIDValue = (PLibMCEnvXMLDocumentAttribute_GetUUIDValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_getuuidvalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetUUIDValue = (PLibMCEnvXMLDocumentAttribute_GetUUIDValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_getuuidvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_GetUUIDValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_IsValidInteger = (PLibMCEnvXMLDocumentAttribute_IsValidIntegerPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_isvalidinteger");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_IsValidInteger = (PLibMCEnvXMLDocumentAttribute_IsValidIntegerPtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_isvalidinteger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_IsValidInteger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetIntegerValue = (PLibMCEnvXMLDocumentAttribute_GetIntegerValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_getintegervalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetIntegerValue = (PLibMCEnvXMLDocumentAttribute_GetIntegerValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_getintegervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_GetIntegerValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_IsValidDouble = (PLibMCEnvXMLDocumentAttribute_IsValidDoublePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_isvaliddouble");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_IsValidDouble = (PLibMCEnvXMLDocumentAttribute_IsValidDoublePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_isvaliddouble");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_IsValidDouble == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetDoubleValue = (PLibMCEnvXMLDocumentAttribute_GetDoubleValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_getdoublevalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetDoubleValue = (PLibMCEnvXMLDocumentAttribute_GetDoubleValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_getdoublevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_GetDoubleValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_IsValidBool = (PLibMCEnvXMLDocumentAttribute_IsValidBoolPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_isvalidbool");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_IsValidBool = (PLibMCEnvXMLDocumentAttribute_IsValidBoolPtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_isvalidbool");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_IsValidBool == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetBoolValue = (PLibMCEnvXMLDocumentAttribute_GetBoolValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_getboolvalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_GetBoolValue = (PLibMCEnvXMLDocumentAttribute_GetBoolValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_getboolvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_GetBoolValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetValue = (PLibMCEnvXMLDocumentAttribute_SetValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_setvalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetValue = (PLibMCEnvXMLDocumentAttribute_SetValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_setvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_SetValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetUUIDValue = (PLibMCEnvXMLDocumentAttribute_SetUUIDValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_setuuidvalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetUUIDValue = (PLibMCEnvXMLDocumentAttribute_SetUUIDValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_setuuidvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_SetUUIDValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetIntegerValue = (PLibMCEnvXMLDocumentAttribute_SetIntegerValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_setintegervalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetIntegerValue = (PLibMCEnvXMLDocumentAttribute_SetIntegerValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_setintegervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_SetIntegerValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetDoubleValue = (PLibMCEnvXMLDocumentAttribute_SetDoubleValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_setdoublevalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetDoubleValue = (PLibMCEnvXMLDocumentAttribute_SetDoubleValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_setdoublevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_SetDoubleValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetBoolValue = (PLibMCEnvXMLDocumentAttribute_SetBoolValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_setboolvalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_SetBoolValue = (PLibMCEnvXMLDocumentAttribute_SetBoolValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_setboolvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_SetBoolValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentAttribute_Remove = (PLibMCEnvXMLDocumentAttribute_RemovePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentattribute_remove");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentAttribute_Remove = (PLibMCEnvXMLDocumentAttribute_RemovePtr) dlsym(hLibrary, "libmcenv_xmldocumentattribute_remove");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentAttribute_Remove == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetName = (PLibMCEnvXMLDocumentNode_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getname");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetName = (PLibMCEnvXMLDocumentNode_GetNamePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetNameSpace = (PLibMCEnvXMLDocumentNode_GetNameSpacePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getnamespace");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetNameSpace = (PLibMCEnvXMLDocumentNode_GetNameSpacePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetNameSpace == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetTextContent = (PLibMCEnvXMLDocumentNode_GetTextContentPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_gettextcontent");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetTextContent = (PLibMCEnvXMLDocumentNode_GetTextContentPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_gettextcontent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetTextContent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_SetTextContent = (PLibMCEnvXMLDocumentNode_SetTextContentPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_settextcontent");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_SetTextContent = (PLibMCEnvXMLDocumentNode_SetTextContentPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_settextcontent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_SetTextContent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeCount = (PLibMCEnvXMLDocumentNode_GetAttributeCountPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributecount");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeCount = (PLibMCEnvXMLDocumentNode_GetAttributeCountPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttribute = (PLibMCEnvXMLDocumentNode_GetAttributePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattribute");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttribute = (PLibMCEnvXMLDocumentNode_GetAttributePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_HasAttribute = (PLibMCEnvXMLDocumentNode_HasAttributePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_hasattribute");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_HasAttribute = (PLibMCEnvXMLDocumentNode_HasAttributePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_hasattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_HasAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_FindAttribute = (PLibMCEnvXMLDocumentNode_FindAttributePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_findattribute");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_FindAttribute = (PLibMCEnvXMLDocumentNode_FindAttributePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_findattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_FindAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeValue = (PLibMCEnvXMLDocumentNode_GetAttributeValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributevalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeValue = (PLibMCEnvXMLDocumentNode_GetAttributeValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValue = (PLibMCEnvXMLDocumentNode_GetAttributeIntegerValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributeintegervalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValue = (PLibMCEnvXMLDocumentNode_GetAttributeIntegerValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributeintegervalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValue = (PLibMCEnvXMLDocumentNode_GetAttributeDoubleValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributedoublevalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValue = (PLibMCEnvXMLDocumentNode_GetAttributeDoubleValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributedoublevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValue = (PLibMCEnvXMLDocumentNode_GetAttributeBoolValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributeboolvalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValue = (PLibMCEnvXMLDocumentNode_GetAttributeBoolValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributeboolvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValue = (PLibMCEnvXMLDocumentNode_GetAttributeUUIDValuePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributeuuidvalue");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValue = (PLibMCEnvXMLDocumentNode_GetAttributeUUIDValuePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributeuuidvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeValueDefPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributevaluedef");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeValueDefPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributevaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeIntegerValueDefPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributeintegervaluedef");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeIntegerValueDefPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributeintegervaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeDoubleValueDefPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributedoublevaluedef");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeDoubleValueDefPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributedoublevaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeBoolValueDefPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributeboolvaluedef");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeBoolValueDefPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributeboolvaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeUUIDValueDefPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getattributeuuidvaluedef");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValueDef = (PLibMCEnvXMLDocumentNode_GetAttributeUUIDValueDefPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getattributeuuidvaluedef");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValueDef == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_RemoveAttribute = (PLibMCEnvXMLDocumentNode_RemoveAttributePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_removeattribute");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_RemoveAttribute = (PLibMCEnvXMLDocumentNode_RemoveAttributePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_removeattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_RemoveAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_RemoveAttributeByIndex = (PLibMCEnvXMLDocumentNode_RemoveAttributeByIndexPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_removeattributebyindex");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_RemoveAttributeByIndex = (PLibMCEnvXMLDocumentNode_RemoveAttributeByIndexPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_removeattributebyindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_RemoveAttributeByIndex == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_AddAttribute = (PLibMCEnvXMLDocumentNode_AddAttributePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_addattribute");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_AddAttribute = (PLibMCEnvXMLDocumentNode_AddAttributePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_addattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_AddAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_AddIntegerAttribute = (PLibMCEnvXMLDocumentNode_AddIntegerAttributePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_addintegerattribute");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_AddIntegerAttribute = (PLibMCEnvXMLDocumentNode_AddIntegerAttributePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_addintegerattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_AddIntegerAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_AddDoubleAttribute = (PLibMCEnvXMLDocumentNode_AddDoubleAttributePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_adddoubleattribute");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_AddDoubleAttribute = (PLibMCEnvXMLDocumentNode_AddDoubleAttributePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_adddoubleattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_AddDoubleAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_AddBoolAttribute = (PLibMCEnvXMLDocumentNode_AddBoolAttributePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_addboolattribute");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_AddBoolAttribute = (PLibMCEnvXMLDocumentNode_AddBoolAttributePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_addboolattribute");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_AddBoolAttribute == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetChildren = (PLibMCEnvXMLDocumentNode_GetChildrenPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getchildren");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetChildren = (PLibMCEnvXMLDocumentNode_GetChildrenPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getchildren");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetChildren == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_CountChildrenByName = (PLibMCEnvXMLDocumentNode_CountChildrenByNamePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_countchildrenbyname");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_CountChildrenByName = (PLibMCEnvXMLDocumentNode_CountChildrenByNamePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_countchildrenbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_CountChildrenByName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_GetChildrenByName = (PLibMCEnvXMLDocumentNode_GetChildrenByNamePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_getchildrenbyname");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_GetChildrenByName = (PLibMCEnvXMLDocumentNode_GetChildrenByNamePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_getchildrenbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_GetChildrenByName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_HasChild = (PLibMCEnvXMLDocumentNode_HasChildPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_haschild");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_HasChild = (PLibMCEnvXMLDocumentNode_HasChildPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_haschild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_HasChild == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_HasUniqueChild = (PLibMCEnvXMLDocumentNode_HasUniqueChildPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_hasuniquechild");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_HasUniqueChild = (PLibMCEnvXMLDocumentNode_HasUniqueChildPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_hasuniquechild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_HasUniqueChild == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_FindChild = (PLibMCEnvXMLDocumentNode_FindChildPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_findchild");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_FindChild = (PLibMCEnvXMLDocumentNode_FindChildPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_findchild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_FindChild == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_AddChild = (PLibMCEnvXMLDocumentNode_AddChildPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_addchild");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_AddChild = (PLibMCEnvXMLDocumentNode_AddChildPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_addchild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_AddChild == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_AddChildText = (PLibMCEnvXMLDocumentNode_AddChildTextPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_addchildtext");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_AddChildText = (PLibMCEnvXMLDocumentNode_AddChildTextPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_addchildtext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_AddChildText == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_RemoveChild = (PLibMCEnvXMLDocumentNode_RemoveChildPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_removechild");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_RemoveChild = (PLibMCEnvXMLDocumentNode_RemoveChildPtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_removechild");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_RemoveChild == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_RemoveChildrenWithName = (PLibMCEnvXMLDocumentNode_RemoveChildrenWithNamePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_removechildrenwithname");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_RemoveChildrenWithName = (PLibMCEnvXMLDocumentNode_RemoveChildrenWithNamePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_removechildrenwithname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_RemoveChildrenWithName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNode_Remove = (PLibMCEnvXMLDocumentNode_RemovePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnode_remove");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNode_Remove = (PLibMCEnvXMLDocumentNode_RemovePtr) dlsym(hLibrary, "libmcenv_xmldocumentnode_remove");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNode_Remove == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNodes_GetNodeCount = (PLibMCEnvXMLDocumentNodes_GetNodeCountPtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnodes_getnodecount");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNodes_GetNodeCount = (PLibMCEnvXMLDocumentNodes_GetNodeCountPtr) dlsym(hLibrary, "libmcenv_xmldocumentnodes_getnodecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNodes_GetNodeCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNodes_GetNode = (PLibMCEnvXMLDocumentNodes_GetNodePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnodes_getnode");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNodes_GetNode = (PLibMCEnvXMLDocumentNodes_GetNodePtr) dlsym(hLibrary, "libmcenv_xmldocumentnodes_getnode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNodes_GetNode == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNodes_CountNodesByName = (PLibMCEnvXMLDocumentNodes_CountNodesByNamePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnodes_countnodesbyname");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNodes_CountNodesByName = (PLibMCEnvXMLDocumentNodes_CountNodesByNamePtr) dlsym(hLibrary, "libmcenv_xmldocumentnodes_countnodesbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNodes_CountNodesByName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNodes_GetNodesByName = (PLibMCEnvXMLDocumentNodes_GetNodesByNamePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnodes_getnodesbyname");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNodes_GetNodesByName = (PLibMCEnvXMLDocumentNodes_GetNodesByNamePtr) dlsym(hLibrary, "libmcenv_xmldocumentnodes_getnodesbyname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNodes_GetNodesByName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNodes_HasNode = (PLibMCEnvXMLDocumentNodes_HasNodePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnodes_hasnode");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNodes_HasNode = (PLibMCEnvXMLDocumentNodes_HasNodePtr) dlsym(hLibrary, "libmcenv_xmldocumentnodes_hasnode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNodes_HasNode == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNodes_HasUniqueNode = (PLibMCEnvXMLDocumentNodes_HasUniqueNodePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnodes_hasuniquenode");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNodes_HasUniqueNode = (PLibMCEnvXMLDocumentNodes_HasUniqueNodePtr) dlsym(hLibrary, "libmcenv_xmldocumentnodes_hasuniquenode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNodes_HasUniqueNode == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocumentNodes_FindNode = (PLibMCEnvXMLDocumentNodes_FindNodePtr) GetProcAddress(hLibrary, "libmcenv_xmldocumentnodes_findnode");
		#else // _WIN32
		pWrapperTable->m_XMLDocumentNodes_FindNode = (PLibMCEnvXMLDocumentNodes_FindNodePtr) dlsym(hLibrary, "libmcenv_xmldocumentnodes_findnode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocumentNodes_FindNode == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocument_GetDefaultNamespace = (PLibMCEnvXMLDocument_GetDefaultNamespacePtr) GetProcAddress(hLibrary, "libmcenv_xmldocument_getdefaultnamespace");
		#else // _WIN32
		pWrapperTable->m_XMLDocument_GetDefaultNamespace = (PLibMCEnvXMLDocument_GetDefaultNamespacePtr) dlsym(hLibrary, "libmcenv_xmldocument_getdefaultnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocument_GetDefaultNamespace == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocument_GetNamespaceCount = (PLibMCEnvXMLDocument_GetNamespaceCountPtr) GetProcAddress(hLibrary, "libmcenv_xmldocument_getnamespacecount");
		#else // _WIN32
		pWrapperTable->m_XMLDocument_GetNamespaceCount = (PLibMCEnvXMLDocument_GetNamespaceCountPtr) dlsym(hLibrary, "libmcenv_xmldocument_getnamespacecount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocument_GetNamespaceCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocument_GetNamespace = (PLibMCEnvXMLDocument_GetNamespacePtr) GetProcAddress(hLibrary, "libmcenv_xmldocument_getnamespace");
		#else // _WIN32
		pWrapperTable->m_XMLDocument_GetNamespace = (PLibMCEnvXMLDocument_GetNamespacePtr) dlsym(hLibrary, "libmcenv_xmldocument_getnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocument_GetNamespace == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocument_HasNamespace = (PLibMCEnvXMLDocument_HasNamespacePtr) GetProcAddress(hLibrary, "libmcenv_xmldocument_hasnamespace");
		#else // _WIN32
		pWrapperTable->m_XMLDocument_HasNamespace = (PLibMCEnvXMLDocument_HasNamespacePtr) dlsym(hLibrary, "libmcenv_xmldocument_hasnamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocument_HasNamespace == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocument_GetNamespacePrefix = (PLibMCEnvXMLDocument_GetNamespacePrefixPtr) GetProcAddress(hLibrary, "libmcenv_xmldocument_getnamespaceprefix");
		#else // _WIN32
		pWrapperTable->m_XMLDocument_GetNamespacePrefix = (PLibMCEnvXMLDocument_GetNamespacePrefixPtr) dlsym(hLibrary, "libmcenv_xmldocument_getnamespaceprefix");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocument_GetNamespacePrefix == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocument_RegisterNamespace = (PLibMCEnvXMLDocument_RegisterNamespacePtr) GetProcAddress(hLibrary, "libmcenv_xmldocument_registernamespace");
		#else // _WIN32
		pWrapperTable->m_XMLDocument_RegisterNamespace = (PLibMCEnvXMLDocument_RegisterNamespacePtr) dlsym(hLibrary, "libmcenv_xmldocument_registernamespace");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocument_RegisterNamespace == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocument_ChangeNamespacePrefix = (PLibMCEnvXMLDocument_ChangeNamespacePrefixPtr) GetProcAddress(hLibrary, "libmcenv_xmldocument_changenamespaceprefix");
		#else // _WIN32
		pWrapperTable->m_XMLDocument_ChangeNamespacePrefix = (PLibMCEnvXMLDocument_ChangeNamespacePrefixPtr) dlsym(hLibrary, "libmcenv_xmldocument_changenamespaceprefix");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocument_ChangeNamespacePrefix == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocument_GetRootNode = (PLibMCEnvXMLDocument_GetRootNodePtr) GetProcAddress(hLibrary, "libmcenv_xmldocument_getrootnode");
		#else // _WIN32
		pWrapperTable->m_XMLDocument_GetRootNode = (PLibMCEnvXMLDocument_GetRootNodePtr) dlsym(hLibrary, "libmcenv_xmldocument_getrootnode");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocument_GetRootNode == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_XMLDocument_SaveToString = (PLibMCEnvXMLDocument_SaveToStringPtr) GetProcAddress(hLibrary, "libmcenv_xmldocument_savetostring");
		#else // _WIN32
		pWrapperTable->m_XMLDocument_SaveToString = (PLibMCEnvXMLDocument_SaveToStringPtr) dlsym(hLibrary, "libmcenv_xmldocument_savetostring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_XMLDocument_SaveToString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPPacket_IsEmpty = (PLibMCEnvTCPIPPacket_IsEmptyPtr) GetProcAddress(hLibrary, "libmcenv_tcpippacket_isempty");
		#else // _WIN32
		pWrapperTable->m_TCPIPPacket_IsEmpty = (PLibMCEnvTCPIPPacket_IsEmptyPtr) dlsym(hLibrary, "libmcenv_tcpippacket_isempty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPPacket_IsEmpty == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPPacket_GetSize = (PLibMCEnvTCPIPPacket_GetSizePtr) GetProcAddress(hLibrary, "libmcenv_tcpippacket_getsize");
		#else // _WIN32
		pWrapperTable->m_TCPIPPacket_GetSize = (PLibMCEnvTCPIPPacket_GetSizePtr) dlsym(hLibrary, "libmcenv_tcpippacket_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPPacket_GetSize == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPPacket_GetData = (PLibMCEnvTCPIPPacket_GetDataPtr) GetProcAddress(hLibrary, "libmcenv_tcpippacket_getdata");
		#else // _WIN32
		pWrapperTable->m_TCPIPPacket_GetData = (PLibMCEnvTCPIPPacket_GetDataPtr) dlsym(hLibrary, "libmcenv_tcpippacket_getdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPPacket_GetData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_GetIPAddress = (PLibMCEnvTCPIPConnection_GetIPAddressPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_getipaddress");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_GetIPAddress = (PLibMCEnvTCPIPConnection_GetIPAddressPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_getipaddress");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_GetIPAddress == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_GetPort = (PLibMCEnvTCPIPConnection_GetPortPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_getport");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_GetPort = (PLibMCEnvTCPIPConnection_GetPortPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_getport");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_GetPort == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_GetTimeout = (PLibMCEnvTCPIPConnection_GetTimeoutPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_gettimeout");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_GetTimeout = (PLibMCEnvTCPIPConnection_GetTimeoutPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_gettimeout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_GetTimeout == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_IsConnected = (PLibMCEnvTCPIPConnection_IsConnectedPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_isconnected");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_IsConnected = (PLibMCEnvTCPIPConnection_IsConnectedPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_isconnected");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_IsConnected == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_Disconnect = (PLibMCEnvTCPIPConnection_DisconnectPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_disconnect");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_Disconnect = (PLibMCEnvTCPIPConnection_DisconnectPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_disconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_Disconnect == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_Reconnect = (PLibMCEnvTCPIPConnection_ReconnectPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_reconnect");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_Reconnect = (PLibMCEnvTCPIPConnection_ReconnectPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_reconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_Reconnect == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_SendBuffer = (PLibMCEnvTCPIPConnection_SendBufferPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_sendbuffer");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_SendBuffer = (PLibMCEnvTCPIPConnection_SendBufferPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_sendbuffer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_SendBuffer == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_WaitForData = (PLibMCEnvTCPIPConnection_WaitForDataPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_waitfordata");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_WaitForData = (PLibMCEnvTCPIPConnection_WaitForDataPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_waitfordata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_WaitForData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_ReceiveFixedPacket = (PLibMCEnvTCPIPConnection_ReceiveFixedPacketPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_receivefixedpacket");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_ReceiveFixedPacket = (PLibMCEnvTCPIPConnection_ReceiveFixedPacketPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_receivefixedpacket");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_ReceiveFixedPacket == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TCPIPConnection_ReceiveData = (PLibMCEnvTCPIPConnection_ReceiveDataPtr) GetProcAddress(hLibrary, "libmcenv_tcpipconnection_receivedata");
		#else // _WIN32
		pWrapperTable->m_TCPIPConnection_ReceiveData = (PLibMCEnvTCPIPConnection_ReceiveDataPtr) dlsym(hLibrary, "libmcenv_tcpipconnection_receivedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TCPIPConnection_ReceiveData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetCount = (PLibMCEnvModbusTCPDigitalIOStatus_GetCountPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpdigitaliostatus_getcount");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetCount = (PLibMCEnvModbusTCPDigitalIOStatus_GetCountPtr) dlsym(hLibrary, "libmcenv_modbustcpdigitaliostatus_getcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPDigitalIOStatus_GetCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetBaseAddress = (PLibMCEnvModbusTCPDigitalIOStatus_GetBaseAddressPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpdigitaliostatus_getbaseaddress");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetBaseAddress = (PLibMCEnvModbusTCPDigitalIOStatus_GetBaseAddressPtr) dlsym(hLibrary, "libmcenv_modbustcpdigitaliostatus_getbaseaddress");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPDigitalIOStatus_GetBaseAddress == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValue = (PLibMCEnvModbusTCPDigitalIOStatus_GetValuePtr) GetProcAddress(hLibrary, "libmcenv_modbustcpdigitaliostatus_getvalue");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValue = (PLibMCEnvModbusTCPDigitalIOStatus_GetValuePtr) dlsym(hLibrary, "libmcenv_modbustcpdigitaliostatus_getvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValues = (PLibMCEnvModbusTCPDigitalIOStatus_GetValuesPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpdigitaliostatus_getvalues");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValues = (PLibMCEnvModbusTCPDigitalIOStatus_GetValuesPtr) dlsym(hLibrary, "libmcenv_modbustcpdigitaliostatus_getvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPRegisterStatus_GetCount = (PLibMCEnvModbusTCPRegisterStatus_GetCountPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpregisterstatus_getcount");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPRegisterStatus_GetCount = (PLibMCEnvModbusTCPRegisterStatus_GetCountPtr) dlsym(hLibrary, "libmcenv_modbustcpregisterstatus_getcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPRegisterStatus_GetCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPRegisterStatus_GetBaseAddress = (PLibMCEnvModbusTCPRegisterStatus_GetBaseAddressPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpregisterstatus_getbaseaddress");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPRegisterStatus_GetBaseAddress = (PLibMCEnvModbusTCPRegisterStatus_GetBaseAddressPtr) dlsym(hLibrary, "libmcenv_modbustcpregisterstatus_getbaseaddress");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPRegisterStatus_GetBaseAddress == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPRegisterStatus_GetValue = (PLibMCEnvModbusTCPRegisterStatus_GetValuePtr) GetProcAddress(hLibrary, "libmcenv_modbustcpregisterstatus_getvalue");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPRegisterStatus_GetValue = (PLibMCEnvModbusTCPRegisterStatus_GetValuePtr) dlsym(hLibrary, "libmcenv_modbustcpregisterstatus_getvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPRegisterStatus_GetValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPRegisterStatus_GetValues = (PLibMCEnvModbusTCPRegisterStatus_GetValuesPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpregisterstatus_getvalues");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPRegisterStatus_GetValues = (PLibMCEnvModbusTCPRegisterStatus_GetValuesPtr) dlsym(hLibrary, "libmcenv_modbustcpregisterstatus_getvalues");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPRegisterStatus_GetValues == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_GetIPAddress = (PLibMCEnvModbusTCPConnection_GetIPAddressPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_getipaddress");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_GetIPAddress = (PLibMCEnvModbusTCPConnection_GetIPAddressPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_getipaddress");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_GetIPAddress == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_GetPort = (PLibMCEnvModbusTCPConnection_GetPortPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_getport");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_GetPort = (PLibMCEnvModbusTCPConnection_GetPortPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_getport");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_GetPort == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_GetTimeout = (PLibMCEnvModbusTCPConnection_GetTimeoutPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_gettimeout");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_GetTimeout = (PLibMCEnvModbusTCPConnection_GetTimeoutPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_gettimeout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_GetTimeout == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_IsConnected = (PLibMCEnvModbusTCPConnection_IsConnectedPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_isconnected");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_IsConnected = (PLibMCEnvModbusTCPConnection_IsConnectedPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_isconnected");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_IsConnected == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_Disconnect = (PLibMCEnvModbusTCPConnection_DisconnectPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_disconnect");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_Disconnect = (PLibMCEnvModbusTCPConnection_DisconnectPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_disconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_Disconnect == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_Reconnect = (PLibMCEnvModbusTCPConnection_ReconnectPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_reconnect");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_Reconnect = (PLibMCEnvModbusTCPConnection_ReconnectPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_reconnect");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_Reconnect == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_DiagnosisCall = (PLibMCEnvModbusTCPConnection_DiagnosisCallPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_diagnosiscall");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_DiagnosisCall = (PLibMCEnvModbusTCPConnection_DiagnosisCallPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_diagnosiscall");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_DiagnosisCall == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_ReadCoilStatus = (PLibMCEnvModbusTCPConnection_ReadCoilStatusPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_readcoilstatus");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_ReadCoilStatus = (PLibMCEnvModbusTCPConnection_ReadCoilStatusPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_readcoilstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_ReadCoilStatus == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_ReadInputStatus = (PLibMCEnvModbusTCPConnection_ReadInputStatusPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_readinputstatus");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_ReadInputStatus = (PLibMCEnvModbusTCPConnection_ReadInputStatusPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_readinputstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_ReadInputStatus == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_ReadHoldingRegisters = (PLibMCEnvModbusTCPConnection_ReadHoldingRegistersPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_readholdingregisters");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_ReadHoldingRegisters = (PLibMCEnvModbusTCPConnection_ReadHoldingRegistersPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_readholdingregisters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_ReadHoldingRegisters == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_ReadInputRegisters = (PLibMCEnvModbusTCPConnection_ReadInputRegistersPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_readinputregisters");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_ReadInputRegisters = (PLibMCEnvModbusTCPConnection_ReadInputRegistersPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_readinputregisters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_ReadInputRegisters == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_ForceMultipleCoils = (PLibMCEnvModbusTCPConnection_ForceMultipleCoilsPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_forcemultiplecoils");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_ForceMultipleCoils = (PLibMCEnvModbusTCPConnection_ForceMultipleCoilsPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_forcemultiplecoils");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_ForceMultipleCoils == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ModbusTCPConnection_PresetMultipleRegisters = (PLibMCEnvModbusTCPConnection_PresetMultipleRegistersPtr) GetProcAddress(hLibrary, "libmcenv_modbustcpconnection_presetmultipleregisters");
		#else // _WIN32
		pWrapperTable->m_ModbusTCPConnection_PresetMultipleRegisters = (PLibMCEnvModbusTCPConnection_PresetMultipleRegistersPtr) dlsym(hLibrary, "libmcenv_modbustcpconnection_presetmultipleregisters");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ModbusTCPConnection_PresetMultipleRegisters == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetStringParameter = (PLibMCEnvDriverStatusUpdateSession_SetStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverstatusupdatesession_setstringparameter");
		#else // _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetStringParameter = (PLibMCEnvDriverStatusUpdateSession_SetStringParameterPtr) dlsym(hLibrary, "libmcenv_driverstatusupdatesession_setstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverStatusUpdateSession_SetStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetUUIDParameter = (PLibMCEnvDriverStatusUpdateSession_SetUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverstatusupdatesession_setuuidparameter");
		#else // _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetUUIDParameter = (PLibMCEnvDriverStatusUpdateSession_SetUUIDParameterPtr) dlsym(hLibrary, "libmcenv_driverstatusupdatesession_setuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverStatusUpdateSession_SetUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetDoubleParameter = (PLibMCEnvDriverStatusUpdateSession_SetDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverstatusupdatesession_setdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetDoubleParameter = (PLibMCEnvDriverStatusUpdateSession_SetDoubleParameterPtr) dlsym(hLibrary, "libmcenv_driverstatusupdatesession_setdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverStatusUpdateSession_SetDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetIntegerParameter = (PLibMCEnvDriverStatusUpdateSession_SetIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverstatusupdatesession_setintegerparameter");
		#else // _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetIntegerParameter = (PLibMCEnvDriverStatusUpdateSession_SetIntegerParameterPtr) dlsym(hLibrary, "libmcenv_driverstatusupdatesession_setintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverStatusUpdateSession_SetIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetBoolParameter = (PLibMCEnvDriverStatusUpdateSession_SetBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverstatusupdatesession_setboolparameter");
		#else // _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_SetBoolParameter = (PLibMCEnvDriverStatusUpdateSession_SetBoolParameterPtr) dlsym(hLibrary, "libmcenv_driverstatusupdatesession_setboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverStatusUpdateSession_SetBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_LogMessage = (PLibMCEnvDriverStatusUpdateSession_LogMessagePtr) GetProcAddress(hLibrary, "libmcenv_driverstatusupdatesession_logmessage");
		#else // _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_LogMessage = (PLibMCEnvDriverStatusUpdateSession_LogMessagePtr) dlsym(hLibrary, "libmcenv_driverstatusupdatesession_logmessage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverStatusUpdateSession_LogMessage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_LogWarning = (PLibMCEnvDriverStatusUpdateSession_LogWarningPtr) GetProcAddress(hLibrary, "libmcenv_driverstatusupdatesession_logwarning");
		#else // _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_LogWarning = (PLibMCEnvDriverStatusUpdateSession_LogWarningPtr) dlsym(hLibrary, "libmcenv_driverstatusupdatesession_logwarning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverStatusUpdateSession_LogWarning == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_LogInfo = (PLibMCEnvDriverStatusUpdateSession_LogInfoPtr) GetProcAddress(hLibrary, "libmcenv_driverstatusupdatesession_loginfo");
		#else // _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_LogInfo = (PLibMCEnvDriverStatusUpdateSession_LogInfoPtr) dlsym(hLibrary, "libmcenv_driverstatusupdatesession_loginfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverStatusUpdateSession_LogInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_Sleep = (PLibMCEnvDriverStatusUpdateSession_SleepPtr) GetProcAddress(hLibrary, "libmcenv_driverstatusupdatesession_sleep");
		#else // _WIN32
		pWrapperTable->m_DriverStatusUpdateSession_Sleep = (PLibMCEnvDriverStatusUpdateSession_SleepPtr) dlsym(hLibrary, "libmcenv_driverstatusupdatesession_sleep");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverStatusUpdateSession_Sleep == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateStatusUpdateSession = (PLibMCEnvDriverEnvironment_CreateStatusUpdateSessionPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createstatusupdatesession");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateStatusUpdateSession = (PLibMCEnvDriverEnvironment_CreateStatusUpdateSessionPtr) dlsym(hLibrary, "libmcenv_driverenvironment_createstatusupdatesession");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateStatusUpdateSession == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory = (PLibMCEnvDriverEnvironment_CreateWorkingDirectoryPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createworkingdirectory");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory = (PLibMCEnvDriverEnvironment_CreateWorkingDirectoryPtr) dlsym(hLibrary, "libmcenv_driverenvironment_createworkingdirectory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateTCPIPConnection = (PLibMCEnvDriverEnvironment_CreateTCPIPConnectionPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createtcpipconnection");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateTCPIPConnection = (PLibMCEnvDriverEnvironment_CreateTCPIPConnectionPtr) dlsym(hLibrary, "libmcenv_driverenvironment_createtcpipconnection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateTCPIPConnection == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateModbusTCPConnection = (PLibMCEnvDriverEnvironment_CreateModbusTCPConnectionPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createmodbustcpconnection");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateModbusTCPConnection = (PLibMCEnvDriverEnvironment_CreateModbusTCPConnectionPtr) dlsym(hLibrary, "libmcenv_driverenvironment_createmodbustcpconnection");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateModbusTCPConnection == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateXMLDocument = (PLibMCEnvDriverEnvironment_CreateXMLDocumentPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createxmldocument");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateXMLDocument = (PLibMCEnvDriverEnvironment_CreateXMLDocumentPtr) dlsym(hLibrary, "libmcenv_driverenvironment_createxmldocument");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateXMLDocument == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_ParseXMLString = (PLibMCEnvDriverEnvironment_ParseXMLStringPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_parsexmlstring");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_ParseXMLString = (PLibMCEnvDriverEnvironment_ParseXMLStringPtr) dlsym(hLibrary, "libmcenv_driverenvironment_parsexmlstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_ParseXMLString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_ParseXMLData = (PLibMCEnvDriverEnvironment_ParseXMLDataPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_parsexmldata");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_ParseXMLData = (PLibMCEnvDriverEnvironment_ParseXMLDataPtr) dlsym(hLibrary, "libmcenv_driverenvironment_parsexmldata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_ParseXMLData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateDataTable = (PLibMCEnvDriverEnvironment_CreateDataTablePtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createdatatable");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateDataTable = (PLibMCEnvDriverEnvironment_CreateDataTablePtr) dlsym(hLibrary, "libmcenv_driverenvironment_createdatatable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateDataTable == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_DriverHasResourceData = (PLibMCEnvDriverEnvironment_DriverHasResourceDataPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_driverhasresourcedata");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_DriverHasResourceData = (PLibMCEnvDriverEnvironment_DriverHasResourceDataPtr) dlsym(hLibrary, "libmcenv_driverenvironment_driverhasresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_DriverHasResourceData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_MachineHasResourceData = (PLibMCEnvDriverEnvironment_MachineHasResourceDataPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_machinehasresourcedata");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_MachineHasResourceData = (PLibMCEnvDriverEnvironment_MachineHasResourceDataPtr) dlsym(hLibrary, "libmcenv_driverenvironment_machinehasresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_MachineHasResourceData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RetrieveDriverData = (PLibMCEnvDriverEnvironment_RetrieveDriverDataPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_retrievedriverdata");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RetrieveDriverData = (PLibMCEnvDriverEnvironment_RetrieveDriverDataPtr) dlsym(hLibrary, "libmcenv_driverenvironment_retrievedriverdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RetrieveDriverData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RetrieveDriverResourceData = (PLibMCEnvDriverEnvironment_RetrieveDriverResourceDataPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_retrievedriverresourcedata");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RetrieveDriverResourceData = (PLibMCEnvDriverEnvironment_RetrieveDriverResourceDataPtr) dlsym(hLibrary, "libmcenv_driverenvironment_retrievedriverresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RetrieveDriverResourceData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RetrieveMachineResourceData = (PLibMCEnvDriverEnvironment_RetrieveMachineResourceDataPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_retrievemachineresourcedata");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RetrieveMachineResourceData = (PLibMCEnvDriverEnvironment_RetrieveMachineResourceDataPtr) dlsym(hLibrary, "libmcenv_driverenvironment_retrievemachineresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RetrieveMachineResourceData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor = (PLibMCEnvDriverEnvironment_CreateToolpathAccessorPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createtoolpathaccessor");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor = (PLibMCEnvDriverEnvironment_CreateToolpathAccessorPtr) dlsym(hLibrary, "libmcenv_driverenvironment_createtoolpathaccessor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_ParameterNameIsValid = (PLibMCEnvDriverEnvironment_ParameterNameIsValidPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_parameternameisvalid");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_ParameterNameIsValid = (PLibMCEnvDriverEnvironment_ParameterNameIsValidPtr) dlsym(hLibrary, "libmcenv_driverenvironment_parameternameisvalid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_ParameterNameIsValid == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterStringParameter = (PLibMCEnvDriverEnvironment_RegisterStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registerstringparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterStringParameter = (PLibMCEnvDriverEnvironment_RegisterStringParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registerstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter = (PLibMCEnvDriverEnvironment_RegisterUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registeruuidparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter = (PLibMCEnvDriverEnvironment_RegisterUUIDParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registeruuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter = (PLibMCEnvDriverEnvironment_RegisterDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registerdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter = (PLibMCEnvDriverEnvironment_RegisterDoubleParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registerdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterDoubleParameterWithUnits = (PLibMCEnvDriverEnvironment_RegisterDoubleParameterWithUnitsPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registerdoubleparameterwithunits");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterDoubleParameterWithUnits = (PLibMCEnvDriverEnvironment_RegisterDoubleParameterWithUnitsPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registerdoubleparameterwithunits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterDoubleParameterWithUnits == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter = (PLibMCEnvDriverEnvironment_RegisterIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registerintegerparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter = (PLibMCEnvDriverEnvironment_RegisterIntegerParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registerintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterBoolParameter = (PLibMCEnvDriverEnvironment_RegisterBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registerboolparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterBoolParameter = (PLibMCEnvDriverEnvironment_RegisterBoolParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registerboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetStringParameter = (PLibMCEnvDriverEnvironment_SetStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setstringparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetStringParameter = (PLibMCEnvDriverEnvironment_SetStringParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetUUIDParameter = (PLibMCEnvDriverEnvironment_SetUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setuuidparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetUUIDParameter = (PLibMCEnvDriverEnvironment_SetUUIDParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetDoubleParameter = (PLibMCEnvDriverEnvironment_SetDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetDoubleParameter = (PLibMCEnvDriverEnvironment_SetDoubleParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetIntegerParameter = (PLibMCEnvDriverEnvironment_SetIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setintegerparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetIntegerParameter = (PLibMCEnvDriverEnvironment_SetIntegerParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetBoolParameter = (PLibMCEnvDriverEnvironment_SetBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setboolparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetBoolParameter = (PLibMCEnvDriverEnvironment_SetBoolParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_Sleep = (PLibMCEnvDriverEnvironment_SleepPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_sleep");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_Sleep = (PLibMCEnvDriverEnvironment_SleepPtr) dlsym(hLibrary, "libmcenv_driverenvironment_sleep");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_Sleep == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMilliseconds = (PLibMCEnvDriverEnvironment_GetGlobalTimerInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_getglobaltimerinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMilliseconds = (PLibMCEnvDriverEnvironment_GetGlobalTimerInMillisecondsPtr) dlsym(hLibrary, "libmcenv_driverenvironment_getglobaltimerinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMicroseconds = (PLibMCEnvDriverEnvironment_GetGlobalTimerInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_getglobaltimerinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMicroseconds = (PLibMCEnvDriverEnvironment_GetGlobalTimerInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_driverenvironment_getglobaltimerinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_LogMessage = (PLibMCEnvDriverEnvironment_LogMessagePtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_logmessage");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_LogMessage = (PLibMCEnvDriverEnvironment_LogMessagePtr) dlsym(hLibrary, "libmcenv_driverenvironment_logmessage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_LogMessage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_LogWarning = (PLibMCEnvDriverEnvironment_LogWarningPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_logwarning");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_LogWarning = (PLibMCEnvDriverEnvironment_LogWarningPtr) dlsym(hLibrary, "libmcenv_driverenvironment_logwarning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_LogWarning == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_LogInfo = (PLibMCEnvDriverEnvironment_LogInfoPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_loginfo");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_LogInfo = (PLibMCEnvDriverEnvironment_LogInfoPtr) dlsym(hLibrary, "libmcenv_driverenvironment_loginfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_LogInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateEmptyImage = (PLibMCEnvDriverEnvironment_CreateEmptyImagePtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createemptyimage");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateEmptyImage = (PLibMCEnvDriverEnvironment_CreateEmptyImagePtr) dlsym(hLibrary, "libmcenv_driverenvironment_createemptyimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateEmptyImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_LoadPNGImage = (PLibMCEnvDriverEnvironment_LoadPNGImagePtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_loadpngimage");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_LoadPNGImage = (PLibMCEnvDriverEnvironment_LoadPNGImagePtr) dlsym(hLibrary, "libmcenv_driverenvironment_loadpngimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_LoadPNGImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateDiscreteField2D = (PLibMCEnvDriverEnvironment_CreateDiscreteField2DPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_creatediscretefield2d");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateDiscreteField2D = (PLibMCEnvDriverEnvironment_CreateDiscreteField2DPtr) dlsym(hLibrary, "libmcenv_driverenvironment_creatediscretefield2d");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateDiscreteField2D == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateDiscreteField2DFromImage = (PLibMCEnvDriverEnvironment_CreateDiscreteField2DFromImagePtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_creatediscretefield2dfromimage");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateDiscreteField2DFromImage = (PLibMCEnvDriverEnvironment_CreateDiscreteField2DFromImagePtr) dlsym(hLibrary, "libmcenv_driverenvironment_creatediscretefield2dfromimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateDiscreteField2DFromImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_HasBuildJob = (PLibMCEnvDriverEnvironment_HasBuildJobPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_hasbuildjob");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_HasBuildJob = (PLibMCEnvDriverEnvironment_HasBuildJobPtr) dlsym(hLibrary, "libmcenv_driverenvironment_hasbuildjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_HasBuildJob == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_GetBuildJob = (PLibMCEnvDriverEnvironment_GetBuildJobPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_getbuildjob");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_GetBuildJob = (PLibMCEnvDriverEnvironment_GetBuildJobPtr) dlsym(hLibrary, "libmcenv_driverenvironment_getbuildjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_GetBuildJob == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_HasBuildExecution = (PLibMCEnvDriverEnvironment_HasBuildExecutionPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_hasbuildexecution");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_HasBuildExecution = (PLibMCEnvDriverEnvironment_HasBuildExecutionPtr) dlsym(hLibrary, "libmcenv_driverenvironment_hasbuildexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_HasBuildExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_GetBuildExecution = (PLibMCEnvDriverEnvironment_GetBuildExecutionPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_getbuildexecution");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_GetBuildExecution = (PLibMCEnvDriverEnvironment_GetBuildExecutionPtr) dlsym(hLibrary, "libmcenv_driverenvironment_getbuildexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_GetBuildExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateCryptoContext = (PLibMCEnvDriverEnvironment_CreateCryptoContextPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createcryptocontext");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateCryptoContext = (PLibMCEnvDriverEnvironment_CreateCryptoContextPtr) dlsym(hLibrary, "libmcenv_driverenvironment_createcryptocontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateCryptoContext == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_GetCurrentDateTime = (PLibMCEnvDriverEnvironment_GetCurrentDateTimePtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_getcurrentdatetime");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_GetCurrentDateTime = (PLibMCEnvDriverEnvironment_GetCurrentDateTimePtr) dlsym(hLibrary, "libmcenv_driverenvironment_getcurrentdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_GetCurrentDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_GetCustomDateTime = (PLibMCEnvDriverEnvironment_GetCustomDateTimePtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_getcustomdatetime");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_GetCustomDateTime = (PLibMCEnvDriverEnvironment_GetCustomDateTimePtr) dlsym(hLibrary, "libmcenv_driverenvironment_getcustomdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_GetCustomDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_GetStartDateTime = (PLibMCEnvDriverEnvironment_GetStartDateTimePtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_getstartdatetime");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_GetStartDateTime = (PLibMCEnvDriverEnvironment_GetStartDateTimePtr) dlsym(hLibrary, "libmcenv_driverenvironment_getstartdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_GetStartDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_CanTrigger = (PLibMCEnvSignalTrigger_CanTriggerPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_cantrigger");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_CanTrigger = (PLibMCEnvSignalTrigger_CanTriggerPtr) dlsym(hLibrary, "libmcenv_signaltrigger_cantrigger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_CanTrigger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_Trigger = (PLibMCEnvSignalTrigger_TriggerPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_trigger");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_Trigger = (PLibMCEnvSignalTrigger_TriggerPtr) dlsym(hLibrary, "libmcenv_signaltrigger_trigger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_Trigger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_WaitForHandling = (PLibMCEnvSignalTrigger_WaitForHandlingPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_waitforhandling");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_WaitForHandling = (PLibMCEnvSignalTrigger_WaitForHandlingPtr) dlsym(hLibrary, "libmcenv_signaltrigger_waitforhandling");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_WaitForHandling == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetName = (PLibMCEnvSignalTrigger_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getname");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetName = (PLibMCEnvSignalTrigger_GetNamePtr) dlsym(hLibrary, "libmcenv_signaltrigger_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetStateMachine = (PLibMCEnvSignalTrigger_GetStateMachinePtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getstatemachine");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetStateMachine = (PLibMCEnvSignalTrigger_GetStateMachinePtr) dlsym(hLibrary, "libmcenv_signaltrigger_getstatemachine");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetStateMachine == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetString = (PLibMCEnvSignalTrigger_SetStringPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setstring");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetString = (PLibMCEnvSignalTrigger_SetStringPtr) dlsym(hLibrary, "libmcenv_signaltrigger_setstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetUUID = (PLibMCEnvSignalTrigger_SetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setuuid");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetUUID = (PLibMCEnvSignalTrigger_SetUUIDPtr) dlsym(hLibrary, "libmcenv_signaltrigger_setuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetDouble = (PLibMCEnvSignalTrigger_SetDoublePtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setdouble");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetDouble = (PLibMCEnvSignalTrigger_SetDoublePtr) dlsym(hLibrary, "libmcenv_signaltrigger_setdouble");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetDouble == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetInteger = (PLibMCEnvSignalTrigger_SetIntegerPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setinteger");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetInteger = (PLibMCEnvSignalTrigger_SetIntegerPtr) dlsym(hLibrary, "libmcenv_signaltrigger_setinteger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetInteger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetBool = (PLibMCEnvSignalTrigger_SetBoolPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setbool");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetBool = (PLibMCEnvSignalTrigger_SetBoolPtr) dlsym(hLibrary, "libmcenv_signaltrigger_setbool");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetBool == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetStringResult = (PLibMCEnvSignalTrigger_GetStringResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getstringresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetStringResult = (PLibMCEnvSignalTrigger_GetStringResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getstringresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetStringResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetUUIDResult = (PLibMCEnvSignalTrigger_GetUUIDResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getuuidresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetUUIDResult = (PLibMCEnvSignalTrigger_GetUUIDResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getuuidresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetUUIDResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetDoubleResult = (PLibMCEnvSignalTrigger_GetDoubleResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getdoubleresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetDoubleResult = (PLibMCEnvSignalTrigger_GetDoubleResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getdoubleresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetDoubleResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetIntegerResult = (PLibMCEnvSignalTrigger_GetIntegerResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getintegerresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetIntegerResult = (PLibMCEnvSignalTrigger_GetIntegerResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getintegerresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetIntegerResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetBoolResult = (PLibMCEnvSignalTrigger_GetBoolResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getboolresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetBoolResult = (PLibMCEnvSignalTrigger_GetBoolResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getboolresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetBoolResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SignalHandled = (PLibMCEnvSignalHandler_SignalHandledPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_signalhandled");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SignalHandled = (PLibMCEnvSignalHandler_SignalHandledPtr) dlsym(hLibrary, "libmcenv_signalhandler_signalhandled");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SignalHandled == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetName = (PLibMCEnvSignalHandler_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getname");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetName = (PLibMCEnvSignalHandler_GetNamePtr) dlsym(hLibrary, "libmcenv_signalhandler_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetSignalID = (PLibMCEnvSignalHandler_GetSignalIDPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getsignalid");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetSignalID = (PLibMCEnvSignalHandler_GetSignalIDPtr) dlsym(hLibrary, "libmcenv_signalhandler_getsignalid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetSignalID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetSignalUUID = (PLibMCEnvSignalHandler_GetSignalUUIDPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getsignaluuid");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetSignalUUID = (PLibMCEnvSignalHandler_GetSignalUUIDPtr) dlsym(hLibrary, "libmcenv_signalhandler_getsignaluuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetSignalUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetStateMachine = (PLibMCEnvSignalHandler_GetStateMachinePtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getstatemachine");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetStateMachine = (PLibMCEnvSignalHandler_GetStateMachinePtr) dlsym(hLibrary, "libmcenv_signalhandler_getstatemachine");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetStateMachine == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetString = (PLibMCEnvSignalHandler_GetStringPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getstring");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetString = (PLibMCEnvSignalHandler_GetStringPtr) dlsym(hLibrary, "libmcenv_signalhandler_getstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetUUID = (PLibMCEnvSignalHandler_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getuuid");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetUUID = (PLibMCEnvSignalHandler_GetUUIDPtr) dlsym(hLibrary, "libmcenv_signalhandler_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetDouble = (PLibMCEnvSignalHandler_GetDoublePtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getdouble");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetDouble = (PLibMCEnvSignalHandler_GetDoublePtr) dlsym(hLibrary, "libmcenv_signalhandler_getdouble");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetDouble == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetInteger = (PLibMCEnvSignalHandler_GetIntegerPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getinteger");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetInteger = (PLibMCEnvSignalHandler_GetIntegerPtr) dlsym(hLibrary, "libmcenv_signalhandler_getinteger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetInteger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetBool = (PLibMCEnvSignalHandler_GetBoolPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getbool");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetBool = (PLibMCEnvSignalHandler_GetBoolPtr) dlsym(hLibrary, "libmcenv_signalhandler_getbool");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetBool == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetStringResult = (PLibMCEnvSignalHandler_SetStringResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setstringresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetStringResult = (PLibMCEnvSignalHandler_SetStringResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setstringresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetStringResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetUUIDResult = (PLibMCEnvSignalHandler_SetUUIDResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setuuidresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetUUIDResult = (PLibMCEnvSignalHandler_SetUUIDResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setuuidresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetUUIDResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetDoubleResult = (PLibMCEnvSignalHandler_SetDoubleResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setdoubleresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetDoubleResult = (PLibMCEnvSignalHandler_SetDoubleResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setdoubleresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetDoubleResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetIntegerResult = (PLibMCEnvSignalHandler_SetIntegerResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setintegerresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetIntegerResult = (PLibMCEnvSignalHandler_SetIntegerResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setintegerresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetIntegerResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetBoolResult = (PLibMCEnvSignalHandler_SetBoolResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setboolresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetBoolResult = (PLibMCEnvSignalHandler_SetBoolResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setboolresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetBoolResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetUUID = (PLibMCEnvBaseTempStreamWriter_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_basetempstreamwriter_getuuid");
		#else // _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetUUID = (PLibMCEnvBaseTempStreamWriter_GetUUIDPtr) dlsym(hLibrary, "libmcenv_basetempstreamwriter_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseTempStreamWriter_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetName = (PLibMCEnvBaseTempStreamWriter_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_basetempstreamwriter_getname");
		#else // _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetName = (PLibMCEnvBaseTempStreamWriter_GetNamePtr) dlsym(hLibrary, "libmcenv_basetempstreamwriter_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseTempStreamWriter_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetMIMEType = (PLibMCEnvBaseTempStreamWriter_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcenv_basetempstreamwriter_getmimetype");
		#else // _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetMIMEType = (PLibMCEnvBaseTempStreamWriter_GetMIMETypePtr) dlsym(hLibrary, "libmcenv_basetempstreamwriter_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseTempStreamWriter_GetMIMEType == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetSize = (PLibMCEnvBaseTempStreamWriter_GetSizePtr) GetProcAddress(hLibrary, "libmcenv_basetempstreamwriter_getsize");
		#else // _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetSize = (PLibMCEnvBaseTempStreamWriter_GetSizePtr) dlsym(hLibrary, "libmcenv_basetempstreamwriter_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseTempStreamWriter_GetSize == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseTempStreamWriter_Finish = (PLibMCEnvBaseTempStreamWriter_FinishPtr) GetProcAddress(hLibrary, "libmcenv_basetempstreamwriter_finish");
		#else // _WIN32
		pWrapperTable->m_BaseTempStreamWriter_Finish = (PLibMCEnvBaseTempStreamWriter_FinishPtr) dlsym(hLibrary, "libmcenv_basetempstreamwriter_finish");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseTempStreamWriter_Finish == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseTempStreamWriter_IsFinished = (PLibMCEnvBaseTempStreamWriter_IsFinishedPtr) GetProcAddress(hLibrary, "libmcenv_basetempstreamwriter_isfinished");
		#else // _WIN32
		pWrapperTable->m_BaseTempStreamWriter_IsFinished = (PLibMCEnvBaseTempStreamWriter_IsFinishedPtr) dlsym(hLibrary, "libmcenv_basetempstreamwriter_isfinished");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseTempStreamWriter_IsFinished == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetStreamReader = (PLibMCEnvBaseTempStreamWriter_GetStreamReaderPtr) GetProcAddress(hLibrary, "libmcenv_basetempstreamwriter_getstreamreader");
		#else // _WIN32
		pWrapperTable->m_BaseTempStreamWriter_GetStreamReader = (PLibMCEnvBaseTempStreamWriter_GetStreamReaderPtr) dlsym(hLibrary, "libmcenv_basetempstreamwriter_getstreamreader");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BaseTempStreamWriter_GetStreamReader == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TempStreamWriter_GetWritePosition = (PLibMCEnvTempStreamWriter_GetWritePositionPtr) GetProcAddress(hLibrary, "libmcenv_tempstreamwriter_getwriteposition");
		#else // _WIN32
		pWrapperTable->m_TempStreamWriter_GetWritePosition = (PLibMCEnvTempStreamWriter_GetWritePositionPtr) dlsym(hLibrary, "libmcenv_tempstreamwriter_getwriteposition");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TempStreamWriter_GetWritePosition == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TempStreamWriter_Seek = (PLibMCEnvTempStreamWriter_SeekPtr) GetProcAddress(hLibrary, "libmcenv_tempstreamwriter_seek");
		#else // _WIN32
		pWrapperTable->m_TempStreamWriter_Seek = (PLibMCEnvTempStreamWriter_SeekPtr) dlsym(hLibrary, "libmcenv_tempstreamwriter_seek");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TempStreamWriter_Seek == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TempStreamWriter_WriteData = (PLibMCEnvTempStreamWriter_WriteDataPtr) GetProcAddress(hLibrary, "libmcenv_tempstreamwriter_writedata");
		#else // _WIN32
		pWrapperTable->m_TempStreamWriter_WriteData = (PLibMCEnvTempStreamWriter_WriteDataPtr) dlsym(hLibrary, "libmcenv_tempstreamwriter_writedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TempStreamWriter_WriteData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TempStreamWriter_WriteString = (PLibMCEnvTempStreamWriter_WriteStringPtr) GetProcAddress(hLibrary, "libmcenv_tempstreamwriter_writestring");
		#else // _WIN32
		pWrapperTable->m_TempStreamWriter_WriteString = (PLibMCEnvTempStreamWriter_WriteStringPtr) dlsym(hLibrary, "libmcenv_tempstreamwriter_writestring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TempStreamWriter_WriteString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TempStreamWriter_WriteLine = (PLibMCEnvTempStreamWriter_WriteLinePtr) GetProcAddress(hLibrary, "libmcenv_tempstreamwriter_writeline");
		#else // _WIN32
		pWrapperTable->m_TempStreamWriter_WriteLine = (PLibMCEnvTempStreamWriter_WriteLinePtr) dlsym(hLibrary, "libmcenv_tempstreamwriter_writeline");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TempStreamWriter_WriteLine == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_TempStreamWriter_CopyFrom = (PLibMCEnvTempStreamWriter_CopyFromPtr) GetProcAddress(hLibrary, "libmcenv_tempstreamwriter_copyfrom");
		#else // _WIN32
		pWrapperTable->m_TempStreamWriter_CopyFrom = (PLibMCEnvTempStreamWriter_CopyFromPtr) dlsym(hLibrary, "libmcenv_tempstreamwriter_copyfrom");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_TempStreamWriter_CopyFrom == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ZIPStreamWriter_CreateZIPEntry = (PLibMCEnvZIPStreamWriter_CreateZIPEntryPtr) GetProcAddress(hLibrary, "libmcenv_zipstreamwriter_createzipentry");
		#else // _WIN32
		pWrapperTable->m_ZIPStreamWriter_CreateZIPEntry = (PLibMCEnvZIPStreamWriter_CreateZIPEntryPtr) dlsym(hLibrary, "libmcenv_zipstreamwriter_createzipentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ZIPStreamWriter_CreateZIPEntry == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ZIPStreamWriter_CreateZIPEntryFromStream = (PLibMCEnvZIPStreamWriter_CreateZIPEntryFromStreamPtr) GetProcAddress(hLibrary, "libmcenv_zipstreamwriter_createzipentryfromstream");
		#else // _WIN32
		pWrapperTable->m_ZIPStreamWriter_CreateZIPEntryFromStream = (PLibMCEnvZIPStreamWriter_CreateZIPEntryFromStreamPtr) dlsym(hLibrary, "libmcenv_zipstreamwriter_createzipentryfromstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ZIPStreamWriter_CreateZIPEntryFromStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StreamReader_GetUUID = (PLibMCEnvStreamReader_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_streamreader_getuuid");
		#else // _WIN32
		pWrapperTable->m_StreamReader_GetUUID = (PLibMCEnvStreamReader_GetUUIDPtr) dlsym(hLibrary, "libmcenv_streamreader_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StreamReader_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StreamReader_GetName = (PLibMCEnvStreamReader_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_streamreader_getname");
		#else // _WIN32
		pWrapperTable->m_StreamReader_GetName = (PLibMCEnvStreamReader_GetNamePtr) dlsym(hLibrary, "libmcenv_streamreader_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StreamReader_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StreamReader_GetMIMEType = (PLibMCEnvStreamReader_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcenv_streamreader_getmimetype");
		#else // _WIN32
		pWrapperTable->m_StreamReader_GetMIMEType = (PLibMCEnvStreamReader_GetMIMETypePtr) dlsym(hLibrary, "libmcenv_streamreader_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StreamReader_GetMIMEType == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StreamReader_GetSize = (PLibMCEnvStreamReader_GetSizePtr) GetProcAddress(hLibrary, "libmcenv_streamreader_getsize");
		#else // _WIN32
		pWrapperTable->m_StreamReader_GetSize = (PLibMCEnvStreamReader_GetSizePtr) dlsym(hLibrary, "libmcenv_streamreader_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StreamReader_GetSize == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StreamReader_GetReadPosition = (PLibMCEnvStreamReader_GetReadPositionPtr) GetProcAddress(hLibrary, "libmcenv_streamreader_getreadposition");
		#else // _WIN32
		pWrapperTable->m_StreamReader_GetReadPosition = (PLibMCEnvStreamReader_GetReadPositionPtr) dlsym(hLibrary, "libmcenv_streamreader_getreadposition");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StreamReader_GetReadPosition == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StreamReader_Seek = (PLibMCEnvStreamReader_SeekPtr) GetProcAddress(hLibrary, "libmcenv_streamreader_seek");
		#else // _WIN32
		pWrapperTable->m_StreamReader_Seek = (PLibMCEnvStreamReader_SeekPtr) dlsym(hLibrary, "libmcenv_streamreader_seek");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StreamReader_Seek == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StreamReader_ReadData = (PLibMCEnvStreamReader_ReadDataPtr) GetProcAddress(hLibrary, "libmcenv_streamreader_readdata");
		#else // _WIN32
		pWrapperTable->m_StreamReader_ReadData = (PLibMCEnvStreamReader_ReadDataPtr) dlsym(hLibrary, "libmcenv_streamreader_readdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StreamReader_ReadData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StreamReader_ReadAllData = (PLibMCEnvStreamReader_ReadAllDataPtr) GetProcAddress(hLibrary, "libmcenv_streamreader_readalldata");
		#else // _WIN32
		pWrapperTable->m_StreamReader_ReadAllData = (PLibMCEnvStreamReader_ReadAllDataPtr) dlsym(hLibrary, "libmcenv_streamreader_readalldata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StreamReader_ReadAllData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UniformJournalSampling_GetVariableName = (PLibMCEnvUniformJournalSampling_GetVariableNamePtr) GetProcAddress(hLibrary, "libmcenv_uniformjournalsampling_getvariablename");
		#else // _WIN32
		pWrapperTable->m_UniformJournalSampling_GetVariableName = (PLibMCEnvUniformJournalSampling_GetVariableNamePtr) dlsym(hLibrary, "libmcenv_uniformjournalsampling_getvariablename");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UniformJournalSampling_GetVariableName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UniformJournalSampling_GetNumberOfSamples = (PLibMCEnvUniformJournalSampling_GetNumberOfSamplesPtr) GetProcAddress(hLibrary, "libmcenv_uniformjournalsampling_getnumberofsamples");
		#else // _WIN32
		pWrapperTable->m_UniformJournalSampling_GetNumberOfSamples = (PLibMCEnvUniformJournalSampling_GetNumberOfSamplesPtr) dlsym(hLibrary, "libmcenv_uniformjournalsampling_getnumberofsamples");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UniformJournalSampling_GetNumberOfSamples == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UniformJournalSampling_GetStartTimeStamp = (PLibMCEnvUniformJournalSampling_GetStartTimeStampPtr) GetProcAddress(hLibrary, "libmcenv_uniformjournalsampling_getstarttimestamp");
		#else // _WIN32
		pWrapperTable->m_UniformJournalSampling_GetStartTimeStamp = (PLibMCEnvUniformJournalSampling_GetStartTimeStampPtr) dlsym(hLibrary, "libmcenv_uniformjournalsampling_getstarttimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UniformJournalSampling_GetStartTimeStamp == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UniformJournalSampling_GetEndTimeStamp = (PLibMCEnvUniformJournalSampling_GetEndTimeStampPtr) GetProcAddress(hLibrary, "libmcenv_uniformjournalsampling_getendtimestamp");
		#else // _WIN32
		pWrapperTable->m_UniformJournalSampling_GetEndTimeStamp = (PLibMCEnvUniformJournalSampling_GetEndTimeStampPtr) dlsym(hLibrary, "libmcenv_uniformjournalsampling_getendtimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UniformJournalSampling_GetEndTimeStamp == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UniformJournalSampling_GetSample = (PLibMCEnvUniformJournalSampling_GetSamplePtr) GetProcAddress(hLibrary, "libmcenv_uniformjournalsampling_getsample");
		#else // _WIN32
		pWrapperTable->m_UniformJournalSampling_GetSample = (PLibMCEnvUniformJournalSampling_GetSamplePtr) dlsym(hLibrary, "libmcenv_uniformjournalsampling_getsample");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UniformJournalSampling_GetSample == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UniformJournalSampling_GetAllSamples = (PLibMCEnvUniformJournalSampling_GetAllSamplesPtr) GetProcAddress(hLibrary, "libmcenv_uniformjournalsampling_getallsamples");
		#else // _WIN32
		pWrapperTable->m_UniformJournalSampling_GetAllSamples = (PLibMCEnvUniformJournalSampling_GetAllSamplesPtr) dlsym(hLibrary, "libmcenv_uniformjournalsampling_getallsamples");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UniformJournalSampling_GetAllSamples == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalVariable_GetVariableName = (PLibMCEnvJournalVariable_GetVariableNamePtr) GetProcAddress(hLibrary, "libmcenv_journalvariable_getvariablename");
		#else // _WIN32
		pWrapperTable->m_JournalVariable_GetVariableName = (PLibMCEnvJournalVariable_GetVariableNamePtr) dlsym(hLibrary, "libmcenv_journalvariable_getvariablename");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalVariable_GetVariableName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalVariable_GetStartTimeStamp = (PLibMCEnvJournalVariable_GetStartTimeStampPtr) GetProcAddress(hLibrary, "libmcenv_journalvariable_getstarttimestamp");
		#else // _WIN32
		pWrapperTable->m_JournalVariable_GetStartTimeStamp = (PLibMCEnvJournalVariable_GetStartTimeStampPtr) dlsym(hLibrary, "libmcenv_journalvariable_getstarttimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalVariable_GetStartTimeStamp == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalVariable_GetEndTimeStamp = (PLibMCEnvJournalVariable_GetEndTimeStampPtr) GetProcAddress(hLibrary, "libmcenv_journalvariable_getendtimestamp");
		#else // _WIN32
		pWrapperTable->m_JournalVariable_GetEndTimeStamp = (PLibMCEnvJournalVariable_GetEndTimeStampPtr) dlsym(hLibrary, "libmcenv_journalvariable_getendtimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalVariable_GetEndTimeStamp == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalVariable_ComputeFullAverage = (PLibMCEnvJournalVariable_ComputeFullAveragePtr) GetProcAddress(hLibrary, "libmcenv_journalvariable_computefullaverage");
		#else // _WIN32
		pWrapperTable->m_JournalVariable_ComputeFullAverage = (PLibMCEnvJournalVariable_ComputeFullAveragePtr) dlsym(hLibrary, "libmcenv_journalvariable_computefullaverage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalVariable_ComputeFullAverage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalVariable_ComputeAverage = (PLibMCEnvJournalVariable_ComputeAveragePtr) GetProcAddress(hLibrary, "libmcenv_journalvariable_computeaverage");
		#else // _WIN32
		pWrapperTable->m_JournalVariable_ComputeAverage = (PLibMCEnvJournalVariable_ComputeAveragePtr) dlsym(hLibrary, "libmcenv_journalvariable_computeaverage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalVariable_ComputeAverage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalVariable_ComputeSample = (PLibMCEnvJournalVariable_ComputeSamplePtr) GetProcAddress(hLibrary, "libmcenv_journalvariable_computesample");
		#else // _WIN32
		pWrapperTable->m_JournalVariable_ComputeSample = (PLibMCEnvJournalVariable_ComputeSamplePtr) dlsym(hLibrary, "libmcenv_journalvariable_computesample");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalVariable_ComputeSample == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalVariable_ComputeUniformAverageSamples = (PLibMCEnvJournalVariable_ComputeUniformAverageSamplesPtr) GetProcAddress(hLibrary, "libmcenv_journalvariable_computeuniformaveragesamples");
		#else // _WIN32
		pWrapperTable->m_JournalVariable_ComputeUniformAverageSamples = (PLibMCEnvJournalVariable_ComputeUniformAverageSamplesPtr) dlsym(hLibrary, "libmcenv_journalvariable_computeuniformaveragesamples");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalVariable_ComputeUniformAverageSamples == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalVariable_ComputeEquidistantSamples = (PLibMCEnvJournalVariable_ComputeEquidistantSamplesPtr) GetProcAddress(hLibrary, "libmcenv_journalvariable_computeequidistantsamples");
		#else // _WIN32
		pWrapperTable->m_JournalVariable_ComputeEquidistantSamples = (PLibMCEnvJournalVariable_ComputeEquidistantSamplesPtr) dlsym(hLibrary, "libmcenv_journalvariable_computeequidistantsamples");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalVariable_ComputeEquidistantSamples == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalVariable_ReceiveRawTimeStream = (PLibMCEnvJournalVariable_ReceiveRawTimeStreamPtr) GetProcAddress(hLibrary, "libmcenv_journalvariable_receiverawtimestream");
		#else // _WIN32
		pWrapperTable->m_JournalVariable_ReceiveRawTimeStream = (PLibMCEnvJournalVariable_ReceiveRawTimeStreamPtr) dlsym(hLibrary, "libmcenv_journalvariable_receiverawtimestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalVariable_ReceiveRawTimeStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetUUID = (PLibMCEnvAlert_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_alert_getuuid");
		#else // _WIN32
		pWrapperTable->m_Alert_GetUUID = (PLibMCEnvAlert_GetUUIDPtr) dlsym(hLibrary, "libmcenv_alert_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_IsActive = (PLibMCEnvAlert_IsActivePtr) GetProcAddress(hLibrary, "libmcenv_alert_isactive");
		#else // _WIN32
		pWrapperTable->m_Alert_IsActive = (PLibMCEnvAlert_IsActivePtr) dlsym(hLibrary, "libmcenv_alert_isactive");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_IsActive == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetAlertLevel = (PLibMCEnvAlert_GetAlertLevelPtr) GetProcAddress(hLibrary, "libmcenv_alert_getalertlevel");
		#else // _WIN32
		pWrapperTable->m_Alert_GetAlertLevel = (PLibMCEnvAlert_GetAlertLevelPtr) dlsym(hLibrary, "libmcenv_alert_getalertlevel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetAlertLevel == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetIdentifier = (PLibMCEnvAlert_GetIdentifierPtr) GetProcAddress(hLibrary, "libmcenv_alert_getidentifier");
		#else // _WIN32
		pWrapperTable->m_Alert_GetIdentifier = (PLibMCEnvAlert_GetIdentifierPtr) dlsym(hLibrary, "libmcenv_alert_getidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetIdentifier == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetReadableContextInformation = (PLibMCEnvAlert_GetReadableContextInformationPtr) GetProcAddress(hLibrary, "libmcenv_alert_getreadablecontextinformation");
		#else // _WIN32
		pWrapperTable->m_Alert_GetReadableContextInformation = (PLibMCEnvAlert_GetReadableContextInformationPtr) dlsym(hLibrary, "libmcenv_alert_getreadablecontextinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetReadableContextInformation == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_NeedsAcknowledgement = (PLibMCEnvAlert_NeedsAcknowledgementPtr) GetProcAddress(hLibrary, "libmcenv_alert_needsacknowledgement");
		#else // _WIN32
		pWrapperTable->m_Alert_NeedsAcknowledgement = (PLibMCEnvAlert_NeedsAcknowledgementPtr) dlsym(hLibrary, "libmcenv_alert_needsacknowledgement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_NeedsAcknowledgement == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_HasBeenAcknowledged = (PLibMCEnvAlert_HasBeenAcknowledgedPtr) GetProcAddress(hLibrary, "libmcenv_alert_hasbeenacknowledged");
		#else // _WIN32
		pWrapperTable->m_Alert_HasBeenAcknowledged = (PLibMCEnvAlert_HasBeenAcknowledgedPtr) dlsym(hLibrary, "libmcenv_alert_hasbeenacknowledged");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_HasBeenAcknowledged == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetAcknowledgementInformation = (PLibMCEnvAlert_GetAcknowledgementInformationPtr) GetProcAddress(hLibrary, "libmcenv_alert_getacknowledgementinformation");
		#else // _WIN32
		pWrapperTable->m_Alert_GetAcknowledgementInformation = (PLibMCEnvAlert_GetAcknowledgementInformationPtr) dlsym(hLibrary, "libmcenv_alert_getacknowledgementinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetAcknowledgementInformation == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetAcknowledgementTime = (PLibMCEnvAlert_GetAcknowledgementTimePtr) GetProcAddress(hLibrary, "libmcenv_alert_getacknowledgementtime");
		#else // _WIN32
		pWrapperTable->m_Alert_GetAcknowledgementTime = (PLibMCEnvAlert_GetAcknowledgementTimePtr) dlsym(hLibrary, "libmcenv_alert_getacknowledgementtime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetAcknowledgementTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_AcknowledgeForUser = (PLibMCEnvAlert_AcknowledgeForUserPtr) GetProcAddress(hLibrary, "libmcenv_alert_acknowledgeforuser");
		#else // _WIN32
		pWrapperTable->m_Alert_AcknowledgeForUser = (PLibMCEnvAlert_AcknowledgeForUserPtr) dlsym(hLibrary, "libmcenv_alert_acknowledgeforuser");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_AcknowledgeForUser == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_AcknowledgeAlertForCurrentUser = (PLibMCEnvAlert_AcknowledgeAlertForCurrentUserPtr) GetProcAddress(hLibrary, "libmcenv_alert_acknowledgealertforcurrentuser");
		#else // _WIN32
		pWrapperTable->m_Alert_AcknowledgeAlertForCurrentUser = (PLibMCEnvAlert_AcknowledgeAlertForCurrentUserPtr) dlsym(hLibrary, "libmcenv_alert_acknowledgealertforcurrentuser");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_AcknowledgeAlertForCurrentUser == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_DeactivateAlert = (PLibMCEnvAlert_DeactivateAlertPtr) GetProcAddress(hLibrary, "libmcenv_alert_deactivatealert");
		#else // _WIN32
		pWrapperTable->m_Alert_DeactivateAlert = (PLibMCEnvAlert_DeactivateAlertPtr) dlsym(hLibrary, "libmcenv_alert_deactivatealert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_DeactivateAlert == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AlertIterator_GetCurrentAlert = (PLibMCEnvAlertIterator_GetCurrentAlertPtr) GetProcAddress(hLibrary, "libmcenv_alertiterator_getcurrentalert");
		#else // _WIN32
		pWrapperTable->m_AlertIterator_GetCurrentAlert = (PLibMCEnvAlertIterator_GetCurrentAlertPtr) dlsym(hLibrary, "libmcenv_alertiterator_getcurrentalert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AlertIterator_GetCurrentAlert == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_GetCount = (PLibMCEnvLogEntryList_GetCountPtr) GetProcAddress(hLibrary, "libmcenv_logentrylist_getcount");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_GetCount = (PLibMCEnvLogEntryList_GetCountPtr) dlsym(hLibrary, "libmcenv_logentrylist_getcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_GetCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_GetEntry = (PLibMCEnvLogEntryList_GetEntryPtr) GetProcAddress(hLibrary, "libmcenv_logentrylist_getentry");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_GetEntry = (PLibMCEnvLogEntryList_GetEntryPtr) dlsym(hLibrary, "libmcenv_logentrylist_getentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_GetEntry == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_GetEntryTime = (PLibMCEnvLogEntryList_GetEntryTimePtr) GetProcAddress(hLibrary, "libmcenv_logentrylist_getentrytime");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_GetEntryTime = (PLibMCEnvLogEntryList_GetEntryTimePtr) dlsym(hLibrary, "libmcenv_logentrylist_getentrytime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_GetEntryTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalHandler_RetrieveJournalVariable = (PLibMCEnvJournalHandler_RetrieveJournalVariablePtr) GetProcAddress(hLibrary, "libmcenv_journalhandler_retrievejournalvariable");
		#else // _WIN32
		pWrapperTable->m_JournalHandler_RetrieveJournalVariable = (PLibMCEnvJournalHandler_RetrieveJournalVariablePtr) dlsym(hLibrary, "libmcenv_journalhandler_retrievejournalvariable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalHandler_RetrieveJournalVariable == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalHandler_RetrieveJournalVariableFromTimeInterval = (PLibMCEnvJournalHandler_RetrieveJournalVariableFromTimeIntervalPtr) GetProcAddress(hLibrary, "libmcenv_journalhandler_retrievejournalvariablefromtimeinterval");
		#else // _WIN32
		pWrapperTable->m_JournalHandler_RetrieveJournalVariableFromTimeInterval = (PLibMCEnvJournalHandler_RetrieveJournalVariableFromTimeIntervalPtr) dlsym(hLibrary, "libmcenv_journalhandler_retrievejournalvariablefromtimeinterval");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalHandler_RetrieveJournalVariableFromTimeInterval == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalHandler_GetStartTime = (PLibMCEnvJournalHandler_GetStartTimePtr) GetProcAddress(hLibrary, "libmcenv_journalhandler_getstarttime");
		#else // _WIN32
		pWrapperTable->m_JournalHandler_GetStartTime = (PLibMCEnvJournalHandler_GetStartTimePtr) dlsym(hLibrary, "libmcenv_journalhandler_getstarttime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalHandler_GetStartTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalHandler_RetrieveLogEntries = (PLibMCEnvJournalHandler_RetrieveLogEntriesPtr) GetProcAddress(hLibrary, "libmcenv_journalhandler_retrievelogentries");
		#else // _WIN32
		pWrapperTable->m_JournalHandler_RetrieveLogEntries = (PLibMCEnvJournalHandler_RetrieveLogEntriesPtr) dlsym(hLibrary, "libmcenv_journalhandler_retrievelogentries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalHandler_RetrieveLogEntries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalHandler_RetrieveLogEntriesFromTimeInterval = (PLibMCEnvJournalHandler_RetrieveLogEntriesFromTimeIntervalPtr) GetProcAddress(hLibrary, "libmcenv_journalhandler_retrievelogentriesfromtimeinterval");
		#else // _WIN32
		pWrapperTable->m_JournalHandler_RetrieveLogEntriesFromTimeInterval = (PLibMCEnvJournalHandler_RetrieveLogEntriesFromTimeIntervalPtr) dlsym(hLibrary, "libmcenv_journalhandler_retrievelogentriesfromtimeinterval");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalHandler_RetrieveLogEntriesFromTimeInterval == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalHandler_RetrieveAlerts = (PLibMCEnvJournalHandler_RetrieveAlertsPtr) GetProcAddress(hLibrary, "libmcenv_journalhandler_retrievealerts");
		#else // _WIN32
		pWrapperTable->m_JournalHandler_RetrieveAlerts = (PLibMCEnvJournalHandler_RetrieveAlertsPtr) dlsym(hLibrary, "libmcenv_journalhandler_retrievealerts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalHandler_RetrieveAlerts == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalHandler_RetrieveAlertsFromTimeInterval = (PLibMCEnvJournalHandler_RetrieveAlertsFromTimeIntervalPtr) GetProcAddress(hLibrary, "libmcenv_journalhandler_retrievealertsfromtimeinterval");
		#else // _WIN32
		pWrapperTable->m_JournalHandler_RetrieveAlertsFromTimeInterval = (PLibMCEnvJournalHandler_RetrieveAlertsFromTimeIntervalPtr) dlsym(hLibrary, "libmcenv_journalhandler_retrievealertsfromtimeinterval");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalHandler_RetrieveAlertsFromTimeInterval == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserDetailList_Count = (PLibMCEnvUserDetailList_CountPtr) GetProcAddress(hLibrary, "libmcenv_userdetaillist_count");
		#else // _WIN32
		pWrapperTable->m_UserDetailList_Count = (PLibMCEnvUserDetailList_CountPtr) dlsym(hLibrary, "libmcenv_userdetaillist_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserDetailList_Count == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserDetailList_GetUserProperties = (PLibMCEnvUserDetailList_GetUserPropertiesPtr) GetProcAddress(hLibrary, "libmcenv_userdetaillist_getuserproperties");
		#else // _WIN32
		pWrapperTable->m_UserDetailList_GetUserProperties = (PLibMCEnvUserDetailList_GetUserPropertiesPtr) dlsym(hLibrary, "libmcenv_userdetaillist_getuserproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserDetailList_GetUserProperties == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserDetailList_GetUsername = (PLibMCEnvUserDetailList_GetUsernamePtr) GetProcAddress(hLibrary, "libmcenv_userdetaillist_getusername");
		#else // _WIN32
		pWrapperTable->m_UserDetailList_GetUsername = (PLibMCEnvUserDetailList_GetUsernamePtr) dlsym(hLibrary, "libmcenv_userdetaillist_getusername");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserDetailList_GetUsername == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserDetailList_GetUUID = (PLibMCEnvUserDetailList_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_userdetaillist_getuuid");
		#else // _WIN32
		pWrapperTable->m_UserDetailList_GetUUID = (PLibMCEnvUserDetailList_GetUUIDPtr) dlsym(hLibrary, "libmcenv_userdetaillist_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserDetailList_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserDetailList_GetDescription = (PLibMCEnvUserDetailList_GetDescriptionPtr) GetProcAddress(hLibrary, "libmcenv_userdetaillist_getdescription");
		#else // _WIN32
		pWrapperTable->m_UserDetailList_GetDescription = (PLibMCEnvUserDetailList_GetDescriptionPtr) dlsym(hLibrary, "libmcenv_userdetaillist_getdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserDetailList_GetDescription == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserDetailList_GetRole = (PLibMCEnvUserDetailList_GetRolePtr) GetProcAddress(hLibrary, "libmcenv_userdetaillist_getrole");
		#else // _WIN32
		pWrapperTable->m_UserDetailList_GetRole = (PLibMCEnvUserDetailList_GetRolePtr) dlsym(hLibrary, "libmcenv_userdetaillist_getrole");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserDetailList_GetRole == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserDetailList_GetLanguage = (PLibMCEnvUserDetailList_GetLanguagePtr) GetProcAddress(hLibrary, "libmcenv_userdetaillist_getlanguage");
		#else // _WIN32
		pWrapperTable->m_UserDetailList_GetLanguage = (PLibMCEnvUserDetailList_GetLanguagePtr) dlsym(hLibrary, "libmcenv_userdetaillist_getlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserDetailList_GetLanguage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_UserExists = (PLibMCEnvUserManagementHandler_UserExistsPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_userexists");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_UserExists = (PLibMCEnvUserManagementHandler_UserExistsPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_userexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_UserExists == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_UserUUIDExists = (PLibMCEnvUserManagementHandler_UserUUIDExistsPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_useruuidexists");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_UserUUIDExists = (PLibMCEnvUserManagementHandler_UserUUIDExistsPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_useruuidexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_UserUUIDExists == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserProperties = (PLibMCEnvUserManagementHandler_GetUserPropertiesPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getuserproperties");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserProperties = (PLibMCEnvUserManagementHandler_GetUserPropertiesPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getuserproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUserProperties == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserPropertiesByUUID = (PLibMCEnvUserManagementHandler_GetUserPropertiesByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getuserpropertiesbyuuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserPropertiesByUUID = (PLibMCEnvUserManagementHandler_GetUserPropertiesByUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getuserpropertiesbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUserPropertiesByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUsernameByUUID = (PLibMCEnvUserManagementHandler_GetUsernameByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getusernamebyuuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUsernameByUUID = (PLibMCEnvUserManagementHandler_GetUsernameByUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getusernamebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUsernameByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserUUID = (PLibMCEnvUserManagementHandler_GetUserUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getuseruuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserUUID = (PLibMCEnvUserManagementHandler_GetUserUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getuseruuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUserUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserDescription = (PLibMCEnvUserManagementHandler_GetUserDescriptionPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getuserdescription");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserDescription = (PLibMCEnvUserManagementHandler_GetUserDescriptionPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getuserdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUserDescription == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserDescriptionByUUID = (PLibMCEnvUserManagementHandler_GetUserDescriptionByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getuserdescriptionbyuuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserDescriptionByUUID = (PLibMCEnvUserManagementHandler_GetUserDescriptionByUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getuserdescriptionbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUserDescriptionByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserRole = (PLibMCEnvUserManagementHandler_GetUserRolePtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getuserrole");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserRole = (PLibMCEnvUserManagementHandler_GetUserRolePtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getuserrole");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUserRole == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserRoleByUUID = (PLibMCEnvUserManagementHandler_GetUserRoleByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getuserrolebyuuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserRoleByUUID = (PLibMCEnvUserManagementHandler_GetUserRoleByUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getuserrolebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUserRoleByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserLanguage = (PLibMCEnvUserManagementHandler_GetUserLanguagePtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getuserlanguage");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserLanguage = (PLibMCEnvUserManagementHandler_GetUserLanguagePtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getuserlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUserLanguage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserLanguageByUUID = (PLibMCEnvUserManagementHandler_GetUserLanguageByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getuserlanguagebyuuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetUserLanguageByUUID = (PLibMCEnvUserManagementHandler_GetUserLanguageByUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getuserlanguagebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetUserLanguageByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_CreateUser = (PLibMCEnvUserManagementHandler_CreateUserPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_createuser");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_CreateUser = (PLibMCEnvUserManagementHandler_CreateUserPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_createuser");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_CreateUser == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserLanguage = (PLibMCEnvUserManagementHandler_SetUserLanguagePtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_setuserlanguage");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserLanguage = (PLibMCEnvUserManagementHandler_SetUserLanguagePtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_setuserlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_SetUserLanguage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserRole = (PLibMCEnvUserManagementHandler_SetUserRolePtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_setuserrole");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserRole = (PLibMCEnvUserManagementHandler_SetUserRolePtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_setuserrole");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_SetUserRole == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserDescription = (PLibMCEnvUserManagementHandler_SetUserDescriptionPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_setuserdescription");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserDescription = (PLibMCEnvUserManagementHandler_SetUserDescriptionPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_setuserdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_SetUserDescription == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserPassword = (PLibMCEnvUserManagementHandler_SetUserPasswordPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_setuserpassword");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserPassword = (PLibMCEnvUserManagementHandler_SetUserPasswordPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_setuserpassword");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_SetUserPassword == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserLanguageByUUID = (PLibMCEnvUserManagementHandler_SetUserLanguageByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_setuserlanguagebyuuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserLanguageByUUID = (PLibMCEnvUserManagementHandler_SetUserLanguageByUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_setuserlanguagebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_SetUserLanguageByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserRoleByUUID = (PLibMCEnvUserManagementHandler_SetUserRoleByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_setuserrolebyuuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserRoleByUUID = (PLibMCEnvUserManagementHandler_SetUserRoleByUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_setuserrolebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_SetUserRoleByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserDescriptionByUUID = (PLibMCEnvUserManagementHandler_SetUserDescriptionByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_setuserdescriptionbyuuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserDescriptionByUUID = (PLibMCEnvUserManagementHandler_SetUserDescriptionByUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_setuserdescriptionbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_SetUserDescriptionByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserPasswordByUUID = (PLibMCEnvUserManagementHandler_SetUserPasswordByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_setuserpasswordbyuuid");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_SetUserPasswordByUUID = (PLibMCEnvUserManagementHandler_SetUserPasswordByUUIDPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_setuserpasswordbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_SetUserPasswordByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserManagementHandler_GetActiveUsers = (PLibMCEnvUserManagementHandler_GetActiveUsersPtr) GetProcAddress(hLibrary, "libmcenv_usermanagementhandler_getactiveusers");
		#else // _WIN32
		pWrapperTable->m_UserManagementHandler_GetActiveUsers = (PLibMCEnvUserManagementHandler_GetActiveUsersPtr) dlsym(hLibrary, "libmcenv_usermanagementhandler_getactiveusers");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserManagementHandler_GetActiveUsers == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetMachineState = (PLibMCEnvStateEnvironment_GetMachineStatePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getmachinestate");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetMachineState = (PLibMCEnvStateEnvironment_GetMachineStatePtr) dlsym(hLibrary, "libmcenv_stateenvironment_getmachinestate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetMachineState == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetPreviousState = (PLibMCEnvStateEnvironment_GetPreviousStatePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getpreviousstate");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetPreviousState = (PLibMCEnvStateEnvironment_GetPreviousStatePtr) dlsym(hLibrary, "libmcenv_stateenvironment_getpreviousstate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetPreviousState == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_PrepareSignal = (PLibMCEnvStateEnvironment_PrepareSignalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_preparesignal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_PrepareSignal = (PLibMCEnvStateEnvironment_PrepareSignalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_preparesignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_PrepareSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_WaitForSignal = (PLibMCEnvStateEnvironment_WaitForSignalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_waitforsignal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_WaitForSignal = (PLibMCEnvStateEnvironment_WaitForSignalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_waitforsignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_WaitForSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetUnhandledSignal = (PLibMCEnvStateEnvironment_GetUnhandledSignalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getunhandledsignal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetUnhandledSignal = (PLibMCEnvStateEnvironment_GetUnhandledSignalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getunhandledsignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetUnhandledSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetUnhandledSignalByUUID = (PLibMCEnvStateEnvironment_GetUnhandledSignalByUUIDPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getunhandledsignalbyuuid");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetUnhandledSignalByUUID = (PLibMCEnvStateEnvironment_GetUnhandledSignalByUUIDPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getunhandledsignalbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetUnhandledSignalByUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetDriverLibrary = (PLibMCEnvStateEnvironment_GetDriverLibraryPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getdriverlibrary");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetDriverLibrary = (PLibMCEnvStateEnvironment_GetDriverLibraryPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getdriverlibrary");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetDriverLibrary == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateDriverAccess = (PLibMCEnvStateEnvironment_CreateDriverAccessPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createdriveraccess");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateDriverAccess = (PLibMCEnvStateEnvironment_CreateDriverAccessPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createdriveraccess");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateDriverAccess == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_HasBuildJob = (PLibMCEnvStateEnvironment_HasBuildJobPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_hasbuildjob");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_HasBuildJob = (PLibMCEnvStateEnvironment_HasBuildJobPtr) dlsym(hLibrary, "libmcenv_stateenvironment_hasbuildjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_HasBuildJob == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetBuildJob = (PLibMCEnvStateEnvironment_GetBuildJobPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getbuildjob");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetBuildJob = (PLibMCEnvStateEnvironment_GetBuildJobPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getbuildjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetBuildJob == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_HasBuildExecution = (PLibMCEnvStateEnvironment_HasBuildExecutionPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_hasbuildexecution");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_HasBuildExecution = (PLibMCEnvStateEnvironment_HasBuildExecutionPtr) dlsym(hLibrary, "libmcenv_stateenvironment_hasbuildexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_HasBuildExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetBuildExecution = (PLibMCEnvStateEnvironment_GetBuildExecutionPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getbuildexecution");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetBuildExecution = (PLibMCEnvStateEnvironment_GetBuildExecutionPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getbuildexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetBuildExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_UnloadAllToolpathes = (PLibMCEnvStateEnvironment_UnloadAllToolpathesPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_unloadalltoolpathes");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_UnloadAllToolpathes = (PLibMCEnvStateEnvironment_UnloadAllToolpathesPtr) dlsym(hLibrary, "libmcenv_stateenvironment_unloadalltoolpathes");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_UnloadAllToolpathes == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetNextState = (PLibMCEnvStateEnvironment_SetNextStatePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setnextstate");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetNextState = (PLibMCEnvStateEnvironment_SetNextStatePtr) dlsym(hLibrary, "libmcenv_stateenvironment_setnextstate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetNextState == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LogMessage = (PLibMCEnvStateEnvironment_LogMessagePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_logmessage");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LogMessage = (PLibMCEnvStateEnvironment_LogMessagePtr) dlsym(hLibrary, "libmcenv_stateenvironment_logmessage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LogMessage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LogWarning = (PLibMCEnvStateEnvironment_LogWarningPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_logwarning");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LogWarning = (PLibMCEnvStateEnvironment_LogWarningPtr) dlsym(hLibrary, "libmcenv_stateenvironment_logwarning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LogWarning == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LogInfo = (PLibMCEnvStateEnvironment_LogInfoPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_loginfo");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LogInfo = (PLibMCEnvStateEnvironment_LogInfoPtr) dlsym(hLibrary, "libmcenv_stateenvironment_loginfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LogInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_Sleep = (PLibMCEnvStateEnvironment_SleepPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_sleep");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_Sleep = (PLibMCEnvStateEnvironment_SleepPtr) dlsym(hLibrary, "libmcenv_stateenvironment_sleep");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_Sleep == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CheckForTermination = (PLibMCEnvStateEnvironment_CheckForTerminationPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_checkfortermination");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CheckForTermination = (PLibMCEnvStateEnvironment_CheckForTerminationPtr) dlsym(hLibrary, "libmcenv_stateenvironment_checkfortermination");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CheckForTermination == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_StoreSignal = (PLibMCEnvStateEnvironment_StoreSignalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_storesignal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_StoreSignal = (PLibMCEnvStateEnvironment_StoreSignalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_storesignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_StoreSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_RetrieveSignal = (PLibMCEnvStateEnvironment_RetrieveSignalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_retrievesignal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_RetrieveSignal = (PLibMCEnvStateEnvironment_RetrieveSignalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_retrievesignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_RetrieveSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_ClearStoredValue = (PLibMCEnvStateEnvironment_ClearStoredValuePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_clearstoredvalue");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_ClearStoredValue = (PLibMCEnvStateEnvironment_ClearStoredValuePtr) dlsym(hLibrary, "libmcenv_stateenvironment_clearstoredvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_ClearStoredValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetStringParameter = (PLibMCEnvStateEnvironment_SetStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setstringparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetStringParameter = (PLibMCEnvStateEnvironment_SetStringParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetUUIDParameter = (PLibMCEnvStateEnvironment_SetUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setuuidparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetUUIDParameter = (PLibMCEnvStateEnvironment_SetUUIDParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetDoubleParameter = (PLibMCEnvStateEnvironment_SetDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetDoubleParameter = (PLibMCEnvStateEnvironment_SetDoubleParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetIntegerParameter = (PLibMCEnvStateEnvironment_SetIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setintegerparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetIntegerParameter = (PLibMCEnvStateEnvironment_SetIntegerParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetBoolParameter = (PLibMCEnvStateEnvironment_SetBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setboolparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetBoolParameter = (PLibMCEnvStateEnvironment_SetBoolParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetStringParameter = (PLibMCEnvStateEnvironment_GetStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getstringparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetStringParameter = (PLibMCEnvStateEnvironment_GetStringParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetUUIDParameter = (PLibMCEnvStateEnvironment_GetUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getuuidparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetUUIDParameter = (PLibMCEnvStateEnvironment_GetUUIDParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetDoubleParameter = (PLibMCEnvStateEnvironment_GetDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetDoubleParameter = (PLibMCEnvStateEnvironment_GetDoubleParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetIntegerParameter = (PLibMCEnvStateEnvironment_GetIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getintegerparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetIntegerParameter = (PLibMCEnvStateEnvironment_GetIntegerParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetBoolParameter = (PLibMCEnvStateEnvironment_GetBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getboolparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetBoolParameter = (PLibMCEnvStateEnvironment_GetBoolParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LoadResourceData = (PLibMCEnvStateEnvironment_LoadResourceDataPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_loadresourcedata");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LoadResourceData = (PLibMCEnvStateEnvironment_LoadResourceDataPtr) dlsym(hLibrary, "libmcenv_stateenvironment_loadresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LoadResourceData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LoadResourceString = (PLibMCEnvStateEnvironment_LoadResourceStringPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_loadresourcestring");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LoadResourceString = (PLibMCEnvStateEnvironment_LoadResourceStringPtr) dlsym(hLibrary, "libmcenv_stateenvironment_loadresourcestring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LoadResourceString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateEmptyImage = (PLibMCEnvStateEnvironment_CreateEmptyImagePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createemptyimage");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateEmptyImage = (PLibMCEnvStateEnvironment_CreateEmptyImagePtr) dlsym(hLibrary, "libmcenv_stateenvironment_createemptyimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateEmptyImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LoadPNGImage = (PLibMCEnvStateEnvironment_LoadPNGImagePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_loadpngimage");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LoadPNGImage = (PLibMCEnvStateEnvironment_LoadPNGImagePtr) dlsym(hLibrary, "libmcenv_stateenvironment_loadpngimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LoadPNGImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateDiscreteField2D = (PLibMCEnvStateEnvironment_CreateDiscreteField2DPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_creatediscretefield2d");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateDiscreteField2D = (PLibMCEnvStateEnvironment_CreateDiscreteField2DPtr) dlsym(hLibrary, "libmcenv_stateenvironment_creatediscretefield2d");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateDiscreteField2D == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateDiscreteField2DFromImage = (PLibMCEnvStateEnvironment_CreateDiscreteField2DFromImagePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_creatediscretefield2dfromimage");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateDiscreteField2DFromImage = (PLibMCEnvStateEnvironment_CreateDiscreteField2DFromImagePtr) dlsym(hLibrary, "libmcenv_stateenvironment_creatediscretefield2dfromimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateDiscreteField2DFromImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetGlobalTimerInMilliseconds = (PLibMCEnvStateEnvironment_GetGlobalTimerInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getglobaltimerinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetGlobalTimerInMilliseconds = (PLibMCEnvStateEnvironment_GetGlobalTimerInMillisecondsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getglobaltimerinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetGlobalTimerInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetGlobalTimerInMicroseconds = (PLibMCEnvStateEnvironment_GetGlobalTimerInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getglobaltimerinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetGlobalTimerInMicroseconds = (PLibMCEnvStateEnvironment_GetGlobalTimerInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getglobaltimerinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetGlobalTimerInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMilliseconds = (PLibMCEnvStateEnvironment_GetStartTimeOfStateInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getstarttimeofstateinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMilliseconds = (PLibMCEnvStateEnvironment_GetStartTimeOfStateInMillisecondsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getstarttimeofstateinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMicroseconds = (PLibMCEnvStateEnvironment_GetStartTimeOfStateInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getstarttimeofstateinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMicroseconds = (PLibMCEnvStateEnvironment_GetStartTimeOfStateInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getstarttimeofstateinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMicroseconds = (PLibMCEnvStateEnvironment_GetEndTimeOfPreviousStateInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getendtimeofpreviousstateinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMicroseconds = (PLibMCEnvStateEnvironment_GetEndTimeOfPreviousStateInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getendtimeofpreviousstateinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMilliseconds = (PLibMCEnvStateEnvironment_GetEndTimeOfPreviousStateInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getendtimeofpreviousstateinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMilliseconds = (PLibMCEnvStateEnvironment_GetEndTimeOfPreviousStateInMillisecondsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getendtimeofpreviousstateinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMilliseconds = (PLibMCEnvStateEnvironment_GetElapsedTimeInStateInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getelapsedtimeinstateinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMilliseconds = (PLibMCEnvStateEnvironment_GetElapsedTimeInStateInMillisecondsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getelapsedtimeinstateinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMicroseconds = (PLibMCEnvStateEnvironment_GetElapsedTimeInStateInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getelapsedtimeinstateinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMicroseconds = (PLibMCEnvStateEnvironment_GetElapsedTimeInStateInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getelapsedtimeinstateinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetCurrentDateTime = (PLibMCEnvStateEnvironment_GetCurrentDateTimePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getcurrentdatetime");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetCurrentDateTime = (PLibMCEnvStateEnvironment_GetCurrentDateTimePtr) dlsym(hLibrary, "libmcenv_stateenvironment_getcurrentdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetCurrentDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetCustomDateTime = (PLibMCEnvStateEnvironment_GetCustomDateTimePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getcustomdatetime");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetCustomDateTime = (PLibMCEnvStateEnvironment_GetCustomDateTimePtr) dlsym(hLibrary, "libmcenv_stateenvironment_getcustomdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetCustomDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetStartDateTime = (PLibMCEnvStateEnvironment_GetStartDateTimePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getstartdatetime");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetStartDateTime = (PLibMCEnvStateEnvironment_GetStartDateTimePtr) dlsym(hLibrary, "libmcenv_stateenvironment_getstartdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetStartDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetTestEnvironment = (PLibMCEnvStateEnvironment_GetTestEnvironmentPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_gettestenvironment");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetTestEnvironment = (PLibMCEnvStateEnvironment_GetTestEnvironmentPtr) dlsym(hLibrary, "libmcenv_stateenvironment_gettestenvironment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetTestEnvironment == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateXMLDocument = (PLibMCEnvStateEnvironment_CreateXMLDocumentPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createxmldocument");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateXMLDocument = (PLibMCEnvStateEnvironment_CreateXMLDocumentPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createxmldocument");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateXMLDocument == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_ParseXMLString = (PLibMCEnvStateEnvironment_ParseXMLStringPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_parsexmlstring");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_ParseXMLString = (PLibMCEnvStateEnvironment_ParseXMLStringPtr) dlsym(hLibrary, "libmcenv_stateenvironment_parsexmlstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_ParseXMLString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_ParseXMLData = (PLibMCEnvStateEnvironment_ParseXMLDataPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_parsexmldata");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_ParseXMLData = (PLibMCEnvStateEnvironment_ParseXMLDataPtr) dlsym(hLibrary, "libmcenv_stateenvironment_parsexmldata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_ParseXMLData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateDataTable = (PLibMCEnvStateEnvironment_CreateDataTablePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createdatatable");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateDataTable = (PLibMCEnvStateEnvironment_CreateDataTablePtr) dlsym(hLibrary, "libmcenv_stateenvironment_createdatatable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateDataTable == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CheckUserPermission = (PLibMCEnvStateEnvironment_CheckUserPermissionPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_checkuserpermission");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CheckUserPermission = (PLibMCEnvStateEnvironment_CheckUserPermissionPtr) dlsym(hLibrary, "libmcenv_stateenvironment_checkuserpermission");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CheckUserPermission == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateUserManagement = (PLibMCEnvStateEnvironment_CreateUserManagementPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createusermanagement");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateUserManagement = (PLibMCEnvStateEnvironment_CreateUserManagementPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createusermanagement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateUserManagement == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetCurrentJournal = (PLibMCEnvStateEnvironment_GetCurrentJournalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getcurrentjournal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetCurrentJournal = (PLibMCEnvStateEnvironment_GetCurrentJournalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getcurrentjournal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetCurrentJournal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateSceneHandler = (PLibMCEnvStateEnvironment_CreateSceneHandlerPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createscenehandler");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateSceneHandler = (PLibMCEnvStateEnvironment_CreateSceneHandlerPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createscenehandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateSceneHandler == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateDataSeries = (PLibMCEnvStateEnvironment_CreateDataSeriesPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createdataseries");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateDataSeries = (PLibMCEnvStateEnvironment_CreateDataSeriesPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createdataseries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateDataSeries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_HasDataSeries = (PLibMCEnvStateEnvironment_HasDataSeriesPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_hasdataseries");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_HasDataSeries = (PLibMCEnvStateEnvironment_HasDataSeriesPtr) dlsym(hLibrary, "libmcenv_stateenvironment_hasdataseries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_HasDataSeries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_FindDataSeries = (PLibMCEnvStateEnvironment_FindDataSeriesPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_finddataseries");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_FindDataSeries = (PLibMCEnvStateEnvironment_FindDataSeriesPtr) dlsym(hLibrary, "libmcenv_stateenvironment_finddataseries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_FindDataSeries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_ReleaseDataSeries = (PLibMCEnvStateEnvironment_ReleaseDataSeriesPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_releasedataseries");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_ReleaseDataSeries = (PLibMCEnvStateEnvironment_ReleaseDataSeriesPtr) dlsym(hLibrary, "libmcenv_stateenvironment_releasedataseries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_ReleaseDataSeries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateAlert = (PLibMCEnvStateEnvironment_CreateAlertPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createalert");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateAlert = (PLibMCEnvStateEnvironment_CreateAlertPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createalert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateAlert == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_FindAlert = (PLibMCEnvStateEnvironment_FindAlertPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_findalert");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_FindAlert = (PLibMCEnvStateEnvironment_FindAlertPtr) dlsym(hLibrary, "libmcenv_stateenvironment_findalert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_FindAlert == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_AlertExists = (PLibMCEnvStateEnvironment_AlertExistsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_alertexists");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_AlertExists = (PLibMCEnvStateEnvironment_AlertExistsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_alertexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_AlertExists == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_RetrieveAlerts = (PLibMCEnvStateEnvironment_RetrieveAlertsPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_retrievealerts");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_RetrieveAlerts = (PLibMCEnvStateEnvironment_RetrieveAlertsPtr) dlsym(hLibrary, "libmcenv_stateenvironment_retrievealerts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_RetrieveAlerts == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_RetrieveAlertsByType = (PLibMCEnvStateEnvironment_RetrieveAlertsByTypePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_retrievealertsbytype");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_RetrieveAlertsByType = (PLibMCEnvStateEnvironment_RetrieveAlertsByTypePtr) dlsym(hLibrary, "libmcenv_stateenvironment_retrievealertsbytype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_RetrieveAlertsByType == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_HasAlertOfType = (PLibMCEnvStateEnvironment_HasAlertOfTypePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_hasalertoftype");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_HasAlertOfType = (PLibMCEnvStateEnvironment_HasAlertOfTypePtr) dlsym(hLibrary, "libmcenv_stateenvironment_hasalertoftype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_HasAlertOfType == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateCryptoContext = (PLibMCEnvStateEnvironment_CreateCryptoContextPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createcryptocontext");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateCryptoContext = (PLibMCEnvStateEnvironment_CreateCryptoContextPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createcryptocontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateCryptoContext == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateTemporaryStream = (PLibMCEnvStateEnvironment_CreateTemporaryStreamPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createtemporarystream");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateTemporaryStream = (PLibMCEnvStateEnvironment_CreateTemporaryStreamPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createtemporarystream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateTemporaryStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateZIPStream = (PLibMCEnvStateEnvironment_CreateZIPStreamPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createzipstream");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateZIPStream = (PLibMCEnvStateEnvironment_CreateZIPStreamPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createzipstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateZIPStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LoadStream = (PLibMCEnvStateEnvironment_LoadStreamPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_loadstream");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LoadStream = (PLibMCEnvStateEnvironment_LoadStreamPtr) dlsym(hLibrary, "libmcenv_stateenvironment_loadstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LoadStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIItem_GetName = (PLibMCEnvUIItem_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_uiitem_getname");
		#else // _WIN32
		pWrapperTable->m_UIItem_GetName = (PLibMCEnvUIItem_GetNamePtr) dlsym(hLibrary, "libmcenv_uiitem_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIItem_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIItem_GetPath = (PLibMCEnvUIItem_GetPathPtr) GetProcAddress(hLibrary, "libmcenv_uiitem_getpath");
		#else // _WIN32
		pWrapperTable->m_UIItem_GetPath = (PLibMCEnvUIItem_GetPathPtr) dlsym(hLibrary, "libmcenv_uiitem_getpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIItem_GetPath == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIItem_GetUUID = (PLibMCEnvUIItem_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_uiitem_getuuid");
		#else // _WIN32
		pWrapperTable->m_UIItem_GetUUID = (PLibMCEnvUIItem_GetUUIDPtr) dlsym(hLibrary, "libmcenv_uiitem_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIItem_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_ActivateModalDialog = (PLibMCEnvUIEnvironment_ActivateModalDialogPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_activatemodaldialog");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_ActivateModalDialog = (PLibMCEnvUIEnvironment_ActivateModalDialogPtr) dlsym(hLibrary, "libmcenv_uienvironment_activatemodaldialog");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_ActivateModalDialog == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CloseModalDialog = (PLibMCEnvUIEnvironment_CloseModalDialogPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_closemodaldialog");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CloseModalDialog = (PLibMCEnvUIEnvironment_CloseModalDialogPtr) dlsym(hLibrary, "libmcenv_uienvironment_closemodaldialog");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CloseModalDialog == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_ActivatePage = (PLibMCEnvUIEnvironment_ActivatePagePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_activatepage");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_ActivatePage = (PLibMCEnvUIEnvironment_ActivatePagePtr) dlsym(hLibrary, "libmcenv_uienvironment_activatepage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_ActivatePage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_LogOut = (PLibMCEnvUIEnvironment_LogOutPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_logout");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_LogOut = (PLibMCEnvUIEnvironment_LogOutPtr) dlsym(hLibrary, "libmcenv_uienvironment_logout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_LogOut == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_ShowHint = (PLibMCEnvUIEnvironment_ShowHintPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_showhint");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_ShowHint = (PLibMCEnvUIEnvironment_ShowHintPtr) dlsym(hLibrary, "libmcenv_uienvironment_showhint");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_ShowHint == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_ShowHintColored = (PLibMCEnvUIEnvironment_ShowHintColoredPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_showhintcolored");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_ShowHintColored = (PLibMCEnvUIEnvironment_ShowHintColoredPtr) dlsym(hLibrary, "libmcenv_uienvironment_showhintcolored");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_ShowHintColored == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_HideHint = (PLibMCEnvUIEnvironment_HideHintPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_hidehint");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_HideHint = (PLibMCEnvUIEnvironment_HideHintPtr) dlsym(hLibrary, "libmcenv_uienvironment_hidehint");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_HideHint == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_StartStreamDownload = (PLibMCEnvUIEnvironment_StartStreamDownloadPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_startstreamdownload");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_StartStreamDownload = (PLibMCEnvUIEnvironment_StartStreamDownloadPtr) dlsym(hLibrary, "libmcenv_uienvironment_startstreamdownload");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_StartStreamDownload == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_ShowMessageDlg = (PLibMCEnvUIEnvironment_ShowMessageDlgPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_showmessagedlg");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_ShowMessageDlg = (PLibMCEnvUIEnvironment_ShowMessageDlgPtr) dlsym(hLibrary, "libmcenv_uienvironment_showmessagedlg");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_ShowMessageDlg == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveEventSender = (PLibMCEnvUIEnvironment_RetrieveEventSenderPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_retrieveeventsender");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveEventSender = (PLibMCEnvUIEnvironment_RetrieveEventSenderPtr) dlsym(hLibrary, "libmcenv_uienvironment_retrieveeventsender");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_RetrieveEventSender == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveEventSenderPage = (PLibMCEnvUIEnvironment_RetrieveEventSenderPagePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_retrieveeventsenderpage");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveEventSenderPage = (PLibMCEnvUIEnvironment_RetrieveEventSenderPagePtr) dlsym(hLibrary, "libmcenv_uienvironment_retrieveeventsenderpage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_RetrieveEventSenderPage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveEventSenderUUID = (PLibMCEnvUIEnvironment_RetrieveEventSenderUUIDPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_retrieveeventsenderuuid");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveEventSenderUUID = (PLibMCEnvUIEnvironment_RetrieveEventSenderUUIDPtr) dlsym(hLibrary, "libmcenv_uienvironment_retrieveeventsenderuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_RetrieveEventSenderUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_PrepareSignal = (PLibMCEnvUIEnvironment_PrepareSignalPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_preparesignal");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_PrepareSignal = (PLibMCEnvUIEnvironment_PrepareSignalPtr) dlsym(hLibrary, "libmcenv_uienvironment_preparesignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_PrepareSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineState = (PLibMCEnvUIEnvironment_GetMachineStatePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getmachinestate");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineState = (PLibMCEnvUIEnvironment_GetMachineStatePtr) dlsym(hLibrary, "libmcenv_uienvironment_getmachinestate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetMachineState == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_LogMessage = (PLibMCEnvUIEnvironment_LogMessagePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_logmessage");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_LogMessage = (PLibMCEnvUIEnvironment_LogMessagePtr) dlsym(hLibrary, "libmcenv_uienvironment_logmessage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_LogMessage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_LogWarning = (PLibMCEnvUIEnvironment_LogWarningPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_logwarning");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_LogWarning = (PLibMCEnvUIEnvironment_LogWarningPtr) dlsym(hLibrary, "libmcenv_uienvironment_logwarning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_LogWarning == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_LogInfo = (PLibMCEnvUIEnvironment_LogInfoPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_loginfo");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_LogInfo = (PLibMCEnvUIEnvironment_LogInfoPtr) dlsym(hLibrary, "libmcenv_uienvironment_loginfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_LogInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameter = (PLibMCEnvUIEnvironment_GetMachineParameterPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getmachineparameter");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameter = (PLibMCEnvUIEnvironment_GetMachineParameterPtr) dlsym(hLibrary, "libmcenv_uienvironment_getmachineparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetMachineParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsUUID = (PLibMCEnvUIEnvironment_GetMachineParameterAsUUIDPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getmachineparameterasuuid");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsUUID = (PLibMCEnvUIEnvironment_GetMachineParameterAsUUIDPtr) dlsym(hLibrary, "libmcenv_uienvironment_getmachineparameterasuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetMachineParameterAsUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsDouble = (PLibMCEnvUIEnvironment_GetMachineParameterAsDoublePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getmachineparameterasdouble");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsDouble = (PLibMCEnvUIEnvironment_GetMachineParameterAsDoublePtr) dlsym(hLibrary, "libmcenv_uienvironment_getmachineparameterasdouble");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetMachineParameterAsDouble == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsInteger = (PLibMCEnvUIEnvironment_GetMachineParameterAsIntegerPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getmachineparameterasinteger");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsInteger = (PLibMCEnvUIEnvironment_GetMachineParameterAsIntegerPtr) dlsym(hLibrary, "libmcenv_uienvironment_getmachineparameterasinteger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetMachineParameterAsInteger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsBool = (PLibMCEnvUIEnvironment_GetMachineParameterAsBoolPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getmachineparameterasbool");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineParameterAsBool = (PLibMCEnvUIEnvironment_GetMachineParameterAsBoolPtr) dlsym(hLibrary, "libmcenv_uienvironment_getmachineparameterasbool");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetMachineParameterAsBool == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetUIProperty = (PLibMCEnvUIEnvironment_GetUIPropertyPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getuiproperty");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetUIProperty = (PLibMCEnvUIEnvironment_GetUIPropertyPtr) dlsym(hLibrary, "libmcenv_uienvironment_getuiproperty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetUIProperty == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsUUID = (PLibMCEnvUIEnvironment_GetUIPropertyAsUUIDPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getuipropertyasuuid");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsUUID = (PLibMCEnvUIEnvironment_GetUIPropertyAsUUIDPtr) dlsym(hLibrary, "libmcenv_uienvironment_getuipropertyasuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetUIPropertyAsUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsDouble = (PLibMCEnvUIEnvironment_GetUIPropertyAsDoublePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getuipropertyasdouble");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsDouble = (PLibMCEnvUIEnvironment_GetUIPropertyAsDoublePtr) dlsym(hLibrary, "libmcenv_uienvironment_getuipropertyasdouble");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetUIPropertyAsDouble == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsInteger = (PLibMCEnvUIEnvironment_GetUIPropertyAsIntegerPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getuipropertyasinteger");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsInteger = (PLibMCEnvUIEnvironment_GetUIPropertyAsIntegerPtr) dlsym(hLibrary, "libmcenv_uienvironment_getuipropertyasinteger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetUIPropertyAsInteger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsBool = (PLibMCEnvUIEnvironment_GetUIPropertyAsBoolPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getuipropertyasbool");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetUIPropertyAsBool = (PLibMCEnvUIEnvironment_GetUIPropertyAsBoolPtr) dlsym(hLibrary, "libmcenv_uienvironment_getuipropertyasbool");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetUIPropertyAsBool == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_SetUIProperty = (PLibMCEnvUIEnvironment_SetUIPropertyPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_setuiproperty");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_SetUIProperty = (PLibMCEnvUIEnvironment_SetUIPropertyPtr) dlsym(hLibrary, "libmcenv_uienvironment_setuiproperty");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_SetUIProperty == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsUUID = (PLibMCEnvUIEnvironment_SetUIPropertyAsUUIDPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_setuipropertyasuuid");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsUUID = (PLibMCEnvUIEnvironment_SetUIPropertyAsUUIDPtr) dlsym(hLibrary, "libmcenv_uienvironment_setuipropertyasuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_SetUIPropertyAsUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsDouble = (PLibMCEnvUIEnvironment_SetUIPropertyAsDoublePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_setuipropertyasdouble");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsDouble = (PLibMCEnvUIEnvironment_SetUIPropertyAsDoublePtr) dlsym(hLibrary, "libmcenv_uienvironment_setuipropertyasdouble");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_SetUIPropertyAsDouble == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsInteger = (PLibMCEnvUIEnvironment_SetUIPropertyAsIntegerPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_setuipropertyasinteger");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsInteger = (PLibMCEnvUIEnvironment_SetUIPropertyAsIntegerPtr) dlsym(hLibrary, "libmcenv_uienvironment_setuipropertyasinteger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_SetUIPropertyAsInteger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsBool = (PLibMCEnvUIEnvironment_SetUIPropertyAsBoolPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_setuipropertyasbool");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_SetUIPropertyAsBool = (PLibMCEnvUIEnvironment_SetUIPropertyAsBoolPtr) dlsym(hLibrary, "libmcenv_uienvironment_setuipropertyasbool");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_SetUIPropertyAsBool == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateEmptyImage = (PLibMCEnvUIEnvironment_CreateEmptyImagePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createemptyimage");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateEmptyImage = (PLibMCEnvUIEnvironment_CreateEmptyImagePtr) dlsym(hLibrary, "libmcenv_uienvironment_createemptyimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateEmptyImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_LoadPNGImage = (PLibMCEnvUIEnvironment_LoadPNGImagePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_loadpngimage");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_LoadPNGImage = (PLibMCEnvUIEnvironment_LoadPNGImagePtr) dlsym(hLibrary, "libmcenv_uienvironment_loadpngimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_LoadPNGImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetGlobalTimerInMilliseconds = (PLibMCEnvUIEnvironment_GetGlobalTimerInMillisecondsPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getglobaltimerinmilliseconds");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetGlobalTimerInMilliseconds = (PLibMCEnvUIEnvironment_GetGlobalTimerInMillisecondsPtr) dlsym(hLibrary, "libmcenv_uienvironment_getglobaltimerinmilliseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetGlobalTimerInMilliseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetGlobalTimerInMicroseconds = (PLibMCEnvUIEnvironment_GetGlobalTimerInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getglobaltimerinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetGlobalTimerInMicroseconds = (PLibMCEnvUIEnvironment_GetGlobalTimerInMicrosecondsPtr) dlsym(hLibrary, "libmcenv_uienvironment_getglobaltimerinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetGlobalTimerInMicroseconds == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetTestEnvironment = (PLibMCEnvUIEnvironment_GetTestEnvironmentPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_gettestenvironment");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetTestEnvironment = (PLibMCEnvUIEnvironment_GetTestEnvironmentPtr) dlsym(hLibrary, "libmcenv_uienvironment_gettestenvironment");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetTestEnvironment == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateXMLDocument = (PLibMCEnvUIEnvironment_CreateXMLDocumentPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createxmldocument");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateXMLDocument = (PLibMCEnvUIEnvironment_CreateXMLDocumentPtr) dlsym(hLibrary, "libmcenv_uienvironment_createxmldocument");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateXMLDocument == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_ParseXMLString = (PLibMCEnvUIEnvironment_ParseXMLStringPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_parsexmlstring");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_ParseXMLString = (PLibMCEnvUIEnvironment_ParseXMLStringPtr) dlsym(hLibrary, "libmcenv_uienvironment_parsexmlstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_ParseXMLString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_ParseXMLData = (PLibMCEnvUIEnvironment_ParseXMLDataPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_parsexmldata");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_ParseXMLData = (PLibMCEnvUIEnvironment_ParseXMLDataPtr) dlsym(hLibrary, "libmcenv_uienvironment_parsexmldata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_ParseXMLData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateDataTable = (PLibMCEnvUIEnvironment_CreateDataTablePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createdatatable");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateDataTable = (PLibMCEnvUIEnvironment_CreateDataTablePtr) dlsym(hLibrary, "libmcenv_uienvironment_createdatatable");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateDataTable == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_HasBuildJob = (PLibMCEnvUIEnvironment_HasBuildJobPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_hasbuildjob");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_HasBuildJob = (PLibMCEnvUIEnvironment_HasBuildJobPtr) dlsym(hLibrary, "libmcenv_uienvironment_hasbuildjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_HasBuildJob == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetBuildJob = (PLibMCEnvUIEnvironment_GetBuildJobPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getbuildjob");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetBuildJob = (PLibMCEnvUIEnvironment_GetBuildJobPtr) dlsym(hLibrary, "libmcenv_uienvironment_getbuildjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetBuildJob == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_HasBuildExecution = (PLibMCEnvUIEnvironment_HasBuildExecutionPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_hasbuildexecution");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_HasBuildExecution = (PLibMCEnvUIEnvironment_HasBuildExecutionPtr) dlsym(hLibrary, "libmcenv_uienvironment_hasbuildexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_HasBuildExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetBuildExecution = (PLibMCEnvUIEnvironment_GetBuildExecutionPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getbuildexecution");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetBuildExecution = (PLibMCEnvUIEnvironment_GetBuildExecutionPtr) dlsym(hLibrary, "libmcenv_uienvironment_getbuildexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetBuildExecution == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateDiscreteField2D = (PLibMCEnvUIEnvironment_CreateDiscreteField2DPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_creatediscretefield2d");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateDiscreteField2D = (PLibMCEnvUIEnvironment_CreateDiscreteField2DPtr) dlsym(hLibrary, "libmcenv_uienvironment_creatediscretefield2d");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateDiscreteField2D == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateDiscreteField2DFromImage = (PLibMCEnvUIEnvironment_CreateDiscreteField2DFromImagePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_creatediscretefield2dfromimage");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateDiscreteField2DFromImage = (PLibMCEnvUIEnvironment_CreateDiscreteField2DFromImagePtr) dlsym(hLibrary, "libmcenv_uienvironment_creatediscretefield2dfromimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateDiscreteField2DFromImage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CheckPermission = (PLibMCEnvUIEnvironment_CheckPermissionPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_checkpermission");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CheckPermission = (PLibMCEnvUIEnvironment_CheckPermissionPtr) dlsym(hLibrary, "libmcenv_uienvironment_checkpermission");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CheckPermission == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserLogin = (PLibMCEnvUIEnvironment_GetCurrentUserLoginPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getcurrentuserlogin");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserLogin = (PLibMCEnvUIEnvironment_GetCurrentUserLoginPtr) dlsym(hLibrary, "libmcenv_uienvironment_getcurrentuserlogin");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetCurrentUserLogin == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserDescription = (PLibMCEnvUIEnvironment_GetCurrentUserDescriptionPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getcurrentuserdescription");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserDescription = (PLibMCEnvUIEnvironment_GetCurrentUserDescriptionPtr) dlsym(hLibrary, "libmcenv_uienvironment_getcurrentuserdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetCurrentUserDescription == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserRole = (PLibMCEnvUIEnvironment_GetCurrentUserRolePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getcurrentuserrole");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserRole = (PLibMCEnvUIEnvironment_GetCurrentUserRolePtr) dlsym(hLibrary, "libmcenv_uienvironment_getcurrentuserrole");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetCurrentUserRole == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserLanguage = (PLibMCEnvUIEnvironment_GetCurrentUserLanguagePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getcurrentuserlanguage");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserLanguage = (PLibMCEnvUIEnvironment_GetCurrentUserLanguagePtr) dlsym(hLibrary, "libmcenv_uienvironment_getcurrentuserlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetCurrentUserLanguage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserUUID = (PLibMCEnvUIEnvironment_GetCurrentUserUUIDPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getcurrentuseruuid");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentUserUUID = (PLibMCEnvUIEnvironment_GetCurrentUserUUIDPtr) dlsym(hLibrary, "libmcenv_uienvironment_getcurrentuseruuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetCurrentUserUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateUserManagement = (PLibMCEnvUIEnvironment_CreateUserManagementPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createusermanagement");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateUserManagement = (PLibMCEnvUIEnvironment_CreateUserManagementPtr) dlsym(hLibrary, "libmcenv_uienvironment_createusermanagement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateUserManagement == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentJournal = (PLibMCEnvUIEnvironment_GetCurrentJournalPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getcurrentjournal");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentJournal = (PLibMCEnvUIEnvironment_GetCurrentJournalPtr) dlsym(hLibrary, "libmcenv_uienvironment_getcurrentjournal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetCurrentJournal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateSceneHandler = (PLibMCEnvUIEnvironment_CreateSceneHandlerPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createscenehandler");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateSceneHandler = (PLibMCEnvUIEnvironment_CreateSceneHandlerPtr) dlsym(hLibrary, "libmcenv_uienvironment_createscenehandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateSceneHandler == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateDataSeries = (PLibMCEnvUIEnvironment_CreateDataSeriesPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createdataseries");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateDataSeries = (PLibMCEnvUIEnvironment_CreateDataSeriesPtr) dlsym(hLibrary, "libmcenv_uienvironment_createdataseries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateDataSeries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_HasDataSeries = (PLibMCEnvUIEnvironment_HasDataSeriesPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_hasdataseries");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_HasDataSeries = (PLibMCEnvUIEnvironment_HasDataSeriesPtr) dlsym(hLibrary, "libmcenv_uienvironment_hasdataseries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_HasDataSeries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_FindDataSeries = (PLibMCEnvUIEnvironment_FindDataSeriesPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_finddataseries");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_FindDataSeries = (PLibMCEnvUIEnvironment_FindDataSeriesPtr) dlsym(hLibrary, "libmcenv_uienvironment_finddataseries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_FindDataSeries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_ReleaseDataSeries = (PLibMCEnvUIEnvironment_ReleaseDataSeriesPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_releasedataseries");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_ReleaseDataSeries = (PLibMCEnvUIEnvironment_ReleaseDataSeriesPtr) dlsym(hLibrary, "libmcenv_uienvironment_releasedataseries");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_ReleaseDataSeries == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateAlert = (PLibMCEnvUIEnvironment_CreateAlertPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createalert");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateAlert = (PLibMCEnvUIEnvironment_CreateAlertPtr) dlsym(hLibrary, "libmcenv_uienvironment_createalert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateAlert == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_FindAlert = (PLibMCEnvUIEnvironment_FindAlertPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_findalert");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_FindAlert = (PLibMCEnvUIEnvironment_FindAlertPtr) dlsym(hLibrary, "libmcenv_uienvironment_findalert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_FindAlert == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_AlertExists = (PLibMCEnvUIEnvironment_AlertExistsPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_alertexists");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_AlertExists = (PLibMCEnvUIEnvironment_AlertExistsPtr) dlsym(hLibrary, "libmcenv_uienvironment_alertexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_AlertExists == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveAlerts = (PLibMCEnvUIEnvironment_RetrieveAlertsPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_retrievealerts");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveAlerts = (PLibMCEnvUIEnvironment_RetrieveAlertsPtr) dlsym(hLibrary, "libmcenv_uienvironment_retrievealerts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_RetrieveAlerts == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveAlertsByType = (PLibMCEnvUIEnvironment_RetrieveAlertsByTypePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_retrievealertsbytype");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_RetrieveAlertsByType = (PLibMCEnvUIEnvironment_RetrieveAlertsByTypePtr) dlsym(hLibrary, "libmcenv_uienvironment_retrievealertsbytype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_RetrieveAlertsByType == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_HasAlertOfType = (PLibMCEnvUIEnvironment_HasAlertOfTypePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_hasalertoftype");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_HasAlertOfType = (PLibMCEnvUIEnvironment_HasAlertOfTypePtr) dlsym(hLibrary, "libmcenv_uienvironment_hasalertoftype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_HasAlertOfType == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateCryptoContext = (PLibMCEnvUIEnvironment_CreateCryptoContextPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createcryptocontext");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateCryptoContext = (PLibMCEnvUIEnvironment_CreateCryptoContextPtr) dlsym(hLibrary, "libmcenv_uienvironment_createcryptocontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateCryptoContext == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateTemporaryStream = (PLibMCEnvUIEnvironment_CreateTemporaryStreamPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createtemporarystream");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateTemporaryStream = (PLibMCEnvUIEnvironment_CreateTemporaryStreamPtr) dlsym(hLibrary, "libmcenv_uienvironment_createtemporarystream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateTemporaryStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_CreateZIPStream = (PLibMCEnvUIEnvironment_CreateZIPStreamPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_createzipstream");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_CreateZIPStream = (PLibMCEnvUIEnvironment_CreateZIPStreamPtr) dlsym(hLibrary, "libmcenv_uienvironment_createzipstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_CreateZIPStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_LoadStream = (PLibMCEnvUIEnvironment_LoadStreamPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_loadstream");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_LoadStream = (PLibMCEnvUIEnvironment_LoadStreamPtr) dlsym(hLibrary, "libmcenv_uienvironment_loadstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_LoadStream == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentDateTime = (PLibMCEnvUIEnvironment_GetCurrentDateTimePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getcurrentdatetime");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetCurrentDateTime = (PLibMCEnvUIEnvironment_GetCurrentDateTimePtr) dlsym(hLibrary, "libmcenv_uienvironment_getcurrentdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetCurrentDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetCustomDateTime = (PLibMCEnvUIEnvironment_GetCustomDateTimePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getcustomdatetime");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetCustomDateTime = (PLibMCEnvUIEnvironment_GetCustomDateTimePtr) dlsym(hLibrary, "libmcenv_uienvironment_getcustomdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetCustomDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetStartDateTime = (PLibMCEnvUIEnvironment_GetStartDateTimePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getstartdatetime");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetStartDateTime = (PLibMCEnvUIEnvironment_GetStartDateTimePtr) dlsym(hLibrary, "libmcenv_uienvironment_getstartdatetime");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetStartDateTime == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_Sleep = (PLibMCEnvUIEnvironment_SleepPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_sleep");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_Sleep = (PLibMCEnvUIEnvironment_SleepPtr) dlsym(hLibrary, "libmcenv_uienvironment_sleep");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_Sleep == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCEnvGetVersionPtr) GetProcAddress(hLibrary, "libmcenv_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCEnvGetVersionPtr) dlsym(hLibrary, "libmcenv_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCEnvGetLastErrorPtr) GetProcAddress(hLibrary, "libmcenv_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCEnvGetLastErrorPtr) dlsym(hLibrary, "libmcenv_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCEnvReleaseInstancePtr) GetProcAddress(hLibrary, "libmcenv_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCEnvReleaseInstancePtr) dlsym(hLibrary, "libmcenv_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCEnvAcquireInstancePtr) GetProcAddress(hLibrary, "libmcenv_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCEnvAcquireInstancePtr) dlsym(hLibrary, "libmcenv_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCEnvGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcenv_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCEnvGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcenv_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCENV_SUCCESS;
	}

	inline LibMCEnvResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCEnvDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		
		typedef LibMCEnvResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCEnvResult eLookupError = LIBMCENV_SUCCESS;
		eLookupError = (*pLookup)("libmcenv_iterator_movenext", (void**)&(pWrapperTable->m_Iterator_MoveNext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MoveNext == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_iterator_moveprevious", (void**)&(pWrapperTable->m_Iterator_MovePrevious));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MovePrevious == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_iterator_getcurrent", (void**)&(pWrapperTable->m_Iterator_GetCurrent));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_GetCurrent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_iterator_clone", (void**)&(pWrapperTable->m_Iterator_Clone));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Clone == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_iterator_count", (void**)&(pWrapperTable->m_Iterator_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Count == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_testenvironment_writetestoutput", (void**)&(pWrapperTable->m_TestEnvironment_WriteTestOutput));
		if ( (eLookupError != 0) || (pWrapperTable->m_TestEnvironment_WriteTestOutput == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_cryptocontext_calculatesha256fromstring", (void**)&(pWrapperTable->m_CryptoContext_CalculateSHA256FromString));
		if ( (eLookupError != 0) || (pWrapperTable->m_CryptoContext_CalculateSHA256FromString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_cryptocontext_calculatesha256frombytes", (void**)&(pWrapperTable->m_CryptoContext_CalculateSHA256FromBytes));
		if ( (eLookupError != 0) || (pWrapperTable->m_CryptoContext_CalculateSHA256FromBytes == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_cryptocontext_normalizesha256string", (void**)&(pWrapperTable->m_CryptoContext_NormalizeSHA256String));
		if ( (eLookupError != 0) || (pWrapperTable->m_CryptoContext_NormalizeSHA256String == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_cryptocontext_createrandomsha256hash", (void**)&(pWrapperTable->m_CryptoContext_CreateRandomSHA256Hash));
		if ( (eLookupError != 0) || (pWrapperTable->m_CryptoContext_CreateRandomSHA256Hash == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_cryptocontext_createuuid", (void**)&(pWrapperTable->m_CryptoContext_CreateUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_CryptoContext_CreateUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_cryptocontext_normalizeuuidstring", (void**)&(pWrapperTable->m_CryptoContext_NormalizeUUIDString));
		if ( (eLookupError != 0) || (pWrapperTable->m_CryptoContext_NormalizeUUIDString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_pngimagestoreoptions_resettodefaults", (void**)&(pWrapperTable->m_PNGImageStoreOptions_ResetToDefaults));
		if ( (eLookupError != 0) || (pWrapperTable->m_PNGImageStoreOptions_ResetToDefaults == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_pngimagedata_getsizeinpixels", (void**)&(pWrapperTable->m_PNGImageData_GetSizeInPixels));
		if ( (eLookupError != 0) || (pWrapperTable->m_PNGImageData_GetSizeInPixels == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_pngimagedata_getpngdatastream", (void**)&(pWrapperTable->m_PNGImageData_GetPNGDataStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_PNGImageData_GetPNGDataStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_getpixelformat", (void**)&(pWrapperTable->m_ImageData_GetPixelFormat));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_GetPixelFormat == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_changepixelformat", (void**)&(pWrapperTable->m_ImageData_ChangePixelFormat));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_ChangePixelFormat == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_getdpi", (void**)&(pWrapperTable->m_ImageData_GetDPI));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_GetDPI == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_setdpi", (void**)&(pWrapperTable->m_ImageData_SetDPI));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_SetDPI == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_getsizeinmm", (void**)&(pWrapperTable->m_ImageData_GetSizeInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_GetSizeInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_getsizeinpixels", (void**)&(pWrapperTable->m_ImageData_GetSizeInPixels));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_GetSizeInPixels == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_resizeimage", (void**)&(pWrapperTable->m_ImageData_ResizeImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_ResizeImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_createpngimage", (void**)&(pWrapperTable->m_ImageData_CreatePNGImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_CreatePNGImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_encodepng", (void**)&(pWrapperTable->m_ImageData_EncodePNG));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_EncodePNG == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_getencodedpngdata", (void**)&(pWrapperTable->m_ImageData_GetEncodedPNGData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_GetEncodedPNGData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_clearencodedpngdata", (void**)&(pWrapperTable->m_ImageData_ClearEncodedPNGData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_ClearEncodedPNGData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_clear", (void**)&(pWrapperTable->m_ImageData_Clear));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_Clear == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_getpixel", (void**)&(pWrapperTable->m_ImageData_GetPixel));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_GetPixel == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_setpixel", (void**)&(pWrapperTable->m_ImageData_SetPixel));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_SetPixel == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_getpixelrange", (void**)&(pWrapperTable->m_ImageData_GetPixelRange));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_GetPixelRange == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_imagedata_setpixelrange", (void**)&(pWrapperTable->m_ImageData_SetPixelRange));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageData_SetPixelRange == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2dstoreoptions_resettodefaults", (void**)&(pWrapperTable->m_DiscreteFieldData2DStoreOptions_ResetToDefaults));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2DStoreOptions_ResetToDefaults == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_getdpi", (void**)&(pWrapperTable->m_DiscreteFieldData2D_GetDPI));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_GetDPI == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_setdpi", (void**)&(pWrapperTable->m_DiscreteFieldData2D_SetDPI));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_SetDPI == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_getorigininmm", (void**)&(pWrapperTable->m_DiscreteFieldData2D_GetOriginInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_GetOriginInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_setorigininmm", (void**)&(pWrapperTable->m_DiscreteFieldData2D_SetOriginInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_SetOriginInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_getsizeinmm", (void**)&(pWrapperTable->m_DiscreteFieldData2D_GetSizeInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_GetSizeInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_getsizeinpixels", (void**)&(pWrapperTable->m_DiscreteFieldData2D_GetSizeInPixels));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_GetSizeInPixels == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_resizefield", (void**)&(pWrapperTable->m_DiscreteFieldData2D_ResizeField));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_ResizeField == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_clear", (void**)&(pWrapperTable->m_DiscreteFieldData2D_Clear));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_Clear == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_clamp", (void**)&(pWrapperTable->m_DiscreteFieldData2D_Clamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_Clamp == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_getpixel", (void**)&(pWrapperTable->m_DiscreteFieldData2D_GetPixel));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_GetPixel == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_setpixel", (void**)&(pWrapperTable->m_DiscreteFieldData2D_SetPixel));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_SetPixel == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_getpixelrange", (void**)&(pWrapperTable->m_DiscreteFieldData2D_GetPixelRange));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_GetPixelRange == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_setpixelrange", (void**)&(pWrapperTable->m_DiscreteFieldData2D_SetPixelRange));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_SetPixelRange == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_renderaveragepointvalues", (void**)&(pWrapperTable->m_DiscreteFieldData2D_RenderAveragePointValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_RenderAveragePointValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_scalefielddown", (void**)&(pWrapperTable->m_DiscreteFieldData2D_ScaleFieldDown));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_ScaleFieldDown == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_scalefieldup", (void**)&(pWrapperTable->m_DiscreteFieldData2D_ScaleFieldUp));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_ScaleFieldUp == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_discretize", (void**)&(pWrapperTable->m_DiscreteFieldData2D_Discretize));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_Discretize == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_discretizewithmapping", (void**)&(pWrapperTable->m_DiscreteFieldData2D_DiscretizeWithMapping));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_DiscretizeWithMapping == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_rendertoimageraw", (void**)&(pWrapperTable->m_DiscreteFieldData2D_RenderToImageRaw));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_RenderToImageRaw == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_transformfield", (void**)&(pWrapperTable->m_DiscreteFieldData2D_TransformField));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_TransformField == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_addfield", (void**)&(pWrapperTable->m_DiscreteFieldData2D_AddField));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_AddField == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_discretefielddata2d_duplicate", (void**)&(pWrapperTable->m_DiscreteFieldData2D_Duplicate));
		if ( (eLookupError != 0) || (pWrapperTable->m_DiscreteFieldData2D_Duplicate == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatablecsvwriteoptions_getseparator", (void**)&(pWrapperTable->m_DataTableCSVWriteOptions_GetSeparator));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTableCSVWriteOptions_GetSeparator == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatablecsvwriteoptions_setseparator", (void**)&(pWrapperTable->m_DataTableCSVWriteOptions_SetSeparator));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTableCSVWriteOptions_SetSeparator == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_addcolumn", (void**)&(pWrapperTable->m_DataTable_AddColumn));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_AddColumn == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_removecolumn", (void**)&(pWrapperTable->m_DataTable_RemoveColumn));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_RemoveColumn == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_clear", (void**)&(pWrapperTable->m_DataTable_Clear));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_Clear == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_hascolumn", (void**)&(pWrapperTable->m_DataTable_HasColumn));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_HasColumn == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getrowcount", (void**)&(pWrapperTable->m_DataTable_GetRowCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetRowCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getcolumncount", (void**)&(pWrapperTable->m_DataTable_GetColumnCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetColumnCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getcolumnidentifier", (void**)&(pWrapperTable->m_DataTable_GetColumnIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetColumnIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getcolumndescription", (void**)&(pWrapperTable->m_DataTable_GetColumnDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetColumnDescription == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getcolumntype", (void**)&(pWrapperTable->m_DataTable_GetColumnType));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetColumnType == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getcolumninformation", (void**)&(pWrapperTable->m_DataTable_GetColumnInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetColumnInformation == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getdoublecolumnvalues", (void**)&(pWrapperTable->m_DataTable_GetDoubleColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetDoubleColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getint32columnvalues", (void**)&(pWrapperTable->m_DataTable_GetInt32ColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetInt32ColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getint64columnvalues", (void**)&(pWrapperTable->m_DataTable_GetInt64ColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetInt64ColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getuint32columnvalues", (void**)&(pWrapperTable->m_DataTable_GetUint32ColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetUint32ColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_getuint64columnvalues", (void**)&(pWrapperTable->m_DataTable_GetUint64ColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_GetUint64ColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_setdoublecolumnvalues", (void**)&(pWrapperTable->m_DataTable_SetDoubleColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_SetDoubleColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_setint32columnvalues", (void**)&(pWrapperTable->m_DataTable_SetInt32ColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_SetInt32ColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_setint64columnvalues", (void**)&(pWrapperTable->m_DataTable_SetInt64ColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_SetInt64ColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_setuint32columnvalues", (void**)&(pWrapperTable->m_DataTable_SetUint32ColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_SetUint32ColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_setuint64columnvalues", (void**)&(pWrapperTable->m_DataTable_SetUint64ColumnValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_SetUint64ColumnValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_createwriteoptions", (void**)&(pWrapperTable->m_DataTable_CreateWriteOptions));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_CreateWriteOptions == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_createcsvwriteoptions", (void**)&(pWrapperTable->m_DataTable_CreateCSVWriteOptions));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_CreateCSVWriteOptions == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_writecsvtostream", (void**)&(pWrapperTable->m_DataTable_WriteCSVToStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_WriteCSVToStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_writedatatostream", (void**)&(pWrapperTable->m_DataTable_WriteDataToStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_WriteDataToStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datatable_loadfromstream", (void**)&(pWrapperTable->m_DataTable_LoadFromStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataTable_LoadFromStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_getname", (void**)&(pWrapperTable->m_DataSeries_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_getuuid", (void**)&(pWrapperTable->m_DataSeries_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_clear", (void**)&(pWrapperTable->m_DataSeries_Clear));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_Clear == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_isempty", (void**)&(pWrapperTable->m_DataSeries_IsEmpty));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_IsEmpty == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_getminimum", (void**)&(pWrapperTable->m_DataSeries_GetMinimum));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_GetMinimum == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_getmaximum", (void**)&(pWrapperTable->m_DataSeries_GetMaximum));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_GetMaximum == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_getallentries", (void**)&(pWrapperTable->m_DataSeries_GetAllEntries));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_GetAllEntries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_setallentries", (void**)&(pWrapperTable->m_DataSeries_SetAllEntries));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_SetAllEntries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_samplejournalvariable", (void**)&(pWrapperTable->m_DataSeries_SampleJournalVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_SampleJournalVariable == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_getversion", (void**)&(pWrapperTable->m_DataSeries_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_GetVersion == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_dataseries_increaseversion", (void**)&(pWrapperTable->m_DataSeries_IncreaseVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataSeries_IncreaseVersion == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_tomicroseconds", (void**)&(pWrapperTable->m_DateTimeDifference_ToMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_ToMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_tomilliseconds", (void**)&(pWrapperTable->m_DateTimeDifference_ToMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_ToMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_toseconds", (void**)&(pWrapperTable->m_DateTimeDifference_ToSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_ToSeconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_tominutes", (void**)&(pWrapperTable->m_DateTimeDifference_ToMinutes));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_ToMinutes == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_tohours", (void**)&(pWrapperTable->m_DateTimeDifference_ToHours));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_ToHours == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_todays", (void**)&(pWrapperTable->m_DateTimeDifference_ToDays));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_ToDays == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounddowntoday", (void**)&(pWrapperTable->m_DateTimeDifference_RoundDownToDay));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundDownToDay == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounddowntohour", (void**)&(pWrapperTable->m_DateTimeDifference_RoundDownToHour));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundDownToHour == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounddowntominute", (void**)&(pWrapperTable->m_DateTimeDifference_RoundDownToMinute));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundDownToMinute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounddowntoseconds", (void**)&(pWrapperTable->m_DateTimeDifference_RoundDownToSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundDownToSeconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounddowntomilliseconds", (void**)&(pWrapperTable->m_DateTimeDifference_RoundDownToMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundDownToMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounduptoday", (void**)&(pWrapperTable->m_DateTimeDifference_RoundUpToDay));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundUpToDay == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounduptohour", (void**)&(pWrapperTable->m_DateTimeDifference_RoundUpToHour));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundUpToHour == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounduptominute", (void**)&(pWrapperTable->m_DateTimeDifference_RoundUpToMinute));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundUpToMinute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounduptoseconds", (void**)&(pWrapperTable->m_DateTimeDifference_RoundUpToSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundUpToSeconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetimedifference_rounduptomilliseconds", (void**)&(pWrapperTable->m_DateTimeDifference_RoundupToMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTimeDifference_RoundupToMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_tomicrosecondssince1970", (void**)&(pWrapperTable->m_DateTime_ToMicrosecondsSince1970));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ToMicrosecondsSince1970 == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_tounixtimestamp", (void**)&(pWrapperTable->m_DateTime_ToUnixTimestamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ToUnixTimestamp == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_toutcdatetime", (void**)&(pWrapperTable->m_DateTime_ToUTCDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ToUTCDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_toutcdatetimeinmilliseconds", (void**)&(pWrapperTable->m_DateTime_ToUTCDateTimeInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ToUTCDateTimeInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_toutcdatetimeinmicroseconds", (void**)&(pWrapperTable->m_DateTime_ToUTCDateTimeInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ToUTCDateTimeInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_getdate", (void**)&(pWrapperTable->m_DateTime_GetDate));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_GetDate == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_gettime", (void**)&(pWrapperTable->m_DateTime_GetTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_GetTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_duplicate", (void**)&(pWrapperTable->m_DateTime_Duplicate));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_Duplicate == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_isleapyear", (void**)&(pWrapperTable->m_DateTime_IsLeapYear));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_IsLeapYear == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_islaterthan", (void**)&(pWrapperTable->m_DateTime_IsLaterThan));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_IsLaterThan == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_isearlierthan", (void**)&(pWrapperTable->m_DateTime_IsEarlierThan));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_IsEarlierThan == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_isequalto", (void**)&(pWrapperTable->m_DateTime_IsEqualTo));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_IsEqualTo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_gettimedifference", (void**)&(pWrapperTable->m_DateTime_GetTimeDifference));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_GetTimeDifference == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_addduration", (void**)&(pWrapperTable->m_DateTime_AddDuration));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_AddDuration == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_subtractduration", (void**)&(pWrapperTable->m_DateTime_SubtractDuration));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_SubtractDuration == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_shiftbyyears", (void**)&(pWrapperTable->m_DateTime_ShiftByYears));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ShiftByYears == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_shiftbydays", (void**)&(pWrapperTable->m_DateTime_ShiftByDays));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ShiftByDays == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_shiftbyhours", (void**)&(pWrapperTable->m_DateTime_ShiftByHours));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ShiftByHours == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_shiftbyminutes", (void**)&(pWrapperTable->m_DateTime_ShiftByMinutes));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ShiftByMinutes == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_shiftbyseconds", (void**)&(pWrapperTable->m_DateTime_ShiftBySeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ShiftBySeconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_shiftbymilliseconds", (void**)&(pWrapperTable->m_DateTime_ShiftByMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ShiftByMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_shiftbymicroseconds", (void**)&(pWrapperTable->m_DateTime_ShiftByMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_ShiftByMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounddowntoyear", (void**)&(pWrapperTable->m_DateTime_RoundDownToYear));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundDownToYear == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounddowntomonth", (void**)&(pWrapperTable->m_DateTime_RoundDownToMonth));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundDownToMonth == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounddowntoday", (void**)&(pWrapperTable->m_DateTime_RoundDownToDay));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundDownToDay == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounddowntohour", (void**)&(pWrapperTable->m_DateTime_RoundDownToHour));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundDownToHour == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounddowntominute", (void**)&(pWrapperTable->m_DateTime_RoundDownToMinute));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundDownToMinute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounddowntoseconds", (void**)&(pWrapperTable->m_DateTime_RoundDownToSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundDownToSeconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounddowntomilliseconds", (void**)&(pWrapperTable->m_DateTime_RoundDownToMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundDownToMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounduptoyear", (void**)&(pWrapperTable->m_DateTime_RoundUpToYear));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundUpToYear == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounduptomonth", (void**)&(pWrapperTable->m_DateTime_RoundUpToMonth));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundUpToMonth == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounduptoday", (void**)&(pWrapperTable->m_DateTime_RoundUpToDay));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundUpToDay == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounduptohour", (void**)&(pWrapperTable->m_DateTime_RoundUpToHour));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundUpToHour == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounduptominute", (void**)&(pWrapperTable->m_DateTime_RoundUpToMinute));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundUpToMinute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounduptoseconds", (void**)&(pWrapperTable->m_DateTime_RoundUpToSeconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundUpToSeconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_datetime_rounduptomilliseconds", (void**)&(pWrapperTable->m_DateTime_RoundUpToMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DateTime_RoundUpToMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_getname", (void**)&(pWrapperTable->m_MeshObject_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_getuuid", (void**)&(pWrapperTable->m_MeshObject_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_gettrianglecount", (void**)&(pWrapperTable->m_MeshObject_GetTriangleCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetTriangleCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_getvertexcount", (void**)&(pWrapperTable->m_MeshObject_GetVertexCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetVertexCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_ismanifold", (void**)&(pWrapperTable->m_MeshObject_IsManifold));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_IsManifold == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_isoriented", (void**)&(pWrapperTable->m_MeshObject_IsOriented));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_IsOriented == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_iswatertight", (void**)&(pWrapperTable->m_MeshObject_IsWatertight));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_IsWatertight == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_getmaxvertexid", (void**)&(pWrapperTable->m_MeshObject_GetMaxVertexID));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetMaxVertexID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_vertexexists", (void**)&(pWrapperTable->m_MeshObject_VertexExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_VertexExists == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_getvertex", (void**)&(pWrapperTable->m_MeshObject_GetVertex));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetVertex == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_getvertexids", (void**)&(pWrapperTable->m_MeshObject_GetVertexIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetVertexIDs == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_getallvertices", (void**)&(pWrapperTable->m_MeshObject_GetAllVertices));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetAllVertices == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_getmaxtriangleid", (void**)&(pWrapperTable->m_MeshObject_GetMaxTriangleID));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetMaxTriangleID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_triangeexists", (void**)&(pWrapperTable->m_MeshObject_TriangeExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_TriangeExists == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_gettriangle", (void**)&(pWrapperTable->m_MeshObject_GetTriangle));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetTriangle == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_gettriangleids", (void**)&(pWrapperTable->m_MeshObject_GetTriangleIDs));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetTriangleIDs == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_getalltriangles", (void**)&(pWrapperTable->m_MeshObject_GetAllTriangles));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_GetAllTriangles == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_ispersistent", (void**)&(pWrapperTable->m_MeshObject_IsPersistent));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_IsPersistent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshobject_makepersistent", (void**)&(pWrapperTable->m_MeshObject_MakePersistent));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshObject_MakePersistent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_persistentmeshobject_isboundtologinsession", (void**)&(pWrapperTable->m_PersistentMeshObject_IsBoundToLoginSession));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistentMeshObject_IsBoundToLoginSession == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatameshinstance_getname", (void**)&(pWrapperTable->m_ModelDataMeshInstance_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataMeshInstance_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatameshinstance_getuuid", (void**)&(pWrapperTable->m_ModelDataMeshInstance_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataMeshInstance_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatameshinstance_getlocaltransform", (void**)&(pWrapperTable->m_ModelDataMeshInstance_GetLocalTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataMeshInstance_GetLocalTransform == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatameshinstance_getabsolutetransform", (void**)&(pWrapperTable->m_ModelDataMeshInstance_GetAbsoluteTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataMeshInstance_GetAbsoluteTransform == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatameshinstance_createcopiedmesh", (void**)&(pWrapperTable->m_ModelDataMeshInstance_CreateCopiedMesh));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataMeshInstance_CreateCopiedMesh == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatameshinstance_createpersistentmesh", (void**)&(pWrapperTable->m_ModelDataMeshInstance_CreatePersistentMesh));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataMeshInstance_CreatePersistentMesh == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getname", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getuuid", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getlocaltransform", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetLocalTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetLocalTransform == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getabsolutetransform", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetAbsoluteTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetAbsoluteTransform == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getsolidcount", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetSolidCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetSolidCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getsolidmesh", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetSolidMesh));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetSolidMesh == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getsupportcount", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetSupportCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetSupportCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getsupportmesh", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetSupportMesh));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetSupportMesh == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getsubcomponentcount", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetSubComponentCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetSubComponentCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modeldatacomponentinstance_getsubcomponent", (void**)&(pWrapperTable->m_ModelDataComponentInstance_GetSubComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModelDataComponentInstance_GetSubComponent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshsceneitem_getitemuuid", (void**)&(pWrapperTable->m_MeshSceneItem_GetItemUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshSceneItem_GetItemUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshsceneitem_getsceneuuid", (void**)&(pWrapperTable->m_MeshSceneItem_GetSceneUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshSceneItem_GetSceneUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshsceneitem_gettransform", (void**)&(pWrapperTable->m_MeshSceneItem_GetTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshSceneItem_GetTransform == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshsceneitem_updatetransform", (void**)&(pWrapperTable->m_MeshSceneItem_UpdateTransform));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshSceneItem_UpdateTransform == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshsceneitem_getmeshobject", (void**)&(pWrapperTable->m_MeshSceneItem_GetMeshObject));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshSceneItem_GetMeshObject == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshsceneitem_referenceisvalid", (void**)&(pWrapperTable->m_MeshSceneItem_ReferenceIsValid));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshSceneItem_ReferenceIsValid == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshscene_getsceneuuid", (void**)&(pWrapperTable->m_MeshScene_GetSceneUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshScene_GetSceneUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshscene_isboundtologinsession", (void**)&(pWrapperTable->m_MeshScene_IsBoundToLoginSession));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshScene_IsBoundToLoginSession == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshscene_addsceneitem", (void**)&(pWrapperTable->m_MeshScene_AddSceneItem));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshScene_AddSceneItem == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshscene_addmodeldatameshassceneitem", (void**)&(pWrapperTable->m_MeshScene_AddModelDataMeshAsSceneItem));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshScene_AddModelDataMeshAsSceneItem == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshscene_getsceneitemcount", (void**)&(pWrapperTable->m_MeshScene_GetSceneItemCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshScene_GetSceneItemCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshscene_getsceneitem", (void**)&(pWrapperTable->m_MeshScene_GetSceneItem));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshScene_GetSceneItem == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshscene_findsceneitem", (void**)&(pWrapperTable->m_MeshScene_FindSceneItem));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshScene_FindSceneItem == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshscene_hassceneitem", (void**)&(pWrapperTable->m_MeshScene_HasSceneItem));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshScene_HasSceneItem == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_meshscene_removesceneitem", (void**)&(pWrapperTable->m_MeshScene_RemoveSceneItem));
		if ( (eLookupError != 0) || (pWrapperTable->m_MeshScene_RemoveSceneItem == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_scenehandler_meshispersistent", (void**)&(pWrapperTable->m_SceneHandler_MeshIsPersistent));
		if ( (eLookupError != 0) || (pWrapperTable->m_SceneHandler_MeshIsPersistent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_scenehandler_findpersistentmesh", (void**)&(pWrapperTable->m_SceneHandler_FindPersistentMesh));
		if ( (eLookupError != 0) || (pWrapperTable->m_SceneHandler_FindPersistentMesh == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_scenehandler_createemptymeshscene", (void**)&(pWrapperTable->m_SceneHandler_CreateEmptyMeshScene));
		if ( (eLookupError != 0) || (pWrapperTable->m_SceneHandler_CreateEmptyMeshScene == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_scenehandler_releasemeshscene", (void**)&(pWrapperTable->m_SceneHandler_ReleaseMeshScene));
		if ( (eLookupError != 0) || (pWrapperTable->m_SceneHandler_ReleaseMeshScene == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_scenehandler_load3mffromresource", (void**)&(pWrapperTable->m_SceneHandler_Load3MFFromResource));
		if ( (eLookupError != 0) || (pWrapperTable->m_SceneHandler_Load3MFFromResource == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_scenehandler_load3mffrommemory", (void**)&(pWrapperTable->m_SceneHandler_Load3MFFromMemory));
		if ( (eLookupError != 0) || (pWrapperTable->m_SceneHandler_Load3MFFromMemory == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_scenehandler_load3mffromstream", (void**)&(pWrapperTable->m_SceneHandler_Load3MFFromStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_SceneHandler_Load3MFFromStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathpart_getname", (void**)&(pWrapperTable->m_ToolpathPart_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathPart_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathpart_getuuid", (void**)&(pWrapperTable->m_ToolpathPart_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathPart_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathpart_getrootcomponent", (void**)&(pWrapperTable->m_ToolpathPart_GetRootComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathPart_GetRootComponent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getlayerdatauuid", (void**)&(pWrapperTable->m_ToolpathLayer_GetLayerDataUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetLayerDataUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentcount", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentinfo", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmenttype", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentType));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentType == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_segmentisloop", (void**)&(pWrapperTable->m_ToolpathLayer_SegmentIsLoop));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_SegmentIsLoop == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_segmentispolyline", (void**)&(pWrapperTable->m_ToolpathLayer_SegmentIsPolyline));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_SegmentIsPolyline == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_segmentishatchsegment", (void**)&(pWrapperTable->m_ToolpathLayer_SegmentIsHatchSegment));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_SegmentIsHatchSegment == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentintegerattribute", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentIntegerAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentIntegerAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentdoubleattribute", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentDoubleAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentDoubleAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_hascustomsegmentattribute", (void**)&(pWrapperTable->m_ToolpathLayer_HasCustomSegmentAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_HasCustomSegmentAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_findcustomsegmentattributeid", (void**)&(pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_findcustomsegmentattributetype", (void**)&(pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeType));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeType == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_findcustomsegmentattributeinfo", (void**)&(pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_FindCustomSegmentAttributeInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentpointcount", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentPointCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentPointCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmenthatchcount", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentHatchCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentHatchCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofileuuid", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_segmentprofilehasvalue", (void**)&(pWrapperTable->m_ToolpathLayer_SegmentProfileHasValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_SegmentProfileHasValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofilevalue", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofilevaluedef", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofiledoublevalue", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofiledoublevaluedef", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileDoubleValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofileintegervalue", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofileintegervaluedef", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileIntegerValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofileboolvalue", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofileboolvaluedef", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileBoolValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofiletypedvalue", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofiletypedvaluedef", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentpartuuid", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentpointdata", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentPointData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentPointData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmenthatchdata", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentHatchData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentHatchData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentpointdatainmm", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentPointDataInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentPointDataInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmenthatchdatainmm", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentHatchDataInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentHatchDataInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getzvalue", (void**)&(pWrapperTable->m_ToolpathLayer_GetZValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetZValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getzvalueinmm", (void**)&(pWrapperTable->m_ToolpathLayer_GetZValueInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetZValueInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getunits", (void**)&(pWrapperTable->m_ToolpathLayer_GetUnits));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetUnits == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getmetadatacount", (void**)&(pWrapperTable->m_ToolpathLayer_GetMetaDataCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetMetaDataCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getmetadatainfo", (void**)&(pWrapperTable->m_ToolpathLayer_GetMetaDataInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetMetaDataInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getmetadatacontent", (void**)&(pWrapperTable->m_ToolpathLayer_GetMetaDataContent));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetMetaDataContent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_hasuniquemetadata", (void**)&(pWrapperTable->m_ToolpathLayer_HasUniqueMetaData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_HasUniqueMetaData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_finduniquemetadata", (void**)&(pWrapperTable->m_ToolpathLayer_FindUniqueMetaData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_FindUniqueMetaData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_calculateextents", (void**)&(pWrapperTable->m_ToolpathLayer_CalculateExtents));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_CalculateExtents == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_calculateextentsinmm", (void**)&(pWrapperTable->m_ToolpathLayer_CalculateExtentsInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_CalculateExtentsInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getstorageuuid", (void**)&(pWrapperTable->m_ToolpathAccessor_GetStorageUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetStorageUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getbuilduuid", (void**)&(pWrapperTable->m_ToolpathAccessor_GetBuildUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetBuildUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getlayercount", (void**)&(pWrapperTable->m_ToolpathAccessor_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetLayerCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_registercustomsegmentattribute", (void**)&(pWrapperTable->m_ToolpathAccessor_RegisterCustomSegmentAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_RegisterCustomSegmentAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_loadlayer", (void**)&(pWrapperTable->m_ToolpathAccessor_LoadLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_LoadLayer == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getunits", (void**)&(pWrapperTable->m_ToolpathAccessor_GetUnits));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetUnits == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getpartcount", (void**)&(pWrapperTable->m_ToolpathAccessor_GetPartCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetPartCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getpart", (void**)&(pWrapperTable->m_ToolpathAccessor_GetPart));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetPart == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_findpartbyuuid", (void**)&(pWrapperTable->m_ToolpathAccessor_FindPartByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_FindPartByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getbuildheightinunits", (void**)&(pWrapperTable->m_ToolpathAccessor_GetBuildHeightInUnits));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetBuildHeightInUnits == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getzvalueinunits", (void**)&(pWrapperTable->m_ToolpathAccessor_GetZValueInUnits));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetZValueInUnits == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getbuildheightinmm", (void**)&(pWrapperTable->m_ToolpathAccessor_GetBuildHeightInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetBuildHeightInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getzvalueinmm", (void**)&(pWrapperTable->m_ToolpathAccessor_GetZValueInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetZValueInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getmetadatacount", (void**)&(pWrapperTable->m_ToolpathAccessor_GetMetaDataCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetMetaDataCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getmetadatainfo", (void**)&(pWrapperTable->m_ToolpathAccessor_GetMetaDataInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetMetaDataInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getmetadatacontent", (void**)&(pWrapperTable->m_ToolpathAccessor_GetMetaDataContent));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetMetaDataContent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_hasuniquemetadata", (void**)&(pWrapperTable->m_ToolpathAccessor_HasUniqueMetaData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_HasUniqueMetaData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_finduniquemetadata", (void**)&(pWrapperTable->m_ToolpathAccessor_FindUniqueMetaData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_FindUniqueMetaData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getuuid", (void**)&(pWrapperTable->m_BuildExecution_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getbuilduuid", (void**)&(pWrapperTable->m_BuildExecution_GetBuildUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetBuildUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getbuild", (void**)&(pWrapperTable->m_BuildExecution_GetBuild));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetBuild == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getexecutionstatus", (void**)&(pWrapperTable->m_BuildExecution_GetExecutionStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetExecutionStatus == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_isinprocess", (void**)&(pWrapperTable->m_BuildExecution_IsInProcess));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_IsInProcess == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_isfinished", (void**)&(pWrapperTable->m_BuildExecution_IsFinished));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_IsFinished == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_isfailed", (void**)&(pWrapperTable->m_BuildExecution_IsFailed));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_IsFailed == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_setstatustofinished", (void**)&(pWrapperTable->m_BuildExecution_SetStatusToFinished));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_SetStatusToFinished == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_setstatustofailed", (void**)&(pWrapperTable->m_BuildExecution_SetStatusToFailed));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_SetStatusToFailed == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getdescription", (void**)&(pWrapperTable->m_BuildExecution_GetDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetDescription == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_setdescription", (void**)&(pWrapperTable->m_BuildExecution_SetDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_SetDescription == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getjournaluuid", (void**)&(pWrapperTable->m_BuildExecution_GetJournalUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetJournalUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_hasattacheduser", (void**)&(pWrapperTable->m_BuildExecution_HasAttachedUser));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_HasAttachedUser == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getuseruuid", (void**)&(pWrapperTable->m_BuildExecution_GetUserUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetUserUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getstarttimestampinmilliseconds", (void**)&(pWrapperTable->m_BuildExecution_GetStartTimeStampInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetStartTimeStampInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getstarttimestampinmicroseconds", (void**)&(pWrapperTable->m_BuildExecution_GetStartTimeStampInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetStartTimeStampInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getendtimestampinmilliseconds", (void**)&(pWrapperTable->m_BuildExecution_GetEndTimeStampInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetEndTimeStampInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getendtimestampinmicroseconds", (void**)&(pWrapperTable->m_BuildExecution_GetEndTimeStampInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetEndTimeStampInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getelapsedtimeinmilliseconds", (void**)&(pWrapperTable->m_BuildExecution_GetElapsedTimeInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetElapsedTimeInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getelapsedtimeinmicroseconds", (void**)&(pWrapperTable->m_BuildExecution_GetElapsedTimeInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetElapsedTimeInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_hasattachment", (void**)&(pWrapperTable->m_BuildExecution_HasAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_HasAttachment == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_hasattachmentidentifier", (void**)&(pWrapperTable->m_BuildExecution_HasAttachmentIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_HasAttachmentIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_addbinarydata", (void**)&(pWrapperTable->m_BuildExecution_AddBinaryData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_AddBinaryData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_attachtempstream", (void**)&(pWrapperTable->m_BuildExecution_AttachTempStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_AttachTempStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_loadstreambyidentifier", (void**)&(pWrapperTable->m_BuildExecution_LoadStreamByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_LoadStreamByIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_loadstreambyuuid", (void**)&(pWrapperTable->m_BuildExecution_LoadStreamByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_LoadStreamByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_loaddiscretefield2dbyidentifier", (void**)&(pWrapperTable->m_BuildExecution_LoadDiscreteField2DByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_LoadDiscreteField2DByIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_loaddiscretefield2dbyuuid", (void**)&(pWrapperTable->m_BuildExecution_LoadDiscreteField2DByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_LoadDiscreteField2DByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_storediscretefield2d", (void**)&(pWrapperTable->m_BuildExecution_StoreDiscreteField2D));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_StoreDiscreteField2D == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_loaddatatablebyidentifier", (void**)&(pWrapperTable->m_BuildExecution_LoadDataTableByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_LoadDataTableByIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_loaddatatablebyuuid", (void**)&(pWrapperTable->m_BuildExecution_LoadDataTableByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_LoadDataTableByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_storedatatable", (void**)&(pWrapperTable->m_BuildExecution_StoreDataTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_StoreDataTable == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_loadpngimagebyidentifier", (void**)&(pWrapperTable->m_BuildExecution_LoadPNGImageByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_LoadPNGImageByIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_loadpngimagebyuuid", (void**)&(pWrapperTable->m_BuildExecution_LoadPNGImageByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_LoadPNGImageByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_storepngimage", (void**)&(pWrapperTable->m_BuildExecution_StorePNGImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_StorePNGImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_storemetadatastring", (void**)&(pWrapperTable->m_BuildExecution_StoreMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_StoreMetaDataString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_hasmetadatastring", (void**)&(pWrapperTable->m_BuildExecution_HasMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_HasMetaDataString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_getmetadatastring", (void**)&(pWrapperTable->m_BuildExecution_GetMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_GetMetaDataString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecution_loadattachedjournal", (void**)&(pWrapperTable->m_BuildExecution_LoadAttachedJournal));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecution_LoadAttachedJournal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_buildexecutioniterator_getcurrentexecution", (void**)&(pWrapperTable->m_BuildExecutionIterator_GetCurrentExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildExecutionIterator_GetCurrentExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getname", (void**)&(pWrapperTable->m_Build_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getbuilduuid", (void**)&(pWrapperTable->m_Build_GetBuildUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetBuildUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getstorageuuid", (void**)&(pWrapperTable->m_Build_GetStorageUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetStorageUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getstoragesha256", (void**)&(pWrapperTable->m_Build_GetStorageSHA256));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetStorageSHA256 == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getlayercount", (void**)&(pWrapperTable->m_Build_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetLayerCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getbuildheightinmm", (void**)&(pWrapperTable->m_Build_GetBuildHeightInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetBuildHeightInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getzvalueinmm", (void**)&(pWrapperTable->m_Build_GetZValueInMM));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetZValueInMM == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loadtoolpath", (void**)&(pWrapperTable->m_Build_LoadToolpath));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadToolpath == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_unloadtoolpath", (void**)&(pWrapperTable->m_Build_UnloadToolpath));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_UnloadToolpath == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_toolpathisloaded", (void**)&(pWrapperTable->m_Build_ToolpathIsLoaded));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_ToolpathIsLoaded == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_createtoolpathaccessor", (void**)&(pWrapperTable->m_Build_CreateToolpathAccessor));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_CreateToolpathAccessor == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_hasattachment", (void**)&(pWrapperTable->m_Build_HasAttachment));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_HasAttachment == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_hasattachmentidentifier", (void**)&(pWrapperTable->m_Build_HasAttachmentIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_HasAttachmentIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_addbinarydata", (void**)&(pWrapperTable->m_Build_AddBinaryData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_AddBinaryData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_attachtempstream", (void**)&(pWrapperTable->m_Build_AttachTempStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_AttachTempStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loadstreambyidentifier", (void**)&(pWrapperTable->m_Build_LoadStreamByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadStreamByIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loadstreambyuuid", (void**)&(pWrapperTable->m_Build_LoadStreamByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadStreamByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loaddiscretefield2dbyidentifier", (void**)&(pWrapperTable->m_Build_LoadDiscreteField2DByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadDiscreteField2DByIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loaddiscretefield2dbyuuid", (void**)&(pWrapperTable->m_Build_LoadDiscreteField2DByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadDiscreteField2DByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_storediscretefield2d", (void**)&(pWrapperTable->m_Build_StoreDiscreteField2D));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_StoreDiscreteField2D == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loaddatatablebyidentifier", (void**)&(pWrapperTable->m_Build_LoadDataTableByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadDataTableByIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loaddatatablebyuuid", (void**)&(pWrapperTable->m_Build_LoadDataTableByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadDataTableByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_storedatatable", (void**)&(pWrapperTable->m_Build_StoreDataTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_StoreDataTable == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loadpngimagebyidentifier", (void**)&(pWrapperTable->m_Build_LoadPNGImageByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadPNGImageByIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loadpngimagebyuuid", (void**)&(pWrapperTable->m_Build_LoadPNGImageByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadPNGImageByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_storepngimage", (void**)&(pWrapperTable->m_Build_StorePNGImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_StorePNGImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_startexecution", (void**)&(pWrapperTable->m_Build_StartExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_StartExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_hasexecution", (void**)&(pWrapperTable->m_Build_HasExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_HasExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_findexecution", (void**)&(pWrapperTable->m_Build_FindExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_FindExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_listexecutions", (void**)&(pWrapperTable->m_Build_ListExecutions));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_ListExecutions == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_listexecutionsbystatus", (void**)&(pWrapperTable->m_Build_ListExecutionsByStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_ListExecutionsByStatus == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_storemetadatastring", (void**)&(pWrapperTable->m_Build_StoreMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_StoreMetaDataString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_hasmetadatastring", (void**)&(pWrapperTable->m_Build_HasMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_HasMetaDataString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getmetadatastring", (void**)&(pWrapperTable->m_Build_GetMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetMetaDataString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfileexecution_getstatus", (void**)&(pWrapperTable->m_WorkingFileExecution_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFileExecution_GetStatus == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfileexecution_returnstdout", (void**)&(pWrapperTable->m_WorkingFileExecution_ReturnStdOut));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFileExecution_ReturnStdOut == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_getabsolutefilename", (void**)&(pWrapperTable->m_WorkingFile_GetAbsoluteFileName));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_GetAbsoluteFileName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_getsize", (void**)&(pWrapperTable->m_WorkingFile_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_GetSize == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_calculatesha2", (void**)&(pWrapperTable->m_WorkingFile_CalculateSHA2));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_CalculateSHA2 == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_executefile", (void**)&(pWrapperTable->m_WorkingFile_ExecuteFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_ExecuteFile == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_ismanaged", (void**)&(pWrapperTable->m_WorkingFile_IsManaged));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_IsManaged == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_makemanaged", (void**)&(pWrapperTable->m_WorkingFile_MakeManaged));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_MakeManaged == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_fileexists", (void**)&(pWrapperTable->m_WorkingFile_FileExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_FileExists == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_deletefromdisk", (void**)&(pWrapperTable->m_WorkingFile_DeleteFromDisk));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_DeleteFromDisk == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfileiterator_getcurrentfile", (void**)&(pWrapperTable->m_WorkingFileIterator_GetCurrentFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFileIterator_GetCurrentFile == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_isactive", (void**)&(pWrapperTable->m_WorkingDirectory_IsActive));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_IsActive == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_getabsolutefilepath", (void**)&(pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_storecustomdata", (void**)&(pWrapperTable->m_WorkingDirectory_StoreCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_StoreCustomData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_storecustomstring", (void**)&(pWrapperTable->m_WorkingDirectory_StoreCustomString));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_StoreCustomString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_storedriverdata", (void**)&(pWrapperTable->m_WorkingDirectory_StoreDriverData));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_StoreDriverData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_storecustomdataintempfile", (void**)&(pWrapperTable->m_WorkingDirectory_StoreCustomDataInTempFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_StoreCustomDataInTempFile == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_storecustomstringintempfile", (void**)&(pWrapperTable->m_WorkingDirectory_StoreCustomStringInTempFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_StoreCustomStringInTempFile == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_storedriverdataintempfile", (void**)&(pWrapperTable->m_WorkingDirectory_StoreDriverDataInTempFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_StoreDriverDataInTempFile == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_cleanup", (void**)&(pWrapperTable->m_WorkingDirectory_CleanUp));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_CleanUp == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_addmanagedfile", (void**)&(pWrapperTable->m_WorkingDirectory_AddManagedFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_AddManagedFile == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_hasunmanagedfiles", (void**)&(pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_retrieveunmanagedfiles", (void**)&(pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_retrievemanagedfiles", (void**)&(pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_retrieveallfiles", (void**)&(pWrapperTable->m_WorkingDirectory_RetrieveAllFiles));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_RetrieveAllFiles == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_getnamespace", (void**)&(pWrapperTable->m_XMLDocumentAttribute_GetNameSpace));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_GetNameSpace == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_getname", (void**)&(pWrapperTable->m_XMLDocumentAttribute_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_getvalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_GetValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_GetValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_isvaliduuid", (void**)&(pWrapperTable->m_XMLDocumentAttribute_IsValidUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_IsValidUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_getuuidvalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_GetUUIDValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_GetUUIDValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_isvalidinteger", (void**)&(pWrapperTable->m_XMLDocumentAttribute_IsValidInteger));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_IsValidInteger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_getintegervalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_GetIntegerValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_GetIntegerValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_isvaliddouble", (void**)&(pWrapperTable->m_XMLDocumentAttribute_IsValidDouble));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_IsValidDouble == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_getdoublevalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_GetDoubleValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_GetDoubleValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_isvalidbool", (void**)&(pWrapperTable->m_XMLDocumentAttribute_IsValidBool));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_IsValidBool == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_getboolvalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_GetBoolValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_GetBoolValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_setvalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_SetValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_SetValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_setuuidvalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_SetUUIDValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_SetUUIDValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_setintegervalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_SetIntegerValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_SetIntegerValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_setdoublevalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_SetDoubleValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_SetDoubleValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_setboolvalue", (void**)&(pWrapperTable->m_XMLDocumentAttribute_SetBoolValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_SetBoolValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentattribute_remove", (void**)&(pWrapperTable->m_XMLDocumentAttribute_Remove));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentAttribute_Remove == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getname", (void**)&(pWrapperTable->m_XMLDocumentNode_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getnamespace", (void**)&(pWrapperTable->m_XMLDocumentNode_GetNameSpace));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetNameSpace == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_gettextcontent", (void**)&(pWrapperTable->m_XMLDocumentNode_GetTextContent));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetTextContent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_settextcontent", (void**)&(pWrapperTable->m_XMLDocumentNode_SetTextContent));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_SetTextContent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributecount", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattribute", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_hasattribute", (void**)&(pWrapperTable->m_XMLDocumentNode_HasAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_HasAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_findattribute", (void**)&(pWrapperTable->m_XMLDocumentNode_FindAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_FindAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributevalue", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributeintegervalue", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributedoublevalue", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributeboolvalue", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributeuuidvalue", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributevaluedef", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributeintegervaluedef", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeIntegerValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributedoublevaluedef", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeDoubleValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributeboolvaluedef", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeBoolValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getattributeuuidvaluedef", (void**)&(pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValueDef));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetAttributeUUIDValueDef == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_removeattribute", (void**)&(pWrapperTable->m_XMLDocumentNode_RemoveAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_RemoveAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_removeattributebyindex", (void**)&(pWrapperTable->m_XMLDocumentNode_RemoveAttributeByIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_RemoveAttributeByIndex == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_addattribute", (void**)&(pWrapperTable->m_XMLDocumentNode_AddAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_AddAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_addintegerattribute", (void**)&(pWrapperTable->m_XMLDocumentNode_AddIntegerAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_AddIntegerAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_adddoubleattribute", (void**)&(pWrapperTable->m_XMLDocumentNode_AddDoubleAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_AddDoubleAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_addboolattribute", (void**)&(pWrapperTable->m_XMLDocumentNode_AddBoolAttribute));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_AddBoolAttribute == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getchildren", (void**)&(pWrapperTable->m_XMLDocumentNode_GetChildren));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetChildren == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_countchildrenbyname", (void**)&(pWrapperTable->m_XMLDocumentNode_CountChildrenByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_CountChildrenByName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_getchildrenbyname", (void**)&(pWrapperTable->m_XMLDocumentNode_GetChildrenByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_GetChildrenByName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_haschild", (void**)&(pWrapperTable->m_XMLDocumentNode_HasChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_HasChild == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_hasuniquechild", (void**)&(pWrapperTable->m_XMLDocumentNode_HasUniqueChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_HasUniqueChild == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_findchild", (void**)&(pWrapperTable->m_XMLDocumentNode_FindChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_FindChild == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_addchild", (void**)&(pWrapperTable->m_XMLDocumentNode_AddChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_AddChild == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_addchildtext", (void**)&(pWrapperTable->m_XMLDocumentNode_AddChildText));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_AddChildText == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_removechild", (void**)&(pWrapperTable->m_XMLDocumentNode_RemoveChild));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_RemoveChild == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_removechildrenwithname", (void**)&(pWrapperTable->m_XMLDocumentNode_RemoveChildrenWithName));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_RemoveChildrenWithName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnode_remove", (void**)&(pWrapperTable->m_XMLDocumentNode_Remove));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNode_Remove == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnodes_getnodecount", (void**)&(pWrapperTable->m_XMLDocumentNodes_GetNodeCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNodes_GetNodeCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnodes_getnode", (void**)&(pWrapperTable->m_XMLDocumentNodes_GetNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNodes_GetNode == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnodes_countnodesbyname", (void**)&(pWrapperTable->m_XMLDocumentNodes_CountNodesByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNodes_CountNodesByName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnodes_getnodesbyname", (void**)&(pWrapperTable->m_XMLDocumentNodes_GetNodesByName));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNodes_GetNodesByName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnodes_hasnode", (void**)&(pWrapperTable->m_XMLDocumentNodes_HasNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNodes_HasNode == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnodes_hasuniquenode", (void**)&(pWrapperTable->m_XMLDocumentNodes_HasUniqueNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNodes_HasUniqueNode == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocumentnodes_findnode", (void**)&(pWrapperTable->m_XMLDocumentNodes_FindNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocumentNodes_FindNode == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocument_getdefaultnamespace", (void**)&(pWrapperTable->m_XMLDocument_GetDefaultNamespace));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocument_GetDefaultNamespace == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocument_getnamespacecount", (void**)&(pWrapperTable->m_XMLDocument_GetNamespaceCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocument_GetNamespaceCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocument_getnamespace", (void**)&(pWrapperTable->m_XMLDocument_GetNamespace));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocument_GetNamespace == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocument_hasnamespace", (void**)&(pWrapperTable->m_XMLDocument_HasNamespace));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocument_HasNamespace == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocument_getnamespaceprefix", (void**)&(pWrapperTable->m_XMLDocument_GetNamespacePrefix));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocument_GetNamespacePrefix == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocument_registernamespace", (void**)&(pWrapperTable->m_XMLDocument_RegisterNamespace));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocument_RegisterNamespace == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocument_changenamespaceprefix", (void**)&(pWrapperTable->m_XMLDocument_ChangeNamespacePrefix));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocument_ChangeNamespacePrefix == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocument_getrootnode", (void**)&(pWrapperTable->m_XMLDocument_GetRootNode));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocument_GetRootNode == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_xmldocument_savetostring", (void**)&(pWrapperTable->m_XMLDocument_SaveToString));
		if ( (eLookupError != 0) || (pWrapperTable->m_XMLDocument_SaveToString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpippacket_isempty", (void**)&(pWrapperTable->m_TCPIPPacket_IsEmpty));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPPacket_IsEmpty == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpippacket_getsize", (void**)&(pWrapperTable->m_TCPIPPacket_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPPacket_GetSize == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpippacket_getdata", (void**)&(pWrapperTable->m_TCPIPPacket_GetData));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPPacket_GetData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_getipaddress", (void**)&(pWrapperTable->m_TCPIPConnection_GetIPAddress));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_GetIPAddress == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_getport", (void**)&(pWrapperTable->m_TCPIPConnection_GetPort));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_GetPort == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_gettimeout", (void**)&(pWrapperTable->m_TCPIPConnection_GetTimeout));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_GetTimeout == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_isconnected", (void**)&(pWrapperTable->m_TCPIPConnection_IsConnected));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_IsConnected == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_disconnect", (void**)&(pWrapperTable->m_TCPIPConnection_Disconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_Disconnect == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_reconnect", (void**)&(pWrapperTable->m_TCPIPConnection_Reconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_Reconnect == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_sendbuffer", (void**)&(pWrapperTable->m_TCPIPConnection_SendBuffer));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_SendBuffer == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_waitfordata", (void**)&(pWrapperTable->m_TCPIPConnection_WaitForData));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_WaitForData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_receivefixedpacket", (void**)&(pWrapperTable->m_TCPIPConnection_ReceiveFixedPacket));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_ReceiveFixedPacket == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tcpipconnection_receivedata", (void**)&(pWrapperTable->m_TCPIPConnection_ReceiveData));
		if ( (eLookupError != 0) || (pWrapperTable->m_TCPIPConnection_ReceiveData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpdigitaliostatus_getcount", (void**)&(pWrapperTable->m_ModbusTCPDigitalIOStatus_GetCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPDigitalIOStatus_GetCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpdigitaliostatus_getbaseaddress", (void**)&(pWrapperTable->m_ModbusTCPDigitalIOStatus_GetBaseAddress));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPDigitalIOStatus_GetBaseAddress == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpdigitaliostatus_getvalue", (void**)&(pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpdigitaliostatus_getvalues", (void**)&(pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPDigitalIOStatus_GetValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpregisterstatus_getcount", (void**)&(pWrapperTable->m_ModbusTCPRegisterStatus_GetCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPRegisterStatus_GetCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpregisterstatus_getbaseaddress", (void**)&(pWrapperTable->m_ModbusTCPRegisterStatus_GetBaseAddress));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPRegisterStatus_GetBaseAddress == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpregisterstatus_getvalue", (void**)&(pWrapperTable->m_ModbusTCPRegisterStatus_GetValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPRegisterStatus_GetValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpregisterstatus_getvalues", (void**)&(pWrapperTable->m_ModbusTCPRegisterStatus_GetValues));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPRegisterStatus_GetValues == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_getipaddress", (void**)&(pWrapperTable->m_ModbusTCPConnection_GetIPAddress));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_GetIPAddress == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_getport", (void**)&(pWrapperTable->m_ModbusTCPConnection_GetPort));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_GetPort == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_gettimeout", (void**)&(pWrapperTable->m_ModbusTCPConnection_GetTimeout));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_GetTimeout == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_isconnected", (void**)&(pWrapperTable->m_ModbusTCPConnection_IsConnected));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_IsConnected == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_disconnect", (void**)&(pWrapperTable->m_ModbusTCPConnection_Disconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_Disconnect == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_reconnect", (void**)&(pWrapperTable->m_ModbusTCPConnection_Reconnect));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_Reconnect == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_diagnosiscall", (void**)&(pWrapperTable->m_ModbusTCPConnection_DiagnosisCall));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_DiagnosisCall == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_readcoilstatus", (void**)&(pWrapperTable->m_ModbusTCPConnection_ReadCoilStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_ReadCoilStatus == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_readinputstatus", (void**)&(pWrapperTable->m_ModbusTCPConnection_ReadInputStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_ReadInputStatus == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_readholdingregisters", (void**)&(pWrapperTable->m_ModbusTCPConnection_ReadHoldingRegisters));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_ReadHoldingRegisters == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_readinputregisters", (void**)&(pWrapperTable->m_ModbusTCPConnection_ReadInputRegisters));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_ReadInputRegisters == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_forcemultiplecoils", (void**)&(pWrapperTable->m_ModbusTCPConnection_ForceMultipleCoils));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_ForceMultipleCoils == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_modbustcpconnection_presetmultipleregisters", (void**)&(pWrapperTable->m_ModbusTCPConnection_PresetMultipleRegisters));
		if ( (eLookupError != 0) || (pWrapperTable->m_ModbusTCPConnection_PresetMultipleRegisters == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverstatusupdatesession_setstringparameter", (void**)&(pWrapperTable->m_DriverStatusUpdateSession_SetStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverStatusUpdateSession_SetStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverstatusupdatesession_setuuidparameter", (void**)&(pWrapperTable->m_DriverStatusUpdateSession_SetUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverStatusUpdateSession_SetUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverstatusupdatesession_setdoubleparameter", (void**)&(pWrapperTable->m_DriverStatusUpdateSession_SetDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverStatusUpdateSession_SetDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverstatusupdatesession_setintegerparameter", (void**)&(pWrapperTable->m_DriverStatusUpdateSession_SetIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverStatusUpdateSession_SetIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverstatusupdatesession_setboolparameter", (void**)&(pWrapperTable->m_DriverStatusUpdateSession_SetBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverStatusUpdateSession_SetBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverstatusupdatesession_logmessage", (void**)&(pWrapperTable->m_DriverStatusUpdateSession_LogMessage));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverStatusUpdateSession_LogMessage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverstatusupdatesession_logwarning", (void**)&(pWrapperTable->m_DriverStatusUpdateSession_LogWarning));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverStatusUpdateSession_LogWarning == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverstatusupdatesession_loginfo", (void**)&(pWrapperTable->m_DriverStatusUpdateSession_LogInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverStatusUpdateSession_LogInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverstatusupdatesession_sleep", (void**)&(pWrapperTable->m_DriverStatusUpdateSession_Sleep));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverStatusUpdateSession_Sleep == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createstatusupdatesession", (void**)&(pWrapperTable->m_DriverEnvironment_CreateStatusUpdateSession));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateStatusUpdateSession == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createworkingdirectory", (void**)&(pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createtcpipconnection", (void**)&(pWrapperTable->m_DriverEnvironment_CreateTCPIPConnection));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateTCPIPConnection == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createmodbustcpconnection", (void**)&(pWrapperTable->m_DriverEnvironment_CreateModbusTCPConnection));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateModbusTCPConnection == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createxmldocument", (void**)&(pWrapperTable->m_DriverEnvironment_CreateXMLDocument));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateXMLDocument == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_parsexmlstring", (void**)&(pWrapperTable->m_DriverEnvironment_ParseXMLString));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_ParseXMLString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_parsexmldata", (void**)&(pWrapperTable->m_DriverEnvironment_ParseXMLData));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_ParseXMLData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createdatatable", (void**)&(pWrapperTable->m_DriverEnvironment_CreateDataTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateDataTable == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_driverhasresourcedata", (void**)&(pWrapperTable->m_DriverEnvironment_DriverHasResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_DriverHasResourceData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_machinehasresourcedata", (void**)&(pWrapperTable->m_DriverEnvironment_MachineHasResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_MachineHasResourceData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_retrievedriverdata", (void**)&(pWrapperTable->m_DriverEnvironment_RetrieveDriverData));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RetrieveDriverData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_retrievedriverresourcedata", (void**)&(pWrapperTable->m_DriverEnvironment_RetrieveDriverResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RetrieveDriverResourceData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_retrievemachineresourcedata", (void**)&(pWrapperTable->m_DriverEnvironment_RetrieveMachineResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RetrieveMachineResourceData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createtoolpathaccessor", (void**)&(pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_parameternameisvalid", (void**)&(pWrapperTable->m_DriverEnvironment_ParameterNameIsValid));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_ParameterNameIsValid == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registerstringparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registeruuidparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registerdoubleparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registerdoubleparameterwithunits", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterDoubleParameterWithUnits));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterDoubleParameterWithUnits == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registerintegerparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registerboolparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setstringparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setuuidparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setdoubleparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setintegerparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setboolparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_sleep", (void**)&(pWrapperTable->m_DriverEnvironment_Sleep));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_Sleep == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_getglobaltimerinmilliseconds", (void**)&(pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_getglobaltimerinmicroseconds", (void**)&(pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_GetGlobalTimerInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_logmessage", (void**)&(pWrapperTable->m_DriverEnvironment_LogMessage));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_LogMessage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_logwarning", (void**)&(pWrapperTable->m_DriverEnvironment_LogWarning));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_LogWarning == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_loginfo", (void**)&(pWrapperTable->m_DriverEnvironment_LogInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_LogInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createemptyimage", (void**)&(pWrapperTable->m_DriverEnvironment_CreateEmptyImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateEmptyImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_loadpngimage", (void**)&(pWrapperTable->m_DriverEnvironment_LoadPNGImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_LoadPNGImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_creatediscretefield2d", (void**)&(pWrapperTable->m_DriverEnvironment_CreateDiscreteField2D));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateDiscreteField2D == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_creatediscretefield2dfromimage", (void**)&(pWrapperTable->m_DriverEnvironment_CreateDiscreteField2DFromImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateDiscreteField2DFromImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_hasbuildjob", (void**)&(pWrapperTable->m_DriverEnvironment_HasBuildJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_HasBuildJob == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_getbuildjob", (void**)&(pWrapperTable->m_DriverEnvironment_GetBuildJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_GetBuildJob == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_hasbuildexecution", (void**)&(pWrapperTable->m_DriverEnvironment_HasBuildExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_HasBuildExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_getbuildexecution", (void**)&(pWrapperTable->m_DriverEnvironment_GetBuildExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_GetBuildExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createcryptocontext", (void**)&(pWrapperTable->m_DriverEnvironment_CreateCryptoContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateCryptoContext == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_getcurrentdatetime", (void**)&(pWrapperTable->m_DriverEnvironment_GetCurrentDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_GetCurrentDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_getcustomdatetime", (void**)&(pWrapperTable->m_DriverEnvironment_GetCustomDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_GetCustomDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_getstartdatetime", (void**)&(pWrapperTable->m_DriverEnvironment_GetStartDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_GetStartDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_cantrigger", (void**)&(pWrapperTable->m_SignalTrigger_CanTrigger));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_CanTrigger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_trigger", (void**)&(pWrapperTable->m_SignalTrigger_Trigger));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_Trigger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_waitforhandling", (void**)&(pWrapperTable->m_SignalTrigger_WaitForHandling));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_WaitForHandling == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getname", (void**)&(pWrapperTable->m_SignalTrigger_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getstatemachine", (void**)&(pWrapperTable->m_SignalTrigger_GetStateMachine));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetStateMachine == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setstring", (void**)&(pWrapperTable->m_SignalTrigger_SetString));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setuuid", (void**)&(pWrapperTable->m_SignalTrigger_SetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setdouble", (void**)&(pWrapperTable->m_SignalTrigger_SetDouble));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetDouble == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setinteger", (void**)&(pWrapperTable->m_SignalTrigger_SetInteger));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetInteger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setbool", (void**)&(pWrapperTable->m_SignalTrigger_SetBool));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetBool == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getstringresult", (void**)&(pWrapperTable->m_SignalTrigger_GetStringResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetStringResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getuuidresult", (void**)&(pWrapperTable->m_SignalTrigger_GetUUIDResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetUUIDResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getdoubleresult", (void**)&(pWrapperTable->m_SignalTrigger_GetDoubleResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetDoubleResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getintegerresult", (void**)&(pWrapperTable->m_SignalTrigger_GetIntegerResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetIntegerResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getboolresult", (void**)&(pWrapperTable->m_SignalTrigger_GetBoolResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetBoolResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_signalhandled", (void**)&(pWrapperTable->m_SignalHandler_SignalHandled));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SignalHandled == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getname", (void**)&(pWrapperTable->m_SignalHandler_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getsignalid", (void**)&(pWrapperTable->m_SignalHandler_GetSignalID));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetSignalID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getsignaluuid", (void**)&(pWrapperTable->m_SignalHandler_GetSignalUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetSignalUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getstatemachine", (void**)&(pWrapperTable->m_SignalHandler_GetStateMachine));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetStateMachine == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getstring", (void**)&(pWrapperTable->m_SignalHandler_GetString));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getuuid", (void**)&(pWrapperTable->m_SignalHandler_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getdouble", (void**)&(pWrapperTable->m_SignalHandler_GetDouble));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetDouble == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getinteger", (void**)&(pWrapperTable->m_SignalHandler_GetInteger));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetInteger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getbool", (void**)&(pWrapperTable->m_SignalHandler_GetBool));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetBool == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setstringresult", (void**)&(pWrapperTable->m_SignalHandler_SetStringResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetStringResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setuuidresult", (void**)&(pWrapperTable->m_SignalHandler_SetUUIDResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetUUIDResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setdoubleresult", (void**)&(pWrapperTable->m_SignalHandler_SetDoubleResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetDoubleResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setintegerresult", (void**)&(pWrapperTable->m_SignalHandler_SetIntegerResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetIntegerResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setboolresult", (void**)&(pWrapperTable->m_SignalHandler_SetBoolResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetBoolResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_basetempstreamwriter_getuuid", (void**)&(pWrapperTable->m_BaseTempStreamWriter_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseTempStreamWriter_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_basetempstreamwriter_getname", (void**)&(pWrapperTable->m_BaseTempStreamWriter_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseTempStreamWriter_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_basetempstreamwriter_getmimetype", (void**)&(pWrapperTable->m_BaseTempStreamWriter_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseTempStreamWriter_GetMIMEType == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_basetempstreamwriter_getsize", (void**)&(pWrapperTable->m_BaseTempStreamWriter_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseTempStreamWriter_GetSize == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_basetempstreamwriter_finish", (void**)&(pWrapperTable->m_BaseTempStreamWriter_Finish));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseTempStreamWriter_Finish == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_basetempstreamwriter_isfinished", (void**)&(pWrapperTable->m_BaseTempStreamWriter_IsFinished));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseTempStreamWriter_IsFinished == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_basetempstreamwriter_getstreamreader", (void**)&(pWrapperTable->m_BaseTempStreamWriter_GetStreamReader));
		if ( (eLookupError != 0) || (pWrapperTable->m_BaseTempStreamWriter_GetStreamReader == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tempstreamwriter_getwriteposition", (void**)&(pWrapperTable->m_TempStreamWriter_GetWritePosition));
		if ( (eLookupError != 0) || (pWrapperTable->m_TempStreamWriter_GetWritePosition == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tempstreamwriter_seek", (void**)&(pWrapperTable->m_TempStreamWriter_Seek));
		if ( (eLookupError != 0) || (pWrapperTable->m_TempStreamWriter_Seek == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tempstreamwriter_writedata", (void**)&(pWrapperTable->m_TempStreamWriter_WriteData));
		if ( (eLookupError != 0) || (pWrapperTable->m_TempStreamWriter_WriteData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tempstreamwriter_writestring", (void**)&(pWrapperTable->m_TempStreamWriter_WriteString));
		if ( (eLookupError != 0) || (pWrapperTable->m_TempStreamWriter_WriteString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tempstreamwriter_writeline", (void**)&(pWrapperTable->m_TempStreamWriter_WriteLine));
		if ( (eLookupError != 0) || (pWrapperTable->m_TempStreamWriter_WriteLine == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_tempstreamwriter_copyfrom", (void**)&(pWrapperTable->m_TempStreamWriter_CopyFrom));
		if ( (eLookupError != 0) || (pWrapperTable->m_TempStreamWriter_CopyFrom == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_zipstreamwriter_createzipentry", (void**)&(pWrapperTable->m_ZIPStreamWriter_CreateZIPEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_ZIPStreamWriter_CreateZIPEntry == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_zipstreamwriter_createzipentryfromstream", (void**)&(pWrapperTable->m_ZIPStreamWriter_CreateZIPEntryFromStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_ZIPStreamWriter_CreateZIPEntryFromStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_streamreader_getuuid", (void**)&(pWrapperTable->m_StreamReader_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_StreamReader_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_streamreader_getname", (void**)&(pWrapperTable->m_StreamReader_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_StreamReader_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_streamreader_getmimetype", (void**)&(pWrapperTable->m_StreamReader_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_StreamReader_GetMIMEType == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_streamreader_getsize", (void**)&(pWrapperTable->m_StreamReader_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_StreamReader_GetSize == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_streamreader_getreadposition", (void**)&(pWrapperTable->m_StreamReader_GetReadPosition));
		if ( (eLookupError != 0) || (pWrapperTable->m_StreamReader_GetReadPosition == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_streamreader_seek", (void**)&(pWrapperTable->m_StreamReader_Seek));
		if ( (eLookupError != 0) || (pWrapperTable->m_StreamReader_Seek == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_streamreader_readdata", (void**)&(pWrapperTable->m_StreamReader_ReadData));
		if ( (eLookupError != 0) || (pWrapperTable->m_StreamReader_ReadData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_streamreader_readalldata", (void**)&(pWrapperTable->m_StreamReader_ReadAllData));
		if ( (eLookupError != 0) || (pWrapperTable->m_StreamReader_ReadAllData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uniformjournalsampling_getvariablename", (void**)&(pWrapperTable->m_UniformJournalSampling_GetVariableName));
		if ( (eLookupError != 0) || (pWrapperTable->m_UniformJournalSampling_GetVariableName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uniformjournalsampling_getnumberofsamples", (void**)&(pWrapperTable->m_UniformJournalSampling_GetNumberOfSamples));
		if ( (eLookupError != 0) || (pWrapperTable->m_UniformJournalSampling_GetNumberOfSamples == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uniformjournalsampling_getstarttimestamp", (void**)&(pWrapperTable->m_UniformJournalSampling_GetStartTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_UniformJournalSampling_GetStartTimeStamp == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uniformjournalsampling_getendtimestamp", (void**)&(pWrapperTable->m_UniformJournalSampling_GetEndTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_UniformJournalSampling_GetEndTimeStamp == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uniformjournalsampling_getsample", (void**)&(pWrapperTable->m_UniformJournalSampling_GetSample));
		if ( (eLookupError != 0) || (pWrapperTable->m_UniformJournalSampling_GetSample == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uniformjournalsampling_getallsamples", (void**)&(pWrapperTable->m_UniformJournalSampling_GetAllSamples));
		if ( (eLookupError != 0) || (pWrapperTable->m_UniformJournalSampling_GetAllSamples == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalvariable_getvariablename", (void**)&(pWrapperTable->m_JournalVariable_GetVariableName));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalVariable_GetVariableName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalvariable_getstarttimestamp", (void**)&(pWrapperTable->m_JournalVariable_GetStartTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalVariable_GetStartTimeStamp == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalvariable_getendtimestamp", (void**)&(pWrapperTable->m_JournalVariable_GetEndTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalVariable_GetEndTimeStamp == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalvariable_computefullaverage", (void**)&(pWrapperTable->m_JournalVariable_ComputeFullAverage));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalVariable_ComputeFullAverage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalvariable_computeaverage", (void**)&(pWrapperTable->m_JournalVariable_ComputeAverage));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalVariable_ComputeAverage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalvariable_computesample", (void**)&(pWrapperTable->m_JournalVariable_ComputeSample));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalVariable_ComputeSample == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalvariable_computeuniformaveragesamples", (void**)&(pWrapperTable->m_JournalVariable_ComputeUniformAverageSamples));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalVariable_ComputeUniformAverageSamples == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalvariable_computeequidistantsamples", (void**)&(pWrapperTable->m_JournalVariable_ComputeEquidistantSamples));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalVariable_ComputeEquidistantSamples == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalvariable_receiverawtimestream", (void**)&(pWrapperTable->m_JournalVariable_ReceiveRawTimeStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalVariable_ReceiveRawTimeStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_getuuid", (void**)&(pWrapperTable->m_Alert_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_isactive", (void**)&(pWrapperTable->m_Alert_IsActive));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_IsActive == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_getalertlevel", (void**)&(pWrapperTable->m_Alert_GetAlertLevel));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetAlertLevel == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_getidentifier", (void**)&(pWrapperTable->m_Alert_GetIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetIdentifier == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_getreadablecontextinformation", (void**)&(pWrapperTable->m_Alert_GetReadableContextInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetReadableContextInformation == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_needsacknowledgement", (void**)&(pWrapperTable->m_Alert_NeedsAcknowledgement));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_NeedsAcknowledgement == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_hasbeenacknowledged", (void**)&(pWrapperTable->m_Alert_HasBeenAcknowledged));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_HasBeenAcknowledged == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_getacknowledgementinformation", (void**)&(pWrapperTable->m_Alert_GetAcknowledgementInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetAcknowledgementInformation == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_getacknowledgementtime", (void**)&(pWrapperTable->m_Alert_GetAcknowledgementTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetAcknowledgementTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_acknowledgeforuser", (void**)&(pWrapperTable->m_Alert_AcknowledgeForUser));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_AcknowledgeForUser == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_acknowledgealertforcurrentuser", (void**)&(pWrapperTable->m_Alert_AcknowledgeAlertForCurrentUser));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_AcknowledgeAlertForCurrentUser == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alert_deactivatealert", (void**)&(pWrapperTable->m_Alert_DeactivateAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_DeactivateAlert == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_alertiterator_getcurrentalert", (void**)&(pWrapperTable->m_AlertIterator_GetCurrentAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_AlertIterator_GetCurrentAlert == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_logentrylist_getcount", (void**)&(pWrapperTable->m_LogEntryList_GetCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_GetCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_logentrylist_getentry", (void**)&(pWrapperTable->m_LogEntryList_GetEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_GetEntry == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_logentrylist_getentrytime", (void**)&(pWrapperTable->m_LogEntryList_GetEntryTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_GetEntryTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalhandler_retrievejournalvariable", (void**)&(pWrapperTable->m_JournalHandler_RetrieveJournalVariable));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalHandler_RetrieveJournalVariable == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalhandler_retrievejournalvariablefromtimeinterval", (void**)&(pWrapperTable->m_JournalHandler_RetrieveJournalVariableFromTimeInterval));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalHandler_RetrieveJournalVariableFromTimeInterval == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalhandler_getstarttime", (void**)&(pWrapperTable->m_JournalHandler_GetStartTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalHandler_GetStartTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalhandler_retrievelogentries", (void**)&(pWrapperTable->m_JournalHandler_RetrieveLogEntries));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalHandler_RetrieveLogEntries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalhandler_retrievelogentriesfromtimeinterval", (void**)&(pWrapperTable->m_JournalHandler_RetrieveLogEntriesFromTimeInterval));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalHandler_RetrieveLogEntriesFromTimeInterval == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalhandler_retrievealerts", (void**)&(pWrapperTable->m_JournalHandler_RetrieveAlerts));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalHandler_RetrieveAlerts == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_journalhandler_retrievealertsfromtimeinterval", (void**)&(pWrapperTable->m_JournalHandler_RetrieveAlertsFromTimeInterval));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalHandler_RetrieveAlertsFromTimeInterval == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_userdetaillist_count", (void**)&(pWrapperTable->m_UserDetailList_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserDetailList_Count == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_userdetaillist_getuserproperties", (void**)&(pWrapperTable->m_UserDetailList_GetUserProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserDetailList_GetUserProperties == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_userdetaillist_getusername", (void**)&(pWrapperTable->m_UserDetailList_GetUsername));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserDetailList_GetUsername == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_userdetaillist_getuuid", (void**)&(pWrapperTable->m_UserDetailList_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserDetailList_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_userdetaillist_getdescription", (void**)&(pWrapperTable->m_UserDetailList_GetDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserDetailList_GetDescription == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_userdetaillist_getrole", (void**)&(pWrapperTable->m_UserDetailList_GetRole));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserDetailList_GetRole == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_userdetaillist_getlanguage", (void**)&(pWrapperTable->m_UserDetailList_GetLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserDetailList_GetLanguage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_userexists", (void**)&(pWrapperTable->m_UserManagementHandler_UserExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_UserExists == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_useruuidexists", (void**)&(pWrapperTable->m_UserManagementHandler_UserUUIDExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_UserUUIDExists == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getuserproperties", (void**)&(pWrapperTable->m_UserManagementHandler_GetUserProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUserProperties == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getuserpropertiesbyuuid", (void**)&(pWrapperTable->m_UserManagementHandler_GetUserPropertiesByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUserPropertiesByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getusernamebyuuid", (void**)&(pWrapperTable->m_UserManagementHandler_GetUsernameByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUsernameByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getuseruuid", (void**)&(pWrapperTable->m_UserManagementHandler_GetUserUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUserUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getuserdescription", (void**)&(pWrapperTable->m_UserManagementHandler_GetUserDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUserDescription == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getuserdescriptionbyuuid", (void**)&(pWrapperTable->m_UserManagementHandler_GetUserDescriptionByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUserDescriptionByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getuserrole", (void**)&(pWrapperTable->m_UserManagementHandler_GetUserRole));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUserRole == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getuserrolebyuuid", (void**)&(pWrapperTable->m_UserManagementHandler_GetUserRoleByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUserRoleByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getuserlanguage", (void**)&(pWrapperTable->m_UserManagementHandler_GetUserLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUserLanguage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getuserlanguagebyuuid", (void**)&(pWrapperTable->m_UserManagementHandler_GetUserLanguageByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetUserLanguageByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_createuser", (void**)&(pWrapperTable->m_UserManagementHandler_CreateUser));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_CreateUser == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_setuserlanguage", (void**)&(pWrapperTable->m_UserManagementHandler_SetUserLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_SetUserLanguage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_setuserrole", (void**)&(pWrapperTable->m_UserManagementHandler_SetUserRole));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_SetUserRole == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_setuserdescription", (void**)&(pWrapperTable->m_UserManagementHandler_SetUserDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_SetUserDescription == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_setuserpassword", (void**)&(pWrapperTable->m_UserManagementHandler_SetUserPassword));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_SetUserPassword == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_setuserlanguagebyuuid", (void**)&(pWrapperTable->m_UserManagementHandler_SetUserLanguageByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_SetUserLanguageByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_setuserrolebyuuid", (void**)&(pWrapperTable->m_UserManagementHandler_SetUserRoleByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_SetUserRoleByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_setuserdescriptionbyuuid", (void**)&(pWrapperTable->m_UserManagementHandler_SetUserDescriptionByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_SetUserDescriptionByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_setuserpasswordbyuuid", (void**)&(pWrapperTable->m_UserManagementHandler_SetUserPasswordByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_SetUserPasswordByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_usermanagementhandler_getactiveusers", (void**)&(pWrapperTable->m_UserManagementHandler_GetActiveUsers));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserManagementHandler_GetActiveUsers == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getmachinestate", (void**)&(pWrapperTable->m_StateEnvironment_GetMachineState));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetMachineState == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getpreviousstate", (void**)&(pWrapperTable->m_StateEnvironment_GetPreviousState));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetPreviousState == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_preparesignal", (void**)&(pWrapperTable->m_StateEnvironment_PrepareSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_PrepareSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_waitforsignal", (void**)&(pWrapperTable->m_StateEnvironment_WaitForSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_WaitForSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getunhandledsignal", (void**)&(pWrapperTable->m_StateEnvironment_GetUnhandledSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetUnhandledSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getunhandledsignalbyuuid", (void**)&(pWrapperTable->m_StateEnvironment_GetUnhandledSignalByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetUnhandledSignalByUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getdriverlibrary", (void**)&(pWrapperTable->m_StateEnvironment_GetDriverLibrary));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetDriverLibrary == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createdriveraccess", (void**)&(pWrapperTable->m_StateEnvironment_CreateDriverAccess));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateDriverAccess == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_hasbuildjob", (void**)&(pWrapperTable->m_StateEnvironment_HasBuildJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_HasBuildJob == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getbuildjob", (void**)&(pWrapperTable->m_StateEnvironment_GetBuildJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetBuildJob == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_hasbuildexecution", (void**)&(pWrapperTable->m_StateEnvironment_HasBuildExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_HasBuildExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getbuildexecution", (void**)&(pWrapperTable->m_StateEnvironment_GetBuildExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetBuildExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_unloadalltoolpathes", (void**)&(pWrapperTable->m_StateEnvironment_UnloadAllToolpathes));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_UnloadAllToolpathes == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setnextstate", (void**)&(pWrapperTable->m_StateEnvironment_SetNextState));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetNextState == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_logmessage", (void**)&(pWrapperTable->m_StateEnvironment_LogMessage));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LogMessage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_logwarning", (void**)&(pWrapperTable->m_StateEnvironment_LogWarning));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LogWarning == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_loginfo", (void**)&(pWrapperTable->m_StateEnvironment_LogInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LogInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_sleep", (void**)&(pWrapperTable->m_StateEnvironment_Sleep));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_Sleep == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_checkfortermination", (void**)&(pWrapperTable->m_StateEnvironment_CheckForTermination));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CheckForTermination == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_storesignal", (void**)&(pWrapperTable->m_StateEnvironment_StoreSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_StoreSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_retrievesignal", (void**)&(pWrapperTable->m_StateEnvironment_RetrieveSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_RetrieveSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_clearstoredvalue", (void**)&(pWrapperTable->m_StateEnvironment_ClearStoredValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_ClearStoredValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setstringparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setuuidparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setdoubleparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setintegerparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setboolparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getstringparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getuuidparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getdoubleparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getintegerparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getboolparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_loadresourcedata", (void**)&(pWrapperTable->m_StateEnvironment_LoadResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LoadResourceData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_loadresourcestring", (void**)&(pWrapperTable->m_StateEnvironment_LoadResourceString));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LoadResourceString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createemptyimage", (void**)&(pWrapperTable->m_StateEnvironment_CreateEmptyImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateEmptyImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_loadpngimage", (void**)&(pWrapperTable->m_StateEnvironment_LoadPNGImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LoadPNGImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_creatediscretefield2d", (void**)&(pWrapperTable->m_StateEnvironment_CreateDiscreteField2D));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateDiscreteField2D == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_creatediscretefield2dfromimage", (void**)&(pWrapperTable->m_StateEnvironment_CreateDiscreteField2DFromImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateDiscreteField2DFromImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getglobaltimerinmilliseconds", (void**)&(pWrapperTable->m_StateEnvironment_GetGlobalTimerInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetGlobalTimerInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getglobaltimerinmicroseconds", (void**)&(pWrapperTable->m_StateEnvironment_GetGlobalTimerInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetGlobalTimerInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getstarttimeofstateinmilliseconds", (void**)&(pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getstarttimeofstateinmicroseconds", (void**)&(pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetStartTimeOfStateInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getendtimeofpreviousstateinmicroseconds", (void**)&(pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getendtimeofpreviousstateinmilliseconds", (void**)&(pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetEndTimeOfPreviousStateInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getelapsedtimeinstateinmilliseconds", (void**)&(pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getelapsedtimeinstateinmicroseconds", (void**)&(pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetElapsedTimeInStateInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getcurrentdatetime", (void**)&(pWrapperTable->m_StateEnvironment_GetCurrentDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetCurrentDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getcustomdatetime", (void**)&(pWrapperTable->m_StateEnvironment_GetCustomDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetCustomDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getstartdatetime", (void**)&(pWrapperTable->m_StateEnvironment_GetStartDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetStartDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_gettestenvironment", (void**)&(pWrapperTable->m_StateEnvironment_GetTestEnvironment));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetTestEnvironment == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createxmldocument", (void**)&(pWrapperTable->m_StateEnvironment_CreateXMLDocument));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateXMLDocument == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_parsexmlstring", (void**)&(pWrapperTable->m_StateEnvironment_ParseXMLString));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_ParseXMLString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_parsexmldata", (void**)&(pWrapperTable->m_StateEnvironment_ParseXMLData));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_ParseXMLData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createdatatable", (void**)&(pWrapperTable->m_StateEnvironment_CreateDataTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateDataTable == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_checkuserpermission", (void**)&(pWrapperTable->m_StateEnvironment_CheckUserPermission));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CheckUserPermission == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createusermanagement", (void**)&(pWrapperTable->m_StateEnvironment_CreateUserManagement));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateUserManagement == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getcurrentjournal", (void**)&(pWrapperTable->m_StateEnvironment_GetCurrentJournal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetCurrentJournal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createscenehandler", (void**)&(pWrapperTable->m_StateEnvironment_CreateSceneHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateSceneHandler == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createdataseries", (void**)&(pWrapperTable->m_StateEnvironment_CreateDataSeries));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateDataSeries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_hasdataseries", (void**)&(pWrapperTable->m_StateEnvironment_HasDataSeries));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_HasDataSeries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_finddataseries", (void**)&(pWrapperTable->m_StateEnvironment_FindDataSeries));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_FindDataSeries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_releasedataseries", (void**)&(pWrapperTable->m_StateEnvironment_ReleaseDataSeries));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_ReleaseDataSeries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createalert", (void**)&(pWrapperTable->m_StateEnvironment_CreateAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateAlert == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_findalert", (void**)&(pWrapperTable->m_StateEnvironment_FindAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_FindAlert == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_alertexists", (void**)&(pWrapperTable->m_StateEnvironment_AlertExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_AlertExists == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_retrievealerts", (void**)&(pWrapperTable->m_StateEnvironment_RetrieveAlerts));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_RetrieveAlerts == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_retrievealertsbytype", (void**)&(pWrapperTable->m_StateEnvironment_RetrieveAlertsByType));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_RetrieveAlertsByType == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_hasalertoftype", (void**)&(pWrapperTable->m_StateEnvironment_HasAlertOfType));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_HasAlertOfType == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createcryptocontext", (void**)&(pWrapperTable->m_StateEnvironment_CreateCryptoContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateCryptoContext == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createtemporarystream", (void**)&(pWrapperTable->m_StateEnvironment_CreateTemporaryStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateTemporaryStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createzipstream", (void**)&(pWrapperTable->m_StateEnvironment_CreateZIPStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateZIPStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_loadstream", (void**)&(pWrapperTable->m_StateEnvironment_LoadStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LoadStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uiitem_getname", (void**)&(pWrapperTable->m_UIItem_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIItem_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uiitem_getpath", (void**)&(pWrapperTable->m_UIItem_GetPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIItem_GetPath == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uiitem_getuuid", (void**)&(pWrapperTable->m_UIItem_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIItem_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_activatemodaldialog", (void**)&(pWrapperTable->m_UIEnvironment_ActivateModalDialog));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_ActivateModalDialog == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_closemodaldialog", (void**)&(pWrapperTable->m_UIEnvironment_CloseModalDialog));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CloseModalDialog == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_activatepage", (void**)&(pWrapperTable->m_UIEnvironment_ActivatePage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_ActivatePage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_logout", (void**)&(pWrapperTable->m_UIEnvironment_LogOut));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_LogOut == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_showhint", (void**)&(pWrapperTable->m_UIEnvironment_ShowHint));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_ShowHint == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_showhintcolored", (void**)&(pWrapperTable->m_UIEnvironment_ShowHintColored));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_ShowHintColored == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_hidehint", (void**)&(pWrapperTable->m_UIEnvironment_HideHint));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_HideHint == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_startstreamdownload", (void**)&(pWrapperTable->m_UIEnvironment_StartStreamDownload));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_StartStreamDownload == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_showmessagedlg", (void**)&(pWrapperTable->m_UIEnvironment_ShowMessageDlg));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_ShowMessageDlg == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_retrieveeventsender", (void**)&(pWrapperTable->m_UIEnvironment_RetrieveEventSender));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_RetrieveEventSender == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_retrieveeventsenderpage", (void**)&(pWrapperTable->m_UIEnvironment_RetrieveEventSenderPage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_RetrieveEventSenderPage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_retrieveeventsenderuuid", (void**)&(pWrapperTable->m_UIEnvironment_RetrieveEventSenderUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_RetrieveEventSenderUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_preparesignal", (void**)&(pWrapperTable->m_UIEnvironment_PrepareSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_PrepareSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getmachinestate", (void**)&(pWrapperTable->m_UIEnvironment_GetMachineState));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetMachineState == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_logmessage", (void**)&(pWrapperTable->m_UIEnvironment_LogMessage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_LogMessage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_logwarning", (void**)&(pWrapperTable->m_UIEnvironment_LogWarning));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_LogWarning == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_loginfo", (void**)&(pWrapperTable->m_UIEnvironment_LogInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_LogInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getmachineparameter", (void**)&(pWrapperTable->m_UIEnvironment_GetMachineParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetMachineParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getmachineparameterasuuid", (void**)&(pWrapperTable->m_UIEnvironment_GetMachineParameterAsUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetMachineParameterAsUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getmachineparameterasdouble", (void**)&(pWrapperTable->m_UIEnvironment_GetMachineParameterAsDouble));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetMachineParameterAsDouble == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getmachineparameterasinteger", (void**)&(pWrapperTable->m_UIEnvironment_GetMachineParameterAsInteger));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetMachineParameterAsInteger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getmachineparameterasbool", (void**)&(pWrapperTable->m_UIEnvironment_GetMachineParameterAsBool));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetMachineParameterAsBool == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getuiproperty", (void**)&(pWrapperTable->m_UIEnvironment_GetUIProperty));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetUIProperty == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getuipropertyasuuid", (void**)&(pWrapperTable->m_UIEnvironment_GetUIPropertyAsUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetUIPropertyAsUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getuipropertyasdouble", (void**)&(pWrapperTable->m_UIEnvironment_GetUIPropertyAsDouble));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetUIPropertyAsDouble == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getuipropertyasinteger", (void**)&(pWrapperTable->m_UIEnvironment_GetUIPropertyAsInteger));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetUIPropertyAsInteger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getuipropertyasbool", (void**)&(pWrapperTable->m_UIEnvironment_GetUIPropertyAsBool));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetUIPropertyAsBool == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_setuiproperty", (void**)&(pWrapperTable->m_UIEnvironment_SetUIProperty));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_SetUIProperty == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_setuipropertyasuuid", (void**)&(pWrapperTable->m_UIEnvironment_SetUIPropertyAsUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_SetUIPropertyAsUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_setuipropertyasdouble", (void**)&(pWrapperTable->m_UIEnvironment_SetUIPropertyAsDouble));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_SetUIPropertyAsDouble == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_setuipropertyasinteger", (void**)&(pWrapperTable->m_UIEnvironment_SetUIPropertyAsInteger));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_SetUIPropertyAsInteger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_setuipropertyasbool", (void**)&(pWrapperTable->m_UIEnvironment_SetUIPropertyAsBool));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_SetUIPropertyAsBool == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createemptyimage", (void**)&(pWrapperTable->m_UIEnvironment_CreateEmptyImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateEmptyImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_loadpngimage", (void**)&(pWrapperTable->m_UIEnvironment_LoadPNGImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_LoadPNGImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getglobaltimerinmilliseconds", (void**)&(pWrapperTable->m_UIEnvironment_GetGlobalTimerInMilliseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetGlobalTimerInMilliseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getglobaltimerinmicroseconds", (void**)&(pWrapperTable->m_UIEnvironment_GetGlobalTimerInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetGlobalTimerInMicroseconds == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_gettestenvironment", (void**)&(pWrapperTable->m_UIEnvironment_GetTestEnvironment));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetTestEnvironment == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createxmldocument", (void**)&(pWrapperTable->m_UIEnvironment_CreateXMLDocument));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateXMLDocument == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_parsexmlstring", (void**)&(pWrapperTable->m_UIEnvironment_ParseXMLString));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_ParseXMLString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_parsexmldata", (void**)&(pWrapperTable->m_UIEnvironment_ParseXMLData));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_ParseXMLData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createdatatable", (void**)&(pWrapperTable->m_UIEnvironment_CreateDataTable));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateDataTable == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_hasbuildjob", (void**)&(pWrapperTable->m_UIEnvironment_HasBuildJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_HasBuildJob == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getbuildjob", (void**)&(pWrapperTable->m_UIEnvironment_GetBuildJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetBuildJob == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_hasbuildexecution", (void**)&(pWrapperTable->m_UIEnvironment_HasBuildExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_HasBuildExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getbuildexecution", (void**)&(pWrapperTable->m_UIEnvironment_GetBuildExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetBuildExecution == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_creatediscretefield2d", (void**)&(pWrapperTable->m_UIEnvironment_CreateDiscreteField2D));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateDiscreteField2D == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_creatediscretefield2dfromimage", (void**)&(pWrapperTable->m_UIEnvironment_CreateDiscreteField2DFromImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateDiscreteField2DFromImage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_checkpermission", (void**)&(pWrapperTable->m_UIEnvironment_CheckPermission));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CheckPermission == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getcurrentuserlogin", (void**)&(pWrapperTable->m_UIEnvironment_GetCurrentUserLogin));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetCurrentUserLogin == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getcurrentuserdescription", (void**)&(pWrapperTable->m_UIEnvironment_GetCurrentUserDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetCurrentUserDescription == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getcurrentuserrole", (void**)&(pWrapperTable->m_UIEnvironment_GetCurrentUserRole));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetCurrentUserRole == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getcurrentuserlanguage", (void**)&(pWrapperTable->m_UIEnvironment_GetCurrentUserLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetCurrentUserLanguage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getcurrentuseruuid", (void**)&(pWrapperTable->m_UIEnvironment_GetCurrentUserUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetCurrentUserUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createusermanagement", (void**)&(pWrapperTable->m_UIEnvironment_CreateUserManagement));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateUserManagement == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getcurrentjournal", (void**)&(pWrapperTable->m_UIEnvironment_GetCurrentJournal));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetCurrentJournal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createscenehandler", (void**)&(pWrapperTable->m_UIEnvironment_CreateSceneHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateSceneHandler == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createdataseries", (void**)&(pWrapperTable->m_UIEnvironment_CreateDataSeries));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateDataSeries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_hasdataseries", (void**)&(pWrapperTable->m_UIEnvironment_HasDataSeries));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_HasDataSeries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_finddataseries", (void**)&(pWrapperTable->m_UIEnvironment_FindDataSeries));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_FindDataSeries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_releasedataseries", (void**)&(pWrapperTable->m_UIEnvironment_ReleaseDataSeries));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_ReleaseDataSeries == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createalert", (void**)&(pWrapperTable->m_UIEnvironment_CreateAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateAlert == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_findalert", (void**)&(pWrapperTable->m_UIEnvironment_FindAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_FindAlert == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_alertexists", (void**)&(pWrapperTable->m_UIEnvironment_AlertExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_AlertExists == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_retrievealerts", (void**)&(pWrapperTable->m_UIEnvironment_RetrieveAlerts));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_RetrieveAlerts == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_retrievealertsbytype", (void**)&(pWrapperTable->m_UIEnvironment_RetrieveAlertsByType));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_RetrieveAlertsByType == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_hasalertoftype", (void**)&(pWrapperTable->m_UIEnvironment_HasAlertOfType));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_HasAlertOfType == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createcryptocontext", (void**)&(pWrapperTable->m_UIEnvironment_CreateCryptoContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateCryptoContext == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createtemporarystream", (void**)&(pWrapperTable->m_UIEnvironment_CreateTemporaryStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateTemporaryStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_createzipstream", (void**)&(pWrapperTable->m_UIEnvironment_CreateZIPStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_CreateZIPStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_loadstream", (void**)&(pWrapperTable->m_UIEnvironment_LoadStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_LoadStream == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getcurrentdatetime", (void**)&(pWrapperTable->m_UIEnvironment_GetCurrentDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetCurrentDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getcustomdatetime", (void**)&(pWrapperTable->m_UIEnvironment_GetCustomDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetCustomDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getstartdatetime", (void**)&(pWrapperTable->m_UIEnvironment_GetStartDateTime));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetStartDateTime == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_sleep", (void**)&(pWrapperTable->m_UIEnvironment_Sleep));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_Sleep == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCENV_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CIterator
	 */
	
	/**
	* CIterator::MoveNext - Iterates to the next object in the list.
	* @return Iterates to the next object in the list.
	*/
	bool CIterator::MoveNext()
	{
		bool resultHasNext = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MoveNext(m_pHandle, &resultHasNext));
		
		return resultHasNext;
	}
	
	/**
	* CIterator::MovePrevious - Iterates to the previous object in the list.
	* @return Iterates to the previous object in the list.
	*/
	bool CIterator::MovePrevious()
	{
		bool resultHasPrevious = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MovePrevious(m_pHandle, &resultHasPrevious));
		
		return resultHasPrevious;
	}
	
	/**
	* CIterator::GetCurrent - Returns the object the iterator points at.
	* @return returns the object instance.
	*/
	PBase CIterator::GetCurrent()
	{
		LibMCEnvHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_GetCurrent(m_pHandle, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBase>(m_pWrapper, hInstance);
	}
	
	/**
	* CIterator::Clone - Creates a new object iterator with the same object list.
	* @return returns the cloned Iterator instance
	*/
	PIterator CIterator::Clone()
	{
		LibMCEnvHandle hOutIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Clone(m_pHandle, &hOutIterator));
		
		if (!hOutIterator) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CIterator>(m_pWrapper, hOutIterator);
	}
	
	/**
	* CIterator::Count - Returns the number of resoucres the iterator captures.
	* @return returns the number of objects the iterator captures.
	*/
	LibMCEnv_uint64 CIterator::Count()
	{
		LibMCEnv_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CTestEnvironment
	 */
	
	/**
	* CTestEnvironment::WriteTestOutput - Write output file to test directory.
	* @param[in] sOutputName - Output file name. Only alphanumeric characters, point, underscore and hypen are allowed.
	* @param[in] DataBuffer - Test data to write into output directory.
	*/
	void CTestEnvironment::WriteTestOutput(const std::string & sOutputName, const CInputVector<LibMCEnv_uint8> & DataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_TestEnvironment_WriteTestOutput(m_pHandle, sOutputName.c_str(), (LibMCEnv_uint64)DataBuffer.size(), DataBuffer.data()));
	}
	
	/**
	 * Method definitions for class CCryptoContext
	 */
	
	/**
	* CCryptoContext::CalculateSHA256FromString - Calculates SHA256 from a string. Fails if string is empty.
	* @param[in] sValue - Input value.
	* @return SHA256 Return value.
	*/
	std::string CCryptoContext::CalculateSHA256FromString(const std::string & sValue)
	{
		LibMCEnv_uint32 bytesNeededSHA256Value = 0;
		LibMCEnv_uint32 bytesWrittenSHA256Value = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_CalculateSHA256FromString(m_pHandle, sValue.c_str(), 0, &bytesNeededSHA256Value, nullptr));
		std::vector<char> bufferSHA256Value(bytesNeededSHA256Value);
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_CalculateSHA256FromString(m_pHandle, sValue.c_str(), bytesNeededSHA256Value, &bytesWrittenSHA256Value, &bufferSHA256Value[0]));
		
		return std::string(&bufferSHA256Value[0]);
	}
	
	/**
	* CCryptoContext::CalculateSHA256FromBytes - Calculates SHA256 from a byte array. Fails if array is empty.
	* @param[in] ValueBuffer - Input value.
	* @return SHA256 Return value.
	*/
	std::string CCryptoContext::CalculateSHA256FromBytes(const CInputVector<LibMCEnv_uint8> & ValueBuffer)
	{
		LibMCEnv_uint32 bytesNeededSHA256Value = 0;
		LibMCEnv_uint32 bytesWrittenSHA256Value = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_CalculateSHA256FromBytes(m_pHandle, (LibMCEnv_uint64)ValueBuffer.size(), ValueBuffer.data(), 0, &bytesNeededSHA256Value, nullptr));
		std::vector<char> bufferSHA256Value(bytesNeededSHA256Value);
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_CalculateSHA256FromBytes(m_pHandle, (LibMCEnv_uint64)ValueBuffer.size(), ValueBuffer.data(), bytesNeededSHA256Value, &bytesWrittenSHA256Value, &bufferSHA256Value[0]));
		
		return std::string(&bufferSHA256Value[0]);
	}
	
	/**
	* CCryptoContext::NormalizeSHA256String - Normalizes a standard string into UUID format. Fails if string does not have a proper UUID format.
	* @param[in] sValue - Input value.
	* @return SHA256 Return value.
	*/
	std::string CCryptoContext::NormalizeSHA256String(const std::string & sValue)
	{
		LibMCEnv_uint32 bytesNeededSHA256Value = 0;
		LibMCEnv_uint32 bytesWrittenSHA256Value = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_NormalizeSHA256String(m_pHandle, sValue.c_str(), 0, &bytesNeededSHA256Value, nullptr));
		std::vector<char> bufferSHA256Value(bytesNeededSHA256Value);
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_NormalizeSHA256String(m_pHandle, sValue.c_str(), bytesNeededSHA256Value, &bytesWrittenSHA256Value, &bufferSHA256Value[0]));
		
		return std::string(&bufferSHA256Value[0]);
	}
	
	/**
	* CCryptoContext::CreateRandomSHA256Hash - Generates a random SHA256 hash value with operating system APIs.
	* @return SHA256 Return value.
	*/
	std::string CCryptoContext::CreateRandomSHA256Hash()
	{
		LibMCEnv_uint32 bytesNeededSHA256Value = 0;
		LibMCEnv_uint32 bytesWrittenSHA256Value = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_CreateRandomSHA256Hash(m_pHandle, 0, &bytesNeededSHA256Value, nullptr));
		std::vector<char> bufferSHA256Value(bytesNeededSHA256Value);
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_CreateRandomSHA256Hash(m_pHandle, bytesNeededSHA256Value, &bytesWrittenSHA256Value, &bufferSHA256Value[0]));
		
		return std::string(&bufferSHA256Value[0]);
	}
	
	/**
	* CCryptoContext::CreateUUID - Generates a random UUID with operating system APIs.
	* @return UUID Return value.
	*/
	std::string CCryptoContext::CreateUUID()
	{
		LibMCEnv_uint32 bytesNeededUUIDValue = 0;
		LibMCEnv_uint32 bytesWrittenUUIDValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_CreateUUID(m_pHandle, 0, &bytesNeededUUIDValue, nullptr));
		std::vector<char> bufferUUIDValue(bytesNeededUUIDValue);
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_CreateUUID(m_pHandle, bytesNeededUUIDValue, &bytesWrittenUUIDValue, &bufferUUIDValue[0]));
		
		return std::string(&bufferUUIDValue[0]);
	}
	
	/**
	* CCryptoContext::NormalizeUUIDString - Normalizes a standard string into UUID format. Fails if string does not have a proper UUID format.
	* @param[in] sValue - Input value.
	* @return UUID Return value.
	*/
	std::string CCryptoContext::NormalizeUUIDString(const std::string & sValue)
	{
		LibMCEnv_uint32 bytesNeededUUIDValue = 0;
		LibMCEnv_uint32 bytesWrittenUUIDValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_NormalizeUUIDString(m_pHandle, sValue.c_str(), 0, &bytesNeededUUIDValue, nullptr));
		std::vector<char> bufferUUIDValue(bytesNeededUUIDValue);
		CheckError(m_pWrapper->m_WrapperTable.m_CryptoContext_NormalizeUUIDString(m_pHandle, sValue.c_str(), bytesNeededUUIDValue, &bytesWrittenUUIDValue, &bufferUUIDValue[0]));
		
		return std::string(&bufferUUIDValue[0]);
	}
	
	/**
	 * Method definitions for class CPNGImageStoreOptions
	 */
	
	/**
	* CPNGImageStoreOptions::ResetToDefaults - Resets Options to default.
	*/
	void CPNGImageStoreOptions::ResetToDefaults()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PNGImageStoreOptions_ResetToDefaults(m_pHandle));
	}
	
	/**
	 * Method definitions for class CPNGImageData
	 */
	
	/**
	* CPNGImageData::GetSizeInPixels - Returns image pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	void CPNGImageData::GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PNGImageData_GetSizeInPixels(m_pHandle, &nPixelSizeX, &nPixelSizeY));
	}
	
	/**
	* CPNGImageData::GetPNGDataStream - Retrieves encoded data stream of image object.
	* @param[out] PNGDataBuffer - PNG Data stream.
	*/
	void CPNGImageData::GetPNGDataStream(std::vector<LibMCEnv_uint8> & PNGDataBuffer)
	{
		LibMCEnv_uint64 elementsNeededPNGData = 0;
		LibMCEnv_uint64 elementsWrittenPNGData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PNGImageData_GetPNGDataStream(m_pHandle, 0, &elementsNeededPNGData, nullptr));
		PNGDataBuffer.resize((size_t) elementsNeededPNGData);
		CheckError(m_pWrapper->m_WrapperTable.m_PNGImageData_GetPNGDataStream(m_pHandle, elementsNeededPNGData, &elementsWrittenPNGData, PNGDataBuffer.data()));
	}
	
	/**
	 * Method definitions for class CImageData
	 */
	
	/**
	* CImageData::GetPixelFormat - Returns Pixel format of the image.
	* @return Pixel Format of image
	*/
	eImagePixelFormat CImageData::GetPixelFormat()
	{
		eImagePixelFormat resultPixelFormat = (eImagePixelFormat) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_GetPixelFormat(m_pHandle, &resultPixelFormat));
		
		return resultPixelFormat;
	}
	
	/**
	* CImageData::ChangePixelFormat - Changes Pixel format of the image. Might lose alpha or color information during the process.
	* @param[in] ePixelFormat - new Pixel Format of image
	*/
	void CImageData::ChangePixelFormat(const eImagePixelFormat ePixelFormat)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_ChangePixelFormat(m_pHandle, ePixelFormat));
	}
	
	/**
	* CImageData::GetDPI - Returns DPI values in X and Y.
	* @param[out] dDPIValueX - DPI value in X
	* @param[out] dDPIValueY - DPI value in Y
	*/
	void CImageData::GetDPI(LibMCEnv_double & dDPIValueX, LibMCEnv_double & dDPIValueY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_GetDPI(m_pHandle, &dDPIValueX, &dDPIValueY));
	}
	
	/**
	* CImageData::SetDPI - Sets DPI values in X and Y.
	* @param[in] dDPIValueX - new DPI value in X
	* @param[in] dDPIValueY - new DPI value in Y
	*/
	void CImageData::SetDPI(const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_SetDPI(m_pHandle, dDPIValueX, dDPIValueY));
	}
	
	/**
	* CImageData::GetSizeInMM - Returns image sizes inmm.
	* @param[out] dSizeX - Size in X in mm
	* @param[out] dSizeY - Size in Y in mm
	*/
	void CImageData::GetSizeInMM(LibMCEnv_double & dSizeX, LibMCEnv_double & dSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_GetSizeInMM(m_pHandle, &dSizeX, &dSizeY));
	}
	
	/**
	* CImageData::GetSizeInPixels - Returns image pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	void CImageData::GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_GetSizeInPixels(m_pHandle, &nPixelSizeX, &nPixelSizeY));
	}
	
	/**
	* CImageData::ResizeImage - Resizes Image pixel data.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	void CImageData::ResizeImage(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_ResizeImage(m_pHandle, &nPixelSizeX, &nPixelSizeY));
	}
	
	/**
	* CImageData::CreatePNGImage - Creates PNG Image out of the pixel data.
	* @param[in] pPNGStorageOptions - Optional encoding options for the image.
	* @return Image data.
	*/
	PPNGImageData CImageData::CreatePNGImage(classParam<CPNGImageStoreOptions> pPNGStorageOptions)
	{
		LibMCEnvHandle hPNGStorageOptions = pPNGStorageOptions.GetHandle();
		LibMCEnvHandle hPNGImage = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_CreatePNGImage(m_pHandle, hPNGStorageOptions, &hPNGImage));
		
		if (!hPNGImage) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPNGImageData>(m_pWrapper, hPNGImage);
	}
	
	/**
	* CImageData::EncodePNG - Depreciated. DO NOT USE. Encodes PNG and stores data stream in image object.
	*/
	void CImageData::EncodePNG()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_EncodePNG(m_pHandle));
	}
	
	/**
	* CImageData::GetEncodedPNGData - Depreciated. DO NOT USE. Retrieves encoded data stream of image object. MUST have been encoded with EncodePNG before.
	* @param[out] PNGDataBuffer - PNG Data stream.
	*/
	void CImageData::GetEncodedPNGData(std::vector<LibMCEnv_uint8> & PNGDataBuffer)
	{
		LibMCEnv_uint64 elementsNeededPNGData = 0;
		LibMCEnv_uint64 elementsWrittenPNGData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_GetEncodedPNGData(m_pHandle, 0, &elementsNeededPNGData, nullptr));
		PNGDataBuffer.resize((size_t) elementsNeededPNGData);
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_GetEncodedPNGData(m_pHandle, elementsNeededPNGData, &elementsWrittenPNGData, PNGDataBuffer.data()));
	}
	
	/**
	* CImageData::ClearEncodedPNGData - Depreciated. DO NOT USE. Releases encoded data stream of image object. Depreciated.
	*/
	void CImageData::ClearEncodedPNGData()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_ClearEncodedPNGData(m_pHandle));
	}
	
	/**
	* CImageData::Clear - Sets all pixels to a single value.
	* @param[in] nValue - Pixel value.
	*/
	void CImageData::Clear(const LibMCEnv_uint32 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_Clear(m_pHandle, nValue));
	}
	
	/**
	* CImageData::GetPixel - Returns one pixel of an image.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @return Pixel value at this position
	*/
	LibMCEnv_uint32 CImageData::GetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY)
	{
		LibMCEnv_uint32 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_GetPixel(m_pHandle, nX, nY, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CImageData::SetPixel - Sets one pixel of an image.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @param[in] nValue - New Pixel value at this position
	*/
	void CImageData::SetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY, const LibMCEnv_uint32 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_SetPixel(m_pHandle, nX, nY, nValue));
	}
	
	/**
	* CImageData::GetPixelRange - Returns a subset of an image or the whole image data. DEPRECIATED.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within image bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within image bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within image bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within image bounds. MUST be larger or equal than MinY
	* @param[out] ValueBuffer - Pixel values of the rectangle, rowwise array. Will return the exact number of pixels in size and 1, 3 or 4 bytes per pixel, depending on pixel format.
	*/
	void CImageData::GetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, std::vector<LibMCEnv_uint8> & ValueBuffer)
	{
		LibMCEnv_uint64 elementsNeededValue = 0;
		LibMCEnv_uint64 elementsWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_GetPixelRange(m_pHandle, nXMin, nYMin, nXMax, nYMax, 0, &elementsNeededValue, nullptr));
		ValueBuffer.resize((size_t) elementsNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_GetPixelRange(m_pHandle, nXMin, nYMin, nXMax, nYMax, elementsNeededValue, &elementsWrittenValue, ValueBuffer.data()));
	}
	
	/**
	* CImageData::SetPixelRange - Exchanges a subset of an image or the whole image data. DEPRECIATED.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within image bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within image bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within image bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within image bounds. MUST be larger or equal than MinY
	* @param[in] ValueBuffer - New pixel values of the rectangle, rowwise array. MUST have the exact number of pixels in size and 1, 3 or 4 bytes per pixel, depending on pixel format.
	*/
	void CImageData::SetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, const CInputVector<LibMCEnv_uint8> & ValueBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageData_SetPixelRange(m_pHandle, nXMin, nYMin, nXMax, nYMax, (LibMCEnv_uint64)ValueBuffer.size(), ValueBuffer.data()));
	}
	
	/**
	 * Method definitions for class CDiscreteFieldData2DStoreOptions
	 */
	
	/**
	* CDiscreteFieldData2DStoreOptions::ResetToDefaults - Resets Options to default.
	*/
	void CDiscreteFieldData2DStoreOptions::ResetToDefaults()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2DStoreOptions_ResetToDefaults(m_pHandle));
	}
	
	/**
	 * Method definitions for class CDiscreteFieldData2D
	 */
	
	/**
	* CDiscreteFieldData2D::GetDPI - Returns DPI values in X and Y.
	* @param[out] dDPIValueX - DPI value in X
	* @param[out] dDPIValueY - DPI value in Y
	*/
	void CDiscreteFieldData2D::GetDPI(LibMCEnv_double & dDPIValueX, LibMCEnv_double & dDPIValueY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_GetDPI(m_pHandle, &dDPIValueX, &dDPIValueY));
	}
	
	/**
	* CDiscreteFieldData2D::SetDPI - Sets DPI values in X and Y.
	* @param[in] dDPIValueX - new DPI value in X. MUST be positive.
	* @param[in] dDPIValueY - new DPI value in Y. MUST be positive.
	*/
	void CDiscreteFieldData2D::SetDPI(const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_SetDPI(m_pHandle, dDPIValueX, dDPIValueY));
	}
	
	/**
	* CDiscreteFieldData2D::GetOriginInMM - Returns field origin in mm.
	* @param[out] dOriginX - Origin in X in mm
	* @param[out] dOriginY - Origin in Y in mm
	*/
	void CDiscreteFieldData2D::GetOriginInMM(LibMCEnv_double & dOriginX, LibMCEnv_double & dOriginY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_GetOriginInMM(m_pHandle, &dOriginX, &dOriginY));
	}
	
	/**
	* CDiscreteFieldData2D::SetOriginInMM - Set field origin in mm.
	* @param[in] dOriginX - Origin in X in mm
	* @param[in] dOriginY - Origin in Y in mm
	*/
	void CDiscreteFieldData2D::SetOriginInMM(const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_SetOriginInMM(m_pHandle, dOriginX, dOriginY));
	}
	
	/**
	* CDiscreteFieldData2D::GetSizeInMM - Returns field sizes in mm.
	* @param[out] dSizeX - Size in X in mm
	* @param[out] dSizeY - Size in Y in mm
	*/
	void CDiscreteFieldData2D::GetSizeInMM(LibMCEnv_double & dSizeX, LibMCEnv_double & dSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_GetSizeInMM(m_pHandle, &dSizeX, &dSizeY));
	}
	
	/**
	* CDiscreteFieldData2D::GetSizeInPixels - Returns field pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	void CDiscreteFieldData2D::GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_GetSizeInPixels(m_pHandle, &nPixelSizeX, &nPixelSizeY));
	}
	
	/**
	* CDiscreteFieldData2D::ResizeField - Resizes field pixel data.
	* @param[in] nPixelSizeX - Number of pixels in X
	* @param[in] nPixelSizeY - Number of pixels in Y
	* @param[in] dDefaultValue - Default Pixel value.
	*/
	void CDiscreteFieldData2D::ResizeField(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_ResizeField(m_pHandle, nPixelSizeX, nPixelSizeY, dDefaultValue));
	}
	
	/**
	* CDiscreteFieldData2D::Clear - Sets all pixels to a single value.
	* @param[in] dValue - Pixel value.
	*/
	void CDiscreteFieldData2D::Clear(const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_Clear(m_pHandle, dValue));
	}
	
	/**
	* CDiscreteFieldData2D::Clamp - Clamps all pixels to a certain interval.
	* @param[in] dMinValue - Minimum value. MUST be smaller or equal than MaxValue.
	* @param[in] dMaxValue - Maximum value. MUST be larger or equal than MinValue.
	*/
	void CDiscreteFieldData2D::Clamp(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_Clamp(m_pHandle, dMinValue, dMaxValue));
	}
	
	/**
	* CDiscreteFieldData2D::GetPixel - Returns one pixel of an field. Fails if outside of field size.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @return Pixel value at this position
	*/
	LibMCEnv_double CDiscreteFieldData2D::GetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_GetPixel(m_pHandle, nX, nY, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CDiscreteFieldData2D::SetPixel - Sets one pixel of an field. Fails if outside of field size.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @param[in] dValue - New Pixel value at this position
	*/
	void CDiscreteFieldData2D::SetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_SetPixel(m_pHandle, nX, nY, dValue));
	}
	
	/**
	* CDiscreteFieldData2D::GetPixelRange - Returns a subset of an field or the whole field data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within field bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within field bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within field bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within field bounds. MUST be larger or equal than MinY
	* @param[out] ValueBuffer - Pixel values of the rectangle, rowwise array. Will return the exact number of pixels in size.
	*/
	void CDiscreteFieldData2D::GetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, std::vector<LibMCEnv_double> & ValueBuffer)
	{
		LibMCEnv_uint64 elementsNeededValue = 0;
		LibMCEnv_uint64 elementsWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_GetPixelRange(m_pHandle, nXMin, nYMin, nXMax, nYMax, 0, &elementsNeededValue, nullptr));
		ValueBuffer.resize((size_t) elementsNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_GetPixelRange(m_pHandle, nXMin, nYMin, nXMax, nYMax, elementsNeededValue, &elementsWrittenValue, ValueBuffer.data()));
	}
	
	/**
	* CDiscreteFieldData2D::SetPixelRange - Exchanges a subset of an field or the whole field data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within field bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within field bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within field bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within field bounds. MUST be larger or equal than MinY
	* @param[in] ValueBuffer - New pixel values of the rectangle, rowwise array. MUST have the exact number of pixels in size.
	*/
	void CDiscreteFieldData2D::SetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, const CInputVector<LibMCEnv_double> & ValueBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_SetPixelRange(m_pHandle, nXMin, nYMin, nXMax, nYMax, (LibMCEnv_uint64)ValueBuffer.size(), ValueBuffer.data()));
	}
	
	/**
	* CDiscreteFieldData2D::RenderAveragePointValues - Renders and array of average point values into the field. 
	* @param[in] dDefaultValue - If a pixel does not contain any value, fall back to this given value.
	* @param[in] eSamplingMode - Sampling mode of point values.
	* @param[in] dSampleSizeX - How large a sample point should be drawn in Pixel widths. This determines the weighting when a point value overlaps multiple pixels. Ignored if SamplingMode is equal FloorCoordinate or CeilCoordinate. MUST be positive otherwise.
	* @param[in] dSampleSizeY - How large a sample point should be drawn in Pixel heights. This determines the weighting when a point value overlaps multiple pixels. Ignored if SamplingMode is equal FloorCoordinate or CeilCoordinate. MUST be positive otherwise.
	* @param[in] PointValuesBuffer - Array of Field Data Points that are sorted into the grid. If a point lies on a grid border, it will be counted to all adjacent pixels.
	*/
	void CDiscreteFieldData2D::RenderAveragePointValues(const LibMCEnv_double dDefaultValue, const eFieldSamplingMode eSamplingMode, const LibMCEnv_double dSampleSizeX, const LibMCEnv_double dSampleSizeY, const CInputVector<sFieldData2DPoint> & PointValuesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_RenderAveragePointValues(m_pHandle, dDefaultValue, eSamplingMode, dSampleSizeX, dSampleSizeY, (LibMCEnv_uint64)PointValuesBuffer.size(), PointValuesBuffer.data()));
	}
	
	/**
	* CDiscreteFieldData2D::ScaleFieldDown - Scales the field to a smaller size.
	* @param[in] nFactorX - The new field will be this factor smaller in X. MUST be positive and smaller than PixelSizeX
	* @param[in] nFactorY - The new field will be this factor smaller in Y. MUST be positive and smaller than PixelSizeY
	* @return Scaled Field Instance
	*/
	PDiscreteFieldData2D CDiscreteFieldData2D::ScaleFieldDown(const LibMCEnv_uint32 nFactorX, const LibMCEnv_uint32 nFactorY)
	{
		LibMCEnvHandle hNewField = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_ScaleFieldDown(m_pHandle, nFactorX, nFactorY, &hNewField));
		
		if (!hNewField) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hNewField);
	}
	
	/**
	* CDiscreteFieldData2D::ScaleFieldUp - Scales the field to a larger size.
	* @param[in] nFactorX - The new field will be this factor larger in X. MUST be positive.
	* @param[in] nFactorY - The new field will be this factor larger in Y. MUST be positive.
	* @return Scaled Field Instance
	*/
	PDiscreteFieldData2D CDiscreteFieldData2D::ScaleFieldUp(const LibMCEnv_uint32 nFactorX, const LibMCEnv_uint32 nFactorY)
	{
		LibMCEnvHandle hNewField = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_ScaleFieldUp(m_pHandle, nFactorX, nFactorY, &hNewField));
		
		if (!hNewField) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hNewField);
	}
	
	/**
	* CDiscreteFieldData2D::Discretize - Discretizes the field into a finite set of values. All field values will be set to the nearest value in the given array. Equivalent to DiscretizeWithMapping with two identical parameters.
	* @param[in] DiscreteValuesBuffer - An array of values. MUST NOT be empty.
	*/
	void CDiscreteFieldData2D::Discretize(const CInputVector<LibMCEnv_double> & DiscreteValuesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_Discretize(m_pHandle, (LibMCEnv_uint64)DiscreteValuesBuffer.size(), DiscreteValuesBuffer.data()));
	}
	
	/**
	* CDiscreteFieldData2D::DiscretizeWithMapping - Discretizes the field into a finite set of DiscreteValues. For each field value the nearest DiscreteValue is determined, and the field is set to the element of NewValues with the same index.
	* @param[in] DiscreteValuesBuffer - An array of values. MUST NOT be empty.  
	* @param[in] NewValuesBuffer - An array of values. MUST have the same cardinality as DiscreteValues.
	*/
	void CDiscreteFieldData2D::DiscretizeWithMapping(const CInputVector<LibMCEnv_double> & DiscreteValuesBuffer, const CInputVector<LibMCEnv_double> & NewValuesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_DiscretizeWithMapping(m_pHandle, (LibMCEnv_uint64)DiscreteValuesBuffer.size(), DiscreteValuesBuffer.data(), (LibMCEnv_uint64)NewValuesBuffer.size(), NewValuesBuffer.data()));
	}
	
	/**
	* CDiscreteFieldData2D::RenderToImageRaw - Renders the field into a PNG image. The colors will be linearly interpolated into a given color scheme.
	* @param[in] dMinValue - Min point value. Values smaller than MinValue will be clamped to MinValue.
	* @param[in] MinColor - The color assigned to MinValue.
	* @param[in] dMidValue - Mid point value. MUST be at least 1E-6 larger than MinValue.
	* @param[in] MidColor - The color assigned to MidValue
	* @param[in] dMaxValue - Max point value. MUST be at least 1E-6 larger than MidValue. Values larger than MaxValue will be clamped to MaxValue.
	* @param[in] MaxColor - The color assigned to MaxValue
	* @return New Image with the according data. Pixel size and DPI will be equal to the field. Pixel format will be RGB24bit.
	*/
	PImageData CDiscreteFieldData2D::RenderToImageRaw(const LibMCEnv_double dMinValue, const sColorRGB & MinColor, const LibMCEnv_double dMidValue, const sColorRGB & MidColor, const LibMCEnv_double dMaxValue, const sColorRGB & MaxColor)
	{
		LibMCEnvHandle hNewImage = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_RenderToImageRaw(m_pHandle, dMinValue, &MinColor, dMidValue, &MidColor, dMaxValue, &MaxColor, &hNewImage));
		
		if (!hNewImage) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hNewImage);
	}
	
	/**
	* CDiscreteFieldData2D::TransformField - Scales the field values with a factor and a translation.
	* @param[in] dScale - A scaling factor will be applied to all values in the field.
	* @param[in] dOffset - The offset will be applied to all values in the field after scaling.
	*/
	void CDiscreteFieldData2D::TransformField(const LibMCEnv_double dScale, const LibMCEnv_double dOffset)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_TransformField(m_pHandle, dScale, dOffset));
	}
	
	/**
	* CDiscreteFieldData2D::AddField - Adds another field to the field. Both fields MUST have the same pixel extensions.
	* @param[in] pOtherField - Field Instance to add
	* @param[in] dScale - A scaling factor will be applied to all values in the other field before adding.
	* @param[in] dOffset - The offset will be applied to all values in the field after scaling.
	*/
	void CDiscreteFieldData2D::AddField(classParam<CDiscreteFieldData2D> pOtherField, const LibMCEnv_double dScale, const LibMCEnv_double dOffset)
	{
		LibMCEnvHandle hOtherField = pOtherField.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_AddField(m_pHandle, hOtherField, dScale, dOffset));
	}
	
	/**
	* CDiscreteFieldData2D::Duplicate - Creates a copy of the field.
	* @return Scaled Field Instance
	*/
	PDiscreteFieldData2D CDiscreteFieldData2D::Duplicate()
	{
		LibMCEnvHandle hNewField = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DiscreteFieldData2D_Duplicate(m_pHandle, &hNewField));
		
		if (!hNewField) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hNewField);
	}
	
	/**
	 * Method definitions for class CDataTableWriteOptions
	 */
	
	/**
	 * Method definitions for class CDataTableCSVWriteOptions
	 */
	
	/**
	* CDataTableCSVWriteOptions::GetSeparator - Returns the desired separator of the CSV file. Default is semicolon.
	* @return Separator to use.
	*/
	std::string CDataTableCSVWriteOptions::GetSeparator()
	{
		LibMCEnv_uint32 bytesNeededSeparator = 0;
		LibMCEnv_uint32 bytesWrittenSeparator = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTableCSVWriteOptions_GetSeparator(m_pHandle, 0, &bytesNeededSeparator, nullptr));
		std::vector<char> bufferSeparator(bytesNeededSeparator);
		CheckError(m_pWrapper->m_WrapperTable.m_DataTableCSVWriteOptions_GetSeparator(m_pHandle, bytesNeededSeparator, &bytesWrittenSeparator, &bufferSeparator[0]));
		
		return std::string(&bufferSeparator[0]);
	}
	
	/**
	* CDataTableCSVWriteOptions::SetSeparator - Sets the desired separator of the CSV file.
	* @param[in] sSeparator - Separator to use. MUST be a single character ASCII string. (ASCII Code 32-127)
	*/
	void CDataTableCSVWriteOptions::SetSeparator(const std::string & sSeparator)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataTableCSVWriteOptions_SetSeparator(m_pHandle, sSeparator.c_str()));
	}
	
	/**
	 * Method definitions for class CDataTable
	 */
	
	/**
	* CDataTable::AddColumn - Adds a column to the data field.
	* @param[in] sIdentifier - Identifier of the column. MUST be unique, alphanumeric and not empty.
	* @param[in] sDescription - Description of the column.
	* @param[in] eColumnType - Data type of the column.
	*/
	void CDataTable::AddColumn(const std::string & sIdentifier, const std::string & sDescription, const eDataTableColumnType eColumnType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_AddColumn(m_pHandle, sIdentifier.c_str(), sDescription.c_str(), eColumnType));
	}
	
	/**
	* CDataTable::RemoveColumn - Removes a column from the data field. Fails if Column does not exist.
	* @param[in] sIdentifier - Identifier of the column.
	*/
	void CDataTable::RemoveColumn(const std::string & sIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_RemoveColumn(m_pHandle, sIdentifier.c_str()));
	}
	
	/**
	* CDataTable::Clear - Clears all data from the data table.
	*/
	void CDataTable::Clear()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_Clear(m_pHandle));
	}
	
	/**
	* CDataTable::HasColumn - Returns if a column exists in the data field.
	* @param[in] sIdentifier - Identifier of the column.
	* @return Returns if the columns exist.
	*/
	bool CDataTable::HasColumn(const std::string & sIdentifier)
	{
		bool resultColumnExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_HasColumn(m_pHandle, sIdentifier.c_str(), &resultColumnExists));
		
		return resultColumnExists;
	}
	
	/**
	* CDataTable::GetRowCount - Returns the current row count.
	* @return Number of rows.
	*/
	LibMCEnv_uint32 CDataTable::GetRowCount()
	{
		LibMCEnv_uint32 resultRowCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetRowCount(m_pHandle, &resultRowCount));
		
		return resultRowCount;
	}
	
	/**
	* CDataTable::GetColumnCount - Returns the current column count.
	* @return Number of columns.
	*/
	LibMCEnv_uint32 CDataTable::GetColumnCount()
	{
		LibMCEnv_uint32 resultColumnCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetColumnCount(m_pHandle, &resultColumnCount));
		
		return resultColumnCount;
	}
	
	/**
	* CDataTable::GetColumnIdentifier - Returns the identifier of a column. Will fail if Index is out of bounds.
	* @param[in] nColumnIndex - Index of column. 0-based.
	* @return Identifier of the column.
	*/
	std::string CDataTable::GetColumnIdentifier(const LibMCEnv_uint32 nColumnIndex)
	{
		LibMCEnv_uint32 bytesNeededIdentifier = 0;
		LibMCEnv_uint32 bytesWrittenIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetColumnIdentifier(m_pHandle, nColumnIndex, 0, &bytesNeededIdentifier, nullptr));
		std::vector<char> bufferIdentifier(bytesNeededIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetColumnIdentifier(m_pHandle, nColumnIndex, bytesNeededIdentifier, &bytesWrittenIdentifier, &bufferIdentifier[0]));
		
		return std::string(&bufferIdentifier[0]);
	}
	
	/**
	* CDataTable::GetColumnDescription - Returns the description of a column. Will fail if Index is out of bounds.
	* @param[in] nColumnIndex - Index of column. 0-based.
	* @return Description of the column.
	*/
	std::string CDataTable::GetColumnDescription(const LibMCEnv_uint32 nColumnIndex)
	{
		LibMCEnv_uint32 bytesNeededDescription = 0;
		LibMCEnv_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetColumnDescription(m_pHandle, nColumnIndex, 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetColumnDescription(m_pHandle, nColumnIndex, bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CDataTable::GetColumnType - Returns the type of a column. Will fail if Index is out of bounds.
	* @param[in] nColumnIndex - Index of column. 0-based.
	* @return Data type of the column.
	*/
	eDataTableColumnType CDataTable::GetColumnType(const LibMCEnv_uint32 nColumnIndex)
	{
		eDataTableColumnType resultColumnType = (eDataTableColumnType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetColumnType(m_pHandle, nColumnIndex, &resultColumnType));
		
		return resultColumnType;
	}
	
	/**
	* CDataTable::GetColumnInformation - Returns the values of a double column. Will fail if column does not exist or type is not double.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[out] sDescription - Description of the column.
	* @param[out] eColumnType - Data type of the column.
	*/
	void CDataTable::GetColumnInformation(const std::string & sIdentifier, std::string & sDescription, eDataTableColumnType & eColumnType)
	{
		LibMCEnv_uint32 bytesNeededDescription = 0;
		LibMCEnv_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetColumnInformation(m_pHandle, sIdentifier.c_str(), 0, &bytesNeededDescription, nullptr, &eColumnType));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetColumnInformation(m_pHandle, sIdentifier.c_str(), bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], &eColumnType));
		sDescription = std::string(&bufferDescription[0]);
	}
	
	/**
	* CDataTable::GetDoubleColumnValues - Returns the values of a double column. Will fail if column does not exist or type is not double.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[out] ValuesBuffer - Value array of a column.
	*/
	void CDataTable::GetDoubleColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_double> & ValuesBuffer)
	{
		LibMCEnv_uint64 elementsNeededValues = 0;
		LibMCEnv_uint64 elementsWrittenValues = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetDoubleColumnValues(m_pHandle, sIdentifier.c_str(), 0, &elementsNeededValues, nullptr));
		ValuesBuffer.resize((size_t) elementsNeededValues);
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetDoubleColumnValues(m_pHandle, sIdentifier.c_str(), elementsNeededValues, &elementsWrittenValues, ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::GetInt32ColumnValues - Returns the double columns. Will fail if column does not exist or type is not int32.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[out] ValuesBuffer - Value array of a column.
	*/
	void CDataTable::GetInt32ColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_int32> & ValuesBuffer)
	{
		LibMCEnv_uint64 elementsNeededValues = 0;
		LibMCEnv_uint64 elementsWrittenValues = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetInt32ColumnValues(m_pHandle, sIdentifier.c_str(), 0, &elementsNeededValues, nullptr));
		ValuesBuffer.resize((size_t) elementsNeededValues);
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetInt32ColumnValues(m_pHandle, sIdentifier.c_str(), elementsNeededValues, &elementsWrittenValues, ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::GetInt64ColumnValues - Returns the double columns. Will fail if column does not exist or type is not int64.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[out] ValuesBuffer - Value array of a column.
	*/
	void CDataTable::GetInt64ColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_int64> & ValuesBuffer)
	{
		LibMCEnv_uint64 elementsNeededValues = 0;
		LibMCEnv_uint64 elementsWrittenValues = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetInt64ColumnValues(m_pHandle, sIdentifier.c_str(), 0, &elementsNeededValues, nullptr));
		ValuesBuffer.resize((size_t) elementsNeededValues);
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetInt64ColumnValues(m_pHandle, sIdentifier.c_str(), elementsNeededValues, &elementsWrittenValues, ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::GetUint32ColumnValues - Returns the double columns. Will fail if column does not exist or type is not uint32.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[out] ValuesBuffer - Value array of a column.
	*/
	void CDataTable::GetUint32ColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_uint32> & ValuesBuffer)
	{
		LibMCEnv_uint64 elementsNeededValues = 0;
		LibMCEnv_uint64 elementsWrittenValues = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetUint32ColumnValues(m_pHandle, sIdentifier.c_str(), 0, &elementsNeededValues, nullptr));
		ValuesBuffer.resize((size_t) elementsNeededValues);
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetUint32ColumnValues(m_pHandle, sIdentifier.c_str(), elementsNeededValues, &elementsWrittenValues, ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::GetUint64ColumnValues - Returns the double columns. Will fail if column does not exist or type is not uint64.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[out] ValuesBuffer - Value array of a column.
	*/
	void CDataTable::GetUint64ColumnValues(const std::string & sIdentifier, std::vector<LibMCEnv_uint64> & ValuesBuffer)
	{
		LibMCEnv_uint64 elementsNeededValues = 0;
		LibMCEnv_uint64 elementsWrittenValues = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetUint64ColumnValues(m_pHandle, sIdentifier.c_str(), 0, &elementsNeededValues, nullptr));
		ValuesBuffer.resize((size_t) elementsNeededValues);
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_GetUint64ColumnValues(m_pHandle, sIdentifier.c_str(), elementsNeededValues, &elementsWrittenValues, ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::SetDoubleColumnValues - Sets the values of a double column. Will fail if column does not exist or type is not double.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] ValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	void CDataTable::SetDoubleColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_double> & ValuesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_SetDoubleColumnValues(m_pHandle, sIdentifier.c_str(), (LibMCEnv_uint64)ValuesBuffer.size(), ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::SetInt32ColumnValues - Sets the double columns. Will fail if column does not exist or type is not int32.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] ValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	void CDataTable::SetInt32ColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_int32> & ValuesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_SetInt32ColumnValues(m_pHandle, sIdentifier.c_str(), (LibMCEnv_uint64)ValuesBuffer.size(), ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::SetInt64ColumnValues - Sets the double columns. Will fail if column does not exist or type is not int64.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] ValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	void CDataTable::SetInt64ColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_int64> & ValuesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_SetInt64ColumnValues(m_pHandle, sIdentifier.c_str(), (LibMCEnv_uint64)ValuesBuffer.size(), ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::SetUint32ColumnValues - Sets the double columns. Will fail if column does not exist or type is not uint32.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] ValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	void CDataTable::SetUint32ColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_uint32> & ValuesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_SetUint32ColumnValues(m_pHandle, sIdentifier.c_str(), (LibMCEnv_uint64)ValuesBuffer.size(), ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::SetUint64ColumnValues - Sets the double columns. Will fail if column does not exist or type is not uint64.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] ValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	void CDataTable::SetUint64ColumnValues(const std::string & sIdentifier, const CInputVector<LibMCEnv_uint64> & ValuesBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_SetUint64ColumnValues(m_pHandle, sIdentifier.c_str(), (LibMCEnv_uint64)ValuesBuffer.size(), ValuesBuffer.data()));
	}
	
	/**
	* CDataTable::CreateWriteOptions - Creates a Write Option.
	* @return Writer Options Instance to pass on to WriteDataToStream.
	*/
	PDataTableWriteOptions CDataTable::CreateWriteOptions()
	{
		LibMCEnvHandle hOptions = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_CreateWriteOptions(m_pHandle, &hOptions));
		
		if (!hOptions) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataTableWriteOptions>(m_pWrapper, hOptions);
	}
	
	/**
	* CDataTable::CreateCSVWriteOptions - Creates a CSV Write Option.
	* @return Writer Options Instance to pass on to WriteCSVToStream.
	*/
	PDataTableCSVWriteOptions CDataTable::CreateCSVWriteOptions()
	{
		LibMCEnvHandle hOptions = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_CreateCSVWriteOptions(m_pHandle, &hOptions));
		
		if (!hOptions) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataTableCSVWriteOptions>(m_pWrapper, hOptions);
	}
	
	/**
	* CDataTable::WriteCSVToStream - Writes the data as CSV to a temporary stream.
	* @param[in] pWriter - Stream writer to use.
	* @param[in] pOptions - Optional CSV writer options to use.
	*/
	void CDataTable::WriteCSVToStream(classParam<CTempStreamWriter> pWriter, classParam<CDataTableCSVWriteOptions> pOptions)
	{
		LibMCEnvHandle hWriter = pWriter.GetHandle();
		LibMCEnvHandle hOptions = pOptions.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_WriteCSVToStream(m_pHandle, hWriter, hOptions));
	}
	
	/**
	* CDataTable::WriteDataToStream - Writes the data as binary to a temporary stream.
	* @param[in] pWriter - Stream writer instance to use.
	* @param[in] pOptions - Optional writer options to use.
	*/
	void CDataTable::WriteDataToStream(classParam<CTempStreamWriter> pWriter, classParam<CDataTableWriteOptions> pOptions)
	{
		LibMCEnvHandle hWriter = pWriter.GetHandle();
		LibMCEnvHandle hOptions = pOptions.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_WriteDataToStream(m_pHandle, hWriter, hOptions));
	}
	
	/**
	* CDataTable::LoadFromStream - Loads the data table from a stream. Clears all existing data from the data table.
	* @param[in] pStream - Stream read instance to read from.
	*/
	void CDataTable::LoadFromStream(classParam<CStreamReader> pStream)
	{
		LibMCEnvHandle hStream = pStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_DataTable_LoadFromStream(m_pHandle, hStream));
	}
	
	/**
	 * Method definitions for class CDataSeries
	 */
	
	/**
	* CDataSeries::GetName - Returns the name of the data series.
	* @return Returns the name.
	*/
	std::string CDataSeries::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CDataSeries::GetUUID - Returns the UUID of the data series.
	* @return Returns uuid.
	*/
	std::string CDataSeries::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CDataSeries::Clear - Clears all entries of the data series.
	*/
	void CDataSeries::Clear()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_Clear(m_pHandle));
	}
	
	/**
	* CDataSeries::IsEmpty - Checks if data series is empty.
	* @return Returns true if data series has no entries.
	*/
	bool CDataSeries::IsEmpty()
	{
		bool resultEmptyValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_IsEmpty(m_pHandle, &resultEmptyValue));
		
		return resultEmptyValue;
	}
	
	/**
	* CDataSeries::GetMinimum - Returns the minimum time stamp of the data series. Fails if data series is empty.
	* @return Minimum time stamp in microseconds.
	*/
	LibMCEnv_uint64 CDataSeries::GetMinimum()
	{
		LibMCEnv_uint64 resultMinimumInMicroSeconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_GetMinimum(m_pHandle, &resultMinimumInMicroSeconds));
		
		return resultMinimumInMicroSeconds;
	}
	
	/**
	* CDataSeries::GetMaximum - Returns the maximum time stamp of the data series. Fails if data series is empty.
	* @return Maximum time stamp in microseconds.
	*/
	LibMCEnv_uint64 CDataSeries::GetMaximum()
	{
		LibMCEnv_uint64 resultMaximumInMicroSeconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_GetMaximum(m_pHandle, &resultMaximumInMicroSeconds));
		
		return resultMaximumInMicroSeconds;
	}
	
	/**
	* CDataSeries::GetAllEntries - Returns all entries of the data series. Fails if data series is empty.
	* @param[out] EntryArrayBuffer - Data series entries will be written in this array.
	*/
	void CDataSeries::GetAllEntries(std::vector<sTimeStreamEntry> & EntryArrayBuffer)
	{
		LibMCEnv_uint64 elementsNeededEntryArray = 0;
		LibMCEnv_uint64 elementsWrittenEntryArray = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_GetAllEntries(m_pHandle, 0, &elementsNeededEntryArray, nullptr));
		EntryArrayBuffer.resize((size_t) elementsNeededEntryArray);
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_GetAllEntries(m_pHandle, elementsNeededEntryArray, &elementsWrittenEntryArray, EntryArrayBuffer.data()));
	}
	
	/**
	* CDataSeries::SetAllEntries - Sets all entries of the data series. The time stamp array MUST be sorted in incrementing order, with no two time stamps being equal.
	* @param[in] EntryArrayBuffer - Data series entries to use.
	*/
	void CDataSeries::SetAllEntries(const CInputVector<sTimeStreamEntry> & EntryArrayBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_SetAllEntries(m_pHandle, (LibMCEnv_uint64)EntryArrayBuffer.size(), EntryArrayBuffer.data()));
	}
	
	/**
	* CDataSeries::SampleJournalVariable - Samples a journal variable.
	* @param[in] pJournalVariable - Journal variable to sample.
	* @param[in] nNumberOfSamples - Number of samples to generate.
	* @param[in] dMovingAverageDelta - Each sample will be averaged from minus MovingAverageDelta to plus MovingAverageDelta.
	*/
	void CDataSeries::SampleJournalVariable(classParam<CJournalVariable> pJournalVariable, const LibMCEnv_uint32 nNumberOfSamples, const LibMCEnv_double dMovingAverageDelta)
	{
		LibMCEnvHandle hJournalVariable = pJournalVariable.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_SampleJournalVariable(m_pHandle, hJournalVariable, nNumberOfSamples, dMovingAverageDelta));
	}
	
	/**
	* CDataSeries::GetVersion - Returns the incrementing change version of the data series.
	* @return Version number. Increases with every change to the data.
	*/
	LibMCEnv_uint32 CDataSeries::GetVersion()
	{
		LibMCEnv_uint32 resultVersion = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_GetVersion(m_pHandle, &resultVersion));
		
		return resultVersion;
	}
	
	/**
	* CDataSeries::IncreaseVersion - Increases the version number of the data series.
	*/
	void CDataSeries::IncreaseVersion()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataSeries_IncreaseVersion(m_pHandle));
	}
	
	/**
	 * Method definitions for class CDateTimeDifference
	 */
	
	/**
	* CDateTimeDifference::ToMicroseconds - Returns the duration in Microseconds.
	* @return The duration in Microseconds.
	*/
	LibMCEnv_uint64 CDateTimeDifference::ToMicroseconds()
	{
		LibMCEnv_uint64 resultMicroseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_ToMicroseconds(m_pHandle, &resultMicroseconds));
		
		return resultMicroseconds;
	}
	
	/**
	* CDateTimeDifference::ToMilliseconds - Returns the duration in Milliseconds. Partial milliseconds are rounded down.
	* @return The duration in Milliseconds.
	*/
	LibMCEnv_uint64 CDateTimeDifference::ToMilliseconds()
	{
		LibMCEnv_uint64 resultMilliseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_ToMilliseconds(m_pHandle, &resultMilliseconds));
		
		return resultMilliseconds;
	}
	
	/**
	* CDateTimeDifference::ToSeconds - Returns the duration in Seconds. Partial seconds are rounded down.
	* @return The duration in seconds.
	*/
	LibMCEnv_uint64 CDateTimeDifference::ToSeconds()
	{
		LibMCEnv_uint64 resultSeconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_ToSeconds(m_pHandle, &resultSeconds));
		
		return resultSeconds;
	}
	
	/**
	* CDateTimeDifference::ToMinutes - Returns the duration in Seconds. Partial minutes are rounded down.
	* @return The duration in seconds.
	*/
	LibMCEnv_uint64 CDateTimeDifference::ToMinutes()
	{
		LibMCEnv_uint64 resultMinutes = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_ToMinutes(m_pHandle, &resultMinutes));
		
		return resultMinutes;
	}
	
	/**
	* CDateTimeDifference::ToHours - Returns the duration in Hours. Partial hours are rounded down.
	* @return The duration in hours.
	*/
	LibMCEnv_uint64 CDateTimeDifference::ToHours()
	{
		LibMCEnv_uint64 resultHours = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_ToHours(m_pHandle, &resultHours));
		
		return resultHours;
	}
	
	/**
	* CDateTimeDifference::ToDays - Returns the duration in Days. Partial days are rounded down.
	* @return The duration in days.
	*/
	LibMCEnv_uint64 CDateTimeDifference::ToDays()
	{
		LibMCEnv_uint64 resultDays = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_ToDays(m_pHandle, &resultDays));
		
		return resultDays;
	}
	
	/**
	* CDateTimeDifference::RoundDownToDay - Rounds down the duration to the full day.
	*/
	void CDateTimeDifference::RoundDownToDay()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundDownToDay(m_pHandle));
	}
	
	/**
	* CDateTimeDifference::RoundDownToHour - Rounds down the duration to the full hour.
	*/
	void CDateTimeDifference::RoundDownToHour()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundDownToHour(m_pHandle));
	}
	
	/**
	* CDateTimeDifference::RoundDownToMinute - Rounds down the duration to the full minute.
	*/
	void CDateTimeDifference::RoundDownToMinute()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundDownToMinute(m_pHandle));
	}
	
	/**
	* CDateTimeDifference::RoundDownToSeconds - Rounds down the duration to the full second.
	*/
	void CDateTimeDifference::RoundDownToSeconds()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundDownToSeconds(m_pHandle));
	}
	
	/**
	* CDateTimeDifference::RoundDownToMilliseconds - Rounds down the duration to the full millisecond.
	*/
	void CDateTimeDifference::RoundDownToMilliseconds()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundDownToMilliseconds(m_pHandle));
	}
	
	/**
	* CDateTimeDifference::RoundUpToDay - Rounds up the duration to the full day.
	*/
	void CDateTimeDifference::RoundUpToDay()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundUpToDay(m_pHandle));
	}
	
	/**
	* CDateTimeDifference::RoundUpToHour - Rounds up the duration to the full hour.
	*/
	void CDateTimeDifference::RoundUpToHour()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundUpToHour(m_pHandle));
	}
	
	/**
	* CDateTimeDifference::RoundUpToMinute - Rounds up the duration to the full minute.
	*/
	void CDateTimeDifference::RoundUpToMinute()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundUpToMinute(m_pHandle));
	}
	
	/**
	* CDateTimeDifference::RoundUpToSeconds - Rounds up the duration to the full second.
	*/
	void CDateTimeDifference::RoundUpToSeconds()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundUpToSeconds(m_pHandle));
	}
	
	/**
	* CDateTimeDifference::RoundupToMilliseconds - Rounds up the duration to the full millisecond.
	*/
	void CDateTimeDifference::RoundupToMilliseconds()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTimeDifference_RoundupToMilliseconds(m_pHandle));
	}
	
	/**
	 * Method definitions for class CDateTime
	 */
	
	/**
	* CDateTime::ToMicrosecondsSince1970 - Returns the maximum accuracy date time.
	* @return Returns the date in Microseconds since midnight first of January 1970.
	*/
	LibMCEnv_uint64 CDateTime::ToMicrosecondsSince1970()
	{
		LibMCEnv_uint64 resultMicrosecondsSince1970 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ToMicrosecondsSince1970(m_pHandle, &resultMicrosecondsSince1970));
		
		return resultMicrosecondsSince1970;
	}
	
	/**
	* CDateTime::ToUnixTimestamp - Returns the unix time stamp of the date time
	* @return Returns the date in seconds since midnight the first of January 1970. Rounds down the value if microseconds are present.
	*/
	LibMCEnv_uint64 CDateTime::ToUnixTimestamp()
	{
		LibMCEnv_uint64 resultSecondsSince1970 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ToUnixTimestamp(m_pHandle, &resultSecondsSince1970));
		
		return resultSecondsSince1970;
	}
	
	/**
	* CDateTime::ToUTCDateTime - Returns the Timestamp in ISO8601 UTC format. Rounded down to Second Accuracy.
	* @return The time stamp in ISO8601 format. Rounds down the value if microseconds are present. One example is 2024-03-27T15:21:46Z UTC
	*/
	std::string CDateTime::ToUTCDateTime()
	{
		LibMCEnv_uint32 bytesNeededUTCDateTime = 0;
		LibMCEnv_uint32 bytesWrittenUTCDateTime = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ToUTCDateTime(m_pHandle, 0, &bytesNeededUTCDateTime, nullptr));
		std::vector<char> bufferUTCDateTime(bytesNeededUTCDateTime);
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ToUTCDateTime(m_pHandle, bytesNeededUTCDateTime, &bytesWrittenUTCDateTime, &bufferUTCDateTime[0]));
		
		return std::string(&bufferUTCDateTime[0]);
	}
	
	/**
	* CDateTime::ToUTCDateTimeInMilliseconds - Returns the Timestamp in ISO8601 UTC format. Rounded down to Millisecond Accuracy.
	* @return The time stamp in ISO8601 format. Rounds down the value if microseconds are present. One example is 2024-03-27T15:21:46.123Z UTC
	*/
	std::string CDateTime::ToUTCDateTimeInMilliseconds()
	{
		LibMCEnv_uint32 bytesNeededUTCDateTime = 0;
		LibMCEnv_uint32 bytesWrittenUTCDateTime = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ToUTCDateTimeInMilliseconds(m_pHandle, 0, &bytesNeededUTCDateTime, nullptr));
		std::vector<char> bufferUTCDateTime(bytesNeededUTCDateTime);
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ToUTCDateTimeInMilliseconds(m_pHandle, bytesNeededUTCDateTime, &bytesWrittenUTCDateTime, &bufferUTCDateTime[0]));
		
		return std::string(&bufferUTCDateTime[0]);
	}
	
	/**
	* CDateTime::ToUTCDateTimeInMicroseconds - Returns the Timestamp in ISO8601 UTC format. Returns the string in full microsecond accuracy.
	* @return The time stamp in ISO8601 format. One example is 2024-03-27T15:21:46.123456Z UTC
	*/
	std::string CDateTime::ToUTCDateTimeInMicroseconds()
	{
		LibMCEnv_uint32 bytesNeededUTCDateTime = 0;
		LibMCEnv_uint32 bytesWrittenUTCDateTime = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ToUTCDateTimeInMicroseconds(m_pHandle, 0, &bytesNeededUTCDateTime, nullptr));
		std::vector<char> bufferUTCDateTime(bytesNeededUTCDateTime);
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ToUTCDateTimeInMicroseconds(m_pHandle, bytesNeededUTCDateTime, &bytesWrittenUTCDateTime, &bufferUTCDateTime[0]));
		
		return std::string(&bufferUTCDateTime[0]);
	}
	
	/**
	* CDateTime::GetDate - Returns the date information.
	* @param[out] nYear - Year of the date.
	* @param[out] nMonth - Month of the date.
	* @param[out] nDay - Day of the date.
	*/
	void CDateTime::GetDate(LibMCEnv_uint32 & nYear, LibMCEnv_uint32 & nMonth, LibMCEnv_uint32 & nDay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_GetDate(m_pHandle, &nYear, &nMonth, &nDay));
	}
	
	/**
	* CDateTime::GetTime - Returns the time information.
	* @param[out] nHour - Hour of the time. Returns 0-23.
	* @param[out] nMinute - Minute of the time. Returns 0-59.
	* @param[out] nSecond - Seconds of the time. Returns 0-59.
	* @param[out] nMicrosecond - Partial microseconds of the time. Returns 0-999999.
	*/
	void CDateTime::GetTime(LibMCEnv_uint32 & nHour, LibMCEnv_uint32 & nMinute, LibMCEnv_uint32 & nSecond, LibMCEnv_uint32 & nMicrosecond)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_GetTime(m_pHandle, &nHour, &nMinute, &nSecond, &nMicrosecond));
	}
	
	/**
	* CDateTime::Duplicate - Duplicates the date time instance.
	* @return Returns a copied instance.
	*/
	PDateTime CDateTime::Duplicate()
	{
		LibMCEnvHandle hNewInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_Duplicate(m_pHandle, &hNewInstance));
		
		if (!hNewInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hNewInstance);
	}
	
	/**
	* CDateTime::IsLeapYear - Returns if the year is a leap year.
	* @return Returns true if the year is a leap year.
	*/
	bool CDateTime::IsLeapYear()
	{
		bool resultIsLeapYear = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_IsLeapYear(m_pHandle, &resultIsLeapYear));
		
		return resultIsLeapYear;
	}
	
	/**
	* CDateTime::IsLaterThan - Checks if this timestamp is later than another timestamp.
	* @param[in] pOtherTimeStamp - Instance to check against.
	* @return Returns true if the instance is later than OtherTimeStamp.
	*/
	bool CDateTime::IsLaterThan(classParam<CDateTime> pOtherTimeStamp)
	{
		LibMCEnvHandle hOtherTimeStamp = pOtherTimeStamp.GetHandle();
		bool resultIsLater = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_IsLaterThan(m_pHandle, hOtherTimeStamp, &resultIsLater));
		
		return resultIsLater;
	}
	
	/**
	* CDateTime::IsEarlierThan - Checks if this timestamp is earlier than another timestamp.
	* @param[in] pOtherTimeStamp - Instance to check against.
	* @return Returns true if the instance is earlier than OtherTimeStamp.
	*/
	bool CDateTime::IsEarlierThan(classParam<CDateTime> pOtherTimeStamp)
	{
		LibMCEnvHandle hOtherTimeStamp = pOtherTimeStamp.GetHandle();
		bool resultIsEarlier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_IsEarlierThan(m_pHandle, hOtherTimeStamp, &resultIsEarlier));
		
		return resultIsEarlier;
	}
	
	/**
	* CDateTime::IsEqualTo - Checks if this timestamp is equal to another timestamp.
	* @param[in] pOtherTimeStamp - Instance to check against.
	* @return Returns true if the instance is equal to the OtherTimeStamp.
	*/
	bool CDateTime::IsEqualTo(classParam<CDateTime> pOtherTimeStamp)
	{
		LibMCEnvHandle hOtherTimeStamp = pOtherTimeStamp.GetHandle();
		bool resultIsEqual = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_IsEqualTo(m_pHandle, hOtherTimeStamp, &resultIsEqual));
		
		return resultIsEqual;
	}
	
	/**
	* CDateTime::GetTimeDifference - Returns the time difference to another time stamp as positive duration value.
	* @param[in] pOtherTimeStamp - Instance to check against.
	* @return Difference between the two time stamps. Value will always be positive. Use IsEarlierThan or IsLaterThan to figure out the time ordering.
	*/
	PDateTimeDifference CDateTime::GetTimeDifference(classParam<CDateTime> pOtherTimeStamp)
	{
		LibMCEnvHandle hOtherTimeStamp = pOtherTimeStamp.GetHandle();
		LibMCEnvHandle hDifference = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_GetTimeDifference(m_pHandle, hOtherTimeStamp, &hDifference));
		
		if (!hDifference) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTimeDifference>(m_pWrapper, hDifference);
	}
	
	/**
	* CDateTime::AddDuration - Shifts the date time by a duration. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] pDuration - Duration to add to the time stamp.
	*/
	void CDateTime::AddDuration(classParam<CDateTimeDifference> pDuration)
	{
		LibMCEnvHandle hDuration = pDuration.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_AddDuration(m_pHandle, hDuration));
	}
	
	/**
	* CDateTime::SubtractDuration - Shifts the date time by a duration. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] pDuration - Duration to subtract from the time stamp.
	*/
	void CDateTime::SubtractDuration(classParam<CDateTimeDifference> pDuration)
	{
		LibMCEnvHandle hDuration = pDuration.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_SubtractDuration(m_pHandle, hDuration));
	}
	
	/**
	* CDateTime::ShiftByYears - Shifts the date time by years. Takes leap years into account. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaYears - Years to shift the date time stamp.
	*/
	void CDateTime::ShiftByYears(const LibMCEnv_int64 nDeltaYears)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ShiftByYears(m_pHandle, nDeltaYears));
	}
	
	/**
	* CDateTime::ShiftByDays - Shifts the date time by days. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaDays - Days to shift the date time stamp.
	*/
	void CDateTime::ShiftByDays(const LibMCEnv_int64 nDeltaDays)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ShiftByDays(m_pHandle, nDeltaDays));
	}
	
	/**
	* CDateTime::ShiftByHours - Shifts the date time by hours. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaHours - Hours to shift the date time stamp.
	*/
	void CDateTime::ShiftByHours(const LibMCEnv_int64 nDeltaHours)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ShiftByHours(m_pHandle, nDeltaHours));
	}
	
	/**
	* CDateTime::ShiftByMinutes - Shifts the date time by minutes. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaMinutes - Minutes to shift the date time stamp.
	*/
	void CDateTime::ShiftByMinutes(const LibMCEnv_int64 nDeltaMinutes)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ShiftByMinutes(m_pHandle, nDeltaMinutes));
	}
	
	/**
	* CDateTime::ShiftBySeconds - Shifts the date time by seconds. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaSeconds - Seconds to shift the date time stamp.
	*/
	void CDateTime::ShiftBySeconds(const LibMCEnv_int64 nDeltaSeconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ShiftBySeconds(m_pHandle, nDeltaSeconds));
	}
	
	/**
	* CDateTime::ShiftByMilliseconds - Shifts the date time by milliseconds. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaMilliseconds - Milliseconds to shift the date time stamp.
	*/
	void CDateTime::ShiftByMilliseconds(const LibMCEnv_int64 nDeltaMilliseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ShiftByMilliseconds(m_pHandle, nDeltaMilliseconds));
	}
	
	/**
	* CDateTime::ShiftByMicroseconds - Shifts the date time by microseconds. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaMicroseconds - Microseconds to shift the date time stamp.
	*/
	void CDateTime::ShiftByMicroseconds(const LibMCEnv_int64 nDeltaMicroseconds)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_ShiftByMicroseconds(m_pHandle, nDeltaMicroseconds));
	}
	
	/**
	* CDateTime::RoundDownToYear - Rounds down the timestamp to the start of the year. Takes leap years into account.
	*/
	void CDateTime::RoundDownToYear()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundDownToYear(m_pHandle));
	}
	
	/**
	* CDateTime::RoundDownToMonth - Rounds down the timestamp to the start of the month. Takes leap years into account.
	*/
	void CDateTime::RoundDownToMonth()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundDownToMonth(m_pHandle));
	}
	
	/**
	* CDateTime::RoundDownToDay - Rounds down the timestamp to the full day.
	*/
	void CDateTime::RoundDownToDay()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundDownToDay(m_pHandle));
	}
	
	/**
	* CDateTime::RoundDownToHour - Rounds down the timestamp to the full hour.
	*/
	void CDateTime::RoundDownToHour()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundDownToHour(m_pHandle));
	}
	
	/**
	* CDateTime::RoundDownToMinute - Rounds down the timestamp to the full minute.
	*/
	void CDateTime::RoundDownToMinute()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundDownToMinute(m_pHandle));
	}
	
	/**
	* CDateTime::RoundDownToSeconds - Rounds down the timestamp to the full second.
	*/
	void CDateTime::RoundDownToSeconds()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundDownToSeconds(m_pHandle));
	}
	
	/**
	* CDateTime::RoundDownToMilliseconds - Rounds down the timestamp to the full millisecond.
	*/
	void CDateTime::RoundDownToMilliseconds()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundDownToMilliseconds(m_pHandle));
	}
	
	/**
	* CDateTime::RoundUpToYear - Rounds up the timestamp to the start of the year. Takes leap years into account.
	*/
	void CDateTime::RoundUpToYear()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundUpToYear(m_pHandle));
	}
	
	/**
	* CDateTime::RoundUpToMonth - Rounds up the timestamp to the start of the month. Takes leap years into account.
	*/
	void CDateTime::RoundUpToMonth()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundUpToMonth(m_pHandle));
	}
	
	/**
	* CDateTime::RoundUpToDay - Rounds up the timestamp to the full day.
	*/
	void CDateTime::RoundUpToDay()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundUpToDay(m_pHandle));
	}
	
	/**
	* CDateTime::RoundUpToHour - Rounds up the timestamp to the full hour.
	*/
	void CDateTime::RoundUpToHour()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundUpToHour(m_pHandle));
	}
	
	/**
	* CDateTime::RoundUpToMinute - Rounds up the timestamp to the full minute.
	*/
	void CDateTime::RoundUpToMinute()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundUpToMinute(m_pHandle));
	}
	
	/**
	* CDateTime::RoundUpToSeconds - Rounds up the timestamp to the full second.
	*/
	void CDateTime::RoundUpToSeconds()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundUpToSeconds(m_pHandle));
	}
	
	/**
	* CDateTime::RoundUpToMilliseconds - Rounds up the timestamp to the full millisecond.
	*/
	void CDateTime::RoundUpToMilliseconds()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DateTime_RoundUpToMilliseconds(m_pHandle));
	}
	
	/**
	 * Method definitions for class CMeshObject
	 */
	
	/**
	* CMeshObject::GetName - Returns the name of the Mesh Object.
	* @return Returns the name of the mesh object.
	*/
	std::string CMeshObject::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CMeshObject::GetUUID - Returns the UUID of the mesh object.
	* @return Returns mesh uuid.
	*/
	std::string CMeshObject::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CMeshObject::GetTriangleCount - Returns the number of triangles in the mesh.
	* @return Number of triangles.
	*/
	LibMCEnv_uint32 CMeshObject::GetTriangleCount()
	{
		LibMCEnv_uint32 resultTriangleCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetTriangleCount(m_pHandle, &resultTriangleCount));
		
		return resultTriangleCount;
	}
	
	/**
	* CMeshObject::GetVertexCount - Returns the number of vertices in the mesh.
	* @return Number of vertices.
	*/
	LibMCEnv_uint32 CMeshObject::GetVertexCount()
	{
		LibMCEnv_uint32 resultVertexCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetVertexCount(m_pHandle, &resultVertexCount));
		
		return resultVertexCount;
	}
	
	/**
	* CMeshObject::IsManifold - Checks if the mesh topology is closed and every edge has two adjacent faces.
	* @return Returns true if the mesh is manifold.
	*/
	bool CMeshObject::IsManifold()
	{
		bool resultManifoldResult = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_IsManifold(m_pHandle, &resultManifoldResult));
		
		return resultManifoldResult;
	}
	
	/**
	* CMeshObject::IsOriented - Checks if the mesh topology is oriented, so no Mobius strip or Klein bottle for example.
	* @return Returns true if the mesh is oriented.
	*/
	bool CMeshObject::IsOriented()
	{
		bool resultOrientedResult = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_IsOriented(m_pHandle, &resultOrientedResult));
		
		return resultOrientedResult;
	}
	
	/**
	* CMeshObject::IsWatertight - Checks if the mesh topology is oriented and manifold, e.g is describing a 3D volume.
	* @return Returns true if the mesh is watertight.
	*/
	bool CMeshObject::IsWatertight()
	{
		bool resultWatertightResult = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_IsWatertight(m_pHandle, &resultWatertightResult));
		
		return resultWatertightResult;
	}
	
	/**
	* CMeshObject::GetMaxVertexID - Returns the maximum vertex ID occuring in the mesh.
	* @return All vertices will have an ID smaller or equal this ID.
	*/
	LibMCEnv_uint32 CMeshObject::GetMaxVertexID()
	{
		LibMCEnv_uint32 resultMaxVertexID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetMaxVertexID(m_pHandle, &resultMaxVertexID));
		
		return resultMaxVertexID;
	}
	
	/**
	* CMeshObject::VertexExists - Returns if a vertex with an ID exists.
	* @param[in] nVertexID - Vertex ID to check.
	* @return Returns true if the vertex exists.
	*/
	bool CMeshObject::VertexExists(const LibMCEnv_uint32 nVertexID)
	{
		bool resultVertexExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_VertexExists(m_pHandle, nVertexID, &resultVertexExists));
		
		return resultVertexExists;
	}
	
	/**
	* CMeshObject::GetVertex - Returns position of a vertex. Will return 0 if vertex does not exist.
	* @param[in] nVertexID - Vertex ID to retrieve.
	* @param[out] dX - Returns the X coordinate of the vertex. Returns 0 if vertex does not exist.
	* @param[out] dY - Returns the Y coordinate of the vertex. Returns 0 if vertex does not exist.
	* @param[out] dZ - Returns the Z coordinate of the vertex. Returns 0 if vertex does not exist.
	* @return Returns true if the vertex exists.
	*/
	bool CMeshObject::GetVertex(const LibMCEnv_uint32 nVertexID, LibMCEnv_double & dX, LibMCEnv_double & dY, LibMCEnv_double & dZ)
	{
		bool resultVertexExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetVertex(m_pHandle, nVertexID, &dX, &dY, &dZ, &resultVertexExists));
		
		return resultVertexExists;
	}
	
	/**
	* CMeshObject::GetVertexIDs - Returns all IDs of the vertices. Ordered sequentially.
	* @param[out] VertexIDsBuffer - Vertex ID array.
	*/
	void CMeshObject::GetVertexIDs(std::vector<LibMCEnv_uint32> & VertexIDsBuffer)
	{
		LibMCEnv_uint64 elementsNeededVertexIDs = 0;
		LibMCEnv_uint64 elementsWrittenVertexIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetVertexIDs(m_pHandle, 0, &elementsNeededVertexIDs, nullptr));
		VertexIDsBuffer.resize((size_t) elementsNeededVertexIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetVertexIDs(m_pHandle, elementsNeededVertexIDs, &elementsWrittenVertexIDs, VertexIDsBuffer.data()));
	}
	
	/**
	* CMeshObject::GetAllVertices - Returns all the vertex information. Ordered sequentially by ID.
	* @param[out] VerticesBuffer - Vertex array.
	*/
	void CMeshObject::GetAllVertices(std::vector<sMeshVertex3D> & VerticesBuffer)
	{
		LibMCEnv_uint64 elementsNeededVertices = 0;
		LibMCEnv_uint64 elementsWrittenVertices = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetAllVertices(m_pHandle, 0, &elementsNeededVertices, nullptr));
		VerticesBuffer.resize((size_t) elementsNeededVertices);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetAllVertices(m_pHandle, elementsNeededVertices, &elementsWrittenVertices, VerticesBuffer.data()));
	}
	
	/**
	* CMeshObject::GetMaxTriangleID - Returns the maximum triangle ID occuring in the mesh.
	* @return All triangles will have an ID smaller or equal this ID.
	*/
	LibMCEnv_uint32 CMeshObject::GetMaxTriangleID()
	{
		LibMCEnv_uint32 resultMaxTriangleID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetMaxTriangleID(m_pHandle, &resultMaxTriangleID));
		
		return resultMaxTriangleID;
	}
	
	/**
	* CMeshObject::TriangeExists - Returns if a triangle with an ID exists.
	* @param[in] nTriangleID - Triangle ID to check.
	* @return Returns true if the triangle exists.
	*/
	bool CMeshObject::TriangeExists(const LibMCEnv_uint32 nTriangleID)
	{
		bool resultTriangleExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_TriangeExists(m_pHandle, nTriangleID, &resultTriangleExists));
		
		return resultTriangleExists;
	}
	
	/**
	* CMeshObject::GetTriangle - Returns vertex IDs of a triangle. Will return 0 if triangle does not exist.
	* @param[in] nTriangleID - Triangle ID to retrieve.
	* @param[out] nVertex1ID - Returns the vertex ID of the first corner. Returns 0 if triangle does not exist.
	* @param[out] nVertex2ID - Returns the vertex ID of the second corner. Returns 0 if triangle does not exist.
	* @param[out] nVertex3ID - Returns the vertex ID of the third corner. Returns 0 if triangle does not exist.
	* @return Returns true if the triangle exists.
	*/
	bool CMeshObject::GetTriangle(const LibMCEnv_uint32 nTriangleID, LibMCEnv_uint32 & nVertex1ID, LibMCEnv_uint32 & nVertex2ID, LibMCEnv_uint32 & nVertex3ID)
	{
		bool resultVertexExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetTriangle(m_pHandle, nTriangleID, &nVertex1ID, &nVertex2ID, &nVertex3ID, &resultVertexExists));
		
		return resultVertexExists;
	}
	
	/**
	* CMeshObject::GetTriangleIDs - Returns all IDs of the triangles. Ordered sequentially.
	* @param[out] TriangleIDsBuffer - Triangle ID array.
	*/
	void CMeshObject::GetTriangleIDs(std::vector<LibMCEnv_uint32> & TriangleIDsBuffer)
	{
		LibMCEnv_uint64 elementsNeededTriangleIDs = 0;
		LibMCEnv_uint64 elementsWrittenTriangleIDs = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetTriangleIDs(m_pHandle, 0, &elementsNeededTriangleIDs, nullptr));
		TriangleIDsBuffer.resize((size_t) elementsNeededTriangleIDs);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetTriangleIDs(m_pHandle, elementsNeededTriangleIDs, &elementsWrittenTriangleIDs, TriangleIDsBuffer.data()));
	}
	
	/**
	* CMeshObject::GetAllTriangles - Returns all the triangle information. Ordered sequentially by ID.
	* @param[out] TrianglesBuffer - Triangle array.
	*/
	void CMeshObject::GetAllTriangles(std::vector<sMeshTriangle3D> & TrianglesBuffer)
	{
		LibMCEnv_uint64 elementsNeededTriangles = 0;
		LibMCEnv_uint64 elementsWrittenTriangles = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetAllTriangles(m_pHandle, 0, &elementsNeededTriangles, nullptr));
		TrianglesBuffer.resize((size_t) elementsNeededTriangles);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_GetAllTriangles(m_pHandle, elementsNeededTriangles, &elementsWrittenTriangles, TrianglesBuffer.data()));
	}
	
	/**
	* CMeshObject::IsPersistent - Returns if the mesh object is persisted in memory.
	* @return If true, the mesh object is persisted in memory and can be retrieved by FindPersistentMeshObject.
	*/
	bool CMeshObject::IsPersistent()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_IsPersistent(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CMeshObject::MakePersistent - Makes the mesh persistent in memory. It will not be released when the MeshObject instances is released. Should be handled with great care!
	* @param[in] bBoundToLoginSession - If true, the mesh will be freed once the client login session expires.
	* @return Returns a persistent instance to the same mesh data.
	*/
	PPersistentMeshObject CMeshObject::MakePersistent(const bool bBoundToLoginSession)
	{
		LibMCEnvHandle hPersistentMesh = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshObject_MakePersistent(m_pHandle, bBoundToLoginSession, &hPersistentMesh));
		
		if (!hPersistentMesh) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPersistentMeshObject>(m_pWrapper, hPersistentMesh);
	}
	
	/**
	 * Method definitions for class CPersistentMeshObject
	 */
	
	/**
	* CPersistentMeshObject::IsBoundToLoginSession - Returns if the mesh object is bound to a specific login session.
	* @return If true, the mesh will be freed once the client login session expires.
	*/
	bool CPersistentMeshObject::IsBoundToLoginSession()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistentMeshObject_IsBoundToLoginSession(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	 * Method definitions for class CModelDataMeshInstance
	 */
	
	/**
	* CModelDataMeshInstance::GetName - Returns Mesh Name.
	* @return Returns mesh instance name.
	*/
	std::string CModelDataMeshInstance::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataMeshInstance_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataMeshInstance_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CModelDataMeshInstance::GetUUID - Returns Mesh UUID.
	* @return Returns mesh instance uuid.
	*/
	std::string CModelDataMeshInstance::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataMeshInstance_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataMeshInstance_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CModelDataMeshInstance::GetLocalTransform - Returns Local Transform of the Mesh.
	* @return Returns the transform matrix of the mesh in its component coordinate system.
	*/
	sModelDataTransform CModelDataMeshInstance::GetLocalTransform()
	{
		sModelDataTransform resultLocalTransform;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataMeshInstance_GetLocalTransform(m_pHandle, &resultLocalTransform));
		
		return resultLocalTransform;
	}
	
	/**
	* CModelDataMeshInstance::GetAbsoluteTransform - Returns Transform of the Mesh.
	* @return Returns the transform matrix of the mesh in the global world coordinate system.
	*/
	sModelDataTransform CModelDataMeshInstance::GetAbsoluteTransform()
	{
		sModelDataTransform resultAbsoluteTransform;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataMeshInstance_GetAbsoluteTransform(m_pHandle, &resultAbsoluteTransform));
		
		return resultAbsoluteTransform;
	}
	
	/**
	* CModelDataMeshInstance::CreateCopiedMesh - Loads a copy of the mesh geometry into memory. Might be inefficient to use for many identical copies of the mesh in the scene.
	* @return Returns the mesh object instance.
	*/
	PMeshObject CModelDataMeshInstance::CreateCopiedMesh()
	{
		LibMCEnvHandle hMeshObjectCopy = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataMeshInstance_CreateCopiedMesh(m_pHandle, &hMeshObjectCopy));
		
		if (!hMeshObjectCopy) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMeshObject>(m_pWrapper, hMeshObjectCopy);
	}
	
	/**
	* CModelDataMeshInstance::CreatePersistentMesh - Creates a persistent mesh of the geometry. Will not create a duplicate if the instance was already persisted before. The release of the memory should be handled with great care! 
	* @param[in] bBoundToLoginSession - If true, the mesh will be freed once the client login session expires.
	* @return Returns a persistent instance to the same mesh data.
	*/
	PPersistentMeshObject CModelDataMeshInstance::CreatePersistentMesh(const bool bBoundToLoginSession)
	{
		LibMCEnvHandle hPersistentMesh = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataMeshInstance_CreatePersistentMesh(m_pHandle, bBoundToLoginSession, &hPersistentMesh));
		
		if (!hPersistentMesh) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPersistentMeshObject>(m_pWrapper, hPersistentMesh);
	}
	
	/**
	 * Method definitions for class CModelDataComponentInstance
	 */
	
	/**
	* CModelDataComponentInstance::GetName - Returns Component Name.
	* @return Returns toolpath part name.
	*/
	std::string CModelDataComponentInstance::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CModelDataComponentInstance::GetUUID - Returns Component UUID.
	* @return Returns toolpath part uuid.
	*/
	std::string CModelDataComponentInstance::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CModelDataComponentInstance::GetLocalTransform - Returns Local Transform of the Mesh.
	* @return Returns the transform matrix of the mesh in its component coordinate system.
	*/
	sModelDataTransform CModelDataComponentInstance::GetLocalTransform()
	{
		sModelDataTransform resultLocalTransform;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetLocalTransform(m_pHandle, &resultLocalTransform));
		
		return resultLocalTransform;
	}
	
	/**
	* CModelDataComponentInstance::GetAbsoluteTransform - Returns Transform of the Mesh.
	* @return Returns the transform matrix of the mesh in the global world coordinate system.
	*/
	sModelDataTransform CModelDataComponentInstance::GetAbsoluteTransform()
	{
		sModelDataTransform resultAbsoluteTransform;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetAbsoluteTransform(m_pHandle, &resultAbsoluteTransform));
		
		return resultAbsoluteTransform;
	}
	
	/**
	* CModelDataComponentInstance::GetSolidCount - Returns the number of solid meshes in the component.
	* @return Model Count.
	*/
	LibMCEnv_uint32 CModelDataComponentInstance::GetSolidCount()
	{
		LibMCEnv_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetSolidCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CModelDataComponentInstance::GetSolidMesh - Returns a solid mesh of the component.
	* @param[in] nIndex - Index of Solid Mesh. MUST be between 0 and SolidCount - 1.
	* @return Solid Mesh. MUST be between 0 and ModelCount - 1.
	*/
	PModelDataMeshInstance CModelDataComponentInstance::GetSolidMesh(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnvHandle hMeshInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetSolidMesh(m_pHandle, nIndex, &hMeshInstance));
		
		if (!hMeshInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModelDataMeshInstance>(m_pWrapper, hMeshInstance);
	}
	
	/**
	* CModelDataComponentInstance::GetSupportCount - Returns the number of support meshes in the component.
	* @return Support Count.
	*/
	LibMCEnv_uint32 CModelDataComponentInstance::GetSupportCount()
	{
		LibMCEnv_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetSupportCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CModelDataComponentInstance::GetSupportMesh - Returns a support mesh of the component.
	* @param[in] nIndex - Index of Support Mesh. MUST be between 0 and SupportCount - 1.
	* @return Support Mesh. MUST be between 0 and ModelCount - 1.
	*/
	PModelDataMeshInstance CModelDataComponentInstance::GetSupportMesh(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnvHandle hMeshInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetSupportMesh(m_pHandle, nIndex, &hMeshInstance));
		
		if (!hMeshInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModelDataMeshInstance>(m_pWrapper, hMeshInstance);
	}
	
	/**
	* CModelDataComponentInstance::GetSubComponentCount - Returns the number of subcomponents of the component.
	* @return Subcomponent Count.
	*/
	LibMCEnv_uint32 CModelDataComponentInstance::GetSubComponentCount()
	{
		LibMCEnv_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetSubComponentCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CModelDataComponentInstance::GetSubComponent - Returns a subcomponent of the component.
	* @param[in] nIndex - Index of Subcomponent. MUST be between 0 and SubComponentCount - 1.
	* @return SubComponent. MUST be between 0 and ModelCount - 1.
	*/
	PModelDataComponentInstance CModelDataComponentInstance::GetSubComponent(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnvHandle hSubComponentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ModelDataComponentInstance_GetSubComponent(m_pHandle, nIndex, &hSubComponentInstance));
		
		if (!hSubComponentInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModelDataComponentInstance>(m_pWrapper, hSubComponentInstance);
	}
	
	/**
	 * Method definitions for class CMeshSceneItem
	 */
	
	/**
	* CMeshSceneItem::GetItemUUID - Returns the UUID of the scene item.
	* @return Returns scene item uuid.
	*/
	std::string CMeshSceneItem::GetItemUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshSceneItem_GetItemUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshSceneItem_GetItemUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CMeshSceneItem::GetSceneUUID - Returns the UUID of the scene.
	* @return Returns scene uuid.
	*/
	std::string CMeshSceneItem::GetSceneUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshSceneItem_GetSceneUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshSceneItem_GetSceneUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CMeshSceneItem::GetTransform - Returns the transform of the scene item.
	* @return Returns the transform matrix of the mesh in the global world coordinate system.
	*/
	sModelDataTransform CMeshSceneItem::GetTransform()
	{
		sModelDataTransform resultAbsoluteTransform;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshSceneItem_GetTransform(m_pHandle, &resultAbsoluteTransform));
		
		return resultAbsoluteTransform;
	}
	
	/**
	* CMeshSceneItem::UpdateTransform - Updates the transform of the scene item.
	* @param[in] AbsoluteTransform - The new transform matrix of the mesh in the global world coordinate system.
	*/
	void CMeshSceneItem::UpdateTransform(const sModelDataTransform & AbsoluteTransform)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MeshSceneItem_UpdateTransform(m_pHandle, &AbsoluteTransform));
	}
	
	/**
	* CMeshSceneItem::GetMeshObject - Returns persistent mesh object.
	* @return Returns a persistent mesh object of this scene.
	*/
	PPersistentMeshObject CMeshSceneItem::GetMeshObject()
	{
		LibMCEnvHandle hPersistentMesh = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshSceneItem_GetMeshObject(m_pHandle, &hPersistentMesh));
		
		if (!hPersistentMesh) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPersistentMeshObject>(m_pWrapper, hPersistentMesh);
	}
	
	/**
	* CMeshSceneItem::ReferenceIsValid - Returns if the underlying mesh object exists.
	* @return Returns a persistent mesh object of this scene.
	*/
	bool CMeshSceneItem::ReferenceIsValid()
	{
		bool resultIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshSceneItem_ReferenceIsValid(m_pHandle, &resultIsValid));
		
		return resultIsValid;
	}
	
	/**
	 * Method definitions for class CMeshScene
	 */
	
	/**
	* CMeshScene::GetSceneUUID - Returns the UUID of the scene.
	* @return Returns scene uuid.
	*/
	std::string CMeshScene::GetSceneUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_GetSceneUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_GetSceneUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CMeshScene::IsBoundToLoginSession - Returns if the scene object is bound to a specific login session.
	* @return If true, the scene will be freed once the client login session expires.
	*/
	bool CMeshScene::IsBoundToLoginSession()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_IsBoundToLoginSession(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CMeshScene::AddSceneItem - Adds a persistent mesh to the scene.
	* @param[in] pMesh - Mesh to add to the scene.
	* @param[in] AbsoluteTransform - Transform matrix of the mesh in the global world coordinate system.
	* @return The returned scene item.
	*/
	PMeshSceneItem CMeshScene::AddSceneItem(classParam<CPersistentMeshObject> pMesh, const sModelDataTransform & AbsoluteTransform)
	{
		LibMCEnvHandle hMesh = pMesh.GetHandle();
		LibMCEnvHandle hSceneItem = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_AddSceneItem(m_pHandle, hMesh, &AbsoluteTransform, &hSceneItem));
		
		if (!hSceneItem) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMeshSceneItem>(m_pWrapper, hSceneItem);
	}
	
	/**
	* CMeshScene::AddModelDataMeshAsSceneItem - Adds an instance from a ModelData component. Reuses underlying mesh data, if mesh has been persisted already. Registers new Persistent Mesh if necessary.
	* @param[in] pModelDataMesh - Adds a mesh to the scene.
	* @return The returned scene item.
	*/
	PMeshSceneItem CMeshScene::AddModelDataMeshAsSceneItem(classParam<CModelDataMeshInstance> pModelDataMesh)
	{
		LibMCEnvHandle hModelDataMesh = pModelDataMesh.GetHandle();
		LibMCEnvHandle hSceneItem = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_AddModelDataMeshAsSceneItem(m_pHandle, hModelDataMesh, &hSceneItem));
		
		if (!hSceneItem) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMeshSceneItem>(m_pWrapper, hSceneItem);
	}
	
	/**
	* CMeshScene::GetSceneItemCount - Returns the number of scene items.
	* @return Returns the number of scene items.
	*/
	LibMCEnv_uint32 CMeshScene::GetSceneItemCount()
	{
		LibMCEnv_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_GetSceneItemCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CMeshScene::GetSceneItem - Returns a scene item by index.
	* @param[in] nIndex - Index to retrieve. MUST be between 0 and SceneItemCount - 1
	* @return The returned scene item.
	*/
	PMeshSceneItem CMeshScene::GetSceneItem(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnvHandle hSceneItem = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_GetSceneItem(m_pHandle, nIndex, &hSceneItem));
		
		if (!hSceneItem) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMeshSceneItem>(m_pWrapper, hSceneItem);
	}
	
	/**
	* CMeshScene::FindSceneItem - Finds a scene item by UUID.
	* @param[in] sUUID - UUID to retrieve.
	* @param[in] bMustExist - If true, the call fails, if the UUID does not exist.
	* @return The returned scene item. NULL, if MustExist is false and UUID does not exist.
	*/
	PMeshSceneItem CMeshScene::FindSceneItem(const std::string & sUUID, const bool bMustExist)
	{
		LibMCEnvHandle hSceneItem = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_FindSceneItem(m_pHandle, sUUID.c_str(), bMustExist, &hSceneItem));
		
		if (!hSceneItem) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMeshSceneItem>(m_pWrapper, hSceneItem);
	}
	
	/**
	* CMeshScene::HasSceneItem - Checks if a scene item exists.
	* @param[in] sUUID - UUID to retrieve.
	* @return Returns true, if scene item UUID exists.
	*/
	bool CMeshScene::HasSceneItem(const std::string & sUUID)
	{
		bool resultSceneItemExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_HasSceneItem(m_pHandle, sUUID.c_str(), &resultSceneItemExists));
		
		return resultSceneItemExists;
	}
	
	/**
	* CMeshScene::RemoveSceneItem - Removes a scene item from the scene.
	* @param[in] pSceneItem - Scene Item to remove.
	*/
	void CMeshScene::RemoveSceneItem(classParam<CMeshSceneItem> pSceneItem)
	{
		LibMCEnvHandle hSceneItem = pSceneItem.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_MeshScene_RemoveSceneItem(m_pHandle, hSceneItem));
	}
	
	/**
	 * Method definitions for class CSceneHandler
	 */
	
	/**
	* CSceneHandler::MeshIsPersistent - Checks if a mesh uuid is registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Flag is registered.
	*/
	bool CSceneHandler::MeshIsPersistent(const std::string & sMeshUUID)
	{
		bool resultMeshIsRegistered = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SceneHandler_MeshIsPersistent(m_pHandle, sMeshUUID.c_str(), &resultMeshIsRegistered));
		
		return resultMeshIsRegistered;
	}
	
	/**
	* CSceneHandler::FindPersistentMesh - Finds a registered mesh by its UUID. Fails if mesh UUID is not registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Mesh Object instance.
	*/
	PPersistentMeshObject CSceneHandler::FindPersistentMesh(const std::string & sMeshUUID)
	{
		LibMCEnvHandle hMeshObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SceneHandler_FindPersistentMesh(m_pHandle, sMeshUUID.c_str(), &hMeshObjectInstance));
		
		if (!hMeshObjectInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPersistentMeshObject>(m_pWrapper, hMeshObjectInstance);
	}
	
	/**
	* CSceneHandler::CreateEmptyMeshScene - Creates an empty mesh scene object.
	* @param[in] sUUID - Mesh Scene UUID
	* @param[in] bBoundToLoginSession - Scene shall be freed when the current login session expires. Parameter is ignored, if not executed in a UIEnvironment context.
	* @return Returns and register a scene instance.
	*/
	PMeshScene CSceneHandler::CreateEmptyMeshScene(const std::string & sUUID, const bool bBoundToLoginSession)
	{
		LibMCEnvHandle hSceneInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SceneHandler_CreateEmptyMeshScene(m_pHandle, sUUID.c_str(), bBoundToLoginSession, &hSceneInstance));
		
		if (!hSceneInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMeshScene>(m_pWrapper, hSceneInstance);
	}
	
	/**
	* CSceneHandler::ReleaseMeshScene - Removes a mesh scene and removes all memory.
	* @return Returns and register a scene instance.
	*/
	PMeshScene CSceneHandler::ReleaseMeshScene()
	{
		LibMCEnvHandle hSceneInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SceneHandler_ReleaseMeshScene(m_pHandle, &hSceneInstance));
		
		if (!hSceneInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMeshScene>(m_pWrapper, hSceneInstance);
	}
	
	/**
	* CSceneHandler::Load3MFFromResource - Loads a 3MF Resource into memory.
	* @param[in] sResourceName - Resource name to load.
	* @return Contains the component hierarchy of the 3MF mesh. Memory will be freed once this component instance is freed.
	*/
	PModelDataComponentInstance CSceneHandler::Load3MFFromResource(const std::string & sResourceName)
	{
		LibMCEnvHandle hModelData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SceneHandler_Load3MFFromResource(m_pHandle, sResourceName.c_str(), &hModelData));
		
		if (!hModelData) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModelDataComponentInstance>(m_pWrapper, hModelData);
	}
	
	/**
	* CSceneHandler::Load3MFFromMemory - Loads a 3MF from memory.
	* @param[in] DataBuffer - Binary data to load.
	* @return Contains the component hierarchy of the 3MF mesh. Memory will be freed once this component instance is freed.
	*/
	PModelDataComponentInstance CSceneHandler::Load3MFFromMemory(const CInputVector<LibMCEnv_uint8> & DataBuffer)
	{
		LibMCEnvHandle hModelData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SceneHandler_Load3MFFromMemory(m_pHandle, (LibMCEnv_uint64)DataBuffer.size(), DataBuffer.data(), &hModelData));
		
		if (!hModelData) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModelDataComponentInstance>(m_pWrapper, hModelData);
	}
	
	/**
	* CSceneHandler::Load3MFFromStream - Loads a 3MF from a StreamReader.
	* @param[in] pReaderInstance - Stream reader instance.
	* @return Contains the component hierarchy of the 3MF mesh. Memory will be freed once this component instance is freed.
	*/
	PModelDataComponentInstance CSceneHandler::Load3MFFromStream(classParam<CStreamReader> pReaderInstance)
	{
		LibMCEnvHandle hReaderInstance = pReaderInstance.GetHandle();
		LibMCEnvHandle hModelData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SceneHandler_Load3MFFromStream(m_pHandle, hReaderInstance, &hModelData));
		
		if (!hModelData) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModelDataComponentInstance>(m_pWrapper, hModelData);
	}
	
	/**
	 * Method definitions for class CToolpathPart
	 */
	
	/**
	* CToolpathPart::GetName - Returns Part Name.
	* @return Returns toolpath part name.
	*/
	std::string CToolpathPart::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathPart_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathPart_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CToolpathPart::GetUUID - Returns Part UUID.
	* @return Returns toolpath part uuid.
	*/
	std::string CToolpathPart::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathPart_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathPart_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CToolpathPart::GetRootComponent - Returns the Root Component of the part.
	* @return Returns root component instance.
	*/
	PModelDataComponentInstance CToolpathPart::GetRootComponent()
	{
		LibMCEnvHandle hRootComponent = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathPart_GetRootComponent(m_pHandle, &hRootComponent));
		
		if (!hRootComponent) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModelDataComponentInstance>(m_pWrapper, hRootComponent);
	}
	
	/**
	 * Method definitions for class CToolpathLayer
	 */
	
	/**
	* CToolpathLayer::GetLayerDataUUID - Retrieves the layerdata's uuid
	* @return Returns the uuid value.
	*/
	std::string CToolpathLayer::GetLayerDataUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetLayerDataUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetLayerDataUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CToolpathLayer::GetSegmentCount - Retrieves the count of segments.
	* @return Count
	*/
	LibMCEnv_uint32 CToolpathLayer::GetSegmentCount()
	{
		LibMCEnv_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CToolpathLayer::GetSegmentInfo - Retrieves the segment type and point count information .
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] eType - Segment Type
	* @param[out] nPointCount - Point count of segment.
	*/
	void CToolpathLayer::GetSegmentInfo(const LibMCEnv_uint32 nIndex, eToolpathSegmentType & eType, LibMCEnv_uint32 & nPointCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentInfo(m_pHandle, nIndex, &eType, &nPointCount));
	}
	
	/**
	* CToolpathLayer::GetSegmentType - Retrieves the segment type.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Type
	*/
	eToolpathSegmentType CToolpathLayer::GetSegmentType(const LibMCEnv_uint32 nIndex)
	{
		eToolpathSegmentType resultType = (eToolpathSegmentType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentType(m_pHandle, nIndex, &resultType));
		
		return resultType;
	}
	
	/**
	* CToolpathLayer::SegmentIsLoop - Returns if segment is a loop.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Flag if segment is a loop.
	*/
	bool CToolpathLayer::SegmentIsLoop(const LibMCEnv_uint32 nIndex)
	{
		bool resultIsLoop = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_SegmentIsLoop(m_pHandle, nIndex, &resultIsLoop));
		
		return resultIsLoop;
	}
	
	/**
	* CToolpathLayer::SegmentIsPolyline - Returns if segment is a polyline.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Flag if segment is a polyline.
	*/
	bool CToolpathLayer::SegmentIsPolyline(const LibMCEnv_uint32 nIndex)
	{
		bool resultIsPolyline = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_SegmentIsPolyline(m_pHandle, nIndex, &resultIsPolyline));
		
		return resultIsPolyline;
	}
	
	/**
	* CToolpathLayer::SegmentIsHatchSegment - Returns if segment is a hatch segment.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Flag if segment is a hatch segment.
	*/
	bool CToolpathLayer::SegmentIsHatchSegment(const LibMCEnv_uint32 nIndex)
	{
		bool resultIsHatchSegment = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_SegmentIsHatchSegment(m_pHandle, nIndex, &resultIsHatchSegment));
		
		return resultIsHatchSegment;
	}
	
	/**
	* CToolpathLayer::GetSegmentIntegerAttribute - Retrieves the segment integer attribute with the corresponding ID. Fails if attribute does not exist or does have different type.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] nAttributeID - ID of the attribute.
	* @return Attribute Value.
	*/
	LibMCEnv_int64 CToolpathLayer::GetSegmentIntegerAttribute(const LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nAttributeID)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentIntegerAttribute(m_pHandle, nIndex, nAttributeID, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentDoubleAttribute - Retrieves the segment double attribute with the corresponding ID. Fails if attribute does not exist or does have different type.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] nAttributeID - ID of the attribute.
	* @return Attribute Value.
	*/
	LibMCEnv_double CToolpathLayer::GetSegmentDoubleAttribute(const LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nAttributeID)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentDoubleAttribute(m_pHandle, nIndex, nAttributeID, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::HasCustomSegmentAttribute - Checks if a segment attribute is registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @return Flag if attribute is registered.
	*/
	bool CToolpathLayer::HasCustomSegmentAttribute(const std::string & sNamespace, const std::string & sAttributeName)
	{
		bool resultValueExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_HasCustomSegmentAttribute(m_pHandle, sNamespace.c_str(), sAttributeName.c_str(), &resultValueExists));
		
		return resultValueExists;
	}
	
	/**
	* CToolpathLayer::FindCustomSegmentAttributeID - Finds a segment attribute ID. Fails if attribute is not registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @return ID of the attribute.
	*/
	LibMCEnv_uint32 CToolpathLayer::FindCustomSegmentAttributeID(const std::string & sNamespace, const std::string & sAttributeName)
	{
		LibMCEnv_uint32 resultAttributeID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_FindCustomSegmentAttributeID(m_pHandle, sNamespace.c_str(), sAttributeName.c_str(), &resultAttributeID));
		
		return resultAttributeID;
	}
	
	/**
	* CToolpathLayer::FindCustomSegmentAttributeType - Finds a segment attribute type. Fails if attribute is not registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @return Type of the attribute.
	*/
	eToolpathAttributeType CToolpathLayer::FindCustomSegmentAttributeType(const std::string & sNamespace, const std::string & sAttributeName)
	{
		eToolpathAttributeType resultAttributeType = (eToolpathAttributeType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_FindCustomSegmentAttributeType(m_pHandle, sNamespace.c_str(), sAttributeName.c_str(), &resultAttributeType));
		
		return resultAttributeType;
	}
	
	/**
	* CToolpathLayer::FindCustomSegmentAttributeInfo - Finds a segment attribute ID and type. Fails if attribute is not registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @param[out] nAttributeID - ID of the attribute.
	* @param[out] eAttributeType - Type of the attribute.
	*/
	void CToolpathLayer::FindCustomSegmentAttributeInfo(const std::string & sNamespace, const std::string & sAttributeName, LibMCEnv_uint32 & nAttributeID, eToolpathAttributeType & eAttributeType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_FindCustomSegmentAttributeInfo(m_pHandle, sNamespace.c_str(), sAttributeName.c_str(), &nAttributeID, &eAttributeType));
	}
	
	/**
	* CToolpathLayer::GetSegmentPointCount - Retrieves the number of points in the segment. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Hatch count of segment.
	*/
	LibMCEnv_uint32 CToolpathLayer::GetSegmentPointCount(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnv_uint32 resultHatchCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPointCount(m_pHandle, nIndex, &resultHatchCount));
		
		return resultHatchCount;
	}
	
	/**
	* CToolpathLayer::GetSegmentHatchCount - Retrieves the number of hatches in the segment (i.e. PointCount / 2). Returns 0 if segment is not of type hatch.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Hatch count of segment.
	*/
	LibMCEnv_uint32 CToolpathLayer::GetSegmentHatchCount(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnv_uint32 resultHatchCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentHatchCount(m_pHandle, nIndex, &resultHatchCount));
		
		return resultHatchCount;
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileUUID - Retrieves the assigned segment profile uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Profile UUID
	*/
	std::string CToolpathLayer::GetSegmentProfileUUID(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnv_uint32 bytesNeededProfileUUID = 0;
		LibMCEnv_uint32 bytesWrittenProfileUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileUUID(m_pHandle, nIndex, 0, &bytesNeededProfileUUID, nullptr));
		std::vector<char> bufferProfileUUID(bytesNeededProfileUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileUUID(m_pHandle, nIndex, bytesNeededProfileUUID, &bytesWrittenProfileUUID, &bufferProfileUUID[0]));
		
		return std::string(&bufferProfileUUID[0]);
	}
	
	/**
	* CToolpathLayer::SegmentProfileHasValue - Retrieves an assigned profile custom value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Returns true if value exist.
	*/
	bool CToolpathLayer::SegmentProfileHasValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName)
	{
		bool resultHasValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_SegmentProfileHasValue(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), &resultHasValue));
		
		return resultHasValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileValue - Retrieves an assigned profile custom value. Fails if value does not exist.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return String Value.
	*/
	std::string CToolpathLayer::GetSegmentProfileValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileValue(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileValue(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileValueDef - Retrieves an assigned profile custom value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] sDefaultValue - Default value if value does not exist.
	* @return String Value.
	*/
	std::string CToolpathLayer::GetSegmentProfileValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const std::string & sDefaultValue)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileValueDef(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), sDefaultValue.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileValueDef(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), sDefaultValue.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileDoubleValue - Retrieves an assigned profile custom double value. Fails if value does not exist or is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Double Value.
	*/
	LibMCEnv_double CToolpathLayer::GetSegmentProfileDoubleValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileDoubleValue(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileDoubleValueDef - Retrieves an assigned profile custom double value. Fails if value exists but is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] dDefaultValue - Default value if value does not exist.
	* @return Double Value.
	*/
	LibMCEnv_double CToolpathLayer::GetSegmentProfileDoubleValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const LibMCEnv_double dDefaultValue)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileDoubleValueDef(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), dDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileIntegerValue - Retrieves an assigned profile custom integer value. Fails if value does not exist or is not a integer value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Integer Value.
	*/
	LibMCEnv_int64 CToolpathLayer::GetSegmentProfileIntegerValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileIntegerValue(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileIntegerValueDef - Retrieves an assigned profile custom integer value. Fails if value exists but is not a integer value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] nDefaultValue - Default value if value does not exist.
	* @return Integer Value.
	*/
	LibMCEnv_int64 CToolpathLayer::GetSegmentProfileIntegerValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const LibMCEnv_int64 nDefaultValue)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileIntegerValueDef(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), nDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileBoolValue - Retrieves an assigned profile custom boolean value. A Boolean value is either an integer value, or strings of the form true or false (case insensitive). Fails if value does not exist or is not a bool value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Boolean Value.
	*/
	bool CToolpathLayer::GetSegmentProfileBoolValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileBoolValue(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileBoolValueDef - Retrieves an assigned profile custom boolean value. A Boolean value is either an integer value, or strings of the form true or false (case insensitive). Fails if value exists but is not a bool value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] bDefaultValue - Default value if value does not exist.
	* @return Boolean Value.
	*/
	bool CToolpathLayer::GetSegmentProfileBoolValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const bool bDefaultValue)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileBoolValueDef(m_pHandle, nIndex, sNamespace.c_str(), sValueName.c_str(), bDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileTypedValue - Retrieves an assigned profile value of a standard type. Fails if value does not exist or is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] eValueType - Enum to query for. MUST NOT be custom.
	* @return Double Value
	*/
	LibMCEnv_double CToolpathLayer::GetSegmentProfileTypedValue(const LibMCEnv_uint32 nIndex, const eToolpathProfileValueType eValueType)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileTypedValue(m_pHandle, nIndex, eValueType, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileTypedValueDef - Retrieves an assigned profile value of a standard type. Fails if value exists but is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] eValueType - Enum to query for. MUST NOT be custom.
	* @param[in] dDefaultValue - Default value if value does not exist.
	* @return Double Value
	*/
	LibMCEnv_double CToolpathLayer::GetSegmentProfileTypedValueDef(const LibMCEnv_uint32 nIndex, const eToolpathProfileValueType eValueType, const LibMCEnv_double dDefaultValue)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileTypedValueDef(m_pHandle, nIndex, eValueType, dDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentPartUUID - Retrieves the assigned segment part uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Part UUID
	*/
	std::string CToolpathLayer::GetSegmentPartUUID(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnv_uint32 bytesNeededPartUUID = 0;
		LibMCEnv_uint32 bytesWrittenPartUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPartUUID(m_pHandle, nIndex, 0, &bytesNeededPartUUID, nullptr));
		std::vector<char> bufferPartUUID(bytesNeededPartUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPartUUID(m_pHandle, nIndex, bytesNeededPartUUID, &bytesWrittenPartUUID, &bufferPartUUID[0]));
		
		return std::string(&bufferPartUUID[0]);
	}
	
	/**
	* CToolpathLayer::GetSegmentPointData - Retrieves the assigned segment point list. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] PointDataBuffer - The point data array. Positions are absolute in units.
	*/
	void CToolpathLayer::GetSegmentPointData(const LibMCEnv_uint32 nIndex, std::vector<sPosition2D> & PointDataBuffer)
	{
		LibMCEnv_uint64 elementsNeededPointData = 0;
		LibMCEnv_uint64 elementsWrittenPointData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPointData(m_pHandle, nIndex, 0, &elementsNeededPointData, nullptr));
		PointDataBuffer.resize((size_t) elementsNeededPointData);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPointData(m_pHandle, nIndex, elementsNeededPointData, &elementsWrittenPointData, PointDataBuffer.data()));
	}
	
	/**
	* CToolpathLayer::GetSegmentHatchData - Retrieves the assigned segment hatch list. Fails if segment type is not hatch.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] HatchDataBuffer - The hatch data array. Positions are absolute in units.
	*/
	void CToolpathLayer::GetSegmentHatchData(const LibMCEnv_uint32 nIndex, std::vector<sHatch2D> & HatchDataBuffer)
	{
		LibMCEnv_uint64 elementsNeededHatchData = 0;
		LibMCEnv_uint64 elementsWrittenHatchData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentHatchData(m_pHandle, nIndex, 0, &elementsNeededHatchData, nullptr));
		HatchDataBuffer.resize((size_t) elementsNeededHatchData);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentHatchData(m_pHandle, nIndex, elementsNeededHatchData, &elementsWrittenHatchData, HatchDataBuffer.data()));
	}
	
	/**
	* CToolpathLayer::GetSegmentPointDataInMM - Retrieves the assigned segment point list. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] PointDataBuffer - The point data array. Positions are absolute in mm.
	*/
	void CToolpathLayer::GetSegmentPointDataInMM(const LibMCEnv_uint32 nIndex, std::vector<sFloatPosition2D> & PointDataBuffer)
	{
		LibMCEnv_uint64 elementsNeededPointData = 0;
		LibMCEnv_uint64 elementsWrittenPointData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPointDataInMM(m_pHandle, nIndex, 0, &elementsNeededPointData, nullptr));
		PointDataBuffer.resize((size_t) elementsNeededPointData);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPointDataInMM(m_pHandle, nIndex, elementsNeededPointData, &elementsWrittenPointData, PointDataBuffer.data()));
	}
	
	/**
	* CToolpathLayer::GetSegmentHatchDataInMM - Retrieves the assigned segment hatch list. Fails if segment type is not hatch.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] HatchDataBuffer - The hatch data array. Positions are absolute in mm.
	*/
	void CToolpathLayer::GetSegmentHatchDataInMM(const LibMCEnv_uint32 nIndex, std::vector<sFloatHatch2D> & HatchDataBuffer)
	{
		LibMCEnv_uint64 elementsNeededHatchData = 0;
		LibMCEnv_uint64 elementsWrittenHatchData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentHatchDataInMM(m_pHandle, nIndex, 0, &elementsNeededHatchData, nullptr));
		HatchDataBuffer.resize((size_t) elementsNeededHatchData);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentHatchDataInMM(m_pHandle, nIndex, elementsNeededHatchData, &elementsWrittenHatchData, HatchDataBuffer.data()));
	}
	
	/**
	* CToolpathLayer::GetZValue - Retrieves the layers Z Value in units.
	* @return Z Value of the layer in units.
	*/
	LibMCEnv_int32 CToolpathLayer::GetZValue()
	{
		LibMCEnv_int32 resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetZValue(m_pHandle, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CToolpathLayer::GetZValueInMM - Retrieves the layers Z Value in mm.
	* @return Z Value of the layer in mm.
	*/
	LibMCEnv_double CToolpathLayer::GetZValueInMM()
	{
		LibMCEnv_double resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetZValueInMM(m_pHandle, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CToolpathLayer::GetUnits - Retrieves the toolpath units in mm.
	* @return Toolpath units.
	*/
	LibMCEnv_double CToolpathLayer::GetUnits()
	{
		LibMCEnv_double resultUnits = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetUnits(m_pHandle, &resultUnits));
		
		return resultUnits;
	}
	
	/**
	* CToolpathLayer::GetMetaDataCount - Retrieves the number of metadata nodes in the build file.
	* @return Meta Data information.
	*/
	LibMCEnv_uint32 CToolpathLayer::GetMetaDataCount()
	{
		LibMCEnv_uint32 resultMetaDataCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetMetaDataCount(m_pHandle, &resultMetaDataCount));
		
		return resultMetaDataCount;
	}
	
	/**
	* CToolpathLayer::GetMetaDataInfo - Returns the namespace and identifier of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @param[out] sNamespace - Namespace of the metadata
	* @param[out] sName - Name of the metadata
	*/
	void CToolpathLayer::GetMetaDataInfo(const LibMCEnv_uint32 nMetaDataIndex, std::string & sNamespace, std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededNamespace = 0;
		LibMCEnv_uint32 bytesWrittenNamespace = 0;
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetMetaDataInfo(m_pHandle, nMetaDataIndex, 0, &bytesNeededNamespace, nullptr, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferNamespace(bytesNeededNamespace);
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetMetaDataInfo(m_pHandle, nMetaDataIndex, bytesNeededNamespace, &bytesWrittenNamespace, &bufferNamespace[0], bytesNeededName, &bytesWrittenName, &bufferName[0]));
		sNamespace = std::string(&bufferNamespace[0]);
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* CToolpathLayer::GetMetaDataContent - Returns the metadata XML content of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @return XML Metadata Object
	*/
	PXMLDocumentNode CToolpathLayer::GetMetaDataContent(const LibMCEnv_uint32 nMetaDataIndex)
	{
		LibMCEnvHandle hXMLNode = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetMetaDataContent(m_pHandle, nMetaDataIndex, &hXMLNode));
		
		if (!hXMLNode) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNode>(m_pWrapper, hXMLNode);
	}
	
	/**
	* CToolpathLayer::HasUniqueMetaData - Checks if a metadata exists in the build file.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return Returns true if metadata exists and is unique.
	*/
	bool CToolpathLayer::HasUniqueMetaData(const std::string & sNamespace, const std::string & sName)
	{
		bool resultMetaDataExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_HasUniqueMetaData(m_pHandle, sNamespace.c_str(), sName.c_str(), &resultMetaDataExists));
		
		return resultMetaDataExists;
	}
	
	/**
	* CToolpathLayer::FindUniqueMetaData - Returns the given metadata XML content of the build file. Fails if metadata content does not exist or is not unique.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return XML Metadata Object
	*/
	PXMLDocumentNode CToolpathLayer::FindUniqueMetaData(const std::string & sNamespace, const std::string & sName)
	{
		LibMCEnvHandle hXMLNode = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_FindUniqueMetaData(m_pHandle, sNamespace.c_str(), sName.c_str(), &hXMLNode));
		
		if (!hXMLNode) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNode>(m_pWrapper, hXMLNode);
	}
	
	/**
	* CToolpathLayer::CalculateExtents - Calculates the layers extents in units
	* @param[out] nMinX - Minimal X value of the layer in units.
	* @param[out] nMinY - Minimal Y value of the layer in units.
	* @param[out] nMaxX - Maximal X value of the layer in units.
	* @param[out] nMaxY - Maximal Y value of the layer in units.
	*/
	void CToolpathLayer::CalculateExtents(LibMCEnv_int32 & nMinX, LibMCEnv_int32 & nMinY, LibMCEnv_int32 & nMaxX, LibMCEnv_int32 & nMaxY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_CalculateExtents(m_pHandle, &nMinX, &nMinY, &nMaxX, &nMaxY));
	}
	
	/**
	* CToolpathLayer::CalculateExtentsInMM - Calculates the layers extents in millimeters
	* @param[out] dMinX - Minimal X value of the layer in mm.
	* @param[out] dMinY - Minimal Y value of the layer in mm.
	* @param[out] dMaxX - Maximal X value of the layer in mm.
	* @param[out] dMaxY - Maximal Y value of the layer in mm.
	*/
	void CToolpathLayer::CalculateExtentsInMM(LibMCEnv_double & dMinX, LibMCEnv_double & dMinY, LibMCEnv_double & dMaxX, LibMCEnv_double & dMaxY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_CalculateExtentsInMM(m_pHandle, &dMinX, &dMinY, &dMaxX, &dMaxY));
	}
	
	/**
	 * Method definitions for class CToolpathAccessor
	 */
	
	/**
	* CToolpathAccessor::GetStorageUUID - Returns Toolpath storage UUID.
	* @return Returns toolpath storage uuid.
	*/
	std::string CToolpathAccessor::GetStorageUUID()
	{
		LibMCEnv_uint32 bytesNeededStorageUUID = 0;
		LibMCEnv_uint32 bytesWrittenStorageUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetStorageUUID(m_pHandle, 0, &bytesNeededStorageUUID, nullptr));
		std::vector<char> bufferStorageUUID(bytesNeededStorageUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetStorageUUID(m_pHandle, bytesNeededStorageUUID, &bytesWrittenStorageUUID, &bufferStorageUUID[0]));
		
		return std::string(&bufferStorageUUID[0]);
	}
	
	/**
	* CToolpathAccessor::GetBuildUUID - Returns UUID of the toolpath's build file.
	* @return Returns build uuid.
	*/
	std::string CToolpathAccessor::GetBuildUUID()
	{
		LibMCEnv_uint32 bytesNeededBuildUUID = 0;
		LibMCEnv_uint32 bytesWrittenBuildUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetBuildUUID(m_pHandle, 0, &bytesNeededBuildUUID, nullptr));
		std::vector<char> bufferBuildUUID(bytesNeededBuildUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetBuildUUID(m_pHandle, bytesNeededBuildUUID, &bytesWrittenBuildUUID, &bufferBuildUUID[0]));
		
		return std::string(&bufferBuildUUID[0]);
	}
	
	/**
	* CToolpathAccessor::GetLayerCount - Returns layer count.
	* @return Returns layer count.
	*/
	LibMCEnv_uint32 CToolpathAccessor::GetLayerCount()
	{
		LibMCEnv_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CToolpathAccessor::RegisterCustomSegmentAttribute - Registers a new custom segment attribute to be read.
	* @param[in] sNameSpace - Namespace of the custom attribute.
	* @param[in] sAttributeName - Name of the custom attribute.
	* @param[in] eAttributeType - Attribute Type.
	*/
	void CToolpathAccessor::RegisterCustomSegmentAttribute(const std::string & sNameSpace, const std::string & sAttributeName, const eToolpathAttributeType eAttributeType)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_RegisterCustomSegmentAttribute(m_pHandle, sNameSpace.c_str(), sAttributeName.c_str(), eAttributeType));
	}
	
	/**
	* CToolpathAccessor::LoadLayer - Reads and returns a layer object.
	* @param[in] nLayerIndex - Layer Index.
	* @return Toolpath layer object.
	*/
	PToolpathLayer CToolpathAccessor::LoadLayer(const LibMCEnv_uint32 nLayerIndex)
	{
		LibMCEnvHandle hLayerData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_LoadLayer(m_pHandle, nLayerIndex, &hLayerData));
		
		if (!hLayerData) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CToolpathLayer>(m_pWrapper, hLayerData);
	}
	
	/**
	* CToolpathAccessor::GetUnits - Retrieves the toolpath units in mm.
	* @return Toolpath units.
	*/
	LibMCEnv_double CToolpathAccessor::GetUnits()
	{
		LibMCEnv_double resultUnits = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetUnits(m_pHandle, &resultUnits));
		
		return resultUnits;
	}
	
	/**
	* CToolpathAccessor::GetPartCount - Retrieves the number of parts in the toolpath.
	* @return Number of parts.
	*/
	LibMCEnv_uint32 CToolpathAccessor::GetPartCount()
	{
		LibMCEnv_uint32 resultPartCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetPartCount(m_pHandle, &resultPartCount));
		
		return resultPartCount;
	}
	
	/**
	* CToolpathAccessor::GetPart - Retrieves the part information of a toolpath.
	* @param[in] nPartIndex - Index of part. MUST be between 0 and PartCount-1
	* @return Part Instance
	*/
	PToolpathPart CToolpathAccessor::GetPart(const LibMCEnv_uint32 nPartIndex)
	{
		LibMCEnvHandle hPart = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetPart(m_pHandle, nPartIndex, &hPart));
		
		if (!hPart) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CToolpathPart>(m_pWrapper, hPart);
	}
	
	/**
	* CToolpathAccessor::FindPartByUUID - Finds the part information of a toolpath.
	* @param[in] sPartUUID - UUID of part.
	* @return Part Instance. Returns null if part does not exist.
	*/
	PToolpathPart CToolpathAccessor::FindPartByUUID(const std::string & sPartUUID)
	{
		LibMCEnvHandle hPart = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_FindPartByUUID(m_pHandle, sPartUUID.c_str(), &hPart));
		
		if (hPart) {
			return std::make_shared<CToolpathPart>(m_pWrapper, hPart);
		} else {
			return nullptr;
		}
	}
	
	/**
	* CToolpathAccessor::GetBuildHeightInUnits - Retrieves the build height in units.
	* @return Build height in units.
	*/
	LibMCEnv_int32 CToolpathAccessor::GetBuildHeightInUnits()
	{
		LibMCEnv_int32 resultBuildHeight = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetBuildHeightInUnits(m_pHandle, &resultBuildHeight));
		
		return resultBuildHeight;
	}
	
	/**
	* CToolpathAccessor::GetZValueInUnits - Retrieves the layers Z Value in units.
	* @param[in] nLayerIndex - Layer Index to return.
	* @return Z Value of the layer in units.
	*/
	LibMCEnv_int32 CToolpathAccessor::GetZValueInUnits(const LibMCEnv_uint32 nLayerIndex)
	{
		LibMCEnv_int32 resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetZValueInUnits(m_pHandle, nLayerIndex, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CToolpathAccessor::GetBuildHeightInMM - Retrieves the build height in mm.
	* @return Build height in mm.
	*/
	LibMCEnv_double CToolpathAccessor::GetBuildHeightInMM()
	{
		LibMCEnv_double resultBuildHeight = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetBuildHeightInMM(m_pHandle, &resultBuildHeight));
		
		return resultBuildHeight;
	}
	
	/**
	* CToolpathAccessor::GetZValueInMM - Retrieves the layers Z Value in mm.
	* @param[in] nLayerIndex - Layer Index to return.
	* @return Z Value of the layer in mm.
	*/
	LibMCEnv_double CToolpathAccessor::GetZValueInMM(const LibMCEnv_uint32 nLayerIndex)
	{
		LibMCEnv_double resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetZValueInMM(m_pHandle, nLayerIndex, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CToolpathAccessor::GetMetaDataCount - Retrieves the number of metadata nodes in the build file.
	* @return Meta Data information.
	*/
	LibMCEnv_uint32 CToolpathAccessor::GetMetaDataCount()
	{
		LibMCEnv_uint32 resultMetaDataCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetMetaDataCount(m_pHandle, &resultMetaDataCount));
		
		return resultMetaDataCount;
	}
	
	/**
	* CToolpathAccessor::GetMetaDataInfo - Returns the namespace and identifier of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @param[out] sNamespace - Namespace of the metadata
	* @param[out] sName - Name of the metadata
	*/
	void CToolpathAccessor::GetMetaDataInfo(const LibMCEnv_uint32 nMetaDataIndex, std::string & sNamespace, std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededNamespace = 0;
		LibMCEnv_uint32 bytesWrittenNamespace = 0;
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetMetaDataInfo(m_pHandle, nMetaDataIndex, 0, &bytesNeededNamespace, nullptr, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferNamespace(bytesNeededNamespace);
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetMetaDataInfo(m_pHandle, nMetaDataIndex, bytesNeededNamespace, &bytesWrittenNamespace, &bufferNamespace[0], bytesNeededName, &bytesWrittenName, &bufferName[0]));
		sNamespace = std::string(&bufferNamespace[0]);
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* CToolpathAccessor::GetMetaDataContent - Returns the metadata XML content of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @return XML Metadata Object
	*/
	PXMLDocumentNode CToolpathAccessor::GetMetaDataContent(const LibMCEnv_uint32 nMetaDataIndex)
	{
		LibMCEnvHandle hXMLNode = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetMetaDataContent(m_pHandle, nMetaDataIndex, &hXMLNode));
		
		if (!hXMLNode) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNode>(m_pWrapper, hXMLNode);
	}
	
	/**
	* CToolpathAccessor::HasUniqueMetaData - Checks if a metadata exists in the build file.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return Returns true if metadata exists and is unique.
	*/
	bool CToolpathAccessor::HasUniqueMetaData(const std::string & sNamespace, const std::string & sName)
	{
		bool resultMetaDataExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_HasUniqueMetaData(m_pHandle, sNamespace.c_str(), sName.c_str(), &resultMetaDataExists));
		
		return resultMetaDataExists;
	}
	
	/**
	* CToolpathAccessor::FindUniqueMetaData - Returns the given metadata XML content of the build file. Fails if metadata content does not exist or is not unique.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return XML Metadata Object
	*/
	PXMLDocumentNode CToolpathAccessor::FindUniqueMetaData(const std::string & sNamespace, const std::string & sName)
	{
		LibMCEnvHandle hXMLNode = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_FindUniqueMetaData(m_pHandle, sNamespace.c_str(), sName.c_str(), &hXMLNode));
		
		if (!hXMLNode) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNode>(m_pWrapper, hXMLNode);
	}
	
	/**
	 * Method definitions for class CBuildExecution
	 */
	
	/**
	* CBuildExecution::GetUUID - Returns uuid of the build execution.
	* @return UUID of the build execution.
	*/
	std::string CBuildExecution::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededExecutionUUID = 0;
		LibMCEnv_uint32 bytesWrittenExecutionUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetUUID(m_pHandle, 0, &bytesNeededExecutionUUID, nullptr));
		std::vector<char> bufferExecutionUUID(bytesNeededExecutionUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetUUID(m_pHandle, bytesNeededExecutionUUID, &bytesWrittenExecutionUUID, &bufferExecutionUUID[0]));
		
		return std::string(&bufferExecutionUUID[0]);
	}
	
	/**
	* CBuildExecution::GetBuildUUID - Returns uuid of the build.
	* @return UUID of the build.
	*/
	std::string CBuildExecution::GetBuildUUID()
	{
		LibMCEnv_uint32 bytesNeededBuildUUID = 0;
		LibMCEnv_uint32 bytesWrittenBuildUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetBuildUUID(m_pHandle, 0, &bytesNeededBuildUUID, nullptr));
		std::vector<char> bufferBuildUUID(bytesNeededBuildUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetBuildUUID(m_pHandle, bytesNeededBuildUUID, &bytesWrittenBuildUUID, &bufferBuildUUID[0]));
		
		return std::string(&bufferBuildUUID[0]);
	}
	
	/**
	* CBuildExecution::GetBuild - Returns the instance of the build.
	* @return Instance of the build.
	*/
	PBuild CBuildExecution::GetBuild()
	{
		LibMCEnvHandle hBuildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetBuild(m_pHandle, &hBuildInstance));
		
		if (!hBuildInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuild>(m_pWrapper, hBuildInstance);
	}
	
	/**
	* CBuildExecution::GetExecutionStatus - Returns the status of the execution.
	* @return Status of the build.
	*/
	eBuildExecutionStatus CBuildExecution::GetExecutionStatus()
	{
		eBuildExecutionStatus resultExecutionStatus = (eBuildExecutionStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetExecutionStatus(m_pHandle, &resultExecutionStatus));
		
		return resultExecutionStatus;
	}
	
	/**
	* CBuildExecution::IsInProcess - Convenience function for checking the execution status.
	* @return Returns true if the status is InProcess.
	*/
	bool CBuildExecution::IsInProcess()
	{
		bool resultIsInProcess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_IsInProcess(m_pHandle, &resultIsInProcess));
		
		return resultIsInProcess;
	}
	
	/**
	* CBuildExecution::IsFinished - Convenience function for checking the execution status.
	* @return Returns true if the status is Finished.
	*/
	bool CBuildExecution::IsFinished()
	{
		bool resultIsInProcess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_IsFinished(m_pHandle, &resultIsInProcess));
		
		return resultIsInProcess;
	}
	
	/**
	* CBuildExecution::IsFailed - Convenience function for checking the execution status.
	* @return Returns true if the status is Failed.
	*/
	bool CBuildExecution::IsFailed()
	{
		bool resultIsInProcess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_IsFailed(m_pHandle, &resultIsInProcess));
		
		return resultIsInProcess;
	}
	
	/**
	* CBuildExecution::SetStatusToFinished - Sets build execution status to finished. Fails if Build status is not InProcess 
	*/
	void CBuildExecution::SetStatusToFinished()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_SetStatusToFinished(m_pHandle));
	}
	
	/**
	* CBuildExecution::SetStatusToFailed - Sets build execution status to failed. Fails if Build status is not InProcess 
	*/
	void CBuildExecution::SetStatusToFailed()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_SetStatusToFailed(m_pHandle));
	}
	
	/**
	* CBuildExecution::GetDescription - Returns a human readable description of the build execution for display in the User Interface.
	* @return Description.
	*/
	std::string CBuildExecution::GetDescription()
	{
		LibMCEnv_uint32 bytesNeededDescription = 0;
		LibMCEnv_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetDescription(m_pHandle, 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetDescription(m_pHandle, bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CBuildExecution::SetDescription - Sets a human readable description of the build execution for display in the User Interface. Should not be empty.
	* @param[in] sDescription - Description.
	*/
	void CBuildExecution::SetDescription(const std::string & sDescription)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_SetDescription(m_pHandle, sDescription.c_str()));
	}
	
	/**
	* CBuildExecution::GetJournalUUID - Returns the machine journal UUID that this job in executing in.
	* @return Journal UUID of build execution.
	*/
	std::string CBuildExecution::GetJournalUUID()
	{
		LibMCEnv_uint32 bytesNeededJournalUUID = 0;
		LibMCEnv_uint32 bytesWrittenJournalUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetJournalUUID(m_pHandle, 0, &bytesNeededJournalUUID, nullptr));
		std::vector<char> bufferJournalUUID(bytesNeededJournalUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetJournalUUID(m_pHandle, bytesNeededJournalUUID, &bytesWrittenJournalUUID, &bufferJournalUUID[0]));
		
		return std::string(&bufferJournalUUID[0]);
	}
	
	/**
	* CBuildExecution::HasAttachedUser - Returns if a user is attached to the execution.
	* @return Flag if a user is attached to the execution.
	*/
	bool CBuildExecution::HasAttachedUser()
	{
		bool resultUserIsAttached = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_HasAttachedUser(m_pHandle, &resultUserIsAttached));
		
		return resultUserIsAttached;
	}
	
	/**
	* CBuildExecution::GetUserUUID - Returns the user that started this job. Fails if no user is attached to the execution.
	* @return User who started the job.
	*/
	std::string CBuildExecution::GetUserUUID()
	{
		LibMCEnv_uint32 bytesNeededUserUUID = 0;
		LibMCEnv_uint32 bytesWrittenUserUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetUserUUID(m_pHandle, 0, &bytesNeededUserUUID, nullptr));
		std::vector<char> bufferUserUUID(bytesNeededUserUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetUserUUID(m_pHandle, bytesNeededUserUUID, &bytesWrittenUserUUID, &bufferUserUUID[0]));
		
		return std::string(&bufferUserUUID[0]);
	}
	
	/**
	* CBuildExecution::GetStartTimeStampInMilliseconds - Returns the start time stamp of the build execution in the current machine journal.
	* @return TimeStamp when the build started in Milliseconds.
	*/
	LibMCEnv_uint64 CBuildExecution::GetStartTimeStampInMilliseconds()
	{
		LibMCEnv_uint64 resultTimeStampInMilliseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetStartTimeStampInMilliseconds(m_pHandle, &resultTimeStampInMilliseconds));
		
		return resultTimeStampInMilliseconds;
	}
	
	/**
	* CBuildExecution::GetStartTimeStampInMicroseconds - Returns the start time stamp of the build execution in the current machine journal.
	* @return TimeStamp when the build started in Microseconds.
	*/
	LibMCEnv_uint64 CBuildExecution::GetStartTimeStampInMicroseconds()
	{
		LibMCEnv_uint64 resultTimeStampInMicroseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetStartTimeStampInMicroseconds(m_pHandle, &resultTimeStampInMicroseconds));
		
		return resultTimeStampInMicroseconds;
	}
	
	/**
	* CBuildExecution::GetEndTimeStampInMilliseconds - Returns the end time stamp of the build execution in the current machine journal. Status MUST BE in Finished or Failed to retrieve this value.
	* @return TimeStamp when the build ended in Milliseconds.
	*/
	LibMCEnv_uint64 CBuildExecution::GetEndTimeStampInMilliseconds()
	{
		LibMCEnv_uint64 resultTimeStampInMilliseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetEndTimeStampInMilliseconds(m_pHandle, &resultTimeStampInMilliseconds));
		
		return resultTimeStampInMilliseconds;
	}
	
	/**
	* CBuildExecution::GetEndTimeStampInMicroseconds - Returns the end time stamp of the build execution in the current machine journal. Status MUST BE in Finished or Failed to retrieve this value.
	* @return TimeStamp when the build ended in Microseconds.
	*/
	LibMCEnv_uint64 CBuildExecution::GetEndTimeStampInMicroseconds()
	{
		LibMCEnv_uint64 resultTimeStampInMicroseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetEndTimeStampInMicroseconds(m_pHandle, &resultTimeStampInMicroseconds));
		
		return resultTimeStampInMicroseconds;
	}
	
	/**
	* CBuildExecution::GetElapsedTimeInMilliseconds - Returns the relative time of the build execution. If status is Finished or Failed, the full duration is returned.
	* @return Elapsed time in Milliseconds.
	*/
	LibMCEnv_uint64 CBuildExecution::GetElapsedTimeInMilliseconds()
	{
		LibMCEnv_uint64 resultTimeStampInMilliseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetElapsedTimeInMilliseconds(m_pHandle, &resultTimeStampInMilliseconds));
		
		return resultTimeStampInMilliseconds;
	}
	
	/**
	* CBuildExecution::GetElapsedTimeInMicroseconds - Returns the relative time of the build execution. If status is Finished or Failed, the full duration is returned.
	* @return Elapsed time in Microseconds.
	*/
	LibMCEnv_uint64 CBuildExecution::GetElapsedTimeInMicroseconds()
	{
		LibMCEnv_uint64 resultTimeStampInMicroseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetElapsedTimeInMicroseconds(m_pHandle, &resultTimeStampInMicroseconds));
		
		return resultTimeStampInMicroseconds;
	}
	
	/**
	* CBuildExecution::HasAttachment - Returns if the Execution has an attached data with a certain UUID
	* @param[in] sDataUUID - Data UUID of the attachment to query. 
	* @return Returns true if the data exists.
	*/
	bool CBuildExecution::HasAttachment(const std::string & sDataUUID)
	{
		bool resultDataExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_HasAttachment(m_pHandle, sDataUUID.c_str(), &resultDataExists));
		
		return resultDataExists;
	}
	
	/**
	* CBuildExecution::HasAttachmentIdentifier - Returns if the Execution has an attached data with a certain identifier
	* @param[in] sIdentifier - Identifier of the attachment to query.
	* @return Returns true if the data exists.
	*/
	bool CBuildExecution::HasAttachmentIdentifier(const std::string & sIdentifier)
	{
		bool resultDataExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_HasAttachmentIdentifier(m_pHandle, sIdentifier.c_str(), &resultDataExists));
		
		return resultDataExists;
	}
	
	/**
	* CBuildExecution::AddBinaryData - Adds binary data to store with the build execution.
	* @param[in] sIdentifier - Unique identifier of the attached data. Fails if ther already exists a binary data with the equal identifier.
	* @param[in] sName - Name of the attache data
	* @param[in] sMIMEType - Mime type of the data.
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @param[in] ContentBuffer - Stream content to store
	* @return Data UUID of the attachment.
	*/
	std::string CBuildExecution::AddBinaryData(const std::string & sIdentifier, const std::string & sName, const std::string & sMIMEType, const std::string & sUserUUID, const CInputVector<LibMCEnv_uint8> & ContentBuffer)
	{
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_AddBinaryData(m_pHandle, sIdentifier.c_str(), sName.c_str(), sMIMEType.c_str(), sUserUUID.c_str(), (LibMCEnv_uint64)ContentBuffer.size(), ContentBuffer.data(), 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_AddBinaryData(m_pHandle, sIdentifier.c_str(), sName.c_str(), sMIMEType.c_str(), sUserUUID.c_str(), (LibMCEnv_uint64)ContentBuffer.size(), ContentBuffer.data(), bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuildExecution::AttachTempStream - Attaches a temp stream to the build execution.
	* @param[in] sIdentifier - Unique identifier of the attached data. Fails if ther already exists a binary data with the equal identifier.
	* @param[in] sName - Name of the attached data
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @param[in] pStreamWriterInstance - Stream to attach to the build.
	* @return Data UUID of the attachment.
	*/
	std::string CBuildExecution::AttachTempStream(const std::string & sIdentifier, const std::string & sName, const std::string & sUserUUID, classParam<CBaseTempStreamWriter> pStreamWriterInstance)
	{
		LibMCEnvHandle hStreamWriterInstance = pStreamWriterInstance.GetHandle();
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_AttachTempStream(m_pHandle, sIdentifier.c_str(), sName.c_str(), sUserUUID.c_str(), hStreamWriterInstance, 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_AttachTempStream(m_pHandle, sIdentifier.c_str(), sName.c_str(), sUserUUID.c_str(), hStreamWriterInstance, bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuildExecution::LoadStreamByIdentifier - Loads stream of the build execution by attachment identifier.
	* @param[in] sIdentifier - Unique name of the attachment. Fails if name does not exist.
	* @return Reader class to access the stream.
	*/
	PStreamReader CBuildExecution::LoadStreamByIdentifier(const std::string & sIdentifier)
	{
		LibMCEnvHandle hStreamReaderInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_LoadStreamByIdentifier(m_pHandle, sIdentifier.c_str(), &hStreamReaderInstance));
		
		if (!hStreamReaderInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStreamReader>(m_pWrapper, hStreamReaderInstance);
	}
	
	/**
	* CBuildExecution::LoadStreamByUUID - Loads stream of the build by attachment UUID.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if uuid does not exist.
	* @return Reader class to access the stream.
	*/
	PStreamReader CBuildExecution::LoadStreamByUUID(const std::string & sDataUUID)
	{
		LibMCEnvHandle hStreamReaderInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_LoadStreamByUUID(m_pHandle, sDataUUID.c_str(), &hStreamReaderInstance));
		
		if (!hStreamReaderInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStreamReader>(m_pWrapper, hStreamReaderInstance);
	}
	
	/**
	* CBuildExecution::LoadDiscreteField2DByIdentifier - Loads a discrete field by attachment identifier which was previously stored in the build execution. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sIdentifier - Unique name of the build execution attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	PDiscreteFieldData2D CBuildExecution::LoadDiscreteField2DByIdentifier(const std::string & sIdentifier)
	{
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_LoadDiscreteField2DByIdentifier(m_pHandle, sIdentifier.c_str(), &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CBuildExecution::LoadDiscreteField2DByUUID - Loads a discrete field by attachment uuid which previously stored in the build execution. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	PDiscreteFieldData2D CBuildExecution::LoadDiscreteField2DByUUID(const std::string & sDataUUID)
	{
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_LoadDiscreteField2DByUUID(m_pHandle, sDataUUID.c_str(), &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CBuildExecution::StoreDiscreteField2D - Stores a discrete field in the build execution. MIME Type will be application/amcf-discretefield2d.
	* @param[in] sIdentifier - Unique name of the attachment. Fails if identifier already exists or is invalid.
	* @param[in] sName - Human Readable name of the attachment.
	* @param[in] pFieldDataInstance - Field instance to store.
	* @param[in] pStoreOptions - Field Data Store Options.
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @return Data UUID of the attachment.
	*/
	std::string CBuildExecution::StoreDiscreteField2D(const std::string & sIdentifier, const std::string & sName, classParam<CDiscreteFieldData2D> pFieldDataInstance, classParam<CDiscreteFieldData2DStoreOptions> pStoreOptions, const std::string & sUserUUID)
	{
		LibMCEnvHandle hFieldDataInstance = pFieldDataInstance.GetHandle();
		LibMCEnvHandle hStoreOptions = pStoreOptions.GetHandle();
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_StoreDiscreteField2D(m_pHandle, sIdentifier.c_str(), sName.c_str(), hFieldDataInstance, hStoreOptions, sUserUUID.c_str(), 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_StoreDiscreteField2D(m_pHandle, sIdentifier.c_str(), sName.c_str(), hFieldDataInstance, hStoreOptions, sUserUUID.c_str(), bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuildExecution::LoadDataTableByIdentifier - Loads a data table by attachment identifier which was previously stored in the build execution. MIME Type MUST be application/amcf-datatable.
	* @param[in] sIdentifier - Unique name of the build execution attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded data table instance.
	*/
	PDataTable CBuildExecution::LoadDataTableByIdentifier(const std::string & sIdentifier)
	{
		LibMCEnvHandle hDataTableInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_LoadDataTableByIdentifier(m_pHandle, sIdentifier.c_str(), &hDataTableInstance));
		
		if (!hDataTableInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataTable>(m_pWrapper, hDataTableInstance);
	}
	
	/**
	* CBuildExecution::LoadDataTableByUUID - Loads a data table by attachment uuid which previously stored in the build execution. MIME Type MUST be application/amcf-datatable.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded data table instance.
	*/
	PDataTable CBuildExecution::LoadDataTableByUUID(const std::string & sDataUUID)
	{
		LibMCEnvHandle hDataTableInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_LoadDataTableByUUID(m_pHandle, sDataUUID.c_str(), &hDataTableInstance));
		
		if (!hDataTableInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataTable>(m_pWrapper, hDataTableInstance);
	}
	
	/**
	* CBuildExecution::StoreDataTable - Stores a data table in the build execution. MIME Type will be application/amcf-datatable.
	* @param[in] sIdentifier - Unique name of the attachment. Fails if identifier already exists or is invalid.
	* @param[in] sName - Human Readable name of the attachment.
	* @param[in] pFieldDataInstance - Field instance to store.
	* @param[in] pStoreOptions - Data Table Write Options.
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @return Data UUID of the attachment.
	*/
	std::string CBuildExecution::StoreDataTable(const std::string & sIdentifier, const std::string & sName, classParam<CDataTable> pFieldDataInstance, classParam<CDataTableWriteOptions> pStoreOptions, const std::string & sUserUUID)
	{
		LibMCEnvHandle hFieldDataInstance = pFieldDataInstance.GetHandle();
		LibMCEnvHandle hStoreOptions = pStoreOptions.GetHandle();
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_StoreDataTable(m_pHandle, sIdentifier.c_str(), sName.c_str(), hFieldDataInstance, hStoreOptions, sUserUUID.c_str(), 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_StoreDataTable(m_pHandle, sIdentifier.c_str(), sName.c_str(), hFieldDataInstance, hStoreOptions, sUserUUID.c_str(), bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuildExecution::LoadPNGImageByIdentifier - Loads a PNG image by attachment identifier which was previously stored in the build execution. MIME Type MUST be image/png.
	* @param[in] sIdentifier - Unique name of the attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image data instance.
	*/
	PImageData CBuildExecution::LoadPNGImageByIdentifier(const std::string & sIdentifier, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_LoadPNGImageByIdentifier(m_pHandle, sIdentifier.c_str(), dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CBuildExecution::LoadPNGImageByUUID - Loads a PNG image by attachment uuid which was previously stored in the build execution. MIME Type MUST be image/png.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image data instance.
	*/
	PImageData CBuildExecution::LoadPNGImageByUUID(const std::string & sDataUUID, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_LoadPNGImageByUUID(m_pHandle, sDataUUID.c_str(), dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CBuildExecution::StorePNGImage - Stores a PNG image in the build job. MIME Type will be image/png
	* @param[in] sIdentifier - Unique name of the attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] sName - Unique name of the attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] pImageDataInstance - Image data instance.
	* @param[in] pStoreOptions - PNG Store Options.
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @return Data UUID of the attachment.
	*/
	std::string CBuildExecution::StorePNGImage(const std::string & sIdentifier, const std::string & sName, classParam<CImageData> pImageDataInstance, classParam<CPNGImageStoreOptions> pStoreOptions, const std::string & sUserUUID)
	{
		LibMCEnvHandle hImageDataInstance = pImageDataInstance.GetHandle();
		LibMCEnvHandle hStoreOptions = pStoreOptions.GetHandle();
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_StorePNGImage(m_pHandle, sIdentifier.c_str(), sName.c_str(), hImageDataInstance, hStoreOptions, sUserUUID.c_str(), 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_StorePNGImage(m_pHandle, sIdentifier.c_str(), sName.c_str(), hImageDataInstance, hStoreOptions, sUserUUID.c_str(), bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuildExecution::StoreMetaDataString - Adds a metadata string to a build execution. Meta data can only be added once. Deletion is not supported by purpose and MUST be avoided by the system design.
	* @param[in] sKey - Unique key of value. MUST NOT be empty. MUST consist of alphanumeric characters or hyphen or underscore. Fails if Key already exists.
	* @param[in] sValue - Value to store.
	*/
	void CBuildExecution::StoreMetaDataString(const std::string & sKey, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_StoreMetaDataString(m_pHandle, sKey.c_str(), sValue.c_str()));
	}
	
	/**
	* CBuildExecution::HasMetaDataString - Checks if a metadata string exists.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Returns if metadata string exists.
	*/
	bool CBuildExecution::HasMetaDataString(const std::string & sKey)
	{
		bool resultMetaDataStringExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_HasMetaDataString(m_pHandle, sKey.c_str(), &resultMetaDataStringExists));
		
		return resultMetaDataStringExists;
	}
	
	/**
	* CBuildExecution::GetMetaDataString - Gets a metadata string of a build execution. Fails if Meta Data does not exist.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Return value.
	*/
	std::string CBuildExecution::GetMetaDataString(const std::string & sKey)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetMetaDataString(m_pHandle, sKey.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_GetMetaDataString(m_pHandle, sKey.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CBuildExecution::LoadAttachedJournal - Loads the journal that is associated with the build execution and returns an accessor instance.
	* @return Journal instance.
	*/
	PJournalHandler CBuildExecution::LoadAttachedJournal()
	{
		LibMCEnvHandle hJournalHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecution_LoadAttachedJournal(m_pHandle, &hJournalHandler));
		
		if (!hJournalHandler) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CJournalHandler>(m_pWrapper, hJournalHandler);
	}
	
	/**
	 * Method definitions for class CBuildExecutionIterator
	 */
	
	/**
	* CBuildExecutionIterator::GetCurrentExecution - Returns the execution the iterator points at.
	* @return returns the BuildExecution instance.
	*/
	PBuildExecution CBuildExecutionIterator::GetCurrentExecution()
	{
		LibMCEnvHandle hBuildExecutionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildExecutionIterator_GetCurrentExecution(m_pHandle, &hBuildExecutionInstance));
		
		if (!hBuildExecutionInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildExecution>(m_pWrapper, hBuildExecutionInstance);
	}
	
	/**
	 * Method definitions for class CBuild
	 */
	
	/**
	* CBuild::GetName - Returns name of the build.
	* @return Name of the build.
	*/
	std::string CBuild::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBuild::GetBuildUUID - Returns uuid of the build.
	* @return UUID of the build.
	*/
	std::string CBuild::GetBuildUUID()
	{
		LibMCEnv_uint32 bytesNeededBuildUUID = 0;
		LibMCEnv_uint32 bytesWrittenBuildUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetBuildUUID(m_pHandle, 0, &bytesNeededBuildUUID, nullptr));
		std::vector<char> bufferBuildUUID(bytesNeededBuildUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetBuildUUID(m_pHandle, bytesNeededBuildUUID, &bytesWrittenBuildUUID, &bufferBuildUUID[0]));
		
		return std::string(&bufferBuildUUID[0]);
	}
	
	/**
	* CBuild::GetStorageUUID - Returns storage uuid of the build stream.
	* @return Storage UUID of the build.
	*/
	std::string CBuild::GetStorageUUID()
	{
		LibMCEnv_uint32 bytesNeededStorageUUID = 0;
		LibMCEnv_uint32 bytesWrittenStorageUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetStorageUUID(m_pHandle, 0, &bytesNeededStorageUUID, nullptr));
		std::vector<char> bufferStorageUUID(bytesNeededStorageUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetStorageUUID(m_pHandle, bytesNeededStorageUUID, &bytesWrittenStorageUUID, &bufferStorageUUID[0]));
		
		return std::string(&bufferStorageUUID[0]);
	}
	
	/**
	* CBuild::GetStorageSHA256 - Returns SHA256 of the build stream.
	* @return SHA256 of the build stream.
	*/
	std::string CBuild::GetStorageSHA256()
	{
		LibMCEnv_uint32 bytesNeededSHA256 = 0;
		LibMCEnv_uint32 bytesWrittenSHA256 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetStorageSHA256(m_pHandle, 0, &bytesNeededSHA256, nullptr));
		std::vector<char> bufferSHA256(bytesNeededSHA256);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetStorageSHA256(m_pHandle, bytesNeededSHA256, &bytesWrittenSHA256, &bufferSHA256[0]));
		
		return std::string(&bufferSHA256[0]);
	}
	
	/**
	* CBuild::GetLayerCount - Returns cached layer count of the toolpath.
	* @return Returns layer count.
	*/
	LibMCEnv_uint32 CBuild::GetLayerCount()
	{
		LibMCEnv_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CBuild::GetBuildHeightInMM - Retrieves the build height in mm.
	* @return Build height in mm.
	*/
	LibMCEnv_double CBuild::GetBuildHeightInMM()
	{
		LibMCEnv_double resultBuildHeight = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetBuildHeightInMM(m_pHandle, &resultBuildHeight));
		
		return resultBuildHeight;
	}
	
	/**
	* CBuild::GetZValueInMM - Retrieves the layers Z Value in mm.
	* @param[in] nLayerIndex - Layer Index to return.
	* @return Z Value of the layer in mm.
	*/
	LibMCEnv_double CBuild::GetZValueInMM(const LibMCEnv_uint32 nLayerIndex)
	{
		LibMCEnv_double resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetZValueInMM(m_pHandle, nLayerIndex, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CBuild::LoadToolpath - loads the a toolpath into memory
	*/
	void CBuild::LoadToolpath()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadToolpath(m_pHandle));
	}
	
	/**
	* CBuild::UnloadToolpath - unloads the a toolpath from memory, if it has been loaded before.
	*/
	void CBuild::UnloadToolpath()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Build_UnloadToolpath(m_pHandle));
	}
	
	/**
	* CBuild::ToolpathIsLoaded - checks, if a toolpath object is loaded to memory.
	* @return returns if toolpath is loaded.
	*/
	bool CBuild::ToolpathIsLoaded()
	{
		bool resultIsLoaded = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_ToolpathIsLoaded(m_pHandle, &resultIsLoaded));
		
		return resultIsLoaded;
	}
	
	/**
	* CBuild::CreateToolpathAccessor - Creates an accessor object for a toolpath. Toolpath MUST have been loaded with LoadToolpath before.
	* @return Toolpath instance.
	*/
	PToolpathAccessor CBuild::CreateToolpathAccessor()
	{
		LibMCEnvHandle hToolpathInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_CreateToolpathAccessor(m_pHandle, &hToolpathInstance));
		
		if (!hToolpathInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CToolpathAccessor>(m_pWrapper, hToolpathInstance);
	}
	
	/**
	* CBuild::HasAttachment - Returns if the Build has an attached data with a certain UUID
	* @param[in] sDataUUID - Data UUID of the attachment to query. 
	* @return Returns true if the data exists.
	*/
	bool CBuild::HasAttachment(const std::string & sDataUUID)
	{
		bool resultDataExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_HasAttachment(m_pHandle, sDataUUID.c_str(), &resultDataExists));
		
		return resultDataExists;
	}
	
	/**
	* CBuild::HasAttachmentIdentifier - Returns if the Build has an attached data with a certain identifier
	* @param[in] sIdentifier - Identifier of the attachment to query.
	* @return Returns true if the data exists.
	*/
	bool CBuild::HasAttachmentIdentifier(const std::string & sIdentifier)
	{
		bool resultDataExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_HasAttachmentIdentifier(m_pHandle, sIdentifier.c_str(), &resultDataExists));
		
		return resultDataExists;
	}
	
	/**
	* CBuild::AddBinaryData - Adds binary data to store with the build.
	* @param[in] sIdentifier - Unique identifier of the attached data. Fails if ther already exists a binary data with the equal identifier.
	* @param[in] sName - Name of the attache data
	* @param[in] sMIMEType - Mime type of the data.
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @param[in] ContentBuffer - Stream content to store
	* @return Data UUID of the attachment.
	*/
	std::string CBuild::AddBinaryData(const std::string & sIdentifier, const std::string & sName, const std::string & sMIMEType, const std::string & sUserUUID, const CInputVector<LibMCEnv_uint8> & ContentBuffer)
	{
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_AddBinaryData(m_pHandle, sIdentifier.c_str(), sName.c_str(), sMIMEType.c_str(), sUserUUID.c_str(), (LibMCEnv_uint64)ContentBuffer.size(), ContentBuffer.data(), 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_AddBinaryData(m_pHandle, sIdentifier.c_str(), sName.c_str(), sMIMEType.c_str(), sUserUUID.c_str(), (LibMCEnv_uint64)ContentBuffer.size(), ContentBuffer.data(), bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuild::AttachTempStream - Attaches a temp stream to the build.
	* @param[in] sIdentifier - Unique identifier of the attached data. Fails if ther already exists a binary data with the equal identifier.
	* @param[in] sName - Name of the attached data
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @param[in] pStreamWriterInstance - Stream to attach to the build.
	* @return Data UUID of the attachment.
	*/
	std::string CBuild::AttachTempStream(const std::string & sIdentifier, const std::string & sName, const std::string & sUserUUID, classParam<CBaseTempStreamWriter> pStreamWriterInstance)
	{
		LibMCEnvHandle hStreamWriterInstance = pStreamWriterInstance.GetHandle();
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_AttachTempStream(m_pHandle, sIdentifier.c_str(), sName.c_str(), sUserUUID.c_str(), hStreamWriterInstance, 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_AttachTempStream(m_pHandle, sIdentifier.c_str(), sName.c_str(), sUserUUID.c_str(), hStreamWriterInstance, bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuild::LoadStreamByIdentifier - Loads stream of the build by identifier.
	* @param[in] sIdentifier - Unique name of the build attachment. Fails if name does not exist.
	* @return Reader class to access the stream.
	*/
	PStreamReader CBuild::LoadStreamByIdentifier(const std::string & sIdentifier)
	{
		LibMCEnvHandle hStreamReaderInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadStreamByIdentifier(m_pHandle, sIdentifier.c_str(), &hStreamReaderInstance));
		
		if (!hStreamReaderInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStreamReader>(m_pWrapper, hStreamReaderInstance);
	}
	
	/**
	* CBuild::LoadStreamByUUID - Loads stream of the build by attachment UUID.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if uuid does not exist.
	* @return Reader class to access the stream.
	*/
	PStreamReader CBuild::LoadStreamByUUID(const std::string & sDataUUID)
	{
		LibMCEnvHandle hStreamReaderInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadStreamByUUID(m_pHandle, sDataUUID.c_str(), &hStreamReaderInstance));
		
		if (!hStreamReaderInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStreamReader>(m_pWrapper, hStreamReaderInstance);
	}
	
	/**
	* CBuild::LoadDiscreteField2DByIdentifier - Loads a discrete field by identifier which was previously stored in the build job. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	PDiscreteFieldData2D CBuild::LoadDiscreteField2DByIdentifier(const std::string & sIdentifier)
	{
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadDiscreteField2DByIdentifier(m_pHandle, sIdentifier.c_str(), &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CBuild::LoadDiscreteField2DByUUID - Loads a discrete field by uuid which previously stored in the build job. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	PDiscreteFieldData2D CBuild::LoadDiscreteField2DByUUID(const std::string & sDataUUID)
	{
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadDiscreteField2DByUUID(m_pHandle, sDataUUID.c_str(), &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CBuild::StoreDiscreteField2D - Stores a discrete field in the build job. MIME Type will be application/amcf-discretefield2d.
	* @param[in] sIdentifier - Unique name of the build attachment. Fails if identifier already exists or is invalid.
	* @param[in] sName - Unique name of the build attachment.
	* @param[in] pFieldDataInstance - Field instance to store.
	* @param[in] pStoreOptions - Field Data Store Options.
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @return Data UUID of the attachment.
	*/
	std::string CBuild::StoreDiscreteField2D(const std::string & sIdentifier, const std::string & sName, classParam<CDiscreteFieldData2D> pFieldDataInstance, classParam<CDiscreteFieldData2DStoreOptions> pStoreOptions, const std::string & sUserUUID)
	{
		LibMCEnvHandle hFieldDataInstance = pFieldDataInstance.GetHandle();
		LibMCEnvHandle hStoreOptions = pStoreOptions.GetHandle();
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_StoreDiscreteField2D(m_pHandle, sIdentifier.c_str(), sName.c_str(), hFieldDataInstance, hStoreOptions, sUserUUID.c_str(), 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_StoreDiscreteField2D(m_pHandle, sIdentifier.c_str(), sName.c_str(), hFieldDataInstance, hStoreOptions, sUserUUID.c_str(), bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuild::LoadDataTableByIdentifier - Loads a data table by identifier which was previously stored in the build job. MIME Type MUST be application/amcf-datatable.
	* @param[in] sIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @return Data Table instance.
	*/
	PDataTable CBuild::LoadDataTableByIdentifier(const std::string & sIdentifier)
	{
		LibMCEnvHandle hDataTableInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadDataTableByIdentifier(m_pHandle, sIdentifier.c_str(), &hDataTableInstance));
		
		if (!hDataTableInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataTable>(m_pWrapper, hDataTableInstance);
	}
	
	/**
	* CBuild::LoadDataTableByUUID - Loads a data table by uuid which previously stored in the build job. MIME Type MUST be application/amcf-datatable.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Data Table instance.
	*/
	PDataTable CBuild::LoadDataTableByUUID(const std::string & sDataUUID)
	{
		LibMCEnvHandle hDataTableInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadDataTableByUUID(m_pHandle, sDataUUID.c_str(), &hDataTableInstance));
		
		if (!hDataTableInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataTable>(m_pWrapper, hDataTableInstance);
	}
	
	/**
	* CBuild::StoreDataTable - Stores a data table in the build job. MIME Type will be application/amcf-datatable.
	* @param[in] sIdentifier - Unique name of the build attachment. Fails if identifier already exists or is invalid.
	* @param[in] sName - Unique name of the build attachment.
	* @param[in] pDataTableInstance - Data Table instance to store.
	* @param[in] pStoreOptions - Data Table Write Options.
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @return Data UUID of the attachment.
	*/
	std::string CBuild::StoreDataTable(const std::string & sIdentifier, const std::string & sName, classParam<CDataTable> pDataTableInstance, classParam<CDataTableWriteOptions> pStoreOptions, const std::string & sUserUUID)
	{
		LibMCEnvHandle hDataTableInstance = pDataTableInstance.GetHandle();
		LibMCEnvHandle hStoreOptions = pStoreOptions.GetHandle();
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_StoreDataTable(m_pHandle, sIdentifier.c_str(), sName.c_str(), hDataTableInstance, hStoreOptions, sUserUUID.c_str(), 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_StoreDataTable(m_pHandle, sIdentifier.c_str(), sName.c_str(), hDataTableInstance, hStoreOptions, sUserUUID.c_str(), bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuild::LoadPNGImageByIdentifier - Loads a PNG image by identifier which was previously stored in the build job. MIME Type MUST be image/png.
	* @param[in] sIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image data instance.
	*/
	PImageData CBuild::LoadPNGImageByIdentifier(const std::string & sIdentifier, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadPNGImageByIdentifier(m_pHandle, sIdentifier.c_str(), dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CBuild::LoadPNGImageByUUID - Loads a PNG image by uuid which was previously stored in the build job. MIME Type MUST be image/png.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image data instance.
	*/
	PImageData CBuild::LoadPNGImageByUUID(const std::string & sDataUUID, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadPNGImageByUUID(m_pHandle, sDataUUID.c_str(), dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CBuild::StorePNGImage - Stores a PNG Image in the build job. MIME Type will be image/png
	* @param[in] sIdentifier - Unique name of the attachment. Fails if identifier does already exist or is invalid.
	* @param[in] sName - Unique name of the build attachment.
	* @param[in] pImageDataInstance - Image data instance.
	* @param[in] pStoreOptions - PNG Store Options.
	* @param[in] sUserUUID - User UUID of the user that this data comes from. Empty string means no user attached.
	* @return Data UUID of the attachment.
	*/
	std::string CBuild::StorePNGImage(const std::string & sIdentifier, const std::string & sName, classParam<CImageData> pImageDataInstance, classParam<CPNGImageStoreOptions> pStoreOptions, const std::string & sUserUUID)
	{
		LibMCEnvHandle hImageDataInstance = pImageDataInstance.GetHandle();
		LibMCEnvHandle hStoreOptions = pStoreOptions.GetHandle();
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_StorePNGImage(m_pHandle, sIdentifier.c_str(), sName.c_str(), hImageDataInstance, hStoreOptions, sUserUUID.c_str(), 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_StorePNGImage(m_pHandle, sIdentifier.c_str(), sName.c_str(), hImageDataInstance, hStoreOptions, sUserUUID.c_str(), bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	* CBuild::StartExecution - Starts a build execution. This function does not work in a UIEnvironment context!
	* @param[in] sDescription - A human readable description of the build execution for display in the User Interface. Should not be empty.
	* @param[in] sUserUUID - User who started the execution. MUST exist. If empty, no user is attached.
	* @return Build execution instance. Will be newly created and has the status InProcess.
	*/
	PBuildExecution CBuild::StartExecution(const std::string & sDescription, const std::string & sUserUUID)
	{
		LibMCEnvHandle hBuildExecutionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_StartExecution(m_pHandle, sDescription.c_str(), sUserUUID.c_str(), &hBuildExecutionInstance));
		
		if (!hBuildExecutionInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildExecution>(m_pWrapper, hBuildExecutionInstance);
	}
	
	/**
	* CBuild::HasExecution - Checks if a build execution exists for this build.
	* @param[in] sExecutionUUID - The UUID of the exceution.
	* @return Returns true if the execution exists.
	*/
	bool CBuild::HasExecution(const std::string & sExecutionUUID)
	{
		bool resultExecutionExist = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_HasExecution(m_pHandle, sExecutionUUID.c_str(), &resultExecutionExist));
		
		return resultExecutionExist;
	}
	
	/**
	* CBuild::FindExecution - Finds a build execution. Fails if execution does not exist.
	* @param[in] sExecutionUUID - The UUID of the exceution.
	* @return Build execution instance. Will be newly created and has the status InProcess.
	*/
	PBuildExecution CBuild::FindExecution(const std::string & sExecutionUUID)
	{
		LibMCEnvHandle hBuildExecutionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_FindExecution(m_pHandle, sExecutionUUID.c_str(), &hBuildExecutionInstance));
		
		if (!hBuildExecutionInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildExecution>(m_pWrapper, hBuildExecutionInstance);
	}
	
	/**
	* CBuild::ListExecutions - Lists all Executions of the build.
	* @param[in] bOnlyCurrentJournalSession - If true, only the builds that have been created in the current machine session.
	* @return Iterator instance.
	*/
	PBuildExecutionIterator CBuild::ListExecutions(const bool bOnlyCurrentJournalSession)
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_ListExecutions(m_pHandle, bOnlyCurrentJournalSession, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildExecutionIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuild::ListExecutionsByStatus - Lists all Executions of the build by status.
	* @param[in] eExecutionStatus - Status of the build.
	* @param[in] bOnlyCurrentJournalSession - If true, only the builds that have been created in the current machine session.
	* @return Iterator instance.
	*/
	PBuildExecutionIterator CBuild::ListExecutionsByStatus(const eBuildExecutionStatus eExecutionStatus, const bool bOnlyCurrentJournalSession)
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_ListExecutionsByStatus(m_pHandle, eExecutionStatus, bOnlyCurrentJournalSession, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildExecutionIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuild::StoreMetaDataString - Adds a metadata string to a build. Meta data can only be added once. Deletion is not supported by purpose and MUST be avoided by the system design.
	* @param[in] sKey - Unique key of value. MUST NOT be empty. MUST consist of alphanumeric characters or hyphen or underscore. Fails if Key already exists.
	* @param[in] sValue - Value to store.
	*/
	void CBuild::StoreMetaDataString(const std::string & sKey, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Build_StoreMetaDataString(m_pHandle, sKey.c_str(), sValue.c_str()));
	}
	
	/**
	* CBuild::HasMetaDataString - Checks if a metadata string exists.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Returns if metadata string exists.
	*/
	bool CBuild::HasMetaDataString(const std::string & sKey)
	{
		bool resultMetaDataStringExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_HasMetaDataString(m_pHandle, sKey.c_str(), &resultMetaDataStringExists));
		
		return resultMetaDataStringExists;
	}
	
	/**
	* CBuild::GetMetaDataString - Gets a metadata string of a build. Fails if Meta Data does not exist.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Return value.
	*/
	std::string CBuild::GetMetaDataString(const std::string & sKey)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetMetaDataString(m_pHandle, sKey.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetMetaDataString(m_pHandle, sKey.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	 * Method definitions for class CWorkingFileExecution
	 */
	
	/**
	* CWorkingFileExecution::GetStatus - Returns the execution status
	*/
	void CWorkingFileExecution::GetStatus()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFileExecution_GetStatus(m_pHandle));
	}
	
	/**
	* CWorkingFileExecution::ReturnStdOut - Returns the output of the executable as string buffer
	* @return stdout buffer
	*/
	std::string CWorkingFileExecution::ReturnStdOut()
	{
		LibMCEnv_uint32 bytesNeededStringBuffer = 0;
		LibMCEnv_uint32 bytesWrittenStringBuffer = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFileExecution_ReturnStdOut(m_pHandle, 0, &bytesNeededStringBuffer, nullptr));
		std::vector<char> bufferStringBuffer(bytesNeededStringBuffer);
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFileExecution_ReturnStdOut(m_pHandle, bytesNeededStringBuffer, &bytesWrittenStringBuffer, &bufferStringBuffer[0]));
		
		return std::string(&bufferStringBuffer[0]);
	}
	
	/**
	 * Method definitions for class CWorkingFile
	 */
	
	/**
	* CWorkingFile::GetAbsoluteFileName - Retrieves absolute file name of the working file
	* @return global path of the file
	*/
	std::string CWorkingFile::GetAbsoluteFileName()
	{
		LibMCEnv_uint32 bytesNeededFileName = 0;
		LibMCEnv_uint32 bytesWrittenFileName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_GetAbsoluteFileName(m_pHandle, 0, &bytesNeededFileName, nullptr));
		std::vector<char> bufferFileName(bytesNeededFileName);
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_GetAbsoluteFileName(m_pHandle, bytesNeededFileName, &bytesWrittenFileName, &bufferFileName[0]));
		
		return std::string(&bufferFileName[0]);
	}
	
	/**
	* CWorkingFile::GetSize - Returns the size of temporary file.
	* @return file size
	*/
	LibMCEnv_uint64 CWorkingFile::GetSize()
	{
		LibMCEnv_uint64 resultFileSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_GetSize(m_pHandle, &resultFileSize));
		
		return resultFileSize;
	}
	
	/**
	* CWorkingFile::CalculateSHA2 - Calculates the SHA256 checksum of the file.
	* @return sha256 checksum
	*/
	std::string CWorkingFile::CalculateSHA2()
	{
		LibMCEnv_uint32 bytesNeededSHA2 = 0;
		LibMCEnv_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_CalculateSHA2(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_CalculateSHA2(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CWorkingFile::ExecuteFile - Executes the temporary file, if it is an executable.
	* @return execution object
	*/
	PWorkingFileExecution CWorkingFile::ExecuteFile()
	{
		LibMCEnvHandle hExecution = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_ExecuteFile(m_pHandle, &hExecution));
		
		if (!hExecution) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFileExecution>(m_pWrapper, hExecution);
	}
	
	/**
	* CWorkingFile::IsManaged - Returns if the file is managed.
	* @return returns if the file is managed.
	*/
	bool CWorkingFile::IsManaged()
	{
		bool resultFileIsManaged = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_IsManaged(m_pHandle, &resultFileIsManaged));
		
		return resultFileIsManaged;
	}
	
	/**
	* CWorkingFile::MakeManaged - Makes the file managed if it is not managed yet.
	*/
	void CWorkingFile::MakeManaged()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_MakeManaged(m_pHandle));
	}
	
	/**
	* CWorkingFile::FileExists - Returns if the file exists on disk.
	* @return returns if the file exists.
	*/
	bool CWorkingFile::FileExists()
	{
		bool resultFileDoesExist = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_FileExists(m_pHandle, &resultFileDoesExist));
		
		return resultFileDoesExist;
	}
	
	/**
	* CWorkingFile::DeleteFromDisk - Deletes the temporary file.
	* @return returns if deletion was successful or file did not exist in the first place.
	*/
	bool CWorkingFile::DeleteFromDisk()
	{
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_DeleteFromDisk(m_pHandle, &resultSuccess));
		
		return resultSuccess;
	}
	
	/**
	 * Method definitions for class CWorkingFileIterator
	 */
	
	/**
	* CWorkingFileIterator::GetCurrentFile - Returns the working file the iterator points at.
	* @return returns the WorkingFile instance.
	*/
	PWorkingFile CWorkingFileIterator::GetCurrentFile()
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFileIterator_GetCurrentFile(m_pHandle, &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	 * Method definitions for class CWorkingDirectory
	 */
	
	/**
	* CWorkingDirectory::IsActive - Working directory is active.
	* @return returns true if files can be read and written to the directory.
	*/
	bool CWorkingDirectory::IsActive()
	{
		bool resultIsActive = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_IsActive(m_pHandle, &resultIsActive));
		
		return resultIsActive;
	}
	
	/**
	* CWorkingDirectory::GetAbsoluteFilePath - Retrieves absolute file path.
	* @return global path of the directory, including path delimiter.
	*/
	std::string CWorkingDirectory::GetAbsoluteFilePath()
	{
		LibMCEnv_uint32 bytesNeededFilePath = 0;
		LibMCEnv_uint32 bytesWrittenFilePath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_GetAbsoluteFilePath(m_pHandle, 0, &bytesNeededFilePath, nullptr));
		std::vector<char> bufferFilePath(bytesNeededFilePath);
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_GetAbsoluteFilePath(m_pHandle, bytesNeededFilePath, &bytesWrittenFilePath, &bufferFilePath[0]));
		
		return std::string(&bufferFilePath[0]);
	}
	
	/**
	* CWorkingDirectory::StoreCustomData - Stores a data buffer in a temporary file with a given name.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] DataBufferBuffer - file data to store to.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::StoreCustomData(const std::string & sFileName, const CInputVector<LibMCEnv_uint8> & DataBufferBuffer)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_StoreCustomData(m_pHandle, sFileName.c_str(), (LibMCEnv_uint64)DataBufferBuffer.size(), DataBufferBuffer.data(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::StoreCustomString - Stores a string in a temporary file with a given name.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] sDataString - file data to store to.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::StoreCustomString(const std::string & sFileName, const std::string & sDataString)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_StoreCustomString(m_pHandle, sFileName.c_str(), sDataString.c_str(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::StoreDriverData - Stores attached driver data in a temporary file.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::StoreDriverData(const std::string & sFileName, const std::string & sIdentifier)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_StoreDriverData(m_pHandle, sFileName.c_str(), sIdentifier.c_str(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::StoreCustomDataInTempFile - Stores a data buffer in a temporary file with a generated name.
	* @param[in] sExtension - extension of the file to store. MAY be an empty string. MUST only include up to 64 alphanumeric characters.
	* @param[in] DataBufferBuffer - file data to store to.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::StoreCustomDataInTempFile(const std::string & sExtension, const CInputVector<LibMCEnv_uint8> & DataBufferBuffer)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_StoreCustomDataInTempFile(m_pHandle, sExtension.c_str(), (LibMCEnv_uint64)DataBufferBuffer.size(), DataBufferBuffer.data(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::StoreCustomStringInTempFile - Stores a string in a temporary file.
	* @param[in] sExtension - extension of the file to store. MAY be an empty string. MUST only include up to 64 alphanumeric characters.
	* @param[in] sDataString - file data to store to.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::StoreCustomStringInTempFile(const std::string & sExtension, const std::string & sDataString)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_StoreCustomStringInTempFile(m_pHandle, sExtension.c_str(), sDataString.c_str(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::StoreDriverDataInTempFile - Stores attached driver data in a temporary file.
	* @param[in] sExtension - extension of the file to store. MAY be an empty string. MUST only include up to 64 alphanumeric characters.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::StoreDriverDataInTempFile(const std::string & sExtension, const std::string & sIdentifier)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_StoreDriverDataInTempFile(m_pHandle, sExtension.c_str(), sIdentifier.c_str(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::CleanUp - Deletes all managed files in the directory and the directory. No storing is possible after a cleanup.
	* @return returns if deletion was successful.
	*/
	bool CWorkingDirectory::CleanUp()
	{
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_CleanUp(m_pHandle, &resultSuccess));
		
		return resultSuccess;
	}
	
	/**
	* CWorkingDirectory::AddManagedFile - Adds a managed filename in the directory (i.e. this file will be deleted at CleanUp). Subdirectories are not allowed.
	* @param[in] sFileName - Filename to manage. The file does not need to exist yet.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::AddManagedFile(const std::string & sFileName)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_AddManagedFile(m_pHandle, sFileName.c_str(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::HasUnmanagedFiles - Returns if the working directory has unmanaged files. A clean implementation will never deal with unmanaged files.
	* @return returns if there are unmanaged files.
	*/
	bool CWorkingDirectory::HasUnmanagedFiles()
	{
		bool resultHasUnmanagedFiles = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_HasUnmanagedFiles(m_pHandle, &resultHasUnmanagedFiles));
		
		return resultHasUnmanagedFiles;
	}
	
	/**
	* CWorkingDirectory::RetrieveUnmanagedFiles - Returns a list of unmanaged files.
	* @return working file iterator instance.
	*/
	PWorkingFileIterator CWorkingDirectory::RetrieveUnmanagedFiles()
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_RetrieveUnmanagedFiles(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFileIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CWorkingDirectory::RetrieveManagedFiles - Returns a list of managed files.
	* @return working file iterator instance.
	*/
	PWorkingFileIterator CWorkingDirectory::RetrieveManagedFiles()
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_RetrieveManagedFiles(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFileIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CWorkingDirectory::RetrieveAllFiles - Returns a list of all files in the directory.
	* @return working file iterator instance.
	*/
	PWorkingFileIterator CWorkingDirectory::RetrieveAllFiles()
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_RetrieveAllFiles(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFileIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	 * Method definitions for class CXMLDocumentAttribute
	 */
	
	/**
	* CXMLDocumentAttribute::GetNameSpace - Retrieves namespace of the attribute.
	* @return returns the namespace of the attribute.
	*/
	std::string CXMLDocumentAttribute::GetNameSpace()
	{
		LibMCEnv_uint32 bytesNeededNameSpace = 0;
		LibMCEnv_uint32 bytesWrittenNameSpace = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetNameSpace(m_pHandle, 0, &bytesNeededNameSpace, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetNameSpace(m_pHandle, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0]));
		
		return std::string(&bufferNameSpace[0]);
	}
	
	/**
	* CXMLDocumentAttribute::GetName - Retrieves name of the attribute.
	* @return returns the name of the attribute.
	*/
	std::string CXMLDocumentAttribute::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CXMLDocumentAttribute::GetValue - Retrieves value of the attribute as string.
	* @return returns the value of the attribute.
	*/
	std::string CXMLDocumentAttribute::GetValue()
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetValue(m_pHandle, 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetValue(m_pHandle, bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CXMLDocumentAttribute::IsValidUUID - Checks if the value is a valid UUID string.
	* @return returns if the value is a valid UUID string.
	*/
	bool CXMLDocumentAttribute::IsValidUUID()
	{
		bool resultIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_IsValidUUID(m_pHandle, &resultIsValid));
		
		return resultIsValid;
	}
	
	/**
	* CXMLDocumentAttribute::GetUUIDValue - Retrieves value of the attribute as UUID string. Fails if value is not a UUID string.
	* @return returns the value of the attribute as normalized UUID string.
	*/
	std::string CXMLDocumentAttribute::GetUUIDValue()
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetUUIDValue(m_pHandle, 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetUUIDValue(m_pHandle, bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CXMLDocumentAttribute::IsValidInteger - Checks if the value is a valid integer in the given range.
	* @param[in] nMinValue - Minimum allowed value
	* @param[in] nMaxValue - Maximum allowed value
	* @return returns if the value is a valid integer.
	*/
	bool CXMLDocumentAttribute::IsValidInteger(const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue)
	{
		bool resultIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_IsValidInteger(m_pHandle, nMinValue, nMaxValue, &resultIsValid));
		
		return resultIsValid;
	}
	
	/**
	* CXMLDocumentAttribute::GetIntegerValue - Returns the value as integer. Fails if the value is not a valid integer in the given range.
	* @param[in] nMinValue - Minimum allowed value
	* @param[in] nMaxValue - Maximum allowed value
	* @return returns the value.
	*/
	LibMCEnv_int64 CXMLDocumentAttribute::GetIntegerValue(const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetIntegerValue(m_pHandle, nMinValue, nMaxValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CXMLDocumentAttribute::IsValidDouble - Checks if the value is a valid double in the given range.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return returns if the value is a valid double.
	*/
	bool CXMLDocumentAttribute::IsValidDouble(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue)
	{
		bool resultIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_IsValidDouble(m_pHandle, dMinValue, dMaxValue, &resultIsValid));
		
		return resultIsValid;
	}
	
	/**
	* CXMLDocumentAttribute::GetDoubleValue - Returns the value as double. Fails if the value is not a valid double in the given range.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return returns the value .
	*/
	LibMCEnv_double CXMLDocumentAttribute::GetDoubleValue(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetDoubleValue(m_pHandle, dMinValue, dMaxValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CXMLDocumentAttribute::IsValidBool - Checks if the value is a valid boolean value, meaning an integer or true or false as string. The value will be trimmed and any character will be converted to lowercase.
	* @return returns if the value is a valid bool.
	*/
	bool CXMLDocumentAttribute::IsValidBool()
	{
		bool resultIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_IsValidBool(m_pHandle, &resultIsValid));
		
		return resultIsValid;
	}
	
	/**
	* CXMLDocumentAttribute::GetBoolValue - Returns the value as bool. Fails if the value is not a valid boolean value, meaning an integer or true or false as string. The value will be trimmed and any character will be converted to lowercase.
	* @return returns the value .
	*/
	bool CXMLDocumentAttribute::GetBoolValue()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_GetBoolValue(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CXMLDocumentAttribute::SetValue - Sets the value of the attribute as string.
	* @param[in] sValue - new value of the attribute.
	*/
	void CXMLDocumentAttribute::SetValue(const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_SetValue(m_pHandle, sValue.c_str()));
	}
	
	/**
	* CXMLDocumentAttribute::SetUUIDValue - Sets the value of the attribute as UUID string.
	* @param[in] sValue - new value of the attribute. Fails if Value is not a UUID.
	*/
	void CXMLDocumentAttribute::SetUUIDValue(const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_SetUUIDValue(m_pHandle, sValue.c_str()));
	}
	
	/**
	* CXMLDocumentAttribute::SetIntegerValue - Sets the value of the attribute as integer.
	* @param[in] nValue - new value of the attribute.
	*/
	void CXMLDocumentAttribute::SetIntegerValue(const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_SetIntegerValue(m_pHandle, nValue));
	}
	
	/**
	* CXMLDocumentAttribute::SetDoubleValue - Sets the value of the attribute as double.
	* @param[in] dValue - new value of the attribute.
	*/
	void CXMLDocumentAttribute::SetDoubleValue(const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_SetDoubleValue(m_pHandle, dValue));
	}
	
	/**
	* CXMLDocumentAttribute::SetBoolValue - Sets the value of the attribute as bool.
	* @param[in] bValue - new value of the attribute.
	*/
	void CXMLDocumentAttribute::SetBoolValue(const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_SetBoolValue(m_pHandle, bValue));
	}
	
	/**
	* CXMLDocumentAttribute::Remove - Removes the attribute from its parent node. All subsequent calls to the class will fail.
	*/
	void CXMLDocumentAttribute::Remove()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentAttribute_Remove(m_pHandle));
	}
	
	/**
	 * Method definitions for class CXMLDocumentNode
	 */
	
	/**
	* CXMLDocumentNode::GetName - Retrieves name of the node.
	* @return returns the name of the node.
	*/
	std::string CXMLDocumentNode::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CXMLDocumentNode::GetNameSpace - Retrieves namespace of the node.
	* @return returns the namespace of the node.
	*/
	std::string CXMLDocumentNode::GetNameSpace()
	{
		LibMCEnv_uint32 bytesNeededNameSpace = 0;
		LibMCEnv_uint32 bytesWrittenNameSpace = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetNameSpace(m_pHandle, 0, &bytesNeededNameSpace, nullptr));
		std::vector<char> bufferNameSpace(bytesNeededNameSpace);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetNameSpace(m_pHandle, bytesNeededNameSpace, &bytesWrittenNameSpace, &bufferNameSpace[0]));
		
		return std::string(&bufferNameSpace[0]);
	}
	
	/**
	* CXMLDocumentNode::GetTextContent - Retrieves the text content of the node. A node with text content MUST NOT have children.
	* @return returns the text content of the node.
	*/
	std::string CXMLDocumentNode::GetTextContent()
	{
		LibMCEnv_uint32 bytesNeededTextContent = 0;
		LibMCEnv_uint32 bytesWrittenTextContent = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetTextContent(m_pHandle, 0, &bytesNeededTextContent, nullptr));
		std::vector<char> bufferTextContent(bytesNeededTextContent);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetTextContent(m_pHandle, bytesNeededTextContent, &bytesWrittenTextContent, &bufferTextContent[0]));
		
		return std::string(&bufferTextContent[0]);
	}
	
	/**
	* CXMLDocumentNode::SetTextContent - Sets the text content of the node. Call will fail if node has children.
	* @param[in] sTextContent - the new text content of the node.
	*/
	void CXMLDocumentNode::SetTextContent(const std::string & sTextContent)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_SetTextContent(m_pHandle, sTextContent.c_str()));
	}
	
	/**
	* CXMLDocumentNode::GetAttributeCount - Returns number of attributes.
	* @return returns the number of attributes.
	*/
	LibMCEnv_uint64 CXMLDocumentNode::GetAttributeCount()
	{
		LibMCEnv_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CXMLDocumentNode::GetAttribute - Returns attribute instance. Fails if Index is out of range.
	* @param[in] nIndex - Index of the attribute to return (0-based).
	* @return XML Document attribute.
	*/
	PXMLDocumentAttribute CXMLDocumentNode::GetAttribute(const LibMCEnv_uint64 nIndex)
	{
		LibMCEnvHandle hAttributeInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttribute(m_pHandle, nIndex, &hAttributeInstance));
		
		if (!hAttributeInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentAttribute>(m_pWrapper, hAttributeInstance);
	}
	
	/**
	* CXMLDocumentNode::HasAttribute - Returns if attribute of a specific name exists.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Returns if the attribute exists.
	*/
	bool CXMLDocumentNode::HasAttribute(const std::string & sNameSpace, const std::string & sName)
	{
		bool resultAttributeExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_HasAttribute(m_pHandle, sNameSpace.c_str(), sName.c_str(), &resultAttributeExists));
		
		return resultAttributeExists;
	}
	
	/**
	* CXMLDocumentNode::FindAttribute - Returns attribute instance of a specific name. 
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] bMustExist - If true, the call fails if attribute does not exist. If falls, the call will return null if the attribute does not exist.
	* @return XML Document attribute.
	*/
	PXMLDocumentAttribute CXMLDocumentNode::FindAttribute(const std::string & sNameSpace, const std::string & sName, const bool bMustExist)
	{
		LibMCEnvHandle hAttributeInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_FindAttribute(m_pHandle, sNameSpace.c_str(), sName.c_str(), bMustExist, &hAttributeInstance));
		
		if (hAttributeInstance) {
			return std::make_shared<CXMLDocumentAttribute>(m_pWrapper, hAttributeInstance);
		} else {
			return nullptr;
		}
	}
	
	/**
	* CXMLDocumentNode::GetAttributeValue - Returns string value of an attribute. Fails if attribute does not exist.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Attribute value.
	*/
	std::string CXMLDocumentNode::GetAttributeValue(const std::string & sNameSpace, const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeValue(m_pHandle, sNameSpace.c_str(), sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeValue(m_pHandle, sNameSpace.c_str(), sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CXMLDocumentNode::GetAttributeIntegerValue - Returns integer value of an attribute. Fails if attribute does not exist or attribute is not an integer .
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] nMinValue - Minimum allowed value.
	* @param[in] nMaxValue - Maximum allowed value.
	* @return Attribute value.
	*/
	LibMCEnv_int64 CXMLDocumentNode::GetAttributeIntegerValue(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeIntegerValue(m_pHandle, sNameSpace.c_str(), sName.c_str(), nMinValue, nMaxValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CXMLDocumentNode::GetAttributeDoubleValue - Returns double value of an attribute. Fails if attribute does not exist or attribute is not a double value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return Attribute value.
	*/
	LibMCEnv_double CXMLDocumentNode::GetAttributeDoubleValue(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeDoubleValue(m_pHandle, sNameSpace.c_str(), sName.c_str(), dMinValue, dMaxValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CXMLDocumentNode::GetAttributeBoolValue - Returns bool value of an attribute. Fails if attribute does not exist or attribute is not a boolean value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Attribute value.
	*/
	bool CXMLDocumentNode::GetAttributeBoolValue(const std::string & sNameSpace, const std::string & sName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeBoolValue(m_pHandle, sNameSpace.c_str(), sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CXMLDocumentNode::GetAttributeUUIDValue - Returns UUID value of an attribute. Fails if attribute does not exist or attribute value is not a UUID.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Attribute value.
	*/
	std::string CXMLDocumentNode::GetAttributeUUIDValue(const std::string & sNameSpace, const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeUUIDValue(m_pHandle, sNameSpace.c_str(), sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeUUIDValue(m_pHandle, sNameSpace.c_str(), sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CXMLDocumentNode::GetAttributeValueDef - Returns string value of an attribute. Returns default value if attribute does not exist.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] sDefaultValue - Default value.
	* @return Attribute value.
	*/
	std::string CXMLDocumentNode::GetAttributeValueDef(const std::string & sNameSpace, const std::string & sName, const std::string & sDefaultValue)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeValueDef(m_pHandle, sNameSpace.c_str(), sName.c_str(), sDefaultValue.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeValueDef(m_pHandle, sNameSpace.c_str(), sName.c_str(), sDefaultValue.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CXMLDocumentNode::GetAttributeIntegerValueDef - Returns integer value of an attribute. Returns default value if attribute does not exist or attribute is not an integer .
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] nMinValue - Minimum allowed value.
	* @param[in] nMaxValue - Maximum allowed value.
	* @param[in] nDefaultValue - Default value. MUST be in valid range.
	* @return Attribute value.
	*/
	LibMCEnv_int64 CXMLDocumentNode::GetAttributeIntegerValueDef(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue, const LibMCEnv_int64 nDefaultValue)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeIntegerValueDef(m_pHandle, sNameSpace.c_str(), sName.c_str(), nMinValue, nMaxValue, nDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CXMLDocumentNode::GetAttributeDoubleValueDef - Returns double value of an attribute. Returns default value if attribute does not exist or attribute is not a double value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @param[in] dDefaultValue - Default value. MUST be in valid range.
	* @return Attribute value.
	*/
	LibMCEnv_double CXMLDocumentNode::GetAttributeDoubleValueDef(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue, const LibMCEnv_double dDefaultValue)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeDoubleValueDef(m_pHandle, sNameSpace.c_str(), sName.c_str(), dMinValue, dMaxValue, dDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CXMLDocumentNode::GetAttributeBoolValueDef - Returns bool value of an attribute. Returns default value if attribute does not exist or attribute is not a boolean value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] bDefaultValue - Default value.
	* @return Attribute value.
	*/
	bool CXMLDocumentNode::GetAttributeBoolValueDef(const std::string & sNameSpace, const std::string & sName, const bool bDefaultValue)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeBoolValueDef(m_pHandle, sNameSpace.c_str(), sName.c_str(), bDefaultValue, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CXMLDocumentNode::GetAttributeUUIDValueDef - Returns UUID value of an attribute. Returns default value if attribute does not exist or attribute value is not a UUID.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] sDefaultValue - Attribute value. MUST be a valid UUID
	* @return Attribute value.
	*/
	std::string CXMLDocumentNode::GetAttributeUUIDValueDef(const std::string & sNameSpace, const std::string & sName, const std::string & sDefaultValue)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeUUIDValueDef(m_pHandle, sNameSpace.c_str(), sName.c_str(), sDefaultValue.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetAttributeUUIDValueDef(m_pHandle, sNameSpace.c_str(), sName.c_str(), sDefaultValue.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CXMLDocumentNode::RemoveAttribute - Removes the attribute with a specific name. Does nothing if attribute does not exist.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	*/
	void CXMLDocumentNode::RemoveAttribute(const std::string & sNameSpace, const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_RemoveAttribute(m_pHandle, sNameSpace.c_str(), sName.c_str()));
	}
	
	/**
	* CXMLDocumentNode::RemoveAttributeByIndex - Removes the attribute with a specific index. Does nothing if attribute does not exist.
	* @param[in] nIndex - Index of the attribute to remove (0-based).
	*/
	void CXMLDocumentNode::RemoveAttributeByIndex(const LibMCEnv_uint64 nIndex)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_RemoveAttributeByIndex(m_pHandle, nIndex));
	}
	
	/**
	* CXMLDocumentNode::AddAttribute - Adds an attribute with a specific name and string value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the attribute. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] sValue - Value of the attribute.
	*/
	void CXMLDocumentNode::AddAttribute(const std::string & sNameSpace, const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_AddAttribute(m_pHandle, sNameSpace.c_str(), sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CXMLDocumentNode::AddIntegerAttribute - Adds an attribute with a specific name and integer value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the attribute. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] nValue - Value of the attribute.
	*/
	void CXMLDocumentNode::AddIntegerAttribute(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_AddIntegerAttribute(m_pHandle, sNameSpace.c_str(), sName.c_str(), nValue));
	}
	
	/**
	* CXMLDocumentNode::AddDoubleAttribute - Adds an attribute with a specific name and double value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] dValue - Value of the attribute.
	*/
	void CXMLDocumentNode::AddDoubleAttribute(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_AddDoubleAttribute(m_pHandle, sNameSpace.c_str(), sName.c_str(), dValue));
	}
	
	/**
	* CXMLDocumentNode::AddBoolAttribute - Adds an attribute with a specific name and bool value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] bValue - Value of the attribute.
	*/
	void CXMLDocumentNode::AddBoolAttribute(const std::string & sNameSpace, const std::string & sName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_AddBoolAttribute(m_pHandle, sNameSpace.c_str(), sName.c_str(), bValue));
	}
	
	/**
	* CXMLDocumentNode::GetChildren - Returns all the child nodes of the XML Node.
	* @return returns the list of child nodes.
	*/
	PXMLDocumentNodes CXMLDocumentNode::GetChildren()
	{
		LibMCEnvHandle hChildNodes = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetChildren(m_pHandle, &hChildNodes));
		
		if (!hChildNodes) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNodes>(m_pWrapper, hChildNodes);
	}
	
	/**
	* CXMLDocumentNode::CountChildrenByName - Returns how many children of the XML Node have a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns the number children with the specified name.
	*/
	LibMCEnv_uint64 CXMLDocumentNode::CountChildrenByName(const std::string & sNameSpace, const std::string & sName)
	{
		LibMCEnv_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_CountChildrenByName(m_pHandle, sNameSpace.c_str(), sName.c_str(), &resultCount));
		
		return resultCount;
	}
	
	/**
	* CXMLDocumentNode::GetChildrenByName - Returns all the child nodes of the XML Node with a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns the list of child nodes.
	*/
	PXMLDocumentNodes CXMLDocumentNode::GetChildrenByName(const std::string & sNameSpace, const std::string & sName)
	{
		LibMCEnvHandle hChildNodes = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_GetChildrenByName(m_pHandle, sNameSpace.c_str(), sName.c_str(), &hChildNodes));
		
		if (!hChildNodes) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNodes>(m_pWrapper, hChildNodes);
	}
	
	/**
	* CXMLDocumentNode::HasChild - Returns if a child with a specific name exist.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns if a child with a specific name exists.
	*/
	bool CXMLDocumentNode::HasChild(const std::string & sNameSpace, const std::string & sName)
	{
		bool resultChildExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_HasChild(m_pHandle, sNameSpace.c_str(), sName.c_str(), &resultChildExists));
		
		return resultChildExists;
	}
	
	/**
	* CXMLDocumentNode::HasUniqueChild - Returns if a child with a specific name exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns if a child with a specific name exists once and only once.
	*/
	bool CXMLDocumentNode::HasUniqueChild(const std::string & sNameSpace, const std::string & sName)
	{
		bool resultChildExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_HasUniqueChild(m_pHandle, sNameSpace.c_str(), sName.c_str(), &resultChildExists));
		
		return resultChildExists;
	}
	
	/**
	* CXMLDocumentNode::FindChild - Returns child with a specific name. Throws an error if name does not exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @param[in] bMustExist - If true, the call fails if child does not exist. If falls, the call will return null if the child does not exist.
	* @return returns child instance or null.
	*/
	PXMLDocumentNode CXMLDocumentNode::FindChild(const std::string & sNameSpace, const std::string & sName, const bool bMustExist)
	{
		LibMCEnvHandle hChildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_FindChild(m_pHandle, sNameSpace.c_str(), sName.c_str(), bMustExist, &hChildInstance));
		
		if (hChildInstance) {
			return std::make_shared<CXMLDocumentNode>(m_pWrapper, hChildInstance);
		} else {
			return nullptr;
		}
	}
	
	/**
	* CXMLDocumentNode::AddChild - Adds a new child with a specific name. Fails if node has a non-empty text content.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns child instance.
	*/
	PXMLDocumentNode CXMLDocumentNode::AddChild(const std::string & sNameSpace, const std::string & sName)
	{
		LibMCEnvHandle hChildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_AddChild(m_pHandle, sNameSpace.c_str(), sName.c_str(), &hChildInstance));
		
		if (!hChildInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNode>(m_pWrapper, hChildInstance);
	}
	
	/**
	* CXMLDocumentNode::AddChildText - Adds a new child with text content and a specific name. Fails if node has a non-empty text content.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @param[in] sTextContent - Text content of the child.
	* @return returns child instance.
	*/
	PXMLDocumentNode CXMLDocumentNode::AddChildText(const std::string & sNameSpace, const std::string & sName, const std::string & sTextContent)
	{
		LibMCEnvHandle hChildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_AddChildText(m_pHandle, sNameSpace.c_str(), sName.c_str(), sTextContent.c_str(), &hChildInstance));
		
		if (!hChildInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNode>(m_pWrapper, hChildInstance);
	}
	
	/**
	* CXMLDocumentNode::RemoveChild - Removes a child with a specific name. All subsequent calls to the child will fail after the call.
	* @param[in] pChildInstance - child instance to remove. Fails if given instance is not a child of the node.
	*/
	void CXMLDocumentNode::RemoveChild(classParam<CXMLDocumentNode> pChildInstance)
	{
		LibMCEnvHandle hChildInstance = pChildInstance.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_RemoveChild(m_pHandle, hChildInstance));
	}
	
	/**
	* CXMLDocumentNode::RemoveChildrenWithName - Removes all children with a specific name. Does nothing if no child with the name exists. . All subsequent calls to the deleted children will fail after the call.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the children.
	*/
	void CXMLDocumentNode::RemoveChildrenWithName(const std::string & sNameSpace, const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_RemoveChildrenWithName(m_pHandle, sNameSpace.c_str(), sName.c_str()));
	}
	
	/**
	* CXMLDocumentNode::Remove - Removes the node from its parent. The root node of the document can not be removed.
	*/
	void CXMLDocumentNode::Remove()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNode_Remove(m_pHandle));
	}
	
	/**
	 * Method definitions for class CXMLDocumentNodes
	 */
	
	/**
	* CXMLDocumentNodes::GetNodeCount - Returns number of nodes.
	* @return returns the number of nodes in the list.
	*/
	LibMCEnv_uint64 CXMLDocumentNodes::GetNodeCount()
	{
		LibMCEnv_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNodes_GetNodeCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CXMLDocumentNodes::GetNode - Returns node instance. Fails if Index is out of range.
	* @param[in] nIndex - Index of the node to return (0-based).
	* @return XML Node node.
	*/
	PXMLDocumentNode CXMLDocumentNodes::GetNode(const LibMCEnv_uint64 nIndex)
	{
		LibMCEnvHandle hNodeInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNodes_GetNode(m_pHandle, nIndex, &hNodeInstance));
		
		if (!hNodeInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNode>(m_pWrapper, hNodeInstance);
	}
	
	/**
	* CXMLDocumentNodes::CountNodesByName - Returns how many nodes of the XML Node have a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns the number of nodes with the specified name.
	*/
	LibMCEnv_uint64 CXMLDocumentNodes::CountNodesByName(const std::string & sNameSpace, const std::string & sName)
	{
		LibMCEnv_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNodes_CountNodesByName(m_pHandle, sNameSpace.c_str(), sName.c_str(), &resultCount));
		
		return resultCount;
	}
	
	/**
	* CXMLDocumentNodes::GetNodesByName - Returns all the nodes nodes of the XML Node with a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns the list of node nodes.
	*/
	PXMLDocumentNodes CXMLDocumentNodes::GetNodesByName(const std::string & sNameSpace, const std::string & sName)
	{
		LibMCEnvHandle hNodes = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNodes_GetNodesByName(m_pHandle, sNameSpace.c_str(), sName.c_str(), &hNodes));
		
		if (!hNodes) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNodes>(m_pWrapper, hNodes);
	}
	
	/**
	* CXMLDocumentNodes::HasNode - Returns if a node with a specific name exist.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns if a node with a specific name exists.
	*/
	bool CXMLDocumentNodes::HasNode(const std::string & sNameSpace, const std::string & sName)
	{
		bool resultNodeExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNodes_HasNode(m_pHandle, sNameSpace.c_str(), sName.c_str(), &resultNodeExists));
		
		return resultNodeExists;
	}
	
	/**
	* CXMLDocumentNodes::HasUniqueNode - Returns if a node with a specific name exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns if a node with a specific name exists once and only once.
	*/
	bool CXMLDocumentNodes::HasUniqueNode(const std::string & sNameSpace, const std::string & sName)
	{
		bool resultNodeExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNodes_HasUniqueNode(m_pHandle, sNameSpace.c_str(), sName.c_str(), &resultNodeExists));
		
		return resultNodeExists;
	}
	
	/**
	* CXMLDocumentNodes::FindNode - Returns node with a specific name. Throws an error if name does not exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @param[in] bMustExist - If true, the call fails if node does not exist. If falls, the call will return null if the node does not exist.
	* @return returns node instance.
	*/
	PXMLDocumentNode CXMLDocumentNodes::FindNode(const std::string & sNameSpace, const std::string & sName, const bool bMustExist)
	{
		LibMCEnvHandle hNodeInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocumentNodes_FindNode(m_pHandle, sNameSpace.c_str(), sName.c_str(), bMustExist, &hNodeInstance));
		
		if (hNodeInstance) {
			return std::make_shared<CXMLDocumentNode>(m_pWrapper, hNodeInstance);
		} else {
			return nullptr;
		}
	}
	
	/**
	 * Method definitions for class CXMLDocument
	 */
	
	/**
	* CXMLDocument::GetDefaultNamespace - Returns default name space of the document.
	* @return name space of the document.
	*/
	std::string CXMLDocument::GetDefaultNamespace()
	{
		LibMCEnv_uint32 bytesNeededNamespace = 0;
		LibMCEnv_uint32 bytesWrittenNamespace = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_GetDefaultNamespace(m_pHandle, 0, &bytesNeededNamespace, nullptr));
		std::vector<char> bufferNamespace(bytesNeededNamespace);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_GetDefaultNamespace(m_pHandle, bytesNeededNamespace, &bytesWrittenNamespace, &bufferNamespace[0]));
		
		return std::string(&bufferNamespace[0]);
	}
	
	/**
	* CXMLDocument::GetNamespaceCount - Returns the used number of name spaces of the document.
	* @return number of registered name spaces of the document.
	*/
	LibMCEnv_uint64 CXMLDocument::GetNamespaceCount()
	{
		LibMCEnv_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_GetNamespaceCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CXMLDocument::GetNamespace - Returns a name space of the document. Will fail if index is invalid.
	* @param[in] nIndex - index of name space. 0-based.
	* @param[out] sNamespace - name space of the document.
	* @param[out] sNamespacePrefix - name space prefix of the document. Empty for root namespace.
	*/
	void CXMLDocument::GetNamespace(const LibMCEnv_uint64 nIndex, std::string & sNamespace, std::string & sNamespacePrefix)
	{
		LibMCEnv_uint32 bytesNeededNamespace = 0;
		LibMCEnv_uint32 bytesWrittenNamespace = 0;
		LibMCEnv_uint32 bytesNeededNamespacePrefix = 0;
		LibMCEnv_uint32 bytesWrittenNamespacePrefix = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_GetNamespace(m_pHandle, nIndex, 0, &bytesNeededNamespace, nullptr, 0, &bytesNeededNamespacePrefix, nullptr));
		std::vector<char> bufferNamespace(bytesNeededNamespace);
		std::vector<char> bufferNamespacePrefix(bytesNeededNamespacePrefix);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_GetNamespace(m_pHandle, nIndex, bytesNeededNamespace, &bytesWrittenNamespace, &bufferNamespace[0], bytesNeededNamespacePrefix, &bytesWrittenNamespacePrefix, &bufferNamespacePrefix[0]));
		sNamespace = std::string(&bufferNamespace[0]);
		sNamespacePrefix = std::string(&bufferNamespacePrefix[0]);
	}
	
	/**
	* CXMLDocument::HasNamespace - Returns if the document has a namespace.
	* @param[in] sNamespace - Name space name.
	* @return name space has been registered.
	*/
	bool CXMLDocument::HasNamespace(const std::string & sNamespace)
	{
		bool resultNameSpaceIsRegistered = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_HasNamespace(m_pHandle, sNamespace.c_str(), &resultNameSpaceIsRegistered));
		
		return resultNameSpaceIsRegistered;
	}
	
	/**
	* CXMLDocument::GetNamespacePrefix - Returns a name space of the document. Will fail if namespace is not registered.
	* @param[in] sNamespace - name space of the document.
	* @return name space prefix of the document. Empty for root namespace.
	*/
	std::string CXMLDocument::GetNamespacePrefix(const std::string & sNamespace)
	{
		LibMCEnv_uint32 bytesNeededNamespacePrefix = 0;
		LibMCEnv_uint32 bytesWrittenNamespacePrefix = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_GetNamespacePrefix(m_pHandle, sNamespace.c_str(), 0, &bytesNeededNamespacePrefix, nullptr));
		std::vector<char> bufferNamespacePrefix(bytesNeededNamespacePrefix);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_GetNamespacePrefix(m_pHandle, sNamespace.c_str(), bytesNeededNamespacePrefix, &bytesWrittenNamespacePrefix, &bufferNamespacePrefix[0]));
		
		return std::string(&bufferNamespacePrefix[0]);
	}
	
	/**
	* CXMLDocument::RegisterNamespace - Registers a custom namespace prefix. Given Namespace MUST NOT have been in use before calling this function.
	* @param[in] sNamespace - name space to register
	* @param[in] sNamespacePrefix - name space prefix to use for the namespace. MUST NOT be in use, MUST NOT be an empty string or contain non-alphanumeric characters.
	*/
	void CXMLDocument::RegisterNamespace(const std::string & sNamespace, const std::string & sNamespacePrefix)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_RegisterNamespace(m_pHandle, sNamespace.c_str(), sNamespacePrefix.c_str()));
	}
	
	/**
	* CXMLDocument::ChangeNamespacePrefix - Changes the prefix of an existing Namespace. New Namespace MUST NOT have been in use before calling this function.
	* @param[in] sOldNamespacePrefix - name space prefix that is currently in use.
	* @param[in] sNewNamespacePrefix - name space prefix to use for the namespace. MUST NOT be in use, MUST NOT be an empty string or contain non-alphanumeric characters.
	*/
	void CXMLDocument::ChangeNamespacePrefix(const std::string & sOldNamespacePrefix, const std::string & sNewNamespacePrefix)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_ChangeNamespacePrefix(m_pHandle, sOldNamespacePrefix.c_str(), sNewNamespacePrefix.c_str()));
	}
	
	/**
	* CXMLDocument::GetRootNode - Returns root node of the document.
	* @return Root node of the document.
	*/
	PXMLDocumentNode CXMLDocument::GetRootNode()
	{
		LibMCEnvHandle hRootNode = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_GetRootNode(m_pHandle, &hRootNode));
		
		if (!hRootNode) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocumentNode>(m_pWrapper, hRootNode);
	}
	
	/**
	* CXMLDocument::SaveToString - Saves the XML document into a string.
	* @param[in] bAddLineBreaks - If true, line breaks and indentation will be added to the output string.
	* @return String with the XML Content.
	*/
	std::string CXMLDocument::SaveToString(const bool bAddLineBreaks)
	{
		LibMCEnv_uint32 bytesNeededXMLString = 0;
		LibMCEnv_uint32 bytesWrittenXMLString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_SaveToString(m_pHandle, bAddLineBreaks, 0, &bytesNeededXMLString, nullptr));
		std::vector<char> bufferXMLString(bytesNeededXMLString);
		CheckError(m_pWrapper->m_WrapperTable.m_XMLDocument_SaveToString(m_pHandle, bAddLineBreaks, bytesNeededXMLString, &bytesWrittenXMLString, &bufferXMLString[0]));
		
		return std::string(&bufferXMLString[0]);
	}
	
	/**
	 * Method definitions for class CTCPIPPacket
	 */
	
	/**
	* CTCPIPPacket::IsEmpty - Returns if packet is empty.
	* @return Flag if packet is empty.
	*/
	bool CTCPIPPacket::IsEmpty()
	{
		bool resultPacketIsEmpty = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPPacket_IsEmpty(m_pHandle, &resultPacketIsEmpty));
		
		return resultPacketIsEmpty;
	}
	
	/**
	* CTCPIPPacket::GetSize - Returns the size of the packet. Returns 0 if packet is empty.
	* @return returns size of packet.
	*/
	LibMCEnv_uint32 CTCPIPPacket::GetSize()
	{
		LibMCEnv_uint32 resultPacketSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPPacket_GetSize(m_pHandle, &resultPacketSize));
		
		return resultPacketSize;
	}
	
	/**
	* CTCPIPPacket::GetData - Returns the data of the packet. Fails if packet is empty.
	* @param[out] BufferBuffer - packet data.
	*/
	void CTCPIPPacket::GetData(std::vector<LibMCEnv_uint8> & BufferBuffer)
	{
		LibMCEnv_uint64 elementsNeededBuffer = 0;
		LibMCEnv_uint64 elementsWrittenBuffer = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPPacket_GetData(m_pHandle, 0, &elementsNeededBuffer, nullptr));
		BufferBuffer.resize((size_t) elementsNeededBuffer);
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPPacket_GetData(m_pHandle, elementsNeededBuffer, &elementsWrittenBuffer, BufferBuffer.data()));
	}
	
	/**
	 * Method definitions for class CTCPIPConnection
	 */
	
	/**
	* CTCPIPConnection::GetIPAddress - Returns the IP Address of the Connection.
	* @return IP Address.
	*/
	std::string CTCPIPConnection::GetIPAddress()
	{
		LibMCEnv_uint32 bytesNeededIPAddress = 0;
		LibMCEnv_uint32 bytesWrittenIPAddress = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_GetIPAddress(m_pHandle, 0, &bytesNeededIPAddress, nullptr));
		std::vector<char> bufferIPAddress(bytesNeededIPAddress);
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_GetIPAddress(m_pHandle, bytesNeededIPAddress, &bytesWrittenIPAddress, &bufferIPAddress[0]));
		
		return std::string(&bufferIPAddress[0]);
	}
	
	/**
	* CTCPIPConnection::GetPort - Returns the Port of the Connection.
	* @return Port.
	*/
	LibMCEnv_uint32 CTCPIPConnection::GetPort()
	{
		LibMCEnv_uint32 resultPort = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_GetPort(m_pHandle, &resultPort));
		
		return resultPort;
	}
	
	/**
	* CTCPIPConnection::GetTimeout - Returns the Timeout of the Connection.
	* @return Timeout in milliseconds.
	*/
	LibMCEnv_uint32 CTCPIPConnection::GetTimeout()
	{
		LibMCEnv_uint32 resultTimeout = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_GetTimeout(m_pHandle, &resultTimeout));
		
		return resultTimeout;
	}
	
	/**
	* CTCPIPConnection::IsConnected - Returns if the instance is connected.
	* @return .
	*/
	bool CTCPIPConnection::IsConnected()
	{
		bool resultIsConnected = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_IsConnected(m_pHandle, &resultIsConnected));
		
		return resultIsConnected;
	}
	
	/**
	* CTCPIPConnection::Disconnect - Disconnects from the Server, if connected.
	*/
	void CTCPIPConnection::Disconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_Disconnect(m_pHandle));
	}
	
	/**
	* CTCPIPConnection::Reconnect - Disconnects and Connects to the Server.
	*/
	void CTCPIPConnection::Reconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_Reconnect(m_pHandle));
	}
	
	/**
	* CTCPIPConnection::SendBuffer - Sends a buffer of bytes to the Server.
	* @param[in] BufferBuffer - packet payload.
	*/
	void CTCPIPConnection::SendBuffer(const CInputVector<LibMCEnv_uint8> & BufferBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_SendBuffer(m_pHandle, (LibMCEnv_uint64)BufferBuffer.size(), BufferBuffer.data()));
	}
	
	/**
	* CTCPIPConnection::WaitForData - Waits for a server packet to arrive.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return Flag if a new packet has arrived.
	*/
	bool CTCPIPConnection::WaitForData(const LibMCEnv_uint32 nTimeOutInMS)
	{
		bool resultDataAvailable = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_WaitForData(m_pHandle, nTimeOutInMS, &resultDataAvailable));
		
		return resultDataAvailable;
	}
	
	/**
	* CTCPIPConnection::ReceiveFixedPacket - Receives a fixed length packet. Blocks until expected number of bytes arrives or timeout is hit. Fails if there is a connection error. Returns empty packet if timeout is hit.
	* @param[in] nPacketSize - Size of packet to receive. MUST be larger than 0.
	* @param[in] nTimeOutInMS - Timeout in Milliseconds.
	* @return Packet instance. Returns empty packet if timeout is hit
	*/
	PTCPIPPacket CTCPIPConnection::ReceiveFixedPacket(const LibMCEnv_uint32 nPacketSize, const LibMCEnv_uint32 nTimeOutInMS)
	{
		LibMCEnvHandle hPacketInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_ReceiveFixedPacket(m_pHandle, nPacketSize, nTimeOutInMS, &hPacketInstance));
		
		if (!hPacketInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CTCPIPPacket>(m_pWrapper, hPacketInstance);
	}
	
	/**
	* CTCPIPConnection::ReceiveData - Receives data. Fails if there is a connection error. Returns empty packet if timeout is hit.
	* @param[in] nDataSize - Size of data to receive.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return Packet instance. Size will be between 0 and DataSize.
	*/
	PTCPIPPacket CTCPIPConnection::ReceiveData(const LibMCEnv_uint32 nDataSize, const LibMCEnv_uint32 nTimeOutInMS)
	{
		LibMCEnvHandle hPacketInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_TCPIPConnection_ReceiveData(m_pHandle, nDataSize, nTimeOutInMS, &hPacketInstance));
		
		if (!hPacketInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CTCPIPPacket>(m_pWrapper, hPacketInstance);
	}
	
	/**
	 * Method definitions for class CModbusTCPDigitalIOStatus
	 */
	
	/**
	* CModbusTCPDigitalIOStatus::GetCount - Returns the number of Digital IOs in the instance.
	* @return Count.
	*/
	LibMCEnv_uint32 CModbusTCPDigitalIOStatus::GetCount()
	{
		LibMCEnv_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPDigitalIOStatus_GetCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CModbusTCPDigitalIOStatus::GetBaseAddress - Returns the base address of Digital IOs in the instance.
	* @return Base Address.
	*/
	LibMCEnv_uint32 CModbusTCPDigitalIOStatus::GetBaseAddress()
	{
		LibMCEnv_uint32 resultAddress = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPDigitalIOStatus_GetBaseAddress(m_pHandle, &resultAddress));
		
		return resultAddress;
	}
	
	/**
	* CModbusTCPDigitalIOStatus::GetValue - Returns the cached state of the Digital IO in the instance.
	* @param[in] nIndex - Index of IO Value. 0-based.
	* @return State Value.
	*/
	bool CModbusTCPDigitalIOStatus::GetValue(const LibMCEnv_uint32 nIndex)
	{
		bool resultState = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPDigitalIOStatus_GetValue(m_pHandle, nIndex, &resultState));
		
		return resultState;
	}
	
	/**
	* CModbusTCPDigitalIOStatus::GetValues - Returns all Digital IOs of the instance as byte array.
	* @param[out] StateArrayBuffer - State Value Array.
	*/
	void CModbusTCPDigitalIOStatus::GetValues(std::vector<LibMCEnv_uint8> & StateArrayBuffer)
	{
		LibMCEnv_uint64 elementsNeededStateArray = 0;
		LibMCEnv_uint64 elementsWrittenStateArray = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPDigitalIOStatus_GetValues(m_pHandle, 0, &elementsNeededStateArray, nullptr));
		StateArrayBuffer.resize((size_t) elementsNeededStateArray);
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPDigitalIOStatus_GetValues(m_pHandle, elementsNeededStateArray, &elementsWrittenStateArray, StateArrayBuffer.data()));
	}
	
	/**
	 * Method definitions for class CModbusTCPRegisterStatus
	 */
	
	/**
	* CModbusTCPRegisterStatus::GetCount - Returns the number of registers in the instance.
	* @return Count.
	*/
	LibMCEnv_uint32 CModbusTCPRegisterStatus::GetCount()
	{
		LibMCEnv_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPRegisterStatus_GetCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CModbusTCPRegisterStatus::GetBaseAddress - Returns the base address of registers in the instance.
	* @return Base Address.
	*/
	LibMCEnv_uint32 CModbusTCPRegisterStatus::GetBaseAddress()
	{
		LibMCEnv_uint32 resultAddress = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPRegisterStatus_GetBaseAddress(m_pHandle, &resultAddress));
		
		return resultAddress;
	}
	
	/**
	* CModbusTCPRegisterStatus::GetValue - Returns the cached state of the registers in the instance.
	* @param[in] nIndex - Index of IO Value. 0-based.
	* @return State Value.
	*/
	LibMCEnv_uint16 CModbusTCPRegisterStatus::GetValue(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnv_uint16 resultState = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPRegisterStatus_GetValue(m_pHandle, nIndex, &resultState));
		
		return resultState;
	}
	
	/**
	* CModbusTCPRegisterStatus::GetValues - Returns all registers of the instance as word array.
	* @param[out] StateArrayBuffer - State Value Array.
	*/
	void CModbusTCPRegisterStatus::GetValues(std::vector<LibMCEnv_uint16> & StateArrayBuffer)
	{
		LibMCEnv_uint64 elementsNeededStateArray = 0;
		LibMCEnv_uint64 elementsWrittenStateArray = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPRegisterStatus_GetValues(m_pHandle, 0, &elementsNeededStateArray, nullptr));
		StateArrayBuffer.resize((size_t) elementsNeededStateArray);
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPRegisterStatus_GetValues(m_pHandle, elementsNeededStateArray, &elementsWrittenStateArray, StateArrayBuffer.data()));
	}
	
	/**
	 * Method definitions for class CModbusTCPConnection
	 */
	
	/**
	* CModbusTCPConnection::GetIPAddress - Returns the IP Address of the Connection.
	* @return IP Address.
	*/
	std::string CModbusTCPConnection::GetIPAddress()
	{
		LibMCEnv_uint32 bytesNeededIPAddress = 0;
		LibMCEnv_uint32 bytesWrittenIPAddress = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_GetIPAddress(m_pHandle, 0, &bytesNeededIPAddress, nullptr));
		std::vector<char> bufferIPAddress(bytesNeededIPAddress);
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_GetIPAddress(m_pHandle, bytesNeededIPAddress, &bytesWrittenIPAddress, &bufferIPAddress[0]));
		
		return std::string(&bufferIPAddress[0]);
	}
	
	/**
	* CModbusTCPConnection::GetPort - Returns the Port of the Connection.
	* @return Port.
	*/
	LibMCEnv_uint32 CModbusTCPConnection::GetPort()
	{
		LibMCEnv_uint32 resultPort = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_GetPort(m_pHandle, &resultPort));
		
		return resultPort;
	}
	
	/**
	* CModbusTCPConnection::GetTimeout - Returns the Timeout of the Connection.
	* @return Timeout in milliseconds.
	*/
	LibMCEnv_uint32 CModbusTCPConnection::GetTimeout()
	{
		LibMCEnv_uint32 resultTimeout = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_GetTimeout(m_pHandle, &resultTimeout));
		
		return resultTimeout;
	}
	
	/**
	* CModbusTCPConnection::IsConnected - Returns if the instance is connected.
	* @return .
	*/
	bool CModbusTCPConnection::IsConnected()
	{
		bool resultIsConnected = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_IsConnected(m_pHandle, &resultIsConnected));
		
		return resultIsConnected;
	}
	
	/**
	* CModbusTCPConnection::Disconnect - Disconnects from the Server.
	*/
	void CModbusTCPConnection::Disconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_Disconnect(m_pHandle));
	}
	
	/**
	* CModbusTCPConnection::Reconnect - Disconnects and Connects to the Server.
	*/
	void CModbusTCPConnection::Reconnect()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_Reconnect(m_pHandle));
	}
	
	/**
	* CModbusTCPConnection::DiagnosisCall - Sends a diagnosis call to the Server.
	* @param[in] nSubFunction - Modbus TCP Subfunction ID.
	* @param[in] nDataField - Modbus TCP Data Field.
	* @return Modbus TCP Data Response.
	*/
	LibMCEnv_uint16 CModbusTCPConnection::DiagnosisCall(const LibMCEnv_uint16 nSubFunction, const LibMCEnv_uint16 nDataField)
	{
		LibMCEnv_uint16 resultDataResponse = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_DiagnosisCall(m_pHandle, nSubFunction, nDataField, &resultDataResponse));
		
		return resultDataResponse;
	}
	
	/**
	* CModbusTCPConnection::ReadCoilStatus - Reads coil status of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBitCount - Number of coils to read. MUST be larger than 0.
	* @return Coil status instance.
	*/
	PModbusTCPDigitalIOStatus CModbusTCPConnection::ReadCoilStatus(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nBitCount)
	{
		LibMCEnvHandle hCoilStatus = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_ReadCoilStatus(m_pHandle, nStartAddress, nBitCount, &hCoilStatus));
		
		if (!hCoilStatus) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModbusTCPDigitalIOStatus>(m_pWrapper, hCoilStatus);
	}
	
	/**
	* CModbusTCPConnection::ReadInputStatus - Reads input status of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBitCount - Number of inputs to read. MUST be larger than 0.
	* @return Input status instance.
	*/
	PModbusTCPDigitalIOStatus CModbusTCPConnection::ReadInputStatus(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nBitCount)
	{
		LibMCEnvHandle hInputStatus = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_ReadInputStatus(m_pHandle, nStartAddress, nBitCount, &hInputStatus));
		
		if (!hInputStatus) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModbusTCPDigitalIOStatus>(m_pWrapper, hInputStatus);
	}
	
	/**
	* CModbusTCPConnection::ReadHoldingRegisters - Reads holding registers of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nRegisterCount - Number of registers. MUST be larger than 0.
	* @return Holding register instance.
	*/
	PModbusTCPRegisterStatus CModbusTCPConnection::ReadHoldingRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nRegisterCount)
	{
		LibMCEnvHandle hRegisterInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_ReadHoldingRegisters(m_pHandle, nStartAddress, nRegisterCount, &hRegisterInstance));
		
		if (!hRegisterInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModbusTCPRegisterStatus>(m_pWrapper, hRegisterInstance);
	}
	
	/**
	* CModbusTCPConnection::ReadInputRegisters - Reads input registers of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nRegisterCount - Number of registers. MUST be larger than 0.
	* @return Input register instance.
	*/
	PModbusTCPRegisterStatus CModbusTCPConnection::ReadInputRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nRegisterCount)
	{
		LibMCEnvHandle hRegisterInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_ReadInputRegisters(m_pHandle, nStartAddress, nRegisterCount, &hRegisterInstance));
		
		if (!hRegisterInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModbusTCPRegisterStatus>(m_pWrapper, hRegisterInstance);
	}
	
	/**
	* CModbusTCPConnection::ForceMultipleCoils - Forces multiple coils on Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] BufferBuffer - Input coil array. One byte per Input. MUST NOT be empty
	*/
	void CModbusTCPConnection::ForceMultipleCoils(const LibMCEnv_uint32 nStartAddress, const CInputVector<LibMCEnv_uint8> & BufferBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_ForceMultipleCoils(m_pHandle, nStartAddress, (LibMCEnv_uint64)BufferBuffer.size(), BufferBuffer.data()));
	}
	
	/**
	* CModbusTCPConnection::PresetMultipleRegisters - Forces multiple registers on Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] BufferBuffer - Input register array. One word per Input. MUST NOT be empty
	*/
	void CModbusTCPConnection::PresetMultipleRegisters(const LibMCEnv_uint32 nStartAddress, const CInputVector<LibMCEnv_uint16> & BufferBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ModbusTCPConnection_PresetMultipleRegisters(m_pHandle, nStartAddress, (LibMCEnv_uint64)BufferBuffer.size(), BufferBuffer.data()));
	}
	
	/**
	 * Method definitions for class CDriverStatusUpdateSession
	 */
	
	/**
	* CDriverStatusUpdateSession::SetStringParameter - sets a string parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CDriverStatusUpdateSession::SetStringParameter(const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverStatusUpdateSession_SetStringParameter(m_pHandle, sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CDriverStatusUpdateSession::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CDriverStatusUpdateSession::SetUUIDParameter(const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverStatusUpdateSession_SetUUIDParameter(m_pHandle, sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CDriverStatusUpdateSession::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	void CDriverStatusUpdateSession::SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverStatusUpdateSession_SetDoubleParameter(m_pHandle, sParameterName.c_str(), dValue));
	}
	
	/**
	* CDriverStatusUpdateSession::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	void CDriverStatusUpdateSession::SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverStatusUpdateSession_SetIntegerParameter(m_pHandle, sParameterName.c_str(), nValue));
	}
	
	/**
	* CDriverStatusUpdateSession::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	void CDriverStatusUpdateSession::SetBoolParameter(const std::string & sParameterName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverStatusUpdateSession_SetBoolParameter(m_pHandle, sParameterName.c_str(), bValue));
	}
	
	/**
	* CDriverStatusUpdateSession::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	void CDriverStatusUpdateSession::LogMessage(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverStatusUpdateSession_LogMessage(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CDriverStatusUpdateSession::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	void CDriverStatusUpdateSession::LogWarning(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverStatusUpdateSession_LogWarning(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CDriverStatusUpdateSession::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	void CDriverStatusUpdateSession::LogInfo(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverStatusUpdateSession_LogInfo(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CDriverStatusUpdateSession::Sleep - Puts the current instance to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	void CDriverStatusUpdateSession::Sleep(const LibMCEnv_uint32 nDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverStatusUpdateSession_Sleep(m_pHandle, nDelay));
	}
	
	/**
	 * Method definitions for class CDriverEnvironment
	 */
	
	/**
	* CDriverEnvironment::CreateStatusUpdateSession - creates a status update object which can be easily called from an independent thread.
	* @return creates a status update instance
	*/
	PDriverStatusUpdateSession CDriverEnvironment::CreateStatusUpdateSession()
	{
		LibMCEnvHandle hUpdateStatusInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateStatusUpdateSession(m_pHandle, &hUpdateStatusInstance));
		
		if (!hUpdateStatusInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDriverStatusUpdateSession>(m_pWrapper, hUpdateStatusInstance);
	}
	
	/**
	* CDriverEnvironment::CreateWorkingDirectory - creates a temporary working directory.
	* @return creates a working directory
	*/
	PWorkingDirectory CDriverEnvironment::CreateWorkingDirectory()
	{
		LibMCEnvHandle hWorkingDirectory = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateWorkingDirectory(m_pHandle, &hWorkingDirectory));
		
		if (!hWorkingDirectory) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingDirectory>(m_pWrapper, hWorkingDirectory);
	}
	
	/**
	* CDriverEnvironment::CreateTCPIPConnection - creates a TCP/IP Connection for a specific IP address and port.
	* @param[in] sIPAddress - IP Address.
	* @param[in] nPort - Port.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return connects to the given IP Address
	*/
	PTCPIPConnection CDriverEnvironment::CreateTCPIPConnection(const std::string & sIPAddress, const LibMCEnv_uint32 nPort, const LibMCEnv_uint32 nTimeOutInMS)
	{
		LibMCEnvHandle hConnectionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateTCPIPConnection(m_pHandle, sIPAddress.c_str(), nPort, nTimeOutInMS, &hConnectionInstance));
		
		if (!hConnectionInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CTCPIPConnection>(m_pWrapper, hConnectionInstance);
	}
	
	/**
	* CDriverEnvironment::CreateModbusTCPConnection - creates a Modbus TCP Connection for a specific IP address and port.
	* @param[in] sIPAddress - IP Address.
	* @param[in] nPort - Port.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return connects to the given IP Address
	*/
	PModbusTCPConnection CDriverEnvironment::CreateModbusTCPConnection(const std::string & sIPAddress, const LibMCEnv_uint32 nPort, const LibMCEnv_uint32 nTimeOutInMS)
	{
		LibMCEnvHandle hConnectionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateModbusTCPConnection(m_pHandle, sIPAddress.c_str(), nPort, nTimeOutInMS, &hConnectionInstance));
		
		if (!hConnectionInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CModbusTCPConnection>(m_pWrapper, hConnectionInstance);
	}
	
	/**
	* CDriverEnvironment::CreateXMLDocument - creates an empty XML Document.
	* @param[in] sRootNodeName - Name of the root node. MUST be a valid XML Node Name string.
	* @param[in] sDefaultNamespace - Default namespace of the document. MUST be a valid XML namespace string.
	* @return XML Document Instance.
	*/
	PXMLDocument CDriverEnvironment::CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace)
	{
		LibMCEnvHandle hXMLDocument = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateXMLDocument(m_pHandle, sRootNodeName.c_str(), sDefaultNamespace.c_str(), &hXMLDocument));
		
		if (!hXMLDocument) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocument>(m_pWrapper, hXMLDocument);
	}
	
	/**
	* CDriverEnvironment::ParseXMLString - parses an XML String and returns an XML Document instance. Throws an error if XML is malformatted.
	* @param[in] sXMLString - XML String.
	* @return XML Document Instance.
	*/
	PXMLDocument CDriverEnvironment::ParseXMLString(const std::string & sXMLString)
	{
		LibMCEnvHandle hXMLDocument = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_ParseXMLString(m_pHandle, sXMLString.c_str(), &hXMLDocument));
		
		if (!hXMLDocument) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocument>(m_pWrapper, hXMLDocument);
	}
	
	/**
	* CDriverEnvironment::ParseXMLData - parses a XML stored in a byte array and returns an XML Document instance. . Throws an error if XML is malformatted.
	* @param[in] XMLDataBuffer - XML Binary data.
	* @return XML Document Instance.
	*/
	PXMLDocument CDriverEnvironment::ParseXMLData(const CInputVector<LibMCEnv_uint8> & XMLDataBuffer)
	{
		LibMCEnvHandle hXMLDocument = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_ParseXMLData(m_pHandle, (LibMCEnv_uint64)XMLDataBuffer.size(), XMLDataBuffer.data(), &hXMLDocument));
		
		if (!hXMLDocument) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocument>(m_pWrapper, hXMLDocument);
	}
	
	/**
	* CDriverEnvironment::CreateDataTable - creates an empty data table.
	* @return Data Table Instance.
	*/
	PDataTable CDriverEnvironment::CreateDataTable()
	{
		LibMCEnvHandle hDataTableInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateDataTable(m_pHandle, &hDataTableInstance));
		
		if (!hDataTableInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataTable>(m_pWrapper, hDataTableInstance);
	}
	
	/**
	* CDriverEnvironment::DriverHasResourceData - retrieves if attached driver has data with the given identifier.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return returns true if the resource exists in the machine resource package.
	*/
	bool CDriverEnvironment::DriverHasResourceData(const std::string & sIdentifier)
	{
		bool resultHasResourceData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_DriverHasResourceData(m_pHandle, sIdentifier.c_str(), &resultHasResourceData));
		
		return resultHasResourceData;
	}
	
	/**
	* CDriverEnvironment::MachineHasResourceData - retrieves if attached driver has data with the given identifier.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return returns true if the resource exists in the machine resource package.
	*/
	bool CDriverEnvironment::MachineHasResourceData(const std::string & sIdentifier)
	{
		bool resultHasResourceData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_MachineHasResourceData(m_pHandle, sIdentifier.c_str(), &resultHasResourceData));
		
		return resultHasResourceData;
	}
	
	/**
	* CDriverEnvironment::RetrieveDriverData - retrieves attached driver resource data into a memory buffer. (depreciated, equivalent to RetrieveDriverResourceData)
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @param[out] DataBufferBuffer - buffer data.
	*/
	void CDriverEnvironment::RetrieveDriverData(const std::string & sIdentifier, std::vector<LibMCEnv_uint8> & DataBufferBuffer)
	{
		LibMCEnv_uint64 elementsNeededDataBuffer = 0;
		LibMCEnv_uint64 elementsWrittenDataBuffer = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RetrieveDriverData(m_pHandle, sIdentifier.c_str(), 0, &elementsNeededDataBuffer, nullptr));
		DataBufferBuffer.resize((size_t) elementsNeededDataBuffer);
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RetrieveDriverData(m_pHandle, sIdentifier.c_str(), elementsNeededDataBuffer, &elementsWrittenDataBuffer, DataBufferBuffer.data()));
	}
	
	/**
	* CDriverEnvironment::RetrieveDriverResourceData - retrieves attached driver resource data into a memory buffer.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @param[out] DataBufferBuffer - buffer data.
	*/
	void CDriverEnvironment::RetrieveDriverResourceData(const std::string & sIdentifier, std::vector<LibMCEnv_uint8> & DataBufferBuffer)
	{
		LibMCEnv_uint64 elementsNeededDataBuffer = 0;
		LibMCEnv_uint64 elementsWrittenDataBuffer = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RetrieveDriverResourceData(m_pHandle, sIdentifier.c_str(), 0, &elementsNeededDataBuffer, nullptr));
		DataBufferBuffer.resize((size_t) elementsNeededDataBuffer);
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RetrieveDriverResourceData(m_pHandle, sIdentifier.c_str(), elementsNeededDataBuffer, &elementsWrittenDataBuffer, DataBufferBuffer.data()));
	}
	
	/**
	* CDriverEnvironment::RetrieveMachineResourceData - retrieves a machine resource data (Plugins Directory) driver data into a memory buffer.
	* @param[in] sIdentifier - identifier of the binary data in the machine resource package.
	* @param[out] DataBufferBuffer - buffer data.
	*/
	void CDriverEnvironment::RetrieveMachineResourceData(const std::string & sIdentifier, std::vector<LibMCEnv_uint8> & DataBufferBuffer)
	{
		LibMCEnv_uint64 elementsNeededDataBuffer = 0;
		LibMCEnv_uint64 elementsWrittenDataBuffer = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RetrieveMachineResourceData(m_pHandle, sIdentifier.c_str(), 0, &elementsNeededDataBuffer, nullptr));
		DataBufferBuffer.resize((size_t) elementsNeededDataBuffer);
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RetrieveMachineResourceData(m_pHandle, sIdentifier.c_str(), elementsNeededDataBuffer, &elementsWrittenDataBuffer, DataBufferBuffer.data()));
	}
	
	/**
	* CDriverEnvironment::CreateToolpathAccessor - Creates an accessor object for a toolpath. Toolpath MUST have been loaded into memory before.
	* @param[in] sStreamUUID - UUID of the stream.
	* @return Toolpath instance.
	*/
	PToolpathAccessor CDriverEnvironment::CreateToolpathAccessor(const std::string & sStreamUUID)
	{
		LibMCEnvHandle hToolpathInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateToolpathAccessor(m_pHandle, sStreamUUID.c_str(), &hToolpathInstance));
		
		if (!hToolpathInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CToolpathAccessor>(m_pWrapper, hToolpathInstance);
	}
	
	/**
	* CDriverEnvironment::ParameterNameIsValid - checks if a name is a valid alphanumerical string for parameters.
	* @param[in] sParameterName - Parameter Name
	* @return returns true if the parameter name is a valid name.
	*/
	bool CDriverEnvironment::ParameterNameIsValid(const std::string & sParameterName)
	{
		bool resultNameIsValid = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_ParameterNameIsValid(m_pHandle, sParameterName.c_str(), &resultNameIsValid));
		
		return resultNameIsValid;
	}
	
	/**
	* CDriverEnvironment::RegisterStringParameter - registers a string parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] sDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterStringParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterStringParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), sDefaultValue.c_str()));
	}
	
	/**
	* CDriverEnvironment::RegisterUUIDParameter - registers a uuid parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] sDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterUUIDParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterUUIDParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), sDefaultValue.c_str()));
	}
	
	/**
	* CDriverEnvironment::RegisterDoubleParameter - registers a double parameter. Must only be called during driver creation. The default units are 0.001.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] dDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterDoubleParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_double dDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterDoubleParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), dDefaultValue));
	}
	
	/**
	* CDriverEnvironment::RegisterDoubleParameterWithUnits - registers a double parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] dDefaultValue - default value to set
	* @param[in] dUnits - unit factor to use
	*/
	void CDriverEnvironment::RegisterDoubleParameterWithUnits(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_double dDefaultValue, const LibMCEnv_double dUnits)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterDoubleParameterWithUnits(m_pHandle, sParameterName.c_str(), sDescription.c_str(), dDefaultValue, dUnits));
	}
	
	/**
	* CDriverEnvironment::RegisterIntegerParameter - registers an int parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] nDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterIntegerParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_int64 nDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterIntegerParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), nDefaultValue));
	}
	
	/**
	* CDriverEnvironment::RegisterBoolParameter - registers a bool parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] bDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterBoolParameter(const std::string & sParameterName, const std::string & sDescription, const bool bDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterBoolParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), bDefaultValue));
	}
	
	/**
	* CDriverEnvironment::SetStringParameter - sets a string parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CDriverEnvironment::SetStringParameter(const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetStringParameter(m_pHandle, sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CDriverEnvironment::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CDriverEnvironment::SetUUIDParameter(const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetUUIDParameter(m_pHandle, sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CDriverEnvironment::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	void CDriverEnvironment::SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetDoubleParameter(m_pHandle, sParameterName.c_str(), dValue));
	}
	
	/**
	* CDriverEnvironment::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	void CDriverEnvironment::SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetIntegerParameter(m_pHandle, sParameterName.c_str(), nValue));
	}
	
	/**
	* CDriverEnvironment::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	void CDriverEnvironment::SetBoolParameter(const std::string & sParameterName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetBoolParameter(m_pHandle, sParameterName.c_str(), bValue));
	}
	
	/**
	* CDriverEnvironment::Sleep - Puts the current instance to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	void CDriverEnvironment::Sleep(const LibMCEnv_uint32 nDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_Sleep(m_pHandle, nDelay));
	}
	
	/**
	* CDriverEnvironment::GetGlobalTimerInMilliseconds - Returns the global timer in milliseconds.
	* @return Timer value in Milliseconds
	*/
	LibMCEnv_uint64 CDriverEnvironment::GetGlobalTimerInMilliseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_GetGlobalTimerInMilliseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CDriverEnvironment::GetGlobalTimerInMicroseconds - Returns the global timer in microseconds.
	* @return Timer value in Microseconds
	*/
	LibMCEnv_uint64 CDriverEnvironment::GetGlobalTimerInMicroseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_GetGlobalTimerInMicroseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CDriverEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	void CDriverEnvironment::LogMessage(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_LogMessage(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CDriverEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	void CDriverEnvironment::LogWarning(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_LogWarning(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CDriverEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	void CDriverEnvironment::LogInfo(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_LogInfo(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CDriverEnvironment::CreateEmptyImage - creates an empty image object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use.
	* @return Empty image instance.
	*/
	PImageData CDriverEnvironment::CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateEmptyImage(m_pHandle, nPixelSizeX, nPixelSizeY, dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CDriverEnvironment::LoadPNGImage - creates an image object from a PNG data stream.
	* @param[in] PNGDataBuffer - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image instance containing the PNG image.
	*/
	PImageData CDriverEnvironment::LoadPNGImage(const CInputVector<LibMCEnv_uint8> & PNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_LoadPNGImage(m_pHandle, (LibMCEnv_uint64)PNGDataBuffer.size(), PNGDataBuffer.data(), dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CDriverEnvironment::CreateDiscreteField2D - Creates an empty discrete field.
	* @param[in] nPixelCountX - Pixel count in X. MUST be positive.
	* @param[in] nPixelCountY - Pixel count in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @param[in] dDefaultValue - Default value of the field.
	* @return Empty field instance.
	*/
	PDiscreteFieldData2D CDriverEnvironment::CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue)
	{
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateDiscreteField2D(m_pHandle, nPixelCountX, nPixelCountY, dDPIValueX, dDPIValueY, dOriginX, dOriginY, dDefaultValue, &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CDriverEnvironment::CreateDiscreteField2DFromImage - Creates a discrete field from the greyscale values of an image. RGB colors in the image will be averaged to obtain a greyscale color.
	* @param[in] pImageDataInstance - Image instance containing the pixel data.
	* @param[in] dBlackValue - Value that the minimum color (black) shall be mapped to.
	* @param[in] dWhiteValue - Value that the maximum color (white) shall be mapped to.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @return Empty field instance.
	*/
	PDiscreteFieldData2D CDriverEnvironment::CreateDiscreteField2DFromImage(classParam<CImageData> pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY)
	{
		LibMCEnvHandle hImageDataInstance = pImageDataInstance.GetHandle();
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateDiscreteField2DFromImage(m_pHandle, hImageDataInstance, dBlackValue, dWhiteValue, dOriginX, dOriginY, &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CDriverEnvironment::HasBuildJob - Returns if a build object exists. Fails if BuildUUID is not a valid UUID string.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Returns true if build exists
	*/
	bool CDriverEnvironment::HasBuildJob(const std::string & sBuildUUID)
	{
		bool resultBuildExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_HasBuildJob(m_pHandle, sBuildUUID.c_str(), &resultBuildExists));
		
		return resultBuildExists;
	}
	
	/**
	* CDriverEnvironment::GetBuildJob - Returns a instance of a build object. Fails if build uuid does not exist.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	PBuild CDriverEnvironment::GetBuildJob(const std::string & sBuildUUID)
	{
		LibMCEnvHandle hBuildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_GetBuildJob(m_pHandle, sBuildUUID.c_str(), &hBuildInstance));
		
		if (!hBuildInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuild>(m_pWrapper, hBuildInstance);
	}
	
	/**
	* CDriverEnvironment::HasBuildExecution - Returns if a build execution exists. Fails if ExecutionUUID is not a valid UUID string.
	* @param[in] sExecutionUUID - UUID of the execution entity.
	* @return Returns true if execution exists
	*/
	bool CDriverEnvironment::HasBuildExecution(const std::string & sExecutionUUID)
	{
		bool resultExecutionExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_HasBuildExecution(m_pHandle, sExecutionUUID.c_str(), &resultExecutionExists));
		
		return resultExecutionExists;
	}
	
	/**
	* CDriverEnvironment::GetBuildExecution - Returns a instance of a build execution object. Fails if build execution uuid does not exist.
	* @param[in] sExecutionUUID - UUID of the execution entity.
	* @return Build execution instance
	*/
	PBuildExecution CDriverEnvironment::GetBuildExecution(const std::string & sExecutionUUID)
	{
		LibMCEnvHandle hExecutionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_GetBuildExecution(m_pHandle, sExecutionUUID.c_str(), &hExecutionInstance));
		
		if (!hExecutionInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildExecution>(m_pWrapper, hExecutionInstance);
	}
	
	/**
	* CDriverEnvironment::CreateCryptoContext - Creates a crypto context.
	* @return Cryptographic context instance
	*/
	PCryptoContext CDriverEnvironment::CreateCryptoContext()
	{
		LibMCEnvHandle hContext = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateCryptoContext(m_pHandle, &hContext));
		
		if (!hContext) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CCryptoContext>(m_pWrapper, hContext);
	}
	
	/**
	* CDriverEnvironment::GetCurrentDateTime - Returns the current time as DateTime object instance.
	* @return Date Time Instance.
	*/
	PDateTime CDriverEnvironment::GetCurrentDateTime()
	{
		LibMCEnvHandle hDateTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_GetCurrentDateTime(m_pHandle, &hDateTime));
		
		if (!hDateTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTime);
	}
	
	/**
	* CDriverEnvironment::GetCustomDateTime - Returns a custom time as DateTime object instance. Fails if the values are not a valid time from January first 1970 to year 1 million.
	* @param[in] nYear - Year. Must be larger or equal than 1970.
	* @param[in] nMonth - Month. Must be between 1 and 12.
	* @param[in] nDay - Day. Must be between 1 and 31.
	* @param[in] nHour - Hour. Must be between 0 and 23.
	* @param[in] nMinute - Minute. Must be between 0 and 59.
	* @param[in] nSecond - Second. Must be between 0 and 59.
	* @param[in] nMicrosecond - Microsecond. Must be between 0 and 999999.
	* @return Date Time Instance.
	*/
	PDateTime CDriverEnvironment::GetCustomDateTime(const LibMCEnv_uint32 nYear, const LibMCEnv_uint32 nMonth, const LibMCEnv_uint32 nDay, const LibMCEnv_uint32 nHour, const LibMCEnv_uint32 nMinute, const LibMCEnv_uint32 nSecond, const LibMCEnv_uint32 nMicrosecond)
	{
		LibMCEnvHandle hDateTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_GetCustomDateTime(m_pHandle, nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicrosecond, &hDateTime));
		
		if (!hDateTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTime);
	}
	
	/**
	* CDriverEnvironment::GetStartDateTime - Returns the startup time of the system as DateTime object instance. All Timer values are counted from there.
	* @return Date Time Instance.
	*/
	PDateTime CDriverEnvironment::GetStartDateTime()
	{
		LibMCEnvHandle hDateTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_GetStartDateTime(m_pHandle, &hDateTime));
		
		if (!hDateTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTime);
	}
	
	/**
	 * Method definitions for class CSignalTrigger
	 */
	
	/**
	* CSignalTrigger::CanTrigger - Returns, if signal channel is available.
	* @return Returns true, if signal channel is available.
	*/
	bool CSignalTrigger::CanTrigger()
	{
		bool resultChannelIsAvailable = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_CanTrigger(m_pHandle, &resultChannelIsAvailable));
		
		return resultChannelIsAvailable;
	}
	
	/**
	* CSignalTrigger::Trigger - Triggers a signal, if signal channel is available.
	*/
	void CSignalTrigger::Trigger()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_Trigger(m_pHandle));
	}
	
	/**
	* CSignalTrigger::WaitForHandling - Waits until the signal is reset.
	* @param[in] nTimeOut - Timeout in Milliseconds. 0 for Immediate return.
	* @return Flag if signal handling has been handled.
	*/
	bool CSignalTrigger::WaitForHandling(const LibMCEnv_uint32 nTimeOut)
	{
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_WaitForHandling(m_pHandle, nTimeOut, &resultSuccess));
		
		return resultSuccess;
	}
	
	/**
	* CSignalTrigger::GetName - Returns the signal name.
	* @return Name Of Signal
	*/
	std::string CSignalTrigger::GetName()
	{
		LibMCEnv_uint32 bytesNeededSignalName = 0;
		LibMCEnv_uint32 bytesWrittenSignalName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetName(m_pHandle, 0, &bytesNeededSignalName, nullptr));
		std::vector<char> bufferSignalName(bytesNeededSignalName);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetName(m_pHandle, bytesNeededSignalName, &bytesWrittenSignalName, &bufferSignalName[0]));
		
		return std::string(&bufferSignalName[0]);
	}
	
	/**
	* CSignalTrigger::GetStateMachine - Returns the signal state machine instance.
	* @return Name Of State Machine
	*/
	std::string CSignalTrigger::GetStateMachine()
	{
		LibMCEnv_uint32 bytesNeededStateMachineName = 0;
		LibMCEnv_uint32 bytesWrittenStateMachineName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetStateMachine(m_pHandle, 0, &bytesNeededStateMachineName, nullptr));
		std::vector<char> bufferStateMachineName(bytesNeededStateMachineName);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetStateMachine(m_pHandle, bytesNeededStateMachineName, &bytesWrittenStateMachineName, &bufferStateMachineName[0]));
		
		return std::string(&bufferStateMachineName[0]);
	}
	
	/**
	* CSignalTrigger::SetString - sets a string value
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	void CSignalTrigger::SetString(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetString(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CSignalTrigger::SetUUID - sets a uuid value
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	void CSignalTrigger::SetUUID(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetUUID(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CSignalTrigger::SetDouble - sets a double
	* @param[in] sName - Name
	* @param[in] dValue - Value
	*/
	void CSignalTrigger::SetDouble(const std::string & sName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetDouble(m_pHandle, sName.c_str(), dValue));
	}
	
	/**
	* CSignalTrigger::SetInteger - sets an int.
	* @param[in] sName - Name
	* @param[in] nValue - Value
	*/
	void CSignalTrigger::SetInteger(const std::string & sName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetInteger(m_pHandle, sName.c_str(), nValue));
	}
	
	/**
	* CSignalTrigger::SetBool - sets a bool
	* @param[in] sName - Name
	* @param[in] bValue - Value
	*/
	void CSignalTrigger::SetBool(const std::string & sName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetBool(m_pHandle, sName.c_str(), bValue));
	}
	
	/**
	* CSignalTrigger::GetStringResult - returns a string value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	std::string CSignalTrigger::GetStringResult(const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetStringResult(m_pHandle, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetStringResult(m_pHandle, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CSignalTrigger::GetUUIDResult - returns a uuid value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	std::string CSignalTrigger::GetUUIDResult(const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetUUIDResult(m_pHandle, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetUUIDResult(m_pHandle, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CSignalTrigger::GetDoubleResult - returns a string value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	LibMCEnv_double CSignalTrigger::GetDoubleResult(const std::string & sName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetDoubleResult(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalTrigger::GetIntegerResult - returns an int value of the result.
	* @param[in] sName - Name
	* @return Value
	*/
	LibMCEnv_int64 CSignalTrigger::GetIntegerResult(const std::string & sName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetIntegerResult(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalTrigger::GetBoolResult - returns a bool value of the result.
	* @param[in] sName - Name
	* @return Value
	*/
	bool CSignalTrigger::GetBoolResult(const std::string & sName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetBoolResult(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	 * Method definitions for class CSignalHandler
	 */
	
	/**
	* CSignalHandler::SignalHandled - Marks signal as handled and resets signal channel.
	*/
	void CSignalHandler::SignalHandled()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SignalHandled(m_pHandle));
	}
	
	/**
	* CSignalHandler::GetName - Returns the signal name.
	* @return Name Of Signal
	*/
	std::string CSignalHandler::GetName()
	{
		LibMCEnv_uint32 bytesNeededSignalName = 0;
		LibMCEnv_uint32 bytesWrittenSignalName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetName(m_pHandle, 0, &bytesNeededSignalName, nullptr));
		std::vector<char> bufferSignalName(bytesNeededSignalName);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetName(m_pHandle, bytesNeededSignalName, &bytesWrittenSignalName, &bufferSignalName[0]));
		
		return std::string(&bufferSignalName[0]);
	}
	
	/**
	* CSignalHandler::GetSignalID - Returns the signal id. Depreciated.
	* @return Signal Identifier
	*/
	std::string CSignalHandler::GetSignalID()
	{
		LibMCEnv_uint32 bytesNeededSignalID = 0;
		LibMCEnv_uint32 bytesWrittenSignalID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetSignalID(m_pHandle, 0, &bytesNeededSignalID, nullptr));
		std::vector<char> bufferSignalID(bytesNeededSignalID);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetSignalID(m_pHandle, bytesNeededSignalID, &bytesWrittenSignalID, &bufferSignalID[0]));
		
		return std::string(&bufferSignalID[0]);
	}
	
	/**
	* CSignalHandler::GetSignalUUID - Returns the signal uuid. Identical to GetSignalID.
	* @return Signal Identifier
	*/
	std::string CSignalHandler::GetSignalUUID()
	{
		LibMCEnv_uint32 bytesNeededSignalUUID = 0;
		LibMCEnv_uint32 bytesWrittenSignalUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetSignalUUID(m_pHandle, 0, &bytesNeededSignalUUID, nullptr));
		std::vector<char> bufferSignalUUID(bytesNeededSignalUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetSignalUUID(m_pHandle, bytesNeededSignalUUID, &bytesWrittenSignalUUID, &bufferSignalUUID[0]));
		
		return std::string(&bufferSignalUUID[0]);
	}
	
	/**
	* CSignalHandler::GetStateMachine - Returns the signal state machine instance.
	* @return Name Of State Machine
	*/
	std::string CSignalHandler::GetStateMachine()
	{
		LibMCEnv_uint32 bytesNeededStateMachineName = 0;
		LibMCEnv_uint32 bytesWrittenStateMachineName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetStateMachine(m_pHandle, 0, &bytesNeededStateMachineName, nullptr));
		std::vector<char> bufferStateMachineName(bytesNeededStateMachineName);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetStateMachine(m_pHandle, bytesNeededStateMachineName, &bytesWrittenStateMachineName, &bufferStateMachineName[0]));
		
		return std::string(&bufferStateMachineName[0]);
	}
	
	/**
	* CSignalHandler::GetString - gets a string value
	* @param[in] sName - Name
	* @return Value
	*/
	std::string CSignalHandler::GetString(const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetString(m_pHandle, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetString(m_pHandle, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CSignalHandler::GetUUID - gets a uuid value
	* @param[in] sName - Name
	* @return Value
	*/
	std::string CSignalHandler::GetUUID(const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetUUID(m_pHandle, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetUUID(m_pHandle, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CSignalHandler::GetDouble - gets a double
	* @param[in] sName - Name
	* @return Value
	*/
	LibMCEnv_double CSignalHandler::GetDouble(const std::string & sName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetDouble(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalHandler::GetInteger - gets an int.
	* @param[in] sName - Name
	* @return Value
	*/
	LibMCEnv_int64 CSignalHandler::GetInteger(const std::string & sName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetInteger(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalHandler::GetBool - gets a bool
	* @param[in] sName - Name
	* @return Value
	*/
	bool CSignalHandler::GetBool(const std::string & sName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetBool(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalHandler::SetStringResult - returns a string value of the result
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	void CSignalHandler::SetStringResult(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetStringResult(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CSignalHandler::SetUUIDResult - returns a uuid value of the result
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	void CSignalHandler::SetUUIDResult(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetUUIDResult(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CSignalHandler::SetDoubleResult - returns a string value of the result
	* @param[in] sName - Name
	* @param[in] dValue - Value
	*/
	void CSignalHandler::SetDoubleResult(const std::string & sName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetDoubleResult(m_pHandle, sName.c_str(), dValue));
	}
	
	/**
	* CSignalHandler::SetIntegerResult - sets an int.
	* @param[in] sName - Name
	* @param[in] nValue - Value
	*/
	void CSignalHandler::SetIntegerResult(const std::string & sName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetIntegerResult(m_pHandle, sName.c_str(), nValue));
	}
	
	/**
	* CSignalHandler::SetBoolResult - sets a bool
	* @param[in] sName - Name
	* @param[in] bValue - Value
	*/
	void CSignalHandler::SetBoolResult(const std::string & sName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetBoolResult(m_pHandle, sName.c_str(), bValue));
	}
	
	/**
	 * Method definitions for class CBaseTempStreamWriter
	 */
	
	/**
	* CBaseTempStreamWriter::GetUUID - Returns the UUID of the stream.
	* @return Returns stream uuid.
	*/
	std::string CBaseTempStreamWriter::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBaseTempStreamWriter::GetName - Returns the name of the stream.
	* @return Returns stream name.
	*/
	std::string CBaseTempStreamWriter::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBaseTempStreamWriter::GetMIMEType - Returns the MIME type of the stream.
	* @return Returns stream MIME Type.
	*/
	std::string CBaseTempStreamWriter::GetMIMEType()
	{
		LibMCEnv_uint32 bytesNeededMIMEType = 0;
		LibMCEnv_uint32 bytesWrittenMIMEType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_GetMIMEType(m_pHandle, 0, &bytesNeededMIMEType, nullptr));
		std::vector<char> bufferMIMEType(bytesNeededMIMEType);
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_GetMIMEType(m_pHandle, bytesNeededMIMEType, &bytesWrittenMIMEType, &bufferMIMEType[0]));
		
		return std::string(&bufferMIMEType[0]);
	}
	
	/**
	* CBaseTempStreamWriter::GetSize - Returns the current size of the stream.
	* @return Current size of the stream.
	*/
	LibMCEnv_uint64 CBaseTempStreamWriter::GetSize()
	{
		LibMCEnv_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_GetSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CBaseTempStreamWriter::Finish - Finishes the stream writing. All subsequent write attempts will fail. Fails if stream has been finished already.
	*/
	void CBaseTempStreamWriter::Finish()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_Finish(m_pHandle));
	}
	
	/**
	* CBaseTempStreamWriter::IsFinished - Returns if the stream writing has already been finished.
	* @return If true, writing into the stream is not possible anymore.
	*/
	bool CBaseTempStreamWriter::IsFinished()
	{
		bool resultFinished = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_IsFinished(m_pHandle, &resultFinished));
		
		return resultFinished;
	}
	
	/**
	* CBaseTempStreamWriter::GetStreamReader - Creates a stream reader on this stream. This call will finish the stream writing should it not be finished.
	* @return Stream reader instance.
	*/
	PStreamReader CBaseTempStreamWriter::GetStreamReader()
	{
		LibMCEnvHandle hStreamReader = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BaseTempStreamWriter_GetStreamReader(m_pHandle, &hStreamReader));
		
		if (!hStreamReader) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStreamReader>(m_pWrapper, hStreamReader);
	}
	
	/**
	 * Method definitions for class CTempStreamWriter
	 */
	
	/**
	* CTempStreamWriter::GetWritePosition - Returns the current write position of the stream.
	* @return Current write position of the stream.
	*/
	LibMCEnv_uint64 CTempStreamWriter::GetWritePosition()
	{
		LibMCEnv_uint64 resultWritePosition = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_TempStreamWriter_GetWritePosition(m_pHandle, &resultWritePosition));
		
		return resultWritePosition;
	}
	
	/**
	* CTempStreamWriter::Seek - Moves the current write position to a certain address. New position MUST be smaller or equal the stream size.
	* @param[in] nWritePosition - New write position of the stream. If Temp stream is living in a ZIP Writer, seeking is not possible.
	*/
	void CTempStreamWriter::Seek(const LibMCEnv_uint64 nWritePosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_TempStreamWriter_Seek(m_pHandle, nWritePosition));
	}
	
	/**
	* CTempStreamWriter::WriteData - Writes a data array into the stream. Fails if stream has been finished. Will enlarge stream if writing outside of the current size.
	* @param[in] DataBuffer - Data array to write into the stream
	*/
	void CTempStreamWriter::WriteData(const CInputVector<LibMCEnv_uint8> & DataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_TempStreamWriter_WriteData(m_pHandle, (LibMCEnv_uint64)DataBuffer.size(), DataBuffer.data()));
	}
	
	/**
	* CTempStreamWriter::WriteString - Writes a string into the stream. Fails if stream has been finished. Will enlarge stream if writing outside of the current size.
	* @param[in] sData - String to write into the stream
	*/
	void CTempStreamWriter::WriteString(const std::string & sData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_TempStreamWriter_WriteString(m_pHandle, sData.c_str()));
	}
	
	/**
	* CTempStreamWriter::WriteLine - Writes a string into the stream and adds a newline character. Fails if stream has been finished. Will enlarge stream if writing outside of the current size.
	* @param[in] sLine - String to write into the stream
	*/
	void CTempStreamWriter::WriteLine(const std::string & sLine)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_TempStreamWriter_WriteLine(m_pHandle, sLine.c_str()));
	}
	
	/**
	* CTempStreamWriter::CopyFrom - Copies the full content of a StreamReader Instance.
	* @param[in] pStreamReader - Stream to read from.
	*/
	void CTempStreamWriter::CopyFrom(classParam<CStreamReader> pStreamReader)
	{
		LibMCEnvHandle hStreamReader = pStreamReader.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_TempStreamWriter_CopyFrom(m_pHandle, hStreamReader));
	}
	
	/**
	 * Method definitions for class CZIPStreamWriter
	 */
	
	/**
	* CZIPStreamWriter::CreateZIPEntry - Creates a new ZIP entry in the ZIP file. All currently open ZIP Entry streams will be finished and closed.
	* @param[in] sFileName - File Name for the new entry in the ZIP file. Entry MUST not exist yet.
	* @return Returns temp stream to write into.
	*/
	PTempStreamWriter CZIPStreamWriter::CreateZIPEntry(const std::string & sFileName)
	{
		LibMCEnvHandle hTempStream = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ZIPStreamWriter_CreateZIPEntry(m_pHandle, sFileName.c_str(), &hTempStream));
		
		if (!hTempStream) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CTempStreamWriter>(m_pWrapper, hTempStream);
	}
	
	/**
	* CZIPStreamWriter::CreateZIPEntryFromStream - Adds the full content of a StreamReader Instance.
	* @param[in] sFileName - File Name for the new entry in the ZIP file. Entry MUST not exist yet.
	* @param[in] pStreamReader - Stream to read from.
	*/
	void CZIPStreamWriter::CreateZIPEntryFromStream(const std::string & sFileName, classParam<CStreamReader> pStreamReader)
	{
		LibMCEnvHandle hStreamReader = pStreamReader.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_ZIPStreamWriter_CreateZIPEntryFromStream(m_pHandle, sFileName.c_str(), hStreamReader));
	}
	
	/**
	 * Method definitions for class CStreamReader
	 */
	
	/**
	* CStreamReader::GetUUID - Returns the UUID of the stream.
	* @return Returns stream uuid.
	*/
	std::string CStreamReader::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CStreamReader::GetName - Returns the name of the stream.
	* @return Returns stream name.
	*/
	std::string CStreamReader::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CStreamReader::GetMIMEType - Returns the MIME type of the stream.
	* @return Returns stream MIME Type.
	*/
	std::string CStreamReader::GetMIMEType()
	{
		LibMCEnv_uint32 bytesNeededMIMEType = 0;
		LibMCEnv_uint32 bytesWrittenMIMEType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_GetMIMEType(m_pHandle, 0, &bytesNeededMIMEType, nullptr));
		std::vector<char> bufferMIMEType(bytesNeededMIMEType);
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_GetMIMEType(m_pHandle, bytesNeededMIMEType, &bytesWrittenMIMEType, &bufferMIMEType[0]));
		
		return std::string(&bufferMIMEType[0]);
	}
	
	/**
	* CStreamReader::GetSize - Returns the current size of the stream.
	* @return Current size of the stream.
	*/
	LibMCEnv_uint64 CStreamReader::GetSize()
	{
		LibMCEnv_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_GetSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CStreamReader::GetReadPosition - Returns the current read position of the stream.
	* @return Current read position of the stream.
	*/
	LibMCEnv_uint64 CStreamReader::GetReadPosition()
	{
		LibMCEnv_uint64 resultReadPosition = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_GetReadPosition(m_pHandle, &resultReadPosition));
		
		return resultReadPosition;
	}
	
	/**
	* CStreamReader::Seek - Moves the current read position to a certain address. New position MUST be smaller or equal the stream size.
	* @param[in] nReadPosition - New read position of the stream.
	*/
	void CStreamReader::Seek(const LibMCEnv_uint64 nReadPosition)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_Seek(m_pHandle, nReadPosition));
	}
	
	/**
	* CStreamReader::ReadData - Reads a data array from the stream from the current read position. Fails if reading outside of the stream data.
	* @param[in] nSizeToRead - Bytes to read. MUST be larger than 0.
	* @param[out] DataBuffer - Return data array. In case of success, will have SizeToRead elements.
	*/
	void CStreamReader::ReadData(const LibMCEnv_uint64 nSizeToRead, std::vector<LibMCEnv_uint8> & DataBuffer)
	{
		LibMCEnv_uint64 elementsNeededData = 0;
		LibMCEnv_uint64 elementsWrittenData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_ReadData(m_pHandle, nSizeToRead, 0, &elementsNeededData, nullptr));
		DataBuffer.resize((size_t) elementsNeededData);
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_ReadData(m_pHandle, nSizeToRead, elementsNeededData, &elementsWrittenData, DataBuffer.data()));
	}
	
	/**
	* CStreamReader::ReadAllData - Seeks to the beginning of the stream and returns all the stream data.
	* @param[out] DataBuffer - Return data array. In case of success, will have stream size elements.
	*/
	void CStreamReader::ReadAllData(std::vector<LibMCEnv_uint8> & DataBuffer)
	{
		LibMCEnv_uint64 elementsNeededData = 0;
		LibMCEnv_uint64 elementsWrittenData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_ReadAllData(m_pHandle, 0, &elementsNeededData, nullptr));
		DataBuffer.resize((size_t) elementsNeededData);
		CheckError(m_pWrapper->m_WrapperTable.m_StreamReader_ReadAllData(m_pHandle, elementsNeededData, &elementsWrittenData, DataBuffer.data()));
	}
	
	/**
	 * Method definitions for class CUniformJournalSampling
	 */
	
	/**
	* CUniformJournalSampling::GetVariableName - returns the name of the recorded variable.
	* @return Path or name.
	*/
	std::string CUniformJournalSampling::GetVariableName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UniformJournalSampling_GetVariableName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_UniformJournalSampling_GetVariableName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CUniformJournalSampling::GetNumberOfSamples - Returns the number of samples in the interval.
	* @return Number of samples in the sampling.
	*/
	LibMCEnv_uint32 CUniformJournalSampling::GetNumberOfSamples()
	{
		LibMCEnv_uint32 resultNumberOfSamples = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UniformJournalSampling_GetNumberOfSamples(m_pHandle, &resultNumberOfSamples));
		
		return resultNumberOfSamples;
	}
	
	/**
	* CUniformJournalSampling::GetStartTimeStamp - Returns the beginning time stamp of the available data point.
	* @return Start Timestamp of Recording in microseconds.
	*/
	LibMCEnv_uint64 CUniformJournalSampling::GetStartTimeStamp()
	{
		LibMCEnv_uint64 resultStartTimeStampInMicroSeconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UniformJournalSampling_GetStartTimeStamp(m_pHandle, &resultStartTimeStampInMicroSeconds));
		
		return resultStartTimeStampInMicroSeconds;
	}
	
	/**
	* CUniformJournalSampling::GetEndTimeStamp - Returns the beginning time stamp of the available data point.
	* @return End Timestamp of Recording in microseconds.
	*/
	LibMCEnv_uint64 CUniformJournalSampling::GetEndTimeStamp()
	{
		LibMCEnv_uint64 resultEndTimeStampInMicroSeconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UniformJournalSampling_GetEndTimeStamp(m_pHandle, &resultEndTimeStampInMicroSeconds));
		
		return resultEndTimeStampInMicroSeconds;
	}
	
	/**
	* CUniformJournalSampling::GetSample - Returns the timestamp and value of the given sample.
	* @param[in] nIndex - Index of the sample. 0-based. MUST be smaller than NumberOfSamples.
	* @param[out] nTimeStamp - TimeStamp of the sample in MicroSeconds.
	* @param[out] dValue - Value of the sample in ms.
	*/
	void CUniformJournalSampling::GetSample(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 & nTimeStamp, LibMCEnv_double & dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UniformJournalSampling_GetSample(m_pHandle, nIndex, &nTimeStamp, &dValue));
	}
	
	/**
	* CUniformJournalSampling::GetAllSamples - Returns all timestamps and values of the sampling.
	* @param[out] SamplesBuffer - Array of Timestream entries, in increasing order.
	*/
	void CUniformJournalSampling::GetAllSamples(std::vector<sTimeStreamEntry> & SamplesBuffer)
	{
		LibMCEnv_uint64 elementsNeededSamples = 0;
		LibMCEnv_uint64 elementsWrittenSamples = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UniformJournalSampling_GetAllSamples(m_pHandle, 0, &elementsNeededSamples, nullptr));
		SamplesBuffer.resize((size_t) elementsNeededSamples);
		CheckError(m_pWrapper->m_WrapperTable.m_UniformJournalSampling_GetAllSamples(m_pHandle, elementsNeededSamples, &elementsWrittenSamples, SamplesBuffer.data()));
	}
	
	/**
	 * Method definitions for class CJournalVariable
	 */
	
	/**
	* CJournalVariable::GetVariableName - returns the name of the recorded variable.
	* @return Path or name.
	*/
	std::string CJournalVariable::GetVariableName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_GetVariableName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_GetVariableName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CJournalVariable::GetStartTimeStamp - Returns the beginning time stamp of the available data point.
	* @return Start Timestamp of Recording in microseconds.
	*/
	LibMCEnv_uint64 CJournalVariable::GetStartTimeStamp()
	{
		LibMCEnv_uint64 resultRecordingStartInMicroSeconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_GetStartTimeStamp(m_pHandle, &resultRecordingStartInMicroSeconds));
		
		return resultRecordingStartInMicroSeconds;
	}
	
	/**
	* CJournalVariable::GetEndTimeStamp - Returns the beginning time stamp of the available data point.
	* @return End Timestamp of Recording in microseconds.
	*/
	LibMCEnv_uint64 CJournalVariable::GetEndTimeStamp()
	{
		LibMCEnv_uint64 resultRecordingEndInMicroSeconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_GetEndTimeStamp(m_pHandle, &resultRecordingEndInMicroSeconds));
		
		return resultRecordingEndInMicroSeconds;
	}
	
	/**
	* CJournalVariable::ComputeFullAverage - Calculates the average value over the full available time interval.
	* @return Average value of the variable.
	*/
	LibMCEnv_double CJournalVariable::ComputeFullAverage()
	{
		LibMCEnv_double resultAverageValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_ComputeFullAverage(m_pHandle, &resultAverageValue));
		
		return resultAverageValue;
	}
	
	/**
	* CJournalVariable::ComputeAverage - Calculates the average value over a time interval. Fails if no data is available in this time interval.
	* @param[in] nStartTimeInMicroSeconds - Start Timestamp of the interval in ms.
	* @param[in] nEndTimeInMicroSeconds - End Timestamp of the interval in ms. MUST be larger than Timestamp.
	* @param[in] bClampInterval - If ClampInterval is false, the Interval MUST be completely contained in the available recording time. If ClampInterval is false, the Interval will be reduced to the available recording time. If there is no overlap of the Interval with the Recording time at all, the call will fail.
	* @return Average value of the variable.
	*/
	LibMCEnv_double CJournalVariable::ComputeAverage(const LibMCEnv_uint64 nStartTimeInMicroSeconds, const LibMCEnv_uint64 nEndTimeInMicroSeconds, const bool bClampInterval)
	{
		LibMCEnv_double resultAverageValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_ComputeAverage(m_pHandle, nStartTimeInMicroSeconds, nEndTimeInMicroSeconds, bClampInterval, &resultAverageValue));
		
		return resultAverageValue;
	}
	
	/**
	* CJournalVariable::ComputeSample - Computes a single sample at a time. Fails if no data is available at this time value.
	* @param[in] nTimeInMicroSeconds - Timestamp to check.
	* @return Value of the variable at the time step.
	*/
	LibMCEnv_double CJournalVariable::ComputeSample(const LibMCEnv_uint64 nTimeInMicroSeconds)
	{
		LibMCEnv_double resultSampleValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_ComputeSample(m_pHandle, nTimeInMicroSeconds, &resultSampleValue));
		
		return resultSampleValue;
	}
	
	/**
	* CJournalVariable::ComputeUniformAverageSamples - Retrieves sample values for an interval. Interval MUST be inside the available recording time.
	* @param[in] nStartTimeInMicroSeconds - Start Timestamp of the interval in microseconds.
	* @param[in] nIntervalIncrement - Sampling interval distance in microseconds. MUST be larger than 0.
	* @param[in] nNumberOfSamples - Number of samples to record. NumberOfSamples times IntervalIncrement MUST be within the available recording time.
	* @param[in] dMovingAverageDelta - Each sample will be averaged from minus MovingAverageDelta to plus MovingAverageDelta.
	* @param[in] bClampInterval - If ClampInterval is false, each moving average interval MUST be completely contained in the available recording time. If ClampInterval is false, the moving average interval will be reduced to the available recording time. If there is no overlap of the Interval with the Recording time at all, the call will fail.
	* @return Returns an instance with the sampling results.
	*/
	PUniformJournalSampling CJournalVariable::ComputeUniformAverageSamples(const LibMCEnv_uint64 nStartTimeInMicroSeconds, const LibMCEnv_uint64 nIntervalIncrement, const LibMCEnv_uint32 nNumberOfSamples, const LibMCEnv_double dMovingAverageDelta, const bool bClampInterval)
	{
		LibMCEnvHandle hJournalSampling = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_ComputeUniformAverageSamples(m_pHandle, nStartTimeInMicroSeconds, nIntervalIncrement, nNumberOfSamples, dMovingAverageDelta, bClampInterval, &hJournalSampling));
		
		if (!hJournalSampling) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CUniformJournalSampling>(m_pWrapper, hJournalSampling);
	}
	
	/**
	* CJournalVariable::ComputeEquidistantSamples - Retrieves a number of equidistant sample values for an interval. Interval MUST be inside the available recording time.
	* @param[in] nStartTimeInMicroSeconds - Start Timestamp of the interval in microseconds.
	* @param[in] nIntervalIncrement - Sampling interval distance in microseconds. MUST be larger than 0.
	* @param[in] nNumberOfSamples - Number of samples to record. The Length of the Interval (StartTimeInMicroSeconds - EndTimeInMicroSeconds) MUST be a multiple of the Number of samples.
	* @return Returns an instance with the sampling results.
	*/
	PUniformJournalSampling CJournalVariable::ComputeEquidistantSamples(const LibMCEnv_uint64 nStartTimeInMicroSeconds, const LibMCEnv_uint64 nIntervalIncrement, const LibMCEnv_uint32 nNumberOfSamples)
	{
		LibMCEnvHandle hJournalSampling = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_ComputeEquidistantSamples(m_pHandle, nStartTimeInMicroSeconds, nIntervalIncrement, nNumberOfSamples, &hJournalSampling));
		
		if (!hJournalSampling) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CUniformJournalSampling>(m_pWrapper, hJournalSampling);
	}
	
	/**
	* CJournalVariable::ReceiveRawTimeStream - Retrieves the raw timestream data of the variable.
	* @param[out] TimeStreamEntriesBuffer - All change events of the variable in the accessed interval.
	*/
	void CJournalVariable::ReceiveRawTimeStream(std::vector<sTimeStreamEntry> & TimeStreamEntriesBuffer)
	{
		LibMCEnv_uint64 elementsNeededTimeStreamEntries = 0;
		LibMCEnv_uint64 elementsWrittenTimeStreamEntries = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_ReceiveRawTimeStream(m_pHandle, 0, &elementsNeededTimeStreamEntries, nullptr));
		TimeStreamEntriesBuffer.resize((size_t) elementsNeededTimeStreamEntries);
		CheckError(m_pWrapper->m_WrapperTable.m_JournalVariable_ReceiveRawTimeStream(m_pHandle, elementsNeededTimeStreamEntries, &elementsWrittenTimeStreamEntries, TimeStreamEntriesBuffer.data()));
	}
	
	/**
	 * Method definitions for class CAlert
	 */
	
	/**
	* CAlert::GetUUID - Returns Alert UUID.
	* @return Returns the alert uuid.
	*/
	std::string CAlert::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CAlert::IsActive - Returns if the alert is actuve.
	* @return Returns if the alert is active.
	*/
	bool CAlert::IsActive()
	{
		bool resultActive = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_IsActive(m_pHandle, &resultActive));
		
		return resultActive;
	}
	
	/**
	* CAlert::GetAlertLevel - Returns Alert Level.
	* @return Returns the alert level.
	*/
	eAlertLevel CAlert::GetAlertLevel()
	{
		eAlertLevel resultLevel = (eAlertLevel) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetAlertLevel(m_pHandle, &resultLevel));
		
		return resultLevel;
	}
	
	/**
	* CAlert::GetIdentifier - Returns Alert Identifier.
	* @return Returns the alert identifier.
	*/
	std::string CAlert::GetIdentifier()
	{
		LibMCEnv_uint32 bytesNeededIdentifier = 0;
		LibMCEnv_uint32 bytesWrittenIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetIdentifier(m_pHandle, 0, &bytesNeededIdentifier, nullptr));
		std::vector<char> bufferIdentifier(bytesNeededIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetIdentifier(m_pHandle, bytesNeededIdentifier, &bytesWrittenIdentifier, &bufferIdentifier[0]));
		
		return std::string(&bufferIdentifier[0]);
	}
	
	/**
	* CAlert::GetReadableContextInformation - Returns Alert Custom Information.
	* @return Returns context information for the alert.
	*/
	std::string CAlert::GetReadableContextInformation()
	{
		LibMCEnv_uint32 bytesNeededReadableContextInformation = 0;
		LibMCEnv_uint32 bytesWrittenReadableContextInformation = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetReadableContextInformation(m_pHandle, 0, &bytesNeededReadableContextInformation, nullptr));
		std::vector<char> bufferReadableContextInformation(bytesNeededReadableContextInformation);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetReadableContextInformation(m_pHandle, bytesNeededReadableContextInformation, &bytesWrittenReadableContextInformation, &bufferReadableContextInformation[0]));
		
		return std::string(&bufferReadableContextInformation[0]);
	}
	
	/**
	* CAlert::NeedsAcknowledgement - Returns if the alert needs acknowledgement.
	* @return Flag if alert needs acknowledgement.
	*/
	bool CAlert::NeedsAcknowledgement()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_NeedsAcknowledgement(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CAlert::HasBeenAcknowledged - Returns if the alert is acknowledged.
	* @return Flag if alert is acknowledged.
	*/
	bool CAlert::HasBeenAcknowledged()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_HasBeenAcknowledged(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CAlert::GetAcknowledgementInformation - Returns details about the acknowledgement. Fails if the alert is not acknowledged.
	* @param[out] sUserUUID - User who acknowledged the alert.
	* @param[out] sUserComment - Comment of the acknowledgement.
	* @param[out] sAckTime - Timestamp in ISO8601 UTC format.
	*/
	void CAlert::GetAcknowledgementInformation(std::string & sUserUUID, std::string & sUserComment, std::string & sAckTime)
	{
		LibMCEnv_uint32 bytesNeededUserUUID = 0;
		LibMCEnv_uint32 bytesWrittenUserUUID = 0;
		LibMCEnv_uint32 bytesNeededUserComment = 0;
		LibMCEnv_uint32 bytesWrittenUserComment = 0;
		LibMCEnv_uint32 bytesNeededAckTime = 0;
		LibMCEnv_uint32 bytesWrittenAckTime = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetAcknowledgementInformation(m_pHandle, 0, &bytesNeededUserUUID, nullptr, 0, &bytesNeededUserComment, nullptr, 0, &bytesNeededAckTime, nullptr));
		std::vector<char> bufferUserUUID(bytesNeededUserUUID);
		std::vector<char> bufferUserComment(bytesNeededUserComment);
		std::vector<char> bufferAckTime(bytesNeededAckTime);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetAcknowledgementInformation(m_pHandle, bytesNeededUserUUID, &bytesWrittenUserUUID, &bufferUserUUID[0], bytesNeededUserComment, &bytesWrittenUserComment, &bufferUserComment[0], bytesNeededAckTime, &bytesWrittenAckTime, &bufferAckTime[0]));
		sUserUUID = std::string(&bufferUserUUID[0]);
		sUserComment = std::string(&bufferUserComment[0]);
		sAckTime = std::string(&bufferAckTime[0]);
	}
	
	/**
	* CAlert::GetAcknowledgementTime - Returns the time stamp of the the acknowledgement. Fails if the alert is not acknowledged.
	* @return Timestamp Instance.
	*/
	PDateTime CAlert::GetAcknowledgementTime()
	{
		LibMCEnvHandle hAckTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetAcknowledgementTime(m_pHandle, &hAckTime));
		
		if (!hAckTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hAckTime);
	}
	
	/**
	* CAlert::AcknowledgeForUser - Acknowledges an alert for a specific user and sets it inactive. Fails if Alert is read from an archived journal.
	* @param[in] sUserUUID - UUID of the user to acknowledge. Fails if user does not exist.
	* @param[in] sUserComment - User comment to store. May be empty.
	*/
	void CAlert::AcknowledgeForUser(const std::string & sUserUUID, const std::string & sUserComment)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_AcknowledgeForUser(m_pHandle, sUserUUID.c_str(), sUserComment.c_str()));
	}
	
	/**
	* CAlert::AcknowledgeAlertForCurrentUser - Acknowledges an alert for the current user and sets it inactive. Only works if the Alert Instance was created from a UIEnvironment. StateEnvironments do not have login information. Fails if Alert is read from an archived journal.
	* @param[in] sUserComment - User comment to store. May be empty.
	*/
	void CAlert::AcknowledgeAlertForCurrentUser(const std::string & sUserComment)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_AcknowledgeAlertForCurrentUser(m_pHandle, sUserComment.c_str()));
	}
	
	/**
	* CAlert::DeactivateAlert - Sets an alert inactive. It will not be marked as acknowledged by a certain user. Fails if Alert is read from an archived journal.
	*/
	void CAlert::DeactivateAlert()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_DeactivateAlert(m_pHandle));
	}
	
	/**
	 * Method definitions for class CAlertIterator
	 */
	
	/**
	* CAlertIterator::GetCurrentAlert - Returns the alert the iterator points at.
	* @return returns the Alert instance.
	*/
	PAlert CAlertIterator::GetCurrentAlert()
	{
		LibMCEnvHandle hAlertInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_AlertIterator_GetCurrentAlert(m_pHandle, &hAlertInstance));
		
		if (!hAlertInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlert>(m_pWrapper, hAlertInstance);
	}
	
	/**
	 * Method definitions for class CLogEntryList
	 */
	
	/**
	* CLogEntryList::GetCount - Returns the number of log entries in the list.
	* @return Number of log entries.
	*/
	LibMCEnv_uint32 CLogEntryList::GetCount()
	{
		LibMCEnv_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CLogEntryList::GetEntry - Returns the a log entry of the list.
	* @param[in] nIndex - Index of entry to retrieve. 0-based. Fails if larger or equal to Count.
	* @param[out] sMessage - Message of the log entry.
	* @param[out] sSubSystem - Subsystem of the log entry.
	* @param[out] nLogID - ID of the log entry.
	* @param[out] eLogLevel - Level of the log entry.
	*/
	void CLogEntryList::GetEntry(const LibMCEnv_uint32 nIndex, std::string & sMessage, std::string & sSubSystem, LibMCEnv_uint32 & nLogID, eLogLevel & eLogLevel)
	{
		LibMCEnv_uint32 bytesNeededMessage = 0;
		LibMCEnv_uint32 bytesWrittenMessage = 0;
		LibMCEnv_uint32 bytesNeededSubSystem = 0;
		LibMCEnv_uint32 bytesWrittenSubSystem = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntry(m_pHandle, nIndex, 0, &bytesNeededMessage, nullptr, 0, &bytesNeededSubSystem, nullptr, &nLogID, &eLogLevel));
		std::vector<char> bufferMessage(bytesNeededMessage);
		std::vector<char> bufferSubSystem(bytesNeededSubSystem);
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntry(m_pHandle, nIndex, bytesNeededMessage, &bytesWrittenMessage, &bufferMessage[0], bytesNeededSubSystem, &bytesWrittenSubSystem, &bufferSubSystem[0], &nLogID, &eLogLevel));
		sMessage = std::string(&bufferMessage[0]);
		sSubSystem = std::string(&bufferSubSystem[0]);
	}
	
	/**
	* CLogEntryList::GetEntryTime - Returns the time stamp of an entry.
	* @param[in] nIndex - Index of entry to retrieve. 0-based. Fails if larger or equal to Count.
	* @return Date Time object of the entry.
	*/
	PDateTime CLogEntryList::GetEntryTime(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnvHandle hTimestamp = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntryTime(m_pHandle, nIndex, &hTimestamp));
		
		if (!hTimestamp) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hTimestamp);
	}
	
	/**
	 * Method definitions for class CJournalHandler
	 */
	
	/**
	* CJournalHandler::RetrieveJournalVariable - Retrieves the history of a given variable in the system journal.
	* @param[in] sVariableName - Variable name to analyse. Fails if Variable does not exist.
	* @param[in] nTimeDeltaInMicroseconds - How many microseconds the journal should be retrieved in the past.
	* @return Journal Instance.
	*/
	PJournalVariable CJournalHandler::RetrieveJournalVariable(const std::string & sVariableName, const LibMCEnv_uint64 nTimeDeltaInMicroseconds)
	{
		LibMCEnvHandle hJournalVariable = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalHandler_RetrieveJournalVariable(m_pHandle, sVariableName.c_str(), nTimeDeltaInMicroseconds, &hJournalVariable));
		
		if (!hJournalVariable) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CJournalVariable>(m_pWrapper, hJournalVariable);
	}
	
	/**
	* CJournalHandler::RetrieveJournalVariableFromTimeInterval - Retrieves the history of a given variable in the system journal for an arbitrary time interval.
	* @param[in] sVariableName - Variable name to analyse. Fails if Variable does not exist.
	* @param[in] nStartTimeInMicroseconds - Start time stamp in microseconds. MUST be smaller than EndTimeInMicroseconds. Fails if larger than recorded time interval.
	* @param[in] nEndTimeInMicroseconds - End time stamp in microseconds. MUST be larger than StartTimeInMicroseconds. Fails if larger than recorded time interval.
	* @return Journal Instance.
	*/
	PJournalVariable CJournalHandler::RetrieveJournalVariableFromTimeInterval(const std::string & sVariableName, const LibMCEnv_uint64 nStartTimeInMicroseconds, const LibMCEnv_uint64 nEndTimeInMicroseconds)
	{
		LibMCEnvHandle hJournalVariable = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalHandler_RetrieveJournalVariableFromTimeInterval(m_pHandle, sVariableName.c_str(), nStartTimeInMicroseconds, nEndTimeInMicroseconds, &hJournalVariable));
		
		if (!hJournalVariable) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CJournalVariable>(m_pWrapper, hJournalVariable);
	}
	
	/**
	* CJournalHandler::GetStartTime - Retrieves the reference start time of the journal.
	* @return DateTime Instance
	*/
	PDateTime CJournalHandler::GetStartTime()
	{
		LibMCEnvHandle hDateTimeInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalHandler_GetStartTime(m_pHandle, &hDateTimeInstance));
		
		if (!hDateTimeInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTimeInstance);
	}
	
	/**
	* CJournalHandler::RetrieveLogEntries - Retrieves the current log entries of the journal.
	* @param[in] nTimeDeltaInMicroseconds - How many microseconds the journal should be retrieved in the past.
	* @param[out] eMinLogLevel - Only entries with a log level that is higher than the given one are returned.
	* @return Log Entry Instance.
	*/
	PLogEntryList CJournalHandler::RetrieveLogEntries(const LibMCEnv_uint64 nTimeDeltaInMicroseconds, eLogLevel & eMinLogLevel)
	{
		LibMCEnvHandle hEntryList = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalHandler_RetrieveLogEntries(m_pHandle, nTimeDeltaInMicroseconds, &eMinLogLevel, &hEntryList));
		
		if (!hEntryList) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogEntryList>(m_pWrapper, hEntryList);
	}
	
	/**
	* CJournalHandler::RetrieveLogEntriesFromTimeInterval - Retrieves the log entries of the journal over the given time interval.
	* @param[in] nStartTimeInMicroseconds - Start time stamp in microseconds. MUST be smaller than EndTimeInMicroseconds. Fails if larger than recorded time interval.
	* @param[in] nEndTimeInMicroseconds - End time stamp in microseconds. MUST be larger than StartTimeInMicroseconds. Fails if larger than recorded time interval.
	* @param[out] eMinLogLevel - Only entries with a log level that is higher than the given one are returned.
	* @return Log Entry Instance.
	*/
	PLogEntryList CJournalHandler::RetrieveLogEntriesFromTimeInterval(const LibMCEnv_uint64 nStartTimeInMicroseconds, const LibMCEnv_uint64 nEndTimeInMicroseconds, eLogLevel & eMinLogLevel)
	{
		LibMCEnvHandle hEntryList = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalHandler_RetrieveLogEntriesFromTimeInterval(m_pHandle, nStartTimeInMicroseconds, nEndTimeInMicroseconds, &eMinLogLevel, &hEntryList));
		
		if (!hEntryList) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogEntryList>(m_pWrapper, hEntryList);
	}
	
	/**
	* CJournalHandler::RetrieveAlerts - Retrieves the alerts of the journal.
	* @param[in] nTimeDeltaInMicroseconds - How many microseconds the journal should be retrieved in the past.
	* @return Alert Iterator Instance.
	*/
	PAlertIterator CJournalHandler::RetrieveAlerts(const LibMCEnv_uint64 nTimeDeltaInMicroseconds)
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalHandler_RetrieveAlerts(m_pHandle, nTimeDeltaInMicroseconds, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlertIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CJournalHandler::RetrieveAlertsFromTimeInterval - Retrieves the alerts of the journal over the given time interval.
	* @param[in] nStartTimeInMicroseconds - Start time stamp in microseconds. MUST be smaller than EndTimeInMicroseconds. Fails if larger than recorded time interval.
	* @param[in] nEndTimeInMicroseconds - End time stamp in microseconds. MUST be larger than StartTimeInMicroseconds. Fails if larger than recorded time interval.
	* @return Alert Iterator Instance.
	*/
	PAlertIterator CJournalHandler::RetrieveAlertsFromTimeInterval(const LibMCEnv_uint64 nStartTimeInMicroseconds, const LibMCEnv_uint64 nEndTimeInMicroseconds)
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalHandler_RetrieveAlertsFromTimeInterval(m_pHandle, nStartTimeInMicroseconds, nEndTimeInMicroseconds, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlertIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	 * Method definitions for class CUserDetailList
	 */
	
	/**
	* CUserDetailList::Count - Result Number of Users in the list.
	* @return Number of users in the list
	*/
	LibMCEnv_uint32 CUserDetailList::Count()
	{
		LibMCEnv_uint32 resultUserCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_Count(m_pHandle, &resultUserCount));
		
		return resultUserCount;
	}
	
	/**
	* CUserDetailList::GetUserProperties - Retrieves all the data of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @param[out] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	void CUserDetailList::GetUserProperties(const LibMCEnv_uint32 nUserIndex, std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier)
	{
		LibMCEnv_uint32 bytesNeededUsername = 0;
		LibMCEnv_uint32 bytesWrittenUsername = 0;
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		LibMCEnv_uint32 bytesNeededDescription = 0;
		LibMCEnv_uint32 bytesWrittenDescription = 0;
		LibMCEnv_uint32 bytesNeededRole = 0;
		LibMCEnv_uint32 bytesWrittenRole = 0;
		LibMCEnv_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCEnv_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetUserProperties(m_pHandle, nUserIndex, 0, &bytesNeededUsername, nullptr, 0, &bytesNeededUUID, nullptr, 0, &bytesNeededDescription, nullptr, 0, &bytesNeededRole, nullptr, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		std::vector<char> bufferUUID(bytesNeededUUID);
		std::vector<char> bufferDescription(bytesNeededDescription);
		std::vector<char> bufferRole(bytesNeededRole);
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetUserProperties(m_pHandle, nUserIndex, bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0], bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0], bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], bytesNeededRole, &bytesWrittenRole, &bufferRole[0], bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		sUsername = std::string(&bufferUsername[0]);
		sUUID = std::string(&bufferUUID[0]);
		sDescription = std::string(&bufferDescription[0]);
		sRole = std::string(&bufferRole[0]);
		sLanguageIdentifier = std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CUserDetailList::GetUsername - Retrieves the user name of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return User name
	*/
	std::string CUserDetailList::GetUsername(const LibMCEnv_uint32 nUserIndex)
	{
		LibMCEnv_uint32 bytesNeededUsername = 0;
		LibMCEnv_uint32 bytesWrittenUsername = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetUsername(m_pHandle, nUserIndex, 0, &bytesNeededUsername, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetUsername(m_pHandle, nUserIndex, bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0]));
		
		return std::string(&bufferUsername[0]);
	}
	
	/**
	* CUserDetailList::GetUUID - Retrieves the UUID of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return UUID of the user.
	*/
	std::string CUserDetailList::GetUUID(const LibMCEnv_uint32 nUserIndex)
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetUUID(m_pHandle, nUserIndex, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetUUID(m_pHandle, nUserIndex, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CUserDetailList::GetDescription - Retrieves the description of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return Description of the user.
	*/
	std::string CUserDetailList::GetDescription(const LibMCEnv_uint32 nUserIndex)
	{
		LibMCEnv_uint32 bytesNeededDescription = 0;
		LibMCEnv_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetDescription(m_pHandle, nUserIndex, 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetDescription(m_pHandle, nUserIndex, bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CUserDetailList::GetRole - Retrieves the role of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return Role of the user.
	*/
	std::string CUserDetailList::GetRole(const LibMCEnv_uint32 nUserIndex)
	{
		LibMCEnv_uint32 bytesNeededRole = 0;
		LibMCEnv_uint32 bytesWrittenRole = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetRole(m_pHandle, nUserIndex, 0, &bytesNeededRole, nullptr));
		std::vector<char> bufferRole(bytesNeededRole);
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetRole(m_pHandle, nUserIndex, bytesNeededRole, &bytesWrittenRole, &bufferRole[0]));
		
		return std::string(&bufferRole[0]);
	}
	
	/**
	* CUserDetailList::GetLanguage - Retrieves the language identifier of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return Language Identifier of the user.
	*/
	std::string CUserDetailList::GetLanguage(const LibMCEnv_uint32 nUserIndex)
	{
		LibMCEnv_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCEnv_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetLanguage(m_pHandle, nUserIndex, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_UserDetailList_GetLanguage(m_pHandle, nUserIndex, bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		
		return std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	 * Method definitions for class CUserManagementHandler
	 */
	
	/**
	* CUserManagementHandler::UserExists - Checks if a user exist.
	* @param[in] sUsername - User name
	* @return Flag if users exists
	*/
	bool CUserManagementHandler::UserExists(const std::string & sUsername)
	{
		bool resultUserExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_UserExists(m_pHandle, sUsername.c_str(), &resultUserExists));
		
		return resultUserExists;
	}
	
	/**
	* CUserManagementHandler::UserUUIDExists - Checks if a user uuid exist.
	* @param[in] sUUID - UUID of the user.
	* @return Flag if users exists
	*/
	bool CUserManagementHandler::UserUUIDExists(const std::string & sUUID)
	{
		bool resultUserExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_UserUUIDExists(m_pHandle, sUUID.c_str(), &resultUserExists));
		
		return resultUserExists;
	}
	
	/**
	* CUserManagementHandler::GetUserProperties - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	void CUserManagementHandler::GetUserProperties(const std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier)
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		LibMCEnv_uint32 bytesNeededDescription = 0;
		LibMCEnv_uint32 bytesWrittenDescription = 0;
		LibMCEnv_uint32 bytesNeededRole = 0;
		LibMCEnv_uint32 bytesWrittenRole = 0;
		LibMCEnv_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCEnv_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserProperties(m_pHandle, sUsername.c_str(), 0, &bytesNeededUUID, nullptr, 0, &bytesNeededDescription, nullptr, 0, &bytesNeededRole, nullptr, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		std::vector<char> bufferDescription(bytesNeededDescription);
		std::vector<char> bufferRole(bytesNeededRole);
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserProperties(m_pHandle, sUsername.c_str(), bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0], bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], bytesNeededRole, &bytesWrittenRole, &bufferRole[0], bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		sUUID = std::string(&bufferUUID[0]);
		sDescription = std::string(&bufferDescription[0]);
		sRole = std::string(&bufferRole[0]);
		sLanguageIdentifier = std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CUserManagementHandler::GetUserPropertiesByUUID - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[out] sUsername - User name
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	void CUserManagementHandler::GetUserPropertiesByUUID(const std::string & sUUID, std::string & sUsername, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier)
	{
		LibMCEnv_uint32 bytesNeededUsername = 0;
		LibMCEnv_uint32 bytesWrittenUsername = 0;
		LibMCEnv_uint32 bytesNeededDescription = 0;
		LibMCEnv_uint32 bytesWrittenDescription = 0;
		LibMCEnv_uint32 bytesNeededRole = 0;
		LibMCEnv_uint32 bytesWrittenRole = 0;
		LibMCEnv_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCEnv_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserPropertiesByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededUsername, nullptr, 0, &bytesNeededDescription, nullptr, 0, &bytesNeededRole, nullptr, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		std::vector<char> bufferDescription(bytesNeededDescription);
		std::vector<char> bufferRole(bytesNeededRole);
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserPropertiesByUUID(m_pHandle, sUUID.c_str(), bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0], bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], bytesNeededRole, &bytesWrittenRole, &bufferRole[0], bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		sUsername = std::string(&bufferUsername[0]);
		sDescription = std::string(&bufferDescription[0]);
		sRole = std::string(&bufferRole[0]);
		sLanguageIdentifier = std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CUserManagementHandler::GetUsernameByUUID - Retrieves a users name with a given UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return User name
	*/
	std::string CUserManagementHandler::GetUsernameByUUID(const std::string & sUUID)
	{
		LibMCEnv_uint32 bytesNeededUsername = 0;
		LibMCEnv_uint32 bytesWrittenUsername = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUsernameByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededUsername, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUsernameByUUID(m_pHandle, sUUID.c_str(), bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0]));
		
		return std::string(&bufferUsername[0]);
	}
	
	/**
	* CUserManagementHandler::GetUserUUID - Retrieves a users UUID. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return UUID of the user.
	*/
	std::string CUserManagementHandler::GetUserUUID(const std::string & sUsername)
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserUUID(m_pHandle, sUsername.c_str(), 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserUUID(m_pHandle, sUsername.c_str(), bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CUserManagementHandler::GetUserDescription - Retrieves a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Description of the user.
	*/
	std::string CUserManagementHandler::GetUserDescription(const std::string & sUsername)
	{
		LibMCEnv_uint32 bytesNeededDescription = 0;
		LibMCEnv_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserDescription(m_pHandle, sUsername.c_str(), 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserDescription(m_pHandle, sUsername.c_str(), bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CUserManagementHandler::GetUserDescriptionByUUID - Retrieves a users description by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Description of the user.
	*/
	std::string CUserManagementHandler::GetUserDescriptionByUUID(const std::string & sUUID)
	{
		LibMCEnv_uint32 bytesNeededDescription = 0;
		LibMCEnv_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserDescriptionByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserDescriptionByUUID(m_pHandle, sUUID.c_str(), bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CUserManagementHandler::GetUserRole - Retrieves a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Role of the user.
	*/
	std::string CUserManagementHandler::GetUserRole(const std::string & sUsername)
	{
		LibMCEnv_uint32 bytesNeededRole = 0;
		LibMCEnv_uint32 bytesWrittenRole = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserRole(m_pHandle, sUsername.c_str(), 0, &bytesNeededRole, nullptr));
		std::vector<char> bufferRole(bytesNeededRole);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserRole(m_pHandle, sUsername.c_str(), bytesNeededRole, &bytesWrittenRole, &bufferRole[0]));
		
		return std::string(&bufferRole[0]);
	}
	
	/**
	* CUserManagementHandler::GetUserRoleByUUID - Retrieves a users role by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Role of the user.
	*/
	std::string CUserManagementHandler::GetUserRoleByUUID(const std::string & sUUID)
	{
		LibMCEnv_uint32 bytesNeededRole = 0;
		LibMCEnv_uint32 bytesWrittenRole = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserRoleByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededRole, nullptr));
		std::vector<char> bufferRole(bytesNeededRole);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserRoleByUUID(m_pHandle, sUUID.c_str(), bytesNeededRole, &bytesWrittenRole, &bufferRole[0]));
		
		return std::string(&bufferRole[0]);
	}
	
	/**
	* CUserManagementHandler::GetUserLanguage - Retrieves a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Language identifier of the user.
	*/
	std::string CUserManagementHandler::GetUserLanguage(const std::string & sUsername)
	{
		LibMCEnv_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCEnv_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserLanguage(m_pHandle, sUsername.c_str(), 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserLanguage(m_pHandle, sUsername.c_str(), bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		
		return std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CUserManagementHandler::GetUserLanguageByUUID - Retrieves a users language preference by user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Language identifier of the user.
	*/
	std::string CUserManagementHandler::GetUserLanguageByUUID(const std::string & sUUID)
	{
		LibMCEnv_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCEnv_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserLanguageByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetUserLanguageByUUID(m_pHandle, sUUID.c_str(), bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		
		return std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CUserManagementHandler::CreateUser - Creates a new user. Fails if the user already exists.
	* @param[in] sUsername - User name to create. MUST be alphanumeric and not empty.
	* @param[in] sRole - Role of the new user. MUST NOT be empty.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	* @param[in] sDescription - Description of the new user.
	* @return UUID of the new user.
	*/
	std::string CUserManagementHandler::CreateUser(const std::string & sUsername, const std::string & sRole, const std::string & sSalt, const std::string & sHashedPassword, const std::string & sDescription)
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_CreateUser(m_pHandle, sUsername.c_str(), sRole.c_str(), sSalt.c_str(), sHashedPassword.c_str(), sDescription.c_str(), 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_CreateUser(m_pHandle, sUsername.c_str(), sRole.c_str(), sSalt.c_str(), sHashedPassword.c_str(), sDescription.c_str(), bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CUserManagementHandler::SetUserLanguage - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	void CUserManagementHandler::SetUserLanguage(const std::string & sUsername, const std::string & sLanguageIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_SetUserLanguage(m_pHandle, sUsername.c_str(), sLanguageIdentifier.c_str()));
	}
	
	/**
	* CUserManagementHandler::SetUserRole - Updates a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sUserRole - New Role identifier of the user.
	*/
	void CUserManagementHandler::SetUserRole(const std::string & sUsername, const std::string & sUserRole)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_SetUserRole(m_pHandle, sUsername.c_str(), sUserRole.c_str()));
	}
	
	/**
	* CUserManagementHandler::SetUserDescription - Updates a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sDescription - New Description of the user.
	*/
	void CUserManagementHandler::SetUserDescription(const std::string & sUsername, const std::string & sDescription)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_SetUserDescription(m_pHandle, sUsername.c_str(), sDescription.c_str()));
	}
	
	/**
	* CUserManagementHandler::SetUserPassword - Updates a users password. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	void CUserManagementHandler::SetUserPassword(const std::string & sUsername, const std::string & sSalt, const std::string & sHashedPassword)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_SetUserPassword(m_pHandle, sUsername.c_str(), sSalt.c_str(), sHashedPassword.c_str()));
	}
	
	/**
	* CUserManagementHandler::SetUserLanguageByUUID - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	void CUserManagementHandler::SetUserLanguageByUUID(const std::string & sUUID, const std::string & sLanguageIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_SetUserLanguageByUUID(m_pHandle, sUUID.c_str(), sLanguageIdentifier.c_str()));
	}
	
	/**
	* CUserManagementHandler::SetUserRoleByUUID - Updates a users role. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sUserRole - New Role identifier of the user.
	*/
	void CUserManagementHandler::SetUserRoleByUUID(const std::string & sUUID, const std::string & sUserRole)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_SetUserRoleByUUID(m_pHandle, sUUID.c_str(), sUserRole.c_str()));
	}
	
	/**
	* CUserManagementHandler::SetUserDescriptionByUUID - Updates a users description. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sDescription - New Description identifier of the user.
	*/
	void CUserManagementHandler::SetUserDescriptionByUUID(const std::string & sUUID, const std::string & sDescription)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_SetUserDescriptionByUUID(m_pHandle, sUUID.c_str(), sDescription.c_str()));
	}
	
	/**
	* CUserManagementHandler::SetUserPasswordByUUID - Updates a users password. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	void CUserManagementHandler::SetUserPasswordByUUID(const std::string & sUUID, const std::string & sSalt, const std::string & sHashedPassword)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_SetUserPasswordByUUID(m_pHandle, sUUID.c_str(), sSalt.c_str(), sHashedPassword.c_str()));
	}
	
	/**
	* CUserManagementHandler::GetActiveUsers - Returns a list of all users.
	* @return Instance of active users.
	*/
	PUserDetailList CUserManagementHandler::GetActiveUsers()
	{
		LibMCEnvHandle hListInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UserManagementHandler_GetActiveUsers(m_pHandle, &hListInstance));
		
		if (!hListInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CUserDetailList>(m_pWrapper, hListInstance);
	}
	
	/**
	 * Method definitions for class CStateEnvironment
	 */
	
	/**
	* CStateEnvironment::GetMachineState - Retrieves the machine state
	* @param[in] sMachineInstance - State machine instance name
	* @return Name of current state
	*/
	std::string CStateEnvironment::GetMachineState(const std::string & sMachineInstance)
	{
		LibMCEnv_uint32 bytesNeededStateName = 0;
		LibMCEnv_uint32 bytesWrittenStateName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetMachineState(m_pHandle, sMachineInstance.c_str(), 0, &bytesNeededStateName, nullptr));
		std::vector<char> bufferStateName(bytesNeededStateName);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetMachineState(m_pHandle, sMachineInstance.c_str(), bytesNeededStateName, &bytesWrittenStateName, &bufferStateName[0]));
		
		return std::string(&bufferStateName[0]);
	}
	
	/**
	* CStateEnvironment::GetPreviousState - Retrieves the previous state before this execution. Returns the init state name, if called during the first state during runtime.
	* @return Name of previous state
	*/
	std::string CStateEnvironment::GetPreviousState()
	{
		LibMCEnv_uint32 bytesNeededStateName = 0;
		LibMCEnv_uint32 bytesWrittenStateName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetPreviousState(m_pHandle, 0, &bytesNeededStateName, nullptr));
		std::vector<char> bufferStateName(bytesNeededStateName);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetPreviousState(m_pHandle, bytesNeededStateName, &bytesWrittenStateName, &bufferStateName[0]));
		
		return std::string(&bufferStateName[0]);
	}
	
	/**
	* CStateEnvironment::PrepareSignal - prepares a signal object to trigger later.
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sSignalName - Name Of signal channel.
	* @return Signal trigger object.
	*/
	PSignalTrigger CStateEnvironment::PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName)
	{
		LibMCEnvHandle hSignalInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_PrepareSignal(m_pHandle, sMachineInstance.c_str(), sSignalName.c_str(), &hSignalInstance));
		
		if (!hSignalInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSignalTrigger>(m_pWrapper, hSignalInstance);
	}
	
	/**
	* CStateEnvironment::WaitForSignal - Waits for a signal for a certain amount of time.
	* @param[in] sSignalName - Name Of Signal
	* @param[in] nTimeOut - Timeout in Milliseconds. 0 for Immediate return.
	* @param[out] pHandlerInstance - Signal object. If Success is false, the Signal Handler Object will be null.
	* @return Signal has been triggered
	*/
	bool CStateEnvironment::WaitForSignal(const std::string & sSignalName, const LibMCEnv_uint32 nTimeOut, PSignalHandler & pHandlerInstance)
	{
		LibMCEnvHandle hHandlerInstance = nullptr;
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_WaitForSignal(m_pHandle, sSignalName.c_str(), nTimeOut, &hHandlerInstance, &resultSuccess));
		if (hHandlerInstance) {
			pHandlerInstance = std::make_shared<CSignalHandler>(m_pWrapper, hHandlerInstance);
		} else {
			pHandlerInstance = nullptr;
		}
		
		return resultSuccess;
	}
	
	/**
	* CStateEnvironment::GetUnhandledSignal - Retrieves an unhandled signal By signal type name.
	* @param[in] sSignalTypeName - Name Of Signal to be returned
	* @return Signal object. If no signal has been found the signal handler object will be null.
	*/
	PSignalHandler CStateEnvironment::GetUnhandledSignal(const std::string & sSignalTypeName)
	{
		LibMCEnvHandle hHandlerInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetUnhandledSignal(m_pHandle, sSignalTypeName.c_str(), &hHandlerInstance));
		
		if (hHandlerInstance) {
			return std::make_shared<CSignalHandler>(m_pWrapper, hHandlerInstance);
		} else {
			return nullptr;
		}
	}
	
	/**
	* CStateEnvironment::GetUnhandledSignalByUUID - retrieves an unhandled signal from the current state machine by UUID.
	* @param[in] sUUID - Name
	* @param[in] bMustExist - The call fails if MustExist is true and not signal with UUID does exist or a signal with UUID has been handled already.
	* @return Signal handler instance. Returns null, if signal does not exist.
	*/
	PSignalHandler CStateEnvironment::GetUnhandledSignalByUUID(const std::string & sUUID, const bool bMustExist)
	{
		LibMCEnvHandle hHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetUnhandledSignalByUUID(m_pHandle, sUUID.c_str(), bMustExist, &hHandler));
		
		if (hHandler) {
			return std::make_shared<CSignalHandler>(m_pWrapper, hHandler);
		} else {
			return nullptr;
		}
	}
	
	/**
	* CStateEnvironment::GetDriverLibrary - Returns the driver type and library lookup for a specific registered driver.
	* @param[in] sDriverName - Name identifier of the driver.
	* @param[out] sDriverType - returns type identifier of the driver.
	* @param[out] pDriverLookup - GetProcAddress Handle of the driver.
	*/
	void CStateEnvironment::GetDriverLibrary(const std::string & sDriverName, std::string & sDriverType, LibMCEnv_pvoid & pDriverLookup)
	{
		LibMCEnv_uint32 bytesNeededDriverType = 0;
		LibMCEnv_uint32 bytesWrittenDriverType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetDriverLibrary(m_pHandle, sDriverName.c_str(), 0, &bytesNeededDriverType, nullptr, &pDriverLookup));
		std::vector<char> bufferDriverType(bytesNeededDriverType);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetDriverLibrary(m_pHandle, sDriverName.c_str(), bytesNeededDriverType, &bytesWrittenDriverType, &bufferDriverType[0], &pDriverLookup));
		sDriverType = std::string(&bufferDriverType[0]);
	}
	
	/**
	* CStateEnvironment::CreateDriverAccess - Accesses and locks a driver for the execution of the current state.
	* @param[in] sDriverName - Name identifier of the driver.
	* @param[out] pDriverHandle - Handle of the driver.
	*/
	void CStateEnvironment::CreateDriverAccess(const std::string & sDriverName, LibMCEnv_pvoid & pDriverHandle)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateDriverAccess(m_pHandle, sDriverName.c_str(), &pDriverHandle));
	}
	
	/**
	* CStateEnvironment::HasBuildJob - Returns if a build object exists. Fails if BuildUUID is not a valid UUID string.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Returns true if build exists
	*/
	bool CStateEnvironment::HasBuildJob(const std::string & sBuildUUID)
	{
		bool resultBuildExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_HasBuildJob(m_pHandle, sBuildUUID.c_str(), &resultBuildExists));
		
		return resultBuildExists;
	}
	
	/**
	* CStateEnvironment::GetBuildJob - Returns a instance of a build object. Fails if build uuid does not exist.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	PBuild CStateEnvironment::GetBuildJob(const std::string & sBuildUUID)
	{
		LibMCEnvHandle hBuildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetBuildJob(m_pHandle, sBuildUUID.c_str(), &hBuildInstance));
		
		if (!hBuildInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuild>(m_pWrapper, hBuildInstance);
	}
	
	/**
	* CStateEnvironment::HasBuildExecution - Returns if a build execution exists. Fails if ExecutionUUID is not a valid UUID string.
	* @param[in] sExecutionUUID - UUID of the execution entity.
	* @return Returns true if execution exists
	*/
	bool CStateEnvironment::HasBuildExecution(const std::string & sExecutionUUID)
	{
		bool resultExecutionExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_HasBuildExecution(m_pHandle, sExecutionUUID.c_str(), &resultExecutionExists));
		
		return resultExecutionExists;
	}
	
	/**
	* CStateEnvironment::GetBuildExecution - Returns a instance of a build execution object. Fails if build execution uuid does not exist.
	* @param[in] sExecutionUUID - UUID of the execution entity.
	* @return Build execution instance
	*/
	PBuildExecution CStateEnvironment::GetBuildExecution(const std::string & sExecutionUUID)
	{
		LibMCEnvHandle hExecutionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetBuildExecution(m_pHandle, sExecutionUUID.c_str(), &hExecutionInstance));
		
		if (!hExecutionInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildExecution>(m_pWrapper, hExecutionInstance);
	}
	
	/**
	* CStateEnvironment::UnloadAllToolpathes - unloads all toolpath in memory to clean up
	*/
	void CStateEnvironment::UnloadAllToolpathes()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_UnloadAllToolpathes(m_pHandle));
	}
	
	/**
	* CStateEnvironment::SetNextState - sets the next state
	* @param[in] sStateName - Name of next state
	*/
	void CStateEnvironment::SetNextState(const std::string & sStateName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetNextState(m_pHandle, sStateName.c_str()));
	}
	
	/**
	* CStateEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	void CStateEnvironment::LogMessage(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LogMessage(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CStateEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	void CStateEnvironment::LogWarning(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LogWarning(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CStateEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	void CStateEnvironment::LogInfo(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LogInfo(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CStateEnvironment::Sleep - Puts the current instance to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	void CStateEnvironment::Sleep(const LibMCEnv_uint32 nDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_Sleep(m_pHandle, nDelay));
	}
	
	/**
	* CStateEnvironment::CheckForTermination - checks environment for termination signal. MUST be called frequently in longer-running operations.
	* @return Returns if termination shall appear
	*/
	bool CStateEnvironment::CheckForTermination()
	{
		bool resultShallTerminate = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CheckForTermination(m_pHandle, &resultShallTerminate));
		
		return resultShallTerminate;
	}
	
	/**
	* CStateEnvironment::StoreSignal - DEPRECIATED: stores a signal handler in the current state machine
	* @param[in] sName - Name
	* @param[in] pHandler - Signal handler to store.
	*/
	void CStateEnvironment::StoreSignal(const std::string & sName, classParam<CSignalHandler> pHandler)
	{
		LibMCEnvHandle hHandler = pHandler.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_StoreSignal(m_pHandle, sName.c_str(), hHandler));
	}
	
	/**
	* CStateEnvironment::RetrieveSignal - DEPRECIATED: retrieves a signal handler from the current state machine. Fails if value has not been stored before or signal has been already handled.
	* @param[in] sName - Name
	* @return Signal handler instance.
	*/
	PSignalHandler CStateEnvironment::RetrieveSignal(const std::string & sName)
	{
		LibMCEnvHandle hHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_RetrieveSignal(m_pHandle, sName.c_str(), &hHandler));
		
		if (!hHandler) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSignalHandler>(m_pWrapper, hHandler);
	}
	
	/**
	* CStateEnvironment::ClearStoredValue - DEPRECIATED: deletes a value from the data store.
	* @param[in] sName - Name
	*/
	void CStateEnvironment::ClearStoredValue(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_ClearStoredValue(m_pHandle, sName.c_str()));
	}
	
	/**
	* CStateEnvironment::SetStringParameter - sets a string parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CStateEnvironment::SetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetStringParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CStateEnvironment::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CStateEnvironment::SetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetUUIDParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CStateEnvironment::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	void CStateEnvironment::SetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetDoubleParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), dValue));
	}
	
	/**
	* CStateEnvironment::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	void CStateEnvironment::SetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetIntegerParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), nValue));
	}
	
	/**
	* CStateEnvironment::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	void CStateEnvironment::SetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetBoolParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), bValue));
	}
	
	/**
	* CStateEnvironment::GetStringParameter - returns a string parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	std::string CStateEnvironment::GetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetStringParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetStringParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CStateEnvironment::GetUUIDParameter - returns a uuid parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	std::string CStateEnvironment::GetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetUUIDParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetUUIDParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CStateEnvironment::GetDoubleParameter - returns a double parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	LibMCEnv_double CStateEnvironment::GetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetDoubleParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CStateEnvironment::GetIntegerParameter - returns an int parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	LibMCEnv_int64 CStateEnvironment::GetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetIntegerParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CStateEnvironment::GetBoolParameter - returns a bool parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	bool CStateEnvironment::GetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetBoolParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CStateEnvironment::LoadResourceData - loads a plugin resource file into memory.
	* @param[in] sResourceName - Name of the resource.
	* @param[out] ResourceDataBuffer - Resource Data Buffer.
	*/
	void CStateEnvironment::LoadResourceData(const std::string & sResourceName, std::vector<LibMCEnv_uint8> & ResourceDataBuffer)
	{
		LibMCEnv_uint64 elementsNeededResourceData = 0;
		LibMCEnv_uint64 elementsWrittenResourceData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LoadResourceData(m_pHandle, sResourceName.c_str(), 0, &elementsNeededResourceData, nullptr));
		ResourceDataBuffer.resize((size_t) elementsNeededResourceData);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LoadResourceData(m_pHandle, sResourceName.c_str(), elementsNeededResourceData, &elementsWrittenResourceData, ResourceDataBuffer.data()));
	}
	
	/**
	* CStateEnvironment::LoadResourceString - loads a plugin resource file into a string. Fails if content is not a valid UTF8 string.
	* @param[in] sResourceName - Name of the resource.
	* @return Resource Data String.
	*/
	std::string CStateEnvironment::LoadResourceString(const std::string & sResourceName)
	{
		LibMCEnv_uint32 bytesNeededResourceData = 0;
		LibMCEnv_uint32 bytesWrittenResourceData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LoadResourceString(m_pHandle, sResourceName.c_str(), 0, &bytesNeededResourceData, nullptr));
		std::vector<char> bufferResourceData(bytesNeededResourceData);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LoadResourceString(m_pHandle, sResourceName.c_str(), bytesNeededResourceData, &bytesWrittenResourceData, &bufferResourceData[0]));
		
		return std::string(&bufferResourceData[0]);
	}
	
	/**
	* CStateEnvironment::CreateEmptyImage - creates an empty image object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use.
	* @return Empty image instance.
	*/
	PImageData CStateEnvironment::CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateEmptyImage(m_pHandle, nPixelSizeX, nPixelSizeY, dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CStateEnvironment::LoadPNGImage - creates an image object from a PNG data stream.
	* @param[in] PNGDataBuffer - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image instance containing the PNG image.
	*/
	PImageData CStateEnvironment::LoadPNGImage(const CInputVector<LibMCEnv_uint8> & PNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LoadPNGImage(m_pHandle, (LibMCEnv_uint64)PNGDataBuffer.size(), PNGDataBuffer.data(), dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CStateEnvironment::CreateDiscreteField2D - Creates an empty discrete field.
	* @param[in] nPixelCountX - Pixel count in X. MUST be positive.
	* @param[in] nPixelCountY - Pixel count in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @param[in] dDefaultValue - Default value of the field.
	* @return Empty field instance.
	*/
	PDiscreteFieldData2D CStateEnvironment::CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue)
	{
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateDiscreteField2D(m_pHandle, nPixelCountX, nPixelCountY, dDPIValueX, dDPIValueY, dOriginX, dOriginY, dDefaultValue, &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CStateEnvironment::CreateDiscreteField2DFromImage - Creates a discrete field from the greyscale values of an image. RGB colors in the image will be averaged to obtain a greyscale color.
	* @param[in] pImageDataInstance - Image instance containing the pixel data.
	* @param[in] dBlackValue - Value that the minimum color (black) shall be mapped to.
	* @param[in] dWhiteValue - Value that the maximum color (white) shall be mapped to.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @return Empty field instance.
	*/
	PDiscreteFieldData2D CStateEnvironment::CreateDiscreteField2DFromImage(classParam<CImageData> pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY)
	{
		LibMCEnvHandle hImageDataInstance = pImageDataInstance.GetHandle();
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateDiscreteField2DFromImage(m_pHandle, hImageDataInstance, dBlackValue, dWhiteValue, dOriginX, dOriginY, &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CStateEnvironment::GetGlobalTimerInMilliseconds - Returns the global timer in milliseconds.
	* @return Timer value in Milliseconds
	*/
	LibMCEnv_uint64 CStateEnvironment::GetGlobalTimerInMilliseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetGlobalTimerInMilliseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CStateEnvironment::GetGlobalTimerInMicroseconds - Returns the global timer in microseconds.
	* @return Timer value in Microseconds
	*/
	LibMCEnv_uint64 CStateEnvironment::GetGlobalTimerInMicroseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetGlobalTimerInMicroseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CStateEnvironment::GetStartTimeOfStateInMilliseconds - Returns the global start timer of the current state in milliseconds.
	* @return Timer value in Milliseconds
	*/
	LibMCEnv_uint64 CStateEnvironment::GetStartTimeOfStateInMilliseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetStartTimeOfStateInMilliseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CStateEnvironment::GetStartTimeOfStateInMicroseconds - Returns the global start timer of the current state in microseconds.
	* @return Timer value in Milliseconds
	*/
	LibMCEnv_uint64 CStateEnvironment::GetStartTimeOfStateInMicroseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetStartTimeOfStateInMicroseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CStateEnvironment::GetEndTimeOfPreviousStateInMicroseconds - Returns the global finish timer of the previous state in microseconds.
	* @return Timer value in Microseconds
	*/
	LibMCEnv_uint64 CStateEnvironment::GetEndTimeOfPreviousStateInMicroseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetEndTimeOfPreviousStateInMicroseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CStateEnvironment::GetEndTimeOfPreviousStateInMilliseconds - Returns the global finish timer of the previous state in milliseconds.
	* @return Timer value in Milliseconds
	*/
	LibMCEnv_uint64 CStateEnvironment::GetEndTimeOfPreviousStateInMilliseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetEndTimeOfPreviousStateInMilliseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CStateEnvironment::GetElapsedTimeInStateInMilliseconds - Returns the global finish timer of the previous state in milliseconds.
	* @return Timer value in Milliseconds
	*/
	LibMCEnv_uint64 CStateEnvironment::GetElapsedTimeInStateInMilliseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetElapsedTimeInStateInMilliseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CStateEnvironment::GetElapsedTimeInStateInMicroseconds - Returns the global finish timer of the previous state in microseconds.
	* @return Timer value in Microseconds
	*/
	LibMCEnv_uint64 CStateEnvironment::GetElapsedTimeInStateInMicroseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetElapsedTimeInStateInMicroseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CStateEnvironment::GetCurrentDateTime - Returns the current time as DateTime object instance.
	* @return Date Time Instance.
	*/
	PDateTime CStateEnvironment::GetCurrentDateTime()
	{
		LibMCEnvHandle hDateTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetCurrentDateTime(m_pHandle, &hDateTime));
		
		if (!hDateTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTime);
	}
	
	/**
	* CStateEnvironment::GetCustomDateTime - Returns a custom time as DateTime object instance. Fails if the values are not a valid time from January first 1970 to year 1 million.
	* @param[in] nYear - Year. Must be larger or equal than 1970.
	* @param[in] nMonth - Month. Must be between 1 and 12.
	* @param[in] nDay - Day. Must be between 1 and 31.
	* @param[in] nHour - Hour. Must be between 0 and 23.
	* @param[in] nMinute - Minute. Must be between 0 and 59.
	* @param[in] nSecond - Second. Must be between 0 and 59.
	* @param[in] nMicrosecond - Microsecond. Must be between 0 and 999999.
	* @return Date Time Instance.
	*/
	PDateTime CStateEnvironment::GetCustomDateTime(const LibMCEnv_uint32 nYear, const LibMCEnv_uint32 nMonth, const LibMCEnv_uint32 nDay, const LibMCEnv_uint32 nHour, const LibMCEnv_uint32 nMinute, const LibMCEnv_uint32 nSecond, const LibMCEnv_uint32 nMicrosecond)
	{
		LibMCEnvHandle hDateTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetCustomDateTime(m_pHandle, nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicrosecond, &hDateTime));
		
		if (!hDateTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTime);
	}
	
	/**
	* CStateEnvironment::GetStartDateTime - Returns the startup time of the system as DateTime object instance. All Timer values are counted from there.
	* @return Date Time Instance.
	*/
	PDateTime CStateEnvironment::GetStartDateTime()
	{
		LibMCEnvHandle hDateTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetStartDateTime(m_pHandle, &hDateTime));
		
		if (!hDateTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTime);
	}
	
	/**
	* CStateEnvironment::GetTestEnvironment - Returns a test environment instance.
	* @return Test Environment Instance
	*/
	PTestEnvironment CStateEnvironment::GetTestEnvironment()
	{
		LibMCEnvHandle hTestEnvironment = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetTestEnvironment(m_pHandle, &hTestEnvironment));
		
		if (!hTestEnvironment) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CTestEnvironment>(m_pWrapper, hTestEnvironment);
	}
	
	/**
	* CStateEnvironment::CreateXMLDocument - creates an empty XML Document.
	* @param[in] sRootNodeName - Name of the root node. MUST be a valid XML Node Name string.
	* @param[in] sDefaultNamespace - Default namespace of the document. MUST be a valid XML namespace string.
	* @return XML Document Instance.
	*/
	PXMLDocument CStateEnvironment::CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace)
	{
		LibMCEnvHandle hXMLDocument = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateXMLDocument(m_pHandle, sRootNodeName.c_str(), sDefaultNamespace.c_str(), &hXMLDocument));
		
		if (!hXMLDocument) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocument>(m_pWrapper, hXMLDocument);
	}
	
	/**
	* CStateEnvironment::ParseXMLString - parses an XML String and returns an XML Document instance. Throws an error if XML is malformatted.
	* @param[in] sXMLString - XML String.
	* @return XML Document Instance.
	*/
	PXMLDocument CStateEnvironment::ParseXMLString(const std::string & sXMLString)
	{
		LibMCEnvHandle hXMLDocument = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_ParseXMLString(m_pHandle, sXMLString.c_str(), &hXMLDocument));
		
		if (!hXMLDocument) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocument>(m_pWrapper, hXMLDocument);
	}
	
	/**
	* CStateEnvironment::ParseXMLData - parses a XML stored in a byte array and returns an XML Document instance. . Throws an error if XML is malformatted.
	* @param[in] XMLDataBuffer - XML Binary data.
	* @return XML Document Instance.
	*/
	PXMLDocument CStateEnvironment::ParseXMLData(const CInputVector<LibMCEnv_uint8> & XMLDataBuffer)
	{
		LibMCEnvHandle hXMLDocument = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_ParseXMLData(m_pHandle, (LibMCEnv_uint64)XMLDataBuffer.size(), XMLDataBuffer.data(), &hXMLDocument));
		
		if (!hXMLDocument) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocument>(m_pWrapper, hXMLDocument);
	}
	
	/**
	* CStateEnvironment::CreateDataTable - creates an empty data table.
	* @return Data Table Instance.
	*/
	PDataTable CStateEnvironment::CreateDataTable()
	{
		LibMCEnvHandle hDataTableInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateDataTable(m_pHandle, &hDataTableInstance));
		
		if (!hDataTableInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataTable>(m_pWrapper, hDataTableInstance);
	}
	
	/**
	* CStateEnvironment::CheckUserPermission - Returns if the a user has a certain permission. Fails if user or permission is not known to the system.
	* @param[in] sUserLogin - Login of user to check
	* @param[in] sPermissionIdentifier - Permission identifier
	* @return Returns if the user has permission
	*/
	bool CStateEnvironment::CheckUserPermission(const std::string & sUserLogin, const std::string & sPermissionIdentifier)
	{
		bool resultUserHasPermission = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CheckUserPermission(m_pHandle, sUserLogin.c_str(), sPermissionIdentifier.c_str(), &resultUserHasPermission));
		
		return resultUserHasPermission;
	}
	
	/**
	* CStateEnvironment::CreateUserManagement - Returns a user management handler instance.
	* @return Returns a user management handler.
	*/
	PUserManagementHandler CStateEnvironment::CreateUserManagement()
	{
		LibMCEnvHandle hUserManagementInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateUserManagement(m_pHandle, &hUserManagementInstance));
		
		if (!hUserManagementInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CUserManagementHandler>(m_pWrapper, hUserManagementInstance);
	}
	
	/**
	* CStateEnvironment::GetCurrentJournal - Returns the journal instance of the current session.
	* @return Journal instance.
	*/
	PJournalHandler CStateEnvironment::GetCurrentJournal()
	{
		LibMCEnvHandle hJournalHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetCurrentJournal(m_pHandle, &hJournalHandler));
		
		if (!hJournalHandler) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CJournalHandler>(m_pWrapper, hJournalHandler);
	}
	
	/**
	* CStateEnvironment::CreateSceneHandler - Creates a new 3D scene handler instance.
	* @return Scene Handler instance.
	*/
	PSceneHandler CStateEnvironment::CreateSceneHandler()
	{
		LibMCEnvHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateSceneHandler(m_pHandle, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSceneHandler>(m_pWrapper, hInstance);
	}
	
	/**
	* CStateEnvironment::CreateDataSeries - Creates a new empty data series object.
	* @param[in] sName - Name to use for this data series. MUST NOT be an empty string.
	* @return Data series instance.
	*/
	PDataSeries CStateEnvironment::CreateDataSeries(const std::string & sName)
	{
		LibMCEnvHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateDataSeries(m_pHandle, sName.c_str(), &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataSeries>(m_pWrapper, hInstance);
	}
	
	/**
	* CStateEnvironment::HasDataSeries - Checks if a data series exist.
	* @param[in] sDataSeriesUUID - UUID to find.
	* @return returns true if series exists.
	*/
	bool CStateEnvironment::HasDataSeries(const std::string & sDataSeriesUUID)
	{
		bool resultDataSeriesExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_HasDataSeries(m_pHandle, sDataSeriesUUID.c_str(), &resultDataSeriesExists));
		
		return resultDataSeriesExists;
	}
	
	/**
	* CStateEnvironment::FindDataSeries - Finds a data series. Fails if data series does not exist.
	* @param[in] sDataSeriesUUID - UUID to find.
	* @return Data series instance.
	*/
	PDataSeries CStateEnvironment::FindDataSeries(const std::string & sDataSeriesUUID)
	{
		LibMCEnvHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_FindDataSeries(m_pHandle, sDataSeriesUUID.c_str(), &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataSeries>(m_pWrapper, hInstance);
	}
	
	/**
	* CStateEnvironment::ReleaseDataSeries - Releases the memory of a data series. Fails if data series does not exist.
	* @param[in] sDataSeriesUUID - UUID to release.
	*/
	void CStateEnvironment::ReleaseDataSeries(const std::string & sDataSeriesUUID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_ReleaseDataSeries(m_pHandle, sDataSeriesUUID.c_str()));
	}
	
	/**
	* CStateEnvironment::CreateAlert - creates a new alert
	* @param[in] sIdentifier - Alert type identifier. Call fails if identifier is not registered.
	* @param[in] sReadableContextInformation - Context information string that can be displayed to the user.
	* @param[in] bAutomaticLogEntry - If this flag is set to true, an automatic message will be posted to the system log.
	* @return Alert instance.
	*/
	PAlert CStateEnvironment::CreateAlert(const std::string & sIdentifier, const std::string & sReadableContextInformation, const bool bAutomaticLogEntry)
	{
		LibMCEnvHandle hAlert = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateAlert(m_pHandle, sIdentifier.c_str(), sReadableContextInformation.c_str(), bAutomaticLogEntry, &hAlert));
		
		if (!hAlert) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlert>(m_pWrapper, hAlert);
	}
	
	/**
	* CStateEnvironment::FindAlert - finds an alert by UUID. Fails if alert does not exist.
	* @param[in] sUUID - UUID of the alert to return.
	* @return Alert instance.
	*/
	PAlert CStateEnvironment::FindAlert(const std::string & sUUID)
	{
		LibMCEnvHandle hAlert = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_FindAlert(m_pHandle, sUUID.c_str(), &hAlert));
		
		if (!hAlert) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlert>(m_pWrapper, hAlert);
	}
	
	/**
	* CStateEnvironment::AlertExists - Checks if a certain alert exists.
	* @param[in] sUUID - UUID of the alert to return.
	* @return True if alert exists.
	*/
	bool CStateEnvironment::AlertExists(const std::string & sUUID)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_AlertExists(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CStateEnvironment::RetrieveAlerts - Retrieves all or all active alerts.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	PAlertIterator CStateEnvironment::RetrieveAlerts(const bool bOnlyActive)
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_RetrieveAlerts(m_pHandle, bOnlyActive, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlertIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CStateEnvironment::RetrieveAlertsByType - Retrieves alerts of a certain type identifier.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	PAlertIterator CStateEnvironment::RetrieveAlertsByType(const std::string & sIdentifier, const bool bOnlyActive)
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_RetrieveAlertsByType(m_pHandle, sIdentifier.c_str(), bOnlyActive, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlertIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CStateEnvironment::HasAlertOfType - Checks, if an alert of a certain type identifier exists.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be taken into account.
	* @return Flag, if the alert exists.
	*/
	bool CStateEnvironment::HasAlertOfType(const std::string & sIdentifier, const bool bOnlyActive)
	{
		bool resultHasAlert = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_HasAlertOfType(m_pHandle, sIdentifier.c_str(), bOnlyActive, &resultHasAlert));
		
		return resultHasAlert;
	}
	
	/**
	* CStateEnvironment::CreateCryptoContext - Creates a crypto context.
	* @return Cryptographic context instance
	*/
	PCryptoContext CStateEnvironment::CreateCryptoContext()
	{
		LibMCEnvHandle hContext = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateCryptoContext(m_pHandle, &hContext));
		
		if (!hContext) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CCryptoContext>(m_pWrapper, hContext);
	}
	
	/**
	* CStateEnvironment::CreateTemporaryStream - Creates a new writer to store temporary data. This data will be attached to the current journal.
	* @param[in] sName - Name of the storage stream.
	* @param[in] sMIMEType - Mime type of the data.
	* @return Temp stream writer instance
	*/
	PTempStreamWriter CStateEnvironment::CreateTemporaryStream(const std::string & sName, const std::string & sMIMEType)
	{
		LibMCEnvHandle hTempStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateTemporaryStream(m_pHandle, sName.c_str(), sMIMEType.c_str(), &hTempStreamInstance));
		
		if (!hTempStreamInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CTempStreamWriter>(m_pWrapper, hTempStreamInstance);
	}
	
	/**
	* CStateEnvironment::CreateZIPStream - Creates a new ZIP writer to store temporary data. This data will be attached to the current journal. MIME Type will be application/zip
	* @param[in] sName - Name of the storage stream.
	* @return ZIP stream writer instance
	*/
	PZIPStreamWriter CStateEnvironment::CreateZIPStream(const std::string & sName)
	{
		LibMCEnvHandle hZIPStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateZIPStream(m_pHandle, sName.c_str(), &hZIPStreamInstance));
		
		if (!hZIPStreamInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CZIPStreamWriter>(m_pWrapper, hZIPStreamInstance);
	}
	
	/**
	* CStateEnvironment::LoadStream - Loads a stream in the storage system.
	* @param[in] sUUID - UUID of the storage stream.
	* @param[in] bMustExist - If true, the call fails if the stream does not exist.
	* @return Stream Instance. Will return null if not found and MustExists is false.
	*/
	PStreamReader CStateEnvironment::LoadStream(const std::string & sUUID, const bool bMustExist)
	{
		LibMCEnvHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LoadStream(m_pHandle, sUUID.c_str(), bMustExist, &hStreamInstance));
		
		if (hStreamInstance) {
			return std::make_shared<CStreamReader>(m_pWrapper, hStreamInstance);
		} else {
			return nullptr;
		}
	}
	
	/**
	 * Method definitions for class CUIItem
	 */
	
	/**
	* CUIItem::GetName - Returns the name of the user interface item. MUST be unique within its siblings.
	* @return Returns the name.
	*/
	std::string CUIItem::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIItem_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_UIItem_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CUIItem::GetPath - Returns the full path of the user interface item. MUST be unique.
	* @return Returns the path.
	*/
	std::string CUIItem::GetPath()
	{
		LibMCEnv_uint32 bytesNeededPath = 0;
		LibMCEnv_uint32 bytesWrittenPath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIItem_GetPath(m_pHandle, 0, &bytesNeededPath, nullptr));
		std::vector<char> bufferPath(bytesNeededPath);
		CheckError(m_pWrapper->m_WrapperTable.m_UIItem_GetPath(m_pHandle, bytesNeededPath, &bytesWrittenPath, &bufferPath[0]));
		
		return std::string(&bufferPath[0]);
	}
	
	/**
	* CUIItem::GetUUID - Returns the UUID of the time stream chart object.
	* @return Returns uuid.
	*/
	std::string CUIItem::GetUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIItem_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_UIItem_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	 * Method definitions for class CUIEnvironment
	 */
	
	/**
	* CUIEnvironment::ActivateModalDialog - activates a modal dialog on the client.
	* @param[in] sDialogName - Name of the dialog to activate.
	*/
	void CUIEnvironment::ActivateModalDialog(const std::string & sDialogName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_ActivateModalDialog(m_pHandle, sDialogName.c_str()));
	}
	
	/**
	* CUIEnvironment::CloseModalDialog - closes the active modal dialog on the client.
	*/
	void CUIEnvironment::CloseModalDialog()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CloseModalDialog(m_pHandle));
	}
	
	/**
	* CUIEnvironment::ActivatePage - changes the current page on the client.
	* @param[in] sPageName - Name of the page to activate.
	*/
	void CUIEnvironment::ActivatePage(const std::string & sPageName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_ActivatePage(m_pHandle, sPageName.c_str()));
	}
	
	/**
	* CUIEnvironment::LogOut - Logs out the client session.
	*/
	void CUIEnvironment::LogOut()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_LogOut(m_pHandle));
	}
	
	/**
	* CUIEnvironment::ShowHint - Shows a hint message in the user interface.
	* @param[in] sHint - Hint to show.
	* @param[in] nTimeoutInMS - How many milliseconds the snackbar should be shown.
	*/
	void CUIEnvironment::ShowHint(const std::string & sHint, const LibMCEnv_uint32 nTimeoutInMS)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_ShowHint(m_pHandle, sHint.c_str(), nTimeoutInMS));
	}
	
	/**
	* CUIEnvironment::ShowHintColored - Shows a hint message in the user interface in a certain color.
	* @param[in] sHint - Hint to show.
	* @param[in] nTimeoutInMS - How many milliseconds the snackbar should be shown.
	* @param[in] Color - Background color of hint.
	* @param[in] FontColor - Font color of hint.
	*/
	void CUIEnvironment::ShowHintColored(const std::string & sHint, const LibMCEnv_uint32 nTimeoutInMS, const sColorRGB & Color, const sColorRGB & FontColor)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_ShowHintColored(m_pHandle, sHint.c_str(), nTimeoutInMS, &Color, &FontColor));
	}
	
	/**
	* CUIEnvironment::HideHint - Hides hint if any is displayed.
	*/
	void CUIEnvironment::HideHint()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_HideHint(m_pHandle));
	}
	
	/**
	* CUIEnvironment::StartStreamDownload - Starts a stream download on the client. Fails if stream does not exist.
	* @param[in] sUUID - Stream UUID.
	* @param[in] sFilename - Filename on disk. Fails if empty string.
	*/
	void CUIEnvironment::StartStreamDownload(const std::string & sUUID, const std::string & sFilename)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_StartStreamDownload(m_pHandle, sUUID.c_str(), sFilename.c_str()));
	}
	
	/**
	* CUIEnvironment::ShowMessageDlg - Shows a message dialog in the user interface.
	* @param[in] sCaption - Caption of the dialog
	* @param[in] sTitle - Title of the dialog
	* @param[in] eDialogType - Which dialog type shall be shown.
	* @param[in] sYesEvent - Event to be called when clicked yes or ok.
	* @param[in] sNoEvent - Event to be called when clicked no.
	* @param[in] sCancelEvent - Event to be called when dialog is closed or cancel is pressed.
	* @return Dialog UUID. Will be set as sender for triggered events.
	*/
	std::string CUIEnvironment::ShowMessageDlg(const std::string & sCaption, const std::string & sTitle, const eMessageDialogType eDialogType, const std::string & sYesEvent, const std::string & sNoEvent, const std::string & sCancelEvent)
	{
		LibMCEnv_uint32 bytesNeededDialogUUID = 0;
		LibMCEnv_uint32 bytesWrittenDialogUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_ShowMessageDlg(m_pHandle, sCaption.c_str(), sTitle.c_str(), eDialogType, sYesEvent.c_str(), sNoEvent.c_str(), sCancelEvent.c_str(), 0, &bytesNeededDialogUUID, nullptr));
		std::vector<char> bufferDialogUUID(bytesNeededDialogUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_ShowMessageDlg(m_pHandle, sCaption.c_str(), sTitle.c_str(), eDialogType, sYesEvent.c_str(), sNoEvent.c_str(), sCancelEvent.c_str(), bytesNeededDialogUUID, &bytesWrittenDialogUUID, &bufferDialogUUID[0]));
		
		return std::string(&bufferDialogUUID[0]);
	}
	
	/**
	* CUIEnvironment::RetrieveEventSender - returns path of the UI control that triggered the event.
	* @return Path of the sender element.
	*/
	std::string CUIEnvironment::RetrieveEventSender()
	{
		LibMCEnv_uint32 bytesNeededSenderPath = 0;
		LibMCEnv_uint32 bytesWrittenSenderPath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_RetrieveEventSender(m_pHandle, 0, &bytesNeededSenderPath, nullptr));
		std::vector<char> bufferSenderPath(bytesNeededSenderPath);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_RetrieveEventSender(m_pHandle, bytesNeededSenderPath, &bytesWrittenSenderPath, &bufferSenderPath[0]));
		
		return std::string(&bufferSenderPath[0]);
	}
	
	/**
	* CUIEnvironment::RetrieveEventSenderPage - returns name of the page of the UI control that triggered the event.
	* @return Page of the sender element.
	*/
	std::string CUIEnvironment::RetrieveEventSenderPage()
	{
		LibMCEnv_uint32 bytesNeededPageName = 0;
		LibMCEnv_uint32 bytesWrittenPageName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_RetrieveEventSenderPage(m_pHandle, 0, &bytesNeededPageName, nullptr));
		std::vector<char> bufferPageName(bytesNeededPageName);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_RetrieveEventSenderPage(m_pHandle, bytesNeededPageName, &bytesWrittenPageName, &bufferPageName[0]));
		
		return std::string(&bufferPageName[0]);
	}
	
	/**
	* CUIEnvironment::RetrieveEventSenderUUID - returns uuid of the UI control that triggered the event.
	* @return Name of the sender uuid.
	*/
	std::string CUIEnvironment::RetrieveEventSenderUUID()
	{
		LibMCEnv_uint32 bytesNeededSenderUUID = 0;
		LibMCEnv_uint32 bytesWrittenSenderUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_RetrieveEventSenderUUID(m_pHandle, 0, &bytesNeededSenderUUID, nullptr));
		std::vector<char> bufferSenderUUID(bytesNeededSenderUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_RetrieveEventSenderUUID(m_pHandle, bytesNeededSenderUUID, &bytesWrittenSenderUUID, &bufferSenderUUID[0]));
		
		return std::string(&bufferSenderUUID[0]);
	}
	
	/**
	* CUIEnvironment::PrepareSignal - prepares a signal object to trigger later.
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sSignalName - Name Of signal channel.
	* @return Signal trigger object.
	*/
	PSignalTrigger CUIEnvironment::PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName)
	{
		LibMCEnvHandle hSignalInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_PrepareSignal(m_pHandle, sMachineInstance.c_str(), sSignalName.c_str(), &hSignalInstance));
		
		if (!hSignalInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSignalTrigger>(m_pWrapper, hSignalInstance);
	}
	
	/**
	* CUIEnvironment::GetMachineState - Retrieves the machine state
	* @param[in] sMachineInstance - State machine instance name
	* @return Name of current state
	*/
	std::string CUIEnvironment::GetMachineState(const std::string & sMachineInstance)
	{
		LibMCEnv_uint32 bytesNeededStateName = 0;
		LibMCEnv_uint32 bytesWrittenStateName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineState(m_pHandle, sMachineInstance.c_str(), 0, &bytesNeededStateName, nullptr));
		std::vector<char> bufferStateName(bytesNeededStateName);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineState(m_pHandle, sMachineInstance.c_str(), bytesNeededStateName, &bytesWrittenStateName, &bufferStateName[0]));
		
		return std::string(&bufferStateName[0]);
	}
	
	/**
	* CUIEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	void CUIEnvironment::LogMessage(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_LogMessage(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CUIEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	void CUIEnvironment::LogWarning(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_LogWarning(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CUIEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	void CUIEnvironment::LogInfo(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_LogInfo(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CUIEnvironment::GetMachineParameter - returns a string parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	std::string CUIEnvironment::GetMachineParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineParameter(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineParameter(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CUIEnvironment::GetMachineParameterAsUUID - returns a uuid parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	std::string CUIEnvironment::GetMachineParameterAsUUID(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineParameterAsUUID(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineParameterAsUUID(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CUIEnvironment::GetMachineParameterAsDouble - returns a double parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	LibMCEnv_double CUIEnvironment::GetMachineParameterAsDouble(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineParameterAsDouble(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::GetMachineParameterAsInteger - returns an int parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	LibMCEnv_int64 CUIEnvironment::GetMachineParameterAsInteger(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineParameterAsInteger(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::GetMachineParameterAsBool - returns a bool parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	bool CUIEnvironment::GetMachineParameterAsBool(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineParameterAsBool(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::GetUIProperty - returns a string property of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	std::string CUIEnvironment::GetUIProperty(const std::string & sElementPath, const std::string & sPropertyName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetUIProperty(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetUIProperty(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CUIEnvironment::GetUIPropertyAsUUID - returns a uuid variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	std::string CUIEnvironment::GetUIPropertyAsUUID(const std::string & sElementPath, const std::string & sPropertyName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetUIPropertyAsUUID(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetUIPropertyAsUUID(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CUIEnvironment::GetUIPropertyAsDouble - returns a double variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	LibMCEnv_double CUIEnvironment::GetUIPropertyAsDouble(const std::string & sElementPath, const std::string & sPropertyName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetUIPropertyAsDouble(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::GetUIPropertyAsInteger - returns a integer variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	LibMCEnv_int64 CUIEnvironment::GetUIPropertyAsInteger(const std::string & sElementPath, const std::string & sPropertyName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetUIPropertyAsInteger(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::GetUIPropertyAsBool - returns a integer variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	bool CUIEnvironment::GetUIPropertyAsBool(const std::string & sElementPath, const std::string & sPropertyName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetUIPropertyAsBool(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::SetUIProperty - sets a string property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] sValue - New property Value
	*/
	void CUIEnvironment::SetUIProperty(const std::string & sElementPath, const std::string & sPropertyName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_SetUIProperty(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), sValue.c_str()));
	}
	
	/**
	* CUIEnvironment::SetUIPropertyAsUUID - sets a uuid property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] sValue - New property Value
	*/
	void CUIEnvironment::SetUIPropertyAsUUID(const std::string & sElementPath, const std::string & sPropertyName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_SetUIPropertyAsUUID(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), sValue.c_str()));
	}
	
	/**
	* CUIEnvironment::SetUIPropertyAsDouble - sets a double property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] dValue - New property Value
	*/
	void CUIEnvironment::SetUIPropertyAsDouble(const std::string & sElementPath, const std::string & sPropertyName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_SetUIPropertyAsDouble(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), dValue));
	}
	
	/**
	* CUIEnvironment::SetUIPropertyAsInteger - sets a integer property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] nValue - New property Value
	*/
	void CUIEnvironment::SetUIPropertyAsInteger(const std::string & sElementPath, const std::string & sPropertyName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_SetUIPropertyAsInteger(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), nValue));
	}
	
	/**
	* CUIEnvironment::SetUIPropertyAsBool - sets a bool property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] bValue - New property Value
	*/
	void CUIEnvironment::SetUIPropertyAsBool(const std::string & sElementPath, const std::string & sPropertyName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_SetUIPropertyAsBool(m_pHandle, sElementPath.c_str(), sPropertyName.c_str(), bValue));
	}
	
	/**
	* CUIEnvironment::CreateEmptyImage - creates an empty image object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use.
	* @return Empty image instance.
	*/
	PImageData CUIEnvironment::CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateEmptyImage(m_pHandle, nPixelSizeX, nPixelSizeY, dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CUIEnvironment::LoadPNGImage - creates an image object from a PNG data stream.
	* @param[in] PNGDataBuffer - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image instance containing the PNG image.
	*/
	PImageData CUIEnvironment::LoadPNGImage(const CInputVector<LibMCEnv_uint8> & PNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const eImagePixelFormat ePixelFormat)
	{
		LibMCEnvHandle hImageDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_LoadPNGImage(m_pHandle, (LibMCEnv_uint64)PNGDataBuffer.size(), PNGDataBuffer.data(), dDPIValueX, dDPIValueY, ePixelFormat, &hImageDataInstance));
		
		if (!hImageDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageData>(m_pWrapper, hImageDataInstance);
	}
	
	/**
	* CUIEnvironment::GetGlobalTimerInMilliseconds - Returns the global timer in milliseconds.
	* @return Timer value in Milliseconds
	*/
	LibMCEnv_uint64 CUIEnvironment::GetGlobalTimerInMilliseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetGlobalTimerInMilliseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CUIEnvironment::GetGlobalTimerInMicroseconds - Returns the global timer in microseconds.
	* @return Timer value in Microseconds
	*/
	LibMCEnv_uint64 CUIEnvironment::GetGlobalTimerInMicroseconds()
	{
		LibMCEnv_uint64 resultTimerValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetGlobalTimerInMicroseconds(m_pHandle, &resultTimerValue));
		
		return resultTimerValue;
	}
	
	/**
	* CUIEnvironment::GetTestEnvironment - Returns a test environment instance.
	* @return Test Environment Instance
	*/
	PTestEnvironment CUIEnvironment::GetTestEnvironment()
	{
		LibMCEnvHandle hTestEnvironment = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetTestEnvironment(m_pHandle, &hTestEnvironment));
		
		if (!hTestEnvironment) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CTestEnvironment>(m_pWrapper, hTestEnvironment);
	}
	
	/**
	* CUIEnvironment::CreateXMLDocument - creates an empty XML Document.
	* @param[in] sRootNodeName - Name of the root node. MUST be a valid XML Node Name string.
	* @param[in] sDefaultNamespace - Default namespace of the document. MUST be a valid XML namespace string.
	* @return XML Document Instance.
	*/
	PXMLDocument CUIEnvironment::CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace)
	{
		LibMCEnvHandle hXMLDocument = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateXMLDocument(m_pHandle, sRootNodeName.c_str(), sDefaultNamespace.c_str(), &hXMLDocument));
		
		if (!hXMLDocument) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocument>(m_pWrapper, hXMLDocument);
	}
	
	/**
	* CUIEnvironment::ParseXMLString - parses an XML String and returns an XML Document instance. Throws an error if XML is malformatted.
	* @param[in] sXMLString - XML String.
	* @return XML Document Instance.
	*/
	PXMLDocument CUIEnvironment::ParseXMLString(const std::string & sXMLString)
	{
		LibMCEnvHandle hXMLDocument = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_ParseXMLString(m_pHandle, sXMLString.c_str(), &hXMLDocument));
		
		if (!hXMLDocument) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocument>(m_pWrapper, hXMLDocument);
	}
	
	/**
	* CUIEnvironment::ParseXMLData - parses a XML stored in a byte array and returns an XML Document instance. . Throws an error if XML is malformatted.
	* @param[in] XMLDataBuffer - XML Binary data.
	* @return XML Document Instance.
	*/
	PXMLDocument CUIEnvironment::ParseXMLData(const CInputVector<LibMCEnv_uint8> & XMLDataBuffer)
	{
		LibMCEnvHandle hXMLDocument = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_ParseXMLData(m_pHandle, (LibMCEnv_uint64)XMLDataBuffer.size(), XMLDataBuffer.data(), &hXMLDocument));
		
		if (!hXMLDocument) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CXMLDocument>(m_pWrapper, hXMLDocument);
	}
	
	/**
	* CUIEnvironment::CreateDataTable - creates an empty data table.
	* @return Data Table Instance.
	*/
	PDataTable CUIEnvironment::CreateDataTable()
	{
		LibMCEnvHandle hDataTableInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateDataTable(m_pHandle, &hDataTableInstance));
		
		if (!hDataTableInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataTable>(m_pWrapper, hDataTableInstance);
	}
	
	/**
	* CUIEnvironment::HasBuildJob - Returns if a build object exists. Fails if BuildUUID is not a valid UUID string.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Returns true if build exists
	*/
	bool CUIEnvironment::HasBuildJob(const std::string & sBuildUUID)
	{
		bool resultBuildExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_HasBuildJob(m_pHandle, sBuildUUID.c_str(), &resultBuildExists));
		
		return resultBuildExists;
	}
	
	/**
	* CUIEnvironment::GetBuildJob - Returns a instance of a build object. Fails if build uuid does not exist.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	PBuild CUIEnvironment::GetBuildJob(const std::string & sBuildUUID)
	{
		LibMCEnvHandle hBuildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetBuildJob(m_pHandle, sBuildUUID.c_str(), &hBuildInstance));
		
		if (!hBuildInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuild>(m_pWrapper, hBuildInstance);
	}
	
	/**
	* CUIEnvironment::HasBuildExecution - Returns if a build execution exists. Fails if ExecutionUUID is not a valid UUID string.
	* @param[in] sExecutionUUID - UUID of the execution entity.
	* @return Returns true if execution exists
	*/
	bool CUIEnvironment::HasBuildExecution(const std::string & sExecutionUUID)
	{
		bool resultExecutionExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_HasBuildExecution(m_pHandle, sExecutionUUID.c_str(), &resultExecutionExists));
		
		return resultExecutionExists;
	}
	
	/**
	* CUIEnvironment::GetBuildExecution - Returns a instance of a build execution object. Fails if build execution uuid does not exist.
	* @param[in] sExecutionUUID - UUID of the execution entity.
	* @return Build execution instance
	*/
	PBuildExecution CUIEnvironment::GetBuildExecution(const std::string & sExecutionUUID)
	{
		LibMCEnvHandle hExecutionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetBuildExecution(m_pHandle, sExecutionUUID.c_str(), &hExecutionInstance));
		
		if (!hExecutionInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildExecution>(m_pWrapper, hExecutionInstance);
	}
	
	/**
	* CUIEnvironment::CreateDiscreteField2D - Creates an empty discrete field.
	* @param[in] nPixelCountX - Pixel count in X. MUST be positive.
	* @param[in] nPixelCountY - Pixel count in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @param[in] dDefaultValue - Default value of the field.
	* @return Empty field instance.
	*/
	PDiscreteFieldData2D CUIEnvironment::CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue)
	{
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateDiscreteField2D(m_pHandle, nPixelCountX, nPixelCountY, dDPIValueX, dDPIValueY, dOriginX, dOriginY, dDefaultValue, &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CUIEnvironment::CreateDiscreteField2DFromImage - Creates a discrete field from the greyscale values of an image. RGB colors in the image will be averaged to obtain a greyscale color.
	* @param[in] pImageDataInstance - Image instance containing the pixel data.
	* @param[in] dBlackValue - Value that the minimum color (black) shall be mapped to.
	* @param[in] dWhiteValue - Value that the maximum color (white) shall be mapped to.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @return Empty field instance.
	*/
	PDiscreteFieldData2D CUIEnvironment::CreateDiscreteField2DFromImage(classParam<CImageData> pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY)
	{
		LibMCEnvHandle hImageDataInstance = pImageDataInstance.GetHandle();
		LibMCEnvHandle hFieldDataInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateDiscreteField2DFromImage(m_pHandle, hImageDataInstance, dBlackValue, dWhiteValue, dOriginX, dOriginY, &hFieldDataInstance));
		
		if (!hFieldDataInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDiscreteFieldData2D>(m_pWrapper, hFieldDataInstance);
	}
	
	/**
	* CUIEnvironment::CheckPermission - Returns if the current user has a certain permission. Fails if permission is not known to the system.
	* @param[in] sPermissionIdentifier - Permission identifier
	* @return Returns if the user has permission
	*/
	bool CUIEnvironment::CheckPermission(const std::string & sPermissionIdentifier)
	{
		bool resultUserHasPermission = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CheckPermission(m_pHandle, sPermissionIdentifier.c_str(), &resultUserHasPermission));
		
		return resultUserHasPermission;
	}
	
	/**
	* CUIEnvironment::GetCurrentUserLogin - Returns the current user login name.
	* @return Returns the current users login name.
	*/
	std::string CUIEnvironment::GetCurrentUserLogin()
	{
		LibMCEnv_uint32 bytesNeededUserLogin = 0;
		LibMCEnv_uint32 bytesWrittenUserLogin = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserLogin(m_pHandle, 0, &bytesNeededUserLogin, nullptr));
		std::vector<char> bufferUserLogin(bytesNeededUserLogin);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserLogin(m_pHandle, bytesNeededUserLogin, &bytesWrittenUserLogin, &bufferUserLogin[0]));
		
		return std::string(&bufferUserLogin[0]);
	}
	
	/**
	* CUIEnvironment::GetCurrentUserDescription - Returns the current user description.
	* @return Returns the current users description.
	*/
	std::string CUIEnvironment::GetCurrentUserDescription()
	{
		LibMCEnv_uint32 bytesNeededUserDescription = 0;
		LibMCEnv_uint32 bytesWrittenUserDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserDescription(m_pHandle, 0, &bytesNeededUserDescription, nullptr));
		std::vector<char> bufferUserDescription(bytesNeededUserDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserDescription(m_pHandle, bytesNeededUserDescription, &bytesWrittenUserDescription, &bufferUserDescription[0]));
		
		return std::string(&bufferUserDescription[0]);
	}
	
	/**
	* CUIEnvironment::GetCurrentUserRole - Returns the current user role identifier.
	* @return Returns the current users role identifier.
	*/
	std::string CUIEnvironment::GetCurrentUserRole()
	{
		LibMCEnv_uint32 bytesNeededUserRole = 0;
		LibMCEnv_uint32 bytesWrittenUserRole = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserRole(m_pHandle, 0, &bytesNeededUserRole, nullptr));
		std::vector<char> bufferUserRole(bytesNeededUserRole);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserRole(m_pHandle, bytesNeededUserRole, &bytesWrittenUserRole, &bufferUserRole[0]));
		
		return std::string(&bufferUserRole[0]);
	}
	
	/**
	* CUIEnvironment::GetCurrentUserLanguage - Returns the current users language identifier.
	* @return Returns the current users language identifier.
	*/
	std::string CUIEnvironment::GetCurrentUserLanguage()
	{
		LibMCEnv_uint32 bytesNeededUserLanguage = 0;
		LibMCEnv_uint32 bytesWrittenUserLanguage = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserLanguage(m_pHandle, 0, &bytesNeededUserLanguage, nullptr));
		std::vector<char> bufferUserLanguage(bytesNeededUserLanguage);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserLanguage(m_pHandle, bytesNeededUserLanguage, &bytesWrittenUserLanguage, &bufferUserLanguage[0]));
		
		return std::string(&bufferUserLanguage[0]);
	}
	
	/**
	* CUIEnvironment::GetCurrentUserUUID - Returns the current user UUID.
	* @return Returns the current user UUID.
	*/
	std::string CUIEnvironment::GetCurrentUserUUID()
	{
		LibMCEnv_uint32 bytesNeededUserUUID = 0;
		LibMCEnv_uint32 bytesWrittenUserUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserUUID(m_pHandle, 0, &bytesNeededUserUUID, nullptr));
		std::vector<char> bufferUserUUID(bytesNeededUserUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentUserUUID(m_pHandle, bytesNeededUserUUID, &bytesWrittenUserUUID, &bufferUserUUID[0]));
		
		return std::string(&bufferUserUUID[0]);
	}
	
	/**
	* CUIEnvironment::CreateUserManagement - Returns a user management handler instance.
	* @return Returns a user management handler.
	*/
	PUserManagementHandler CUIEnvironment::CreateUserManagement()
	{
		LibMCEnvHandle hUserManagementInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateUserManagement(m_pHandle, &hUserManagementInstance));
		
		if (!hUserManagementInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CUserManagementHandler>(m_pWrapper, hUserManagementInstance);
	}
	
	/**
	* CUIEnvironment::GetCurrentJournal - Returns the journal instance of the current session.
	* @return Journal instance.
	*/
	PJournalHandler CUIEnvironment::GetCurrentJournal()
	{
		LibMCEnvHandle hJournalHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentJournal(m_pHandle, &hJournalHandler));
		
		if (!hJournalHandler) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CJournalHandler>(m_pWrapper, hJournalHandler);
	}
	
	/**
	* CUIEnvironment::CreateSceneHandler - Creates a new 3D scene handler instance.
	* @return Scene Handler instance.
	*/
	PSceneHandler CUIEnvironment::CreateSceneHandler()
	{
		LibMCEnvHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateSceneHandler(m_pHandle, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSceneHandler>(m_pWrapper, hInstance);
	}
	
	/**
	* CUIEnvironment::CreateDataSeries - Creates a new empty data series object.
	* @param[in] sName - Name to use for this data series. MUST NOT be an empty string.
	* @param[in] bBoundToLogin - If true, the data series is tied to the current user login session. If false, the data series will persist until explicitely released. This can be dangerous for the overall machine stability.
	* @return Data series instance.
	*/
	PDataSeries CUIEnvironment::CreateDataSeries(const std::string & sName, const bool bBoundToLogin)
	{
		LibMCEnvHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateDataSeries(m_pHandle, sName.c_str(), bBoundToLogin, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataSeries>(m_pWrapper, hInstance);
	}
	
	/**
	* CUIEnvironment::HasDataSeries - Checks if a data series exist.
	* @param[in] sDataSeriesUUID - UUID to find.
	* @return returns true if series exists.
	*/
	bool CUIEnvironment::HasDataSeries(const std::string & sDataSeriesUUID)
	{
		bool resultDataSeriesExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_HasDataSeries(m_pHandle, sDataSeriesUUID.c_str(), &resultDataSeriesExists));
		
		return resultDataSeriesExists;
	}
	
	/**
	* CUIEnvironment::FindDataSeries - Finds a data series. Fails if data series does not exist.
	* @param[in] sDataSeriesUUID - UUID to find.
	* @return Data series instance.
	*/
	PDataSeries CUIEnvironment::FindDataSeries(const std::string & sDataSeriesUUID)
	{
		LibMCEnvHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_FindDataSeries(m_pHandle, sDataSeriesUUID.c_str(), &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataSeries>(m_pWrapper, hInstance);
	}
	
	/**
	* CUIEnvironment::ReleaseDataSeries - Releases the memory of a data series. Fails if data series does not exist.
	* @param[in] sDataSeriesUUID - UUID to release.
	*/
	void CUIEnvironment::ReleaseDataSeries(const std::string & sDataSeriesUUID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_ReleaseDataSeries(m_pHandle, sDataSeriesUUID.c_str()));
	}
	
	/**
	* CUIEnvironment::CreateAlert - creates a new alert
	* @param[in] sIdentifier - Alert type identifier. Call fails if identifier is not registered.
	* @param[in] sReadableContextInformation - Context information string that can be displayed to the user.
	* @param[in] bAutomaticLogEntry - If this flag is set to true, an automatic message will be posted to the system log.
	* @return Alert instance.
	*/
	PAlert CUIEnvironment::CreateAlert(const std::string & sIdentifier, const std::string & sReadableContextInformation, const bool bAutomaticLogEntry)
	{
		LibMCEnvHandle hAlert = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateAlert(m_pHandle, sIdentifier.c_str(), sReadableContextInformation.c_str(), bAutomaticLogEntry, &hAlert));
		
		if (!hAlert) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlert>(m_pWrapper, hAlert);
	}
	
	/**
	* CUIEnvironment::FindAlert - finds an alert by UUID. Fails if alert does not exist.
	* @param[in] sUUID - UUID of the alert to return.
	* @return Alert instance.
	*/
	PAlert CUIEnvironment::FindAlert(const std::string & sUUID)
	{
		LibMCEnvHandle hAlert = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_FindAlert(m_pHandle, sUUID.c_str(), &hAlert));
		
		if (!hAlert) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlert>(m_pWrapper, hAlert);
	}
	
	/**
	* CUIEnvironment::AlertExists - Checks if a certain alert exists.
	* @param[in] sUUID - UUID of the alert to return.
	* @return True if alert exists.
	*/
	bool CUIEnvironment::AlertExists(const std::string & sUUID)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_AlertExists(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::RetrieveAlerts - Retrieves all or all active alerts.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	PAlertIterator CUIEnvironment::RetrieveAlerts(const bool bOnlyActive)
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_RetrieveAlerts(m_pHandle, bOnlyActive, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlertIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CUIEnvironment::RetrieveAlertsByType - Retrieves alerts of a certain type identifier.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	PAlertIterator CUIEnvironment::RetrieveAlertsByType(const std::string & sIdentifier, const bool bOnlyActive)
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_RetrieveAlertsByType(m_pHandle, sIdentifier.c_str(), bOnlyActive, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlertIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CUIEnvironment::HasAlertOfType - Checks, if an alert of a certain type identifier exists.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be taken into account.
	* @return Flag, if the alert exists.
	*/
	bool CUIEnvironment::HasAlertOfType(const std::string & sIdentifier, const bool bOnlyActive)
	{
		bool resultHasAlert = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_HasAlertOfType(m_pHandle, sIdentifier.c_str(), bOnlyActive, &resultHasAlert));
		
		return resultHasAlert;
	}
	
	/**
	* CUIEnvironment::CreateCryptoContext - Creates a crypto context.
	* @return Cryptographic context instance
	*/
	PCryptoContext CUIEnvironment::CreateCryptoContext()
	{
		LibMCEnvHandle hContext = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateCryptoContext(m_pHandle, &hContext));
		
		if (!hContext) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CCryptoContext>(m_pWrapper, hContext);
	}
	
	/**
	* CUIEnvironment::CreateTemporaryStream - Creates a new writer to store temporary data. This data will be attached to the current journal.
	* @param[in] sName - Name of the storage stream.
	* @param[in] sMIMEType - Mime type of the data.
	* @return Temp stream writer instance
	*/
	PTempStreamWriter CUIEnvironment::CreateTemporaryStream(const std::string & sName, const std::string & sMIMEType)
	{
		LibMCEnvHandle hTempStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateTemporaryStream(m_pHandle, sName.c_str(), sMIMEType.c_str(), &hTempStreamInstance));
		
		if (!hTempStreamInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CTempStreamWriter>(m_pWrapper, hTempStreamInstance);
	}
	
	/**
	* CUIEnvironment::CreateZIPStream - Creates a new ZIP writer to store temporary data. This data will be attached to the current journal. MIME Type will be application/zip
	* @param[in] sName - Name of the storage stream.
	* @return ZIP stream writer instance
	*/
	PZIPStreamWriter CUIEnvironment::CreateZIPStream(const std::string & sName)
	{
		LibMCEnvHandle hZIPStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_CreateZIPStream(m_pHandle, sName.c_str(), &hZIPStreamInstance));
		
		if (!hZIPStreamInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CZIPStreamWriter>(m_pWrapper, hZIPStreamInstance);
	}
	
	/**
	* CUIEnvironment::LoadStream - Loads a stream in the storage system.
	* @param[in] sUUID - UUID of the storage stream.
	* @param[in] bMustExist - If true, the call fails if the stream does not exist.
	* @return Stream Instance. Will return null if not found and MustExists is false.
	*/
	PStreamReader CUIEnvironment::LoadStream(const std::string & sUUID, const bool bMustExist)
	{
		LibMCEnvHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_LoadStream(m_pHandle, sUUID.c_str(), bMustExist, &hStreamInstance));
		
		if (hStreamInstance) {
			return std::make_shared<CStreamReader>(m_pWrapper, hStreamInstance);
		} else {
			return nullptr;
		}
	}
	
	/**
	* CUIEnvironment::GetCurrentDateTime - Returns the current time as DateTime object instance.
	* @return Date Time Instance.
	*/
	PDateTime CUIEnvironment::GetCurrentDateTime()
	{
		LibMCEnvHandle hDateTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCurrentDateTime(m_pHandle, &hDateTime));
		
		if (!hDateTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTime);
	}
	
	/**
	* CUIEnvironment::GetCustomDateTime - Returns a custom time as DateTime object instance. Fails if the values are not a valid time from January first 1970 to year 1 million.
	* @param[in] nYear - Year. Must be larger or equal than 1970.
	* @param[in] nMonth - Month. Must be between 1 and 12.
	* @param[in] nDay - Day. Must be between 1 and 31.
	* @param[in] nHour - Hour. Must be between 0 and 23.
	* @param[in] nMinute - Minute. Must be between 0 and 59.
	* @param[in] nSecond - Second. Must be between 0 and 59.
	* @param[in] nMicrosecond - Microsecond. Must be between 0 and 999999.
	* @return Date Time Instance.
	*/
	PDateTime CUIEnvironment::GetCustomDateTime(const LibMCEnv_uint32 nYear, const LibMCEnv_uint32 nMonth, const LibMCEnv_uint32 nDay, const LibMCEnv_uint32 nHour, const LibMCEnv_uint32 nMinute, const LibMCEnv_uint32 nSecond, const LibMCEnv_uint32 nMicrosecond)
	{
		LibMCEnvHandle hDateTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetCustomDateTime(m_pHandle, nYear, nMonth, nDay, nHour, nMinute, nSecond, nMicrosecond, &hDateTime));
		
		if (!hDateTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTime);
	}
	
	/**
	* CUIEnvironment::GetStartDateTime - Returns the startup time of the system as DateTime object instance. All Timer values are counted from there.
	* @return Date Time Instance.
	*/
	PDateTime CUIEnvironment::GetStartDateTime()
	{
		LibMCEnvHandle hDateTime = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetStartDateTime(m_pHandle, &hDateTime));
		
		if (!hDateTime) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDateTime>(m_pWrapper, hDateTime);
	}
	
	/**
	* CUIEnvironment::Sleep - Puts the current request to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	void CUIEnvironment::Sleep(const LibMCEnv_uint32 nDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_Sleep(m_pHandle, nDelay));
	}

} // namespace LibMCEnv

#endif // __LIBMCENV_CPPHEADER_DYNAMIC_CPP

