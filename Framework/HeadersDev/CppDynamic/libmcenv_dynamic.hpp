/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of MC Environment Interface

Interface version: 1.0.0

*/

#ifndef __LIBMCENV_CPPHEADER_DYNAMIC_CPP
#define __LIBMCENV_CPPHEADER_DYNAMIC_CPP

#include "libmcenv_types.hpp"
#include "libmcenv_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCEnv {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CIterator;
class CToolpathLayer;
class CToolpathAccessor;
class CBuild;
class CWorkingFileExecution;
class CWorkingFile;
class CWorkingFileIterator;
class CWorkingDirectory;
class CDriverEnvironment;
class CSignalTrigger;
class CSignalHandler;
class CStateEnvironment;
class CUIEnvironment;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCEnvWrapper;
typedef CBase CLibMCEnvBase;
typedef CIterator CLibMCEnvIterator;
typedef CToolpathLayer CLibMCEnvToolpathLayer;
typedef CToolpathAccessor CLibMCEnvToolpathAccessor;
typedef CBuild CLibMCEnvBuild;
typedef CWorkingFileExecution CLibMCEnvWorkingFileExecution;
typedef CWorkingFile CLibMCEnvWorkingFile;
typedef CWorkingFileIterator CLibMCEnvWorkingFileIterator;
typedef CWorkingDirectory CLibMCEnvWorkingDirectory;
typedef CDriverEnvironment CLibMCEnvDriverEnvironment;
typedef CSignalTrigger CLibMCEnvSignalTrigger;
typedef CSignalHandler CLibMCEnvSignalHandler;
typedef CStateEnvironment CLibMCEnvStateEnvironment;
typedef CUIEnvironment CLibMCEnvUIEnvironment;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CIterator> PIterator;
typedef std::shared_ptr<CToolpathLayer> PToolpathLayer;
typedef std::shared_ptr<CToolpathAccessor> PToolpathAccessor;
typedef std::shared_ptr<CBuild> PBuild;
typedef std::shared_ptr<CWorkingFileExecution> PWorkingFileExecution;
typedef std::shared_ptr<CWorkingFile> PWorkingFile;
typedef std::shared_ptr<CWorkingFileIterator> PWorkingFileIterator;
typedef std::shared_ptr<CWorkingDirectory> PWorkingDirectory;
typedef std::shared_ptr<CDriverEnvironment> PDriverEnvironment;
typedef std::shared_ptr<CSignalTrigger> PSignalTrigger;
typedef std::shared_ptr<CSignalHandler> PSignalHandler;
typedef std::shared_ptr<CStateEnvironment> PStateEnvironment;
typedef std::shared_ptr<CUIEnvironment> PUIEnvironment;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCEnvWrapper;
typedef PBase PLibMCEnvBase;
typedef PIterator PLibMCEnvIterator;
typedef PToolpathLayer PLibMCEnvToolpathLayer;
typedef PToolpathAccessor PLibMCEnvToolpathAccessor;
typedef PBuild PLibMCEnvBuild;
typedef PWorkingFileExecution PLibMCEnvWorkingFileExecution;
typedef PWorkingFile PLibMCEnvWorkingFile;
typedef PWorkingFileIterator PLibMCEnvWorkingFileIterator;
typedef PWorkingDirectory PLibMCEnvWorkingDirectory;
typedef PDriverEnvironment PLibMCEnvDriverEnvironment;
typedef PSignalTrigger PLibMCEnvSignalTrigger;
typedef PSignalHandler PLibMCEnvSignalHandler;
typedef PStateEnvironment PLibMCEnvStateEnvironment;
typedef PUIEnvironment PLibMCEnvUIEnvironment;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCEnvHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCEnvException 
**************************************************************************************************************************/
class ELibMCEnvException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCEnvResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCEnvException(LibMCEnvResult errorCode, const std::string & sErrorMessage)
		: m_errorMessage("LibMCEnv Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
	{
		m_errorCode = errorCode;
	}

	/**
	* Returns error code
	*/
	LibMCEnvResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector( const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector( const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCEnvInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCEnvResult nResult);

	inline void GetVersion(LibMCEnv_uint32 & nMajor, LibMCEnv_uint32 & nMinor, LibMCEnv_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline LibMCEnv_pvoid GetSymbolLookupMethod();

private:
	sLibMCEnvDynamicWrapperTable m_WrapperTable;
	
	LibMCEnvResult checkBinaryVersion()
	{
		LibMCEnv_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != LIBMCENV_VERSION_MAJOR) || (nMinor < LIBMCENV_VERSION_MINOR) ) {
			return LIBMCENV_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCENV_SUCCESS;
	}
	LibMCEnvResult initWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable);
	LibMCEnvResult releaseWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable);
	LibMCEnvResult loadWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCEnvResult loadWrapperTableFromSymbolLookupMethod(sLibMCEnvDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CIterator;
	friend class CToolpathLayer;
	friend class CToolpathAccessor;
	friend class CBuild;
	friend class CWorkingFileExecution;
	friend class CWorkingFile;
	friend class CWorkingFileIterator;
	friend class CWorkingDirectory;
	friend class CDriverEnvironment;
	friend class CSignalTrigger;
	friend class CSignalHandler;
	friend class CStateEnvironment;
	friend class CUIEnvironment;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCEnvHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCEnvResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCEnvHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCEnvHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CIterator 
**************************************************************************************************************************/
class CIterator : public CBase {
public:
	
	/**
	* CIterator::CIterator - Constructor for Iterator class.
	*/
	CIterator(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MoveNext();
	inline bool MovePrevious();
	inline PBase GetCurrent();
	inline PIterator Clone();
	inline LibMCEnv_uint64 Count();
};
	
/*************************************************************************************************************************
 Class CToolpathLayer 
**************************************************************************************************************************/
class CToolpathLayer : public CBase {
public:
	
	/**
	* CToolpathLayer::CToolpathLayer - Constructor for ToolpathLayer class.
	*/
	CToolpathLayer(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetLayerDataUUID();
	inline LibMCEnv_uint32 GetSegmentCount();
	inline void GetSegmentInfo(const LibMCEnv_uint32 nIndex, eToolpathSegmentType & eType, LibMCEnv_uint32 & nPointCount);
	inline std::string GetSegmentProfileUUID(const LibMCEnv_uint32 nIndex);
	inline std::string GetSegmentProfileValue(const LibMCEnv_uint32 nIndex, const std::string & sValueName);
	inline LibMCEnv_double GetSegmentProfileTypedValue(const LibMCEnv_uint32 nIndex, const eToolpathProfileValueType eValueType);
	inline std::string GetSegmentPartUUID(const LibMCEnv_uint32 nIndex);
	inline void GetSegmentPointData(const LibMCEnv_uint32 nIndex, std::vector<sPosition2D> & PointDataBuffer);
	inline LibMCEnv_int32 GetZValue();
	inline LibMCEnv_double GetUnits();
};
	
/*************************************************************************************************************************
 Class CToolpathAccessor 
**************************************************************************************************************************/
class CToolpathAccessor : public CBase {
public:
	
	/**
	* CToolpathAccessor::CToolpathAccessor - Constructor for ToolpathAccessor class.
	*/
	CToolpathAccessor(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetStorageUUID();
	inline LibMCEnv_uint32 GetLayerCount();
	inline PToolpathLayer LoadLayer(const LibMCEnv_uint32 nLayerIndex);
	inline LibMCEnv_double GetUnits();
};
	
/*************************************************************************************************************************
 Class CBuild 
**************************************************************************************************************************/
class CBuild : public CBase {
public:
	
	/**
	* CBuild::CBuild - Constructor for Build class.
	*/
	CBuild(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetBuildUUID();
	inline std::string GetStorageUUID();
	inline std::string GetStorageSHA256();
	inline LibMCEnv_uint32 GetLayerCount();
	inline void LoadToolpath();
	inline void UnloadToolpath();
	inline bool ToolpathIsLoaded();
	inline PToolpathAccessor CreateToolpathAccessor();
	inline std::string AddBinaryData(const std::string & sName, const std::string & sMIMEType, const CInputVector<LibMCEnv_uint8> & ContentBuffer);
};
	
/*************************************************************************************************************************
 Class CWorkingFileExecution 
**************************************************************************************************************************/
class CWorkingFileExecution : public CBase {
public:
	
	/**
	* CWorkingFileExecution::CWorkingFileExecution - Constructor for WorkingFileExecution class.
	*/
	CWorkingFileExecution(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void GetStatus();
	inline std::string ReturnStdOut();
};
	
/*************************************************************************************************************************
 Class CWorkingFile 
**************************************************************************************************************************/
class CWorkingFile : public CBase {
public:
	
	/**
	* CWorkingFile::CWorkingFile - Constructor for WorkingFile class.
	*/
	CWorkingFile(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetAbsoluteFileName();
	inline LibMCEnv_uint64 GetSize();
	inline std::string CalculateSHA2();
	inline PWorkingFileExecution ExecuteFile();
	inline bool IsManaged();
	inline void MakeManaged();
	inline bool FileExists();
	inline bool DeleteFromDisk();
};
	
/*************************************************************************************************************************
 Class CWorkingFileIterator 
**************************************************************************************************************************/
class CWorkingFileIterator : public CIterator {
public:
	
	/**
	* CWorkingFileIterator::CWorkingFileIterator - Constructor for WorkingFileIterator class.
	*/
	CWorkingFileIterator(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PWorkingFile GetCurrentFile();
};
	
/*************************************************************************************************************************
 Class CWorkingDirectory 
**************************************************************************************************************************/
class CWorkingDirectory : public CBase {
public:
	
	/**
	* CWorkingDirectory::CWorkingDirectory - Constructor for WorkingDirectory class.
	*/
	CWorkingDirectory(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool IsActive();
	inline std::string GetAbsoluteFilePath();
	inline PWorkingFile StoreCustomData(const std::string & sFileName, const CInputVector<LibMCEnv_uint8> & DataBufferBuffer);
	inline PWorkingFile StoreDriverData(const std::string & sFileName, const std::string & sIdentifier);
	inline bool CleanUp();
	inline PWorkingFile AddManagedFile(const std::string & sFileName);
	inline bool HasUnmanagedFiles();
	inline PWorkingFileIterator RetrieveUnmanagedFiles();
	inline PWorkingFileIterator RetrieveManagedFiles();
	inline PWorkingFileIterator RetrieveAllFiles();
};
	
/*************************************************************************************************************************
 Class CDriverEnvironment 
**************************************************************************************************************************/
class CDriverEnvironment : public CBase {
public:
	
	/**
	* CDriverEnvironment::CDriverEnvironment - Constructor for DriverEnvironment class.
	*/
	CDriverEnvironment(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PWorkingDirectory CreateWorkingDirectory();
	inline void RetrieveDriverData(const std::string & sIdentifier, std::vector<LibMCEnv_uint8> & DataBufferBuffer);
	inline PToolpathAccessor CreateToolpathAccessor(const std::string & sStreamUUID);
	inline void RegisterStringParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue);
	inline void RegisterUUIDParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue);
	inline void RegisterDoubleParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_double dDefaultValue);
	inline void RegisterIntegerParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_int64 nDefaultValue);
	inline void RegisterBoolParameter(const std::string & sParameterName, const std::string & sDescription, const bool bDefaultValue);
	inline void SetStringParameter(const std::string & sParameterName, const std::string & sValue);
	inline void SetUUIDParameter(const std::string & sParameterName, const std::string & sValue);
	inline void SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue);
	inline void SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue);
	inline void SetBoolParameter(const std::string & sParameterName, const bool bValue);
};
	
/*************************************************************************************************************************
 Class CSignalTrigger 
**************************************************************************************************************************/
class CSignalTrigger : public CBase {
public:
	
	/**
	* CSignalTrigger::CSignalTrigger - Constructor for SignalTrigger class.
	*/
	CSignalTrigger(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool CanTrigger();
	inline void Trigger();
	inline bool WaitForHandling(const LibMCEnv_uint32 nTimeOut);
	inline std::string GetName();
	inline std::string GetStateMachine();
	inline void SetString(const std::string & sName, const std::string & sValue);
	inline void SetUUID(const std::string & sName, const std::string & sValue);
	inline void SetDouble(const std::string & sName, const LibMCEnv_double dValue);
	inline void SetInteger(const std::string & sName, const LibMCEnv_int64 nValue);
	inline void SetBool(const std::string & sName, const bool bValue);
	inline std::string GetStringResult(const std::string & sName);
	inline std::string GetUUIDResult(const std::string & sName);
	inline LibMCEnv_double GetDoubleResult(const std::string & sName);
	inline LibMCEnv_int64 GetIntegerResult(const std::string & sName);
	inline bool GetBoolResult(const std::string & sName);
};
	
/*************************************************************************************************************************
 Class CSignalHandler 
**************************************************************************************************************************/
class CSignalHandler : public CBase {
public:
	
	/**
	* CSignalHandler::CSignalHandler - Constructor for SignalHandler class.
	*/
	CSignalHandler(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void SignalHandled();
	inline std::string GetName();
	inline std::string GetSignalID();
	inline std::string GetStateMachine();
	inline std::string GetString(const std::string & sName);
	inline std::string GetUUID(const std::string & sName);
	inline LibMCEnv_double GetDouble(const std::string & sName);
	inline LibMCEnv_int64 GetInteger(const std::string & sName);
	inline bool GetBool(const std::string & sName);
	inline void SetStringResult(const std::string & sName, const std::string & sValue);
	inline void SetUUIDResult(const std::string & sName, const std::string & sValue);
	inline void SetDoubleResult(const std::string & sName, const LibMCEnv_double dValue);
	inline void SetIntegerResult(const std::string & sName, const LibMCEnv_int64 nValue);
	inline void SetBoolResult(const std::string & sName, const bool bValue);
};
	
/*************************************************************************************************************************
 Class CStateEnvironment 
**************************************************************************************************************************/
class CStateEnvironment : public CBase {
public:
	
	/**
	* CStateEnvironment::CStateEnvironment - Constructor for StateEnvironment class.
	*/
	CStateEnvironment(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PSignalTrigger PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName);
	inline bool WaitForSignal(const std::string & sSignalName, const LibMCEnv_uint32 nTimeOut, PSignalHandler & pHandlerInstance);
	inline void GetDriverLibrary(const std::string & sDriverName, std::string & sDriverType, LibMCEnv_pvoid & pDriverLookup);
	inline void CreateDriverAccess(const std::string & sDriverName, LibMCEnv_pvoid & pDriverHandle);
	inline PBuild GetBuildJob(const std::string & sBuildUUID);
	inline void UnloadAllToolpathes();
	inline void SetNextState(const std::string & sStateName);
	inline void LogMessage(const std::string & sLogString);
	inline void LogWarning(const std::string & sLogString);
	inline void LogInfo(const std::string & sLogString);
	inline void Sleep(const LibMCEnv_uint32 nDelay);
	inline bool CheckForTermination();
	inline void StoreSignal(const std::string & sName, classParam<CSignalHandler> pHandler);
	inline PSignalHandler RetrieveSignal(const std::string & sName);
	inline void ClearStoredValue(const std::string & sName);
	inline void SetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue);
	inline void SetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue);
	inline void SetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_double dValue);
	inline void SetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_int64 nValue);
	inline void SetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName, const bool bValue);
	inline std::string GetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline std::string GetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline LibMCEnv_double GetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline LibMCEnv_int64 GetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline bool GetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName);
	inline void LoadResourceData(const std::string & sResourceName, std::vector<LibMCEnv_uint8> & ResourceDataBuffer);
};
	
/*************************************************************************************************************************
 Class CUIEnvironment 
**************************************************************************************************************************/
class CUIEnvironment : public CBase {
public:
	
	/**
	* CUIEnvironment::CUIEnvironment - Constructor for UIEnvironment class.
	*/
	CUIEnvironment(CWrapper* pWrapper, LibMCEnvHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PSignalTrigger PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName);
	inline std::string GetMachineState(const std::string & sMachineInstance);
	inline void LogMessage(const std::string & sLogString);
	inline void LogWarning(const std::string & sLogString);
	inline void LogInfo(const std::string & sLogString);
	inline std::string GetStringParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline std::string GetUUIDParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline LibMCEnv_double GetDoubleParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline LibMCEnv_int64 GetIntegerParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline bool GetBoolParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName);
	inline std::string GetEventContext();
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCEnv_uint32 & nMajor, LibMCEnv_uint32 & nMinor, LibMCEnv_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCEnvHandle hInstance = pInstance.GetHandle();
		LibMCEnv_uint32 bytesNeededErrorMessage = 0;
		LibMCEnv_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCEnvHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCEnvHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCEnv_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCEnv_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCEnvResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCEnvException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCEnvResult CWrapper::initWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Iterator_MoveNext = nullptr;
		pWrapperTable->m_Iterator_MovePrevious = nullptr;
		pWrapperTable->m_Iterator_GetCurrent = nullptr;
		pWrapperTable->m_Iterator_Clone = nullptr;
		pWrapperTable->m_Iterator_Count = nullptr;
		pWrapperTable->m_ToolpathLayer_GetLayerDataUUID = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentCount = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentInfo = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID = nullptr;
		pWrapperTable->m_ToolpathLayer_GetSegmentPointData = nullptr;
		pWrapperTable->m_ToolpathLayer_GetZValue = nullptr;
		pWrapperTable->m_ToolpathLayer_GetUnits = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetStorageUUID = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetLayerCount = nullptr;
		pWrapperTable->m_ToolpathAccessor_LoadLayer = nullptr;
		pWrapperTable->m_ToolpathAccessor_GetUnits = nullptr;
		pWrapperTable->m_Build_GetName = nullptr;
		pWrapperTable->m_Build_GetBuildUUID = nullptr;
		pWrapperTable->m_Build_GetStorageUUID = nullptr;
		pWrapperTable->m_Build_GetStorageSHA256 = nullptr;
		pWrapperTable->m_Build_GetLayerCount = nullptr;
		pWrapperTable->m_Build_LoadToolpath = nullptr;
		pWrapperTable->m_Build_UnloadToolpath = nullptr;
		pWrapperTable->m_Build_ToolpathIsLoaded = nullptr;
		pWrapperTable->m_Build_CreateToolpathAccessor = nullptr;
		pWrapperTable->m_Build_AddBinaryData = nullptr;
		pWrapperTable->m_WorkingFileExecution_GetStatus = nullptr;
		pWrapperTable->m_WorkingFileExecution_ReturnStdOut = nullptr;
		pWrapperTable->m_WorkingFile_GetAbsoluteFileName = nullptr;
		pWrapperTable->m_WorkingFile_GetSize = nullptr;
		pWrapperTable->m_WorkingFile_CalculateSHA2 = nullptr;
		pWrapperTable->m_WorkingFile_ExecuteFile = nullptr;
		pWrapperTable->m_WorkingFile_IsManaged = nullptr;
		pWrapperTable->m_WorkingFile_MakeManaged = nullptr;
		pWrapperTable->m_WorkingFile_FileExists = nullptr;
		pWrapperTable->m_WorkingFile_DeleteFromDisk = nullptr;
		pWrapperTable->m_WorkingFileIterator_GetCurrentFile = nullptr;
		pWrapperTable->m_WorkingDirectory_IsActive = nullptr;
		pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath = nullptr;
		pWrapperTable->m_WorkingDirectory_StoreCustomData = nullptr;
		pWrapperTable->m_WorkingDirectory_StoreDriverData = nullptr;
		pWrapperTable->m_WorkingDirectory_CleanUp = nullptr;
		pWrapperTable->m_WorkingDirectory_AddManagedFile = nullptr;
		pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles = nullptr;
		pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles = nullptr;
		pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles = nullptr;
		pWrapperTable->m_WorkingDirectory_RetrieveAllFiles = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory = nullptr;
		pWrapperTable->m_DriverEnvironment_RetrieveDriverData = nullptr;
		pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterStringParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_RegisterBoolParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetStringParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetUUIDParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetDoubleParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetIntegerParameter = nullptr;
		pWrapperTable->m_DriverEnvironment_SetBoolParameter = nullptr;
		pWrapperTable->m_SignalTrigger_CanTrigger = nullptr;
		pWrapperTable->m_SignalTrigger_Trigger = nullptr;
		pWrapperTable->m_SignalTrigger_WaitForHandling = nullptr;
		pWrapperTable->m_SignalTrigger_GetName = nullptr;
		pWrapperTable->m_SignalTrigger_GetStateMachine = nullptr;
		pWrapperTable->m_SignalTrigger_SetString = nullptr;
		pWrapperTable->m_SignalTrigger_SetUUID = nullptr;
		pWrapperTable->m_SignalTrigger_SetDouble = nullptr;
		pWrapperTable->m_SignalTrigger_SetInteger = nullptr;
		pWrapperTable->m_SignalTrigger_SetBool = nullptr;
		pWrapperTable->m_SignalTrigger_GetStringResult = nullptr;
		pWrapperTable->m_SignalTrigger_GetUUIDResult = nullptr;
		pWrapperTable->m_SignalTrigger_GetDoubleResult = nullptr;
		pWrapperTable->m_SignalTrigger_GetIntegerResult = nullptr;
		pWrapperTable->m_SignalTrigger_GetBoolResult = nullptr;
		pWrapperTable->m_SignalHandler_SignalHandled = nullptr;
		pWrapperTable->m_SignalHandler_GetName = nullptr;
		pWrapperTable->m_SignalHandler_GetSignalID = nullptr;
		pWrapperTable->m_SignalHandler_GetStateMachine = nullptr;
		pWrapperTable->m_SignalHandler_GetString = nullptr;
		pWrapperTable->m_SignalHandler_GetUUID = nullptr;
		pWrapperTable->m_SignalHandler_GetDouble = nullptr;
		pWrapperTable->m_SignalHandler_GetInteger = nullptr;
		pWrapperTable->m_SignalHandler_GetBool = nullptr;
		pWrapperTable->m_SignalHandler_SetStringResult = nullptr;
		pWrapperTable->m_SignalHandler_SetUUIDResult = nullptr;
		pWrapperTable->m_SignalHandler_SetDoubleResult = nullptr;
		pWrapperTable->m_SignalHandler_SetIntegerResult = nullptr;
		pWrapperTable->m_SignalHandler_SetBoolResult = nullptr;
		pWrapperTable->m_StateEnvironment_PrepareSignal = nullptr;
		pWrapperTable->m_StateEnvironment_WaitForSignal = nullptr;
		pWrapperTable->m_StateEnvironment_GetDriverLibrary = nullptr;
		pWrapperTable->m_StateEnvironment_CreateDriverAccess = nullptr;
		pWrapperTable->m_StateEnvironment_GetBuildJob = nullptr;
		pWrapperTable->m_StateEnvironment_UnloadAllToolpathes = nullptr;
		pWrapperTable->m_StateEnvironment_SetNextState = nullptr;
		pWrapperTable->m_StateEnvironment_LogMessage = nullptr;
		pWrapperTable->m_StateEnvironment_LogWarning = nullptr;
		pWrapperTable->m_StateEnvironment_LogInfo = nullptr;
		pWrapperTable->m_StateEnvironment_Sleep = nullptr;
		pWrapperTable->m_StateEnvironment_CheckForTermination = nullptr;
		pWrapperTable->m_StateEnvironment_StoreSignal = nullptr;
		pWrapperTable->m_StateEnvironment_RetrieveSignal = nullptr;
		pWrapperTable->m_StateEnvironment_ClearStoredValue = nullptr;
		pWrapperTable->m_StateEnvironment_SetStringParameter = nullptr;
		pWrapperTable->m_StateEnvironment_SetUUIDParameter = nullptr;
		pWrapperTable->m_StateEnvironment_SetDoubleParameter = nullptr;
		pWrapperTable->m_StateEnvironment_SetIntegerParameter = nullptr;
		pWrapperTable->m_StateEnvironment_SetBoolParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetStringParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetUUIDParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetDoubleParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetIntegerParameter = nullptr;
		pWrapperTable->m_StateEnvironment_GetBoolParameter = nullptr;
		pWrapperTable->m_StateEnvironment_LoadResourceData = nullptr;
		pWrapperTable->m_UIEnvironment_PrepareSignal = nullptr;
		pWrapperTable->m_UIEnvironment_GetMachineState = nullptr;
		pWrapperTable->m_UIEnvironment_LogMessage = nullptr;
		pWrapperTable->m_UIEnvironment_LogWarning = nullptr;
		pWrapperTable->m_UIEnvironment_LogInfo = nullptr;
		pWrapperTable->m_UIEnvironment_GetStringParameter = nullptr;
		pWrapperTable->m_UIEnvironment_GetUUIDParameter = nullptr;
		pWrapperTable->m_UIEnvironment_GetDoubleParameter = nullptr;
		pWrapperTable->m_UIEnvironment_GetIntegerParameter = nullptr;
		pWrapperTable->m_UIEnvironment_GetBoolParameter = nullptr;
		pWrapperTable->m_UIEnvironment_GetEventContext = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		
		return LIBMCENV_SUCCESS;
	}

	inline LibMCEnvResult CWrapper::releaseWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCENV_SUCCESS;
	}

	inline LibMCEnvResult CWrapper::loadWrapperTable(sLibMCEnvDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = (int)strlen(pLibraryFileName);
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCENV_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCENV_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCENV_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCEnvIterator_MoveNextPtr) GetProcAddress(hLibrary, "libmcenv_iterator_movenext");
		#else // _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCEnvIterator_MoveNextPtr) dlsym(hLibrary, "libmcenv_iterator_movenext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MoveNext == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCEnvIterator_MovePreviousPtr) GetProcAddress(hLibrary, "libmcenv_iterator_moveprevious");
		#else // _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCEnvIterator_MovePreviousPtr) dlsym(hLibrary, "libmcenv_iterator_moveprevious");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MovePrevious == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCEnvIterator_GetCurrentPtr) GetProcAddress(hLibrary, "libmcenv_iterator_getcurrent");
		#else // _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCEnvIterator_GetCurrentPtr) dlsym(hLibrary, "libmcenv_iterator_getcurrent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_GetCurrent == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCEnvIterator_ClonePtr) GetProcAddress(hLibrary, "libmcenv_iterator_clone");
		#else // _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCEnvIterator_ClonePtr) dlsym(hLibrary, "libmcenv_iterator_clone");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Clone == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCEnvIterator_CountPtr) GetProcAddress(hLibrary, "libmcenv_iterator_count");
		#else // _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCEnvIterator_CountPtr) dlsym(hLibrary, "libmcenv_iterator_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Count == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetLayerDataUUID = (PLibMCEnvToolpathLayer_GetLayerDataUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getlayerdatauuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetLayerDataUUID = (PLibMCEnvToolpathLayer_GetLayerDataUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getlayerdatauuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetLayerDataUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentCount = (PLibMCEnvToolpathLayer_GetSegmentCountPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentcount");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentCount = (PLibMCEnvToolpathLayer_GetSegmentCountPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentcount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentInfo = (PLibMCEnvToolpathLayer_GetSegmentInfoPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentinfo");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentInfo = (PLibMCEnvToolpathLayer_GetSegmentInfoPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentinfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID = (PLibMCEnvToolpathLayer_GetSegmentProfileUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID = (PLibMCEnvToolpathLayer_GetSegmentProfileUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofileuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue = (PLibMCEnvToolpathLayer_GetSegmentProfileValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofilevalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue = (PLibMCEnvToolpathLayer_GetSegmentProfileValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofilevalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue = (PLibMCEnvToolpathLayer_GetSegmentProfileTypedValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiletypedvalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue = (PLibMCEnvToolpathLayer_GetSegmentProfileTypedValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentprofiletypedvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID = (PLibMCEnvToolpathLayer_GetSegmentPartUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentpartuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID = (PLibMCEnvToolpathLayer_GetSegmentPartUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentpartuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPointData = (PLibMCEnvToolpathLayer_GetSegmentPointDataPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getsegmentpointdata");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetSegmentPointData = (PLibMCEnvToolpathLayer_GetSegmentPointDataPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getsegmentpointdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetSegmentPointData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetZValue = (PLibMCEnvToolpathLayer_GetZValuePtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getzvalue");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetZValue = (PLibMCEnvToolpathLayer_GetZValuePtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getzvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetZValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathLayer_GetUnits = (PLibMCEnvToolpathLayer_GetUnitsPtr) GetProcAddress(hLibrary, "libmcenv_toolpathlayer_getunits");
		#else // _WIN32
		pWrapperTable->m_ToolpathLayer_GetUnits = (PLibMCEnvToolpathLayer_GetUnitsPtr) dlsym(hLibrary, "libmcenv_toolpathlayer_getunits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathLayer_GetUnits == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetStorageUUID = (PLibMCEnvToolpathAccessor_GetStorageUUIDPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getstorageuuid");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetStorageUUID = (PLibMCEnvToolpathAccessor_GetStorageUUIDPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getstorageuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetStorageUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetLayerCount = (PLibMCEnvToolpathAccessor_GetLayerCountPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getlayercount");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetLayerCount = (PLibMCEnvToolpathAccessor_GetLayerCountPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetLayerCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_LoadLayer = (PLibMCEnvToolpathAccessor_LoadLayerPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_loadlayer");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_LoadLayer = (PLibMCEnvToolpathAccessor_LoadLayerPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_loadlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_LoadLayer == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ToolpathAccessor_GetUnits = (PLibMCEnvToolpathAccessor_GetUnitsPtr) GetProcAddress(hLibrary, "libmcenv_toolpathaccessor_getunits");
		#else // _WIN32
		pWrapperTable->m_ToolpathAccessor_GetUnits = (PLibMCEnvToolpathAccessor_GetUnitsPtr) dlsym(hLibrary, "libmcenv_toolpathaccessor_getunits");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ToolpathAccessor_GetUnits == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetName = (PLibMCEnvBuild_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_build_getname");
		#else // _WIN32
		pWrapperTable->m_Build_GetName = (PLibMCEnvBuild_GetNamePtr) dlsym(hLibrary, "libmcenv_build_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetBuildUUID = (PLibMCEnvBuild_GetBuildUUIDPtr) GetProcAddress(hLibrary, "libmcenv_build_getbuilduuid");
		#else // _WIN32
		pWrapperTable->m_Build_GetBuildUUID = (PLibMCEnvBuild_GetBuildUUIDPtr) dlsym(hLibrary, "libmcenv_build_getbuilduuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetBuildUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetStorageUUID = (PLibMCEnvBuild_GetStorageUUIDPtr) GetProcAddress(hLibrary, "libmcenv_build_getstorageuuid");
		#else // _WIN32
		pWrapperTable->m_Build_GetStorageUUID = (PLibMCEnvBuild_GetStorageUUIDPtr) dlsym(hLibrary, "libmcenv_build_getstorageuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetStorageUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetStorageSHA256 = (PLibMCEnvBuild_GetStorageSHA256Ptr) GetProcAddress(hLibrary, "libmcenv_build_getstoragesha256");
		#else // _WIN32
		pWrapperTable->m_Build_GetStorageSHA256 = (PLibMCEnvBuild_GetStorageSHA256Ptr) dlsym(hLibrary, "libmcenv_build_getstoragesha256");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetStorageSHA256 == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_GetLayerCount = (PLibMCEnvBuild_GetLayerCountPtr) GetProcAddress(hLibrary, "libmcenv_build_getlayercount");
		#else // _WIN32
		pWrapperTable->m_Build_GetLayerCount = (PLibMCEnvBuild_GetLayerCountPtr) dlsym(hLibrary, "libmcenv_build_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_GetLayerCount == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_LoadToolpath = (PLibMCEnvBuild_LoadToolpathPtr) GetProcAddress(hLibrary, "libmcenv_build_loadtoolpath");
		#else // _WIN32
		pWrapperTable->m_Build_LoadToolpath = (PLibMCEnvBuild_LoadToolpathPtr) dlsym(hLibrary, "libmcenv_build_loadtoolpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_LoadToolpath == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_UnloadToolpath = (PLibMCEnvBuild_UnloadToolpathPtr) GetProcAddress(hLibrary, "libmcenv_build_unloadtoolpath");
		#else // _WIN32
		pWrapperTable->m_Build_UnloadToolpath = (PLibMCEnvBuild_UnloadToolpathPtr) dlsym(hLibrary, "libmcenv_build_unloadtoolpath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_UnloadToolpath == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_ToolpathIsLoaded = (PLibMCEnvBuild_ToolpathIsLoadedPtr) GetProcAddress(hLibrary, "libmcenv_build_toolpathisloaded");
		#else // _WIN32
		pWrapperTable->m_Build_ToolpathIsLoaded = (PLibMCEnvBuild_ToolpathIsLoadedPtr) dlsym(hLibrary, "libmcenv_build_toolpathisloaded");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_ToolpathIsLoaded == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_CreateToolpathAccessor = (PLibMCEnvBuild_CreateToolpathAccessorPtr) GetProcAddress(hLibrary, "libmcenv_build_createtoolpathaccessor");
		#else // _WIN32
		pWrapperTable->m_Build_CreateToolpathAccessor = (PLibMCEnvBuild_CreateToolpathAccessorPtr) dlsym(hLibrary, "libmcenv_build_createtoolpathaccessor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_CreateToolpathAccessor == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Build_AddBinaryData = (PLibMCEnvBuild_AddBinaryDataPtr) GetProcAddress(hLibrary, "libmcenv_build_addbinarydata");
		#else // _WIN32
		pWrapperTable->m_Build_AddBinaryData = (PLibMCEnvBuild_AddBinaryDataPtr) dlsym(hLibrary, "libmcenv_build_addbinarydata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Build_AddBinaryData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFileExecution_GetStatus = (PLibMCEnvWorkingFileExecution_GetStatusPtr) GetProcAddress(hLibrary, "libmcenv_workingfileexecution_getstatus");
		#else // _WIN32
		pWrapperTable->m_WorkingFileExecution_GetStatus = (PLibMCEnvWorkingFileExecution_GetStatusPtr) dlsym(hLibrary, "libmcenv_workingfileexecution_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFileExecution_GetStatus == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFileExecution_ReturnStdOut = (PLibMCEnvWorkingFileExecution_ReturnStdOutPtr) GetProcAddress(hLibrary, "libmcenv_workingfileexecution_returnstdout");
		#else // _WIN32
		pWrapperTable->m_WorkingFileExecution_ReturnStdOut = (PLibMCEnvWorkingFileExecution_ReturnStdOutPtr) dlsym(hLibrary, "libmcenv_workingfileexecution_returnstdout");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFileExecution_ReturnStdOut == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_GetAbsoluteFileName = (PLibMCEnvWorkingFile_GetAbsoluteFileNamePtr) GetProcAddress(hLibrary, "libmcenv_workingfile_getabsolutefilename");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_GetAbsoluteFileName = (PLibMCEnvWorkingFile_GetAbsoluteFileNamePtr) dlsym(hLibrary, "libmcenv_workingfile_getabsolutefilename");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_GetAbsoluteFileName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_GetSize = (PLibMCEnvWorkingFile_GetSizePtr) GetProcAddress(hLibrary, "libmcenv_workingfile_getsize");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_GetSize = (PLibMCEnvWorkingFile_GetSizePtr) dlsym(hLibrary, "libmcenv_workingfile_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_GetSize == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_CalculateSHA2 = (PLibMCEnvWorkingFile_CalculateSHA2Ptr) GetProcAddress(hLibrary, "libmcenv_workingfile_calculatesha2");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_CalculateSHA2 = (PLibMCEnvWorkingFile_CalculateSHA2Ptr) dlsym(hLibrary, "libmcenv_workingfile_calculatesha2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_CalculateSHA2 == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_ExecuteFile = (PLibMCEnvWorkingFile_ExecuteFilePtr) GetProcAddress(hLibrary, "libmcenv_workingfile_executefile");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_ExecuteFile = (PLibMCEnvWorkingFile_ExecuteFilePtr) dlsym(hLibrary, "libmcenv_workingfile_executefile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_ExecuteFile == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_IsManaged = (PLibMCEnvWorkingFile_IsManagedPtr) GetProcAddress(hLibrary, "libmcenv_workingfile_ismanaged");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_IsManaged = (PLibMCEnvWorkingFile_IsManagedPtr) dlsym(hLibrary, "libmcenv_workingfile_ismanaged");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_IsManaged == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_MakeManaged = (PLibMCEnvWorkingFile_MakeManagedPtr) GetProcAddress(hLibrary, "libmcenv_workingfile_makemanaged");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_MakeManaged = (PLibMCEnvWorkingFile_MakeManagedPtr) dlsym(hLibrary, "libmcenv_workingfile_makemanaged");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_MakeManaged == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_FileExists = (PLibMCEnvWorkingFile_FileExistsPtr) GetProcAddress(hLibrary, "libmcenv_workingfile_fileexists");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_FileExists = (PLibMCEnvWorkingFile_FileExistsPtr) dlsym(hLibrary, "libmcenv_workingfile_fileexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_FileExists == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFile_DeleteFromDisk = (PLibMCEnvWorkingFile_DeleteFromDiskPtr) GetProcAddress(hLibrary, "libmcenv_workingfile_deletefromdisk");
		#else // _WIN32
		pWrapperTable->m_WorkingFile_DeleteFromDisk = (PLibMCEnvWorkingFile_DeleteFromDiskPtr) dlsym(hLibrary, "libmcenv_workingfile_deletefromdisk");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFile_DeleteFromDisk == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingFileIterator_GetCurrentFile = (PLibMCEnvWorkingFileIterator_GetCurrentFilePtr) GetProcAddress(hLibrary, "libmcenv_workingfileiterator_getcurrentfile");
		#else // _WIN32
		pWrapperTable->m_WorkingFileIterator_GetCurrentFile = (PLibMCEnvWorkingFileIterator_GetCurrentFilePtr) dlsym(hLibrary, "libmcenv_workingfileiterator_getcurrentfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingFileIterator_GetCurrentFile == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_IsActive = (PLibMCEnvWorkingDirectory_IsActivePtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_isactive");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_IsActive = (PLibMCEnvWorkingDirectory_IsActivePtr) dlsym(hLibrary, "libmcenv_workingdirectory_isactive");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_IsActive == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath = (PLibMCEnvWorkingDirectory_GetAbsoluteFilePathPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_getabsolutefilepath");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath = (PLibMCEnvWorkingDirectory_GetAbsoluteFilePathPtr) dlsym(hLibrary, "libmcenv_workingdirectory_getabsolutefilepath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomData = (PLibMCEnvWorkingDirectory_StoreCustomDataPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_storecustomdata");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_StoreCustomData = (PLibMCEnvWorkingDirectory_StoreCustomDataPtr) dlsym(hLibrary, "libmcenv_workingdirectory_storecustomdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_StoreCustomData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_StoreDriverData = (PLibMCEnvWorkingDirectory_StoreDriverDataPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_storedriverdata");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_StoreDriverData = (PLibMCEnvWorkingDirectory_StoreDriverDataPtr) dlsym(hLibrary, "libmcenv_workingdirectory_storedriverdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_StoreDriverData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_CleanUp = (PLibMCEnvWorkingDirectory_CleanUpPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_cleanup");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_CleanUp = (PLibMCEnvWorkingDirectory_CleanUpPtr) dlsym(hLibrary, "libmcenv_workingdirectory_cleanup");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_CleanUp == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_AddManagedFile = (PLibMCEnvWorkingDirectory_AddManagedFilePtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_addmanagedfile");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_AddManagedFile = (PLibMCEnvWorkingDirectory_AddManagedFilePtr) dlsym(hLibrary, "libmcenv_workingdirectory_addmanagedfile");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_AddManagedFile == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles = (PLibMCEnvWorkingDirectory_HasUnmanagedFilesPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_hasunmanagedfiles");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles = (PLibMCEnvWorkingDirectory_HasUnmanagedFilesPtr) dlsym(hLibrary, "libmcenv_workingdirectory_hasunmanagedfiles");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles = (PLibMCEnvWorkingDirectory_RetrieveUnmanagedFilesPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_retrieveunmanagedfiles");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles = (PLibMCEnvWorkingDirectory_RetrieveUnmanagedFilesPtr) dlsym(hLibrary, "libmcenv_workingdirectory_retrieveunmanagedfiles");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles = (PLibMCEnvWorkingDirectory_RetrieveManagedFilesPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_retrievemanagedfiles");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles = (PLibMCEnvWorkingDirectory_RetrieveManagedFilesPtr) dlsym(hLibrary, "libmcenv_workingdirectory_retrievemanagedfiles");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveAllFiles = (PLibMCEnvWorkingDirectory_RetrieveAllFilesPtr) GetProcAddress(hLibrary, "libmcenv_workingdirectory_retrieveallfiles");
		#else // _WIN32
		pWrapperTable->m_WorkingDirectory_RetrieveAllFiles = (PLibMCEnvWorkingDirectory_RetrieveAllFilesPtr) dlsym(hLibrary, "libmcenv_workingdirectory_retrieveallfiles");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_WorkingDirectory_RetrieveAllFiles == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory = (PLibMCEnvDriverEnvironment_CreateWorkingDirectoryPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createworkingdirectory");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory = (PLibMCEnvDriverEnvironment_CreateWorkingDirectoryPtr) dlsym(hLibrary, "libmcenv_driverenvironment_createworkingdirectory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RetrieveDriverData = (PLibMCEnvDriverEnvironment_RetrieveDriverDataPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_retrievedriverdata");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RetrieveDriverData = (PLibMCEnvDriverEnvironment_RetrieveDriverDataPtr) dlsym(hLibrary, "libmcenv_driverenvironment_retrievedriverdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RetrieveDriverData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor = (PLibMCEnvDriverEnvironment_CreateToolpathAccessorPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_createtoolpathaccessor");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor = (PLibMCEnvDriverEnvironment_CreateToolpathAccessorPtr) dlsym(hLibrary, "libmcenv_driverenvironment_createtoolpathaccessor");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterStringParameter = (PLibMCEnvDriverEnvironment_RegisterStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registerstringparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterStringParameter = (PLibMCEnvDriverEnvironment_RegisterStringParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registerstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter = (PLibMCEnvDriverEnvironment_RegisterUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registeruuidparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter = (PLibMCEnvDriverEnvironment_RegisterUUIDParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registeruuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter = (PLibMCEnvDriverEnvironment_RegisterDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registerdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter = (PLibMCEnvDriverEnvironment_RegisterDoubleParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registerdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter = (PLibMCEnvDriverEnvironment_RegisterIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registerintegerparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter = (PLibMCEnvDriverEnvironment_RegisterIntegerParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registerintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterBoolParameter = (PLibMCEnvDriverEnvironment_RegisterBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_registerboolparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_RegisterBoolParameter = (PLibMCEnvDriverEnvironment_RegisterBoolParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_registerboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_RegisterBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetStringParameter = (PLibMCEnvDriverEnvironment_SetStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setstringparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetStringParameter = (PLibMCEnvDriverEnvironment_SetStringParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetUUIDParameter = (PLibMCEnvDriverEnvironment_SetUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setuuidparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetUUIDParameter = (PLibMCEnvDriverEnvironment_SetUUIDParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetDoubleParameter = (PLibMCEnvDriverEnvironment_SetDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetDoubleParameter = (PLibMCEnvDriverEnvironment_SetDoubleParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetIntegerParameter = (PLibMCEnvDriverEnvironment_SetIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setintegerparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetIntegerParameter = (PLibMCEnvDriverEnvironment_SetIntegerParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DriverEnvironment_SetBoolParameter = (PLibMCEnvDriverEnvironment_SetBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_driverenvironment_setboolparameter");
		#else // _WIN32
		pWrapperTable->m_DriverEnvironment_SetBoolParameter = (PLibMCEnvDriverEnvironment_SetBoolParameterPtr) dlsym(hLibrary, "libmcenv_driverenvironment_setboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DriverEnvironment_SetBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_CanTrigger = (PLibMCEnvSignalTrigger_CanTriggerPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_cantrigger");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_CanTrigger = (PLibMCEnvSignalTrigger_CanTriggerPtr) dlsym(hLibrary, "libmcenv_signaltrigger_cantrigger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_CanTrigger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_Trigger = (PLibMCEnvSignalTrigger_TriggerPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_trigger");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_Trigger = (PLibMCEnvSignalTrigger_TriggerPtr) dlsym(hLibrary, "libmcenv_signaltrigger_trigger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_Trigger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_WaitForHandling = (PLibMCEnvSignalTrigger_WaitForHandlingPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_waitforhandling");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_WaitForHandling = (PLibMCEnvSignalTrigger_WaitForHandlingPtr) dlsym(hLibrary, "libmcenv_signaltrigger_waitforhandling");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_WaitForHandling == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetName = (PLibMCEnvSignalTrigger_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getname");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetName = (PLibMCEnvSignalTrigger_GetNamePtr) dlsym(hLibrary, "libmcenv_signaltrigger_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetStateMachine = (PLibMCEnvSignalTrigger_GetStateMachinePtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getstatemachine");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetStateMachine = (PLibMCEnvSignalTrigger_GetStateMachinePtr) dlsym(hLibrary, "libmcenv_signaltrigger_getstatemachine");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetStateMachine == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetString = (PLibMCEnvSignalTrigger_SetStringPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setstring");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetString = (PLibMCEnvSignalTrigger_SetStringPtr) dlsym(hLibrary, "libmcenv_signaltrigger_setstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetUUID = (PLibMCEnvSignalTrigger_SetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setuuid");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetUUID = (PLibMCEnvSignalTrigger_SetUUIDPtr) dlsym(hLibrary, "libmcenv_signaltrigger_setuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetDouble = (PLibMCEnvSignalTrigger_SetDoublePtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setdouble");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetDouble = (PLibMCEnvSignalTrigger_SetDoublePtr) dlsym(hLibrary, "libmcenv_signaltrigger_setdouble");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetDouble == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetInteger = (PLibMCEnvSignalTrigger_SetIntegerPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setinteger");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetInteger = (PLibMCEnvSignalTrigger_SetIntegerPtr) dlsym(hLibrary, "libmcenv_signaltrigger_setinteger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetInteger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_SetBool = (PLibMCEnvSignalTrigger_SetBoolPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_setbool");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_SetBool = (PLibMCEnvSignalTrigger_SetBoolPtr) dlsym(hLibrary, "libmcenv_signaltrigger_setbool");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_SetBool == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetStringResult = (PLibMCEnvSignalTrigger_GetStringResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getstringresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetStringResult = (PLibMCEnvSignalTrigger_GetStringResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getstringresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetStringResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetUUIDResult = (PLibMCEnvSignalTrigger_GetUUIDResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getuuidresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetUUIDResult = (PLibMCEnvSignalTrigger_GetUUIDResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getuuidresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetUUIDResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetDoubleResult = (PLibMCEnvSignalTrigger_GetDoubleResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getdoubleresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetDoubleResult = (PLibMCEnvSignalTrigger_GetDoubleResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getdoubleresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetDoubleResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetIntegerResult = (PLibMCEnvSignalTrigger_GetIntegerResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getintegerresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetIntegerResult = (PLibMCEnvSignalTrigger_GetIntegerResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getintegerresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetIntegerResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalTrigger_GetBoolResult = (PLibMCEnvSignalTrigger_GetBoolResultPtr) GetProcAddress(hLibrary, "libmcenv_signaltrigger_getboolresult");
		#else // _WIN32
		pWrapperTable->m_SignalTrigger_GetBoolResult = (PLibMCEnvSignalTrigger_GetBoolResultPtr) dlsym(hLibrary, "libmcenv_signaltrigger_getboolresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalTrigger_GetBoolResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SignalHandled = (PLibMCEnvSignalHandler_SignalHandledPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_signalhandled");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SignalHandled = (PLibMCEnvSignalHandler_SignalHandledPtr) dlsym(hLibrary, "libmcenv_signalhandler_signalhandled");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SignalHandled == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetName = (PLibMCEnvSignalHandler_GetNamePtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getname");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetName = (PLibMCEnvSignalHandler_GetNamePtr) dlsym(hLibrary, "libmcenv_signalhandler_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetName == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetSignalID = (PLibMCEnvSignalHandler_GetSignalIDPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getsignalid");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetSignalID = (PLibMCEnvSignalHandler_GetSignalIDPtr) dlsym(hLibrary, "libmcenv_signalhandler_getsignalid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetSignalID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetStateMachine = (PLibMCEnvSignalHandler_GetStateMachinePtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getstatemachine");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetStateMachine = (PLibMCEnvSignalHandler_GetStateMachinePtr) dlsym(hLibrary, "libmcenv_signalhandler_getstatemachine");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetStateMachine == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetString = (PLibMCEnvSignalHandler_GetStringPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getstring");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetString = (PLibMCEnvSignalHandler_GetStringPtr) dlsym(hLibrary, "libmcenv_signalhandler_getstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetString == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetUUID = (PLibMCEnvSignalHandler_GetUUIDPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getuuid");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetUUID = (PLibMCEnvSignalHandler_GetUUIDPtr) dlsym(hLibrary, "libmcenv_signalhandler_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetUUID == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetDouble = (PLibMCEnvSignalHandler_GetDoublePtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getdouble");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetDouble = (PLibMCEnvSignalHandler_GetDoublePtr) dlsym(hLibrary, "libmcenv_signalhandler_getdouble");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetDouble == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetInteger = (PLibMCEnvSignalHandler_GetIntegerPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getinteger");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetInteger = (PLibMCEnvSignalHandler_GetIntegerPtr) dlsym(hLibrary, "libmcenv_signalhandler_getinteger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetInteger == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_GetBool = (PLibMCEnvSignalHandler_GetBoolPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_getbool");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_GetBool = (PLibMCEnvSignalHandler_GetBoolPtr) dlsym(hLibrary, "libmcenv_signalhandler_getbool");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_GetBool == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetStringResult = (PLibMCEnvSignalHandler_SetStringResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setstringresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetStringResult = (PLibMCEnvSignalHandler_SetStringResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setstringresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetStringResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetUUIDResult = (PLibMCEnvSignalHandler_SetUUIDResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setuuidresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetUUIDResult = (PLibMCEnvSignalHandler_SetUUIDResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setuuidresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetUUIDResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetDoubleResult = (PLibMCEnvSignalHandler_SetDoubleResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setdoubleresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetDoubleResult = (PLibMCEnvSignalHandler_SetDoubleResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setdoubleresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetDoubleResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetIntegerResult = (PLibMCEnvSignalHandler_SetIntegerResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setintegerresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetIntegerResult = (PLibMCEnvSignalHandler_SetIntegerResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setintegerresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetIntegerResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SignalHandler_SetBoolResult = (PLibMCEnvSignalHandler_SetBoolResultPtr) GetProcAddress(hLibrary, "libmcenv_signalhandler_setboolresult");
		#else // _WIN32
		pWrapperTable->m_SignalHandler_SetBoolResult = (PLibMCEnvSignalHandler_SetBoolResultPtr) dlsym(hLibrary, "libmcenv_signalhandler_setboolresult");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SignalHandler_SetBoolResult == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_PrepareSignal = (PLibMCEnvStateEnvironment_PrepareSignalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_preparesignal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_PrepareSignal = (PLibMCEnvStateEnvironment_PrepareSignalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_preparesignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_PrepareSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_WaitForSignal = (PLibMCEnvStateEnvironment_WaitForSignalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_waitforsignal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_WaitForSignal = (PLibMCEnvStateEnvironment_WaitForSignalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_waitforsignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_WaitForSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetDriverLibrary = (PLibMCEnvStateEnvironment_GetDriverLibraryPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getdriverlibrary");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetDriverLibrary = (PLibMCEnvStateEnvironment_GetDriverLibraryPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getdriverlibrary");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetDriverLibrary == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CreateDriverAccess = (PLibMCEnvStateEnvironment_CreateDriverAccessPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_createdriveraccess");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CreateDriverAccess = (PLibMCEnvStateEnvironment_CreateDriverAccessPtr) dlsym(hLibrary, "libmcenv_stateenvironment_createdriveraccess");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CreateDriverAccess == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetBuildJob = (PLibMCEnvStateEnvironment_GetBuildJobPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getbuildjob");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetBuildJob = (PLibMCEnvStateEnvironment_GetBuildJobPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getbuildjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetBuildJob == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_UnloadAllToolpathes = (PLibMCEnvStateEnvironment_UnloadAllToolpathesPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_unloadalltoolpathes");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_UnloadAllToolpathes = (PLibMCEnvStateEnvironment_UnloadAllToolpathesPtr) dlsym(hLibrary, "libmcenv_stateenvironment_unloadalltoolpathes");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_UnloadAllToolpathes == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetNextState = (PLibMCEnvStateEnvironment_SetNextStatePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setnextstate");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetNextState = (PLibMCEnvStateEnvironment_SetNextStatePtr) dlsym(hLibrary, "libmcenv_stateenvironment_setnextstate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetNextState == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LogMessage = (PLibMCEnvStateEnvironment_LogMessagePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_logmessage");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LogMessage = (PLibMCEnvStateEnvironment_LogMessagePtr) dlsym(hLibrary, "libmcenv_stateenvironment_logmessage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LogMessage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LogWarning = (PLibMCEnvStateEnvironment_LogWarningPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_logwarning");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LogWarning = (PLibMCEnvStateEnvironment_LogWarningPtr) dlsym(hLibrary, "libmcenv_stateenvironment_logwarning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LogWarning == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LogInfo = (PLibMCEnvStateEnvironment_LogInfoPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_loginfo");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LogInfo = (PLibMCEnvStateEnvironment_LogInfoPtr) dlsym(hLibrary, "libmcenv_stateenvironment_loginfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LogInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_Sleep = (PLibMCEnvStateEnvironment_SleepPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_sleep");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_Sleep = (PLibMCEnvStateEnvironment_SleepPtr) dlsym(hLibrary, "libmcenv_stateenvironment_sleep");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_Sleep == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_CheckForTermination = (PLibMCEnvStateEnvironment_CheckForTerminationPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_checkfortermination");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_CheckForTermination = (PLibMCEnvStateEnvironment_CheckForTerminationPtr) dlsym(hLibrary, "libmcenv_stateenvironment_checkfortermination");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_CheckForTermination == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_StoreSignal = (PLibMCEnvStateEnvironment_StoreSignalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_storesignal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_StoreSignal = (PLibMCEnvStateEnvironment_StoreSignalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_storesignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_StoreSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_RetrieveSignal = (PLibMCEnvStateEnvironment_RetrieveSignalPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_retrievesignal");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_RetrieveSignal = (PLibMCEnvStateEnvironment_RetrieveSignalPtr) dlsym(hLibrary, "libmcenv_stateenvironment_retrievesignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_RetrieveSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_ClearStoredValue = (PLibMCEnvStateEnvironment_ClearStoredValuePtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_clearstoredvalue");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_ClearStoredValue = (PLibMCEnvStateEnvironment_ClearStoredValuePtr) dlsym(hLibrary, "libmcenv_stateenvironment_clearstoredvalue");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_ClearStoredValue == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetStringParameter = (PLibMCEnvStateEnvironment_SetStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setstringparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetStringParameter = (PLibMCEnvStateEnvironment_SetStringParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetUUIDParameter = (PLibMCEnvStateEnvironment_SetUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setuuidparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetUUIDParameter = (PLibMCEnvStateEnvironment_SetUUIDParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetDoubleParameter = (PLibMCEnvStateEnvironment_SetDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetDoubleParameter = (PLibMCEnvStateEnvironment_SetDoubleParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetIntegerParameter = (PLibMCEnvStateEnvironment_SetIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setintegerparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetIntegerParameter = (PLibMCEnvStateEnvironment_SetIntegerParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_SetBoolParameter = (PLibMCEnvStateEnvironment_SetBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_setboolparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_SetBoolParameter = (PLibMCEnvStateEnvironment_SetBoolParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_setboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_SetBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetStringParameter = (PLibMCEnvStateEnvironment_GetStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getstringparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetStringParameter = (PLibMCEnvStateEnvironment_GetStringParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetUUIDParameter = (PLibMCEnvStateEnvironment_GetUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getuuidparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetUUIDParameter = (PLibMCEnvStateEnvironment_GetUUIDParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetDoubleParameter = (PLibMCEnvStateEnvironment_GetDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetDoubleParameter = (PLibMCEnvStateEnvironment_GetDoubleParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetIntegerParameter = (PLibMCEnvStateEnvironment_GetIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getintegerparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetIntegerParameter = (PLibMCEnvStateEnvironment_GetIntegerParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_GetBoolParameter = (PLibMCEnvStateEnvironment_GetBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_getboolparameter");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_GetBoolParameter = (PLibMCEnvStateEnvironment_GetBoolParameterPtr) dlsym(hLibrary, "libmcenv_stateenvironment_getboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_GetBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StateEnvironment_LoadResourceData = (PLibMCEnvStateEnvironment_LoadResourceDataPtr) GetProcAddress(hLibrary, "libmcenv_stateenvironment_loadresourcedata");
		#else // _WIN32
		pWrapperTable->m_StateEnvironment_LoadResourceData = (PLibMCEnvStateEnvironment_LoadResourceDataPtr) dlsym(hLibrary, "libmcenv_stateenvironment_loadresourcedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StateEnvironment_LoadResourceData == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_PrepareSignal = (PLibMCEnvUIEnvironment_PrepareSignalPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_preparesignal");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_PrepareSignal = (PLibMCEnvUIEnvironment_PrepareSignalPtr) dlsym(hLibrary, "libmcenv_uienvironment_preparesignal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_PrepareSignal == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineState = (PLibMCEnvUIEnvironment_GetMachineStatePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getmachinestate");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetMachineState = (PLibMCEnvUIEnvironment_GetMachineStatePtr) dlsym(hLibrary, "libmcenv_uienvironment_getmachinestate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetMachineState == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_LogMessage = (PLibMCEnvUIEnvironment_LogMessagePtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_logmessage");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_LogMessage = (PLibMCEnvUIEnvironment_LogMessagePtr) dlsym(hLibrary, "libmcenv_uienvironment_logmessage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_LogMessage == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_LogWarning = (PLibMCEnvUIEnvironment_LogWarningPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_logwarning");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_LogWarning = (PLibMCEnvUIEnvironment_LogWarningPtr) dlsym(hLibrary, "libmcenv_uienvironment_logwarning");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_LogWarning == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_LogInfo = (PLibMCEnvUIEnvironment_LogInfoPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_loginfo");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_LogInfo = (PLibMCEnvUIEnvironment_LogInfoPtr) dlsym(hLibrary, "libmcenv_uienvironment_loginfo");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_LogInfo == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetStringParameter = (PLibMCEnvUIEnvironment_GetStringParameterPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getstringparameter");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetStringParameter = (PLibMCEnvUIEnvironment_GetStringParameterPtr) dlsym(hLibrary, "libmcenv_uienvironment_getstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetStringParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetUUIDParameter = (PLibMCEnvUIEnvironment_GetUUIDParameterPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getuuidparameter");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetUUIDParameter = (PLibMCEnvUIEnvironment_GetUUIDParameterPtr) dlsym(hLibrary, "libmcenv_uienvironment_getuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetUUIDParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetDoubleParameter = (PLibMCEnvUIEnvironment_GetDoubleParameterPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetDoubleParameter = (PLibMCEnvUIEnvironment_GetDoubleParameterPtr) dlsym(hLibrary, "libmcenv_uienvironment_getdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetDoubleParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetIntegerParameter = (PLibMCEnvUIEnvironment_GetIntegerParameterPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getintegerparameter");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetIntegerParameter = (PLibMCEnvUIEnvironment_GetIntegerParameterPtr) dlsym(hLibrary, "libmcenv_uienvironment_getintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetIntegerParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetBoolParameter = (PLibMCEnvUIEnvironment_GetBoolParameterPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_getboolparameter");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetBoolParameter = (PLibMCEnvUIEnvironment_GetBoolParameterPtr) dlsym(hLibrary, "libmcenv_uienvironment_getboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetBoolParameter == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UIEnvironment_GetEventContext = (PLibMCEnvUIEnvironment_GetEventContextPtr) GetProcAddress(hLibrary, "libmcenv_uienvironment_geteventcontext");
		#else // _WIN32
		pWrapperTable->m_UIEnvironment_GetEventContext = (PLibMCEnvUIEnvironment_GetEventContextPtr) dlsym(hLibrary, "libmcenv_uienvironment_geteventcontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UIEnvironment_GetEventContext == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCEnvGetVersionPtr) GetProcAddress(hLibrary, "libmcenv_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCEnvGetVersionPtr) dlsym(hLibrary, "libmcenv_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCEnvGetLastErrorPtr) GetProcAddress(hLibrary, "libmcenv_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCEnvGetLastErrorPtr) dlsym(hLibrary, "libmcenv_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCEnvReleaseInstancePtr) GetProcAddress(hLibrary, "libmcenv_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCEnvReleaseInstancePtr) dlsym(hLibrary, "libmcenv_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCEnvAcquireInstancePtr) GetProcAddress(hLibrary, "libmcenv_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCEnvAcquireInstancePtr) dlsym(hLibrary, "libmcenv_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCEnvGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcenv_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCEnvGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcenv_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCENV_SUCCESS;
	}

	inline LibMCEnvResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCEnvDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCENV_ERROR_INVALIDPARAM;
		
		typedef LibMCEnvResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCEnvResult eLookupError = LIBMCENV_SUCCESS;
		eLookupError = (*pLookup)("libmcenv_iterator_movenext", (void**)&(pWrapperTable->m_Iterator_MoveNext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MoveNext == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_iterator_moveprevious", (void**)&(pWrapperTable->m_Iterator_MovePrevious));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MovePrevious == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_iterator_getcurrent", (void**)&(pWrapperTable->m_Iterator_GetCurrent));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_GetCurrent == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_iterator_clone", (void**)&(pWrapperTable->m_Iterator_Clone));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Clone == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_iterator_count", (void**)&(pWrapperTable->m_Iterator_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Count == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getlayerdatauuid", (void**)&(pWrapperTable->m_ToolpathLayer_GetLayerDataUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetLayerDataUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentcount", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentinfo", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofileuuid", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofilevalue", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentprofiletypedvalue", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentProfileTypedValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentpartuuid", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentPartUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getsegmentpointdata", (void**)&(pWrapperTable->m_ToolpathLayer_GetSegmentPointData));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetSegmentPointData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getzvalue", (void**)&(pWrapperTable->m_ToolpathLayer_GetZValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetZValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathlayer_getunits", (void**)&(pWrapperTable->m_ToolpathLayer_GetUnits));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathLayer_GetUnits == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getstorageuuid", (void**)&(pWrapperTable->m_ToolpathAccessor_GetStorageUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetStorageUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getlayercount", (void**)&(pWrapperTable->m_ToolpathAccessor_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetLayerCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_loadlayer", (void**)&(pWrapperTable->m_ToolpathAccessor_LoadLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_LoadLayer == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_toolpathaccessor_getunits", (void**)&(pWrapperTable->m_ToolpathAccessor_GetUnits));
		if ( (eLookupError != 0) || (pWrapperTable->m_ToolpathAccessor_GetUnits == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getname", (void**)&(pWrapperTable->m_Build_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getbuilduuid", (void**)&(pWrapperTable->m_Build_GetBuildUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetBuildUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getstorageuuid", (void**)&(pWrapperTable->m_Build_GetStorageUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetStorageUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getstoragesha256", (void**)&(pWrapperTable->m_Build_GetStorageSHA256));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetStorageSHA256 == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_getlayercount", (void**)&(pWrapperTable->m_Build_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_GetLayerCount == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_loadtoolpath", (void**)&(pWrapperTable->m_Build_LoadToolpath));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_LoadToolpath == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_unloadtoolpath", (void**)&(pWrapperTable->m_Build_UnloadToolpath));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_UnloadToolpath == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_toolpathisloaded", (void**)&(pWrapperTable->m_Build_ToolpathIsLoaded));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_ToolpathIsLoaded == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_createtoolpathaccessor", (void**)&(pWrapperTable->m_Build_CreateToolpathAccessor));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_CreateToolpathAccessor == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_build_addbinarydata", (void**)&(pWrapperTable->m_Build_AddBinaryData));
		if ( (eLookupError != 0) || (pWrapperTable->m_Build_AddBinaryData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfileexecution_getstatus", (void**)&(pWrapperTable->m_WorkingFileExecution_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFileExecution_GetStatus == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfileexecution_returnstdout", (void**)&(pWrapperTable->m_WorkingFileExecution_ReturnStdOut));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFileExecution_ReturnStdOut == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_getabsolutefilename", (void**)&(pWrapperTable->m_WorkingFile_GetAbsoluteFileName));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_GetAbsoluteFileName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_getsize", (void**)&(pWrapperTable->m_WorkingFile_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_GetSize == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_calculatesha2", (void**)&(pWrapperTable->m_WorkingFile_CalculateSHA2));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_CalculateSHA2 == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_executefile", (void**)&(pWrapperTable->m_WorkingFile_ExecuteFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_ExecuteFile == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_ismanaged", (void**)&(pWrapperTable->m_WorkingFile_IsManaged));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_IsManaged == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_makemanaged", (void**)&(pWrapperTable->m_WorkingFile_MakeManaged));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_MakeManaged == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_fileexists", (void**)&(pWrapperTable->m_WorkingFile_FileExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_FileExists == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfile_deletefromdisk", (void**)&(pWrapperTable->m_WorkingFile_DeleteFromDisk));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFile_DeleteFromDisk == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingfileiterator_getcurrentfile", (void**)&(pWrapperTable->m_WorkingFileIterator_GetCurrentFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingFileIterator_GetCurrentFile == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_isactive", (void**)&(pWrapperTable->m_WorkingDirectory_IsActive));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_IsActive == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_getabsolutefilepath", (void**)&(pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_GetAbsoluteFilePath == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_storecustomdata", (void**)&(pWrapperTable->m_WorkingDirectory_StoreCustomData));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_StoreCustomData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_storedriverdata", (void**)&(pWrapperTable->m_WorkingDirectory_StoreDriverData));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_StoreDriverData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_cleanup", (void**)&(pWrapperTable->m_WorkingDirectory_CleanUp));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_CleanUp == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_addmanagedfile", (void**)&(pWrapperTable->m_WorkingDirectory_AddManagedFile));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_AddManagedFile == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_hasunmanagedfiles", (void**)&(pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_HasUnmanagedFiles == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_retrieveunmanagedfiles", (void**)&(pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_RetrieveUnmanagedFiles == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_retrievemanagedfiles", (void**)&(pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_RetrieveManagedFiles == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_workingdirectory_retrieveallfiles", (void**)&(pWrapperTable->m_WorkingDirectory_RetrieveAllFiles));
		if ( (eLookupError != 0) || (pWrapperTable->m_WorkingDirectory_RetrieveAllFiles == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createworkingdirectory", (void**)&(pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateWorkingDirectory == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_retrievedriverdata", (void**)&(pWrapperTable->m_DriverEnvironment_RetrieveDriverData));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RetrieveDriverData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_createtoolpathaccessor", (void**)&(pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_CreateToolpathAccessor == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registerstringparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registeruuidparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registerdoubleparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registerintegerparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_registerboolparameter", (void**)&(pWrapperTable->m_DriverEnvironment_RegisterBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_RegisterBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setstringparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setuuidparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setdoubleparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setintegerparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_driverenvironment_setboolparameter", (void**)&(pWrapperTable->m_DriverEnvironment_SetBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_DriverEnvironment_SetBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_cantrigger", (void**)&(pWrapperTable->m_SignalTrigger_CanTrigger));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_CanTrigger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_trigger", (void**)&(pWrapperTable->m_SignalTrigger_Trigger));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_Trigger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_waitforhandling", (void**)&(pWrapperTable->m_SignalTrigger_WaitForHandling));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_WaitForHandling == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getname", (void**)&(pWrapperTable->m_SignalTrigger_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getstatemachine", (void**)&(pWrapperTable->m_SignalTrigger_GetStateMachine));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetStateMachine == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setstring", (void**)&(pWrapperTable->m_SignalTrigger_SetString));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setuuid", (void**)&(pWrapperTable->m_SignalTrigger_SetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setdouble", (void**)&(pWrapperTable->m_SignalTrigger_SetDouble));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetDouble == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setinteger", (void**)&(pWrapperTable->m_SignalTrigger_SetInteger));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetInteger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_setbool", (void**)&(pWrapperTable->m_SignalTrigger_SetBool));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_SetBool == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getstringresult", (void**)&(pWrapperTable->m_SignalTrigger_GetStringResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetStringResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getuuidresult", (void**)&(pWrapperTable->m_SignalTrigger_GetUUIDResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetUUIDResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getdoubleresult", (void**)&(pWrapperTable->m_SignalTrigger_GetDoubleResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetDoubleResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getintegerresult", (void**)&(pWrapperTable->m_SignalTrigger_GetIntegerResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetIntegerResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signaltrigger_getboolresult", (void**)&(pWrapperTable->m_SignalTrigger_GetBoolResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalTrigger_GetBoolResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_signalhandled", (void**)&(pWrapperTable->m_SignalHandler_SignalHandled));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SignalHandled == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getname", (void**)&(pWrapperTable->m_SignalHandler_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetName == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getsignalid", (void**)&(pWrapperTable->m_SignalHandler_GetSignalID));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetSignalID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getstatemachine", (void**)&(pWrapperTable->m_SignalHandler_GetStateMachine));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetStateMachine == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getstring", (void**)&(pWrapperTable->m_SignalHandler_GetString));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetString == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getuuid", (void**)&(pWrapperTable->m_SignalHandler_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetUUID == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getdouble", (void**)&(pWrapperTable->m_SignalHandler_GetDouble));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetDouble == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getinteger", (void**)&(pWrapperTable->m_SignalHandler_GetInteger));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetInteger == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_getbool", (void**)&(pWrapperTable->m_SignalHandler_GetBool));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_GetBool == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setstringresult", (void**)&(pWrapperTable->m_SignalHandler_SetStringResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetStringResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setuuidresult", (void**)&(pWrapperTable->m_SignalHandler_SetUUIDResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetUUIDResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setdoubleresult", (void**)&(pWrapperTable->m_SignalHandler_SetDoubleResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetDoubleResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setintegerresult", (void**)&(pWrapperTable->m_SignalHandler_SetIntegerResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetIntegerResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_signalhandler_setboolresult", (void**)&(pWrapperTable->m_SignalHandler_SetBoolResult));
		if ( (eLookupError != 0) || (pWrapperTable->m_SignalHandler_SetBoolResult == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_preparesignal", (void**)&(pWrapperTable->m_StateEnvironment_PrepareSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_PrepareSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_waitforsignal", (void**)&(pWrapperTable->m_StateEnvironment_WaitForSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_WaitForSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getdriverlibrary", (void**)&(pWrapperTable->m_StateEnvironment_GetDriverLibrary));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetDriverLibrary == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_createdriveraccess", (void**)&(pWrapperTable->m_StateEnvironment_CreateDriverAccess));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CreateDriverAccess == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getbuildjob", (void**)&(pWrapperTable->m_StateEnvironment_GetBuildJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetBuildJob == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_unloadalltoolpathes", (void**)&(pWrapperTable->m_StateEnvironment_UnloadAllToolpathes));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_UnloadAllToolpathes == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setnextstate", (void**)&(pWrapperTable->m_StateEnvironment_SetNextState));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetNextState == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_logmessage", (void**)&(pWrapperTable->m_StateEnvironment_LogMessage));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LogMessage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_logwarning", (void**)&(pWrapperTable->m_StateEnvironment_LogWarning));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LogWarning == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_loginfo", (void**)&(pWrapperTable->m_StateEnvironment_LogInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LogInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_sleep", (void**)&(pWrapperTable->m_StateEnvironment_Sleep));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_Sleep == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_checkfortermination", (void**)&(pWrapperTable->m_StateEnvironment_CheckForTermination));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_CheckForTermination == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_storesignal", (void**)&(pWrapperTable->m_StateEnvironment_StoreSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_StoreSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_retrievesignal", (void**)&(pWrapperTable->m_StateEnvironment_RetrieveSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_RetrieveSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_clearstoredvalue", (void**)&(pWrapperTable->m_StateEnvironment_ClearStoredValue));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_ClearStoredValue == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setstringparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setuuidparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setdoubleparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setintegerparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_setboolparameter", (void**)&(pWrapperTable->m_StateEnvironment_SetBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_SetBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getstringparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getuuidparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getdoubleparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getintegerparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_getboolparameter", (void**)&(pWrapperTable->m_StateEnvironment_GetBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_GetBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_stateenvironment_loadresourcedata", (void**)&(pWrapperTable->m_StateEnvironment_LoadResourceData));
		if ( (eLookupError != 0) || (pWrapperTable->m_StateEnvironment_LoadResourceData == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_preparesignal", (void**)&(pWrapperTable->m_UIEnvironment_PrepareSignal));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_PrepareSignal == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getmachinestate", (void**)&(pWrapperTable->m_UIEnvironment_GetMachineState));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetMachineState == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_logmessage", (void**)&(pWrapperTable->m_UIEnvironment_LogMessage));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_LogMessage == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_logwarning", (void**)&(pWrapperTable->m_UIEnvironment_LogWarning));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_LogWarning == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_loginfo", (void**)&(pWrapperTable->m_UIEnvironment_LogInfo));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_LogInfo == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getstringparameter", (void**)&(pWrapperTable->m_UIEnvironment_GetStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetStringParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getuuidparameter", (void**)&(pWrapperTable->m_UIEnvironment_GetUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetUUIDParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getdoubleparameter", (void**)&(pWrapperTable->m_UIEnvironment_GetDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetDoubleParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getintegerparameter", (void**)&(pWrapperTable->m_UIEnvironment_GetIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetIntegerParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_getboolparameter", (void**)&(pWrapperTable->m_UIEnvironment_GetBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetBoolParameter == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_uienvironment_geteventcontext", (void**)&(pWrapperTable->m_UIEnvironment_GetEventContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_UIEnvironment_GetEventContext == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcenv_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCENV_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CIterator
	 */
	
	/**
	* CIterator::MoveNext - Iterates to the next object in the list.
	* @return Iterates to the next object in the list.
	*/
	bool CIterator::MoveNext()
	{
		bool resultHasNext = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MoveNext(m_pHandle, &resultHasNext));
		
		return resultHasNext;
	}
	
	/**
	* CIterator::MovePrevious - Iterates to the previous object in the list.
	* @return Iterates to the previous object in the list.
	*/
	bool CIterator::MovePrevious()
	{
		bool resultHasPrevious = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MovePrevious(m_pHandle, &resultHasPrevious));
		
		return resultHasPrevious;
	}
	
	/**
	* CIterator::GetCurrent - Returns the object the iterator points at.
	* @return returns the object instance.
	*/
	PBase CIterator::GetCurrent()
	{
		LibMCEnvHandle hInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_GetCurrent(m_pHandle, &hInstance));
		
		if (!hInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBase>(m_pWrapper, hInstance);
	}
	
	/**
	* CIterator::Clone - Creates a new object iterator with the same object list.
	* @return returns the cloned Iterator instance
	*/
	PIterator CIterator::Clone()
	{
		LibMCEnvHandle hOutIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Clone(m_pHandle, &hOutIterator));
		
		if (!hOutIterator) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CIterator>(m_pWrapper, hOutIterator);
	}
	
	/**
	* CIterator::Count - Returns the number of resoucres the iterator captures.
	* @return returns the number of objects the iterator captures.
	*/
	LibMCEnv_uint64 CIterator::Count()
	{
		LibMCEnv_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CToolpathLayer
	 */
	
	/**
	* CToolpathLayer::GetLayerDataUUID - Retrieves the layerdata's uuid
	* @return Returns the uuid value.
	*/
	std::string CToolpathLayer::GetLayerDataUUID()
	{
		LibMCEnv_uint32 bytesNeededUUID = 0;
		LibMCEnv_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetLayerDataUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetLayerDataUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CToolpathLayer::GetSegmentCount - Retrieves the count of segments.
	* @return Count
	*/
	LibMCEnv_uint32 CToolpathLayer::GetSegmentCount()
	{
		LibMCEnv_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentCount(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CToolpathLayer::GetSegmentInfo - Retrieves the segment type information .
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] eType - Segment Type
	* @param[out] nPointCount - Point count of segment.
	*/
	void CToolpathLayer::GetSegmentInfo(const LibMCEnv_uint32 nIndex, eToolpathSegmentType & eType, LibMCEnv_uint32 & nPointCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentInfo(m_pHandle, nIndex, &eType, &nPointCount));
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileUUID - Retrieves the assigned segment profile uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Profile UUID
	*/
	std::string CToolpathLayer::GetSegmentProfileUUID(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnv_uint32 bytesNeededProfileUUID = 0;
		LibMCEnv_uint32 bytesWrittenProfileUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileUUID(m_pHandle, nIndex, 0, &bytesNeededProfileUUID, nullptr));
		std::vector<char> bufferProfileUUID(bytesNeededProfileUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileUUID(m_pHandle, nIndex, bytesNeededProfileUUID, &bytesWrittenProfileUUID, &bufferProfileUUID[0]));
		
		return std::string(&bufferProfileUUID[0]);
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileValue - Retrieves an assigned profile custom value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sValueName - Value Name to query for.
	* @return String Value.
	*/
	std::string CToolpathLayer::GetSegmentProfileValue(const LibMCEnv_uint32 nIndex, const std::string & sValueName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileValue(m_pHandle, nIndex, sValueName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileValue(m_pHandle, nIndex, sValueName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CToolpathLayer::GetSegmentProfileTypedValue - Retrieves an assigned profile value of a standard type.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] eValueType - Enum to query for. MUST NOT be custom.
	* @return Double Value
	*/
	LibMCEnv_double CToolpathLayer::GetSegmentProfileTypedValue(const LibMCEnv_uint32 nIndex, const eToolpathProfileValueType eValueType)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentProfileTypedValue(m_pHandle, nIndex, eValueType, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CToolpathLayer::GetSegmentPartUUID - Retrieves the assigned segment part uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Part UUID
	*/
	std::string CToolpathLayer::GetSegmentPartUUID(const LibMCEnv_uint32 nIndex)
	{
		LibMCEnv_uint32 bytesNeededPartUUID = 0;
		LibMCEnv_uint32 bytesWrittenPartUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPartUUID(m_pHandle, nIndex, 0, &bytesNeededPartUUID, nullptr));
		std::vector<char> bufferPartUUID(bytesNeededPartUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPartUUID(m_pHandle, nIndex, bytesNeededPartUUID, &bytesWrittenPartUUID, &bufferPartUUID[0]));
		
		return std::string(&bufferPartUUID[0]);
	}
	
	/**
	* CToolpathLayer::GetSegmentPointData - Retrieves the assigned segment point list. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] PointDataBuffer - The point data array. Positions are absolute in units.
	*/
	void CToolpathLayer::GetSegmentPointData(const LibMCEnv_uint32 nIndex, std::vector<sPosition2D> & PointDataBuffer)
	{
		LibMCEnv_uint64 elementsNeededPointData = 0;
		LibMCEnv_uint64 elementsWrittenPointData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPointData(m_pHandle, nIndex, 0, &elementsNeededPointData, nullptr));
		PointDataBuffer.resize((size_t) elementsNeededPointData);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetSegmentPointData(m_pHandle, nIndex, elementsNeededPointData, &elementsWrittenPointData, PointDataBuffer.data()));
	}
	
	/**
	* CToolpathLayer::GetZValue - Retrieves the layers Z Value in units.
	* @return Z Value of the layer in units.
	*/
	LibMCEnv_int32 CToolpathLayer::GetZValue()
	{
		LibMCEnv_int32 resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetZValue(m_pHandle, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CToolpathLayer::GetUnits - Retrieves the toolpath units in mm.
	* @return Toolpath units.
	*/
	LibMCEnv_double CToolpathLayer::GetUnits()
	{
		LibMCEnv_double resultUnits = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathLayer_GetUnits(m_pHandle, &resultUnits));
		
		return resultUnits;
	}
	
	/**
	 * Method definitions for class CToolpathAccessor
	 */
	
	/**
	* CToolpathAccessor::GetStorageUUID - Returns Toolpath storage UUID.
	* @return Returns toolpath storage uuid.
	*/
	std::string CToolpathAccessor::GetStorageUUID()
	{
		LibMCEnv_uint32 bytesNeededStorageUUID = 0;
		LibMCEnv_uint32 bytesWrittenStorageUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetStorageUUID(m_pHandle, 0, &bytesNeededStorageUUID, nullptr));
		std::vector<char> bufferStorageUUID(bytesNeededStorageUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetStorageUUID(m_pHandle, bytesNeededStorageUUID, &bytesWrittenStorageUUID, &bufferStorageUUID[0]));
		
		return std::string(&bufferStorageUUID[0]);
	}
	
	/**
	* CToolpathAccessor::GetLayerCount - Returns layer count.
	* @return Returns layer count.
	*/
	LibMCEnv_uint32 CToolpathAccessor::GetLayerCount()
	{
		LibMCEnv_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CToolpathAccessor::LoadLayer - Reads and returns a layer object.
	* @param[in] nLayerIndex - Layer Index.
	* @return Toolpath layer object.
	*/
	PToolpathLayer CToolpathAccessor::LoadLayer(const LibMCEnv_uint32 nLayerIndex)
	{
		LibMCEnvHandle hLayerData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_LoadLayer(m_pHandle, nLayerIndex, &hLayerData));
		
		if (!hLayerData) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CToolpathLayer>(m_pWrapper, hLayerData);
	}
	
	/**
	* CToolpathAccessor::GetUnits - Retrieves the toolpath units in mm.
	* @return Toolpath units.
	*/
	LibMCEnv_double CToolpathAccessor::GetUnits()
	{
		LibMCEnv_double resultUnits = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ToolpathAccessor_GetUnits(m_pHandle, &resultUnits));
		
		return resultUnits;
	}
	
	/**
	 * Method definitions for class CBuild
	 */
	
	/**
	* CBuild::GetName - Returns name of the build.
	* @return Name of the build.
	*/
	std::string CBuild::GetName()
	{
		LibMCEnv_uint32 bytesNeededName = 0;
		LibMCEnv_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBuild::GetBuildUUID - Returns uuid of the build.
	* @return UUID of the build.
	*/
	std::string CBuild::GetBuildUUID()
	{
		LibMCEnv_uint32 bytesNeededBuildUUID = 0;
		LibMCEnv_uint32 bytesWrittenBuildUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetBuildUUID(m_pHandle, 0, &bytesNeededBuildUUID, nullptr));
		std::vector<char> bufferBuildUUID(bytesNeededBuildUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetBuildUUID(m_pHandle, bytesNeededBuildUUID, &bytesWrittenBuildUUID, &bufferBuildUUID[0]));
		
		return std::string(&bufferBuildUUID[0]);
	}
	
	/**
	* CBuild::GetStorageUUID - Returns storage uuid of the build.
	* @return Storage UUID of the build.
	*/
	std::string CBuild::GetStorageUUID()
	{
		LibMCEnv_uint32 bytesNeededStorageUUID = 0;
		LibMCEnv_uint32 bytesWrittenStorageUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetStorageUUID(m_pHandle, 0, &bytesNeededStorageUUID, nullptr));
		std::vector<char> bufferStorageUUID(bytesNeededStorageUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetStorageUUID(m_pHandle, bytesNeededStorageUUID, &bytesWrittenStorageUUID, &bufferStorageUUID[0]));
		
		return std::string(&bufferStorageUUID[0]);
	}
	
	/**
	* CBuild::GetStorageSHA256 - Returns SHA256 of the build stream.
	* @return SHA256 of the build stream.
	*/
	std::string CBuild::GetStorageSHA256()
	{
		LibMCEnv_uint32 bytesNeededSHA256 = 0;
		LibMCEnv_uint32 bytesWrittenSHA256 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetStorageSHA256(m_pHandle, 0, &bytesNeededSHA256, nullptr));
		std::vector<char> bufferSHA256(bytesNeededSHA256);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetStorageSHA256(m_pHandle, bytesNeededSHA256, &bytesWrittenSHA256, &bufferSHA256[0]));
		
		return std::string(&bufferSHA256[0]);
	}
	
	/**
	* CBuild::GetLayerCount - Returns cached layer count of the toolpath.
	* @return Returns layer count.
	*/
	LibMCEnv_uint32 CBuild::GetLayerCount()
	{
		LibMCEnv_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CBuild::LoadToolpath - loads the a toolpath into memory
	*/
	void CBuild::LoadToolpath()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Build_LoadToolpath(m_pHandle));
	}
	
	/**
	* CBuild::UnloadToolpath - unloads the a toolpath from memory, if it has been loaded before.
	*/
	void CBuild::UnloadToolpath()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Build_UnloadToolpath(m_pHandle));
	}
	
	/**
	* CBuild::ToolpathIsLoaded - checks, if a toolpath object is loaded to memory.
	* @return returns if toolpath is loaded.
	*/
	bool CBuild::ToolpathIsLoaded()
	{
		bool resultIsLoaded = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_ToolpathIsLoaded(m_pHandle, &resultIsLoaded));
		
		return resultIsLoaded;
	}
	
	/**
	* CBuild::CreateToolpathAccessor - Creates an accessor object for a toolpath. Toolpath MUST have been loaded with LoadToolpath before.
	* @return Toolpath instance.
	*/
	PToolpathAccessor CBuild::CreateToolpathAccessor()
	{
		LibMCEnvHandle hToolpathInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_CreateToolpathAccessor(m_pHandle, &hToolpathInstance));
		
		if (!hToolpathInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CToolpathAccessor>(m_pWrapper, hToolpathInstance);
	}
	
	/**
	* CBuild::AddBinaryData - Adds binary data to store with the build.
	* @param[in] sName - Name of the attache data block.
	* @param[in] sMIMEType - Mime type of the data.
	* @param[in] ContentBuffer - Stream content to store
	* @return Data UUID of the attachment.
	*/
	std::string CBuild::AddBinaryData(const std::string & sName, const std::string & sMIMEType, const CInputVector<LibMCEnv_uint8> & ContentBuffer)
	{
		LibMCEnv_uint32 bytesNeededDataUUID = 0;
		LibMCEnv_uint32 bytesWrittenDataUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Build_AddBinaryData(m_pHandle, sName.c_str(), sMIMEType.c_str(), (LibMCEnv_uint64)ContentBuffer.size(), ContentBuffer.data(), 0, &bytesNeededDataUUID, nullptr));
		std::vector<char> bufferDataUUID(bytesNeededDataUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Build_AddBinaryData(m_pHandle, sName.c_str(), sMIMEType.c_str(), (LibMCEnv_uint64)ContentBuffer.size(), ContentBuffer.data(), bytesNeededDataUUID, &bytesWrittenDataUUID, &bufferDataUUID[0]));
		
		return std::string(&bufferDataUUID[0]);
	}
	
	/**
	 * Method definitions for class CWorkingFileExecution
	 */
	
	/**
	* CWorkingFileExecution::GetStatus - Returns the execution status
	*/
	void CWorkingFileExecution::GetStatus()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFileExecution_GetStatus(m_pHandle));
	}
	
	/**
	* CWorkingFileExecution::ReturnStdOut - Returns the output of the executable as string buffer
	* @return stdout buffer
	*/
	std::string CWorkingFileExecution::ReturnStdOut()
	{
		LibMCEnv_uint32 bytesNeededStringBuffer = 0;
		LibMCEnv_uint32 bytesWrittenStringBuffer = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFileExecution_ReturnStdOut(m_pHandle, 0, &bytesNeededStringBuffer, nullptr));
		std::vector<char> bufferStringBuffer(bytesNeededStringBuffer);
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFileExecution_ReturnStdOut(m_pHandle, bytesNeededStringBuffer, &bytesWrittenStringBuffer, &bufferStringBuffer[0]));
		
		return std::string(&bufferStringBuffer[0]);
	}
	
	/**
	 * Method definitions for class CWorkingFile
	 */
	
	/**
	* CWorkingFile::GetAbsoluteFileName - Retrieves absolute file name of the working file
	* @return global path of the file
	*/
	std::string CWorkingFile::GetAbsoluteFileName()
	{
		LibMCEnv_uint32 bytesNeededFileName = 0;
		LibMCEnv_uint32 bytesWrittenFileName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_GetAbsoluteFileName(m_pHandle, 0, &bytesNeededFileName, nullptr));
		std::vector<char> bufferFileName(bytesNeededFileName);
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_GetAbsoluteFileName(m_pHandle, bytesNeededFileName, &bytesWrittenFileName, &bufferFileName[0]));
		
		return std::string(&bufferFileName[0]);
	}
	
	/**
	* CWorkingFile::GetSize - Returns the size of temporary file.
	* @return file size
	*/
	LibMCEnv_uint64 CWorkingFile::GetSize()
	{
		LibMCEnv_uint64 resultFileSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_GetSize(m_pHandle, &resultFileSize));
		
		return resultFileSize;
	}
	
	/**
	* CWorkingFile::CalculateSHA2 - Calculates the SHA256 checksum of the file.
	* @return sha256 checksum
	*/
	std::string CWorkingFile::CalculateSHA2()
	{
		LibMCEnv_uint32 bytesNeededSHA2 = 0;
		LibMCEnv_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_CalculateSHA2(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_CalculateSHA2(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CWorkingFile::ExecuteFile - Executes the temporary file, if it is an executable.
	* @return execution object
	*/
	PWorkingFileExecution CWorkingFile::ExecuteFile()
	{
		LibMCEnvHandle hExecution = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_ExecuteFile(m_pHandle, &hExecution));
		
		if (!hExecution) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFileExecution>(m_pWrapper, hExecution);
	}
	
	/**
	* CWorkingFile::IsManaged - Returns if the file is managed.
	* @return returns if the file is managed.
	*/
	bool CWorkingFile::IsManaged()
	{
		bool resultFileIsManaged = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_IsManaged(m_pHandle, &resultFileIsManaged));
		
		return resultFileIsManaged;
	}
	
	/**
	* CWorkingFile::MakeManaged - Makes the file managed if it is not managed yet.
	*/
	void CWorkingFile::MakeManaged()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_MakeManaged(m_pHandle));
	}
	
	/**
	* CWorkingFile::FileExists - Returns if the file exists on disk.
	* @return returns if the file exists.
	*/
	bool CWorkingFile::FileExists()
	{
		bool resultFileDoesExist = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_FileExists(m_pHandle, &resultFileDoesExist));
		
		return resultFileDoesExist;
	}
	
	/**
	* CWorkingFile::DeleteFromDisk - Deletes the temporary file.
	* @return returns if deletion was successful or file did not exist in the first place.
	*/
	bool CWorkingFile::DeleteFromDisk()
	{
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFile_DeleteFromDisk(m_pHandle, &resultSuccess));
		
		return resultSuccess;
	}
	
	/**
	 * Method definitions for class CWorkingFileIterator
	 */
	
	/**
	* CWorkingFileIterator::GetCurrentFile - Returns the working file the iterator points at.
	* @return returns the WorkingFile instance.
	*/
	PWorkingFile CWorkingFileIterator::GetCurrentFile()
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingFileIterator_GetCurrentFile(m_pHandle, &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	 * Method definitions for class CWorkingDirectory
	 */
	
	/**
	* CWorkingDirectory::IsActive - Working directory is active.
	* @return returns true if files can be read and written to the directory.
	*/
	bool CWorkingDirectory::IsActive()
	{
		bool resultIsActive = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_IsActive(m_pHandle, &resultIsActive));
		
		return resultIsActive;
	}
	
	/**
	* CWorkingDirectory::GetAbsoluteFilePath - Retrieves absolute file path.
	* @return global path of the directory, including path delimiter.
	*/
	std::string CWorkingDirectory::GetAbsoluteFilePath()
	{
		LibMCEnv_uint32 bytesNeededFilePath = 0;
		LibMCEnv_uint32 bytesWrittenFilePath = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_GetAbsoluteFilePath(m_pHandle, 0, &bytesNeededFilePath, nullptr));
		std::vector<char> bufferFilePath(bytesNeededFilePath);
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_GetAbsoluteFilePath(m_pHandle, bytesNeededFilePath, &bytesWrittenFilePath, &bufferFilePath[0]));
		
		return std::string(&bufferFilePath[0]);
	}
	
	/**
	* CWorkingDirectory::StoreCustomData - Stores a data buffer in a temporary file.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] DataBufferBuffer - file data to store to.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::StoreCustomData(const std::string & sFileName, const CInputVector<LibMCEnv_uint8> & DataBufferBuffer)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_StoreCustomData(m_pHandle, sFileName.c_str(), (LibMCEnv_uint64)DataBufferBuffer.size(), DataBufferBuffer.data(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::StoreDriverData - Stores attached driver data in a temporary file.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::StoreDriverData(const std::string & sFileName, const std::string & sIdentifier)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_StoreDriverData(m_pHandle, sFileName.c_str(), sIdentifier.c_str(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::CleanUp - Deletes all managed files in the directory and the directory. No storing is possible after a cleanup.
	* @return returns if deletion was successful.
	*/
	bool CWorkingDirectory::CleanUp()
	{
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_CleanUp(m_pHandle, &resultSuccess));
		
		return resultSuccess;
	}
	
	/**
	* CWorkingDirectory::AddManagedFile - Adds a managed filename in the directory (i.e. this file will be deleted at CleanUp). Subdirectories are not allowed.
	* @param[in] sFileName - Filename to manage. The file does not need to exist yet.
	* @return working file instance.
	*/
	PWorkingFile CWorkingDirectory::AddManagedFile(const std::string & sFileName)
	{
		LibMCEnvHandle hWorkingFile = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_AddManagedFile(m_pHandle, sFileName.c_str(), &hWorkingFile));
		
		if (!hWorkingFile) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFile>(m_pWrapper, hWorkingFile);
	}
	
	/**
	* CWorkingDirectory::HasUnmanagedFiles - Returns if the working directory has unmanaged files. A clean implementation will never deal with unmanaged files.
	* @return returns if there are unmanaged files.
	*/
	bool CWorkingDirectory::HasUnmanagedFiles()
	{
		bool resultHasUnmanagedFiles = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_HasUnmanagedFiles(m_pHandle, &resultHasUnmanagedFiles));
		
		return resultHasUnmanagedFiles;
	}
	
	/**
	* CWorkingDirectory::RetrieveUnmanagedFiles - Returns a list of unmanaged files.
	* @return working file iterator instance.
	*/
	PWorkingFileIterator CWorkingDirectory::RetrieveUnmanagedFiles()
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_RetrieveUnmanagedFiles(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFileIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CWorkingDirectory::RetrieveManagedFiles - Returns a list of managed files.
	* @return working file iterator instance.
	*/
	PWorkingFileIterator CWorkingDirectory::RetrieveManagedFiles()
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_RetrieveManagedFiles(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFileIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CWorkingDirectory::RetrieveAllFiles - Returns a list of all files in the directory.
	* @return working file iterator instance.
	*/
	PWorkingFileIterator CWorkingDirectory::RetrieveAllFiles()
	{
		LibMCEnvHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_WorkingDirectory_RetrieveAllFiles(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingFileIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	 * Method definitions for class CDriverEnvironment
	 */
	
	/**
	* CDriverEnvironment::CreateWorkingDirectory - creates a temporary working directory.
	* @return creates a working directory
	*/
	PWorkingDirectory CDriverEnvironment::CreateWorkingDirectory()
	{
		LibMCEnvHandle hWorkingDirectory = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateWorkingDirectory(m_pHandle, &hWorkingDirectory));
		
		if (!hWorkingDirectory) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CWorkingDirectory>(m_pWrapper, hWorkingDirectory);
	}
	
	/**
	* CDriverEnvironment::RetrieveDriverData - retrieves attached driver data into a memory buffer.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @param[out] DataBufferBuffer - buffer data.
	*/
	void CDriverEnvironment::RetrieveDriverData(const std::string & sIdentifier, std::vector<LibMCEnv_uint8> & DataBufferBuffer)
	{
		LibMCEnv_uint64 elementsNeededDataBuffer = 0;
		LibMCEnv_uint64 elementsWrittenDataBuffer = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RetrieveDriverData(m_pHandle, sIdentifier.c_str(), 0, &elementsNeededDataBuffer, nullptr));
		DataBufferBuffer.resize((size_t) elementsNeededDataBuffer);
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RetrieveDriverData(m_pHandle, sIdentifier.c_str(), elementsNeededDataBuffer, &elementsWrittenDataBuffer, DataBufferBuffer.data()));
	}
	
	/**
	* CDriverEnvironment::CreateToolpathAccessor - Creates an accessor object for a toolpath. Toolpath MUST have been loaded into memory before.
	* @param[in] sStreamUUID - UUID of the stream.
	* @return Toolpath instance.
	*/
	PToolpathAccessor CDriverEnvironment::CreateToolpathAccessor(const std::string & sStreamUUID)
	{
		LibMCEnvHandle hToolpathInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_CreateToolpathAccessor(m_pHandle, sStreamUUID.c_str(), &hToolpathInstance));
		
		if (!hToolpathInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CToolpathAccessor>(m_pWrapper, hToolpathInstance);
	}
	
	/**
	* CDriverEnvironment::RegisterStringParameter - registers a string parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] sDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterStringParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterStringParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), sDefaultValue.c_str()));
	}
	
	/**
	* CDriverEnvironment::RegisterUUIDParameter - registers a uuid parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] sDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterUUIDParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterUUIDParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), sDefaultValue.c_str()));
	}
	
	/**
	* CDriverEnvironment::RegisterDoubleParameter - registers a double parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] dDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterDoubleParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_double dDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterDoubleParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), dDefaultValue));
	}
	
	/**
	* CDriverEnvironment::RegisterIntegerParameter - registers an int parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] nDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterIntegerParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_int64 nDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterIntegerParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), nDefaultValue));
	}
	
	/**
	* CDriverEnvironment::RegisterBoolParameter - registers a bool parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] bDefaultValue - default value to set
	*/
	void CDriverEnvironment::RegisterBoolParameter(const std::string & sParameterName, const std::string & sDescription, const bool bDefaultValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_RegisterBoolParameter(m_pHandle, sParameterName.c_str(), sDescription.c_str(), bDefaultValue));
	}
	
	/**
	* CDriverEnvironment::SetStringParameter - sets a string parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CDriverEnvironment::SetStringParameter(const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetStringParameter(m_pHandle, sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CDriverEnvironment::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CDriverEnvironment::SetUUIDParameter(const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetUUIDParameter(m_pHandle, sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CDriverEnvironment::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	void CDriverEnvironment::SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetDoubleParameter(m_pHandle, sParameterName.c_str(), dValue));
	}
	
	/**
	* CDriverEnvironment::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	void CDriverEnvironment::SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetIntegerParameter(m_pHandle, sParameterName.c_str(), nValue));
	}
	
	/**
	* CDriverEnvironment::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	void CDriverEnvironment::SetBoolParameter(const std::string & sParameterName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DriverEnvironment_SetBoolParameter(m_pHandle, sParameterName.c_str(), bValue));
	}
	
	/**
	 * Method definitions for class CSignalTrigger
	 */
	
	/**
	* CSignalTrigger::CanTrigger - Returns, if signal channel is available.
	* @return Returns true, if signal channel is available.
	*/
	bool CSignalTrigger::CanTrigger()
	{
		bool resultChannelIsAvailable = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_CanTrigger(m_pHandle, &resultChannelIsAvailable));
		
		return resultChannelIsAvailable;
	}
	
	/**
	* CSignalTrigger::Trigger - Triggers a signal, if signal channel is available.
	*/
	void CSignalTrigger::Trigger()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_Trigger(m_pHandle));
	}
	
	/**
	* CSignalTrigger::WaitForHandling - Waits until the signal is reset.
	* @param[in] nTimeOut - Timeout in Milliseconds. 0 for Immediate return.
	* @return Flag if signal handling has been handled.
	*/
	bool CSignalTrigger::WaitForHandling(const LibMCEnv_uint32 nTimeOut)
	{
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_WaitForHandling(m_pHandle, nTimeOut, &resultSuccess));
		
		return resultSuccess;
	}
	
	/**
	* CSignalTrigger::GetName - Returns the signal name.
	* @return Name Of Signal
	*/
	std::string CSignalTrigger::GetName()
	{
		LibMCEnv_uint32 bytesNeededSignalName = 0;
		LibMCEnv_uint32 bytesWrittenSignalName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetName(m_pHandle, 0, &bytesNeededSignalName, nullptr));
		std::vector<char> bufferSignalName(bytesNeededSignalName);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetName(m_pHandle, bytesNeededSignalName, &bytesWrittenSignalName, &bufferSignalName[0]));
		
		return std::string(&bufferSignalName[0]);
	}
	
	/**
	* CSignalTrigger::GetStateMachine - Returns the signal state machine instance.
	* @return Name Of State Machine
	*/
	std::string CSignalTrigger::GetStateMachine()
	{
		LibMCEnv_uint32 bytesNeededStateMachineName = 0;
		LibMCEnv_uint32 bytesWrittenStateMachineName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetStateMachine(m_pHandle, 0, &bytesNeededStateMachineName, nullptr));
		std::vector<char> bufferStateMachineName(bytesNeededStateMachineName);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetStateMachine(m_pHandle, bytesNeededStateMachineName, &bytesWrittenStateMachineName, &bufferStateMachineName[0]));
		
		return std::string(&bufferStateMachineName[0]);
	}
	
	/**
	* CSignalTrigger::SetString - sets a string value
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	void CSignalTrigger::SetString(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetString(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CSignalTrigger::SetUUID - sets a uuid value
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	void CSignalTrigger::SetUUID(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetUUID(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CSignalTrigger::SetDouble - sets a double
	* @param[in] sName - Name
	* @param[in] dValue - Value
	*/
	void CSignalTrigger::SetDouble(const std::string & sName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetDouble(m_pHandle, sName.c_str(), dValue));
	}
	
	/**
	* CSignalTrigger::SetInteger - sets an int.
	* @param[in] sName - Name
	* @param[in] nValue - Value
	*/
	void CSignalTrigger::SetInteger(const std::string & sName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetInteger(m_pHandle, sName.c_str(), nValue));
	}
	
	/**
	* CSignalTrigger::SetBool - sets a bool
	* @param[in] sName - Name
	* @param[in] bValue - Value
	*/
	void CSignalTrigger::SetBool(const std::string & sName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_SetBool(m_pHandle, sName.c_str(), bValue));
	}
	
	/**
	* CSignalTrigger::GetStringResult - returns a string value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	std::string CSignalTrigger::GetStringResult(const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetStringResult(m_pHandle, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetStringResult(m_pHandle, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CSignalTrigger::GetUUIDResult - returns a uuid value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	std::string CSignalTrigger::GetUUIDResult(const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetUUIDResult(m_pHandle, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetUUIDResult(m_pHandle, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CSignalTrigger::GetDoubleResult - returns a string value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	LibMCEnv_double CSignalTrigger::GetDoubleResult(const std::string & sName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetDoubleResult(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalTrigger::GetIntegerResult - returns an int value of the result.
	* @param[in] sName - Name
	* @return Value
	*/
	LibMCEnv_int64 CSignalTrigger::GetIntegerResult(const std::string & sName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetIntegerResult(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalTrigger::GetBoolResult - returns a bool value of the result.
	* @param[in] sName - Name
	* @return Value
	*/
	bool CSignalTrigger::GetBoolResult(const std::string & sName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalTrigger_GetBoolResult(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	 * Method definitions for class CSignalHandler
	 */
	
	/**
	* CSignalHandler::SignalHandled - Marks signal as handled and resets signal channel.
	*/
	void CSignalHandler::SignalHandled()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SignalHandled(m_pHandle));
	}
	
	/**
	* CSignalHandler::GetName - Returns the signal name.
	* @return Name Of Signal
	*/
	std::string CSignalHandler::GetName()
	{
		LibMCEnv_uint32 bytesNeededSignalName = 0;
		LibMCEnv_uint32 bytesWrittenSignalName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetName(m_pHandle, 0, &bytesNeededSignalName, nullptr));
		std::vector<char> bufferSignalName(bytesNeededSignalName);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetName(m_pHandle, bytesNeededSignalName, &bytesWrittenSignalName, &bufferSignalName[0]));
		
		return std::string(&bufferSignalName[0]);
	}
	
	/**
	* CSignalHandler::GetSignalID - Returns the signal id.
	* @return Signal Identifier
	*/
	std::string CSignalHandler::GetSignalID()
	{
		LibMCEnv_uint32 bytesNeededSignalID = 0;
		LibMCEnv_uint32 bytesWrittenSignalID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetSignalID(m_pHandle, 0, &bytesNeededSignalID, nullptr));
		std::vector<char> bufferSignalID(bytesNeededSignalID);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetSignalID(m_pHandle, bytesNeededSignalID, &bytesWrittenSignalID, &bufferSignalID[0]));
		
		return std::string(&bufferSignalID[0]);
	}
	
	/**
	* CSignalHandler::GetStateMachine - Returns the signal state machine instance.
	* @return Name Of State Machine
	*/
	std::string CSignalHandler::GetStateMachine()
	{
		LibMCEnv_uint32 bytesNeededStateMachineName = 0;
		LibMCEnv_uint32 bytesWrittenStateMachineName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetStateMachine(m_pHandle, 0, &bytesNeededStateMachineName, nullptr));
		std::vector<char> bufferStateMachineName(bytesNeededStateMachineName);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetStateMachine(m_pHandle, bytesNeededStateMachineName, &bytesWrittenStateMachineName, &bufferStateMachineName[0]));
		
		return std::string(&bufferStateMachineName[0]);
	}
	
	/**
	* CSignalHandler::GetString - gets a string value
	* @param[in] sName - Name
	* @return Value
	*/
	std::string CSignalHandler::GetString(const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetString(m_pHandle, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetString(m_pHandle, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CSignalHandler::GetUUID - gets a uuid value
	* @param[in] sName - Name
	* @return Value
	*/
	std::string CSignalHandler::GetUUID(const std::string & sName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetUUID(m_pHandle, sName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetUUID(m_pHandle, sName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CSignalHandler::GetDouble - gets a double
	* @param[in] sName - Name
	* @return Value
	*/
	LibMCEnv_double CSignalHandler::GetDouble(const std::string & sName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetDouble(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalHandler::GetInteger - gets an int.
	* @param[in] sName - Name
	* @return Value
	*/
	LibMCEnv_int64 CSignalHandler::GetInteger(const std::string & sName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetInteger(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalHandler::GetBool - gets a bool
	* @param[in] sName - Name
	* @return Value
	*/
	bool CSignalHandler::GetBool(const std::string & sName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_GetBool(m_pHandle, sName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CSignalHandler::SetStringResult - returns a string value of the result
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	void CSignalHandler::SetStringResult(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetStringResult(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CSignalHandler::SetUUIDResult - returns a uuid value of the result
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	void CSignalHandler::SetUUIDResult(const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetUUIDResult(m_pHandle, sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CSignalHandler::SetDoubleResult - returns a string value of the result
	* @param[in] sName - Name
	* @param[in] dValue - Value
	*/
	void CSignalHandler::SetDoubleResult(const std::string & sName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetDoubleResult(m_pHandle, sName.c_str(), dValue));
	}
	
	/**
	* CSignalHandler::SetIntegerResult - sets an int.
	* @param[in] sName - Name
	* @param[in] nValue - Value
	*/
	void CSignalHandler::SetIntegerResult(const std::string & sName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetIntegerResult(m_pHandle, sName.c_str(), nValue));
	}
	
	/**
	* CSignalHandler::SetBoolResult - sets a bool
	* @param[in] sName - Name
	* @param[in] bValue - Value
	*/
	void CSignalHandler::SetBoolResult(const std::string & sName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_SignalHandler_SetBoolResult(m_pHandle, sName.c_str(), bValue));
	}
	
	/**
	 * Method definitions for class CStateEnvironment
	 */
	
	/**
	* CStateEnvironment::PrepareSignal - prepares a signal object to trigger later.
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sSignalName - Name Of signal channel.
	* @return Signal trigger object.
	*/
	PSignalTrigger CStateEnvironment::PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName)
	{
		LibMCEnvHandle hSignalInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_PrepareSignal(m_pHandle, sMachineInstance.c_str(), sSignalName.c_str(), &hSignalInstance));
		
		if (!hSignalInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSignalTrigger>(m_pWrapper, hSignalInstance);
	}
	
	/**
	* CStateEnvironment::WaitForSignal - waits for a signal.
	* @param[in] sSignalName - Name Of Signal
	* @param[in] nTimeOut - Timeout in Milliseconds. 0 for Immediate return.
	* @param[out] pHandlerInstance - Signal object. If Success is false, the Signal Handler Object will be null.
	* @return Signal has been triggered
	*/
	bool CStateEnvironment::WaitForSignal(const std::string & sSignalName, const LibMCEnv_uint32 nTimeOut, PSignalHandler & pHandlerInstance)
	{
		LibMCEnvHandle hHandlerInstance = nullptr;
		bool resultSuccess = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_WaitForSignal(m_pHandle, sSignalName.c_str(), nTimeOut, &hHandlerInstance, &resultSuccess));
		if (hHandlerInstance) {
			pHandlerInstance = std::make_shared<CSignalHandler>(m_pWrapper, hHandlerInstance);
		} else {
			pHandlerInstance = nullptr;
		}
		
		return resultSuccess;
	}
	
	/**
	* CStateEnvironment::GetDriverLibrary - Returns the driver type and library lookup for a specific registered driver.
	* @param[in] sDriverName - Name identifier of the driver.
	* @param[out] sDriverType - returns type identifier of the driver.
	* @param[out] pDriverLookup - GetProcAddress Handle of the driver.
	*/
	void CStateEnvironment::GetDriverLibrary(const std::string & sDriverName, std::string & sDriverType, LibMCEnv_pvoid & pDriverLookup)
	{
		LibMCEnv_uint32 bytesNeededDriverType = 0;
		LibMCEnv_uint32 bytesWrittenDriverType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetDriverLibrary(m_pHandle, sDriverName.c_str(), 0, &bytesNeededDriverType, nullptr, &pDriverLookup));
		std::vector<char> bufferDriverType(bytesNeededDriverType);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetDriverLibrary(m_pHandle, sDriverName.c_str(), bytesNeededDriverType, &bytesWrittenDriverType, &bufferDriverType[0], &pDriverLookup));
		sDriverType = std::string(&bufferDriverType[0]);
	}
	
	/**
	* CStateEnvironment::CreateDriverAccess - Accesses and locks a driver for the execution of the current state.
	* @param[in] sDriverName - Name identifier of the driver.
	* @param[out] pDriverHandle - Handle of the driver.
	*/
	void CStateEnvironment::CreateDriverAccess(const std::string & sDriverName, LibMCEnv_pvoid & pDriverHandle)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CreateDriverAccess(m_pHandle, sDriverName.c_str(), &pDriverHandle));
	}
	
	/**
	* CStateEnvironment::GetBuildJob - Returns a instance of a build object.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	PBuild CStateEnvironment::GetBuildJob(const std::string & sBuildUUID)
	{
		LibMCEnvHandle hBuildInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetBuildJob(m_pHandle, sBuildUUID.c_str(), &hBuildInstance));
		
		if (!hBuildInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuild>(m_pWrapper, hBuildInstance);
	}
	
	/**
	* CStateEnvironment::UnloadAllToolpathes - unloads all toolpath in memory to clean up
	*/
	void CStateEnvironment::UnloadAllToolpathes()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_UnloadAllToolpathes(m_pHandle));
	}
	
	/**
	* CStateEnvironment::SetNextState - sets the next state
	* @param[in] sStateName - Name of next state
	*/
	void CStateEnvironment::SetNextState(const std::string & sStateName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetNextState(m_pHandle, sStateName.c_str()));
	}
	
	/**
	* CStateEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	void CStateEnvironment::LogMessage(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LogMessage(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CStateEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	void CStateEnvironment::LogWarning(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LogWarning(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CStateEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	void CStateEnvironment::LogInfo(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LogInfo(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CStateEnvironment::Sleep - Puts the current instance to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	void CStateEnvironment::Sleep(const LibMCEnv_uint32 nDelay)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_Sleep(m_pHandle, nDelay));
	}
	
	/**
	* CStateEnvironment::CheckForTermination - checks environment for termination signal. MUST be called frequently in longer-running operations.
	* @return Returns if termination shall appear
	*/
	bool CStateEnvironment::CheckForTermination()
	{
		bool resultShallTerminate = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_CheckForTermination(m_pHandle, &resultShallTerminate));
		
		return resultShallTerminate;
	}
	
	/**
	* CStateEnvironment::StoreSignal - stores a signal handler in the current state machine
	* @param[in] sName - Name
	* @param[in] pHandler - Signal handler to store.
	*/
	void CStateEnvironment::StoreSignal(const std::string & sName, classParam<CSignalHandler> pHandler)
	{
		LibMCEnvHandle hHandler = pHandler.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_StoreSignal(m_pHandle, sName.c_str(), hHandler));
	}
	
	/**
	* CStateEnvironment::RetrieveSignal - retrieves a signal handler from the current state machine. Fails if value has not been stored before or signal has been already handled.
	* @param[in] sName - Name
	* @return Signal handler instance.
	*/
	PSignalHandler CStateEnvironment::RetrieveSignal(const std::string & sName)
	{
		LibMCEnvHandle hHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_RetrieveSignal(m_pHandle, sName.c_str(), &hHandler));
		
		if (!hHandler) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSignalHandler>(m_pWrapper, hHandler);
	}
	
	/**
	* CStateEnvironment::ClearStoredValue - deletes a value from the data store.
	* @param[in] sName - Name
	*/
	void CStateEnvironment::ClearStoredValue(const std::string & sName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_ClearStoredValue(m_pHandle, sName.c_str()));
	}
	
	/**
	* CStateEnvironment::SetStringParameter - sets a string parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CStateEnvironment::SetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetStringParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CStateEnvironment::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	void CStateEnvironment::SetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetUUIDParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), sValue.c_str()));
	}
	
	/**
	* CStateEnvironment::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	void CStateEnvironment::SetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetDoubleParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), dValue));
	}
	
	/**
	* CStateEnvironment::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	void CStateEnvironment::SetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetIntegerParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), nValue));
	}
	
	/**
	* CStateEnvironment::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	void CStateEnvironment::SetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_SetBoolParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), bValue));
	}
	
	/**
	* CStateEnvironment::GetStringParameter - returns a string parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	std::string CStateEnvironment::GetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetStringParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetStringParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CStateEnvironment::GetUUIDParameter - returns a uuid parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	std::string CStateEnvironment::GetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetUUIDParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetUUIDParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CStateEnvironment::GetDoubleParameter - returns a double parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	LibMCEnv_double CStateEnvironment::GetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetDoubleParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CStateEnvironment::GetIntegerParameter - returns an int parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	LibMCEnv_int64 CStateEnvironment::GetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetIntegerParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CStateEnvironment::GetBoolParameter - returns a bool parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	bool CStateEnvironment::GetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_GetBoolParameter(m_pHandle, sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CStateEnvironment::LoadResourceData - loads a plugin resource file into memory.
	* @param[in] sResourceName - Name of the resource.
	* @param[out] ResourceDataBuffer - Resource Data Buffer.
	*/
	void CStateEnvironment::LoadResourceData(const std::string & sResourceName, std::vector<LibMCEnv_uint8> & ResourceDataBuffer)
	{
		LibMCEnv_uint64 elementsNeededResourceData = 0;
		LibMCEnv_uint64 elementsWrittenResourceData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LoadResourceData(m_pHandle, sResourceName.c_str(), 0, &elementsNeededResourceData, nullptr));
		ResourceDataBuffer.resize((size_t) elementsNeededResourceData);
		CheckError(m_pWrapper->m_WrapperTable.m_StateEnvironment_LoadResourceData(m_pHandle, sResourceName.c_str(), elementsNeededResourceData, &elementsWrittenResourceData, ResourceDataBuffer.data()));
	}
	
	/**
	 * Method definitions for class CUIEnvironment
	 */
	
	/**
	* CUIEnvironment::PrepareSignal - prepares a signal object to trigger later.
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sSignalName - Name Of signal channel.
	* @return Signal trigger object.
	*/
	PSignalTrigger CUIEnvironment::PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName)
	{
		LibMCEnvHandle hSignalInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_PrepareSignal(m_pHandle, sMachineInstance.c_str(), sSignalName.c_str(), &hSignalInstance));
		
		if (!hSignalInstance) {
			CheckError(LIBMCENV_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSignalTrigger>(m_pWrapper, hSignalInstance);
	}
	
	/**
	* CUIEnvironment::GetMachineState - Retrieves the machine state
	* @param[in] sMachineInstance - State machine instance name
	* @return Name of current state
	*/
	std::string CUIEnvironment::GetMachineState(const std::string & sMachineInstance)
	{
		LibMCEnv_uint32 bytesNeededStateName = 0;
		LibMCEnv_uint32 bytesWrittenStateName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineState(m_pHandle, sMachineInstance.c_str(), 0, &bytesNeededStateName, nullptr));
		std::vector<char> bufferStateName(bytesNeededStateName);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetMachineState(m_pHandle, sMachineInstance.c_str(), bytesNeededStateName, &bytesWrittenStateName, &bufferStateName[0]));
		
		return std::string(&bufferStateName[0]);
	}
	
	/**
	* CUIEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	void CUIEnvironment::LogMessage(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_LogMessage(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CUIEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	void CUIEnvironment::LogWarning(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_LogWarning(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CUIEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	void CUIEnvironment::LogInfo(const std::string & sLogString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_LogInfo(m_pHandle, sLogString.c_str()));
	}
	
	/**
	* CUIEnvironment::GetStringParameter - returns a string parameter
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	std::string CUIEnvironment::GetStringParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetStringParameter(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetStringParameter(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CUIEnvironment::GetUUIDParameter - returns a uuid parameter
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	std::string CUIEnvironment::GetUUIDParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_uint32 bytesNeededValue = 0;
		LibMCEnv_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetUUIDParameter(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetUUIDParameter(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CUIEnvironment::GetDoubleParameter - returns a double parameter
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	LibMCEnv_double CUIEnvironment::GetDoubleParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetDoubleParameter(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::GetIntegerParameter - returns an int parameter
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	LibMCEnv_int64 CUIEnvironment::GetIntegerParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		LibMCEnv_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetIntegerParameter(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::GetBoolParameter - returns a bool parameter
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	bool CUIEnvironment::GetBoolParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetBoolParameter(m_pHandle, sMachineInstance.c_str(), sParameterGroup.c_str(), sParameterName.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CUIEnvironment::GetEventContext - returns the event context uuid as string
	* @return Context UUID
	*/
	std::string CUIEnvironment::GetEventContext()
	{
		LibMCEnv_uint32 bytesNeededContextUUID = 0;
		LibMCEnv_uint32 bytesWrittenContextUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetEventContext(m_pHandle, 0, &bytesNeededContextUUID, nullptr));
		std::vector<char> bufferContextUUID(bytesNeededContextUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_UIEnvironment_GetEventContext(m_pHandle, bytesNeededContextUUID, &bytesWrittenContextUUID, &bufferContextUUID[0]));
		
		return std::string(&bufferContextUUID[0]);
	}

} // namespace LibMCEnv

#endif // __LIBMCENV_CPPHEADER_DYNAMIC_CPP

