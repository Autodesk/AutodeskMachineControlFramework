/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ header file in order to allow easy
development of Machine Control data model library. The implementer of Machine Control data model library needs to
derive concrete classes from the abstract classes in this header.

Interface version: 1.0.0

*/


#ifndef __LIBMCDATA_CPPINTERFACES
#define __LIBMCDATA_CPPINTERFACES

#include <string>
#include <memory>

#include "libmcdata_types.hpp"



namespace LibMCData {
namespace Impl {

/**
 Forward declarations of class interfaces
*/
class IBase;
class IIterator;
class ILogEntryList;
class ILogSession;
class IStorageStream;
class IStorage;
class IBuildJobData;
class IBuildJobDataIterator;
class IBuildJob;
class IBuildJobIterator;
class IBuildJobHandler;
class ILoginHandler;
class IPersistencyHandler;
class IDataModel;



/*************************************************************************************************************************
 Parameter Cache definitions
**************************************************************************************************************************/

class ParameterCache {
	public:
		virtual ~ParameterCache() {}
};

template <class T1> class ParameterCache_1 : public ParameterCache {
	private:
		T1 m_param1;
	public:
		ParameterCache_1 (const T1 & param1)
			: m_param1 (param1)
		{
		}

		void retrieveData (T1 & param1)
		{
			param1 = m_param1;
		}
};

template <class T1, class T2> class ParameterCache_2 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
	public:
		ParameterCache_2 (const T1 & param1, const T2 & param2)
			: m_param1 (param1), m_param2 (param2)
		{
		}

		void retrieveData (T1 & param1, T2 & param2)
		{
			param1 = m_param1;
			param2 = m_param2;
		}
};

template <class T1, class T2, class T3> class ParameterCache_3 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
	public:
		ParameterCache_3 (const T1 & param1, const T2 & param2, const T3 & param3)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
		}
};

template <class T1, class T2, class T3, class T4> class ParameterCache_4 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
		T4 m_param4;
	public:
		ParameterCache_4 (const T1 & param1, const T2 & param2, const T3 & param3, const T4 & param4)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3), m_param4 (param4)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3, T4 & param4)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
			param4 = m_param4;
		}
};

template <class T1, class T2, class T3, class T4, class T5> class ParameterCache_5 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
		T4 m_param4;
		T5 m_param5;
	public:
		ParameterCache_5 (const T1 & param1, const T2 & param2, const T3 & param3, const T4 & param4, const T5 & param5)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3), m_param4 (param4), m_param5 (param5)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3, T4 & param4, T5 & param5)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
			param4 = m_param4;
			param5 = m_param5;
		}
};


/*************************************************************************************************************************
 Class interface for Base 
**************************************************************************************************************************/

class IBase {
private:
	std::unique_ptr<ParameterCache> m_ParameterCache;
public:
	/**
	* IBase::~IBase - virtual destructor of IBase
	*/
	virtual ~IBase() {};

	/**
	* IBase::ReleaseBaseClassInterface - Releases ownership of a base class interface. Deletes the reference, if necessary.
	* @param[in] pIBase - The base class instance to release
	*/
	static void ReleaseBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->DecRefCount();
		}
	};

	/**
	* IBase::AcquireBaseClassInterface - Acquires shared ownership of a base class interface.
	* @param[in] pIBase - The base class instance to acquire
	*/
	static void AcquireBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->IncRefCount();
		}
	};


	/**
	* IBase::GetLastErrorMessage - Returns the last error registered of this class instance
	* @param[out] sErrorMessage - Message of the last error registered
	* @return Has an error been registered already
	*/
	virtual bool GetLastErrorMessage(std::string & sErrorMessage) = 0;

	/**
	* IBase::ClearErrorMessages - Clears all registered messages of this class instance
	*/
	virtual void ClearErrorMessages() = 0;

	/**
	* IBase::RegisterErrorMessage - Registers an error message with this class instance
	* @param[in] sErrorMessage - Error message to register
	*/
	virtual void RegisterErrorMessage(const std::string & sErrorMessage) = 0;

	/**
	* IBase::IncRefCount - Increases the reference count of a class instance
	*/
	virtual void IncRefCount() = 0;

	/**
	* IBase::DecRefCount - Decreases the reference count of a class instance and free releases it, if the last reference has been removed
	* @return Has the object been released
	*/
	virtual bool DecRefCount() = 0;

	/**
	* IBase::_setCache - set parameter cache of object
	*/
	void _setCache(ParameterCache * pCache)
	{
		m_ParameterCache.reset(pCache);
	}

	/**
	* IBase::_getCache - returns parameter cache of object
	*/
	ParameterCache* _getCache()
	{
		return m_ParameterCache.get();
	}

};


/**
 Definition of a shared pointer class for IBase
*/
template<class T>
class IBaseSharedPtr : public std::shared_ptr<T>
{
public:
	explicit IBaseSharedPtr(T* t = nullptr)
		: std::shared_ptr<T>(t, IBase::ReleaseBaseClassInterface)
	{
		t->IncRefCount();
	}

	// Reset function, as it also needs to properly set the deleter.
	void reset(T* t = nullptr)
	{
		std::shared_ptr<T>::reset(t, IBase::ReleaseBaseClassInterface);
	}

	// Get-function that increases the Base class's reference count
	T* getCoOwningPtr()
	{
		T* t = this->get();
		t->IncRefCount();
		return t;
	}
};


typedef IBaseSharedPtr<IBase> PIBase;


/*************************************************************************************************************************
 Class interface for Iterator 
**************************************************************************************************************************/

class IIterator : public virtual IBase {
public:
	/**
	* IIterator::MoveNext - Iterates to the next resource in the list.
	* @return Iterates to the next resource in the list.
	*/
	virtual bool MoveNext() = 0;

	/**
	* IIterator::MovePrevious - Iterates to the previous resource in the list.
	* @return Iterates to the previous resource in the list.
	*/
	virtual bool MovePrevious() = 0;

	/**
	* IIterator::GetCurrent - Returns the resource the iterator points at.
	* @return returns the resource instance.
	*/
	virtual IBase * GetCurrent() = 0;

	/**
	* IIterator::Clone - Creates a new resource iterator with the same resource list.
	* @return returns the cloned Iterator instance
	*/
	virtual IIterator * Clone() = 0;

	/**
	* IIterator::Count - Returns the number of resources the iterator captures.
	* @return returns the number of resources the iterator captures.
	*/
	virtual LibMCData_uint64 Count() = 0;

};

typedef IBaseSharedPtr<IIterator> PIIterator;


/*************************************************************************************************************************
 Class interface for LogEntryList 
**************************************************************************************************************************/

class ILogEntryList : public virtual IBase {
public:
	/**
	* ILogEntryList::Count - Returns the number of log entries in the list.
	* @return returns the number of retrieved log entries.
	*/
	virtual LibMCData_uint32 Count() = 0;

	/**
	* ILogEntryList::GetEntryByIndex - Returns a log entry in the list by its index.
	* @param[in] nIndex - Index of log entry, 0-based.
	* @param[out] nID - ID of log entry.
	* @param[out] sMessage - Log Message
	* @param[out] sSubSystem - Sub System identifier
	* @param[out] eLogLevel - Log Level
	* @param[out] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	virtual void GetEntryByIndex(const LibMCData_uint32 nIndex, LibMCData_uint32 & nID, std::string & sMessage, std::string & sSubSystem, LibMCData::eLogLevel & eLogLevel, std::string & sTimestamp) = 0;

	/**
	* ILogEntryList::GetEntryByID - Returns a log entry in the list by its ID.
	* @param[in] nID - ID of log entry.
	* @param[out] sMessage - Log Message
	* @param[out] sSubSystem - Sub System identifier
	* @param[out] eLogLevel - Log Level
	* @param[out] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	virtual void GetEntryByID(const LibMCData_uint32 nID, std::string & sMessage, std::string & sSubSystem, LibMCData::eLogLevel & eLogLevel, std::string & sTimestamp) = 0;

	/**
	* ILogEntryList::HasEntry - Returns if a log entry in the list exists.
	* @param[in] nID - ID of log entry.
	* @return Returns if a list exists.
	*/
	virtual bool HasEntry(const LibMCData_uint32 nID) = 0;

};

typedef IBaseSharedPtr<ILogEntryList> PILogEntryList;


/*************************************************************************************************************************
 Class interface for LogSession 
**************************************************************************************************************************/

class ILogSession : public virtual IBase {
public:
	/**
	* ILogSession::AddEntry - adds a new log entry.
	* @param[in] sMessage - Log Message
	* @param[in] sSubSystem - Sub System identifier
	* @param[in] eLogLevel - Log Level
	* @param[in] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	virtual void AddEntry(const std::string & sMessage, const std::string & sSubSystem, const LibMCData::eLogLevel eLogLevel, const std::string & sTimestamp) = 0;

	/**
	* ILogSession::GetMaxLogEntryID - retrieves the maximum log entry ID in the log.
	* @return Log entry ID
	*/
	virtual LibMCData_uint32 GetMaxLogEntryID() = 0;

	/**
	* ILogSession::RetrieveLogEntriesByID - retrieves an excerpt of the log.
	* @param[in] nMinLogID - Minimum log entry ID to receive.
	* @param[in] nMaxLogID - Maximum log entry ID to receive. MUST be between (MinLogID + 1) and (MinLogID + 65536).
	* @param[in] eMinLogLevel - Minimum Log Level to return.
	* @return Log Entry List.
	*/
	virtual ILogEntryList * RetrieveLogEntriesByID(const LibMCData_uint32 nMinLogID, const LibMCData_uint32 nMaxLogID, const LibMCData::eLogLevel eMinLogLevel) = 0;

};

typedef IBaseSharedPtr<ILogSession> PILogSession;


/*************************************************************************************************************************
 Class interface for StorageStream 
**************************************************************************************************************************/

class IStorageStream : public virtual IBase {
public:
	/**
	* IStorageStream::GetUUID - returns the uuid of a storage stream.
	* @return UUID String
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IStorageStream::GetTimeStamp - returns the timestamp of a storage stream.
	* @return Timestamp in ISO8601 UTC format
	*/
	virtual std::string GetTimeStamp() = 0;

	/**
	* IStorageStream::GetContextIdentifier - returns the context identifier of a storage stream.
	* @return Context Identifier String
	*/
	virtual std::string GetContextIdentifier() = 0;

	/**
	* IStorageStream::GetName - returns the name description of a storage stream.
	* @return Name String
	*/
	virtual std::string GetName() = 0;

	/**
	* IStorageStream::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	virtual std::string GetMIMEType() = 0;

	/**
	* IStorageStream::GetSHA2 - returns the sha256 checksum of a storage stream.
	* @return SHA1 String
	*/
	virtual std::string GetSHA2() = 0;

	/**
	* IStorageStream::GetSize - returns the size of a storage stream.
	* @return Size
	*/
	virtual LibMCData_uint64 GetSize() = 0;

	/**
	* IStorageStream::GetContent - returns the content of a storage stream.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[out] pContentNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pContentBuffer - uint8 buffer of Byte Content of the stream
	*/
	virtual void GetContent(LibMCData_uint64 nContentBufferSize, LibMCData_uint64* pContentNeededCount, LibMCData_uint8 * pContentBuffer) = 0;

	/**
	* IStorageStream::GetCallbacks - returns direct read access to the storage stream. The callbacks are only valid throughout the existence of the StorageStream instance.
	* @param[out] dTheReadCallback - Callback to call for reading a data chunk
	* @param[out] dTheSeekCallback - Callback to call for seeking in the stream.
	* @param[out] dStreamHandle - Handle of the stream.
	*/
	virtual void GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle) = 0;

};

typedef IBaseSharedPtr<IStorageStream> PIStorageStream;


/*************************************************************************************************************************
 Class interface for Storage 
**************************************************************************************************************************/

class IStorage : public virtual IBase {
public:
	/**
	* IStorage::StreamIsReady - checks if a stream exists and is written to disk.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream is ready.
	*/
	virtual bool StreamIsReady(const std::string & sUUID) = 0;

	/**
	* IStorage::RetrieveStream - retrieves an existing stream.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream Instance.
	*/
	virtual IStorageStream * RetrieveStream(const std::string & sUUID) = 0;

	/**
	* IStorage::StoreNewStream - stores a new stream.
	* @param[in] sUUID - UUID of storage stream. Must be unique and newly generated.
	* @param[in] sContextUUID - Context UUID of storage stream. Important for ownership and deletion.
	* @param[in] sContextIdentifier - Identifier of the stream. MUST be unique within the given context.
	* @param[in] sName - Name Description of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[in] pContentBuffer - Data of stream
	* @param[in] sUserID - Currently authenticated user
	*/
	virtual void StoreNewStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sContextIdentifier, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer, const std::string & sUserID) = 0;

	/**
	* IStorage::BeginPartialStream - starts storing a stream with partial uploads.
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sContextUUID - Context UUID of storage stream. Important for ownership and deletion.
	* @param[in] sContextIdentifier - Identifier of the stream. MUST be unique within the given context.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] nSize - Final size of the stream. MUST NOT be 0.
	* @param[in] sUserID - Currently authenticated user
	*/
	virtual void BeginPartialStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sContextIdentifier, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID) = 0;

	/**
	* IStorage::StorePartialStream - stores data in a stream with partial uploads. Uploads should be sequential for optimal performance, but may be in arbitrary order.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] nOffset - Offset in stream to store to. Can be an arbitrary position, but storage MUST NOT override already uploaded data.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[in] pContentBuffer - Data block to store in stream.
	*/
	virtual void StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer) = 0;

	/**
	* IStorage::FinishPartialStream - Finishes storing a stream.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sSHA2 - SHA256 of the uploaded data. If given initially, MUST be identical.
	*/
	virtual void FinishPartialStream(const std::string & sUUID, const std::string & sSHA2) = 0;

	/**
	* IStorage::FinishPartialStreamBlockwiseSHA256 - Finishes storing a stream with a 64k-Blockwise calculated Checksum.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sBlockwiseSHA2 - 64kB hashlist SHA256 checksum of the uploaded data. If given initially, MUST be identical.
	*/
	virtual void FinishPartialStreamBlockwiseSHA256(const std::string & sUUID, const std::string & sBlockwiseSHA2) = 0;

	/**
	* IStorage::GetMaxStreamSize - Returns the maximum stream size that the data model allows.
	* @return Maximum Stream Size in Bytes.
	*/
	virtual LibMCData_uint64 GetMaxStreamSize() = 0;

	/**
	* IStorage::ContentTypeIsAccepted - Returns if the given content type is an acceptable value.
	* @param[in] sContentType - Content type string (is taken case-insensitive)
	* @return Content type is accepted.
	*/
	virtual bool ContentTypeIsAccepted(const std::string & sContentType) = 0;

	/**
	* IStorage::StreamIsImage - checks if a stream is an image.
	* @param[in] sUUID - UUID of storage stream.
	* @return Returns if the stream is an image.
	*/
	virtual bool StreamIsImage(const std::string & sUUID) = 0;

};

typedef IBaseSharedPtr<IStorage> PIStorage;


/*************************************************************************************************************************
 Class interface for BuildJobData 
**************************************************************************************************************************/

class IBuildJobData : public virtual IBase {
public:
	/**
	* IBuildJobData::GetDataUUID - returns the uuid of a build job data.
	* @return UUID String
	*/
	virtual std::string GetDataUUID() = 0;

	/**
	* IBuildJobData::GetJobUUID - returns the uuid of the parent build job.
	* @return UUID String
	*/
	virtual std::string GetJobUUID() = 0;

	/**
	* IBuildJobData::GetName - returns the name of the job data.
	* @return Name String
	*/
	virtual std::string GetName() = 0;

	/**
	* IBuildJobData::GetContextIdentifier - returns the unique context identifier of the job data.
	* @return Context Identifier String
	*/
	virtual std::string GetContextIdentifier() = 0;

	/**
	* IBuildJobData::GetTimeStamp - returns the timestamp when the job data was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	virtual std::string GetTimeStamp() = 0;

	/**
	* IBuildJobData::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	virtual IStorageStream * GetStorageStream() = 0;

	/**
	* IBuildJobData::GetStorageStreamSHA2 - returns the checksum of the storage stream of the build.
	* @return SHA256 of the storage stream.
	*/
	virtual std::string GetStorageStreamSHA2() = 0;

	/**
	* IBuildJobData::GetStorageStreamSize - returns the size of the storage stream of the build.
	* @return size of the storage stream in bytes.
	*/
	virtual LibMCData_uint64 GetStorageStreamSize() = 0;

	/**
	* IBuildJobData::GetDataType - returns the data type of the job data.
	* @return Data type of the job data
	*/
	virtual LibMCData::eBuildJobDataType GetDataType() = 0;

	/**
	* IBuildJobData::GetDataTypeAsString - returns the data type of the job data as string.
	* @return Data type of the job data
	*/
	virtual std::string GetDataTypeAsString() = 0;

	/**
	* IBuildJobData::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	virtual std::string GetMIMEType() = 0;

};

typedef IBaseSharedPtr<IBuildJobData> PIBuildJobData;


/*************************************************************************************************************************
 Class interface for BuildJobDataIterator 
**************************************************************************************************************************/

class IBuildJobDataIterator : public virtual IIterator {
public:
	/**
	* IBuildJobDataIterator::GetCurrentJobData - Returns the build job data the iterator points at.
	* @return returns the build job instance.
	*/
	virtual IBuildJobData * GetCurrentJobData() = 0;

};

typedef IBaseSharedPtr<IBuildJobDataIterator> PIBuildJobDataIterator;


/*************************************************************************************************************************
 Class interface for BuildJob 
**************************************************************************************************************************/

class IBuildJob : public virtual IBase {
public:
	/**
	* IBuildJob::GetUUID - returns the uuid of a build job.
	* @return UUID String
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IBuildJob::GetName - returns the name of a build job.
	* @return Name String
	*/
	virtual std::string GetName() = 0;

	/**
	* IBuildJob::GetStatus - returns the status of a build job.
	* @return Status of build job.
	*/
	virtual LibMCData::eBuildJobStatus GetStatus() = 0;

	/**
	* IBuildJob::GetLayerCount - returns the layer count of a build job.
	* @return Layer Count of build job
	*/
	virtual LibMCData_uint32 GetLayerCount() = 0;

	/**
	* IBuildJob::GetTimeStamp - returns the timestamp when the job was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	virtual std::string GetTimeStamp() = 0;

	/**
	* IBuildJob::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	virtual IStorageStream * GetStorageStream() = 0;

	/**
	* IBuildJob::GetStorageStreamUUID - returns the storage stream uuid of the build.
	* @return Stream UUID.
	*/
	virtual std::string GetStorageStreamUUID() = 0;

	/**
	* IBuildJob::GetBuildJobLogger - creates a build job log session access class.
	* @return LogSession class instance.
	*/
	virtual ILogSession * GetBuildJobLogger() = 0;

	/**
	* IBuildJob::StartValidating - Starts validation of a build job.
	*/
	virtual void StartValidating() = 0;

	/**
	* IBuildJob::FinishValidating - Finishes validation of a build job.
	* @param[in] nLayerCount - Layer count
	*/
	virtual void FinishValidating(const LibMCData_uint32 nLayerCount) = 0;

	/**
	* IBuildJob::ArchiveJob - Archives a Job. Job MUST not be opened in the system. Job MUST be of state validated.
	*/
	virtual void ArchiveJob() = 0;

	/**
	* IBuildJob::UnArchiveJob - Unarchives a Job. Job MUST be of state archived.
	*/
	virtual void UnArchiveJob() = 0;

	/**
	* IBuildJob::DeleteJob - Deletes a Job permanently including all referencing data objects. Job MUST be of state archived to succeed.
	*/
	virtual void DeleteJob() = 0;

	/**
	* IBuildJob::JobCanBeArchived - Returns if a job is opened.
	* @return returns if the job can be archived.
	*/
	virtual bool JobCanBeArchived() = 0;

	/**
	* IBuildJob::AddJobData - Adds additional data to the Job. Job MUST be of state validated in order to add job data.
	* @param[in] sIdentifier - Unique identifier for the job data.
	* @param[in] sName - Name of the job data
	* @param[in] pStream - Storage Stream Instance
	* @param[in] eDataType - Datatype of Job data
	* @param[in] sUserID - Currently authenticated user
	*/
	virtual void AddJobData(const std::string & sIdentifier, const std::string & sName, IStorageStream* pStream, const LibMCData::eBuildJobDataType eDataType, const std::string & sUserID) = 0;

	/**
	* IBuildJob::ListJobDataByType - Retrieves a list of build job data objects, filtered by type.
	* @param[in] eDataType - Datatype of Job data.
	* @return Build Job Data Iterator Instance.
	*/
	virtual IBuildJobDataIterator * ListJobDataByType(const LibMCData::eBuildJobDataType eDataType) = 0;

	/**
	* IBuildJob::ListJobData - Retrieves a list of build job data objects.
	* @return Build Job Data Iterator Instance.
	*/
	virtual IBuildJobDataIterator * ListJobData() = 0;

	/**
	* IBuildJob::RetrieveJobData - Retrieves a build job data instance by its uuid.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Data Instance.
	*/
	virtual IBuildJobData * RetrieveJobData(const std::string & sDataUUID) = 0;

};

typedef IBaseSharedPtr<IBuildJob> PIBuildJob;


/*************************************************************************************************************************
 Class interface for BuildJobIterator 
**************************************************************************************************************************/

class IBuildJobIterator : public virtual IIterator {
public:
	/**
	* IBuildJobIterator::GetCurrentJob - Returns the build job the iterator points at.
	* @return returns the build job instance.
	*/
	virtual IBuildJob * GetCurrentJob() = 0;

};

typedef IBaseSharedPtr<IBuildJobIterator> PIBuildJobIterator;


/*************************************************************************************************************************
 Class interface for BuildJobHandler 
**************************************************************************************************************************/

class IBuildJobHandler : public virtual IBase {
public:
	/**
	* IBuildJobHandler::CreateJob - Creates a new build job.
	* @param[in] sJobUUID - UUID String for the build job. Must be unique and newly generated.
	* @param[in] sName - Name String
	* @param[in] sUserID - Currently authenticated user
	* @param[in] sStorageStreamUUID - Storage stream uuid for the job. Needs not exist yet.
	* @return Build Job Instance.
	*/
	virtual IBuildJob * CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID) = 0;

	/**
	* IBuildJobHandler::RetrieveJob - Retrieves a job with a specific UUID.
	* @param[in] sJobUUID - UUID String for the build job. Must be an existing Job.
	* @return Build Job Instance.
	*/
	virtual IBuildJob * RetrieveJob(const std::string & sJobUUID) = 0;

	/**
	* IBuildJobHandler::FindJobOfData - Finds the parent build job of a given data uuid. Fails if data does not exist.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Instance.
	*/
	virtual IBuildJob * FindJobOfData(const std::string & sDataUUID) = 0;

	/**
	* IBuildJobHandler::ListJobsByStatus - Retrieves a list of build jobs, filtered by status.
	* @param[in] eStatus - Job Status to list.
	* @return Build Job Iterator Instance.
	*/
	virtual IBuildJobIterator * ListJobsByStatus(const LibMCData::eBuildJobStatus eStatus) = 0;

	/**
	* IBuildJobHandler::ConvertBuildStatusToString - Converts a status enum to a string identifier.
	* @param[in] eStatus - Status Enum.
	* @return String Identifier.
	*/
	virtual std::string ConvertBuildStatusToString(const LibMCData::eBuildJobStatus eStatus) = 0;

	/**
	* IBuildJobHandler::ConvertStringToBuildStatus - Converts a string identifier to a status enum. Case sensitive. Fails if invalid.
	* @param[in] sString - String Identifier.
	* @return Status Enum.
	*/
	virtual LibMCData::eBuildJobStatus ConvertStringToBuildStatus(const std::string & sString) = 0;

};

typedef IBaseSharedPtr<IBuildJobHandler> PIBuildJobHandler;


/*************************************************************************************************************************
 Class interface for LoginHandler 
**************************************************************************************************************************/

class ILoginHandler : public virtual IBase {
public:
	/**
	* ILoginHandler::UserExists - Checks if a user exist.
	* @param[in] sUsername - User name
	* @return Flag if users exists
	*/
	virtual bool UserExists(const std::string & sUsername) = 0;

	/**
	* ILoginHandler::GetUserDetails - Retrieves a users data. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sSalt - Salt of the user.
	* @param[out] sHashedPassword - Hashed Password.
	*/
	virtual void GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword) = 0;

	/**
	* ILoginHandler::GetUserRole - Retrieves a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Role of the user.
	*/
	virtual std::string GetUserRole(const std::string & sUsername) = 0;

	/**
	* ILoginHandler::GetUserLanguage - Retrieves a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Language identifier of the user.
	*/
	virtual std::string GetUserLanguage(const std::string & sUsername) = 0;

};

typedef IBaseSharedPtr<ILoginHandler> PILoginHandler;


/*************************************************************************************************************************
 Class interface for PersistencyHandler 
**************************************************************************************************************************/

class IPersistencyHandler : public virtual IBase {
public:
	/**
	* IPersistencyHandler::HasPersistentParameter - Retrieves if a persistent parameter has been stored.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter exists.
	*/
	virtual bool HasPersistentParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::GetPersistentParameterDetails - Retrieves details of a persistent parameter. Fails if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @param[out] sName - Returns name of the parameter
	* @param[out] eDataType - Returns data type of the parameter
	*/
	virtual void GetPersistentParameterDetails(const std::string & sUUID, std::string & sName, LibMCData::eParameterDataType & eDataType) = 0;

	/**
	* IPersistencyHandler::DeletePersistentParameter - Removes a persistent parameter from database. Does nothing if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter existed.
	*/
	virtual bool DeletePersistentParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::StorePersistentParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] eDataType - Data type of the parameter. If parameter exists, MUST be the same as the stored parameter data type.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	*/
	virtual void StorePersistentParameter(const std::string & sUUID, const std::string & sName, const LibMCData::eParameterDataType eDataType, const std::string & sValue) = 0;

	/**
	* IPersistencyHandler::StorePersistentStringParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter.
	*/
	virtual void StorePersistentStringParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue) = 0;

	/**
	* IPersistencyHandler::StorePersistentUUIDParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	*/
	virtual void StorePersistentUUIDParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue) = 0;

	/**
	* IPersistencyHandler::StorePersistentDoubleParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] dValue - Value of the parameter.
	*/
	virtual void StorePersistentDoubleParameter(const std::string & sUUID, const std::string & sName, const LibMCData_double dValue) = 0;

	/**
	* IPersistencyHandler::StorePersistentIntegerParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] nValue - Value of the parameter.
	*/
	virtual void StorePersistentIntegerParameter(const std::string & sUUID, const std::string & sName, const LibMCData_int64 nValue) = 0;

	/**
	* IPersistencyHandler::StorePersistentBoolParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] bValue - Value of the parameter.
	*/
	virtual void StorePersistentBoolParameter(const std::string & sUUID, const std::string & sName, const bool bValue) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentStringParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual std::string RetrievePersistentStringParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentUUIDParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual std::string RetrievePersistentUUIDParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentDoubleParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual LibMCData_double RetrievePersistentDoubleParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentIntegerParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual LibMCData_int64 RetrievePersistentIntegerParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentBoolParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual bool RetrievePersistentBoolParameter(const std::string & sUUID) = 0;

};

typedef IBaseSharedPtr<IPersistencyHandler> PIPersistencyHandler;


/*************************************************************************************************************************
 Class interface for DataModel 
**************************************************************************************************************************/

class IDataModel : public virtual IBase {
public:
	/**
	* IDataModel::InitialiseDatabase - initializes the database connection.
	* @param[in] sDataDirectory - Directory that stores the data.
	* @param[in] eDataBaseType - Type of database.
	* @param[in] sConnectionString - Connection string.
	*/
	virtual void InitialiseDatabase(const std::string & sDataDirectory, const LibMCData::eDataBaseType eDataBaseType, const std::string & sConnectionString) = 0;

	/**
	* IDataModel::GetDataModelVersion - returns the linear data model version.
	* @return Data model version.
	*/
	virtual LibMCData_uint32 GetDataModelVersion() = 0;

	/**
	* IDataModel::GetInstallationInformation - returns unique identifiers for the current installation.
	* @param[out] sInstallationUUID - Installation UUID. Public value to document which installation was used for something.
	* @param[out] sInstallationSecret - Secret SHA256 key for seeding external-facing pseudo-randomness. MUST NOT be given outside of the application.
	*/
	virtual void GetInstallationInformation(std::string & sInstallationUUID, std::string & sInstallationSecret) = 0;

	/**
	* IDataModel::CreateStorage - creates a storage access class.
	* @return Storage class instance.
	*/
	virtual IStorage * CreateStorage() = 0;

	/**
	* IDataModel::CreateBuildJobHandler - creates a build job access class.
	* @return BuildJobHandler class instance.
	*/
	virtual IBuildJobHandler * CreateBuildJobHandler() = 0;

	/**
	* IDataModel::CreateNewLogSession - creates a global log session access class.
	* @return LogSession class instance.
	*/
	virtual ILogSession * CreateNewLogSession() = 0;

	/**
	* IDataModel::CreateLoginHandler - creates a login handler instance.
	* @return LoginHandler instance.
	*/
	virtual ILoginHandler * CreateLoginHandler() = 0;

	/**
	* IDataModel::CreatePersistencyHandler - creates a persistency handler instance.
	* @return PersistencyHandler instance.
	*/
	virtual IPersistencyHandler * CreatePersistencyHandler() = 0;

	/**
	* IDataModel::SetBaseTempDirectory - Sets a custom base temp directory. An empty string defaults to the system temp directory.
	* @param[in] sTempDirectory - Temp directory path to use. SHOULD be an absolute path, if not empty. Directory MUST exist, if not empty.
	*/
	virtual void SetBaseTempDirectory(const std::string & sTempDirectory) = 0;

	/**
	* IDataModel::GetBaseTempDirectory - Returns a custom base temp directory. An empty string defaults to the system temp directory.
	* @return Temp directory path.
	*/
	virtual std::string GetBaseTempDirectory() = 0;

	/**
	* IDataModel::SetLogCallback - Sets a log callback to be used for the execution.
	* @param[in] pLogCallback - callback function
	* @param[in] nUserData - Userdata that is passed to the callback function
	*/
	virtual void SetLogCallback(const LibMCData::LogCallback pLogCallback, const LibMCData_pvoid pUserData) = 0;

	/**
	* IDataModel::ClearLogCallback - Resets the log callback to be used for the execution.
	*/
	virtual void ClearLogCallback() = 0;

	/**
	* IDataModel::HasLogCallback - Returns if a log callback has been set.
	* @return Flag if log callback has been set.
	*/
	virtual bool HasLogCallback() = 0;

	/**
	* IDataModel::TriggerLogCallback - Triggers the log callback. Fails if no log callback has been set.
	* @param[in] sLogMessage - Log message to be logged.
	* @param[in] sSubSystem - SubSystem of Log Message.
	* @param[in] eLogLevel - Log Level to be used.
	* @param[in] sTimestamp - Timestamp of the log message.
	*/
	virtual void TriggerLogCallback(const std::string & sLogMessage, const std::string & sSubSystem, const LibMCData::eLogLevel eLogLevel, const std::string & sTimestamp) = 0;

};

typedef IBaseSharedPtr<IDataModel> PIDataModel;


/*************************************************************************************************************************
 Global functions declarations
**************************************************************************************************************************/
class CWrapper {
public:
	/**
	* Ilibmcdata::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	static void GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro);

	/**
	* Ilibmcdata::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	static bool GetLastError(IBase* pInstance, std::string & sErrorMessage);

	/**
	* Ilibmcdata::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void ReleaseInstance(IBase* pInstance);

	/**
	* Ilibmcdata::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void AcquireInstance(IBase* pInstance);

	/**
	* Ilibmcdata::CreateDataModelInstance - Creates and initializes new MC DataModel Instance.
	* @return New DataModel instance
	*/
	static IDataModel * CreateDataModelInstance();

};

LibMCDataResult LibMCData_GetProcAddress (const char * pProcName, void ** ppProcAddress);

} // namespace Impl
} // namespace LibMCData

#endif // __LIBMCDATA_CPPINTERFACES
