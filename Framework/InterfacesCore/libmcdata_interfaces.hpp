/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ header file in order to allow easy
development of Machine Control data model library. The implementer of Machine Control data model library needs to
derive concrete classes from the abstract classes in this header.

Interface version: 1.0.0

*/


#ifndef __LIBMCDATA_CPPINTERFACES
#define __LIBMCDATA_CPPINTERFACES

#include <string>
#include <memory>

#include "libmcdata_types.hpp"



namespace LibMCData {
namespace Impl {

/**
 Forward declarations of class interfaces
*/
class IBase;
class IIterator;
class ILogEntryList;
class ILogSession;
class IAlert;
class IAlertIterator;
class IAlertSession;
class IJournalSession;
class IStorageStream;
class IStorageZIPWriter;
class IStorage;
class ICustomDataStream;
class IBuildJobData;
class IBuildJobDataIterator;
class IBuildJobExecutionData;
class IBuildJobExecutionDataIterator;
class IBuildJobExecution;
class IBuildJobExecutionIterator;
class IBuildJob;
class IBuildJobIterator;
class IBuildJobHandler;
class IUserList;
class ILoginHandler;
class IPersistencyHandler;
class IInstallationInformation;
class IDataModel;



/*************************************************************************************************************************
 Parameter Cache definitions
**************************************************************************************************************************/

class ParameterCache {
	public:
		virtual ~ParameterCache() {}
};

template <class T1> class ParameterCache_1 : public ParameterCache {
	private:
		T1 m_param1;
	public:
		ParameterCache_1 (const T1 & param1)
			: m_param1 (param1)
		{
		}

		void retrieveData (T1 & param1)
		{
			param1 = m_param1;
		}
};

template <class T1, class T2> class ParameterCache_2 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
	public:
		ParameterCache_2 (const T1 & param1, const T2 & param2)
			: m_param1 (param1), m_param2 (param2)
		{
		}

		void retrieveData (T1 & param1, T2 & param2)
		{
			param1 = m_param1;
			param2 = m_param2;
		}
};

template <class T1, class T2, class T3> class ParameterCache_3 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
	public:
		ParameterCache_3 (const T1 & param1, const T2 & param2, const T3 & param3)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
		}
};

template <class T1, class T2, class T3, class T4> class ParameterCache_4 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
		T4 m_param4;
	public:
		ParameterCache_4 (const T1 & param1, const T2 & param2, const T3 & param3, const T4 & param4)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3), m_param4 (param4)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3, T4 & param4)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
			param4 = m_param4;
		}
};

template <class T1, class T2, class T3, class T4, class T5> class ParameterCache_5 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
		T4 m_param4;
		T5 m_param5;
	public:
		ParameterCache_5 (const T1 & param1, const T2 & param2, const T3 & param3, const T4 & param4, const T5 & param5)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3), m_param4 (param4), m_param5 (param5)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3, T4 & param4, T5 & param5)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
			param4 = m_param4;
			param5 = m_param5;
		}
};


/*************************************************************************************************************************
 Class interface for Base 
**************************************************************************************************************************/

class IBase {
private:
	std::unique_ptr<ParameterCache> m_ParameterCache;
public:
	/**
	* IBase::~IBase - virtual destructor of IBase
	*/
	virtual ~IBase() {};

	/**
	* IBase::ReleaseBaseClassInterface - Releases ownership of a base class interface. Deletes the reference, if necessary.
	* @param[in] pIBase - The base class instance to release
	*/
	static void ReleaseBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->DecRefCount();
		}
	};

	/**
	* IBase::AcquireBaseClassInterface - Acquires shared ownership of a base class interface.
	* @param[in] pIBase - The base class instance to acquire
	*/
	static void AcquireBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->IncRefCount();
		}
	};


	/**
	* IBase::GetLastErrorMessage - Returns the last error registered of this class instance
	* @param[out] sErrorMessage - Message of the last error registered
	* @return Has an error been registered already
	*/
	virtual bool GetLastErrorMessage(std::string & sErrorMessage) = 0;

	/**
	* IBase::ClearErrorMessages - Clears all registered messages of this class instance
	*/
	virtual void ClearErrorMessages() = 0;

	/**
	* IBase::RegisterErrorMessage - Registers an error message with this class instance
	* @param[in] sErrorMessage - Error message to register
	*/
	virtual void RegisterErrorMessage(const std::string & sErrorMessage) = 0;

	/**
	* IBase::IncRefCount - Increases the reference count of a class instance
	*/
	virtual void IncRefCount() = 0;

	/**
	* IBase::DecRefCount - Decreases the reference count of a class instance and free releases it, if the last reference has been removed
	* @return Has the object been released
	*/
	virtual bool DecRefCount() = 0;

	/**
	* IBase::_setCache - set parameter cache of object
	*/
	void _setCache(ParameterCache * pCache)
	{
		m_ParameterCache.reset(pCache);
	}

	/**
	* IBase::_getCache - returns parameter cache of object
	*/
	ParameterCache* _getCache()
	{
		return m_ParameterCache.get();
	}

};


/**
 Definition of a shared pointer class for IBase
*/
template<class T>
class IBaseSharedPtr : public std::shared_ptr<T>
{
public:
	explicit IBaseSharedPtr(T* t = nullptr)
		: std::shared_ptr<T>(t, IBase::ReleaseBaseClassInterface)
	{
		t->IncRefCount();
	}

	// Reset function, as it also needs to properly set the deleter.
	void reset(T* t = nullptr)
	{
		std::shared_ptr<T>::reset(t, IBase::ReleaseBaseClassInterface);
	}

	// Get-function that increases the Base class's reference count
	T* getCoOwningPtr()
	{
		T* t = this->get();
		t->IncRefCount();
		return t;
	}
};


typedef IBaseSharedPtr<IBase> PIBase;


/*************************************************************************************************************************
 Class interface for Iterator 
**************************************************************************************************************************/

class IIterator : public virtual IBase {
public:
	/**
	* IIterator::MoveNext - Iterates to the next resource in the list.
	* @return Iterates to the next resource in the list.
	*/
	virtual bool MoveNext() = 0;

	/**
	* IIterator::MovePrevious - Iterates to the previous resource in the list.
	* @return Iterates to the previous resource in the list.
	*/
	virtual bool MovePrevious() = 0;

	/**
	* IIterator::GetCurrent - Returns the resource the iterator points at.
	* @return returns the resource instance.
	*/
	virtual IBase * GetCurrent() = 0;

	/**
	* IIterator::Clone - Creates a new resource iterator with the same resource list.
	* @return returns the cloned Iterator instance
	*/
	virtual IIterator * Clone() = 0;

	/**
	* IIterator::Count - Returns the number of resources the iterator captures.
	* @return returns the number of resources the iterator captures.
	*/
	virtual LibMCData_uint64 Count() = 0;

};

typedef IBaseSharedPtr<IIterator> PIIterator;


/*************************************************************************************************************************
 Class interface for LogEntryList 
**************************************************************************************************************************/

class ILogEntryList : public virtual IBase {
public:
	/**
	* ILogEntryList::Count - Returns the number of log entries in the list.
	* @return returns the number of retrieved log entries.
	*/
	virtual LibMCData_uint32 Count() = 0;

	/**
	* ILogEntryList::GetEntryByIndex - Returns a log entry in the list by its index.
	* @param[in] nIndex - Index of log entry, 0-based.
	* @param[out] nID - ID of log entry.
	* @param[out] sMessage - Log Message
	* @param[out] sSubSystem - Sub System identifier
	* @param[out] eLogLevel - Log Level
	* @param[out] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	virtual void GetEntryByIndex(const LibMCData_uint32 nIndex, LibMCData_uint32 & nID, std::string & sMessage, std::string & sSubSystem, LibMCData::eLogLevel & eLogLevel, std::string & sTimestamp) = 0;

	/**
	* ILogEntryList::GetEntryByID - Returns a log entry in the list by its ID.
	* @param[in] nID - ID of log entry.
	* @param[out] sMessage - Log Message
	* @param[out] sSubSystem - Sub System identifier
	* @param[out] eLogLevel - Log Level
	* @param[out] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	virtual void GetEntryByID(const LibMCData_uint32 nID, std::string & sMessage, std::string & sSubSystem, LibMCData::eLogLevel & eLogLevel, std::string & sTimestamp) = 0;

	/**
	* ILogEntryList::HasEntry - Returns if a log entry in the list exists.
	* @param[in] nID - ID of log entry.
	* @return Returns if a list exists.
	*/
	virtual bool HasEntry(const LibMCData_uint32 nID) = 0;

};

typedef IBaseSharedPtr<ILogEntryList> PILogEntryList;


/*************************************************************************************************************************
 Class interface for LogSession 
**************************************************************************************************************************/

class ILogSession : public virtual IBase {
public:
	/**
	* ILogSession::GetSessionUUID - retrieves the session UUID.
	* @return Session UUID
	*/
	virtual std::string GetSessionUUID() = 0;

	/**
	* ILogSession::AddEntry - adds a new log entry.
	* @param[in] sMessage - Log Message
	* @param[in] sSubSystem - Sub System identifier
	* @param[in] eLogLevel - Log Level
	* @param[in] sTimestampUTC - Timestamp in ISO8601 UTC format
	*/
	virtual void AddEntry(const std::string & sMessage, const std::string & sSubSystem, const LibMCData::eLogLevel eLogLevel, const std::string & sTimestampUTC) = 0;

	/**
	* ILogSession::GetMaxLogEntryID - retrieves the maximum log entry ID in the log.
	* @return Log entry ID
	*/
	virtual LibMCData_uint32 GetMaxLogEntryID() = 0;

	/**
	* ILogSession::RetrieveLogEntriesByID - retrieves an excerpt of the log.
	* @param[in] nMinLogID - Minimum log entry ID to receive.
	* @param[in] nMaxLogID - Maximum log entry ID to receive. MUST be between (MinLogID + 1) and (MinLogID + 65536).
	* @param[in] eMinLogLevel - Minimum Log Level to return.
	* @return Log Entry List.
	*/
	virtual ILogEntryList * RetrieveLogEntriesByID(const LibMCData_uint32 nMinLogID, const LibMCData_uint32 nMaxLogID, const LibMCData::eLogLevel eMinLogLevel) = 0;

};

typedef IBaseSharedPtr<ILogSession> PILogSession;


/*************************************************************************************************************************
 Class interface for Alert 
**************************************************************************************************************************/

class IAlert : public virtual IBase {
public:
	/**
	* IAlert::GetUUID - Returns the Alert UUID.
	* @return Value.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IAlert::GetIdentifier - Returns the Alert Identifier.
	* @return Value.
	*/
	virtual std::string GetIdentifier() = 0;

	/**
	* IAlert::IsActive - Returns if the alert is actuve.
	* @return Returns if the alert is active.
	*/
	virtual bool IsActive() = 0;

	/**
	* IAlert::GetLevel - Returns the Alert Level.
	* @return Value.
	*/
	virtual LibMCData::eAlertLevel GetLevel() = 0;

	/**
	* IAlert::GetLevelString - Returns the Alert Level string.
	* @return Value.
	*/
	virtual std::string GetLevelString() = 0;

	/**
	* IAlert::GetDescription - Returns the Alert Description.
	* @return Value.
	*/
	virtual std::string GetDescription() = 0;

	/**
	* IAlert::GetDescriptionIdentifier - Returns the Alert DescriptionIdentifier.
	* @return Value.
	*/
	virtual std::string GetDescriptionIdentifier() = 0;

	/**
	* IAlert::GetReadableContextInformation - Returns the Alert ReadableContextInformation.
	* @return Value.
	*/
	virtual std::string GetReadableContextInformation() = 0;

	/**
	* IAlert::GetNeedsAcknowledgement - Returns if the Alert needs acknowledgement.
	* @return Value.
	*/
	virtual bool GetNeedsAcknowledgement() = 0;

	/**
	* IAlert::GetTimestampUTC - Returns the Alert Timestamp in UTC file format.
	* @return Value.
	*/
	virtual std::string GetTimestampUTC() = 0;

	/**
	* IAlert::HasBeenAcknowledged - Checks if the alert has been acknowledged.
	* @return Flag if the alert has been acknowledged.
	*/
	virtual bool HasBeenAcknowledged() = 0;

	/**
	* IAlert::GetAcknowledgementInformation - Returns details about the acknowledgement. Fails if the alert is not acknowledged.
	* @param[out] sUserUUID - User who acknowledged the alert.
	* @param[out] sUserComment - Comment of the acknowledgement.
	* @param[out] sAckTime - Timestamp in ISO8601 UTC format.
	*/
	virtual void GetAcknowledgementInformation(std::string & sUserUUID, std::string & sUserComment, std::string & sAckTime) = 0;

	/**
	* IAlert::AcknowledgeForUser - Acknowledges an alert for a specific user and sets it inactive. 
	* @param[in] sUserUUID - UUID of the user to acknowledge. Fails if user does not exist.
	* @param[in] sUserComment - User comment to store. May be empty.
	* @param[in] sTimestampUTC - Timestamp in UTC format.
	*/
	virtual void AcknowledgeForUser(const std::string & sUserUUID, const std::string & sUserComment, const std::string & sTimestampUTC) = 0;

	/**
	* IAlert::DeactivateAlert - Sets an alert inactive. It will not be marked as acknowledged by a certain user.
	*/
	virtual void DeactivateAlert() = 0;

};

typedef IBaseSharedPtr<IAlert> PIAlert;


/*************************************************************************************************************************
 Class interface for AlertIterator 
**************************************************************************************************************************/

class IAlertIterator : public virtual IIterator {
public:
	/**
	* IAlertIterator::GetCurrentAlert - Returns the alert the iterator points at.
	* @return returns the Alert instance.
	*/
	virtual IAlert * GetCurrentAlert() = 0;

};

typedef IBaseSharedPtr<IAlertIterator> PIAlertIterator;


/*************************************************************************************************************************
 Class interface for AlertSession 
**************************************************************************************************************************/

class IAlertSession : public virtual IBase {
public:
	/**
	* IAlertSession::AddAlert - adds a new alert entry.
	* @param[in] sUUID - Alert UUID
	* @param[in] sIdentifier - Alert Identifier
	* @param[in] eLevel - Alert level.
	* @param[in] sDescription - Alert Description in default language
	* @param[in] sDescriptionIdentifier - Alert Description Identifier for internationalization. May be empty.
	* @param[in] sReadableContextInformation - Readable Context Information in default language
	* @param[in] bNeedsAcknowledgement - Flag if acknowledgement is needed
	* @param[in] sTimestampUTC - Timestamp in ISO8601 UTC format
	* @return Alert Instance
	*/
	virtual IAlert * AddAlert(const std::string & sUUID, const std::string & sIdentifier, const LibMCData::eAlertLevel eLevel, const std::string & sDescription, const std::string & sDescriptionIdentifier, const std::string & sReadableContextInformation, const bool bNeedsAcknowledgement, const std::string & sTimestampUTC) = 0;

	/**
	* IAlertSession::HasAlert - Checks if an alert with a certain UUID exists.
	* @param[in] sUUID - Alert UUID. Fails if not a valid UUID is given.
	* @return Flag if alert exists
	*/
	virtual bool HasAlert(const std::string & sUUID) = 0;

	/**
	* IAlertSession::GetAlertByUUID - Retrieves the alert object. Fails if alert does not exist.
	* @param[in] sUUID - Alert UUID. Fails if not a valid UUID is given.
	* @return Alert Instance
	*/
	virtual IAlert * GetAlertByUUID(const std::string & sUUID) = 0;

	/**
	* IAlertSession::RetrieveAlerts - Retrieves all or all active alerts.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	virtual IAlertIterator * RetrieveAlerts(const bool bOnlyActive) = 0;

	/**
	* IAlertSession::RetrieveAlertsByType - Retrieves alerts of a certain type identifier.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	virtual IAlertIterator * RetrieveAlertsByType(const std::string & sIdentifier, const bool bOnlyActive) = 0;

};

typedef IBaseSharedPtr<IAlertSession> PIAlertSession;


/*************************************************************************************************************************
 Class interface for JournalSession 
**************************************************************************************************************************/

class IJournalSession : public virtual IBase {
public:
	/**
	* IJournalSession::GetSessionUUID - retrieves the session UUID.
	* @return Session UUID
	*/
	virtual std::string GetSessionUUID() = 0;

	/**
	* IJournalSession::WriteJournalChunkIntegerData - writes detailed journal state data to disk.
	* @param[in] nChunkIndex - Index of the Chunk to write
	* @param[in] nStartTimeStamp - Start Timestamp of the chunk (in microseconds)
	* @param[in] nEndTimeStamp - End Timestamp of the chunk (in microseconds)
	* @param[in] nVariableInfoBufferSize - Number of elements in buffer
	* @param[in] pVariableInfoBuffer - Variable information.
	* @param[in] nEntryDataBufferSize - Number of elements in buffer
	* @param[in] pEntryDataBuffer - Entry bulk data.
	*/
	virtual void WriteJournalChunkIntegerData(const LibMCData_uint32 nChunkIndex, const LibMCData_uint64 nStartTimeStamp, const LibMCData_uint64 nEndTimeStamp, const LibMCData_uint64 nVariableInfoBufferSize, const LibMCData::sJournalChunkVariableInfo * pVariableInfoBuffer, const LibMCData_uint64 nEntryDataBufferSize, const LibMCData::sJournalChunkIntegerEntry * pEntryDataBuffer) = 0;

	/**
	* IJournalSession::GetChunkCapacity - Returns the chunk capacity of the session journal.
	* @return Maximum Chunk Capacity in Journal in Bytes
	*/
	virtual LibMCData_uint32 GetChunkCapacity() = 0;

	/**
	* IJournalSession::GetFlushInterval - Returns the flush interval of the session journal.
	* @return The interval determines how often a session journal chunk is written to disk. In Seconds.
	*/
	virtual LibMCData_uint32 GetFlushInterval() = 0;

};

typedef IBaseSharedPtr<IJournalSession> PIJournalSession;


/*************************************************************************************************************************
 Class interface for StorageStream 
**************************************************************************************************************************/

class IStorageStream : public virtual IBase {
public:
	/**
	* IStorageStream::GetUUID - returns the uuid of a storage stream.
	* @return UUID String
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IStorageStream::GetTimeStamp - returns the timestamp of a storage stream.
	* @return Timestamp in ISO8601 UTC format
	*/
	virtual std::string GetTimeStamp() = 0;

	/**
	* IStorageStream::GetContextIdentifier - returns the context identifier of a storage stream.
	* @return Context Identifier String
	*/
	virtual std::string GetContextIdentifier() = 0;

	/**
	* IStorageStream::GetName - returns the name description of a storage stream.
	* @return Name String
	*/
	virtual std::string GetName() = 0;

	/**
	* IStorageStream::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	virtual std::string GetMIMEType() = 0;

	/**
	* IStorageStream::GetSHA2 - returns the sha256 checksum of a storage stream.
	* @return SHA1 String
	*/
	virtual std::string GetSHA2() = 0;

	/**
	* IStorageStream::GetSize - returns the size of a storage stream.
	* @return Size
	*/
	virtual LibMCData_uint64 GetSize() = 0;

	/**
	* IStorageStream::GetContent - returns the content of a storage stream.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[out] pContentNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pContentBuffer - uint8 buffer of Byte Content of the stream
	*/
	virtual void GetContent(LibMCData_uint64 nContentBufferSize, LibMCData_uint64* pContentNeededCount, LibMCData_uint8 * pContentBuffer) = 0;

	/**
	* IStorageStream::GetCallbacks - returns direct read access to the storage stream. The callbacks are only valid throughout the existence of the StorageStream instance.
	* @param[out] dTheReadCallback - Callback to call for reading a data chunk
	* @param[out] dTheSeekCallback - Callback to call for seeking in the stream.
	* @param[out] dStreamHandle - Handle of the stream.
	*/
	virtual void GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle) = 0;

};

typedef IBaseSharedPtr<IStorageStream> PIStorageStream;


/*************************************************************************************************************************
 Class interface for StorageZIPWriter 
**************************************************************************************************************************/

class IStorageZIPWriter : public virtual IBase {
public:
	/**
	* IStorageZIPWriter::StartNewEntry - Starts a new entry in the ZIP Stream. Finishes any unfinished entry. Fails if entry already exists. Fails if more than 1 billion entries exist in the ZIP file.
	* @param[in] sFileName - Filename of the entry. MUST be a valid filename.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	* @return Returns the current entry ID.
	*/
	virtual LibMCData_uint32 StartNewEntry(const std::string & sFileName, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IStorageZIPWriter::FinishCurrentEntry - Finishes the current entry in the ZIP stream. Writing is not possible, after an entry has been finished.
	*/
	virtual void FinishCurrentEntry() = 0;

	/**
	* IStorageZIPWriter::GetOpenEntryID - Returns the entry ID of the current open entry. Or 0, if no writing is possible.
	* @return Returns the current entry ID.
	*/
	virtual LibMCData_uint32 GetOpenEntryID() = 0;

	/**
	* IStorageZIPWriter::WriteData - Writes data into the currently open entry.
	* @param[in] nEntryID - Entry ID to write into. Checks again the current open entry ID and fails if there is a write attempt into any other entry ID.
	* @param[in] nDataBufferSize - Number of elements in buffer
	* @param[in] pDataBuffer - Data block to store in stream.
	*/
	virtual void WriteData(const LibMCData_uint32 nEntryID, const LibMCData_uint64 nDataBufferSize, const LibMCData_uint8 * pDataBuffer) = 0;

	/**
	* IStorageZIPWriter::GetEntrySize - Returns the size of an Entry with the corresponding ID. Fails if entry ID does not exist.
	* @param[in] nEntryID - Entry ID to check.
	* @return Returns the current entry size of the ZIP entry in bytes.
	*/
	virtual LibMCData_uint64 GetEntrySize(const LibMCData_uint32 nEntryID) = 0;

	/**
	* IStorageZIPWriter::GetZIPStreamSize - Returns the current size of the stream.
	* @return Current size of the stream.
	*/
	virtual LibMCData_uint64 GetZIPStreamSize() = 0;

	/**
	* IStorageZIPWriter::Finish - Finishes the stream writing as a whole, including all open entries. All subsequent write attempts will fail. Starting a new entry will fail. Fails if stream has been finished already.
	*/
	virtual void Finish() = 0;

	/**
	* IStorageZIPWriter::IsFinished - Returns if the stream writing has already been finished.
	* @return If true, writing into the stream is not possible anymore.
	*/
	virtual bool IsFinished() = 0;

};

typedef IBaseSharedPtr<IStorageZIPWriter> PIStorageZIPWriter;


/*************************************************************************************************************************
 Class interface for Storage 
**************************************************************************************************************************/

class IStorage : public virtual IBase {
public:
	/**
	* IStorage::StreamIsReady - checks if a stream exists and is written to disk.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream is ready.
	*/
	virtual bool StreamIsReady(const std::string & sUUID) = 0;

	/**
	* IStorage::RetrieveStream - retrieves an existing stream.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream Instance.
	*/
	virtual IStorageStream * RetrieveStream(const std::string & sUUID) = 0;

	/**
	* IStorage::StoreNewStream - stores a new stream.
	* @param[in] sUUID - UUID of storage stream. Must be unique and newly generated.
	* @param[in] sName - Name Description of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[in] pContentBuffer - Data of stream
	* @param[in] sUserID - Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void StoreNewStream(const std::string & sUUID, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IStorage::BeginPartialStream - starts storing a stream with partial uploads.
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] nSize - Final size of the stream. MUST NOT be 0.
	* @param[in] sUserID - Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void BeginPartialStream(const std::string & sUUID, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IStorage::StorePartialStream - stores data in a stream with partial uploads. Uploads should be sequential for optimal performance, but may be in arbitrary order.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] nOffset - Offset in stream to store to. Can be an arbitrary position, but storage MUST NOT override already uploaded data.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[in] pContentBuffer - Data block to store in stream.
	*/
	virtual void StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer) = 0;

	/**
	* IStorage::FinishPartialStream - Finishes storing a stream.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sSHA2 - SHA256 of the uploaded data. If given initially, MUST be identical.
	*/
	virtual void FinishPartialStream(const std::string & sUUID, const std::string & sSHA2) = 0;

	/**
	* IStorage::FinishPartialStreamBlockwiseSHA256 - Finishes storing a stream with a 64k-Blockwise calculated Checksum.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sBlockwiseSHA2 - 64kB hashlist SHA256 checksum of the uploaded data. If given initially, MUST be identical.
	*/
	virtual void FinishPartialStreamBlockwiseSHA256(const std::string & sUUID, const std::string & sBlockwiseSHA2) = 0;

	/**
	* IStorage::BeginRandomWriteStream - starts storing a stream with random write access. Checksums are not required.
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] sUserID - Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void BeginRandomWriteStream(const std::string & sUUID, const std::string & sName, const std::string & sMimeType, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IStorage::StoreRandomWriteStream - stores data in a stream with random write access. Writing may be in arbitrary order.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginRandomWriteStream first.
	* @param[in] nOffset - Offset in stream to store to. Can be an arbitrary position, but MUST be smaller or equal the current size.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[in] pContentBuffer - Data block to store in stream.
	*/
	virtual void StoreRandomWriteStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer) = 0;

	/**
	* IStorage::GetRandomWriteStreamSize - Returns the size random write stream .
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginRandomWriteStream first.
	* @return Current size in bytes.
	*/
	virtual LibMCData_uint64 GetRandomWriteStreamSize(const std::string & sUUID) = 0;

	/**
	* IStorage::FinishRandomWriteStream - Finishes storing a random write stream.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	*/
	virtual void FinishRandomWriteStream(const std::string & sUUID) = 0;

	/**
	* IStorage::GetMaxStreamSize - Returns the maximum stream size that the data model allows.
	* @return Maximum Stream Size in Bytes.
	*/
	virtual LibMCData_uint64 GetMaxStreamSize() = 0;

	/**
	* IStorage::CreateZIPStream - starts storing a stream with a streaming ZIP writer. MIME type will be application/zip
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sName - Name of the stream.
	* @param[in] sUserUUID - UUID of Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	* @return ZIP Writer instance
	*/
	virtual IStorageZIPWriter * CreateZIPStream(const std::string & sUUID, const std::string & sName, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IStorage::ContentTypeIsAccepted - Returns if the given content type is an acceptable value.
	* @param[in] sContentType - Content type string (is taken case-insensitive)
	* @return Content type is accepted.
	*/
	virtual bool ContentTypeIsAccepted(const std::string & sContentType) = 0;

	/**
	* IStorage::StreamIsImage - checks if a stream is an image.
	* @param[in] sUUID - UUID of storage stream.
	* @return Returns if the stream is an image.
	*/
	virtual bool StreamIsImage(const std::string & sUUID) = 0;

	/**
	* IStorage::CreateDownloadTicket - Creates a new download ticket for a stream and a user.
	* @param[in] sTicketUUID - UUID of download ticket.
	* @param[in] sStreamUUID - UUID of storage stream.
	* @param[in] sClientFileName - ClientFileName of the ticket. MUST NOT be empty.
	* @param[in] sSessionUUID - UUID of user session.
	* @param[in] sUserUUID - UUID of user that created the ticket.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void CreateDownloadTicket(const std::string & sTicketUUID, const std::string & sStreamUUID, const std::string & sClientFileName, const std::string & sSessionUUID, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IStorage::RequestDownloadTicket - Returns the details of a download ticket and creates an entry in an access log with time stamp.
	* @param[in] sTicketUUID - UUID of download ticket.
	* @param[in] sIPAddress - IP Address where the request came from.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	* @param[out] sStreamUUID - UUID of storage stream.
	* @param[out] sClientFileName - ClientFileName of the ticket.
	* @param[out] sSessionUUID - UUID of user session.
	* @param[out] sUserUUID - UUID of user that created the ticket.
	*/
	virtual void RequestDownloadTicket(const std::string & sTicketUUID, const std::string & sIPAddress, const LibMCData_uint64 nAbsoluteTimeStamp, std::string & sStreamUUID, std::string & sClientFileName, std::string & sSessionUUID, std::string & sUserUUID) = 0;

	/**
	* IStorage::AttachStreamToJournal - Attaches a stream to a journal as temporary stream.
	* @param[in] sStreamUUID - UUID of stream. Call fails if stream does not exist.
	* @param[in] sJournalUUID - UUID of journal. Call fails if journal does not exist.
	*/
	virtual void AttachStreamToJournal(const std::string & sStreamUUID, const std::string & sJournalUUID) = 0;

};

typedef IBaseSharedPtr<IStorage> PIStorage;


/*************************************************************************************************************************
 Class interface for CustomDataStream 
**************************************************************************************************************************/

class ICustomDataStream : public virtual IBase {
public:
	/**
	* ICustomDataStream::GetDataUUID - returns the uuid of the custom data.
	* @return UUID String
	*/
	virtual std::string GetDataUUID() = 0;

	/**
	* ICustomDataStream::GetIdentifier - returns the identifier of the custom data.
	* @return Name String
	*/
	virtual std::string GetIdentifier() = 0;

	/**
	* ICustomDataStream::GetName - returns the name of the custom data.
	* @return Name String
	*/
	virtual std::string GetName() = 0;

	/**
	* ICustomDataStream::GetTimeStamp - returns the timestamp when the custom data was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	virtual std::string GetTimeStamp() = 0;

	/**
	* ICustomDataStream::GetStorageStream - returns the storage stream.
	* @return Stream Instance.
	*/
	virtual IStorageStream * GetStorageStream() = 0;

	/**
	* ICustomDataStream::GetStorageStreamUUID - returns the UUID of the storage stream.
	* @return UUID of the storage stream.
	*/
	virtual std::string GetStorageStreamUUID() = 0;

	/**
	* ICustomDataStream::GetStorageStreamSHA2 - returns the checksum of the storage stream.
	* @return SHA256 of the storage stream.
	*/
	virtual std::string GetStorageStreamSHA2() = 0;

	/**
	* ICustomDataStream::GetStorageStreamSize - returns the size of the storage stream of the build.
	* @return size of the storage stream in bytes.
	*/
	virtual LibMCData_uint64 GetStorageStreamSize() = 0;

	/**
	* ICustomDataStream::GetUserUUID - returns the UUID of the user who created the stream.
	* @return UUID of the user who create the stream.
	*/
	virtual std::string GetUserUUID() = 0;

	/**
	* ICustomDataStream::GetDataType - returns the data type of the custom data.
	* @return Data type of the custom data
	*/
	virtual LibMCData::eCustomDataType GetDataType() = 0;

	/**
	* ICustomDataStream::GetDataTypeAsString - returns the data type of the custom data as string.
	* @return Data type of the job data
	*/
	virtual std::string GetDataTypeAsString() = 0;

	/**
	* ICustomDataStream::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	virtual std::string GetMIMEType() = 0;

};

typedef IBaseSharedPtr<ICustomDataStream> PICustomDataStream;


/*************************************************************************************************************************
 Class interface for BuildJobData 
**************************************************************************************************************************/

class IBuildJobData : public virtual ICustomDataStream {
public:
	/**
	* IBuildJobData::GetJobUUID - returns the uuid of the parent build job.
	* @return UUID String
	*/
	virtual std::string GetJobUUID() = 0;

};

typedef IBaseSharedPtr<IBuildJobData> PIBuildJobData;


/*************************************************************************************************************************
 Class interface for BuildJobDataIterator 
**************************************************************************************************************************/

class IBuildJobDataIterator : public virtual IIterator {
public:
	/**
	* IBuildJobDataIterator::GetCurrentJobData - Returns the build job data the iterator points at.
	* @return returns the build job instance.
	*/
	virtual IBuildJobData * GetCurrentJobData() = 0;

};

typedef IBaseSharedPtr<IBuildJobDataIterator> PIBuildJobDataIterator;


/*************************************************************************************************************************
 Class interface for BuildJobExecutionData 
**************************************************************************************************************************/

class IBuildJobExecutionData : public virtual ICustomDataStream {
public:
	/**
	* IBuildJobExecutionData::GetExecutionUUID - returns the uuid of the parent build job execution.
	* @return UUID String
	*/
	virtual std::string GetExecutionUUID() = 0;

};

typedef IBaseSharedPtr<IBuildJobExecutionData> PIBuildJobExecutionData;


/*************************************************************************************************************************
 Class interface for BuildJobExecutionDataIterator 
**************************************************************************************************************************/

class IBuildJobExecutionDataIterator : public virtual IIterator {
public:
	/**
	* IBuildJobExecutionDataIterator::GetCurrentJobExecutionData - Returns the build job execution data the iterator points at.
	* @return returns the build job execution instance.
	*/
	virtual IBuildJobExecutionData * GetCurrentJobExecutionData() = 0;

};

typedef IBaseSharedPtr<IBuildJobExecutionDataIterator> PIBuildJobExecutionDataIterator;


/*************************************************************************************************************************
 Class interface for BuildJobExecution 
**************************************************************************************************************************/

class IBuildJobExecution : public virtual IBase {
public:
	/**
	* IBuildJobExecution::GetExecutionUUID - returns the uuid of a build job execution.
	* @return UUID String
	*/
	virtual std::string GetExecutionUUID() = 0;

	/**
	* IBuildJobExecution::GetJobUUID - returns the uuid of the parent build job.
	* @return UUID String
	*/
	virtual std::string GetJobUUID() = 0;

	/**
	* IBuildJobExecution::GetStatus - returns the build job execution status.
	* @return Status Value
	*/
	virtual LibMCData::eBuildJobExecutionStatus GetStatus() = 0;

	/**
	* IBuildJobExecution::ChangeStatus - sets the new build job execution status. Will fail if current status is not InProcess.
	* @param[in] eNewExecutionStatus - Status Value
	* @param[in] nAbsoluteEndTimeStampInMicrosecondsSince1970 - New End Time of execution in Microseconds since 1970. MUST be larger or equal than start time stamp.
	*/
	virtual void ChangeStatus(const LibMCData::eBuildJobExecutionStatus eNewExecutionStatus, const LibMCData_uint64 nAbsoluteEndTimeStampInMicrosecondsSince1970) = 0;

	/**
	* IBuildJobExecution::GetDescription - returns the build job description.
	* @return Current Description.
	*/
	virtual std::string GetDescription() = 0;

	/**
	* IBuildJobExecution::SetDescription - sets the build job description. Should not be an empty string.
	* @param[in] sNewDescription - New Description.
	*/
	virtual void SetDescription(const std::string & sNewDescription) = 0;

	/**
	* IBuildJobExecution::GetJournalUUID - returns the uuid of the execution journal.
	* @return UUID String
	*/
	virtual std::string GetJournalUUID() = 0;

	/**
	* IBuildJobExecution::GetUserUUID - returns the uuid of the user that created the build job.
	* @return UUID String or 00000000-0000-0000-0000-000000000000 if no user is attached.
	*/
	virtual std::string GetUserUUID() = 0;

	/**
	* IBuildJobExecution::GetStartTimeStampInMicroseconds - Returns the start time stamp of the build execution in the machine journal.
	* @return TimeStamp when the build started in Microseconds.
	*/
	virtual LibMCData_uint64 GetStartTimeStampInMicroseconds() = 0;

	/**
	* IBuildJobExecution::GetEndTimeStampInMicroseconds - Returns the end time stamp of the build execution in the machine journal. Status MUST BE in Finished or Failed to retrieve this value.
	* @return TimeStamp when the build ended in Microseconds.
	*/
	virtual LibMCData_uint64 GetEndTimeStampInMicroseconds() = 0;

	/**
	* IBuildJobExecution::ComputeElapsedTimeInMicroseconds - Computes the relative time of the build execution. If status is Finished or Failed, the full duration is returned. Fails if the journal UUID does not match the current journaling session.
	* @param[in] nGlobalTimerInMicroseconds - The current session global timer.
	* @return Elapsed time in Microseconds.
	*/
	virtual LibMCData_uint64 ComputeElapsedTimeInMicroseconds(const LibMCData_uint64 nGlobalTimerInMicroseconds) = 0;

	/**
	* IBuildJobExecution::AddJobExecutionData - Adds additional data to the Job Execution.
	* @param[in] sIdentifier - Unique identifier for the job data.
	* @param[in] sName - Name of the job data
	* @param[in] pStream - Storage Stream Instance
	* @param[in] eDataType - Datatype of Job Execution data
	* @param[in] sUserUUID - UUID of Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void AddJobExecutionData(const std::string & sIdentifier, const std::string & sName, IStorageStream* pStream, const LibMCData::eCustomDataType eDataType, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IBuildJobExecution::ListJobExecutionDataByType - Retrieves a list of build job execution data objects, filtered by type.
	* @param[in] eDataType - Datatype of Job Execution data.
	* @return Build Job Execution Data Iterator Instance.
	*/
	virtual IBuildJobExecutionDataIterator * ListJobExecutionDataByType(const LibMCData::eCustomDataType eDataType) = 0;

	/**
	* IBuildJobExecution::ListJobExecutionData - Retrieves a list of build job execution data objects.
	* @return Build Job Execution Data Iterator Instance.
	*/
	virtual IBuildJobExecutionDataIterator * ListJobExecutionData() = 0;

	/**
	* IBuildJobExecution::RetrieveJobExecutionData - Retrieves a build job execution data instance by its uuid.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job ExecutionData Instance.
	*/
	virtual IBuildJobExecutionData * RetrieveJobExecutionData(const std::string & sDataUUID) = 0;

	/**
	* IBuildJobExecution::RetrieveJobExecutionDataByIdentifier - Retrieves a build job execution data instance by its identifier.
	* @param[in] sIdentifier - Job Execution Data Identifier. Fails if identifier does not exist.
	* @return Build Job Execution Data Instance.
	*/
	virtual IBuildJobExecutionData * RetrieveJobExecutionDataByIdentifier(const std::string & sIdentifier) = 0;

	/**
	* IBuildJobExecution::HasJobExecutionDataUUID - Retrieves if a build job execution data instance with a specific UUID exists in this job execution.
	* @param[in] sUUID - Job Execution Data UUID. Fails if UUID does not exist.
	* @return Returns true, if the job execution data exists.
	*/
	virtual bool HasJobExecutionDataUUID(const std::string & sUUID) = 0;

	/**
	* IBuildJobExecution::HasJobExecutionDataIdentifier - Retrieves if a build job execution data instance with a specific identifier exists.
	* @param[in] sIdentifier - Job Execution Data Identifier. Fails if identifier does not exist.
	* @return Returns true, if the job execution data exists.
	*/
	virtual bool HasJobExecutionDataIdentifier(const std::string & sIdentifier) = 0;

	/**
	* IBuildJobExecution::StoreMetaDataString - Adds a Metadata String to the build job.
	* @param[in] sKey - Unique key of value. MUST NOT be empty. MUST consist of alphanumeric characters or hyphen or underscore. Fails if Key already exists.
	* @param[in] sValue - Value to store.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void StoreMetaDataString(const std::string & sKey, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IBuildJobExecution::HasMetaDataString - Checks if a metadata string exists.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Returns if metadata string exists.
	*/
	virtual bool HasMetaDataString(const std::string & sKey) = 0;

	/**
	* IBuildJobExecution::GetMetaDataString - Gets a metadata string of a build execution. Fails if Meta Data does not exist.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Return value.
	*/
	virtual std::string GetMetaDataString(const std::string & sKey) = 0;

};

typedef IBaseSharedPtr<IBuildJobExecution> PIBuildJobExecution;


/*************************************************************************************************************************
 Class interface for BuildJobExecutionIterator 
**************************************************************************************************************************/

class IBuildJobExecutionIterator : public virtual IIterator {
public:
	/**
	* IBuildJobExecutionIterator::GetCurrentJobExecution - Returns the build job execution the iterator points at.
	* @return returns the build job  execution instance.
	*/
	virtual IBuildJobExecution * GetCurrentJobExecution() = 0;

};

typedef IBaseSharedPtr<IBuildJobExecutionIterator> PIBuildJobExecutionIterator;


/*************************************************************************************************************************
 Class interface for BuildJob 
**************************************************************************************************************************/

class IBuildJob : public virtual IBase {
public:
	/**
	* IBuildJob::GetUUID - returns the uuid of a build job.
	* @return UUID String
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IBuildJob::GetName - returns the name of a build job.
	* @return Name String
	*/
	virtual std::string GetName() = 0;

	/**
	* IBuildJob::GetStatus - returns the status of a build job.
	* @return Status of build job.
	*/
	virtual LibMCData::eBuildJobStatus GetStatus() = 0;

	/**
	* IBuildJob::GetLayerCount - returns the layer count of a build job.
	* @return Layer Count of build job
	*/
	virtual LibMCData_uint32 GetLayerCount() = 0;

	/**
	* IBuildJob::GetTimeStamp - returns the timestamp when the job was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	virtual std::string GetTimeStamp() = 0;

	/**
	* IBuildJob::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	virtual IStorageStream * GetStorageStream() = 0;

	/**
	* IBuildJob::GetStorageStreamUUID - returns the storage stream uuid of the build.
	* @return Stream UUID.
	*/
	virtual std::string GetStorageStreamUUID() = 0;

	/**
	* IBuildJob::StartValidating - Starts validation of a build job.
	*/
	virtual void StartValidating() = 0;

	/**
	* IBuildJob::FinishValidating - Finishes validation of a build job.
	* @param[in] nLayerCount - Layer count
	*/
	virtual void FinishValidating(const LibMCData_uint32 nLayerCount) = 0;

	/**
	* IBuildJob::ArchiveJob - Archives a Job. Job MUST not be opened in the system. Job MUST be of state validated.
	*/
	virtual void ArchiveJob() = 0;

	/**
	* IBuildJob::UnArchiveJob - Unarchives a Job. Job MUST be of state archived.
	*/
	virtual void UnArchiveJob() = 0;

	/**
	* IBuildJob::DeleteJob - Deletes a Job permanently including all referencing data objects. Job MUST be of state archived to succeed.
	*/
	virtual void DeleteJob() = 0;

	/**
	* IBuildJob::JobCanBeArchived - Returns if a job is opened.
	* @return returns if the job can be archived.
	*/
	virtual bool JobCanBeArchived() = 0;

	/**
	* IBuildJob::AddJobData - Adds additional data to the Job. Job MUST be of state validated in order to add job data.
	* @param[in] sIdentifier - Unique identifier for the job data.
	* @param[in] sName - Name of the job data
	* @param[in] pStream - Storage Stream Instance
	* @param[in] eDataType - Datatype of Job data
	* @param[in] sUserID - Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970
	*/
	virtual void AddJobData(const std::string & sIdentifier, const std::string & sName, IStorageStream* pStream, const LibMCData::eCustomDataType eDataType, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IBuildJob::ListJobDataByType - Retrieves a list of build job data objects, filtered by type.
	* @param[in] eDataType - Datatype of Job data.
	* @return Build Job Data Iterator Instance.
	*/
	virtual IBuildJobDataIterator * ListJobDataByType(const LibMCData::eCustomDataType eDataType) = 0;

	/**
	* IBuildJob::ListJobData - Retrieves a list of build job data objects.
	* @return Build Job Data Iterator Instance.
	*/
	virtual IBuildJobDataIterator * ListJobData() = 0;

	/**
	* IBuildJob::RetrieveJobData - Retrieves a build job data instance by its uuid.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Data Instance.
	*/
	virtual IBuildJobData * RetrieveJobData(const std::string & sDataUUID) = 0;

	/**
	* IBuildJob::RetrieveJobDataByIdentifier - Retrieves a build job data instance by its identifier.
	* @param[in] sIdentifier - Job Data Identifier. Fails if identifier does not exist.
	* @return Build Job Data Instance.
	*/
	virtual IBuildJobData * RetrieveJobDataByIdentifier(const std::string & sIdentifier) = 0;

	/**
	* IBuildJob::HasJobDataUUID - Retrieves if a build job data instance with a specific UUID exists.
	* @param[in] sUUID - Job Data UUID. Fails if UUID does not exist.
	* @return Returns true, if the job data exists.
	*/
	virtual bool HasJobDataUUID(const std::string & sUUID) = 0;

	/**
	* IBuildJob::HasJobDataIdentifier - Retrieves if a build job data instance with a specific identifier exists.
	* @param[in] sIdentifier - Job Data Identifier. Fails if identifier does not exist.
	* @return Returns true, if the job data exists.
	*/
	virtual bool HasJobDataIdentifier(const std::string & sIdentifier) = 0;

	/**
	* IBuildJob::StoreMetaDataString - Adds a Metadata String to the build job.
	* @param[in] sKey - Unique key of value. MUST NOT be empty. MUST consist of alphanumeric characters or hyphen or underscore. Fails if Key already exists.
	* @param[in] sValue - Value to store.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void StoreMetaDataString(const std::string & sKey, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IBuildJob::HasMetaDataString - Checks if a metadata string exists.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Returns if metadata string exists.
	*/
	virtual bool HasMetaDataString(const std::string & sKey) = 0;

	/**
	* IBuildJob::GetMetaDataString - Gets a metadata string of a build execution. Fails if Meta Data does not exist.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Return value.
	*/
	virtual std::string GetMetaDataString(const std::string & sKey) = 0;

	/**
	* IBuildJob::CreateBuildJobExecution - Creates a new build job execution with state InProgress.
	* @param[in] sDescription - Description of the execution.
	* @param[in] sUserUUID - UUID of the user who created it. Use 00000000-0000-0000-0000-000000000000 if no user shall be recorded.
	* @param[in] nAbsoluteStartTimeStampInMicrosecondsSince1970 - Absolute Start Time in Microseconds since 1970.
	* @return Newly created execution instance.
	*/
	virtual IBuildJobExecution * CreateBuildJobExecution(const std::string & sDescription, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteStartTimeStampInMicrosecondsSince1970) = 0;

	/**
	* IBuildJob::RetrieveBuildJobExecution - Retrieves a new build job execution by uuid.
	* @param[in] sExecutionUUID - UUID of the execution to retrieve.
	* @return If UUID exists, returns execution instance. Otherwise, returns null.
	*/
	virtual IBuildJobExecution * RetrieveBuildJobExecution(const std::string & sExecutionUUID) = 0;

	/**
	* IBuildJob::RetrieveBuildJobExecutions - Retrieves multiple executions of the build job.
	* @param[in] sJournalUUIDFilter - UUID of the journal to filter from. Ignored if empty string.
	* @return Returns the list of execution instances that are queried. List may be empty.
	*/
	virtual IBuildJobExecutionIterator * RetrieveBuildJobExecutions(const std::string & sJournalUUIDFilter) = 0;

	/**
	* IBuildJob::RetrieveBuildJobExecutionsByStatus - Retrieves multiple executions of the build job.
	* @param[in] eStatusFilter - Status to filter the executions from.
	* @param[in] sJournalUUIDFilter - UUID of the journal to filter from. Ignored if empty string.
	* @return Returns the list of execution instances that are queried. List may be empty.
	*/
	virtual IBuildJobExecutionIterator * RetrieveBuildJobExecutionsByStatus(const LibMCData::eBuildJobExecutionStatus eStatusFilter, const std::string & sJournalUUIDFilter) = 0;

};

typedef IBaseSharedPtr<IBuildJob> PIBuildJob;


/*************************************************************************************************************************
 Class interface for BuildJobIterator 
**************************************************************************************************************************/

class IBuildJobIterator : public virtual IIterator {
public:
	/**
	* IBuildJobIterator::GetCurrentJob - Returns the build job the iterator points at.
	* @return returns the build job instance.
	*/
	virtual IBuildJob * GetCurrentJob() = 0;

};

typedef IBaseSharedPtr<IBuildJobIterator> PIBuildJobIterator;


/*************************************************************************************************************************
 Class interface for BuildJobHandler 
**************************************************************************************************************************/

class IBuildJobHandler : public virtual IBase {
public:
	/**
	* IBuildJobHandler::CreateJob - Creates a new build job.
	* @param[in] sJobUUID - UUID String for the build job. Must be unique and newly generated.
	* @param[in] sName - Name String
	* @param[in] sUserID - Currently authenticated user
	* @param[in] sStorageStreamUUID - Storage stream uuid for the job. Needs not exist yet.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	* @return Build Job Instance.
	*/
	virtual IBuildJob * CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IBuildJobHandler::RetrieveJob - Retrieves a job with a specific UUID.
	* @param[in] sJobUUID - UUID String for the build job. Must be an existing Job.
	* @return Build Job Instance.
	*/
	virtual IBuildJob * RetrieveJob(const std::string & sJobUUID) = 0;

	/**
	* IBuildJobHandler::FindJobOfData - Finds the parent build job of a given data uuid. Fails if data does not exist.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Instance.
	*/
	virtual IBuildJob * FindJobOfData(const std::string & sDataUUID) = 0;

	/**
	* IBuildJobHandler::ListJobsByStatus - Retrieves a list of build jobs, filtered by status.
	* @param[in] eStatus - Job Status to list.
	* @return Build Job Iterator Instance.
	*/
	virtual IBuildJobIterator * ListJobsByStatus(const LibMCData::eBuildJobStatus eStatus) = 0;

	/**
	* IBuildJobHandler::ConvertBuildStatusToString - Converts a status enum to a string identifier.
	* @param[in] eStatus - Status Enum.
	* @return String Identifier.
	*/
	virtual std::string ConvertBuildStatusToString(const LibMCData::eBuildJobStatus eStatus) = 0;

	/**
	* IBuildJobHandler::ConvertStringToBuildStatus - Converts a string identifier to a status enum. Case sensitive. Fails if invalid.
	* @param[in] sString - String Identifier.
	* @return Status Enum.
	*/
	virtual LibMCData::eBuildJobStatus ConvertStringToBuildStatus(const std::string & sString) = 0;

};

typedef IBaseSharedPtr<IBuildJobHandler> PIBuildJobHandler;


/*************************************************************************************************************************
 Class interface for UserList 
**************************************************************************************************************************/

class IUserList : public virtual IBase {
public:
	/**
	* IUserList::Count - Result Number of Users in the list.
	* @return Number of users in the list
	*/
	virtual LibMCData_uint32 Count() = 0;

	/**
	* IUserList::GetUserProperties - Retrieves all the data of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @param[out] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	virtual void GetUserProperties(const LibMCData_uint32 nUserIndex, std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier) = 0;

};

typedef IBaseSharedPtr<IUserList> PIUserList;


/*************************************************************************************************************************
 Class interface for LoginHandler 
**************************************************************************************************************************/

class ILoginHandler : public virtual IBase {
public:
	/**
	* ILoginHandler::UserExists - Checks if a user exist.
	* @param[in] sUsername - User name
	* @return Flag if users exists
	*/
	virtual bool UserExists(const std::string & sUsername) = 0;

	/**
	* ILoginHandler::UserUUIDExists - Checks if a user UUID exist.
	* @param[in] sUUID - UUID of the user.
	* @return Flag if users exists
	*/
	virtual bool UserUUIDExists(const std::string & sUUID) = 0;

	/**
	* ILoginHandler::GetUserDetails - Retrieves login relevant users data. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sSalt - Salt of the user.
	* @param[out] sHashedPassword - Hashed Password.
	*/
	virtual void GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword) = 0;

	/**
	* ILoginHandler::GetUserProperties - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	virtual void GetUserProperties(const std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier) = 0;

	/**
	* ILoginHandler::GetUserPropertiesByUUID - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[out] sUsername - User name
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	virtual void GetUserPropertiesByUUID(const std::string & sUUID, std::string & sUsername, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier) = 0;

	/**
	* ILoginHandler::GetUsernameByUUID - Retrieves a users name with a given UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return User name
	*/
	virtual std::string GetUsernameByUUID(const std::string & sUUID) = 0;

	/**
	* ILoginHandler::GetUserUUID - Retrieves a users UUID. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return UUID of the user.
	*/
	virtual std::string GetUserUUID(const std::string & sUsername) = 0;

	/**
	* ILoginHandler::GetUserDescription - Retrieves a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Description of the user.
	*/
	virtual std::string GetUserDescription(const std::string & sUsername) = 0;

	/**
	* ILoginHandler::GetUserDescriptionByUUID - Retrieves a users description by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Description of the user.
	*/
	virtual std::string GetUserDescriptionByUUID(const std::string & sUUID) = 0;

	/**
	* ILoginHandler::GetUserRole - Retrieves a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Role of the user.
	*/
	virtual std::string GetUserRole(const std::string & sUsername) = 0;

	/**
	* ILoginHandler::GetUserRoleByUUID - Retrieves a users role by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Role of the user.
	*/
	virtual std::string GetUserRoleByUUID(const std::string & sUUID) = 0;

	/**
	* ILoginHandler::GetUserLanguage - Retrieves a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Language identifier of the user.
	*/
	virtual std::string GetUserLanguage(const std::string & sUsername) = 0;

	/**
	* ILoginHandler::GetUserLanguageByUUID - Retrieves a users language preference by user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Language identifier of the user.
	*/
	virtual std::string GetUserLanguageByUUID(const std::string & sUUID) = 0;

	/**
	* ILoginHandler::CreateUser - Creates a new user. Fails if the user already exists.
	* @param[in] sUsername - User name to create. MUST be alphanumeric and not empty.
	* @param[in] sRole - Role of the new user. MUST NOT be empty.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	* @param[in] sDescription - Description of the new user.
	* @return UUID of the new user.
	*/
	virtual std::string CreateUser(const std::string & sUsername, const std::string & sRole, const std::string & sSalt, const std::string & sHashedPassword, const std::string & sDescription) = 0;

	/**
	* ILoginHandler::SetUserLanguage - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	virtual void SetUserLanguage(const std::string & sUsername, const std::string & sLanguageIdentifier) = 0;

	/**
	* ILoginHandler::SetUserRole - Updates a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sRole - New Role identifier of the user.
	*/
	virtual void SetUserRole(const std::string & sUsername, const std::string & sRole) = 0;

	/**
	* ILoginHandler::SetUserDescription - Updates a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sDescription - New Description of the user.
	*/
	virtual void SetUserDescription(const std::string & sUsername, const std::string & sDescription) = 0;

	/**
	* ILoginHandler::SetUserPassword - Updates a users password. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	virtual void SetUserPassword(const std::string & sUsername, const std::string & sSalt, const std::string & sHashedPassword) = 0;

	/**
	* ILoginHandler::SetUserLanguageByUUID - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	virtual void SetUserLanguageByUUID(const std::string & sUUID, const std::string & sLanguageIdentifier) = 0;

	/**
	* ILoginHandler::SetUserRoleByUUID - Updates a users role. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sRole - New Role identifier of the user.
	*/
	virtual void SetUserRoleByUUID(const std::string & sUUID, const std::string & sRole) = 0;

	/**
	* ILoginHandler::SetUserDescriptionByUUID - Updates a users description. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sDescription - New Language identifier of the user.
	*/
	virtual void SetUserDescriptionByUUID(const std::string & sUUID, const std::string & sDescription) = 0;

	/**
	* ILoginHandler::SetUserPasswordByUUID - Updates a users password. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	virtual void SetUserPasswordByUUID(const std::string & sUUID, const std::string & sSalt, const std::string & sHashedPassword) = 0;

	/**
	* ILoginHandler::GetActiveUsers - Returns a list of active users.
	* @return New instance of active users.
	*/
	virtual IUserList * GetActiveUsers() = 0;

};

typedef IBaseSharedPtr<ILoginHandler> PILoginHandler;


/*************************************************************************************************************************
 Class interface for PersistencyHandler 
**************************************************************************************************************************/

class IPersistencyHandler : public virtual IBase {
public:
	/**
	* IPersistencyHandler::HasPersistentParameter - Retrieves if a persistent parameter has been stored.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter exists.
	*/
	virtual bool HasPersistentParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::GetPersistentParameterDetails - Retrieves details of a persistent parameter. Fails if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @param[out] sName - Returns name of the parameter
	* @param[out] eDataType - Returns data type of the parameter
	*/
	virtual void GetPersistentParameterDetails(const std::string & sUUID, std::string & sName, LibMCData::eParameterDataType & eDataType) = 0;

	/**
	* IPersistencyHandler::DeletePersistentParameter - Removes a persistent parameter from database. Does nothing if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter existed.
	*/
	virtual bool DeletePersistentParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::StorePersistentParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] eDataType - Data type of the parameter. If parameter exists, MUST be the same as the stored parameter data type.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void StorePersistentParameter(const std::string & sUUID, const std::string & sName, const LibMCData::eParameterDataType eDataType, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IPersistencyHandler::StorePersistentStringParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void StorePersistentStringParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IPersistencyHandler::StorePersistentUUIDParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void StorePersistentUUIDParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IPersistencyHandler::StorePersistentDoubleParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] dValue - Value of the parameter.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void StorePersistentDoubleParameter(const std::string & sUUID, const std::string & sName, const LibMCData_double dValue, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IPersistencyHandler::StorePersistentIntegerParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] nValue - Value of the parameter.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void StorePersistentIntegerParameter(const std::string & sUUID, const std::string & sName, const LibMCData_int64 nValue, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IPersistencyHandler::StorePersistentBoolParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] bValue - Value of the parameter.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	virtual void StorePersistentBoolParameter(const std::string & sUUID, const std::string & sName, const bool bValue, const LibMCData_uint64 nAbsoluteTimeStamp) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentStringParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual std::string RetrievePersistentStringParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentUUIDParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual std::string RetrievePersistentUUIDParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentDoubleParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual LibMCData_double RetrievePersistentDoubleParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentIntegerParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual LibMCData_int64 RetrievePersistentIntegerParameter(const std::string & sUUID) = 0;

	/**
	* IPersistencyHandler::RetrievePersistentBoolParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	virtual bool RetrievePersistentBoolParameter(const std::string & sUUID) = 0;

};

typedef IBaseSharedPtr<IPersistencyHandler> PIPersistencyHandler;


/*************************************************************************************************************************
 Class interface for InstallationInformation 
**************************************************************************************************************************/

class IInstallationInformation : public virtual IBase {
public:
	/**
	* IInstallationInformation::GetInstallationUUID - Returns the installation UUID.
	* @return Installation UUID. Public value to document which installation was used for something.
	*/
	virtual std::string GetInstallationUUID() = 0;

	/**
	* IInstallationInformation::GetInstallationSecret - Returns the installation Secret.
	* @return Secret SHA256 key for seeding external-facing pseudo-randomness. MUST NOT be given outside of the application.
	*/
	virtual std::string GetInstallationSecret() = 0;

	/**
	* IInstallationInformation::GetBaseTempDirectory - Returns a custom base temp directory. An empty string defaults to the system temp directory.
	* @return Temp directory path.
	*/
	virtual std::string GetBaseTempDirectory() = 0;

};

typedef IBaseSharedPtr<IInstallationInformation> PIInstallationInformation;


/*************************************************************************************************************************
 Class interface for DataModel 
**************************************************************************************************************************/

class IDataModel : public virtual IBase {
public:
	/**
	* IDataModel::InitialiseDatabase - initializes the database connection.
	* @param[in] sDataDirectory - Directory that stores the data.
	* @param[in] eDataBaseType - Type of database.
	* @param[in] sConnectionString - Connection string.
	*/
	virtual void InitialiseDatabase(const std::string & sDataDirectory, const LibMCData::eDataBaseType eDataBaseType, const std::string & sConnectionString) = 0;

	/**
	* IDataModel::GetDataModelVersion - returns the linear data model version.
	* @return Data model version.
	*/
	virtual LibMCData_uint32 GetDataModelVersion() = 0;

	/**
	* IDataModel::GetInstallationInformation - DEPRECIATED. Only used for backwards compatibility. NEVER USE because of thread safety issues.. Use GetInstallationInformationObject instead.
	* @param[out] sDEPRECIATEDInstallationUUID - DEPRECIATED Installation UUID. Public value to document which installation was used for something.
	* @param[out] sDEPRECIATEDInstallationSecret - DEPRECIATED Secret SHA256 key for seeding external-facing pseudo-randomness. MUST NOT be given outside of the application.
	*/
	virtual void GetInstallationInformation(std::string & sDEPRECIATEDInstallationUUID, std::string & sDEPRECIATEDInstallationSecret) = 0;

	/**
	* IDataModel::GetInstallationInformationObject - returns unique identifiers for the current installation. MUST be used instead of depreciated functionality.
	* @return Installation information instance.
	*/
	virtual IInstallationInformation * GetInstallationInformationObject() = 0;

	/**
	* IDataModel::CreateStorage - creates a storage access class.
	* @return Storage class instance.
	*/
	virtual IStorage * CreateStorage() = 0;

	/**
	* IDataModel::CreateBuildJobHandler - creates a build job access class.
	* @return BuildJobHandler class instance.
	*/
	virtual IBuildJobHandler * CreateBuildJobHandler() = 0;

	/**
	* IDataModel::CreateNewLogSession - creates a global log session access class.
	* @return LogSession class instance.
	*/
	virtual ILogSession * CreateNewLogSession() = 0;

	/**
	* IDataModel::CreateJournalSession - creates a global journal session access class.
	* @return JournalSession class instance.
	*/
	virtual IJournalSession * CreateJournalSession() = 0;

	/**
	* IDataModel::CreateAlertSession - creates a global alert session access class.
	* @return AlertSession class instance.
	*/
	virtual IAlertSession * CreateAlertSession() = 0;

	/**
	* IDataModel::CreateLoginHandler - creates a login handler instance.
	* @return LoginHandler instance.
	*/
	virtual ILoginHandler * CreateLoginHandler() = 0;

	/**
	* IDataModel::CreatePersistencyHandler - creates a persistency handler instance.
	* @return PersistencyHandler instance.
	*/
	virtual IPersistencyHandler * CreatePersistencyHandler() = 0;

	/**
	* IDataModel::SetBaseTempDirectory - Sets a custom base temp directory. An empty string defaults to the system temp directory.
	* @param[in] sTempDirectory - Temp directory path to use. SHOULD be an absolute path, if not empty. Directory MUST exist, if not empty.
	*/
	virtual void SetBaseTempDirectory(const std::string & sTempDirectory) = 0;

	/**
	* IDataModel::GetBaseTempDirectory - DEPRECIATED. Only used for backwards compatibility. NEVER USE because of thread safety issues.. USE GetInstallationInformationObject instead.
	* @return Temp directory path.
	*/
	virtual std::string GetBaseTempDirectory() = 0;

	/**
	* IDataModel::SetLogCallback - Sets a log callback to be used for the execution.
	* @param[in] pLogCallback - callback function
	* @param[in] nUserData - Userdata that is passed to the callback function
	*/
	virtual void SetLogCallback(const LibMCData::LogCallback pLogCallback, const LibMCData_pvoid pUserData) = 0;

	/**
	* IDataModel::ClearLogCallback - Resets the log callback to be used for the execution.
	*/
	virtual void ClearLogCallback() = 0;

	/**
	* IDataModel::HasLogCallback - Returns if a log callback has been set.
	* @return Flag if log callback has been set.
	*/
	virtual bool HasLogCallback() = 0;

	/**
	* IDataModel::TriggerLogCallback - Triggers the log callback. Fails if no log callback has been set.
	* @param[in] sLogMessage - Log message to be logged.
	* @param[in] sSubSystem - SubSystem of Log Message.
	* @param[in] eLogLevel - Log Level to be used.
	* @param[in] sTimestamp - Timestamp of the log message.
	*/
	virtual void TriggerLogCallback(const std::string & sLogMessage, const std::string & sSubSystem, const LibMCData::eLogLevel eLogLevel, const std::string & sTimestamp) = 0;

};

typedef IBaseSharedPtr<IDataModel> PIDataModel;


/*************************************************************************************************************************
 Global functions declarations
**************************************************************************************************************************/
class CWrapper {
public:
	/**
	* Ilibmcdata::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	static void GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro);

	/**
	* Ilibmcdata::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	static bool GetLastError(IBase* pInstance, std::string & sErrorMessage);

	/**
	* Ilibmcdata::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void ReleaseInstance(IBase* pInstance);

	/**
	* Ilibmcdata::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void AcquireInstance(IBase* pInstance);

	/**
	* Ilibmcdata::CreateDataModelInstance - Creates and initializes new MC DataModel Instance.
	* @return New DataModel instance
	*/
	static IDataModel * CreateDataModelInstance();

};

LibMCDataResult LibMCData_GetProcAddress (const char * pProcName, void ** ppProcAddress);

} // namespace Impl
} // namespace LibMCData

#endif // __LIBMCDATA_CPPINTERFACES
