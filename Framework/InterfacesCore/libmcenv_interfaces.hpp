/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ header file in order to allow easy
development of MC Environment Interface. The implementer of MC Environment Interface needs to
derive concrete classes from the abstract classes in this header.

Interface version: 1.0.0

*/


#ifndef __LIBMCENV_CPPINTERFACES
#define __LIBMCENV_CPPINTERFACES

#include <string>
#include <memory>

#include "libmcenv_types.hpp"



namespace LibMCEnv {
namespace Impl {

/**
 Forward declarations of class interfaces
*/
class IBase;
class IIterator;
class ITestEnvironment;
class ICryptoContext;
class IPNGImageStoreOptions;
class IPNGImageData;
class IImageData;
class IDiscreteFieldData2DStoreOptions;
class IDiscreteFieldData2D;
class IDataTableWriteOptions;
class IDataTable;
class IDataSeries;
class IDateTimeDifference;
class IDateTime;
class IMeshObject;
class IToolpathPart;
class IToolpathLayer;
class IToolpathAccessor;
class IBuildExecution;
class IBuildExecutionIterator;
class IBuild;
class IWorkingFileExecution;
class IWorkingFile;
class IWorkingFileIterator;
class IWorkingDirectory;
class IXMLDocumentAttribute;
class IXMLDocumentNode;
class IXMLDocumentNodes;
class IXMLDocument;
class ITCPIPPacket;
class ITCPIPConnection;
class IModbusTCPDigitalIOStatus;
class IModbusTCPRegisterStatus;
class IModbusTCPConnection;
class IDriverStatusUpdateSession;
class IDriverEnvironment;
class ISignalTrigger;
class ISignalHandler;
class ITempStreamWriter;
class IStreamReader;
class IUniformJournalSampling;
class IJournalVariable;
class IAlert;
class IAlertIterator;
class IJournalHandler;
class IUserDetailList;
class IUserManagementHandler;
class IStateEnvironment;
class IUIItem;
class IUIEnvironment;



/*************************************************************************************************************************
 Parameter Cache definitions
**************************************************************************************************************************/

class ParameterCache {
	public:
		virtual ~ParameterCache() {}
};

template <class T1> class ParameterCache_1 : public ParameterCache {
	private:
		T1 m_param1;
	public:
		ParameterCache_1 (const T1 & param1)
			: m_param1 (param1)
		{
		}

		void retrieveData (T1 & param1)
		{
			param1 = m_param1;
		}
};

template <class T1, class T2> class ParameterCache_2 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
	public:
		ParameterCache_2 (const T1 & param1, const T2 & param2)
			: m_param1 (param1), m_param2 (param2)
		{
		}

		void retrieveData (T1 & param1, T2 & param2)
		{
			param1 = m_param1;
			param2 = m_param2;
		}
};

template <class T1, class T2, class T3> class ParameterCache_3 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
	public:
		ParameterCache_3 (const T1 & param1, const T2 & param2, const T3 & param3)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
		}
};

template <class T1, class T2, class T3, class T4> class ParameterCache_4 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
		T4 m_param4;
	public:
		ParameterCache_4 (const T1 & param1, const T2 & param2, const T3 & param3, const T4 & param4)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3), m_param4 (param4)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3, T4 & param4)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
			param4 = m_param4;
		}
};

template <class T1, class T2, class T3, class T4, class T5> class ParameterCache_5 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
		T4 m_param4;
		T5 m_param5;
	public:
		ParameterCache_5 (const T1 & param1, const T2 & param2, const T3 & param3, const T4 & param4, const T5 & param5)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3), m_param4 (param4), m_param5 (param5)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3, T4 & param4, T5 & param5)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
			param4 = m_param4;
			param5 = m_param5;
		}
};


/*************************************************************************************************************************
 Class interface for Base 
**************************************************************************************************************************/

class IBase {
private:
	std::unique_ptr<ParameterCache> m_ParameterCache;
public:
	/**
	* IBase::~IBase - virtual destructor of IBase
	*/
	virtual ~IBase() {};

	/**
	* IBase::ReleaseBaseClassInterface - Releases ownership of a base class interface. Deletes the reference, if necessary.
	* @param[in] pIBase - The base class instance to release
	*/
	static void ReleaseBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->DecRefCount();
		}
	};

	/**
	* IBase::AcquireBaseClassInterface - Acquires shared ownership of a base class interface.
	* @param[in] pIBase - The base class instance to acquire
	*/
	static void AcquireBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->IncRefCount();
		}
	};


	/**
	* IBase::GetLastErrorMessage - Returns the last error registered of this class instance
	* @param[out] sErrorMessage - Message of the last error registered
	* @return Has an error been registered already
	*/
	virtual bool GetLastErrorMessage(std::string & sErrorMessage) = 0;

	/**
	* IBase::ClearErrorMessages - Clears all registered messages of this class instance
	*/
	virtual void ClearErrorMessages() = 0;

	/**
	* IBase::RegisterErrorMessage - Registers an error message with this class instance
	* @param[in] sErrorMessage - Error message to register
	*/
	virtual void RegisterErrorMessage(const std::string & sErrorMessage) = 0;

	/**
	* IBase::IncRefCount - Increases the reference count of a class instance
	*/
	virtual void IncRefCount() = 0;

	/**
	* IBase::DecRefCount - Decreases the reference count of a class instance and free releases it, if the last reference has been removed
	* @return Has the object been released
	*/
	virtual bool DecRefCount() = 0;

	/**
	* IBase::_setCache - set parameter cache of object
	*/
	void _setCache(ParameterCache * pCache)
	{
		m_ParameterCache.reset(pCache);
	}

	/**
	* IBase::_getCache - returns parameter cache of object
	*/
	ParameterCache* _getCache()
	{
		return m_ParameterCache.get();
	}

};


/**
 Definition of a shared pointer class for IBase
*/
template<class T>
class IBaseSharedPtr : public std::shared_ptr<T>
{
public:
	explicit IBaseSharedPtr(T* t = nullptr)
		: std::shared_ptr<T>(t, IBase::ReleaseBaseClassInterface)
	{
		t->IncRefCount();
	}

	// Reset function, as it also needs to properly set the deleter.
	void reset(T* t = nullptr)
	{
		std::shared_ptr<T>::reset(t, IBase::ReleaseBaseClassInterface);
	}

	// Get-function that increases the Base class's reference count
	T* getCoOwningPtr()
	{
		T* t = this->get();
		t->IncRefCount();
		return t;
	}
};


typedef IBaseSharedPtr<IBase> PIBase;


/*************************************************************************************************************************
 Class interface for Iterator 
**************************************************************************************************************************/

class IIterator : public virtual IBase {
public:
	/**
	* IIterator::MoveNext - Iterates to the next object in the list.
	* @return Iterates to the next object in the list.
	*/
	virtual bool MoveNext() = 0;

	/**
	* IIterator::MovePrevious - Iterates to the previous object in the list.
	* @return Iterates to the previous object in the list.
	*/
	virtual bool MovePrevious() = 0;

	/**
	* IIterator::GetCurrent - Returns the object the iterator points at.
	* @return returns the object instance.
	*/
	virtual IBase * GetCurrent() = 0;

	/**
	* IIterator::Clone - Creates a new object iterator with the same object list.
	* @return returns the cloned Iterator instance
	*/
	virtual IIterator * Clone() = 0;

	/**
	* IIterator::Count - Returns the number of resoucres the iterator captures.
	* @return returns the number of objects the iterator captures.
	*/
	virtual LibMCEnv_uint64 Count() = 0;

};

typedef IBaseSharedPtr<IIterator> PIIterator;


/*************************************************************************************************************************
 Class interface for TestEnvironment 
**************************************************************************************************************************/

class ITestEnvironment : public virtual IBase {
public:
	/**
	* ITestEnvironment::WriteTestOutput - Write output file to test directory.
	* @param[in] sOutputName - Output file name. Only alphanumeric characters, point, underscore and hypen are allowed.
	* @param[in] nDataBufferSize - Number of elements in buffer
	* @param[in] pDataBuffer - Test data to write into output directory.
	*/
	virtual void WriteTestOutput(const std::string & sOutputName, const LibMCEnv_uint64 nDataBufferSize, const LibMCEnv_uint8 * pDataBuffer) = 0;

};

typedef IBaseSharedPtr<ITestEnvironment> PITestEnvironment;


/*************************************************************************************************************************
 Class interface for CryptoContext 
**************************************************************************************************************************/

class ICryptoContext : public virtual IBase {
public:
	/**
	* ICryptoContext::CalculateSHA256FromString - Calculates SHA256 from a string. Fails if string is empty.
	* @param[in] sValue - Input value.
	* @return SHA256 Return value.
	*/
	virtual std::string CalculateSHA256FromString(const std::string & sValue) = 0;

	/**
	* ICryptoContext::CalculateSHA256FromBytes - Calculates SHA256 from a byte array. Fails if array is empty.
	* @param[in] nValueBufferSize - Number of elements in buffer
	* @param[in] pValueBuffer - Input value.
	* @return SHA256 Return value.
	*/
	virtual std::string CalculateSHA256FromBytes(const LibMCEnv_uint64 nValueBufferSize, const LibMCEnv_uint8 * pValueBuffer) = 0;

	/**
	* ICryptoContext::NormalizeSHA256String - Normalizes a standard string into UUID format. Fails if string does not have a proper UUID format.
	* @param[in] sValue - Input value.
	* @return SHA256 Return value.
	*/
	virtual std::string NormalizeSHA256String(const std::string & sValue) = 0;

	/**
	* ICryptoContext::CreateRandomSHA256Hash - Generates a random SHA256 hash value with operating system APIs.
	* @return SHA256 Return value.
	*/
	virtual std::string CreateRandomSHA256Hash() = 0;

	/**
	* ICryptoContext::CreateUUID - Generates a random UUID with operating system APIs.
	* @return UUID Return value.
	*/
	virtual std::string CreateUUID() = 0;

	/**
	* ICryptoContext::NormalizeUUIDString - Normalizes a standard string into UUID format. Fails if string does not have a proper UUID format.
	* @param[in] sValue - Input value.
	* @return UUID Return value.
	*/
	virtual std::string NormalizeUUIDString(const std::string & sValue) = 0;

};

typedef IBaseSharedPtr<ICryptoContext> PICryptoContext;


/*************************************************************************************************************************
 Class interface for PNGImageStoreOptions 
**************************************************************************************************************************/

class IPNGImageStoreOptions : public virtual IBase {
public:
	/**
	* IPNGImageStoreOptions::ResetToDefaults - Resets Options to default.
	*/
	virtual void ResetToDefaults() = 0;

};

typedef IBaseSharedPtr<IPNGImageStoreOptions> PIPNGImageStoreOptions;


/*************************************************************************************************************************
 Class interface for PNGImageData 
**************************************************************************************************************************/

class IPNGImageData : public virtual IBase {
public:
	/**
	* IPNGImageData::GetSizeInPixels - Returns image pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	virtual void GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY) = 0;

	/**
	* IPNGImageData::GetPNGDataStream - Retrieves encoded data stream of image object.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[out] pPNGDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pPNGDataBuffer - uint8 buffer of PNG Data stream.
	*/
	virtual void GetPNGDataStream(LibMCEnv_uint64 nPNGDataBufferSize, LibMCEnv_uint64* pPNGDataNeededCount, LibMCEnv_uint8 * pPNGDataBuffer) = 0;

};

typedef IBaseSharedPtr<IPNGImageData> PIPNGImageData;


/*************************************************************************************************************************
 Class interface for ImageData 
**************************************************************************************************************************/

class IImageData : public virtual IBase {
public:
	/**
	* IImageData::GetPixelFormat - Returns Pixel format of the image.
	* @return Pixel Format of image
	*/
	virtual LibMCEnv::eImagePixelFormat GetPixelFormat() = 0;

	/**
	* IImageData::ChangePixelFormat - Changes Pixel format of the image. Might lose alpha or color information during the process.
	* @param[in] ePixelFormat - new Pixel Format of image
	*/
	virtual void ChangePixelFormat(const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IImageData::GetDPI - Returns DPI values in X and Y.
	* @param[out] dDPIValueX - DPI value in X
	* @param[out] dDPIValueY - DPI value in Y
	*/
	virtual void GetDPI(LibMCEnv_double & dDPIValueX, LibMCEnv_double & dDPIValueY) = 0;

	/**
	* IImageData::SetDPI - Sets DPI values in X and Y.
	* @param[in] dDPIValueX - new DPI value in X
	* @param[in] dDPIValueY - new DPI value in Y
	*/
	virtual void SetDPI(const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY) = 0;

	/**
	* IImageData::GetSizeInMM - Returns image sizes inmm.
	* @param[out] dSizeX - Size in X in mm
	* @param[out] dSizeY - Size in Y in mm
	*/
	virtual void GetSizeInMM(LibMCEnv_double & dSizeX, LibMCEnv_double & dSizeY) = 0;

	/**
	* IImageData::GetSizeInPixels - Returns image pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	virtual void GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY) = 0;

	/**
	* IImageData::ResizeImage - Resizes Image pixel data.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	virtual void ResizeImage(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY) = 0;

	/**
	* IImageData::LoadPNG - Loads a PNG from a binary array. Supports RGB, RGBA and Greyscale images.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[in] pPNGDataBuffer - PNG Data stream.
	*/
	virtual void LoadPNG(const LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer) = 0;

	/**
	* IImageData::CreatePNGImage - Creates PNG Image out of the pixel data.
	* @param[in] pPNGStorageOptions - Optional encoding options for the image.
	* @return Image data.
	*/
	virtual IPNGImageData * CreatePNGImage(IPNGImageStoreOptions* pPNGStorageOptions) = 0;

	/**
	* IImageData::EncodePNG - Depreciated. DO NOT USE. Encodes PNG and stores data stream in image object.
	*/
	virtual void EncodePNG() = 0;

	/**
	* IImageData::GetEncodedPNGData - Depreciated. DO NOT USE. Retrieves encoded data stream of image object. MUST have been encoded with EncodePNG before.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[out] pPNGDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pPNGDataBuffer - uint8 buffer of PNG Data stream.
	*/
	virtual void GetEncodedPNGData(LibMCEnv_uint64 nPNGDataBufferSize, LibMCEnv_uint64* pPNGDataNeededCount, LibMCEnv_uint8 * pPNGDataBuffer) = 0;

	/**
	* IImageData::ClearEncodedPNGData - Depreciated. DO NOT USE. Releases encoded data stream of image object. Depreciated.
	*/
	virtual void ClearEncodedPNGData() = 0;

	/**
	* IImageData::Clear - Sets all pixels to a single value.
	* @param[in] nValue - Pixel value.
	*/
	virtual void Clear(const LibMCEnv_uint32 nValue) = 0;

	/**
	* IImageData::GetPixel - Returns one pixel of an image.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @return Pixel value at this position
	*/
	virtual LibMCEnv_uint32 GetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY) = 0;

	/**
	* IImageData::SetPixel - Sets one pixel of an image.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @param[in] nValue - New Pixel value at this position
	*/
	virtual void SetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY, const LibMCEnv_uint32 nValue) = 0;

	/**
	* IImageData::GetPixelRange - Returns a subset of an image or the whole image data. DEPRECIATED.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within image bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within image bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within image bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within image bounds. MUST be larger or equal than MinY
	* @param[in] nValueBufferSize - Number of elements in buffer
	* @param[out] pValueNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pValueBuffer - uint8 buffer of Pixel values of the rectangle, rowwise array. Will return the exact number of pixels in size and 1, 3 or 4 bytes per pixel, depending on pixel format.
	*/
	virtual void GetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, LibMCEnv_uint64 nValueBufferSize, LibMCEnv_uint64* pValueNeededCount, LibMCEnv_uint8 * pValueBuffer) = 0;

	/**
	* IImageData::SetPixelRange - Exchanges a subset of an image or the whole image data. DEPRECIATED.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within image bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within image bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within image bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within image bounds. MUST be larger or equal than MinY
	* @param[in] nValueBufferSize - Number of elements in buffer
	* @param[in] pValueBuffer - New pixel values of the rectangle, rowwise array. MUST have the exact number of pixels in size and 1, 3 or 4 bytes per pixel, depending on pixel format.
	*/
	virtual void SetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, const LibMCEnv_uint64 nValueBufferSize, const LibMCEnv_uint8 * pValueBuffer) = 0;

};

typedef IBaseSharedPtr<IImageData> PIImageData;


/*************************************************************************************************************************
 Class interface for DiscreteFieldData2DStoreOptions 
**************************************************************************************************************************/

class IDiscreteFieldData2DStoreOptions : public virtual IBase {
public:
	/**
	* IDiscreteFieldData2DStoreOptions::ResetToDefaults - Resets Options to default.
	*/
	virtual void ResetToDefaults() = 0;

};

typedef IBaseSharedPtr<IDiscreteFieldData2DStoreOptions> PIDiscreteFieldData2DStoreOptions;


/*************************************************************************************************************************
 Class interface for DiscreteFieldData2D 
**************************************************************************************************************************/

class IDiscreteFieldData2D : public virtual IBase {
public:
	/**
	* IDiscreteFieldData2D::GetDPI - Returns DPI values in X and Y.
	* @param[out] dDPIValueX - DPI value in X
	* @param[out] dDPIValueY - DPI value in Y
	*/
	virtual void GetDPI(LibMCEnv_double & dDPIValueX, LibMCEnv_double & dDPIValueY) = 0;

	/**
	* IDiscreteFieldData2D::SetDPI - Sets DPI values in X and Y.
	* @param[in] dDPIValueX - new DPI value in X. MUST be positive.
	* @param[in] dDPIValueY - new DPI value in Y. MUST be positive.
	*/
	virtual void SetDPI(const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY) = 0;

	/**
	* IDiscreteFieldData2D::GetOriginInMM - Returns field origin in mm.
	* @param[out] dOriginX - Origin in X in mm
	* @param[out] dOriginY - Origin in Y in mm
	*/
	virtual void GetOriginInMM(LibMCEnv_double & dOriginX, LibMCEnv_double & dOriginY) = 0;

	/**
	* IDiscreteFieldData2D::SetOriginInMM - Set field origin in mm.
	* @param[in] dOriginX - Origin in X in mm
	* @param[in] dOriginY - Origin in Y in mm
	*/
	virtual void SetOriginInMM(const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY) = 0;

	/**
	* IDiscreteFieldData2D::GetSizeInMM - Returns field sizes in mm.
	* @param[out] dSizeX - Size in X in mm
	* @param[out] dSizeY - Size in Y in mm
	*/
	virtual void GetSizeInMM(LibMCEnv_double & dSizeX, LibMCEnv_double & dSizeY) = 0;

	/**
	* IDiscreteFieldData2D::GetSizeInPixels - Returns field pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	virtual void GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY) = 0;

	/**
	* IDiscreteFieldData2D::ResizeField - Resizes field pixel data.
	* @param[in] nPixelSizeX - Number of pixels in X
	* @param[in] nPixelSizeY - Number of pixels in Y
	* @param[in] dDefaultValue - Default Pixel value.
	*/
	virtual void ResizeField(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IDiscreteFieldData2D::Clear - Sets all pixels to a single value.
	* @param[in] dValue - Pixel value.
	*/
	virtual void Clear(const LibMCEnv_double dValue) = 0;

	/**
	* IDiscreteFieldData2D::Clamp - Clamps all pixels to a certain interval.
	* @param[in] dMinValue - Minimum value. MUST be smaller or equal than MaxValue.
	* @param[in] dMaxValue - Maximum value. MUST be larger or equal than MinValue.
	*/
	virtual void Clamp(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue) = 0;

	/**
	* IDiscreteFieldData2D::GetPixel - Returns one pixel of an field. Fails if outside of field size.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @return Pixel value at this position
	*/
	virtual LibMCEnv_double GetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY) = 0;

	/**
	* IDiscreteFieldData2D::SetPixel - Sets one pixel of an field. Fails if outside of field size.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @param[in] dValue - New Pixel value at this position
	*/
	virtual void SetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY, const LibMCEnv_double dValue) = 0;

	/**
	* IDiscreteFieldData2D::GetPixelRange - Returns a subset of an field or the whole field data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within field bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within field bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within field bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within field bounds. MUST be larger or equal than MinY
	* @param[in] nValueBufferSize - Number of elements in buffer
	* @param[out] pValueNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pValueBuffer - double buffer of Pixel values of the rectangle, rowwise array. Will return the exact number of pixels in size.
	*/
	virtual void GetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, LibMCEnv_uint64 nValueBufferSize, LibMCEnv_uint64* pValueNeededCount, LibMCEnv_double * pValueBuffer) = 0;

	/**
	* IDiscreteFieldData2D::SetPixelRange - Exchanges a subset of an field or the whole field data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within field bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within field bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within field bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within field bounds. MUST be larger or equal than MinY
	* @param[in] nValueBufferSize - Number of elements in buffer
	* @param[in] pValueBuffer - New pixel values of the rectangle, rowwise array. MUST have the exact number of pixels in size.
	*/
	virtual void SetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, const LibMCEnv_uint64 nValueBufferSize, const LibMCEnv_double * pValueBuffer) = 0;

	/**
	* IDiscreteFieldData2D::RenderAveragePointValues - Renders and array of average point values into the field. 
	* @param[in] dDefaultValue - If a pixel does not contain any value, fall back to this given value.
	* @param[in] eSamplingMode - Sampling mode of point values.
	* @param[in] dSampleSizeX - How large a sample point should be drawn in Pixel widths. This determines the weighting when a point value overlaps multiple pixels. Ignored if SamplingMode is equal FloorCoordinate or CeilCoordinate. MUST be positive otherwise.
	* @param[in] dSampleSizeY - How large a sample point should be drawn in Pixel heights. This determines the weighting when a point value overlaps multiple pixels. Ignored if SamplingMode is equal FloorCoordinate or CeilCoordinate. MUST be positive otherwise.
	* @param[in] nPointValuesBufferSize - Number of elements in buffer
	* @param[in] pPointValuesBuffer - Array of Field Data Points that are sorted into the grid. If a point lies on a grid border, it will be counted to all adjacent pixels.
	*/
	virtual void RenderAveragePointValues(const LibMCEnv_double dDefaultValue, const LibMCEnv::eFieldSamplingMode eSamplingMode, const LibMCEnv_double dSampleSizeX, const LibMCEnv_double dSampleSizeY, const LibMCEnv_uint64 nPointValuesBufferSize, const LibMCEnv::sFieldData2DPoint * pPointValuesBuffer) = 0;

	/**
	* IDiscreteFieldData2D::ScaleFieldDown - Scales the field to a smaller size.
	* @param[in] nFactorX - The new field will be this factor smaller in X. MUST be positive and smaller than PixelSizeX
	* @param[in] nFactorY - The new field will be this factor smaller in Y. MUST be positive and smaller than PixelSizeY
	* @return Scaled Field Instance
	*/
	virtual IDiscreteFieldData2D * ScaleFieldDown(const LibMCEnv_uint32 nFactorX, const LibMCEnv_uint32 nFactorY) = 0;

	/**
	* IDiscreteFieldData2D::ScaleFieldUp - Scales the field to a larger size.
	* @param[in] nFactorX - The new field will be this factor larger in X. MUST be positive.
	* @param[in] nFactorY - The new field will be this factor larger in Y. MUST be positive.
	* @return Scaled Field Instance
	*/
	virtual IDiscreteFieldData2D * ScaleFieldUp(const LibMCEnv_uint32 nFactorX, const LibMCEnv_uint32 nFactorY) = 0;

	/**
	* IDiscreteFieldData2D::Discretize - Discretizes the field into a finite set of values. All field values will be set to the nearest value in the given array. Equivalent to DiscretizeWithMapping with two identical parameters.
	* @param[in] nDiscreteValuesBufferSize - Number of elements in buffer
	* @param[in] pDiscreteValuesBuffer - An array of values. MUST NOT be empty.
	*/
	virtual void Discretize(const LibMCEnv_uint64 nDiscreteValuesBufferSize, const LibMCEnv_double * pDiscreteValuesBuffer) = 0;

	/**
	* IDiscreteFieldData2D::DiscretizeWithMapping - Discretizes the field into a finite set of DiscreteValues. For each field value the nearest DiscreteValue is determined, and the field is set to the element of NewValues with the same index.
	* @param[in] nDiscreteValuesBufferSize - Number of elements in buffer
	* @param[in] pDiscreteValuesBuffer - An array of values. MUST NOT be empty.  
	* @param[in] nNewValuesBufferSize - Number of elements in buffer
	* @param[in] pNewValuesBuffer - An array of values. MUST have the same cardinality as DiscreteValues.
	*/
	virtual void DiscretizeWithMapping(const LibMCEnv_uint64 nDiscreteValuesBufferSize, const LibMCEnv_double * pDiscreteValuesBuffer, const LibMCEnv_uint64 nNewValuesBufferSize, const LibMCEnv_double * pNewValuesBuffer) = 0;

	/**
	* IDiscreteFieldData2D::RenderToImageRaw - Renders the field into a PNG image. The colors will be linearly interpolated into a given color scheme.
	* @param[in] dMinValue - Min point value. Values smaller than MinValue will be clamped to MinValue.
	* @param[in] MinColor - The color assigned to MinValue.
	* @param[in] dMidValue - Mid point value. MUST be at least 1E-6 larger than MinValue.
	* @param[in] MidColor - The color assigned to MidValue
	* @param[in] dMaxValue - Max point value. MUST be at least 1E-6 larger than MidValue. Values larger than MaxValue will be clamped to MaxValue.
	* @param[in] MaxColor - The color assigned to MaxValue
	* @return New Image with the according data. Pixel size and DPI will be equal to the field. Pixel format will be RGB24bit.
	*/
	virtual IImageData * RenderToImageRaw(const LibMCEnv_double dMinValue, const LibMCEnv::sColorRGB MinColor, const LibMCEnv_double dMidValue, const LibMCEnv::sColorRGB MidColor, const LibMCEnv_double dMaxValue, const LibMCEnv::sColorRGB MaxColor) = 0;

	/**
	* IDiscreteFieldData2D::TransformField - Scales the field values with a factor and a translation.
	* @param[in] dScale - A scaling factor will be applied to all values in the field.
	* @param[in] dOffset - The offset will be applied to all values in the field after scaling.
	*/
	virtual void TransformField(const LibMCEnv_double dScale, const LibMCEnv_double dOffset) = 0;

	/**
	* IDiscreteFieldData2D::AddField - Adds another field to the field. Both fields MUST have the same pixel extensions.
	* @param[in] pOtherField - Field Instance to add
	* @param[in] dScale - A scaling factor will be applied to all values in the other field before adding.
	* @param[in] dOffset - The offset will be applied to all values in the field after scaling.
	*/
	virtual void AddField(IDiscreteFieldData2D* pOtherField, const LibMCEnv_double dScale, const LibMCEnv_double dOffset) = 0;

	/**
	* IDiscreteFieldData2D::Duplicate - Creates a copy of the field.
	* @return Scaled Field Instance
	*/
	virtual IDiscreteFieldData2D * Duplicate() = 0;

};

typedef IBaseSharedPtr<IDiscreteFieldData2D> PIDiscreteFieldData2D;


/*************************************************************************************************************************
 Class interface for DataTableWriteOptions 
**************************************************************************************************************************/

class IDataTableWriteOptions : public virtual IBase {
public:
};

typedef IBaseSharedPtr<IDataTableWriteOptions> PIDataTableWriteOptions;


/*************************************************************************************************************************
 Class interface for DataTable 
**************************************************************************************************************************/

class IDataTable : public virtual IBase {
public:
	/**
	* IDataTable::AddColumn - Adds a column to the data field.
	* @param[in] sIdentifier - Identifier of the column. MUST be unique, alphanumeric and not empty.
	* @param[in] sDescription - Description of the column.
	* @param[in] eColumnType - Data type of the column.
	*/
	virtual void AddColumn(const std::string & sIdentifier, const std::string & sDescription, const LibMCEnv::eDataTableColumnType eColumnType) = 0;

	/**
	* IDataTable::RemoveColumn - Removes a column from the data field. Fails if Column does not exist.
	* @param[in] sIdentifier - Identifier of the column.
	*/
	virtual void RemoveColumn(const std::string & sIdentifier) = 0;

	/**
	* IDataTable::HasColumn - Returns if a column exists in the data field.
	* @param[in] sIdentifier - Identifier of the column.
	* @return Returns if the columns exist.
	*/
	virtual bool HasColumn(const std::string & sIdentifier) = 0;

	/**
	* IDataTable::GetRowCount - Returns the current row count.
	* @return Number of rows.
	*/
	virtual LibMCEnv_uint32 GetRowCount() = 0;

	/**
	* IDataTable::GetColumnCount - Returns the current column count.
	* @return Number of columns.
	*/
	virtual LibMCEnv_uint32 GetColumnCount() = 0;

	/**
	* IDataTable::GetColumnIdentifier - Returns the identifier of a column. Will fail if Index is out of bounds.
	* @param[in] nColumnIndex - Index of column. 0-based.
	* @return Identifier of the column.
	*/
	virtual std::string GetColumnIdentifier(const LibMCEnv_uint32 nColumnIndex) = 0;

	/**
	* IDataTable::GetColumnDescription - Returns the description of a column. Will fail if Index is out of bounds.
	* @param[in] nColumnIndex - Index of column. 0-based.
	* @return Description of the column.
	*/
	virtual std::string GetColumnDescription(const LibMCEnv_uint32 nColumnIndex) = 0;

	/**
	* IDataTable::GetColumnType - Returns the type of a column. Will fail if Index is out of bounds.
	* @param[in] nColumnIndex - Index of column. 0-based.
	* @return Data type of the column.
	*/
	virtual LibMCEnv::eDataTableColumnType GetColumnType(const LibMCEnv_uint32 nColumnIndex) = 0;

	/**
	* IDataTable::GetColumnInformation - Returns the values of a double column. Will fail if column does not exist or type is not double.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[out] sDescription - Description of the column.
	* @param[out] eColumnType - Data type of the column.
	*/
	virtual void GetColumnInformation(const std::string & sIdentifier, std::string & sDescription, LibMCEnv::eDataTableColumnType & eColumnType) = 0;

	/**
	* IDataTable::GetDoubleColumnValues - Returns the values of a double column. Will fail if column does not exist or type is not double.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[out] pValuesNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pValuesBuffer - double buffer of Value array of a column.
	*/
	virtual void GetDoubleColumnValues(const std::string & sIdentifier, LibMCEnv_uint64 nValuesBufferSize, LibMCEnv_uint64* pValuesNeededCount, LibMCEnv_double * pValuesBuffer) = 0;

	/**
	* IDataTable::GetInt32ColumnValues - Returns the double columns. Will fail if column does not exist or type is not int32.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[out] pValuesNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pValuesBuffer - int32 buffer of Value array of a column.
	*/
	virtual void GetInt32ColumnValues(const std::string & sIdentifier, LibMCEnv_uint64 nValuesBufferSize, LibMCEnv_uint64* pValuesNeededCount, LibMCEnv_int32 * pValuesBuffer) = 0;

	/**
	* IDataTable::GetInt64ColumnValues - Returns the double columns. Will fail if column does not exist or type is not int64.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[out] pValuesNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pValuesBuffer - int64 buffer of Value array of a column.
	*/
	virtual void GetInt64ColumnValues(const std::string & sIdentifier, LibMCEnv_uint64 nValuesBufferSize, LibMCEnv_uint64* pValuesNeededCount, LibMCEnv_int64 * pValuesBuffer) = 0;

	/**
	* IDataTable::GetUint32ColumnValues - Returns the double columns. Will fail if column does not exist or type is not uint32.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[out] pValuesNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pValuesBuffer - uint32 buffer of Value array of a column.
	*/
	virtual void GetUint32ColumnValues(const std::string & sIdentifier, LibMCEnv_uint64 nValuesBufferSize, LibMCEnv_uint64* pValuesNeededCount, LibMCEnv_uint32 * pValuesBuffer) = 0;

	/**
	* IDataTable::GetUint64ColumnValues - Returns the double columns. Will fail if column does not exist or type is not uint64.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[out] pValuesNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pValuesBuffer - uint64 buffer of Value array of a column.
	*/
	virtual void GetUint64ColumnValues(const std::string & sIdentifier, LibMCEnv_uint64 nValuesBufferSize, LibMCEnv_uint64* pValuesNeededCount, LibMCEnv_uint64 * pValuesBuffer) = 0;

	/**
	* IDataTable::SetDoubleColumnValues - Sets the values of a double column. Will fail if column does not exist or type is not double.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[in] pValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	virtual void SetDoubleColumnValues(const std::string & sIdentifier, const LibMCEnv_uint64 nValuesBufferSize, const LibMCEnv_double * pValuesBuffer) = 0;

	/**
	* IDataTable::SetInt32ColumnValues - Sets the double columns. Will fail if column does not exist or type is not int32.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[in] pValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	virtual void SetInt32ColumnValues(const std::string & sIdentifier, const LibMCEnv_uint64 nValuesBufferSize, const LibMCEnv_int32 * pValuesBuffer) = 0;

	/**
	* IDataTable::SetInt64ColumnValues - Sets the double columns. Will fail if column does not exist or type is not int64.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[in] pValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	virtual void SetInt64ColumnValues(const std::string & sIdentifier, const LibMCEnv_uint64 nValuesBufferSize, const LibMCEnv_int64 * pValuesBuffer) = 0;

	/**
	* IDataTable::SetUint32ColumnValues - Sets the double columns. Will fail if column does not exist or type is not uint32.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[in] pValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	virtual void SetUint32ColumnValues(const std::string & sIdentifier, const LibMCEnv_uint64 nValuesBufferSize, const LibMCEnv_uint32 * pValuesBuffer) = 0;

	/**
	* IDataTable::SetUint64ColumnValues - Sets the double columns. Will fail if column does not exist or type is not uint64.
	* @param[in] sIdentifier - Identifier of the column.
	* @param[in] nValuesBufferSize - Number of elements in buffer
	* @param[in] pValuesBuffer - New Value array of a column. Array length should match RowCount. Values will be filled up with 0, if length is less than RowCount. RowCount will be extended if length is larger than RowCount.
	*/
	virtual void SetUint64ColumnValues(const std::string & sIdentifier, const LibMCEnv_uint64 nValuesBufferSize, const LibMCEnv_uint64 * pValuesBuffer) = 0;

	/**
	* IDataTable::WriteCSVToStream - Writes the data as CSV to a temporary stream.
	* @param[in] pWriter - Stream writer to use.
	* @param[in] sSeparator - Seperator to use between the Cells. MUST be a single character string.
	*/
	virtual void WriteCSVToStream(ITempStreamWriter* pWriter, const std::string & sSeparator) = 0;

	/**
	* IDataTable::WriteDataToStream - Writes the data as binary to a temporary stream.
	* @param[in] pWriter - Stream writer instance to use.
	* @param[in] pOptions - Optional writer options to use.
	*/
	virtual void WriteDataToStream(ITempStreamWriter* pWriter, IDataTableWriteOptions* pOptions) = 0;

};

typedef IBaseSharedPtr<IDataTable> PIDataTable;


/*************************************************************************************************************************
 Class interface for DataSeries 
**************************************************************************************************************************/

class IDataSeries : public virtual IBase {
public:
	/**
	* IDataSeries::GetName - Returns the name of the data series.
	* @return Returns the name.
	*/
	virtual std::string GetName() = 0;

	/**
	* IDataSeries::GetUUID - Returns the UUID of the data series.
	* @return Returns uuid.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IDataSeries::Clear - Clears all entries of the data series.
	*/
	virtual void Clear() = 0;

	/**
	* IDataSeries::IsEmpty - Checks if data series is empty.
	* @return Returns true if data series has no entries.
	*/
	virtual bool IsEmpty() = 0;

	/**
	* IDataSeries::GetMinimum - Returns the minimum time stamp of the data series. Fails if data series is empty.
	* @return Minimum time stamp in microseconds.
	*/
	virtual LibMCEnv_uint64 GetMinimum() = 0;

	/**
	* IDataSeries::GetMaximum - Returns the maximum time stamp of the data series. Fails if data series is empty.
	* @return Maximum time stamp in microseconds.
	*/
	virtual LibMCEnv_uint64 GetMaximum() = 0;

	/**
	* IDataSeries::GetAllEntries - Returns all entries of the data series. Fails if data series is empty.
	* @param[in] nEntryArrayBufferSize - Number of elements in buffer
	* @param[out] pEntryArrayNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pEntryArrayBuffer - TimeStreamEntry buffer of Data series entries will be written in this array.
	*/
	virtual void GetAllEntries(LibMCEnv_uint64 nEntryArrayBufferSize, LibMCEnv_uint64* pEntryArrayNeededCount, LibMCEnv::sTimeStreamEntry * pEntryArrayBuffer) = 0;

	/**
	* IDataSeries::SetAllEntries - Sets all entries of the data series. The time stamp array MUST be sorted in incrementing order, with no two time stamps being equal.
	* @param[in] nEntryArrayBufferSize - Number of elements in buffer
	* @param[in] pEntryArrayBuffer - Data series entries to use.
	*/
	virtual void SetAllEntries(const LibMCEnv_uint64 nEntryArrayBufferSize, const LibMCEnv::sTimeStreamEntry * pEntryArrayBuffer) = 0;

	/**
	* IDataSeries::SampleJournalVariable - Samples a journal variable.
	* @param[in] pJournalVariable - Journal variable to sample.
	* @param[in] nNumberOfSamples - Number of samples to generate.
	* @param[in] dMovingAverageDelta - Each sample will be averaged from minus MovingAverageDelta to plus MovingAverageDelta.
	*/
	virtual void SampleJournalVariable(IJournalVariable* pJournalVariable, const LibMCEnv_uint32 nNumberOfSamples, const LibMCEnv_double dMovingAverageDelta) = 0;

	/**
	* IDataSeries::GetVersion - Returns the incrementing change version of the data series.
	* @return Version number. Increases with every change to the data.
	*/
	virtual LibMCEnv_uint32 GetVersion() = 0;

	/**
	* IDataSeries::IncreaseVersion - Increases the version number of the data series.
	*/
	virtual void IncreaseVersion() = 0;

};

typedef IBaseSharedPtr<IDataSeries> PIDataSeries;


/*************************************************************************************************************************
 Class interface for DateTimeDifference 
**************************************************************************************************************************/

class IDateTimeDifference : public virtual IBase {
public:
	/**
	* IDateTimeDifference::ToMicroseconds - Returns the duration in Microseconds.
	* @return The duration in Microseconds.
	*/
	virtual LibMCEnv_uint64 ToMicroseconds() = 0;

	/**
	* IDateTimeDifference::ToMilliseconds - Returns the duration in Milliseconds. Partial milliseconds are rounded down.
	* @return The duration in Milliseconds.
	*/
	virtual LibMCEnv_uint64 ToMilliseconds() = 0;

	/**
	* IDateTimeDifference::ToSeconds - Returns the duration in Seconds. Partial seconds are rounded down.
	* @return The duration in seconds.
	*/
	virtual LibMCEnv_uint64 ToSeconds() = 0;

	/**
	* IDateTimeDifference::ToMinutes - Returns the duration in Seconds. Partial minutes are rounded down.
	* @return The duration in seconds.
	*/
	virtual LibMCEnv_uint64 ToMinutes() = 0;

	/**
	* IDateTimeDifference::ToHours - Returns the duration in Hours. Partial hours are rounded down.
	* @return The duration in hours.
	*/
	virtual LibMCEnv_uint64 ToHours() = 0;

	/**
	* IDateTimeDifference::ToDays - Returns the duration in Days. Partial days are rounded down.
	* @return The duration in days.
	*/
	virtual LibMCEnv_uint64 ToDays() = 0;

	/**
	* IDateTimeDifference::RoundDownToDay - Rounds down the duration to the full day.
	*/
	virtual void RoundDownToDay() = 0;

	/**
	* IDateTimeDifference::RoundDownToHour - Rounds down the duration to the full hour.
	*/
	virtual void RoundDownToHour() = 0;

	/**
	* IDateTimeDifference::RoundDownToMinute - Rounds down the duration to the full minute.
	*/
	virtual void RoundDownToMinute() = 0;

	/**
	* IDateTimeDifference::RoundDownToSeconds - Rounds down the duration to the full second.
	*/
	virtual void RoundDownToSeconds() = 0;

	/**
	* IDateTimeDifference::RoundDownToMilliseconds - Rounds down the duration to the full millisecond.
	*/
	virtual void RoundDownToMilliseconds() = 0;

	/**
	* IDateTimeDifference::RoundUpToDay - Rounds up the duration to the full day.
	*/
	virtual void RoundUpToDay() = 0;

	/**
	* IDateTimeDifference::RoundUpToHour - Rounds up the duration to the full hour.
	*/
	virtual void RoundUpToHour() = 0;

	/**
	* IDateTimeDifference::RoundUpToMinute - Rounds up the duration to the full minute.
	*/
	virtual void RoundUpToMinute() = 0;

	/**
	* IDateTimeDifference::RoundUpToSeconds - Rounds up the duration to the full second.
	*/
	virtual void RoundUpToSeconds() = 0;

	/**
	* IDateTimeDifference::RoundupToMilliseconds - Rounds up the duration to the full millisecond.
	*/
	virtual void RoundupToMilliseconds() = 0;

};

typedef IBaseSharedPtr<IDateTimeDifference> PIDateTimeDifference;


/*************************************************************************************************************************
 Class interface for DateTime 
**************************************************************************************************************************/

class IDateTime : public virtual IBase {
public:
	/**
	* IDateTime::ToMicrosecondsSince1900 - Returns the maximum accuracy date time.
	* @return Returns the date in Microseconds since midnight first of January 1900.
	*/
	virtual LibMCEnv_uint64 ToMicrosecondsSince1900() = 0;

	/**
	* IDateTime::ToUnixTimestamp - Returns the unix time stamp of the date time
	* @return Returns the date in seconds since midnight the first of January 1970. Rounds down the value if microseconds are present.
	*/
	virtual LibMCEnv_uint64 ToUnixTimestamp() = 0;

	/**
	* IDateTime::ToUTCDateTime - Returns the Timestamp in ISO8601 UTC format. Rounded down to Second Accuracy.
	* @return The time stamp in ISO8601 format. Rounds down the value if microseconds are present. One example is 2024-03-27T15:21:46Z UTC
	*/
	virtual std::string ToUTCDateTime() = 0;

	/**
	* IDateTime::ToUTCDateTimeInMilliseconds - Returns the Timestamp in ISO8601 UTC format. Rounded down to Millisecond Accuracy.
	* @return The time stamp in ISO8601 format. Rounds down the value if microseconds are present. One example is 2024-03-27T15:21:46.123Z UTC
	*/
	virtual std::string ToUTCDateTimeInMilliseconds() = 0;

	/**
	* IDateTime::ToUTCDateTimeInMicroseconds - Returns the Timestamp in ISO8601 UTC format. Returns the string in full microsecond accuracy.
	* @return The time stamp in ISO8601 format. One example is 2024-03-27T15:21:46.123456Z UTC
	*/
	virtual std::string ToUTCDateTimeInMicroseconds() = 0;

	/**
	* IDateTime::GetDate - Returns the date information.
	* @param[out] nYear - Year of the date.
	* @param[out] nMonth - Month of the date.
	* @param[out] nDay - Day of the date.
	*/
	virtual void GetDate(LibMCEnv_uint32 & nYear, LibMCEnv_uint32 & nMonth, LibMCEnv_uint32 & nDay) = 0;

	/**
	* IDateTime::GetTime - Returns the time information.
	* @param[out] nHour - Hour of the time. Returns 0-23.
	* @param[out] nMinute - Minute of the time. Returns 0-59.
	* @param[out] nSecond - Seconds of the time. Returns 0-59.
	* @param[out] nMicrosecond - Partial microseconds of the time. Returns 0-999999.
	*/
	virtual void GetTime(LibMCEnv_uint32 & nHour, LibMCEnv_uint32 & nMinute, LibMCEnv_uint32 & nSecond, LibMCEnv_uint32 & nMicrosecond) = 0;

	/**
	* IDateTime::Duplicate - Duplicates the date time instance.
	* @return Returns a copied instance.
	*/
	virtual IDateTime * Duplicate() = 0;

	/**
	* IDateTime::IsLeapYear - Returns if the year is a leap year.
	* @return Returns true if the year is a leap year.
	*/
	virtual bool IsLeapYear() = 0;

	/**
	* IDateTime::IsLaterThan - Checks if this timestamp is later than another timestamp.
	* @param[in] pOtherTimeStamp - Instance to check against.
	* @return Returns true if the instance is later than OtherTimeStamp.
	*/
	virtual bool IsLaterThan(IDateTime* pOtherTimeStamp) = 0;

	/**
	* IDateTime::IsEarlierThan - Checks if this timestamp is earlier than another timestamp.
	* @param[in] pOtherTimeStamp - Instance to check against.
	* @return Returns true if the instance is earlier than OtherTimeStamp.
	*/
	virtual bool IsEarlierThan(IDateTime* pOtherTimeStamp) = 0;

	/**
	* IDateTime::IsEqualTo - Checks if this timestamp is equal to another timestamp.
	* @param[in] pOtherTimeStamp - Instance to check against.
	* @return Returns true if the instance is equal to the OtherTimeStamp.
	*/
	virtual bool IsEqualTo(IDateTime* pOtherTimeStamp) = 0;

	/**
	* IDateTime::GetTimeDifference - Returns the time difference to another time stamp as positive duration value.
	* @param[in] pOtherTimeStamp - Instance to check against.
	* @param[in] pDifference - Difference between the two time stamps. Value will always be positive.
	*/
	virtual void GetTimeDifference(IDateTime* pOtherTimeStamp, IDateTimeDifference* pDifference) = 0;

	/**
	* IDateTime::AddDuration - Shifts the date time by a duration. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] pDuration - Duration to add to the time stamp.
	*/
	virtual void AddDuration(IDateTimeDifference* pDuration) = 0;

	/**
	* IDateTime::SubtractDuration - Shifts the date time by a duration. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] pDuration - Duration to subtract from the time stamp.
	*/
	virtual void SubtractDuration(IDateTimeDifference* pDuration) = 0;

	/**
	* IDateTime::ShiftByYears - Shifts the date time by years. Takes leap years into account. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaYears - Years to shift the date time stamp.
	*/
	virtual void ShiftByYears(const LibMCEnv_int64 nDeltaYears) = 0;

	/**
	* IDateTime::ShiftByDays - Shifts the date time by days. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaDays - Days to shift the date time stamp.
	*/
	virtual void ShiftByDays(const LibMCEnv_int64 nDeltaDays) = 0;

	/**
	* IDateTime::ShiftByHours - Shifts the date time by hours. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaHours - Hours to shift the date time stamp.
	*/
	virtual void ShiftByHours(const LibMCEnv_int64 nDeltaHours) = 0;

	/**
	* IDateTime::ShiftByMinutes - Shifts the date time by minutes. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaMinutes - Minutes to shift the date time stamp.
	*/
	virtual void ShiftByMinutes(const LibMCEnv_int64 nDeltaMinutes) = 0;

	/**
	* IDateTime::ShiftBySeconds - Shifts the date time by seconds. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaSeconds - Seconds to shift the date time stamp.
	*/
	virtual void ShiftBySeconds(const LibMCEnv_int64 nDeltaSeconds) = 0;

	/**
	* IDateTime::ShiftByMilliseconds - Shifts the date time by milliseconds. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaMilliseconds - Milliseconds to shift the date time stamp.
	*/
	virtual void ShiftByMilliseconds(const LibMCEnv_int64 nDeltaMilliseconds) = 0;

	/**
	* IDateTime::ShiftByMicroseconds - Shifts the date time by microseconds. Fails if the shift will make it move outside of the year 1900 or 1000000.
	* @param[in] nDeltaMicroseconds - Microseconds to shift the date time stamp.
	*/
	virtual void ShiftByMicroseconds(const LibMCEnv_int64 nDeltaMicroseconds) = 0;

	/**
	* IDateTime::RoundDownToYear - Rounds down the timestamp to the start of the year. Takes leap years into account.
	*/
	virtual void RoundDownToYear() = 0;

	/**
	* IDateTime::RoundDownToMonth - Rounds down the timestamp to the start of the month. Takes leap years into account.
	*/
	virtual void RoundDownToMonth() = 0;

	/**
	* IDateTime::RoundDownToDay - Rounds down the timestamp to the full day.
	*/
	virtual void RoundDownToDay() = 0;

	/**
	* IDateTime::RoundDownToHour - Rounds down the timestamp to the full hour.
	*/
	virtual void RoundDownToHour() = 0;

	/**
	* IDateTime::RoundDownToMinute - Rounds down the timestamp to the full minute.
	*/
	virtual void RoundDownToMinute() = 0;

	/**
	* IDateTime::RoundDownToSeconds - Rounds down the timestamp to the full second.
	*/
	virtual void RoundDownToSeconds() = 0;

	/**
	* IDateTime::RoundDownToMilliseconds - Rounds down the timestamp to the full millisecond.
	*/
	virtual void RoundDownToMilliseconds() = 0;

	/**
	* IDateTime::RoundUpToYear - Rounds up the timestamp to the start of the year. Takes leap years into account.
	*/
	virtual void RoundUpToYear() = 0;

	/**
	* IDateTime::RoundUpToMonth - Rounds up the timestamp to the start of the month. Takes leap years into account.
	*/
	virtual void RoundUpToMonth() = 0;

	/**
	* IDateTime::RoundUpToDay - Rounds up the timestamp to the full day.
	*/
	virtual void RoundUpToDay() = 0;

	/**
	* IDateTime::RoundUpToHour - Rounds up the timestamp to the full hour.
	*/
	virtual void RoundUpToHour() = 0;

	/**
	* IDateTime::RoundUpToMinute - Rounds up the timestamp to the full minute.
	*/
	virtual void RoundUpToMinute() = 0;

	/**
	* IDateTime::RoundUpToSeconds - Rounds up the timestamp to the full second.
	*/
	virtual void RoundUpToSeconds() = 0;

	/**
	* IDateTime::RoundUpToMilliseconds - Rounds up the timestamp to the full millisecond.
	*/
	virtual void RoundUpToMilliseconds() = 0;

};

typedef IBaseSharedPtr<IDateTime> PIDateTime;


/*************************************************************************************************************************
 Class interface for MeshObject 
**************************************************************************************************************************/

class IMeshObject : public virtual IBase {
public:
	/**
	* IMeshObject::GetName - Returns the name of the Mesh Object.
	* @return Returns the name of the mesh object.
	*/
	virtual std::string GetName() = 0;

	/**
	* IMeshObject::GetUUID - Returns the UUID of the mesh object.
	* @return Returns mesh uuid.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IMeshObject::GetTriangleCount - Returns the number of triangles.
	* @return Number of triangles.
	*/
	virtual LibMCEnv_uint32 GetTriangleCount() = 0;

	/**
	* IMeshObject::GetVertexCount - Returns the number of vertices.
	* @return Number of vertices.
	*/
	virtual LibMCEnv_uint32 GetVertexCount() = 0;

};

typedef IBaseSharedPtr<IMeshObject> PIMeshObject;


/*************************************************************************************************************************
 Class interface for ToolpathPart 
**************************************************************************************************************************/

class IToolpathPart : public virtual IBase {
public:
	/**
	* IToolpathPart::GetName - Returns Part Name.
	* @return Returns toolpath part name.
	*/
	virtual std::string GetName() = 0;

	/**
	* IToolpathPart::GetUUID - Returns Part UUID.
	* @return Returns toolpath part uuid.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IToolpathPart::GetMeshUUID - Returns Mesh UUID of the part.
	* @return Returns toolpath part mesh uuid.
	*/
	virtual std::string GetMeshUUID() = 0;

	/**
	* IToolpathPart::GetTransform - Returns Mesh Transform of the part.
	* @return Returns the mesh transform of the toolpath.
	*/
	virtual LibMCEnv::sToolpathPartTransform GetTransform() = 0;

};

typedef IBaseSharedPtr<IToolpathPart> PIToolpathPart;


/*************************************************************************************************************************
 Class interface for ToolpathLayer 
**************************************************************************************************************************/

class IToolpathLayer : public virtual IBase {
public:
	/**
	* IToolpathLayer::GetLayerDataUUID - Retrieves the layerdata's uuid
	* @return Returns the uuid value.
	*/
	virtual std::string GetLayerDataUUID() = 0;

	/**
	* IToolpathLayer::GetSegmentCount - Retrieves the count of segments.
	* @return Count
	*/
	virtual LibMCEnv_uint32 GetSegmentCount() = 0;

	/**
	* IToolpathLayer::GetSegmentInfo - Retrieves the segment type and point count information .
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] eType - Segment Type
	* @param[out] nPointCount - Point count of segment.
	*/
	virtual void GetSegmentInfo(const LibMCEnv_uint32 nIndex, LibMCEnv::eToolpathSegmentType & eType, LibMCEnv_uint32 & nPointCount) = 0;

	/**
	* IToolpathLayer::GetSegmentType - Retrieves the segment type.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Type
	*/
	virtual LibMCEnv::eToolpathSegmentType GetSegmentType(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::SegmentIsLoop - Returns if segment is a loop.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Flag if segment is a loop.
	*/
	virtual bool SegmentIsLoop(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::SegmentIsPolyline - Returns if segment is a polyline.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Flag if segment is a polyline.
	*/
	virtual bool SegmentIsPolyline(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::SegmentIsHatchSegment - Returns if segment is a hatch segment.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Flag if segment is a hatch segment.
	*/
	virtual bool SegmentIsHatchSegment(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::GetSegmentIntegerAttribute - Retrieves the segment integer attribute with the corresponding ID. Fails if attribute does not exist or does have different type.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] nAttributeID - ID of the attribute.
	* @return Attribute Value.
	*/
	virtual LibMCEnv_int64 GetSegmentIntegerAttribute(const LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nAttributeID) = 0;

	/**
	* IToolpathLayer::GetSegmentDoubleAttribute - Retrieves the segment double attribute with the corresponding ID. Fails if attribute does not exist or does have different type.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] nAttributeID - ID of the attribute.
	* @return Attribute Value.
	*/
	virtual LibMCEnv_double GetSegmentDoubleAttribute(const LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nAttributeID) = 0;

	/**
	* IToolpathLayer::HasCustomSegmentAttribute - Checks if a segment attribute is registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @return Flag if attribute is registered.
	*/
	virtual bool HasCustomSegmentAttribute(const std::string & sNamespace, const std::string & sAttributeName) = 0;

	/**
	* IToolpathLayer::FindCustomSegmentAttributeID - Finds a segment attribute ID. Fails if attribute is not registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @return ID of the attribute.
	*/
	virtual LibMCEnv_uint32 FindCustomSegmentAttributeID(const std::string & sNamespace, const std::string & sAttributeName) = 0;

	/**
	* IToolpathLayer::FindCustomSegmentAttributeType - Finds a segment attribute type. Fails if attribute is not registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @return Type of the attribute.
	*/
	virtual LibMCEnv::eToolpathAttributeType FindCustomSegmentAttributeType(const std::string & sNamespace, const std::string & sAttributeName) = 0;

	/**
	* IToolpathLayer::FindCustomSegmentAttributeInfo - Finds a segment attribute ID and type. Fails if attribute is not registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @param[out] nAttributeID - ID of the attribute.
	* @param[out] eAttributeType - Type of the attribute.
	*/
	virtual void FindCustomSegmentAttributeInfo(const std::string & sNamespace, const std::string & sAttributeName, LibMCEnv_uint32 & nAttributeID, LibMCEnv::eToolpathAttributeType & eAttributeType) = 0;

	/**
	* IToolpathLayer::GetSegmentPointCount - Retrieves the number of points in the segment. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Hatch count of segment.
	*/
	virtual LibMCEnv_uint32 GetSegmentPointCount(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::GetSegmentHatchCount - Retrieves the number of hatches in the segment (i.e. PointCount / 2). Returns 0 if segment is not of type hatch.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Hatch count of segment.
	*/
	virtual LibMCEnv_uint32 GetSegmentHatchCount(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileUUID - Retrieves the assigned segment profile uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Profile UUID
	*/
	virtual std::string GetSegmentProfileUUID(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::SegmentProfileHasValue - Retrieves an assigned profile custom value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Returns true if value exist.
	*/
	virtual bool SegmentProfileHasValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileValue - Retrieves an assigned profile custom value. Fails if value does not exist.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return String Value.
	*/
	virtual std::string GetSegmentProfileValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileValueDef - Retrieves an assigned profile custom value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] sDefaultValue - Default value if value does not exist.
	* @return String Value.
	*/
	virtual std::string GetSegmentProfileValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const std::string & sDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileDoubleValue - Retrieves an assigned profile custom double value. Fails if value does not exist or is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Double Value.
	*/
	virtual LibMCEnv_double GetSegmentProfileDoubleValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileDoubleValueDef - Retrieves an assigned profile custom double value. Fails if value exists but is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] dDefaultValue - Default value if value does not exist.
	* @return Double Value.
	*/
	virtual LibMCEnv_double GetSegmentProfileDoubleValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileIntegerValue - Retrieves an assigned profile custom integer value. Fails if value does not exist or is not a integer value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Integer Value.
	*/
	virtual LibMCEnv_int64 GetSegmentProfileIntegerValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileIntegerValueDef - Retrieves an assigned profile custom integer value. Fails if value exists but is not a integer value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] nDefaultValue - Default value if value does not exist.
	* @return Integer Value.
	*/
	virtual LibMCEnv_int64 GetSegmentProfileIntegerValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const LibMCEnv_int64 nDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileBoolValue - Retrieves an assigned profile custom boolean value. A Boolean value is either an integer value, or strings of the form true or false (case insensitive). Fails if value does not exist or is not a bool value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Boolean Value.
	*/
	virtual bool GetSegmentProfileBoolValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileBoolValueDef - Retrieves an assigned profile custom boolean value. A Boolean value is either an integer value, or strings of the form true or false (case insensitive). Fails if value exists but is not a bool value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] bDefaultValue - Default value if value does not exist.
	* @return Boolean Value.
	*/
	virtual bool GetSegmentProfileBoolValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const bool bDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileTypedValue - Retrieves an assigned profile value of a standard type. Fails if value does not exist or is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] eValueType - Enum to query for. MUST NOT be custom.
	* @return Double Value
	*/
	virtual LibMCEnv_double GetSegmentProfileTypedValue(const LibMCEnv_uint32 nIndex, const LibMCEnv::eToolpathProfileValueType eValueType) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileTypedValueDef - Retrieves an assigned profile value of a standard type. Fails if value exists but is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] eValueType - Enum to query for. MUST NOT be custom.
	* @param[in] dDefaultValue - Default value if value does not exist.
	* @return Double Value
	*/
	virtual LibMCEnv_double GetSegmentProfileTypedValueDef(const LibMCEnv_uint32 nIndex, const LibMCEnv::eToolpathProfileValueType eValueType, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentPartUUID - Retrieves the assigned segment part uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Part UUID
	*/
	virtual std::string GetSegmentPartUUID(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::GetSegmentPointData - Retrieves the assigned segment point list. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] nPointDataBufferSize - Number of elements in buffer
	* @param[out] pPointDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pPointDataBuffer - Position2D buffer of The point data array. Positions are absolute in units.
	*/
	virtual void GetSegmentPointData(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 nPointDataBufferSize, LibMCEnv_uint64* pPointDataNeededCount, LibMCEnv::sPosition2D * pPointDataBuffer) = 0;

	/**
	* IToolpathLayer::GetSegmentHatchData - Retrieves the assigned segment hatch list. Fails if segment type is not hatch.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] nHatchDataBufferSize - Number of elements in buffer
	* @param[out] pHatchDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pHatchDataBuffer - Hatch2D buffer of The hatch data array. Positions are absolute in units.
	*/
	virtual void GetSegmentHatchData(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 nHatchDataBufferSize, LibMCEnv_uint64* pHatchDataNeededCount, LibMCEnv::sHatch2D * pHatchDataBuffer) = 0;

	/**
	* IToolpathLayer::GetSegmentPointDataInMM - Retrieves the assigned segment point list. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] nPointDataBufferSize - Number of elements in buffer
	* @param[out] pPointDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pPointDataBuffer - FloatPosition2D buffer of The point data array. Positions are absolute in mm.
	*/
	virtual void GetSegmentPointDataInMM(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 nPointDataBufferSize, LibMCEnv_uint64* pPointDataNeededCount, LibMCEnv::sFloatPosition2D * pPointDataBuffer) = 0;

	/**
	* IToolpathLayer::GetSegmentHatchDataInMM - Retrieves the assigned segment hatch list. Fails if segment type is not hatch.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] nHatchDataBufferSize - Number of elements in buffer
	* @param[out] pHatchDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pHatchDataBuffer - FloatHatch2D buffer of The hatch data array. Positions are absolute in mm.
	*/
	virtual void GetSegmentHatchDataInMM(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 nHatchDataBufferSize, LibMCEnv_uint64* pHatchDataNeededCount, LibMCEnv::sFloatHatch2D * pHatchDataBuffer) = 0;

	/**
	* IToolpathLayer::GetZValue - Retrieves the layers Z Value in units.
	* @return Z Value of the layer in units.
	*/
	virtual LibMCEnv_int32 GetZValue() = 0;

	/**
	* IToolpathLayer::GetZValueInMM - Retrieves the layers Z Value in mm.
	* @return Z Value of the layer in mm.
	*/
	virtual LibMCEnv_double GetZValueInMM() = 0;

	/**
	* IToolpathLayer::GetUnits - Retrieves the toolpath units in mm.
	* @return Toolpath units.
	*/
	virtual LibMCEnv_double GetUnits() = 0;

	/**
	* IToolpathLayer::GetMetaDataCount - Retrieves the number of metadata nodes in the build file.
	* @return Meta Data information.
	*/
	virtual LibMCEnv_uint32 GetMetaDataCount() = 0;

	/**
	* IToolpathLayer::GetMetaDataInfo - Returns the namespace and identifier of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @param[out] sNamespace - Namespace of the metadata
	* @param[out] sName - Name of the metadata
	*/
	virtual void GetMetaDataInfo(const LibMCEnv_uint32 nMetaDataIndex, std::string & sNamespace, std::string & sName) = 0;

	/**
	* IToolpathLayer::GetMetaDataContent - Returns the metadata XML content of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @return XML Metadata Object
	*/
	virtual IXMLDocumentNode * GetMetaDataContent(const LibMCEnv_uint32 nMetaDataIndex) = 0;

	/**
	* IToolpathLayer::HasUniqueMetaData - Checks if a metadata exists in the build file.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return Returns true if metadata exists and is unique.
	*/
	virtual bool HasUniqueMetaData(const std::string & sNamespace, const std::string & sName) = 0;

	/**
	* IToolpathLayer::FindUniqueMetaData - Returns the given metadata XML content of the build file. Fails if metadata content does not exist or is not unique.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return XML Metadata Object
	*/
	virtual IXMLDocumentNode * FindUniqueMetaData(const std::string & sNamespace, const std::string & sName) = 0;

	/**
	* IToolpathLayer::CalculateExtents - Calculates the layers extents in units
	* @param[out] nMinX - Minimal X value of the layer in units.
	* @param[out] nMinY - Minimal Y value of the layer in units.
	* @param[out] nMaxX - Maximal X value of the layer in units.
	* @param[out] nMaxY - Maximal Y value of the layer in units.
	*/
	virtual void CalculateExtents(LibMCEnv_int32 & nMinX, LibMCEnv_int32 & nMinY, LibMCEnv_int32 & nMaxX, LibMCEnv_int32 & nMaxY) = 0;

	/**
	* IToolpathLayer::CalculateExtentsInMM - Calculates the layers extents in millimeters
	* @param[out] dMinX - Minimal X value of the layer in mm.
	* @param[out] dMinY - Minimal Y value of the layer in mm.
	* @param[out] dMaxX - Maximal X value of the layer in mm.
	* @param[out] dMaxY - Maximal Y value of the layer in mm.
	*/
	virtual void CalculateExtentsInMM(LibMCEnv_double & dMinX, LibMCEnv_double & dMinY, LibMCEnv_double & dMaxX, LibMCEnv_double & dMaxY) = 0;

};

typedef IBaseSharedPtr<IToolpathLayer> PIToolpathLayer;


/*************************************************************************************************************************
 Class interface for ToolpathAccessor 
**************************************************************************************************************************/

class IToolpathAccessor : public virtual IBase {
public:
	/**
	* IToolpathAccessor::GetStorageUUID - Returns Toolpath storage UUID.
	* @return Returns toolpath storage uuid.
	*/
	virtual std::string GetStorageUUID() = 0;

	/**
	* IToolpathAccessor::GetBuildUUID - Returns UUID of the toolpath's build file.
	* @return Returns build uuid.
	*/
	virtual std::string GetBuildUUID() = 0;

	/**
	* IToolpathAccessor::GetLayerCount - Returns layer count.
	* @return Returns layer count.
	*/
	virtual LibMCEnv_uint32 GetLayerCount() = 0;

	/**
	* IToolpathAccessor::RegisterCustomSegmentAttribute - Registers a new custom segment attribute to be read.
	* @param[in] sNameSpace - Namespace of the custom attribute.
	* @param[in] sAttributeName - Name of the custom attribute.
	* @param[in] eAttributeType - Attribute Type.
	*/
	virtual void RegisterCustomSegmentAttribute(const std::string & sNameSpace, const std::string & sAttributeName, const LibMCEnv::eToolpathAttributeType eAttributeType) = 0;

	/**
	* IToolpathAccessor::LoadLayer - Reads and returns a layer object.
	* @param[in] nLayerIndex - Layer Index.
	* @return Toolpath layer object.
	*/
	virtual IToolpathLayer * LoadLayer(const LibMCEnv_uint32 nLayerIndex) = 0;

	/**
	* IToolpathAccessor::GetUnits - Retrieves the toolpath units in mm.
	* @return Toolpath units.
	*/
	virtual LibMCEnv_double GetUnits() = 0;

	/**
	* IToolpathAccessor::GetPartCount - Retrieves the number of parts in the toolpath.
	* @return Number of parts.
	*/
	virtual LibMCEnv_uint32 GetPartCount() = 0;

	/**
	* IToolpathAccessor::GetPart - Retrieves the part information of a toolpath.
	* @param[in] nPartIndex - Index of part. MUST be between 0 and PartCount-1
	* @return Part Instance
	*/
	virtual IToolpathPart * GetPart(const LibMCEnv_uint32 nPartIndex) = 0;

	/**
	* IToolpathAccessor::FindPartByUUID - Finds the part information of a toolpath.
	* @param[in] sPartUUID - UUID of part.
	* @return Part Instance. Returns null if part does not exist.
	*/
	virtual IToolpathPart * FindPartByUUID(const std::string & sPartUUID) = 0;

	/**
	* IToolpathAccessor::GetBuildHeightInUnits - Retrieves the build height in units.
	* @return Build height in units.
	*/
	virtual LibMCEnv_int32 GetBuildHeightInUnits() = 0;

	/**
	* IToolpathAccessor::GetZValueInUnits - Retrieves the layers Z Value in units.
	* @param[in] nLayerIndex - Layer Index to return.
	* @return Z Value of the layer in units.
	*/
	virtual LibMCEnv_int32 GetZValueInUnits(const LibMCEnv_uint32 nLayerIndex) = 0;

	/**
	* IToolpathAccessor::GetBuildHeightInMM - Retrieves the build height in mm.
	* @return Build height in mm.
	*/
	virtual LibMCEnv_double GetBuildHeightInMM() = 0;

	/**
	* IToolpathAccessor::GetZValueInMM - Retrieves the layers Z Value in mm.
	* @param[in] nLayerIndex - Layer Index to return.
	* @return Z Value of the layer in mm.
	*/
	virtual LibMCEnv_double GetZValueInMM(const LibMCEnv_uint32 nLayerIndex) = 0;

	/**
	* IToolpathAccessor::GetMetaDataCount - Retrieves the number of metadata nodes in the build file.
	* @return Meta Data information.
	*/
	virtual LibMCEnv_uint32 GetMetaDataCount() = 0;

	/**
	* IToolpathAccessor::GetMetaDataInfo - Returns the namespace and identifier of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @param[out] sNamespace - Namespace of the metadata
	* @param[out] sName - Name of the metadata
	*/
	virtual void GetMetaDataInfo(const LibMCEnv_uint32 nMetaDataIndex, std::string & sNamespace, std::string & sName) = 0;

	/**
	* IToolpathAccessor::GetMetaDataContent - Returns the metadata XML content of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @return XML Metadata Object
	*/
	virtual IXMLDocumentNode * GetMetaDataContent(const LibMCEnv_uint32 nMetaDataIndex) = 0;

	/**
	* IToolpathAccessor::HasUniqueMetaData - Checks if a metadata exists in the build file.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return Returns true if metadata exists and is unique.
	*/
	virtual bool HasUniqueMetaData(const std::string & sNamespace, const std::string & sName) = 0;

	/**
	* IToolpathAccessor::FindUniqueMetaData - Returns the given metadata XML content of the build file. Fails if metadata content does not exist or is not unique.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return XML Metadata Object
	*/
	virtual IXMLDocumentNode * FindUniqueMetaData(const std::string & sNamespace, const std::string & sName) = 0;

};

typedef IBaseSharedPtr<IToolpathAccessor> PIToolpathAccessor;


/*************************************************************************************************************************
 Class interface for BuildExecution 
**************************************************************************************************************************/

class IBuildExecution : public virtual IBase {
public:
	/**
	* IBuildExecution::GetUUID - Returns uuid of the build execution.
	* @return UUID of the build execution.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IBuildExecution::GetBuildUUID - Returns uuid of the build.
	* @return UUID of the build.
	*/
	virtual std::string GetBuildUUID() = 0;

	/**
	* IBuildExecution::GetBuild - Returns the instance of the build.
	* @return Instance of the build.
	*/
	virtual IBuild * GetBuild() = 0;

	/**
	* IBuildExecution::GetExecutionStatus - Returns the status of the execution.
	* @return Status of the build.
	*/
	virtual LibMCEnv::eBuildExecutionStatus GetExecutionStatus() = 0;

	/**
	* IBuildExecution::IsInProcess - Convenience function for checking the execution status.
	* @return Returns true if the status is InProcess.
	*/
	virtual bool IsInProcess() = 0;

	/**
	* IBuildExecution::IsFinished - Convenience function for checking the execution status.
	* @return Returns true if the status is Finished.
	*/
	virtual bool IsFinished() = 0;

	/**
	* IBuildExecution::IsFailed - Convenience function for checking the execution status.
	* @return Returns true if the status is Failed.
	*/
	virtual bool IsFailed() = 0;

	/**
	* IBuildExecution::SetStatusToFinished - Sets build execution status to finished. Fails if Build status is not InProcess 
	*/
	virtual void SetStatusToFinished() = 0;

	/**
	* IBuildExecution::SetStatusToFailed - Sets build execution status to failed. Fails if Build status is not InProcess 
	*/
	virtual void SetStatusToFailed() = 0;

	/**
	* IBuildExecution::GetDescription - Returns a human readable description of the build execution for display in the User Interface.
	* @return Description.
	*/
	virtual std::string GetDescription() = 0;

	/**
	* IBuildExecution::SetDescription - Sets a human readable description of the build execution for display in the User Interface. Should not be empty.
	* @param[in] sDescription - Description.
	*/
	virtual void SetDescription(const std::string & sDescription) = 0;

	/**
	* IBuildExecution::GetJournalUUID - Returns the machine journal UUID that this job in executing in.
	* @return Journal UUID of build execution.
	*/
	virtual std::string GetJournalUUID() = 0;

	/**
	* IBuildExecution::HasAttachedUser - Returns if a user is attached to the execution.
	* @return Flag if a user is attached to the execution.
	*/
	virtual bool HasAttachedUser() = 0;

	/**
	* IBuildExecution::GetUserUUID - Returns the user that started this job. Fails if no user is attached to the execution.
	* @return User who started the job.
	*/
	virtual std::string GetUserUUID() = 0;

	/**
	* IBuildExecution::GetStartTimeStampInMilliseconds - Returns the start time stamp of the build execution in the current machine journal.
	* @return TimeStamp when the build started in Milliseconds.
	*/
	virtual LibMCEnv_uint64 GetStartTimeStampInMilliseconds() = 0;

	/**
	* IBuildExecution::GetStartTimeStampInMicroseconds - Returns the start time stamp of the build execution in the current machine journal.
	* @return TimeStamp when the build started in Microseconds.
	*/
	virtual LibMCEnv_uint64 GetStartTimeStampInMicroseconds() = 0;

	/**
	* IBuildExecution::GetEndTimeStampInMilliseconds - Returns the end time stamp of the build execution in the current machine journal. Status MUST BE in Finished or Failed to retrieve this value.
	* @return TimeStamp when the build ended in Milliseconds.
	*/
	virtual LibMCEnv_uint64 GetEndTimeStampInMilliseconds() = 0;

	/**
	* IBuildExecution::GetEndTimeStampInMicroseconds - Returns the end time stamp of the build execution in the current machine journal. Status MUST BE in Finished or Failed to retrieve this value.
	* @return TimeStamp when the build ended in Microseconds.
	*/
	virtual LibMCEnv_uint64 GetEndTimeStampInMicroseconds() = 0;

	/**
	* IBuildExecution::GetElapsedTimeInMilliseconds - Returns the relative time of the build execution. If status is Finished or Failed, the full duration is returned.
	* @return Elapsed time in Milliseconds.
	*/
	virtual LibMCEnv_uint64 GetElapsedTimeInMilliseconds() = 0;

	/**
	* IBuildExecution::GetElapsedTimeInMicroseconds - Returns the relative time of the build execution. If status is Finished or Failed, the full duration is returned.
	* @return Elapsed time in Microseconds.
	*/
	virtual LibMCEnv_uint64 GetElapsedTimeInMicroseconds() = 0;

	/**
	* IBuildExecution::AddBinaryData - Adds binary data to store with the build.
	* @param[in] sIdentifier - Unique identifier of the attached data. Fails if ther already exists a binary data with the equal identifier.
	* @param[in] sName - Name of the attache data
	* @param[in] sMIMEType - Mime type of the data.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[in] pContentBuffer - Stream content to store
	* @return Data UUID of the attachment.
	*/
	virtual std::string AddBinaryData(const std::string & sIdentifier, const std::string & sName, const std::string & sMIMEType, const LibMCEnv_uint64 nContentBufferSize, const LibMCEnv_uint8 * pContentBuffer) = 0;

	/**
	* IBuildExecution::LoadDiscreteField2DByIdentifier - Loads a discrete field by context identifier which was previously stored in the build job. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	virtual IDiscreteFieldData2D * LoadDiscreteField2DByIdentifier(const std::string & sContextIdentifier) = 0;

	/**
	* IBuildExecution::LoadDiscreteField2DByUUID - Loads a discrete field by uuid which previously stored in the build job. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	virtual IDiscreteFieldData2D * LoadDiscreteField2DByUUID(const std::string & sDataUUID) = 0;

	/**
	* IBuildExecution::StoreDiscreteField2D - Stores a discrete field in the build job. MIME Type will be application/amcf-discretefield2d.
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] sName - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] pFieldDataInstance - Field instance to store.
	* @param[in] pStoreOptions - Field Data Store Options.
	* @return Data UUID of the attachment.
	*/
	virtual std::string StoreDiscreteField2D(const std::string & sContextIdentifier, const std::string & sName, IDiscreteFieldData2D* pFieldDataInstance, IDiscreteFieldData2DStoreOptions* pStoreOptions) = 0;

	/**
	* IBuildExecution::LoadPNGImageByIdentifier - Loads a discrete field by context identifier which was previously stored in the build job. MIME Type MUST be image/png.
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @return Image data instance.
	*/
	virtual IImageData * LoadPNGImageByIdentifier(const std::string & sContextIdentifier) = 0;

	/**
	* IBuildExecution::LoadPNGImageByUUID - Loads a discrete field by uuid which was previously stored in the build job. MIME Type MUST be image/png.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Image data instance.
	*/
	virtual IImageData * LoadPNGImageByUUID(const std::string & sDataUUID) = 0;

	/**
	* IBuildExecution::StorePNGImage - Stores a discrete field in the build job. MIME Type will be image/png
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] sName - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] pImageDataInstance - Image data instance.
	* @param[in] pStoreOptions - PNG Store Options.
	* @return Data UUID of the attachment.
	*/
	virtual std::string StorePNGImage(const std::string & sContextIdentifier, const std::string & sName, IImageData* pImageDataInstance, IPNGImageStoreOptions* pStoreOptions) = 0;

	/**
	* IBuildExecution::AddMetaDataString - Adds a metadata string to a build execution. Meta data can only be added once. Deletion is not supported by purpose and MUST be avoided by the system design.
	* @param[in] sKey - Unique key of value. MUST NOT be empty. MUST consist of alphanumeric characters or hyphen or underscore. Fails if Key already exists.
	* @param[in] sValue - Value to store.
	*/
	virtual void AddMetaDataString(const std::string & sKey, const std::string & sValue) = 0;

	/**
	* IBuildExecution::HasMetaDataString - Checks if a metadata string exists.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Returns if metadata string exists.
	*/
	virtual bool HasMetaDataString(const std::string & sKey) = 0;

	/**
	* IBuildExecution::GetMetaDataString - Gets a metadata string of a build execution. Fails if Meta Data does not exist.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Return value.
	*/
	virtual std::string GetMetaDataString(const std::string & sKey) = 0;

};

typedef IBaseSharedPtr<IBuildExecution> PIBuildExecution;


/*************************************************************************************************************************
 Class interface for BuildExecutionIterator 
**************************************************************************************************************************/

class IBuildExecutionIterator : public virtual IIterator {
public:
	/**
	* IBuildExecutionIterator::GetCurrentExecution - Returns the execution the iterator points at.
	* @return returns the BuildExecution instance.
	*/
	virtual IBuildExecution * GetCurrentExecution() = 0;

};

typedef IBaseSharedPtr<IBuildExecutionIterator> PIBuildExecutionIterator;


/*************************************************************************************************************************
 Class interface for Build 
**************************************************************************************************************************/

class IBuild : public virtual IBase {
public:
	/**
	* IBuild::GetName - Returns name of the build.
	* @return Name of the build.
	*/
	virtual std::string GetName() = 0;

	/**
	* IBuild::GetBuildUUID - Returns uuid of the build.
	* @return UUID of the build.
	*/
	virtual std::string GetBuildUUID() = 0;

	/**
	* IBuild::GetStorageUUID - Returns storage uuid of the build stream.
	* @return Storage UUID of the build.
	*/
	virtual std::string GetStorageUUID() = 0;

	/**
	* IBuild::GetStorageSHA256 - Returns SHA256 of the build stream.
	* @return SHA256 of the build stream.
	*/
	virtual std::string GetStorageSHA256() = 0;

	/**
	* IBuild::GetLayerCount - Returns cached layer count of the toolpath.
	* @return Returns layer count.
	*/
	virtual LibMCEnv_uint32 GetLayerCount() = 0;

	/**
	* IBuild::GetBuildHeightInMM - Retrieves the build height in mm.
	* @return Build height in mm.
	*/
	virtual LibMCEnv_double GetBuildHeightInMM() = 0;

	/**
	* IBuild::GetZValueInMM - Retrieves the layers Z Value in mm.
	* @param[in] nLayerIndex - Layer Index to return.
	* @return Z Value of the layer in mm.
	*/
	virtual LibMCEnv_double GetZValueInMM(const LibMCEnv_uint32 nLayerIndex) = 0;

	/**
	* IBuild::LoadToolpath - loads the a toolpath into memory
	*/
	virtual void LoadToolpath() = 0;

	/**
	* IBuild::UnloadToolpath - unloads the a toolpath from memory, if it has been loaded before.
	*/
	virtual void UnloadToolpath() = 0;

	/**
	* IBuild::ToolpathIsLoaded - checks, if a toolpath object is loaded to memory.
	* @return returns if toolpath is loaded.
	*/
	virtual bool ToolpathIsLoaded() = 0;

	/**
	* IBuild::CreateToolpathAccessor - Creates an accessor object for a toolpath. Toolpath MUST have been loaded with LoadToolpath before.
	* @return Toolpath instance.
	*/
	virtual IToolpathAccessor * CreateToolpathAccessor() = 0;

	/**
	* IBuild::AddBinaryData - Adds binary data to store with the build.
	* @param[in] sIdentifier - Unique identifier of the attached data. Fails if ther already exists a binary data with the equal identifier.
	* @param[in] sName - Name of the attache data
	* @param[in] sMIMEType - Mime type of the data.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[in] pContentBuffer - Stream content to store
	* @return Data UUID of the attachment.
	*/
	virtual std::string AddBinaryData(const std::string & sIdentifier, const std::string & sName, const std::string & sMIMEType, const LibMCEnv_uint64 nContentBufferSize, const LibMCEnv_uint8 * pContentBuffer) = 0;

	/**
	* IBuild::LoadDiscreteField2DByIdentifier - Loads a discrete field by context identifier which was previously stored in the build job. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	virtual IDiscreteFieldData2D * LoadDiscreteField2DByIdentifier(const std::string & sContextIdentifier) = 0;

	/**
	* IBuild::LoadDiscreteField2DByUUID - Loads a discrete field by uuid which previously stored in the build job. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	virtual IDiscreteFieldData2D * LoadDiscreteField2DByUUID(const std::string & sDataUUID) = 0;

	/**
	* IBuild::StoreDiscreteField2D - Stores a discrete field in the build job. MIME Type will be application/amcf-discretefield2d.
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] sName - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] pFieldDataInstance - Field instance to store.
	* @param[in] pStoreOptions - Field Data Store Options.
	* @return Data UUID of the attachment.
	*/
	virtual std::string StoreDiscreteField2D(const std::string & sContextIdentifier, const std::string & sName, IDiscreteFieldData2D* pFieldDataInstance, IDiscreteFieldData2DStoreOptions* pStoreOptions) = 0;

	/**
	* IBuild::LoadPNGImageByIdentifier - Loads a discrete field by context identifier which was previously stored in the build job. MIME Type MUST be image/png.
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @return Image data instance.
	*/
	virtual IImageData * LoadPNGImageByIdentifier(const std::string & sContextIdentifier) = 0;

	/**
	* IBuild::LoadPNGImageByUUID - Loads a discrete field by uuid which was previously stored in the build job. MIME Type MUST be image/png.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Image data instance.
	*/
	virtual IImageData * LoadPNGImageByUUID(const std::string & sDataUUID) = 0;

	/**
	* IBuild::StorePNGImage - Stores a discrete field in the build job. MIME Type will be image/png
	* @param[in] sContextIdentifier - Unique name of the attachment. Fails if name does already exist or has invalid Mime type.
	* @param[in] sName - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] pImageDataInstance - Image data instance.
	* @param[in] pStoreOptions - PNG Store Options.
	* @return Data UUID of the attachment.
	*/
	virtual std::string StorePNGImage(const std::string & sContextIdentifier, const std::string & sName, IImageData* pImageDataInstance, IPNGImageStoreOptions* pStoreOptions) = 0;

	/**
	* IBuild::StartExecution - Starts a build execution. This function does not work in a UIEnvironment context!
	* @param[in] sDescription - A human readable description of the build execution for display in the User Interface. Should not be empty.
	* @param[in] sUserUUID - User who started the execution. MUST exist. If empty, no user is attached.
	* @return Build execution instance. Will be newly created and has the status InProcess.
	*/
	virtual IBuildExecution * StartExecution(const std::string & sDescription, const std::string & sUserUUID) = 0;

	/**
	* IBuild::HasExecution - Checks if a build execution exists for this build.
	* @param[in] sExecutionUUID - The UUID of the exceution.
	* @return Returns true if the execution exists.
	*/
	virtual bool HasExecution(const std::string & sExecutionUUID) = 0;

	/**
	* IBuild::FindExecution - Finds a build execution. Fails if execution does not exist.
	* @param[in] sExecutionUUID - The UUID of the exceution.
	* @return Build execution instance. Will be newly created and has the status InProcess.
	*/
	virtual IBuildExecution * FindExecution(const std::string & sExecutionUUID) = 0;

	/**
	* IBuild::ListExecutions - Lists all Executions of the build.
	* @param[in] bOnlyCurrentJournalSession - If true, only the builds that have been created in the current machine session.
	* @return Iterator instance.
	*/
	virtual IBuildExecutionIterator * ListExecutions(const bool bOnlyCurrentJournalSession) = 0;

	/**
	* IBuild::ListExecutionsByStatus - Lists all Executions of the build by status.
	* @param[in] eExecutionStatus - Status of the build.
	* @param[in] bOnlyCurrentJournalSession - If true, only the builds that have been created in the current machine session.
	* @return Iterator instance.
	*/
	virtual IBuildExecutionIterator * ListExecutionsByStatus(const LibMCEnv::eBuildExecutionStatus eExecutionStatus, const bool bOnlyCurrentJournalSession) = 0;

	/**
	* IBuild::AddMetaDataString - Adds a metadata string to a build. Meta data can only be added once. Deletion is not supported by purpose and MUST be avoided by the system design.
	* @param[in] sKey - Unique key of value. MUST NOT be empty. MUST consist of alphanumeric characters or hyphen or underscore. Fails if Key already exists.
	* @param[in] sValue - Value to store.
	*/
	virtual void AddMetaDataString(const std::string & sKey, const std::string & sValue) = 0;

	/**
	* IBuild::HasMetaDataString - Checks if a metadata string exists.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Returns if metadata string exists.
	*/
	virtual bool HasMetaDataString(const std::string & sKey) = 0;

	/**
	* IBuild::GetMetaDataString - Gets a metadata string of a build. Fails if Meta Data does not exist.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Return value.
	*/
	virtual std::string GetMetaDataString(const std::string & sKey) = 0;

};

typedef IBaseSharedPtr<IBuild> PIBuild;


/*************************************************************************************************************************
 Class interface for WorkingFileExecution 
**************************************************************************************************************************/

class IWorkingFileExecution : public virtual IBase {
public:
	/**
	* IWorkingFileExecution::GetStatus - Returns the execution status
	*/
	virtual void GetStatus() = 0;

	/**
	* IWorkingFileExecution::ReturnStdOut - Returns the output of the executable as string buffer
	* @return stdout buffer
	*/
	virtual std::string ReturnStdOut() = 0;

};

typedef IBaseSharedPtr<IWorkingFileExecution> PIWorkingFileExecution;


/*************************************************************************************************************************
 Class interface for WorkingFile 
**************************************************************************************************************************/

class IWorkingFile : public virtual IBase {
public:
	/**
	* IWorkingFile::GetAbsoluteFileName - Retrieves absolute file name of the working file
	* @return global path of the file
	*/
	virtual std::string GetAbsoluteFileName() = 0;

	/**
	* IWorkingFile::GetSize - Returns the size of temporary file.
	* @return file size
	*/
	virtual LibMCEnv_uint64 GetSize() = 0;

	/**
	* IWorkingFile::CalculateSHA2 - Calculates the SHA256 checksum of the file.
	* @return sha256 checksum
	*/
	virtual std::string CalculateSHA2() = 0;

	/**
	* IWorkingFile::ExecuteFile - Executes the temporary file, if it is an executable.
	* @return execution object
	*/
	virtual IWorkingFileExecution * ExecuteFile() = 0;

	/**
	* IWorkingFile::IsManaged - Returns if the file is managed.
	* @return returns if the file is managed.
	*/
	virtual bool IsManaged() = 0;

	/**
	* IWorkingFile::MakeManaged - Makes the file managed if it is not managed yet.
	*/
	virtual void MakeManaged() = 0;

	/**
	* IWorkingFile::FileExists - Returns if the file exists on disk.
	* @return returns if the file exists.
	*/
	virtual bool FileExists() = 0;

	/**
	* IWorkingFile::DeleteFromDisk - Deletes the temporary file.
	* @return returns if deletion was successful or file did not exist in the first place.
	*/
	virtual bool DeleteFromDisk() = 0;

};

typedef IBaseSharedPtr<IWorkingFile> PIWorkingFile;


/*************************************************************************************************************************
 Class interface for WorkingFileIterator 
**************************************************************************************************************************/

class IWorkingFileIterator : public virtual IIterator {
public:
	/**
	* IWorkingFileIterator::GetCurrentFile - Returns the working file the iterator points at.
	* @return returns the WorkingFile instance.
	*/
	virtual IWorkingFile * GetCurrentFile() = 0;

};

typedef IBaseSharedPtr<IWorkingFileIterator> PIWorkingFileIterator;


/*************************************************************************************************************************
 Class interface for WorkingDirectory 
**************************************************************************************************************************/

class IWorkingDirectory : public virtual IBase {
public:
	/**
	* IWorkingDirectory::IsActive - Working directory is active.
	* @return returns true if files can be read and written to the directory.
	*/
	virtual bool IsActive() = 0;

	/**
	* IWorkingDirectory::GetAbsoluteFilePath - Retrieves absolute file path.
	* @return global path of the directory, including path delimiter.
	*/
	virtual std::string GetAbsoluteFilePath() = 0;

	/**
	* IWorkingDirectory::StoreCustomData - Stores a data buffer in a temporary file with a given name.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[in] pDataBufferBuffer - file data to store to.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreCustomData(const std::string & sFileName, const LibMCEnv_uint64 nDataBufferBufferSize, const LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IWorkingDirectory::StoreCustomString - Stores a string in a temporary file with a given name.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] sDataString - file data to store to.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreCustomString(const std::string & sFileName, const std::string & sDataString) = 0;

	/**
	* IWorkingDirectory::StoreDriverData - Stores attached driver data in a temporary file.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreDriverData(const std::string & sFileName, const std::string & sIdentifier) = 0;

	/**
	* IWorkingDirectory::StoreCustomDataInTempFile - Stores a data buffer in a temporary file with a generated name.
	* @param[in] sExtension - extension of the file to store. MAY be an empty string. MUST only include up to 64 alphanumeric characters.
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[in] pDataBufferBuffer - file data to store to.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreCustomDataInTempFile(const std::string & sExtension, const LibMCEnv_uint64 nDataBufferBufferSize, const LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IWorkingDirectory::StoreCustomStringInTempFile - Stores a string in a temporary file.
	* @param[in] sExtension - extension of the file to store. MAY be an empty string. MUST only include up to 64 alphanumeric characters.
	* @param[in] sDataString - file data to store to.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreCustomStringInTempFile(const std::string & sExtension, const std::string & sDataString) = 0;

	/**
	* IWorkingDirectory::StoreDriverDataInTempFile - Stores attached driver data in a temporary file.
	* @param[in] sExtension - extension of the file to store. MAY be an empty string. MUST only include up to 64 alphanumeric characters.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreDriverDataInTempFile(const std::string & sExtension, const std::string & sIdentifier) = 0;

	/**
	* IWorkingDirectory::CleanUp - Deletes all managed files in the directory and the directory. No storing is possible after a cleanup.
	* @return returns if deletion was successful.
	*/
	virtual bool CleanUp() = 0;

	/**
	* IWorkingDirectory::AddManagedFile - Adds a managed filename in the directory (i.e. this file will be deleted at CleanUp). Subdirectories are not allowed.
	* @param[in] sFileName - Filename to manage. The file does not need to exist yet.
	* @return working file instance.
	*/
	virtual IWorkingFile * AddManagedFile(const std::string & sFileName) = 0;

	/**
	* IWorkingDirectory::HasUnmanagedFiles - Returns if the working directory has unmanaged files. A clean implementation will never deal with unmanaged files.
	* @return returns if there are unmanaged files.
	*/
	virtual bool HasUnmanagedFiles() = 0;

	/**
	* IWorkingDirectory::RetrieveUnmanagedFiles - Returns a list of unmanaged files.
	* @return working file iterator instance.
	*/
	virtual IWorkingFileIterator * RetrieveUnmanagedFiles() = 0;

	/**
	* IWorkingDirectory::RetrieveManagedFiles - Returns a list of managed files.
	* @return working file iterator instance.
	*/
	virtual IWorkingFileIterator * RetrieveManagedFiles() = 0;

	/**
	* IWorkingDirectory::RetrieveAllFiles - Returns a list of all files in the directory.
	* @return working file iterator instance.
	*/
	virtual IWorkingFileIterator * RetrieveAllFiles() = 0;

};

typedef IBaseSharedPtr<IWorkingDirectory> PIWorkingDirectory;


/*************************************************************************************************************************
 Class interface for XMLDocumentAttribute 
**************************************************************************************************************************/

class IXMLDocumentAttribute : public virtual IBase {
public:
	/**
	* IXMLDocumentAttribute::GetNameSpace - Retrieves namespace of the attribute.
	* @return returns the namespace of the attribute.
	*/
	virtual std::string GetNameSpace() = 0;

	/**
	* IXMLDocumentAttribute::GetName - Retrieves name of the attribute.
	* @return returns the name of the attribute.
	*/
	virtual std::string GetName() = 0;

	/**
	* IXMLDocumentAttribute::GetValue - Retrieves value of the attribute as string.
	* @return returns the value of the attribute.
	*/
	virtual std::string GetValue() = 0;

	/**
	* IXMLDocumentAttribute::IsValidUUID - Checks if the value is a valid UUID string.
	* @return returns if the value is a valid UUID string.
	*/
	virtual bool IsValidUUID() = 0;

	/**
	* IXMLDocumentAttribute::GetUUIDValue - Retrieves value of the attribute as UUID string. Fails if value is not a UUID string.
	* @return returns the value of the attribute as normalized UUID string.
	*/
	virtual std::string GetUUIDValue() = 0;

	/**
	* IXMLDocumentAttribute::IsValidInteger - Checks if the value is a valid integer in the given range.
	* @param[in] nMinValue - Minimum allowed value
	* @param[in] nMaxValue - Maximum allowed value
	* @return returns if the value is a valid integer.
	*/
	virtual bool IsValidInteger(const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue) = 0;

	/**
	* IXMLDocumentAttribute::GetIntegerValue - Returns the value as integer. Fails if the value is not a valid integer in the given range.
	* @param[in] nMinValue - Minimum allowed value
	* @param[in] nMaxValue - Maximum allowed value
	* @return returns the value.
	*/
	virtual LibMCEnv_int64 GetIntegerValue(const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue) = 0;

	/**
	* IXMLDocumentAttribute::IsValidDouble - Checks if the value is a valid double in the given range.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return returns if the value is a valid double.
	*/
	virtual bool IsValidDouble(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue) = 0;

	/**
	* IXMLDocumentAttribute::GetDoubleValue - Returns the value as double. Fails if the value is not a valid double in the given range.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return returns the value .
	*/
	virtual LibMCEnv_double GetDoubleValue(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue) = 0;

	/**
	* IXMLDocumentAttribute::IsValidBool - Checks if the value is a valid boolean value, meaning an integer or true or false as string. The value will be trimmed and any character will be converted to lowercase.
	* @return returns if the value is a valid bool.
	*/
	virtual bool IsValidBool() = 0;

	/**
	* IXMLDocumentAttribute::GetBoolValue - Returns the value as bool. Fails if the value is not a valid boolean value, meaning an integer or true or false as string. The value will be trimmed and any character will be converted to lowercase.
	* @return returns the value .
	*/
	virtual bool GetBoolValue() = 0;

	/**
	* IXMLDocumentAttribute::SetValue - Sets the value of the attribute as string.
	* @param[in] sValue - new value of the attribute.
	*/
	virtual void SetValue(const std::string & sValue) = 0;

	/**
	* IXMLDocumentAttribute::SetUUIDValue - Sets the value of the attribute as UUID string.
	* @param[in] sValue - new value of the attribute. Fails if Value is not a UUID.
	*/
	virtual void SetUUIDValue(const std::string & sValue) = 0;

	/**
	* IXMLDocumentAttribute::SetIntegerValue - Sets the value of the attribute as integer.
	* @param[in] nValue - new value of the attribute.
	*/
	virtual void SetIntegerValue(const LibMCEnv_int64 nValue) = 0;

	/**
	* IXMLDocumentAttribute::SetDoubleValue - Sets the value of the attribute as double.
	* @param[in] dValue - new value of the attribute.
	*/
	virtual void SetDoubleValue(const LibMCEnv_double dValue) = 0;

	/**
	* IXMLDocumentAttribute::SetBoolValue - Sets the value of the attribute as bool.
	* @param[in] bValue - new value of the attribute.
	*/
	virtual void SetBoolValue(const bool bValue) = 0;

	/**
	* IXMLDocumentAttribute::Remove - Removes the attribute from its parent node. All subsequent calls to the class will fail.
	*/
	virtual void Remove() = 0;

};

typedef IBaseSharedPtr<IXMLDocumentAttribute> PIXMLDocumentAttribute;


/*************************************************************************************************************************
 Class interface for XMLDocumentNode 
**************************************************************************************************************************/

class IXMLDocumentNode : public virtual IBase {
public:
	/**
	* IXMLDocumentNode::GetName - Retrieves name of the node.
	* @return returns the name of the node.
	*/
	virtual std::string GetName() = 0;

	/**
	* IXMLDocumentNode::GetNameSpace - Retrieves namespace of the node.
	* @return returns the namespace of the node.
	*/
	virtual std::string GetNameSpace() = 0;

	/**
	* IXMLDocumentNode::GetTextContent - Retrieves the text content of the node. A node with text content MUST NOT have children.
	* @return returns the text content of the node.
	*/
	virtual std::string GetTextContent() = 0;

	/**
	* IXMLDocumentNode::SetTextContent - Sets the text content of the node. Call will fail if node has children.
	* @param[in] sTextContent - the new text content of the node.
	*/
	virtual void SetTextContent(const std::string & sTextContent) = 0;

	/**
	* IXMLDocumentNode::GetAttributeCount - Returns number of attributes.
	* @return returns the number of attributes.
	*/
	virtual LibMCEnv_uint64 GetAttributeCount() = 0;

	/**
	* IXMLDocumentNode::GetAttribute - Returns attribute instance. Fails if Index is out of range.
	* @param[in] nIndex - Index of the attribute to return (0-based).
	* @return XML Document attribute.
	*/
	virtual IXMLDocumentAttribute * GetAttribute(const LibMCEnv_uint64 nIndex) = 0;

	/**
	* IXMLDocumentNode::HasAttribute - Returns if attribute of a specific name exists.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Returns if the attribute exists.
	*/
	virtual bool HasAttribute(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::FindAttribute - Returns attribute instance of a specific name. 
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] bMustExist - If true, the call fails if attribute does not exist. If falls, the call will return null if the attribute does not exist.
	* @return XML Document attribute.
	*/
	virtual IXMLDocumentAttribute * FindAttribute(const std::string & sNameSpace, const std::string & sName, const bool bMustExist) = 0;

	/**
	* IXMLDocumentNode::GetAttributeValue - Returns string value of an attribute. Fails if attribute does not exist.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Attribute value.
	*/
	virtual std::string GetAttributeValue(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::GetAttributeIntegerValue - Returns integer value of an attribute. Fails if attribute does not exist or attribute is not an integer .
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] nMinValue - Minimum allowed value.
	* @param[in] nMaxValue - Maximum allowed value.
	* @return Attribute value.
	*/
	virtual LibMCEnv_int64 GetAttributeIntegerValue(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeDoubleValue - Returns double value of an attribute. Fails if attribute does not exist or attribute is not a double value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return Attribute value.
	*/
	virtual LibMCEnv_double GetAttributeDoubleValue(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeBoolValue - Returns bool value of an attribute. Fails if attribute does not exist or attribute is not a boolean value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Attribute value.
	*/
	virtual bool GetAttributeBoolValue(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::GetAttributeUUIDValue - Returns UUID value of an attribute. Fails if attribute does not exist or attribute value is not a UUID.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Attribute value.
	*/
	virtual std::string GetAttributeUUIDValue(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::GetAttributeValueDef - Returns string value of an attribute. Returns default value if attribute does not exist.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] sDefaultValue - Default value.
	* @return Attribute value.
	*/
	virtual std::string GetAttributeValueDef(const std::string & sNameSpace, const std::string & sName, const std::string & sDefaultValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeIntegerValueDef - Returns integer value of an attribute. Returns default value if attribute does not exist or attribute is not an integer .
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] nMinValue - Minimum allowed value.
	* @param[in] nMaxValue - Maximum allowed value.
	* @param[in] nDefaultValue - Default value. MUST be in valid range.
	* @return Attribute value.
	*/
	virtual LibMCEnv_int64 GetAttributeIntegerValueDef(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue, const LibMCEnv_int64 nDefaultValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeDoubleValueDef - Returns double value of an attribute. Returns default value if attribute does not exist or attribute is not a double value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @param[in] dDefaultValue - Default value. MUST be in valid range.
	* @return Attribute value.
	*/
	virtual LibMCEnv_double GetAttributeDoubleValueDef(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeBoolValueDef - Returns bool value of an attribute. Returns default value if attribute does not exist or attribute is not a boolean value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] bDefaultValue - Default value.
	* @return Attribute value.
	*/
	virtual bool GetAttributeBoolValueDef(const std::string & sNameSpace, const std::string & sName, const bool bDefaultValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeUUIDValueDef - Returns UUID value of an attribute. Returns default value if attribute does not exist or attribute value is not a UUID.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] sDefaultValue - Attribute value. MUST be a valid UUID
	* @return Attribute value.
	*/
	virtual std::string GetAttributeUUIDValueDef(const std::string & sNameSpace, const std::string & sName, const std::string & sDefaultValue) = 0;

	/**
	* IXMLDocumentNode::RemoveAttribute - Removes the attribute with a specific name. Does nothing if attribute does not exist.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	*/
	virtual void RemoveAttribute(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::RemoveAttributeByIndex - Removes the attribute with a specific index. Does nothing if attribute does not exist.
	* @param[in] nIndex - Index of the attribute to remove (0-based).
	*/
	virtual void RemoveAttributeByIndex(const LibMCEnv_uint64 nIndex) = 0;

	/**
	* IXMLDocumentNode::AddAttribute - Adds an attribute with a specific name and string value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the attribute. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] sValue - Value of the attribute.
	*/
	virtual void AddAttribute(const std::string & sNameSpace, const std::string & sName, const std::string & sValue) = 0;

	/**
	* IXMLDocumentNode::AddIntegerAttribute - Adds an attribute with a specific name and integer value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the attribute. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] nValue - Value of the attribute.
	*/
	virtual void AddIntegerAttribute(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IXMLDocumentNode::AddDoubleAttribute - Adds an attribute with a specific name and double value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] dValue - Value of the attribute.
	*/
	virtual void AddDoubleAttribute(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dValue) = 0;

	/**
	* IXMLDocumentNode::AddBoolAttribute - Adds an attribute with a specific name and bool value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] bValue - Value of the attribute.
	*/
	virtual void AddBoolAttribute(const std::string & sNameSpace, const std::string & sName, const bool bValue) = 0;

	/**
	* IXMLDocumentNode::GetChildren - Returns all the child nodes of the XML Node.
	* @return returns the list of child nodes.
	*/
	virtual IXMLDocumentNodes * GetChildren() = 0;

	/**
	* IXMLDocumentNode::CountChildrenByName - Returns how many children of the XML Node have a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns the number children with the specified name.
	*/
	virtual LibMCEnv_uint64 CountChildrenByName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::GetChildrenByName - Returns all the child nodes of the XML Node with a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns the list of child nodes.
	*/
	virtual IXMLDocumentNodes * GetChildrenByName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::HasChild - Returns if a child with a specific name exist.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns if a child with a specific name exists.
	*/
	virtual bool HasChild(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::HasUniqueChild - Returns if a child with a specific name exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns if a child with a specific name exists once and only once.
	*/
	virtual bool HasUniqueChild(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::FindChild - Returns child with a specific name. Throws an error if name does not exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @param[in] bMustExist - If true, the call fails if child does not exist. If falls, the call will return null if the child does not exist.
	* @return returns child instance or null.
	*/
	virtual IXMLDocumentNode * FindChild(const std::string & sNameSpace, const std::string & sName, const bool bMustExist) = 0;

	/**
	* IXMLDocumentNode::AddChild - Adds a new child with a specific name. Fails if node has a non-empty text content.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns child instance.
	*/
	virtual IXMLDocumentNode * AddChild(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::AddChildText - Adds a new child with text content and a specific name. Fails if node has a non-empty text content.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @param[in] sTextContent - Text content of the child.
	* @return returns child instance.
	*/
	virtual IXMLDocumentNode * AddChildText(const std::string & sNameSpace, const std::string & sName, const std::string & sTextContent) = 0;

	/**
	* IXMLDocumentNode::RemoveChild - Removes a child with a specific name. All subsequent calls to the child will fail after the call.
	* @param[in] pChildInstance - child instance to remove. Fails if given instance is not a child of the node.
	*/
	virtual void RemoveChild(IXMLDocumentNode* pChildInstance) = 0;

	/**
	* IXMLDocumentNode::RemoveChildrenWithName - Removes all children with a specific name. Does nothing if no child with the name exists. . All subsequent calls to the deleted children will fail after the call.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the children.
	*/
	virtual void RemoveChildrenWithName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::Remove - Removes the node from its parent. The root node of the document can not be removed.
	*/
	virtual void Remove() = 0;

};

typedef IBaseSharedPtr<IXMLDocumentNode> PIXMLDocumentNode;


/*************************************************************************************************************************
 Class interface for XMLDocumentNodes 
**************************************************************************************************************************/

class IXMLDocumentNodes : public virtual IBase {
public:
	/**
	* IXMLDocumentNodes::GetNodeCount - Returns number of nodes.
	* @return returns the number of nodes in the list.
	*/
	virtual LibMCEnv_uint64 GetNodeCount() = 0;

	/**
	* IXMLDocumentNodes::GetNode - Returns node instance. Fails if Index is out of range.
	* @param[in] nIndex - Index of the node to return (0-based).
	* @return XML Node node.
	*/
	virtual IXMLDocumentNode * GetNode(const LibMCEnv_uint64 nIndex) = 0;

	/**
	* IXMLDocumentNodes::CountNodesByName - Returns how many nodes of the XML Node have a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns the number of nodes with the specified name.
	*/
	virtual LibMCEnv_uint64 CountNodesByName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNodes::GetNodesByName - Returns all the nodes nodes of the XML Node with a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns the list of node nodes.
	*/
	virtual IXMLDocumentNodes * GetNodesByName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNodes::HasNode - Returns if a node with a specific name exist.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns if a node with a specific name exists.
	*/
	virtual bool HasNode(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNodes::HasUniqueNode - Returns if a node with a specific name exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns if a node with a specific name exists once and only once.
	*/
	virtual bool HasUniqueNode(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNodes::FindNode - Returns node with a specific name. Throws an error if name does not exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @param[in] bMustExist - If true, the call fails if node does not exist. If falls, the call will return null if the node does not exist.
	* @return returns node instance.
	*/
	virtual IXMLDocumentNode * FindNode(const std::string & sNameSpace, const std::string & sName, const bool bMustExist) = 0;

};

typedef IBaseSharedPtr<IXMLDocumentNodes> PIXMLDocumentNodes;


/*************************************************************************************************************************
 Class interface for XMLDocument 
**************************************************************************************************************************/

class IXMLDocument : public virtual IBase {
public:
	/**
	* IXMLDocument::GetDefaultNamespace - Returns default name space of the document.
	* @return name space of the document.
	*/
	virtual std::string GetDefaultNamespace() = 0;

	/**
	* IXMLDocument::GetNamespaceCount - Returns the used number of name spaces of the document.
	* @return number of registered name spaces of the document.
	*/
	virtual LibMCEnv_uint64 GetNamespaceCount() = 0;

	/**
	* IXMLDocument::GetNamespace - Returns a name space of the document. Will fail if index is invalid.
	* @param[in] nIndex - index of name space. 0-based.
	* @param[out] sNamespace - name space of the document.
	* @param[out] sNamespacePrefix - name space prefix of the document. Empty for root namespace.
	*/
	virtual void GetNamespace(const LibMCEnv_uint64 nIndex, std::string & sNamespace, std::string & sNamespacePrefix) = 0;

	/**
	* IXMLDocument::HasNamespace - Returns if the document has a namespace.
	* @param[in] sNamespace - Name space name.
	* @return name space has been registered.
	*/
	virtual bool HasNamespace(const std::string & sNamespace) = 0;

	/**
	* IXMLDocument::GetNamespacePrefix - Returns a name space of the document. Will fail if namespace is not registered.
	* @param[in] sNamespace - name space of the document.
	* @return name space prefix of the document. Empty for root namespace.
	*/
	virtual std::string GetNamespacePrefix(const std::string & sNamespace) = 0;

	/**
	* IXMLDocument::RegisterNamespace - Registers a custom namespace prefix. Given Namespace MUST NOT have been in use before calling this function.
	* @param[in] sNamespace - name space to register
	* @param[in] sNamespacePrefix - name space prefix to use for the namespace. MUST NOT be in use, MUST NOT be an empty string or contain non-alphanumeric characters.
	*/
	virtual void RegisterNamespace(const std::string & sNamespace, const std::string & sNamespacePrefix) = 0;

	/**
	* IXMLDocument::ChangeNamespacePrefix - Changes the prefix of an existing Namespace. New Namespace MUST NOT have been in use before calling this function.
	* @param[in] sOldNamespacePrefix - name space prefix that is currently in use.
	* @param[in] sNewNamespacePrefix - name space prefix to use for the namespace. MUST NOT be in use, MUST NOT be an empty string or contain non-alphanumeric characters.
	*/
	virtual void ChangeNamespacePrefix(const std::string & sOldNamespacePrefix, const std::string & sNewNamespacePrefix) = 0;

	/**
	* IXMLDocument::GetRootNode - Returns root node of the document.
	* @return Root node of the document.
	*/
	virtual IXMLDocumentNode * GetRootNode() = 0;

	/**
	* IXMLDocument::SaveToString - Saves the XML document into a string.
	* @param[in] bAddLineBreaks - If true, line breaks and indentation will be added to the output string.
	* @return String with the XML Content.
	*/
	virtual std::string SaveToString(const bool bAddLineBreaks) = 0;

};

typedef IBaseSharedPtr<IXMLDocument> PIXMLDocument;


/*************************************************************************************************************************
 Class interface for TCPIPPacket 
**************************************************************************************************************************/

class ITCPIPPacket : public virtual IBase {
public:
	/**
	* ITCPIPPacket::IsEmpty - Returns if packet is empty.
	* @return Flag if packet is empty.
	*/
	virtual bool IsEmpty() = 0;

	/**
	* ITCPIPPacket::GetSize - Returns the size of the packet. Returns 0 if packet is empty.
	* @return returns size of packet.
	*/
	virtual LibMCEnv_uint32 GetSize() = 0;

	/**
	* ITCPIPPacket::GetData - Returns the data of the packet. Fails if packet is empty.
	* @param[in] nBufferBufferSize - Number of elements in buffer
	* @param[out] pBufferNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pBufferBuffer - uint8 buffer of packet data.
	*/
	virtual void GetData(LibMCEnv_uint64 nBufferBufferSize, LibMCEnv_uint64* pBufferNeededCount, LibMCEnv_uint8 * pBufferBuffer) = 0;

};

typedef IBaseSharedPtr<ITCPIPPacket> PITCPIPPacket;


/*************************************************************************************************************************
 Class interface for TCPIPConnection 
**************************************************************************************************************************/

class ITCPIPConnection : public virtual IBase {
public:
	/**
	* ITCPIPConnection::GetIPAddress - Returns the IP Address of the Connection.
	* @return IP Address.
	*/
	virtual std::string GetIPAddress() = 0;

	/**
	* ITCPIPConnection::GetPort - Returns the Port of the Connection.
	* @return Port.
	*/
	virtual LibMCEnv_uint32 GetPort() = 0;

	/**
	* ITCPIPConnection::GetTimeout - Returns the Timeout of the Connection.
	* @return Timeout in milliseconds.
	*/
	virtual LibMCEnv_uint32 GetTimeout() = 0;

	/**
	* ITCPIPConnection::IsConnected - Returns if the instance is connected.
	* @return .
	*/
	virtual bool IsConnected() = 0;

	/**
	* ITCPIPConnection::Disconnect - Disconnects from the Server, if connected.
	*/
	virtual void Disconnect() = 0;

	/**
	* ITCPIPConnection::Reconnect - Disconnects and Connects to the Server.
	*/
	virtual void Reconnect() = 0;

	/**
	* ITCPIPConnection::SendBuffer - Sends a buffer of bytes to the Server.
	* @param[in] nBufferBufferSize - Number of elements in buffer
	* @param[in] pBufferBuffer - packet payload.
	*/
	virtual void SendBuffer(const LibMCEnv_uint64 nBufferBufferSize, const LibMCEnv_uint8 * pBufferBuffer) = 0;

	/**
	* ITCPIPConnection::WaitForData - Waits for a server packet to arrive.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return Flag if a new packet has arrived.
	*/
	virtual bool WaitForData(const LibMCEnv_uint32 nTimeOutInMS) = 0;

	/**
	* ITCPIPConnection::ReceiveFixedPacket - Receives a fixed length packet. Blocks until expected number of bytes arrives or timeout is hit. Fails if there is a connection error. Returns empty packet if timeout is hit.
	* @param[in] nPacketSize - Size of packet to receive. MUST be larger than 0.
	* @param[in] nTimeOutInMS - Timeout in Milliseconds.
	* @return Packet instance. Returns empty packet if timeout is hit
	*/
	virtual ITCPIPPacket * ReceiveFixedPacket(const LibMCEnv_uint32 nPacketSize, const LibMCEnv_uint32 nTimeOutInMS) = 0;

	/**
	* ITCPIPConnection::ReceiveData - Receives data. Fails if there is a connection error. Returns empty packet if timeout is hit.
	* @param[in] nDataSize - Size of data to receive.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return Packet instance. Size will be between 0 and DataSize.
	*/
	virtual ITCPIPPacket * ReceiveData(const LibMCEnv_uint32 nDataSize, const LibMCEnv_uint32 nTimeOutInMS) = 0;

};

typedef IBaseSharedPtr<ITCPIPConnection> PITCPIPConnection;


/*************************************************************************************************************************
 Class interface for ModbusTCPDigitalIOStatus 
**************************************************************************************************************************/

class IModbusTCPDigitalIOStatus : public virtual IBase {
public:
	/**
	* IModbusTCPDigitalIOStatus::GetCount - Returns the number of Digital IOs in the instance.
	* @return Count.
	*/
	virtual LibMCEnv_uint32 GetCount() = 0;

	/**
	* IModbusTCPDigitalIOStatus::GetBaseAddress - Returns the base address of Digital IOs in the instance.
	* @return Base Address.
	*/
	virtual LibMCEnv_uint32 GetBaseAddress() = 0;

	/**
	* IModbusTCPDigitalIOStatus::GetValue - Returns the cached state of the Digital IO in the instance.
	* @param[in] nIndex - Index of IO Value. 0-based.
	* @return State Value.
	*/
	virtual bool GetValue(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IModbusTCPDigitalIOStatus::GetValues - Returns all Digital IOs of the instance as byte array.
	* @param[in] nStateArrayBufferSize - Number of elements in buffer
	* @param[out] pStateArrayNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pStateArrayBuffer - uint8 buffer of State Value Array.
	*/
	virtual void GetValues(LibMCEnv_uint64 nStateArrayBufferSize, LibMCEnv_uint64* pStateArrayNeededCount, LibMCEnv_uint8 * pStateArrayBuffer) = 0;

};

typedef IBaseSharedPtr<IModbusTCPDigitalIOStatus> PIModbusTCPDigitalIOStatus;


/*************************************************************************************************************************
 Class interface for ModbusTCPRegisterStatus 
**************************************************************************************************************************/

class IModbusTCPRegisterStatus : public virtual IBase {
public:
	/**
	* IModbusTCPRegisterStatus::GetCount - Returns the number of registers in the instance.
	* @return Count.
	*/
	virtual LibMCEnv_uint32 GetCount() = 0;

	/**
	* IModbusTCPRegisterStatus::GetBaseAddress - Returns the base address of registers in the instance.
	* @return Base Address.
	*/
	virtual LibMCEnv_uint32 GetBaseAddress() = 0;

	/**
	* IModbusTCPRegisterStatus::GetValue - Returns the cached state of the registers in the instance.
	* @param[in] nIndex - Index of IO Value. 0-based.
	* @return State Value.
	*/
	virtual LibMCEnv_uint16 GetValue(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IModbusTCPRegisterStatus::GetValues - Returns all registers of the instance as word array.
	* @param[in] nStateArrayBufferSize - Number of elements in buffer
	* @param[out] pStateArrayNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pStateArrayBuffer - uint16 buffer of State Value Array.
	*/
	virtual void GetValues(LibMCEnv_uint64 nStateArrayBufferSize, LibMCEnv_uint64* pStateArrayNeededCount, LibMCEnv_uint16 * pStateArrayBuffer) = 0;

};

typedef IBaseSharedPtr<IModbusTCPRegisterStatus> PIModbusTCPRegisterStatus;


/*************************************************************************************************************************
 Class interface for ModbusTCPConnection 
**************************************************************************************************************************/

class IModbusTCPConnection : public virtual IBase {
public:
	/**
	* IModbusTCPConnection::GetIPAddress - Returns the IP Address of the Connection.
	* @return IP Address.
	*/
	virtual std::string GetIPAddress() = 0;

	/**
	* IModbusTCPConnection::GetPort - Returns the Port of the Connection.
	* @return Port.
	*/
	virtual LibMCEnv_uint32 GetPort() = 0;

	/**
	* IModbusTCPConnection::GetTimeout - Returns the Timeout of the Connection.
	* @return Timeout in milliseconds.
	*/
	virtual LibMCEnv_uint32 GetTimeout() = 0;

	/**
	* IModbusTCPConnection::IsConnected - Returns if the instance is connected.
	* @return .
	*/
	virtual bool IsConnected() = 0;

	/**
	* IModbusTCPConnection::Disconnect - Disconnects from the Server.
	*/
	virtual void Disconnect() = 0;

	/**
	* IModbusTCPConnection::Reconnect - Disconnects and Connects to the Server.
	*/
	virtual void Reconnect() = 0;

	/**
	* IModbusTCPConnection::DiagnosisCall - Sends a diagnosis call to the Server.
	* @param[in] nSubFunction - Modbus TCP Subfunction ID.
	* @param[in] nDataField - Modbus TCP Data Field.
	* @return Modbus TCP Data Response.
	*/
	virtual LibMCEnv_uint16 DiagnosisCall(const LibMCEnv_uint16 nSubFunction, const LibMCEnv_uint16 nDataField) = 0;

	/**
	* IModbusTCPConnection::ReadCoilStatus - Reads coil status of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBitCount - Number of coils to read. MUST be larger than 0.
	* @return Coil status instance.
	*/
	virtual IModbusTCPDigitalIOStatus * ReadCoilStatus(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nBitCount) = 0;

	/**
	* IModbusTCPConnection::ReadInputStatus - Reads input status of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBitCount - Number of inputs to read. MUST be larger than 0.
	* @return Input status instance.
	*/
	virtual IModbusTCPDigitalIOStatus * ReadInputStatus(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nBitCount) = 0;

	/**
	* IModbusTCPConnection::ReadHoldingRegisters - Reads holding registers of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nRegisterCount - Number of registers. MUST be larger than 0.
	* @return Holding register instance.
	*/
	virtual IModbusTCPRegisterStatus * ReadHoldingRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nRegisterCount) = 0;

	/**
	* IModbusTCPConnection::ReadInputRegisters - Reads input registers of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nRegisterCount - Number of registers. MUST be larger than 0.
	* @return Input register instance.
	*/
	virtual IModbusTCPRegisterStatus * ReadInputRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nRegisterCount) = 0;

	/**
	* IModbusTCPConnection::ForceMultipleCoils - Forces multiple coils on Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBufferBufferSize - Number of elements in buffer
	* @param[in] pBufferBuffer - Input coil array. One byte per Input. MUST NOT be empty
	*/
	virtual void ForceMultipleCoils(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint64 nBufferBufferSize, const LibMCEnv_uint8 * pBufferBuffer) = 0;

	/**
	* IModbusTCPConnection::PresetMultipleRegisters - Forces multiple registers on Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBufferBufferSize - Number of elements in buffer
	* @param[in] pBufferBuffer - Input register array. One word per Input. MUST NOT be empty
	*/
	virtual void PresetMultipleRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint64 nBufferBufferSize, const LibMCEnv_uint16 * pBufferBuffer) = 0;

};

typedef IBaseSharedPtr<IModbusTCPConnection> PIModbusTCPConnection;


/*************************************************************************************************************************
 Class interface for DriverStatusUpdateSession 
**************************************************************************************************************************/

class IDriverStatusUpdateSession : public virtual IBase {
public:
	/**
	* IDriverStatusUpdateSession::SetStringParameter - sets a string parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetStringParameter(const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IDriverStatusUpdateSession::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetUUIDParameter(const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IDriverStatusUpdateSession::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	virtual void SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue) = 0;

	/**
	* IDriverStatusUpdateSession::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	virtual void SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IDriverStatusUpdateSession::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	virtual void SetBoolParameter(const std::string & sParameterName, const bool bValue) = 0;

	/**
	* IDriverStatusUpdateSession::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	virtual void LogMessage(const std::string & sLogString) = 0;

	/**
	* IDriverStatusUpdateSession::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	virtual void LogWarning(const std::string & sLogString) = 0;

	/**
	* IDriverStatusUpdateSession::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	virtual void LogInfo(const std::string & sLogString) = 0;

	/**
	* IDriverStatusUpdateSession::Sleep - Puts the current instance to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	virtual void Sleep(const LibMCEnv_uint32 nDelay) = 0;

};

typedef IBaseSharedPtr<IDriverStatusUpdateSession> PIDriverStatusUpdateSession;


/*************************************************************************************************************************
 Class interface for DriverEnvironment 
**************************************************************************************************************************/

class IDriverEnvironment : public virtual IBase {
public:
	/**
	* IDriverEnvironment::CreateStatusUpdateSession - creates a status update object which can be easily called from an independent thread.
	* @return creates a status update instance
	*/
	virtual IDriverStatusUpdateSession * CreateStatusUpdateSession() = 0;

	/**
	* IDriverEnvironment::CreateWorkingDirectory - creates a temporary working directory.
	* @return creates a working directory
	*/
	virtual IWorkingDirectory * CreateWorkingDirectory() = 0;

	/**
	* IDriverEnvironment::CreateTCPIPConnection - creates a TCP/IP Connection for a specific IP address and port.
	* @param[in] sIPAddress - IP Address.
	* @param[in] nPort - Port.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return connects to the given IP Address
	*/
	virtual ITCPIPConnection * CreateTCPIPConnection(const std::string & sIPAddress, const LibMCEnv_uint32 nPort, const LibMCEnv_uint32 nTimeOutInMS) = 0;

	/**
	* IDriverEnvironment::CreateModbusTCPConnection - creates a Modbus TCP Connection for a specific IP address and port.
	* @param[in] sIPAddress - IP Address.
	* @param[in] nPort - Port.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return connects to the given IP Address
	*/
	virtual IModbusTCPConnection * CreateModbusTCPConnection(const std::string & sIPAddress, const LibMCEnv_uint32 nPort, const LibMCEnv_uint32 nTimeOutInMS) = 0;

	/**
	* IDriverEnvironment::CreateXMLDocument - creates an empty XML Document.
	* @param[in] sRootNodeName - Name of the root node. MUST be a valid XML Node Name string.
	* @param[in] sDefaultNamespace - Default namespace of the document. MUST be a valid XML namespace string.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace) = 0;

	/**
	* IDriverEnvironment::ParseXMLString - parses an XML String and returns an XML Document instance. Throws an error if XML is malformatted.
	* @param[in] sXMLString - XML String.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLString(const std::string & sXMLString) = 0;

	/**
	* IDriverEnvironment::ParseXMLData - parses a XML stored in a byte array and returns an XML Document instance. . Throws an error if XML is malformatted.
	* @param[in] nXMLDataBufferSize - Number of elements in buffer
	* @param[in] pXMLDataBuffer - XML Binary data.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLData(const LibMCEnv_uint64 nXMLDataBufferSize, const LibMCEnv_uint8 * pXMLDataBuffer) = 0;

	/**
	* IDriverEnvironment::CreateDataTable - creates an empty data table.
	* @return Data Table Instance.
	*/
	virtual IDataTable * CreateDataTable() = 0;

	/**
	* IDriverEnvironment::DriverHasResourceData - retrieves if attached driver has data with the given identifier.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return returns true if the resource exists in the machine resource package.
	*/
	virtual bool DriverHasResourceData(const std::string & sIdentifier) = 0;

	/**
	* IDriverEnvironment::MachineHasResourceData - retrieves if attached driver has data with the given identifier.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return returns true if the resource exists in the machine resource package.
	*/
	virtual bool MachineHasResourceData(const std::string & sIdentifier) = 0;

	/**
	* IDriverEnvironment::RetrieveDriverData - retrieves attached driver resource data into a memory buffer. (depreciated, equivalent to RetrieveDriverResourceData)
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[out] pDataBufferNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pDataBufferBuffer - uint8 buffer of buffer data.
	*/
	virtual void RetrieveDriverData(const std::string & sIdentifier, LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IDriverEnvironment::RetrieveDriverResourceData - retrieves attached driver resource data into a memory buffer.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[out] pDataBufferNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pDataBufferBuffer - uint8 buffer of buffer data.
	*/
	virtual void RetrieveDriverResourceData(const std::string & sIdentifier, LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IDriverEnvironment::RetrieveMachineResourceData - retrieves a machine resource data (Plugins Directory) driver data into a memory buffer.
	* @param[in] sIdentifier - identifier of the binary data in the machine resource package.
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[out] pDataBufferNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pDataBufferBuffer - uint8 buffer of buffer data.
	*/
	virtual void RetrieveMachineResourceData(const std::string & sIdentifier, LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IDriverEnvironment::CreateToolpathAccessor - Creates an accessor object for a toolpath. Toolpath MUST have been loaded into memory before.
	* @param[in] sStreamUUID - UUID of the stream.
	* @return Toolpath instance.
	*/
	virtual IToolpathAccessor * CreateToolpathAccessor(const std::string & sStreamUUID) = 0;

	/**
	* IDriverEnvironment::ParameterNameIsValid - checks if a name is a valid alphanumerical string for parameters.
	* @param[in] sParameterName - Parameter Name
	* @return returns true if the parameter name is a valid name.
	*/
	virtual bool ParameterNameIsValid(const std::string & sParameterName) = 0;

	/**
	* IDriverEnvironment::RegisterStringParameter - registers a string parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] sDefaultValue - default value to set
	*/
	virtual void RegisterStringParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue) = 0;

	/**
	* IDriverEnvironment::RegisterUUIDParameter - registers a uuid parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] sDefaultValue - default value to set
	*/
	virtual void RegisterUUIDParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue) = 0;

	/**
	* IDriverEnvironment::RegisterDoubleParameter - registers a double parameter. Must only be called during driver creation. The default units are 0.001.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] dDefaultValue - default value to set
	*/
	virtual void RegisterDoubleParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IDriverEnvironment::RegisterDoubleParameterWithUnits - registers a double parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] dDefaultValue - default value to set
	* @param[in] dUnits - unit factor to use
	*/
	virtual void RegisterDoubleParameterWithUnits(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_double dDefaultValue, const LibMCEnv_double dUnits) = 0;

	/**
	* IDriverEnvironment::RegisterIntegerParameter - registers an int parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] nDefaultValue - default value to set
	*/
	virtual void RegisterIntegerParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_int64 nDefaultValue) = 0;

	/**
	* IDriverEnvironment::RegisterBoolParameter - registers a bool parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] bDefaultValue - default value to set
	*/
	virtual void RegisterBoolParameter(const std::string & sParameterName, const std::string & sDescription, const bool bDefaultValue) = 0;

	/**
	* IDriverEnvironment::SetStringParameter - sets a string parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetStringParameter(const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IDriverEnvironment::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetUUIDParameter(const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IDriverEnvironment::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	virtual void SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue) = 0;

	/**
	* IDriverEnvironment::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	virtual void SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IDriverEnvironment::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	virtual void SetBoolParameter(const std::string & sParameterName, const bool bValue) = 0;

	/**
	* IDriverEnvironment::Sleep - Puts the current instance to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	virtual void Sleep(const LibMCEnv_uint32 nDelay) = 0;

	/**
	* IDriverEnvironment::GetGlobalTimerInMilliseconds - Returns the global timer in milliseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetGlobalTimerInMilliseconds() = 0;

	/**
	* IDriverEnvironment::GetGlobalTimerInMicroseconds - Returns the global timer in microseconds.
	* @return Timer value in Microseconds
	*/
	virtual LibMCEnv_uint64 GetGlobalTimerInMicroseconds() = 0;

	/**
	* IDriverEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	virtual void LogMessage(const std::string & sLogString) = 0;

	/**
	* IDriverEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	virtual void LogWarning(const std::string & sLogString) = 0;

	/**
	* IDriverEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	virtual void LogInfo(const std::string & sLogString) = 0;

	/**
	* IDriverEnvironment::CreateEmptyImage - creates an empty image object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use.
	* @return Empty image instance.
	*/
	virtual IImageData * CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IDriverEnvironment::LoadPNGImage - creates an image object from a PNG data stream.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[in] pPNGDataBuffer - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image instance containing the PNG image.
	*/
	virtual IImageData * LoadPNGImage(const LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IDriverEnvironment::CreateDiscreteField2D - Creates an empty discrete field.
	* @param[in] nPixelCountX - Pixel count in X. MUST be positive.
	* @param[in] nPixelCountY - Pixel count in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @param[in] dDefaultValue - Default value of the field.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IDriverEnvironment::CreateDiscreteField2DFromImage - Creates a discrete field from the greyscale values of an image. RGB colors in the image will be averaged to obtain a greyscale color.
	* @param[in] pImageDataInstance - Image instance containing the pixel data.
	* @param[in] dBlackValue - Value that the minimum color (black) shall be mapped to.
	* @param[in] dWhiteValue - Value that the maximum color (white) shall be mapped to.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2DFromImage(IImageData* pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY) = 0;

	/**
	* IDriverEnvironment::HasBuildJob - Returns if a build object exists. Fails if BuildUUID is not a valid UUID string.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Returns true if build exists
	*/
	virtual bool HasBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IDriverEnvironment::GetBuildJob - Returns a instance of a build object. Fails if build uuid does not exist.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	virtual IBuild * GetBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IDriverEnvironment::CreateCryptoContext - Creates a crypto context.
	* @return Cryptographic context instance
	*/
	virtual ICryptoContext * CreateCryptoContext() = 0;

};

typedef IBaseSharedPtr<IDriverEnvironment> PIDriverEnvironment;


/*************************************************************************************************************************
 Class interface for SignalTrigger 
**************************************************************************************************************************/

class ISignalTrigger : public virtual IBase {
public:
	/**
	* ISignalTrigger::CanTrigger - Returns, if signal channel is available.
	* @return Returns true, if signal channel is available.
	*/
	virtual bool CanTrigger() = 0;

	/**
	* ISignalTrigger::Trigger - Triggers a signal, if signal channel is available.
	*/
	virtual void Trigger() = 0;

	/**
	* ISignalTrigger::WaitForHandling - Waits until the signal is reset.
	* @param[in] nTimeOut - Timeout in Milliseconds. 0 for Immediate return.
	* @return Flag if signal handling has been handled.
	*/
	virtual bool WaitForHandling(const LibMCEnv_uint32 nTimeOut) = 0;

	/**
	* ISignalTrigger::GetName - Returns the signal name.
	* @return Name Of Signal
	*/
	virtual std::string GetName() = 0;

	/**
	* ISignalTrigger::GetStateMachine - Returns the signal state machine instance.
	* @return Name Of State Machine
	*/
	virtual std::string GetStateMachine() = 0;

	/**
	* ISignalTrigger::SetString - sets a string value
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	virtual void SetString(const std::string & sName, const std::string & sValue) = 0;

	/**
	* ISignalTrigger::SetUUID - sets a uuid value
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	virtual void SetUUID(const std::string & sName, const std::string & sValue) = 0;

	/**
	* ISignalTrigger::SetDouble - sets a double
	* @param[in] sName - Name
	* @param[in] dValue - Value
	*/
	virtual void SetDouble(const std::string & sName, const LibMCEnv_double dValue) = 0;

	/**
	* ISignalTrigger::SetInteger - sets an int.
	* @param[in] sName - Name
	* @param[in] nValue - Value
	*/
	virtual void SetInteger(const std::string & sName, const LibMCEnv_int64 nValue) = 0;

	/**
	* ISignalTrigger::SetBool - sets a bool
	* @param[in] sName - Name
	* @param[in] bValue - Value
	*/
	virtual void SetBool(const std::string & sName, const bool bValue) = 0;

	/**
	* ISignalTrigger::GetStringResult - returns a string value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	virtual std::string GetStringResult(const std::string & sName) = 0;

	/**
	* ISignalTrigger::GetUUIDResult - returns a uuid value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	virtual std::string GetUUIDResult(const std::string & sName) = 0;

	/**
	* ISignalTrigger::GetDoubleResult - returns a string value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	virtual LibMCEnv_double GetDoubleResult(const std::string & sName) = 0;

	/**
	* ISignalTrigger::GetIntegerResult - returns an int value of the result.
	* @param[in] sName - Name
	* @return Value
	*/
	virtual LibMCEnv_int64 GetIntegerResult(const std::string & sName) = 0;

	/**
	* ISignalTrigger::GetBoolResult - returns a bool value of the result.
	* @param[in] sName - Name
	* @return Value
	*/
	virtual bool GetBoolResult(const std::string & sName) = 0;

};

typedef IBaseSharedPtr<ISignalTrigger> PISignalTrigger;


/*************************************************************************************************************************
 Class interface for SignalHandler 
**************************************************************************************************************************/

class ISignalHandler : public virtual IBase {
public:
	/**
	* ISignalHandler::SignalHandled - Marks signal as handled and resets signal channel.
	*/
	virtual void SignalHandled() = 0;

	/**
	* ISignalHandler::GetName - Returns the signal name.
	* @return Name Of Signal
	*/
	virtual std::string GetName() = 0;

	/**
	* ISignalHandler::GetSignalID - Returns the signal id. Depreciated.
	* @return Signal Identifier
	*/
	virtual std::string GetSignalID() = 0;

	/**
	* ISignalHandler::GetSignalUUID - Returns the signal uuid. Identical to GetSignalID.
	* @return Signal Identifier
	*/
	virtual std::string GetSignalUUID() = 0;

	/**
	* ISignalHandler::GetStateMachine - Returns the signal state machine instance.
	* @return Name Of State Machine
	*/
	virtual std::string GetStateMachine() = 0;

	/**
	* ISignalHandler::GetString - gets a string value
	* @param[in] sName - Name
	* @return Value
	*/
	virtual std::string GetString(const std::string & sName) = 0;

	/**
	* ISignalHandler::GetUUID - gets a uuid value
	* @param[in] sName - Name
	* @return Value
	*/
	virtual std::string GetUUID(const std::string & sName) = 0;

	/**
	* ISignalHandler::GetDouble - gets a double
	* @param[in] sName - Name
	* @return Value
	*/
	virtual LibMCEnv_double GetDouble(const std::string & sName) = 0;

	/**
	* ISignalHandler::GetInteger - gets an int.
	* @param[in] sName - Name
	* @return Value
	*/
	virtual LibMCEnv_int64 GetInteger(const std::string & sName) = 0;

	/**
	* ISignalHandler::GetBool - gets a bool
	* @param[in] sName - Name
	* @return Value
	*/
	virtual bool GetBool(const std::string & sName) = 0;

	/**
	* ISignalHandler::SetStringResult - returns a string value of the result
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	virtual void SetStringResult(const std::string & sName, const std::string & sValue) = 0;

	/**
	* ISignalHandler::SetUUIDResult - returns a uuid value of the result
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	virtual void SetUUIDResult(const std::string & sName, const std::string & sValue) = 0;

	/**
	* ISignalHandler::SetDoubleResult - returns a string value of the result
	* @param[in] sName - Name
	* @param[in] dValue - Value
	*/
	virtual void SetDoubleResult(const std::string & sName, const LibMCEnv_double dValue) = 0;

	/**
	* ISignalHandler::SetIntegerResult - sets an int.
	* @param[in] sName - Name
	* @param[in] nValue - Value
	*/
	virtual void SetIntegerResult(const std::string & sName, const LibMCEnv_int64 nValue) = 0;

	/**
	* ISignalHandler::SetBoolResult - sets a bool
	* @param[in] sName - Name
	* @param[in] bValue - Value
	*/
	virtual void SetBoolResult(const std::string & sName, const bool bValue) = 0;

};

typedef IBaseSharedPtr<ISignalHandler> PISignalHandler;


/*************************************************************************************************************************
 Class interface for TempStreamWriter 
**************************************************************************************************************************/

class ITempStreamWriter : public virtual IBase {
public:
	/**
	* ITempStreamWriter::GetUUID - Returns the UUID of the stream.
	* @return Returns stream uuid.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* ITempStreamWriter::GetName - Returns the name of the stream.
	* @return Returns stream name.
	*/
	virtual std::string GetName() = 0;

	/**
	* ITempStreamWriter::GetMIMEType - Returns the MIME type of the stream.
	* @return Returns stream MIME Type.
	*/
	virtual std::string GetMIMEType() = 0;

	/**
	* ITempStreamWriter::GetSize - Returns the current size of the stream.
	* @return Current size of the stream.
	*/
	virtual LibMCEnv_uint64 GetSize() = 0;

	/**
	* ITempStreamWriter::GetWritePosition - Returns the current write position of the stream.
	* @return Current write position of the stream.
	*/
	virtual LibMCEnv_uint64 GetWritePosition() = 0;

	/**
	* ITempStreamWriter::Seek - Moves the current write position to a certain address. New position MUST be smaller or equal the stream size.
	* @param[in] nWritePosition - New write position of the stream.
	*/
	virtual void Seek(const LibMCEnv_uint64 nWritePosition) = 0;

	/**
	* ITempStreamWriter::IsFinished - Returns if the stream writing has been finished.
	* @return Returns true if writing is finished.
	*/
	virtual bool IsFinished() = 0;

	/**
	* ITempStreamWriter::WriteData - Writes a data array into the stream. Fails if stream has been finished. Will enlarge stream if writing outside of the current size.
	* @param[in] nDataBufferSize - Number of elements in buffer
	* @param[in] pDataBuffer - Data array to write into the stream
	*/
	virtual void WriteData(const LibMCEnv_uint64 nDataBufferSize, const LibMCEnv_uint8 * pDataBuffer) = 0;

	/**
	* ITempStreamWriter::WriteString - Writes a string into the stream. Fails if stream has been finished. Will enlarge stream if writing outside of the current size.
	* @param[in] sData - String to write into the stream
	*/
	virtual void WriteString(const std::string & sData) = 0;

	/**
	* ITempStreamWriter::WriteLine - Writes a string into the stream and adds a newline character. Fails if stream has been finished. Will enlarge stream if writing outside of the current size.
	* @param[in] sLine - String to write into the stream
	*/
	virtual void WriteLine(const std::string & sLine) = 0;

	/**
	* ITempStreamWriter::Finish - Finishes the stream writing. Fails if stream has been finished already.
	*/
	virtual void Finish() = 0;

};

typedef IBaseSharedPtr<ITempStreamWriter> PITempStreamWriter;


/*************************************************************************************************************************
 Class interface for StreamReader 
**************************************************************************************************************************/

class IStreamReader : public virtual IBase {
public:
	/**
	* IStreamReader::GetUUID - Returns the UUID of the stream.
	* @return Returns stream uuid.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IStreamReader::GetName - Returns the name of the stream.
	* @return Returns stream name.
	*/
	virtual std::string GetName() = 0;

	/**
	* IStreamReader::GetMIMEType - Returns the MIME type of the stream.
	* @return Returns stream MIME Type.
	*/
	virtual std::string GetMIMEType() = 0;

	/**
	* IStreamReader::GetSize - Returns the current size of the stream.
	* @return Current size of the stream.
	*/
	virtual LibMCEnv_uint64 GetSize() = 0;

	/**
	* IStreamReader::GetReadPosition - Returns the current read position of the stream.
	* @return Current read position of the stream.
	*/
	virtual LibMCEnv_uint64 GetReadPosition() = 0;

	/**
	* IStreamReader::Seek - Moves the current read position to a certain address. New position MUST be smaller or equal the stream size.
	* @param[in] nReadPosition - New read position of the stream.
	*/
	virtual void Seek(const LibMCEnv_uint64 nReadPosition) = 0;

	/**
	* IStreamReader::ReadData - Reads a data array from the stream from the current read position. Fails if reading outside of the stream data.
	* @param[in] nSizeToRead - Bytes to read. MUST be larger than 0.
	* @param[in] nDataBufferSize - Number of elements in buffer
	* @param[out] pDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pDataBuffer - uint8 buffer of Return data array. In case of success, will have SizeToRead elements.
	*/
	virtual void ReadData(const LibMCEnv_uint64 nSizeToRead, LibMCEnv_uint64 nDataBufferSize, LibMCEnv_uint64* pDataNeededCount, LibMCEnv_uint8 * pDataBuffer) = 0;

	/**
	* IStreamReader::ReadAllData - Seeks to the beginning of the stream and returns all the stream data.
	* @param[in] nDataBufferSize - Number of elements in buffer
	* @param[out] pDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pDataBuffer - uint8 buffer of Return data array. In case of success, will have stream size elements.
	*/
	virtual void ReadAllData(LibMCEnv_uint64 nDataBufferSize, LibMCEnv_uint64* pDataNeededCount, LibMCEnv_uint8 * pDataBuffer) = 0;

};

typedef IBaseSharedPtr<IStreamReader> PIStreamReader;


/*************************************************************************************************************************
 Class interface for UniformJournalSampling 
**************************************************************************************************************************/

class IUniformJournalSampling : public virtual IBase {
public:
	/**
	* IUniformJournalSampling::GetVariableName - returns the name of the recorded variable.
	* @return Path or name.
	*/
	virtual std::string GetVariableName() = 0;

	/**
	* IUniformJournalSampling::GetNumberOfSamples - Returns the number of samples in the interval.
	* @return Number of samples in the sampling.
	*/
	virtual LibMCEnv_uint32 GetNumberOfSamples() = 0;

	/**
	* IUniformJournalSampling::GetStartTimeStamp - Returns the beginning time stamp of the available data point.
	* @return Start Timestamp of Recording in microseconds.
	*/
	virtual LibMCEnv_uint64 GetStartTimeStamp() = 0;

	/**
	* IUniformJournalSampling::GetEndTimeStamp - Returns the beginning time stamp of the available data point.
	* @return End Timestamp of Recording in microseconds.
	*/
	virtual LibMCEnv_uint64 GetEndTimeStamp() = 0;

	/**
	* IUniformJournalSampling::GetSample - Returns the timestamp and value of the given sample.
	* @param[in] nIndex - Index of the sample. 0-based. MUST be smaller than NumberOfSamples.
	* @param[out] nTimeStamp - TimeStamp of the sample in MicroSeconds.
	* @param[out] dValue - Value of the sample in ms.
	*/
	virtual void GetSample(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 & nTimeStamp, LibMCEnv_double & dValue) = 0;

	/**
	* IUniformJournalSampling::GetAllSamples - Returns all timestamps and values of the sampling.
	* @param[in] nSamplesBufferSize - Number of elements in buffer
	* @param[out] pSamplesNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pSamplesBuffer - TimeStreamEntry buffer of Array of Timestream entries, in increasing order.
	*/
	virtual void GetAllSamples(LibMCEnv_uint64 nSamplesBufferSize, LibMCEnv_uint64* pSamplesNeededCount, LibMCEnv::sTimeStreamEntry * pSamplesBuffer) = 0;

};

typedef IBaseSharedPtr<IUniformJournalSampling> PIUniformJournalSampling;


/*************************************************************************************************************************
 Class interface for JournalVariable 
**************************************************************************************************************************/

class IJournalVariable : public virtual IBase {
public:
	/**
	* IJournalVariable::GetVariableName - returns the name of the recorded variable.
	* @return Path or name.
	*/
	virtual std::string GetVariableName() = 0;

	/**
	* IJournalVariable::GetStartTimeStamp - Returns the beginning time stamp of the available data point.
	* @return Start Timestamp of Recording in microseconds.
	*/
	virtual LibMCEnv_uint64 GetStartTimeStamp() = 0;

	/**
	* IJournalVariable::GetEndTimeStamp - Returns the beginning time stamp of the available data point.
	* @return End Timestamp of Recording in microseconds.
	*/
	virtual LibMCEnv_uint64 GetEndTimeStamp() = 0;

	/**
	* IJournalVariable::ComputeFullAverage - Calculates the average value over the full available time interval.
	* @return Average value of the variable.
	*/
	virtual LibMCEnv_double ComputeFullAverage() = 0;

	/**
	* IJournalVariable::ComputeAverage - Calculates the average value over a time interval. Fails if no data is available in this time interval.
	* @param[in] nStartTimeInMicroSeconds - Start Timestamp of the interval in ms.
	* @param[in] nEndTimeInMicroSeconds - End Timestamp of the interval in ms. MUST be larger than Timestamp.
	* @param[in] bClampInterval - If ClampInterval is false, the Interval MUST be completely contained in the available recording time. If ClampInterval is false, the Interval will be reduced to the available recording time. If there is no overlap of the Interval with the Recording time at all, the call will fail.
	* @return Average value of the variable.
	*/
	virtual LibMCEnv_double ComputeAverage(const LibMCEnv_uint64 nStartTimeInMicroSeconds, const LibMCEnv_uint64 nEndTimeInMicroSeconds, const bool bClampInterval) = 0;

	/**
	* IJournalVariable::ComputeSample - Computes a single sample at a time. Fails if no data is available at this time value.
	* @param[in] nTimeInMicroSeconds - Timestamp to check.
	* @return Value of the variable at the time step.
	*/
	virtual LibMCEnv_double ComputeSample(const LibMCEnv_uint64 nTimeInMicroSeconds) = 0;

	/**
	* IJournalVariable::ComputeUniformAverageSamples - Retrieves sample values for an interval. Interval MUST be inside the available recording time.
	* @param[in] nStartTimeInMicroSeconds - Start Timestamp of the interval in microseconds.
	* @param[in] nIntervalIncrement - Sampling interval distance in microseconds. MUST be larger than 0.
	* @param[in] nNumberOfSamples - Number of samples to record. NumberOfSamples times IntervalIncrement MUST be within the available recording time.
	* @param[in] dMovingAverageDelta - Each sample will be averaged from minus MovingAverageDelta to plus MovingAverageDelta.
	* @param[in] bClampInterval - If ClampInterval is false, each moving average interval MUST be completely contained in the available recording time. If ClampInterval is false, the moving average interval will be reduced to the available recording time. If there is no overlap of the Interval with the Recording time at all, the call will fail.
	* @return Returns an instance with the sampling results.
	*/
	virtual IUniformJournalSampling * ComputeUniformAverageSamples(const LibMCEnv_uint64 nStartTimeInMicroSeconds, const LibMCEnv_uint64 nIntervalIncrement, const LibMCEnv_uint32 nNumberOfSamples, const LibMCEnv_double dMovingAverageDelta, const bool bClampInterval) = 0;

	/**
	* IJournalVariable::ComputeEquidistantSamples - Retrieves a number of equidistant sample values for an interval. Interval MUST be inside the available recording time.
	* @param[in] nStartTimeInMicroSeconds - Start Timestamp of the interval in microseconds.
	* @param[in] nIntervalIncrement - Sampling interval distance in microseconds. MUST be larger than 0.
	* @param[in] nNumberOfSamples - Number of samples to record. The Length of the Interval (StartTimeInMicroSeconds - EndTimeInMicroSeconds) MUST be a multiple of the Number of samples.
	* @return Returns an instance with the sampling results.
	*/
	virtual IUniformJournalSampling * ComputeEquidistantSamples(const LibMCEnv_uint64 nStartTimeInMicroSeconds, const LibMCEnv_uint64 nIntervalIncrement, const LibMCEnv_uint32 nNumberOfSamples) = 0;

	/**
	* IJournalVariable::ReceiveRawTimeStream - Retrieves the raw timestream data of the variable.
	* @param[in] nTimeStreamEntriesBufferSize - Number of elements in buffer
	* @param[out] pTimeStreamEntriesNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pTimeStreamEntriesBuffer - TimeStreamEntry buffer of All change events of the variable in the accessed interval.
	*/
	virtual void ReceiveRawTimeStream(LibMCEnv_uint64 nTimeStreamEntriesBufferSize, LibMCEnv_uint64* pTimeStreamEntriesNeededCount, LibMCEnv::sTimeStreamEntry * pTimeStreamEntriesBuffer) = 0;

};

typedef IBaseSharedPtr<IJournalVariable> PIJournalVariable;


/*************************************************************************************************************************
 Class interface for Alert 
**************************************************************************************************************************/

class IAlert : public virtual IBase {
public:
	/**
	* IAlert::GetUUID - Returns Alert UUID.
	* @return Returns the alert uuid.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IAlert::IsActive - Returns if the alert is actuve.
	* @return Returns if the alert is active.
	*/
	virtual bool IsActive() = 0;

	/**
	* IAlert::GetAlertLevel - Returns Alert Level.
	* @return Returns the alert level.
	*/
	virtual LibMCEnv::eAlertLevel GetAlertLevel() = 0;

	/**
	* IAlert::GetIdentifier - Returns Alert Identifier.
	* @return Returns the alert identifier.
	*/
	virtual std::string GetIdentifier() = 0;

	/**
	* IAlert::GetReadableContextInformation - Returns Alert Custom Information.
	* @return Returns context information for the alert.
	*/
	virtual std::string GetReadableContextInformation() = 0;

	/**
	* IAlert::NeedsAcknowledgement - Returns if the alert needs acknowledgement.
	* @return Flag if alert needs acknowledgement.
	*/
	virtual bool NeedsAcknowledgement() = 0;

	/**
	* IAlert::HasBeenAcknowledged - Returns if the alert is acknowledged.
	* @return Flag if alert is acknowledged.
	*/
	virtual bool HasBeenAcknowledged() = 0;

	/**
	* IAlert::GetAcknowledgementInformation - Returns details about the acknowledgement. Fails if the alert is not acknowledged.
	* @param[out] sUserUUID - User who acknowledged the alert.
	* @param[out] sUserComment - Comment of the acknowledgement.
	* @param[out] sAckTime - Timestamp in ISO8601 UTC format.
	*/
	virtual void GetAcknowledgementInformation(std::string & sUserUUID, std::string & sUserComment, std::string & sAckTime) = 0;

	/**
	* IAlert::GetAcknowledgementTime - Returns the time stamp of the the acknowledgement. Fails if the alert is not acknowledged.
	* @return Timestamp Instance.
	*/
	virtual IDateTime * GetAcknowledgementTime() = 0;

	/**
	* IAlert::AcknowledgeForUser - Acknowledges an alert for a specific user and sets it inactive. 
	* @param[in] sUserUUID - UUID of the user to acknowledge. Fails if user does not exist.
	* @param[in] sUserComment - User comment to store. May be empty.
	*/
	virtual void AcknowledgeForUser(const std::string & sUserUUID, const std::string & sUserComment) = 0;

	/**
	* IAlert::AcknowledgeAlertForCurrentUser - Acknowledges an alert for the current user and sets it inactive. Only works if the Alert Instance was created from a UIEnvironment. StateEnvironments do not have login information.
	* @param[in] sUserComment - User comment to store. May be empty.
	*/
	virtual void AcknowledgeAlertForCurrentUser(const std::string & sUserComment) = 0;

	/**
	* IAlert::DeactivateAlert - Sets an alert inactive. It will not be marked as acknowledged by a certain user.
	*/
	virtual void DeactivateAlert() = 0;

};

typedef IBaseSharedPtr<IAlert> PIAlert;


/*************************************************************************************************************************
 Class interface for AlertIterator 
**************************************************************************************************************************/

class IAlertIterator : public virtual IIterator {
public:
	/**
	* IAlertIterator::GetCurrentAlert - Returns the alert the iterator points at.
	* @return returns the Alert instance.
	*/
	virtual IAlert * GetCurrentAlert() = 0;

};

typedef IBaseSharedPtr<IAlertIterator> PIAlertIterator;


/*************************************************************************************************************************
 Class interface for JournalHandler 
**************************************************************************************************************************/

class IJournalHandler : public virtual IBase {
public:
	/**
	* IJournalHandler::RetrieveJournalVariable - Retrieves the history of a given variable in the system journal.
	* @param[in] sVariableName - Variable name to analyse. Fails if Variable does not exist.
	* @param[in] nTimeDeltaInMicroseconds - How many microseconds the journal should be retrieved in the past.
	* @return Journal Instance.
	*/
	virtual IJournalVariable * RetrieveJournalVariable(const std::string & sVariableName, const LibMCEnv_uint64 nTimeDeltaInMicroseconds) = 0;

	/**
	* IJournalHandler::RetrieveJournalVariableFromTimeInterval - Retrieves the history of a given variable in the system journal for an arbitrary time interval.
	* @param[in] sVariableName - Variable name to analyse. Fails if Variable does not exist.
	* @param[in] nStartTimeInMicroseconds - Start time stamp in microseconds. MUST be smaller than EndTimeInMicroseconds. Fails if larger than recorded time interval.
	* @param[in] nEndTimeInMicroseconds - End time stamp in microseconds. MUST be larger than StartTimeInMicroseconds. Fails if larger than recorded time interval.
	* @return Journal Instance.
	*/
	virtual IJournalVariable * RetrieveJournalVariableFromTimeInterval(const std::string & sVariableName, const LibMCEnv_uint64 nStartTimeInMicroseconds, const LibMCEnv_uint64 nEndTimeInMicroseconds) = 0;

	/**
	* IJournalHandler::GetStartTime - Retrieves the reference start time of the journal.
	* @return DateTime Instance
	*/
	virtual IDateTime * GetStartTime() = 0;

};

typedef IBaseSharedPtr<IJournalHandler> PIJournalHandler;


/*************************************************************************************************************************
 Class interface for UserDetailList 
**************************************************************************************************************************/

class IUserDetailList : public virtual IBase {
public:
	/**
	* IUserDetailList::Count - Result Number of Users in the list.
	* @return Number of users in the list
	*/
	virtual LibMCEnv_uint32 Count() = 0;

	/**
	* IUserDetailList::GetUserProperties - Retrieves all the data of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @param[out] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	virtual void GetUserProperties(const LibMCEnv_uint32 nUserIndex, std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier) = 0;

	/**
	* IUserDetailList::GetUsername - Retrieves the user name of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return User name
	*/
	virtual std::string GetUsername(const LibMCEnv_uint32 nUserIndex) = 0;

	/**
	* IUserDetailList::GetUUID - Retrieves the UUID of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return UUID of the user.
	*/
	virtual std::string GetUUID(const LibMCEnv_uint32 nUserIndex) = 0;

	/**
	* IUserDetailList::GetDescription - Retrieves the description of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return Description of the user.
	*/
	virtual std::string GetDescription(const LibMCEnv_uint32 nUserIndex) = 0;

	/**
	* IUserDetailList::GetRole - Retrieves the role of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return Role of the user.
	*/
	virtual std::string GetRole(const LibMCEnv_uint32 nUserIndex) = 0;

	/**
	* IUserDetailList::GetLanguage - Retrieves the language identifier of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @return Language Identifier of the user.
	*/
	virtual std::string GetLanguage(const LibMCEnv_uint32 nUserIndex) = 0;

};

typedef IBaseSharedPtr<IUserDetailList> PIUserDetailList;


/*************************************************************************************************************************
 Class interface for UserManagementHandler 
**************************************************************************************************************************/

class IUserManagementHandler : public virtual IBase {
public:
	/**
	* IUserManagementHandler::UserExists - Checks if a user exist.
	* @param[in] sUsername - User name
	* @return Flag if users exists
	*/
	virtual bool UserExists(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::UserUUIDExists - Checks if a user uuid exist.
	* @param[in] sUUID - UUID of the user.
	* @return Flag if users exists
	*/
	virtual bool UserUUIDExists(const std::string & sUUID) = 0;

	/**
	* IUserManagementHandler::GetUserProperties - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	virtual void GetUserProperties(const std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier) = 0;

	/**
	* IUserManagementHandler::GetUserPropertiesByUUID - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[out] sUsername - User name
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	virtual void GetUserPropertiesByUUID(const std::string & sUUID, std::string & sUsername, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier) = 0;

	/**
	* IUserManagementHandler::GetUsernameByUUID - Retrieves a users name with a given UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return User name
	*/
	virtual std::string GetUsernameByUUID(const std::string & sUUID) = 0;

	/**
	* IUserManagementHandler::GetUserUUID - Retrieves a users UUID. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return UUID of the user.
	*/
	virtual std::string GetUserUUID(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::GetUserDescription - Retrieves a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Description of the user.
	*/
	virtual std::string GetUserDescription(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::GetUserDescriptionByUUID - Retrieves a users description by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Description of the user.
	*/
	virtual std::string GetUserDescriptionByUUID(const std::string & sUUID) = 0;

	/**
	* IUserManagementHandler::GetUserRole - Retrieves a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Role of the user.
	*/
	virtual std::string GetUserRole(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::GetUserRoleByUUID - Retrieves a users role by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Role of the user.
	*/
	virtual std::string GetUserRoleByUUID(const std::string & sUUID) = 0;

	/**
	* IUserManagementHandler::GetUserLanguage - Retrieves a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Language identifier of the user.
	*/
	virtual std::string GetUserLanguage(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::GetUserLanguageByUUID - Retrieves a users language preference by user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Language identifier of the user.
	*/
	virtual std::string GetUserLanguageByUUID(const std::string & sUUID) = 0;

	/**
	* IUserManagementHandler::CreateUser - Creates a new user. Fails if the user already exists.
	* @param[in] sUsername - User name to create. MUST be alphanumeric and not empty.
	* @param[in] sRole - Role of the new user. MUST NOT be empty.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	* @param[in] sDescription - Description of the new user.
	* @return UUID of the new user.
	*/
	virtual std::string CreateUser(const std::string & sUsername, const std::string & sRole, const std::string & sSalt, const std::string & sHashedPassword, const std::string & sDescription) = 0;

	/**
	* IUserManagementHandler::SetUserLanguage - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	virtual void SetUserLanguage(const std::string & sUsername, const std::string & sLanguageIdentifier) = 0;

	/**
	* IUserManagementHandler::SetUserRole - Updates a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sUserRole - New Role identifier of the user.
	*/
	virtual void SetUserRole(const std::string & sUsername, const std::string & sUserRole) = 0;

	/**
	* IUserManagementHandler::SetUserDescription - Updates a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sDescription - New Description of the user.
	*/
	virtual void SetUserDescription(const std::string & sUsername, const std::string & sDescription) = 0;

	/**
	* IUserManagementHandler::SetUserPassword - Updates a users password. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	virtual void SetUserPassword(const std::string & sUsername, const std::string & sSalt, const std::string & sHashedPassword) = 0;

	/**
	* IUserManagementHandler::SetUserLanguageByUUID - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	virtual void SetUserLanguageByUUID(const std::string & sUUID, const std::string & sLanguageIdentifier) = 0;

	/**
	* IUserManagementHandler::SetUserRoleByUUID - Updates a users role. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sUserRole - New Role identifier of the user.
	*/
	virtual void SetUserRoleByUUID(const std::string & sUUID, const std::string & sUserRole) = 0;

	/**
	* IUserManagementHandler::SetUserDescriptionByUUID - Updates a users description. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sDescription - New Description identifier of the user.
	*/
	virtual void SetUserDescriptionByUUID(const std::string & sUUID, const std::string & sDescription) = 0;

	/**
	* IUserManagementHandler::SetUserPasswordByUUID - Updates a users password. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	virtual void SetUserPasswordByUUID(const std::string & sUUID, const std::string & sSalt, const std::string & sHashedPassword) = 0;

	/**
	* IUserManagementHandler::GetActiveUsers - Returns a list of all users.
	* @return Instance of active users.
	*/
	virtual IUserDetailList * GetActiveUsers() = 0;

};

typedef IBaseSharedPtr<IUserManagementHandler> PIUserManagementHandler;


/*************************************************************************************************************************
 Class interface for StateEnvironment 
**************************************************************************************************************************/

class IStateEnvironment : public virtual IBase {
public:
	/**
	* IStateEnvironment::GetMachineState - Retrieves the machine state
	* @param[in] sMachineInstance - State machine instance name
	* @return Name of current state
	*/
	virtual std::string GetMachineState(const std::string & sMachineInstance) = 0;

	/**
	* IStateEnvironment::GetPreviousState - Retrieves the previous state before this execution. Returns the init state name, if called during the first state during runtime.
	* @return Name of previous state
	*/
	virtual std::string GetPreviousState() = 0;

	/**
	* IStateEnvironment::PrepareSignal - prepares a signal object to trigger later.
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sSignalName - Name Of signal channel.
	* @return Signal trigger object.
	*/
	virtual ISignalTrigger * PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName) = 0;

	/**
	* IStateEnvironment::WaitForSignal - Waits for a signal for a certain amount of time.
	* @param[in] sSignalName - Name Of Signal
	* @param[in] nTimeOut - Timeout in Milliseconds. 0 for Immediate return.
	* @param[out] pHandlerInstance - Signal object. If Success is false, the Signal Handler Object will be null.
	* @return Signal has been triggered
	*/
	virtual bool WaitForSignal(const std::string & sSignalName, const LibMCEnv_uint32 nTimeOut, ISignalHandler*& pHandlerInstance) = 0;

	/**
	* IStateEnvironment::GetUnhandledSignal - Retrieves an unhandled signal By signal type name.
	* @param[in] sSignalTypeName - Name Of Signal to be returned
	* @return Signal object. If no signal has been found the signal handler object will be null.
	*/
	virtual ISignalHandler * GetUnhandledSignal(const std::string & sSignalTypeName) = 0;

	/**
	* IStateEnvironment::GetUnhandledSignalByUUID - retrieves an unhandled signal from the current state machine by UUID.
	* @param[in] sUUID - Name
	* @param[in] bMustExist - The call fails if MustExist is true and not signal with UUID does exist or a signal with UUID has been handled already.
	* @return Signal handler instance. Returns null, if signal does not exist.
	*/
	virtual ISignalHandler * GetUnhandledSignalByUUID(const std::string & sUUID, const bool bMustExist) = 0;

	/**
	* IStateEnvironment::GetDriverLibrary - Returns the driver type and library lookup for a specific registered driver.
	* @param[in] sDriverName - Name identifier of the driver.
	* @param[out] sDriverType - returns type identifier of the driver.
	* @param[out] dDriverLookup - GetProcAddress Handle of the driver.
	*/
	virtual void GetDriverLibrary(const std::string & sDriverName, std::string & sDriverType, LibMCEnv_pvoid & pDriverLookup) = 0;

	/**
	* IStateEnvironment::CreateDriverAccess - Accesses and locks a driver for the execution of the current state.
	* @param[in] sDriverName - Name identifier of the driver.
	* @param[out] dDriverHandle - Handle of the driver.
	*/
	virtual void CreateDriverAccess(const std::string & sDriverName, LibMCEnv_pvoid & pDriverHandle) = 0;

	/**
	* IStateEnvironment::HasBuildJob - Returns if a build object exists. Fails if BuildUUID is not a valid UUID string.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Returns true if build exists
	*/
	virtual bool HasBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IStateEnvironment::GetBuildJob - Returns a instance of a build object. Fails if build uuid does not exist.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	virtual IBuild * GetBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IStateEnvironment::UnloadAllToolpathes - unloads all toolpath in memory to clean up
	*/
	virtual void UnloadAllToolpathes() = 0;

	/**
	* IStateEnvironment::SetNextState - sets the next state
	* @param[in] sStateName - Name of next state
	*/
	virtual void SetNextState(const std::string & sStateName) = 0;

	/**
	* IStateEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	virtual void LogMessage(const std::string & sLogString) = 0;

	/**
	* IStateEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	virtual void LogWarning(const std::string & sLogString) = 0;

	/**
	* IStateEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	virtual void LogInfo(const std::string & sLogString) = 0;

	/**
	* IStateEnvironment::Sleep - Puts the current instance to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	virtual void Sleep(const LibMCEnv_uint32 nDelay) = 0;

	/**
	* IStateEnvironment::CheckForTermination - checks environment for termination signal. MUST be called frequently in longer-running operations.
	* @return Returns if termination shall appear
	*/
	virtual bool CheckForTermination() = 0;

	/**
	* IStateEnvironment::StoreSignal - DEPRECIATED: stores a signal handler in the current state machine
	* @param[in] sName - Name
	* @param[in] pHandler - Signal handler to store.
	*/
	virtual void StoreSignal(const std::string & sName, ISignalHandler* pHandler) = 0;

	/**
	* IStateEnvironment::RetrieveSignal - DEPRECIATED: retrieves a signal handler from the current state machine. Fails if value has not been stored before or signal has been already handled.
	* @param[in] sName - Name
	* @return Signal handler instance.
	*/
	virtual ISignalHandler * RetrieveSignal(const std::string & sName) = 0;

	/**
	* IStateEnvironment::ClearStoredValue - DEPRECIATED: deletes a value from the data store.
	* @param[in] sName - Name
	*/
	virtual void ClearStoredValue(const std::string & sName) = 0;

	/**
	* IStateEnvironment::SetStringParameter - sets a string parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IStateEnvironment::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IStateEnvironment::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	virtual void SetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_double dValue) = 0;

	/**
	* IStateEnvironment::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	virtual void SetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IStateEnvironment::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	virtual void SetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName, const bool bValue) = 0;

	/**
	* IStateEnvironment::GetStringParameter - returns a string parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual std::string GetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::GetUUIDParameter - returns a uuid parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual std::string GetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::GetDoubleParameter - returns a double parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual LibMCEnv_double GetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::GetIntegerParameter - returns an int parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual LibMCEnv_int64 GetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::GetBoolParameter - returns a bool parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual bool GetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::LoadResourceData - loads a plugin resource file into memory.
	* @param[in] sResourceName - Name of the resource.
	* @param[in] nResourceDataBufferSize - Number of elements in buffer
	* @param[out] pResourceDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pResourceDataBuffer - uint8 buffer of Resource Data Buffer.
	*/
	virtual void LoadResourceData(const std::string & sResourceName, LibMCEnv_uint64 nResourceDataBufferSize, LibMCEnv_uint64* pResourceDataNeededCount, LibMCEnv_uint8 * pResourceDataBuffer) = 0;

	/**
	* IStateEnvironment::LoadResourceString - loads a plugin resource file into a string. Fails if content is not a valid UTF8 string.
	* @param[in] sResourceName - Name of the resource.
	* @return Resource Data String.
	*/
	virtual std::string LoadResourceString(const std::string & sResourceName) = 0;

	/**
	* IStateEnvironment::CreateEmptyImage - creates an empty image object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use.
	* @return Empty image instance.
	*/
	virtual IImageData * CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IStateEnvironment::LoadPNGImage - creates an image object from a PNG data stream.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[in] pPNGDataBuffer - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image instance containing the PNG image.
	*/
	virtual IImageData * LoadPNGImage(const LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IStateEnvironment::CreateDiscreteField2D - Creates an empty discrete field.
	* @param[in] nPixelCountX - Pixel count in X. MUST be positive.
	* @param[in] nPixelCountY - Pixel count in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @param[in] dDefaultValue - Default value of the field.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IStateEnvironment::CreateDiscreteField2DFromImage - Creates a discrete field from the greyscale values of an image. RGB colors in the image will be averaged to obtain a greyscale color.
	* @param[in] pImageDataInstance - Image instance containing the pixel data.
	* @param[in] dBlackValue - Value that the minimum color (black) shall be mapped to.
	* @param[in] dWhiteValue - Value that the maximum color (white) shall be mapped to.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2DFromImage(IImageData* pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY) = 0;

	/**
	* IStateEnvironment::GetGlobalTimerInMilliseconds - Returns the global timer in milliseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetGlobalTimerInMilliseconds() = 0;

	/**
	* IStateEnvironment::GetGlobalTimerInMicroseconds - Returns the global timer in microseconds.
	* @return Timer value in Microseconds
	*/
	virtual LibMCEnv_uint64 GetGlobalTimerInMicroseconds() = 0;

	/**
	* IStateEnvironment::GetStartTimeOfStateInMilliseconds - Returns the global start time of the current state in milliseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetStartTimeOfStateInMilliseconds() = 0;

	/**
	* IStateEnvironment::GetStartTimeOfStateInMicroseconds - Returns the global start time of the current state in microseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetStartTimeOfStateInMicroseconds() = 0;

	/**
	* IStateEnvironment::GetEndTimeOfPreviousStateInMicroseconds - Returns the global finish time of the previous state in microseconds.
	* @return Timer value in Microseconds
	*/
	virtual LibMCEnv_uint64 GetEndTimeOfPreviousStateInMicroseconds() = 0;

	/**
	* IStateEnvironment::GetEndTimeOfPreviousStateInMilliseconds - Returns the global finish time of the previous state in milliseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetEndTimeOfPreviousStateInMilliseconds() = 0;

	/**
	* IStateEnvironment::GetElapsedTimeInStateInMilliseconds - Returns the global finish time of the previous state in milliseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetElapsedTimeInStateInMilliseconds() = 0;

	/**
	* IStateEnvironment::GetElapsedTimeInStateInMicroseconds - Returns the global finish time of the previous state in microseconds.
	* @return Timer value in Microseconds
	*/
	virtual LibMCEnv_uint64 GetElapsedTimeInStateInMicroseconds() = 0;

	/**
	* IStateEnvironment::GetTestEnvironment - Returns a test environment instance.
	* @return Test Environment Instance
	*/
	virtual ITestEnvironment * GetTestEnvironment() = 0;

	/**
	* IStateEnvironment::CreateXMLDocument - creates an empty XML Document.
	* @param[in] sRootNodeName - Name of the root node. MUST be a valid XML Node Name string.
	* @param[in] sDefaultNamespace - Default namespace of the document. MUST be a valid XML namespace string.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace) = 0;

	/**
	* IStateEnvironment::ParseXMLString - parses an XML String and returns an XML Document instance. Throws an error if XML is malformatted.
	* @param[in] sXMLString - XML String.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLString(const std::string & sXMLString) = 0;

	/**
	* IStateEnvironment::ParseXMLData - parses a XML stored in a byte array and returns an XML Document instance. . Throws an error if XML is malformatted.
	* @param[in] nXMLDataBufferSize - Number of elements in buffer
	* @param[in] pXMLDataBuffer - XML Binary data.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLData(const LibMCEnv_uint64 nXMLDataBufferSize, const LibMCEnv_uint8 * pXMLDataBuffer) = 0;

	/**
	* IStateEnvironment::CreateDataTable - creates an empty data table.
	* @return Data Table Instance.
	*/
	virtual IDataTable * CreateDataTable() = 0;

	/**
	* IStateEnvironment::CheckUserPermission - Returns if the a user has a certain permission. Fails if user or permission is not known to the system.
	* @param[in] sUserLogin - Login of user to check
	* @param[in] sPermissionIdentifier - Permission identifier
	* @return Returns if the user has permission
	*/
	virtual bool CheckUserPermission(const std::string & sUserLogin, const std::string & sPermissionIdentifier) = 0;

	/**
	* IStateEnvironment::CreateUserManagement - Returns a user management handler instance.
	* @return Returns a user management handler.
	*/
	virtual IUserManagementHandler * CreateUserManagement() = 0;

	/**
	* IStateEnvironment::GetCurrentJournal - Returns the journal instance of the current session.
	* @return Journal instance.
	*/
	virtual IJournalHandler * GetCurrentJournal() = 0;

	/**
	* IStateEnvironment::RegisterMeshFrom3MFResource - Loads a from a 3MF Resource File. If 3MF contains multiple objects, it will merge them into one mesh.
	* @param[in] sResourceName - Resource name to load.
	* @return Mesh Object instance.
	*/
	virtual IMeshObject * RegisterMeshFrom3MFResource(const std::string & sResourceName) = 0;

	/**
	* IStateEnvironment::MeshIsRegistered - Checks if a mesh uuid is registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Flag is registered.
	*/
	virtual bool MeshIsRegistered(const std::string & sMeshUUID) = 0;

	/**
	* IStateEnvironment::FindRegisteredMesh - Finds a registered mesh by its UUID. Fails if mesh UUID is not registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Mesh Object instance.
	*/
	virtual IMeshObject * FindRegisteredMesh(const std::string & sMeshUUID) = 0;

	/**
	* IStateEnvironment::CreateDataSeries - Creates a new empty data series object.
	* @param[in] sName - Name to use for this data series. MUST NOT be an empty string.
	* @return Data series instance.
	*/
	virtual IDataSeries * CreateDataSeries(const std::string & sName) = 0;

	/**
	* IStateEnvironment::HasDataSeries - Checks if a data series exist.
	* @param[in] sDataSeriesUUID - UUID to find.
	* @return returns true if series exists.
	*/
	virtual bool HasDataSeries(const std::string & sDataSeriesUUID) = 0;

	/**
	* IStateEnvironment::FindDataSeries - Finds a data series. Fails if data series does not exist.
	* @param[in] sDataSeriesUUID - UUID to find.
	* @return Data series instance.
	*/
	virtual IDataSeries * FindDataSeries(const std::string & sDataSeriesUUID) = 0;

	/**
	* IStateEnvironment::ReleaseDataSeries - Releases the memory of a data series. Fails if data series does not exist.
	* @param[in] sDataSeriesUUID - UUID to release.
	*/
	virtual void ReleaseDataSeries(const std::string & sDataSeriesUUID) = 0;

	/**
	* IStateEnvironment::CreateAlert - creates a new alert
	* @param[in] sIdentifier - Alert type identifier. Call fails if identifier is not registered.
	* @param[in] sReadableContextInformation - Context information string that can be displayed to the user.
	* @param[in] bAutomaticLogEntry - If this flag is set to true, an automatic message will be posted to the system log.
	* @return Alert instance.
	*/
	virtual IAlert * CreateAlert(const std::string & sIdentifier, const std::string & sReadableContextInformation, const bool bAutomaticLogEntry) = 0;

	/**
	* IStateEnvironment::FindAlert - finds an alert by UUID. Fails if alert does not exist.
	* @param[in] sUUID - UUID of the alert to return.
	* @return Alert instance.
	*/
	virtual IAlert * FindAlert(const std::string & sUUID) = 0;

	/**
	* IStateEnvironment::AlertExists - Checks if a certain alert exists.
	* @param[in] sUUID - UUID of the alert to return.
	* @return True if alert exists.
	*/
	virtual bool AlertExists(const std::string & sUUID) = 0;

	/**
	* IStateEnvironment::RetrieveAlerts - Retrieves all or all active alerts.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	virtual IAlertIterator * RetrieveAlerts(const bool bOnlyActive) = 0;

	/**
	* IStateEnvironment::RetrieveAlertsByType - Retrieves alerts of a certain type identifier.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	virtual IAlertIterator * RetrieveAlertsByType(const std::string & sIdentifier, const bool bOnlyActive) = 0;

	/**
	* IStateEnvironment::HasAlertOfType - Checks, if an alert of a certain type identifier exists.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be taken into account.
	* @return Flag, if the alert exists.
	*/
	virtual bool HasAlertOfType(const std::string & sIdentifier, const bool bOnlyActive) = 0;

	/**
	* IStateEnvironment::CreateCryptoContext - Creates a crypto context.
	* @return Cryptographic context instance
	*/
	virtual ICryptoContext * CreateCryptoContext() = 0;

	/**
	* IStateEnvironment::CreateTemporaryStream - Creates a new writer to store temporary data. This data will be attached to the current journal.
	* @param[in] sName - Name of the storage stream.
	* @param[in] sMIMEType - Mime type of the data.
	* @return Temp stream writer instance
	*/
	virtual ITempStreamWriter * CreateTemporaryStream(const std::string & sName, const std::string & sMIMEType) = 0;

	/**
	* IStateEnvironment::FindStream - Finds a stream in the storage system.
	* @param[in] sUUID - UUID of the storage stream.
	* @param[in] bMustExist - If true, the call fails if the stream does not exist.
	* @return Stream Instance. Will return null if not found and MustExists is false.
	*/
	virtual IStreamReader * FindStream(const std::string & sUUID, const bool bMustExist) = 0;

};

typedef IBaseSharedPtr<IStateEnvironment> PIStateEnvironment;


/*************************************************************************************************************************
 Class interface for UIItem 
**************************************************************************************************************************/

class IUIItem : public virtual IBase {
public:
	/**
	* IUIItem::GetName - Returns the name of the user interface item. MUST be unique within its siblings.
	* @return Returns the name.
	*/
	virtual std::string GetName() = 0;

	/**
	* IUIItem::GetPath - Returns the full path of the user interface item. MUST be unique.
	* @return Returns the path.
	*/
	virtual std::string GetPath() = 0;

	/**
	* IUIItem::GetUUID - Returns the UUID of the time stream chart object.
	* @return Returns uuid.
	*/
	virtual std::string GetUUID() = 0;

};

typedef IBaseSharedPtr<IUIItem> PIUIItem;


/*************************************************************************************************************************
 Class interface for UIEnvironment 
**************************************************************************************************************************/

class IUIEnvironment : public virtual IBase {
public:
	/**
	* IUIEnvironment::ActivateModalDialog - activates a modal dialog on the client.
	* @param[in] sDialogName - Name of the dialog to activate.
	*/
	virtual void ActivateModalDialog(const std::string & sDialogName) = 0;

	/**
	* IUIEnvironment::CloseModalDialog - closes the active modal dialog on the client.
	*/
	virtual void CloseModalDialog() = 0;

	/**
	* IUIEnvironment::ActivatePage - changes the current page on the client.
	* @param[in] sPageName - Name of the page to activate.
	*/
	virtual void ActivatePage(const std::string & sPageName) = 0;

	/**
	* IUIEnvironment::LogOut - Logs out the client session.
	*/
	virtual void LogOut() = 0;

	/**
	* IUIEnvironment::ShowHint - Shows a hint message in the user interface.
	* @param[in] sHint - Hint to show.
	* @param[in] nTimeoutInMS - How many milliseconds the snackbar should be shown.
	*/
	virtual void ShowHint(const std::string & sHint, const LibMCEnv_uint32 nTimeoutInMS) = 0;

	/**
	* IUIEnvironment::ShowHintColored - Shows a hint message in the user interface in a certain color.
	* @param[in] sHint - Hint to show.
	* @param[in] nTimeoutInMS - How many milliseconds the snackbar should be shown.
	* @param[in] Color - Background color of hint.
	* @param[in] FontColor - Font color of hint.
	*/
	virtual void ShowHintColored(const std::string & sHint, const LibMCEnv_uint32 nTimeoutInMS, const LibMCEnv::sColorRGB Color, const LibMCEnv::sColorRGB FontColor) = 0;

	/**
	* IUIEnvironment::HideHint - Hides hint if any is displayed.
	*/
	virtual void HideHint() = 0;

	/**
	* IUIEnvironment::StartStreamDownload - Starts a stream download on the client. Fails if stream does not exist.
	* @param[in] sUUID - Stream UUID.
	* @param[in] sFilename - Filename on disk. Fails if empty string.
	*/
	virtual void StartStreamDownload(const std::string & sUUID, const std::string & sFilename) = 0;

	/**
	* IUIEnvironment::ShowMessageDlg - Shows a message dialog in the user interface.
	* @param[in] sCaption - Caption of the dialog
	* @param[in] sTitle - Title of the dialog
	* @param[in] eDialogType - Which dialog type shall be shown.
	* @param[in] sYesEvent - Event to be called when clicked yes or ok.
	* @param[in] sNoEvent - Event to be called when clicked no.
	* @param[in] sCancelEvent - Event to be called when dialog is closed or cancel is pressed.
	* @return Dialog UUID. Will be set as sender for triggered events.
	*/
	virtual std::string ShowMessageDlg(const std::string & sCaption, const std::string & sTitle, const LibMCEnv::eMessageDialogType eDialogType, const std::string & sYesEvent, const std::string & sNoEvent, const std::string & sCancelEvent) = 0;

	/**
	* IUIEnvironment::RetrieveEventSender - returns path of the UI control that triggered the event.
	* @return Path of the sender element.
	*/
	virtual std::string RetrieveEventSender() = 0;

	/**
	* IUIEnvironment::RetrieveEventSenderPage - returns name of the page of the UI control that triggered the event.
	* @return Page of the sender element.
	*/
	virtual std::string RetrieveEventSenderPage() = 0;

	/**
	* IUIEnvironment::RetrieveEventSenderUUID - returns uuid of the UI control that triggered the event.
	* @return Name of the sender uuid.
	*/
	virtual std::string RetrieveEventSenderUUID() = 0;

	/**
	* IUIEnvironment::PrepareSignal - prepares a signal object to trigger later.
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sSignalName - Name Of signal channel.
	* @return Signal trigger object.
	*/
	virtual ISignalTrigger * PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName) = 0;

	/**
	* IUIEnvironment::GetMachineState - Retrieves the machine state
	* @param[in] sMachineInstance - State machine instance name
	* @return Name of current state
	*/
	virtual std::string GetMachineState(const std::string & sMachineInstance) = 0;

	/**
	* IUIEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	virtual void LogMessage(const std::string & sLogString) = 0;

	/**
	* IUIEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	virtual void LogWarning(const std::string & sLogString) = 0;

	/**
	* IUIEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	virtual void LogInfo(const std::string & sLogString) = 0;

	/**
	* IUIEnvironment::GetMachineParameter - returns a string parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual std::string GetMachineParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetMachineParameterAsUUID - returns a uuid parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual std::string GetMachineParameterAsUUID(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetMachineParameterAsDouble - returns a double parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual LibMCEnv_double GetMachineParameterAsDouble(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetMachineParameterAsInteger - returns an int parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual LibMCEnv_int64 GetMachineParameterAsInteger(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetMachineParameterAsBool - returns a bool parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual bool GetMachineParameterAsBool(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetUIProperty - returns a string property of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual std::string GetUIProperty(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::GetUIPropertyAsUUID - returns a uuid variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual std::string GetUIPropertyAsUUID(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::GetUIPropertyAsDouble - returns a double variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual LibMCEnv_double GetUIPropertyAsDouble(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::GetUIPropertyAsInteger - returns a integer variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual LibMCEnv_int64 GetUIPropertyAsInteger(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::GetUIPropertyAsBool - returns a integer variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual bool GetUIPropertyAsBool(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::SetUIProperty - sets a string property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] sValue - New property Value
	*/
	virtual void SetUIProperty(const std::string & sElementPath, const std::string & sPropertyName, const std::string & sValue) = 0;

	/**
	* IUIEnvironment::SetUIPropertyAsUUID - sets a uuid property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] sValue - New property Value
	*/
	virtual void SetUIPropertyAsUUID(const std::string & sElementPath, const std::string & sPropertyName, const std::string & sValue) = 0;

	/**
	* IUIEnvironment::SetUIPropertyAsDouble - sets a double property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] dValue - New property Value
	*/
	virtual void SetUIPropertyAsDouble(const std::string & sElementPath, const std::string & sPropertyName, const LibMCEnv_double dValue) = 0;

	/**
	* IUIEnvironment::SetUIPropertyAsInteger - sets a integer property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] nValue - New property Value
	*/
	virtual void SetUIPropertyAsInteger(const std::string & sElementPath, const std::string & sPropertyName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IUIEnvironment::SetUIPropertyAsBool - sets a bool property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] bValue - New property Value
	*/
	virtual void SetUIPropertyAsBool(const std::string & sElementPath, const std::string & sPropertyName, const bool bValue) = 0;

	/**
	* IUIEnvironment::CreateEmptyImage - creates an empty image object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use.
	* @return Empty image instance.
	*/
	virtual IImageData * CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IUIEnvironment::LoadPNGImage - creates an image object from a PNG data stream.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[in] pPNGDataBuffer - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image instance containing the PNG image.
	*/
	virtual IImageData * LoadPNGImage(const LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IUIEnvironment::GetGlobalTimerInMilliseconds - Returns the global timer in milliseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetGlobalTimerInMilliseconds() = 0;

	/**
	* IUIEnvironment::GetGlobalTimerInMicroseconds - Returns the global timer in microseconds.
	* @return Timer value in Microseconds
	*/
	virtual LibMCEnv_uint64 GetGlobalTimerInMicroseconds() = 0;

	/**
	* IUIEnvironment::GetTestEnvironment - Returns a test environment instance.
	* @return Test Environment Instance
	*/
	virtual ITestEnvironment * GetTestEnvironment() = 0;

	/**
	* IUIEnvironment::CreateXMLDocument - creates an empty XML Document.
	* @param[in] sRootNodeName - Name of the root node. MUST be a valid XML Node Name string.
	* @param[in] sDefaultNamespace - Default namespace of the document. MUST be a valid XML namespace string.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace) = 0;

	/**
	* IUIEnvironment::ParseXMLString - parses an XML String and returns an XML Document instance. Throws an error if XML is malformatted.
	* @param[in] sXMLString - XML String.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLString(const std::string & sXMLString) = 0;

	/**
	* IUIEnvironment::ParseXMLData - parses a XML stored in a byte array and returns an XML Document instance. . Throws an error if XML is malformatted.
	* @param[in] nXMLDataBufferSize - Number of elements in buffer
	* @param[in] pXMLDataBuffer - XML Binary data.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLData(const LibMCEnv_uint64 nXMLDataBufferSize, const LibMCEnv_uint8 * pXMLDataBuffer) = 0;

	/**
	* IUIEnvironment::CreateDataTable - creates an empty data table.
	* @return Data Table Instance.
	*/
	virtual IDataTable * CreateDataTable() = 0;

	/**
	* IUIEnvironment::HasBuildJob - Returns if a build object exists. Fails if BuildUUID is not a valid UUID string.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Returns true if build exists
	*/
	virtual bool HasBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IUIEnvironment::GetBuildJob - Returns a instance of a build object. Fails if build uuid does not exist.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	virtual IBuild * GetBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IUIEnvironment::CreateDiscreteField2D - Creates an empty discrete field.
	* @param[in] nPixelCountX - Pixel count in X. MUST be positive.
	* @param[in] nPixelCountY - Pixel count in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @param[in] dDefaultValue - Default value of the field.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IUIEnvironment::CreateDiscreteField2DFromImage - Creates a discrete field from the greyscale values of an image. RGB colors in the image will be averaged to obtain a greyscale color.
	* @param[in] pImageDataInstance - Image instance containing the pixel data.
	* @param[in] dBlackValue - Value that the minimum color (black) shall be mapped to.
	* @param[in] dWhiteValue - Value that the maximum color (white) shall be mapped to.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2DFromImage(IImageData* pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY) = 0;

	/**
	* IUIEnvironment::CheckPermission - Returns if the current user has a certain permission. Fails if permission is not known to the system.
	* @param[in] sPermissionIdentifier - Permission identifier
	* @return Returns if the user has permission
	*/
	virtual bool CheckPermission(const std::string & sPermissionIdentifier) = 0;

	/**
	* IUIEnvironment::GetCurrentUserLogin - Returns the current user login name.
	* @return Returns the current users login name.
	*/
	virtual std::string GetCurrentUserLogin() = 0;

	/**
	* IUIEnvironment::GetCurrentUserDescription - Returns the current user description.
	* @return Returns the current users description.
	*/
	virtual std::string GetCurrentUserDescription() = 0;

	/**
	* IUIEnvironment::GetCurrentUserRole - Returns the current user role identifier.
	* @return Returns the current users role identifier.
	*/
	virtual std::string GetCurrentUserRole() = 0;

	/**
	* IUIEnvironment::GetCurrentUserLanguage - Returns the current users language identifier.
	* @return Returns the current users language identifier.
	*/
	virtual std::string GetCurrentUserLanguage() = 0;

	/**
	* IUIEnvironment::GetCurrentUserUUID - Returns the current user UUID.
	* @return Returns the current user UUID.
	*/
	virtual std::string GetCurrentUserUUID() = 0;

	/**
	* IUIEnvironment::CreateUserManagement - Returns a user management handler instance.
	* @return Returns a user management handler.
	*/
	virtual IUserManagementHandler * CreateUserManagement() = 0;

	/**
	* IUIEnvironment::GetCurrentJournal - Returns the journal instance of the current session.
	* @return Journal instance.
	*/
	virtual IJournalHandler * GetCurrentJournal() = 0;

	/**
	* IUIEnvironment::RegisterMeshFrom3MFResource - Loads a mesh from a 3MF Resource File. Fails if mesh UUID is already registered.
	* @param[in] sResourceName - Resource name to load.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Mesh Object instance.
	*/
	virtual IMeshObject * RegisterMeshFrom3MFResource(const std::string & sResourceName, const std::string & sMeshUUID) = 0;

	/**
	* IUIEnvironment::MeshIsRegistered - Checks if a mesh uuid is registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Flag is registered.
	*/
	virtual bool MeshIsRegistered(const std::string & sMeshUUID) = 0;

	/**
	* IUIEnvironment::FindRegisteredMesh - Finds a registered mesh by its UUID. Fails if mesh UUID is not registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Mesh Object instance.
	*/
	virtual IMeshObject * FindRegisteredMesh(const std::string & sMeshUUID) = 0;

	/**
	* IUIEnvironment::CreateDataSeries - Creates a new empty data series object.
	* @param[in] sName - Name to use for this data series. MUST NOT be an empty string.
	* @param[in] bBoundToLogin - If true, the data series is tied to the current user login session. If false, the data series will persist until explicitely released. This can be dangerous for the overall machine stability.
	* @return Data series instance.
	*/
	virtual IDataSeries * CreateDataSeries(const std::string & sName, const bool bBoundToLogin) = 0;

	/**
	* IUIEnvironment::HasDataSeries - Checks if a data series exist.
	* @param[in] sDataSeriesUUID - UUID to find.
	* @return returns true if series exists.
	*/
	virtual bool HasDataSeries(const std::string & sDataSeriesUUID) = 0;

	/**
	* IUIEnvironment::FindDataSeries - Finds a data series. Fails if data series does not exist.
	* @param[in] sDataSeriesUUID - UUID to find.
	* @return Data series instance.
	*/
	virtual IDataSeries * FindDataSeries(const std::string & sDataSeriesUUID) = 0;

	/**
	* IUIEnvironment::ReleaseDataSeries - Releases the memory of a data series. Fails if data series does not exist.
	* @param[in] sDataSeriesUUID - UUID to release.
	*/
	virtual void ReleaseDataSeries(const std::string & sDataSeriesUUID) = 0;

	/**
	* IUIEnvironment::CreateAlert - creates a new alert
	* @param[in] sIdentifier - Alert type identifier. Call fails if identifier is not registered.
	* @param[in] sReadableContextInformation - Context information string that can be displayed to the user.
	* @param[in] bAutomaticLogEntry - If this flag is set to true, an automatic message will be posted to the system log.
	* @return Alert instance.
	*/
	virtual IAlert * CreateAlert(const std::string & sIdentifier, const std::string & sReadableContextInformation, const bool bAutomaticLogEntry) = 0;

	/**
	* IUIEnvironment::FindAlert - finds an alert by UUID. Fails if alert does not exist.
	* @param[in] sUUID - UUID of the alert to return.
	* @return Alert instance.
	*/
	virtual IAlert * FindAlert(const std::string & sUUID) = 0;

	/**
	* IUIEnvironment::AlertExists - Checks if a certain alert exists.
	* @param[in] sUUID - UUID of the alert to return.
	* @return True if alert exists.
	*/
	virtual bool AlertExists(const std::string & sUUID) = 0;

	/**
	* IUIEnvironment::RetrieveAlerts - Retrieves all or all active alerts.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	virtual IAlertIterator * RetrieveAlerts(const bool bOnlyActive) = 0;

	/**
	* IUIEnvironment::RetrieveAlertsByType - Retrieves alerts of a certain type identifier.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	virtual IAlertIterator * RetrieveAlertsByType(const std::string & sIdentifier, const bool bOnlyActive) = 0;

	/**
	* IUIEnvironment::HasAlertOfType - Checks, if an alert of a certain type identifier exists.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be taken into account.
	* @return Flag, if the alert exists.
	*/
	virtual bool HasAlertOfType(const std::string & sIdentifier, const bool bOnlyActive) = 0;

	/**
	* IUIEnvironment::CreateCryptoContext - Creates a crypto context.
	* @return Cryptographic context instance
	*/
	virtual ICryptoContext * CreateCryptoContext() = 0;

	/**
	* IUIEnvironment::CreateTemporaryStream - Creates a new writer to store temporary data. This data will be attached to the current journal.
	* @param[in] sName - Name of the storage stream.
	* @param[in] sMIMEType - Mime type of the data.
	* @return Temp stream writer instance
	*/
	virtual ITempStreamWriter * CreateTemporaryStream(const std::string & sName, const std::string & sMIMEType) = 0;

	/**
	* IUIEnvironment::FindStream - Finds a stream in the storage system.
	* @param[in] sUUID - UUID of the storage stream.
	* @param[in] bMustExist - If true, the call fails if the stream does not exist.
	* @return Stream Instance. Will return null if not found and MustExists is false.
	*/
	virtual IStreamReader * FindStream(const std::string & sUUID, const bool bMustExist) = 0;

};

typedef IBaseSharedPtr<IUIEnvironment> PIUIEnvironment;


/*************************************************************************************************************************
 Global functions declarations
**************************************************************************************************************************/
class CWrapper {
public:
	/**
	* Ilibmcenv::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	static void GetVersion(LibMCEnv_uint32 & nMajor, LibMCEnv_uint32 & nMinor, LibMCEnv_uint32 & nMicro);

	/**
	* Ilibmcenv::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	static bool GetLastError(IBase* pInstance, std::string & sErrorMessage);

	/**
	* Ilibmcenv::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void ReleaseInstance(IBase* pInstance);

	/**
	* Ilibmcenv::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void AcquireInstance(IBase* pInstance);

};

LibMCEnvResult LibMCEnv_GetProcAddress (const char * pProcName, void ** ppProcAddress);

} // namespace Impl
} // namespace LibMCEnv

#endif // __LIBMCENV_CPPINTERFACES
