/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ header file in order to allow easy
development of MC Environment Interface. The implementer of MC Environment Interface needs to
derive concrete classes from the abstract classes in this header.

Interface version: 1.0.0

*/


#ifndef __LIBMCENV_CPPINTERFACES
#define __LIBMCENV_CPPINTERFACES

#include <string>
#include <memory>

#include "libmcenv_types.hpp"



namespace LibMCEnv {
namespace Impl {

/**
 Forward declarations of class interfaces
*/
class IBase;
class IIterator;
class ITestEnvironment;
class IPNGImageStoreOptions;
class IPNGImageData;
class IImageData;
class IDiscreteFieldData2DStoreOptions;
class IDiscreteFieldData2D;
class IMeshObject;
class IToolpathPart;
class IToolpathLayer;
class IToolpathAccessor;
class IBuild;
class IWorkingFileExecution;
class IWorkingFile;
class IWorkingFileIterator;
class IWorkingDirectory;
class IXMLDocumentAttribute;
class IXMLDocumentNode;
class IXMLDocumentNodes;
class IXMLDocument;
class ITCPIPPacket;
class ITCPIPConnection;
class IModbusTCPDigitalIOStatus;
class IModbusTCPRegisterStatus;
class IModbusTCPConnection;
class IDriverStatusUpdateSession;
class IDriverEnvironment;
class ISignalTrigger;
class ISignalHandler;
class IUniformJournalSampling;
class IJournalVariable;
class IJournalHandler;
class IUserManagementHandler;
class IStateEnvironment;
class IUIEnvironment;



/*************************************************************************************************************************
 Parameter Cache definitions
**************************************************************************************************************************/

class ParameterCache {
	public:
		virtual ~ParameterCache() {}
};

template <class T1> class ParameterCache_1 : public ParameterCache {
	private:
		T1 m_param1;
	public:
		ParameterCache_1 (const T1 & param1)
			: m_param1 (param1)
		{
		}

		void retrieveData (T1 & param1)
		{
			param1 = m_param1;
		}
};

template <class T1, class T2> class ParameterCache_2 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
	public:
		ParameterCache_2 (const T1 & param1, const T2 & param2)
			: m_param1 (param1), m_param2 (param2)
		{
		}

		void retrieveData (T1 & param1, T2 & param2)
		{
			param1 = m_param1;
			param2 = m_param2;
		}
};

template <class T1, class T2, class T3> class ParameterCache_3 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
	public:
		ParameterCache_3 (const T1 & param1, const T2 & param2, const T3 & param3)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
		}
};

template <class T1, class T2, class T3, class T4> class ParameterCache_4 : public ParameterCache {
	private:
		T1 m_param1;
		T2 m_param2;
		T3 m_param3;
		T4 m_param4;
	public:
		ParameterCache_4 (const T1 & param1, const T2 & param2, const T3 & param3, const T4 & param4)
			: m_param1 (param1), m_param2 (param2), m_param3 (param3), m_param4 (param4)
		{
		}

		void retrieveData (T1 & param1, T2 & param2, T3 & param3, T4 & param4)
		{
			param1 = m_param1;
			param2 = m_param2;
			param3 = m_param3;
			param4 = m_param4;
		}
};


/*************************************************************************************************************************
 Class interface for Base 
**************************************************************************************************************************/

class IBase {
private:
	std::unique_ptr<ParameterCache> m_ParameterCache;
public:
	/**
	* IBase::~IBase - virtual destructor of IBase
	*/
	virtual ~IBase() {};

	/**
	* IBase::ReleaseBaseClassInterface - Releases ownership of a base class interface. Deletes the reference, if necessary.
	* @param[in] pIBase - The base class instance to release
	*/
	static void ReleaseBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->DecRefCount();
		}
	};

	/**
	* IBase::AcquireBaseClassInterface - Acquires shared ownership of a base class interface.
	* @param[in] pIBase - The base class instance to acquire
	*/
	static void AcquireBaseClassInterface(IBase* pIBase)
	{
		if (pIBase) {
			pIBase->IncRefCount();
		}
	};


	/**
	* IBase::GetLastErrorMessage - Returns the last error registered of this class instance
	* @param[out] sErrorMessage - Message of the last error registered
	* @return Has an error been registered already
	*/
	virtual bool GetLastErrorMessage(std::string & sErrorMessage) = 0;

	/**
	* IBase::ClearErrorMessages - Clears all registered messages of this class instance
	*/
	virtual void ClearErrorMessages() = 0;

	/**
	* IBase::RegisterErrorMessage - Registers an error message with this class instance
	* @param[in] sErrorMessage - Error message to register
	*/
	virtual void RegisterErrorMessage(const std::string & sErrorMessage) = 0;

	/**
	* IBase::IncRefCount - Increases the reference count of a class instance
	*/
	virtual void IncRefCount() = 0;

	/**
	* IBase::DecRefCount - Decreases the reference count of a class instance and free releases it, if the last reference has been removed
	* @return Has the object been released
	*/
	virtual bool DecRefCount() = 0;

	/**
	* IBase::_setCache - set parameter cache of object
	*/
	void _setCache(ParameterCache * pCache)
	{
		m_ParameterCache.reset(pCache);
	}

	/**
	* IBase::_getCache - returns parameter cache of object
	*/
	ParameterCache* _getCache()
	{
		return m_ParameterCache.get();
	}

};


/**
 Definition of a shared pointer class for IBase
*/
template<class T>
class IBaseSharedPtr : public std::shared_ptr<T>
{
public:
	explicit IBaseSharedPtr(T* t = nullptr)
		: std::shared_ptr<T>(t, IBase::ReleaseBaseClassInterface)
	{
		t->IncRefCount();
	}

	// Reset function, as it also needs to properly set the deleter.
	void reset(T* t = nullptr)
	{
		std::shared_ptr<T>::reset(t, IBase::ReleaseBaseClassInterface);
	}

	// Get-function that increases the Base class's reference count
	T* getCoOwningPtr()
	{
		T* t = this->get();
		t->IncRefCount();
		return t;
	}
};


typedef IBaseSharedPtr<IBase> PIBase;


/*************************************************************************************************************************
 Class interface for Iterator 
**************************************************************************************************************************/

class IIterator : public virtual IBase {
public:
	/**
	* IIterator::MoveNext - Iterates to the next object in the list.
	* @return Iterates to the next object in the list.
	*/
	virtual bool MoveNext() = 0;

	/**
	* IIterator::MovePrevious - Iterates to the previous object in the list.
	* @return Iterates to the previous object in the list.
	*/
	virtual bool MovePrevious() = 0;

	/**
	* IIterator::GetCurrent - Returns the object the iterator points at.
	* @return returns the object instance.
	*/
	virtual IBase * GetCurrent() = 0;

	/**
	* IIterator::Clone - Creates a new object iterator with the same object list.
	* @return returns the cloned Iterator instance
	*/
	virtual IIterator * Clone() = 0;

	/**
	* IIterator::Count - Returns the number of resoucres the iterator captures.
	* @return returns the number of objects the iterator captures.
	*/
	virtual LibMCEnv_uint64 Count() = 0;

};

typedef IBaseSharedPtr<IIterator> PIIterator;


/*************************************************************************************************************************
 Class interface for TestEnvironment 
**************************************************************************************************************************/

class ITestEnvironment : public virtual IBase {
public:
	/**
	* ITestEnvironment::WriteTestOutput - Write output file to test directory.
	* @param[in] sOutputName - Output file name. Only alphanumeric characters, point, underscore and hypen are allowed.
	* @param[in] nDataBufferSize - Number of elements in buffer
	* @param[in] pDataBuffer - Test data to write into output directory.
	*/
	virtual void WriteTestOutput(const std::string & sOutputName, const LibMCEnv_uint64 nDataBufferSize, const LibMCEnv_uint8 * pDataBuffer) = 0;

};

typedef IBaseSharedPtr<ITestEnvironment> PITestEnvironment;


/*************************************************************************************************************************
 Class interface for PNGImageStoreOptions 
**************************************************************************************************************************/

class IPNGImageStoreOptions : public virtual IBase {
public:
	/**
	* IPNGImageStoreOptions::ResetToDefaults - Resets Options to default.
	*/
	virtual void ResetToDefaults() = 0;

};

typedef IBaseSharedPtr<IPNGImageStoreOptions> PIPNGImageStoreOptions;


/*************************************************************************************************************************
 Class interface for PNGImageData 
**************************************************************************************************************************/

class IPNGImageData : public virtual IBase {
public:
	/**
	* IPNGImageData::GetSizeInPixels - Returns image pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	virtual void GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY) = 0;

	/**
	* IPNGImageData::GetPNGDataStream - Retrieves encoded data stream of image object.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[out] pPNGDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pPNGDataBuffer - uint8 buffer of PNG Data stream.
	*/
	virtual void GetPNGDataStream(LibMCEnv_uint64 nPNGDataBufferSize, LibMCEnv_uint64* pPNGDataNeededCount, LibMCEnv_uint8 * pPNGDataBuffer) = 0;

};

typedef IBaseSharedPtr<IPNGImageData> PIPNGImageData;


/*************************************************************************************************************************
 Class interface for ImageData 
**************************************************************************************************************************/

class IImageData : public virtual IBase {
public:
	/**
	* IImageData::GetPixelFormat - Returns Pixel format of the image.
	* @return Pixel Format of image
	*/
	virtual LibMCEnv::eImagePixelFormat GetPixelFormat() = 0;

	/**
	* IImageData::ChangePixelFormat - Changes Pixel format of the image. Might lose alpha or color information during the process.
	* @param[in] ePixelFormat - new Pixel Format of image
	*/
	virtual void ChangePixelFormat(const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IImageData::GetDPI - Returns DPI values in X and Y.
	* @param[out] dDPIValueX - DPI value in X
	* @param[out] dDPIValueY - DPI value in Y
	*/
	virtual void GetDPI(LibMCEnv_double & dDPIValueX, LibMCEnv_double & dDPIValueY) = 0;

	/**
	* IImageData::SetDPI - Sets DPI values in X and Y.
	* @param[in] dDPIValueX - new DPI value in X
	* @param[in] dDPIValueY - new DPI value in Y
	*/
	virtual void SetDPI(const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY) = 0;

	/**
	* IImageData::GetSizeInMM - Returns image sizes inmm.
	* @param[out] dSizeX - Size in X in mm
	* @param[out] dSizeY - Size in Y in mm
	*/
	virtual void GetSizeInMM(LibMCEnv_double & dSizeX, LibMCEnv_double & dSizeY) = 0;

	/**
	* IImageData::GetSizeInPixels - Returns image pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	virtual void GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY) = 0;

	/**
	* IImageData::ResizeImage - Resizes Image pixel data.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	virtual void ResizeImage(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY) = 0;

	/**
	* IImageData::LoadPNG - Loads a PNG from a binary array. Supports RGB, RGBA and Greyscale images.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[in] pPNGDataBuffer - PNG Data stream.
	*/
	virtual void LoadPNG(const LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer) = 0;

	/**
	* IImageData::CreatePNGImage - Creates PNG Image out of the pixel data.
	* @param[in] pPNGStorageOptions - Optional encoding options for the image.
	* @return Image data.
	*/
	virtual IPNGImageData * CreatePNGImage(IPNGImageStoreOptions* pPNGStorageOptions) = 0;

	/**
	* IImageData::EncodePNG - Depreciated. DO NOT USE. Encodes PNG and stores data stream in image object.
	*/
	virtual void EncodePNG() = 0;

	/**
	* IImageData::GetEncodedPNGData - Depreciated. DO NOT USE. Retrieves encoded data stream of image object. MUST have been encoded with EncodePNG before.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[out] pPNGDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pPNGDataBuffer - uint8 buffer of PNG Data stream.
	*/
	virtual void GetEncodedPNGData(LibMCEnv_uint64 nPNGDataBufferSize, LibMCEnv_uint64* pPNGDataNeededCount, LibMCEnv_uint8 * pPNGDataBuffer) = 0;

	/**
	* IImageData::ClearEncodedPNGData - Depreciated. DO NOT USE. Releases encoded data stream of image object. Depreciated.
	*/
	virtual void ClearEncodedPNGData() = 0;

	/**
	* IImageData::Clear - Sets all pixels to a single value.
	* @param[in] nValue - Pixel value.
	*/
	virtual void Clear(const LibMCEnv_uint32 nValue) = 0;

	/**
	* IImageData::GetPixel - Returns one pixel of an image.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @return Pixel value at this position
	*/
	virtual LibMCEnv_uint32 GetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY) = 0;

	/**
	* IImageData::SetPixel - Sets one pixel of an image.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @param[in] nValue - New Pixel value at this position
	*/
	virtual void SetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY, const LibMCEnv_uint32 nValue) = 0;

	/**
	* IImageData::GetPixelRange - Returns a subset of an image or the whole image data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within image bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within image bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within image bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within image bounds. MUST be larger or equal than MinY
	* @param[in] nValueBufferSize - Number of elements in buffer
	* @param[out] pValueNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pValueBuffer - uint8 buffer of Pixel values of the rectangle, rowwise array. Will return the exact number of pixels in size and 1, 3 or 4 bytes per pixel, depending on pixel format.
	*/
	virtual void GetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, LibMCEnv_uint64 nValueBufferSize, LibMCEnv_uint64* pValueNeededCount, LibMCEnv_uint8 * pValueBuffer) = 0;

	/**
	* IImageData::SetPixelRange - Exchanges a subset of an image or the whole image data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within image bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within image bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within image bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within image bounds. MUST be larger or equal than MinY
	* @param[in] nValueBufferSize - Number of elements in buffer
	* @param[in] pValueBuffer - New pixel values of the rectangle, rowwise array. MUST have the exact number of pixels in size and 1, 3 or 4 bytes per pixel, depending on pixel format.
	*/
	virtual void SetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, const LibMCEnv_uint64 nValueBufferSize, const LibMCEnv_uint8 * pValueBuffer) = 0;

};

typedef IBaseSharedPtr<IImageData> PIImageData;


/*************************************************************************************************************************
 Class interface for DiscreteFieldData2DStoreOptions 
**************************************************************************************************************************/

class IDiscreteFieldData2DStoreOptions : public virtual IBase {
public:
	/**
	* IDiscreteFieldData2DStoreOptions::ResetToDefaults - Resets Options to default.
	*/
	virtual void ResetToDefaults() = 0;

};

typedef IBaseSharedPtr<IDiscreteFieldData2DStoreOptions> PIDiscreteFieldData2DStoreOptions;


/*************************************************************************************************************************
 Class interface for DiscreteFieldData2D 
**************************************************************************************************************************/

class IDiscreteFieldData2D : public virtual IBase {
public:
	/**
	* IDiscreteFieldData2D::GetDPI - Returns DPI values in X and Y.
	* @param[out] dDPIValueX - DPI value in X
	* @param[out] dDPIValueY - DPI value in Y
	*/
	virtual void GetDPI(LibMCEnv_double & dDPIValueX, LibMCEnv_double & dDPIValueY) = 0;

	/**
	* IDiscreteFieldData2D::SetDPI - Sets DPI values in X and Y.
	* @param[in] dDPIValueX - new DPI value in X. MUST be positive.
	* @param[in] dDPIValueY - new DPI value in Y. MUST be positive.
	*/
	virtual void SetDPI(const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY) = 0;

	/**
	* IDiscreteFieldData2D::GetOriginInMM - Returns field origin in mm.
	* @param[out] dOriginX - Origin in X in mm
	* @param[out] dOriginY - Origin in Y in mm
	*/
	virtual void GetOriginInMM(LibMCEnv_double & dOriginX, LibMCEnv_double & dOriginY) = 0;

	/**
	* IDiscreteFieldData2D::SetOriginInMM - Set field origin in mm.
	* @param[in] dOriginX - Origin in X in mm
	* @param[in] dOriginY - Origin in Y in mm
	*/
	virtual void SetOriginInMM(const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY) = 0;

	/**
	* IDiscreteFieldData2D::GetSizeInMM - Returns field sizes in mm.
	* @param[out] dSizeX - Size in X in mm
	* @param[out] dSizeY - Size in Y in mm
	*/
	virtual void GetSizeInMM(LibMCEnv_double & dSizeX, LibMCEnv_double & dSizeY) = 0;

	/**
	* IDiscreteFieldData2D::GetSizeInPixels - Returns field pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	virtual void GetSizeInPixels(LibMCEnv_uint32 & nPixelSizeX, LibMCEnv_uint32 & nPixelSizeY) = 0;

	/**
	* IDiscreteFieldData2D::ResizeField - Resizes field pixel data.
	* @param[in] nPixelSizeX - Number of pixels in X
	* @param[in] nPixelSizeY - Number of pixels in Y
	* @param[in] dDefaultValue - Default Pixel value.
	*/
	virtual void ResizeField(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IDiscreteFieldData2D::Clear - Sets all pixels to a single value.
	* @param[in] dValue - Pixel value.
	*/
	virtual void Clear(const LibMCEnv_double dValue) = 0;

	/**
	* IDiscreteFieldData2D::Clamp - Clamps all pixels to a certain interval.
	* @param[in] dMinValue - Minimum value. MUST be smaller or equal than MaxValue.
	* @param[in] dMaxValue - Maximum value. MUST be larger or equal than MinValue.
	*/
	virtual void Clamp(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue) = 0;

	/**
	* IDiscreteFieldData2D::GetPixel - Returns one pixel of an field. Fails if outside of field size.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @return Pixel value at this position
	*/
	virtual LibMCEnv_double GetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY) = 0;

	/**
	* IDiscreteFieldData2D::SetPixel - Sets one pixel of an field. Fails if outside of field size.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @param[in] dValue - New Pixel value at this position
	*/
	virtual void SetPixel(const LibMCEnv_uint32 nX, const LibMCEnv_uint32 nY, const LibMCEnv_double dValue) = 0;

	/**
	* IDiscreteFieldData2D::GetPixelRange - Returns a subset of an field or the whole field data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within field bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within field bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within field bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within field bounds. MUST be larger or equal than MinY
	* @param[in] nValueBufferSize - Number of elements in buffer
	* @param[out] pValueNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pValueBuffer - double buffer of Pixel values of the rectangle, rowwise array. Will return the exact number of pixels in size.
	*/
	virtual void GetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, LibMCEnv_uint64 nValueBufferSize, LibMCEnv_uint64* pValueNeededCount, LibMCEnv_double * pValueBuffer) = 0;

	/**
	* IDiscreteFieldData2D::SetPixelRange - Exchanges a subset of an field or the whole field data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within field bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within field bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within field bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within field bounds. MUST be larger or equal than MinY
	* @param[in] nValueBufferSize - Number of elements in buffer
	* @param[in] pValueBuffer - New pixel values of the rectangle, rowwise array. MUST have the exact number of pixels in size.
	*/
	virtual void SetPixelRange(const LibMCEnv_uint32 nXMin, const LibMCEnv_uint32 nYMin, const LibMCEnv_uint32 nXMax, const LibMCEnv_uint32 nYMax, const LibMCEnv_uint64 nValueBufferSize, const LibMCEnv_double * pValueBuffer) = 0;

	/**
	* IDiscreteFieldData2D::RenderAveragePointValues - Renders and array of average point values into the field. 
	* @param[in] dDefaultValue - If a pixel does not contain any value, fall back to this given value.
	* @param[in] eSamplingMode - Sampling mode of point values.
	* @param[in] dSampleSizeX - How large a sample point should be drawn in Pixel widths. This determines the weighting when a point value overlaps multiple pixels. Ignored if SamplingMode is equal FloorCoordinate or CeilCoordinate. MUST be positive otherwise.
	* @param[in] dSampleSizeY - How large a sample point should be drawn in Pixel heights. This determines the weighting when a point value overlaps multiple pixels. Ignored if SamplingMode is equal FloorCoordinate or CeilCoordinate. MUST be positive otherwise.
	* @param[in] nPointValuesBufferSize - Number of elements in buffer
	* @param[in] pPointValuesBuffer - Array of Field Data Points that are sorted into the grid. If a point lies on a grid border, it will be counted to all adjacent pixels.
	*/
	virtual void RenderAveragePointValues(const LibMCEnv_double dDefaultValue, const LibMCEnv::eFieldSamplingMode eSamplingMode, const LibMCEnv_double dSampleSizeX, const LibMCEnv_double dSampleSizeY, const LibMCEnv_uint64 nPointValuesBufferSize, const LibMCEnv::sFieldData2DPoint * pPointValuesBuffer) = 0;

	/**
	* IDiscreteFieldData2D::ScaleFieldDown - Scales the field to a smaller size.
	* @param[in] nFactorX - The new field will be this factor smaller in X. MUST be positive and smaller than PixelSizeX
	* @param[in] nFactorY - The new field will be this factor smaller in Y. MUST be positive and smaller than PixelSizeY
	* @return Scaled Field Instance
	*/
	virtual IDiscreteFieldData2D * ScaleFieldDown(const LibMCEnv_uint32 nFactorX, const LibMCEnv_uint32 nFactorY) = 0;

	/**
	* IDiscreteFieldData2D::ScaleFieldUp - Scales the field to a larger size.
	* @param[in] nFactorX - The new field will be this factor larger in X. MUST be positive.
	* @param[in] nFactorY - The new field will be this factor larger in Y. MUST be positive.
	* @return Scaled Field Instance
	*/
	virtual IDiscreteFieldData2D * ScaleFieldUp(const LibMCEnv_uint32 nFactorX, const LibMCEnv_uint32 nFactorY) = 0;

	/**
	* IDiscreteFieldData2D::Discretize - Discretizes the field into a finite set of values. All field values will be set to the nearest value in the given array. Equivalent to DiscretizeWithMapping with two identical parameters.
	* @param[in] nDiscreteValuesBufferSize - Number of elements in buffer
	* @param[in] pDiscreteValuesBuffer - An array of values. MUST NOT be empty.
	*/
	virtual void Discretize(const LibMCEnv_uint64 nDiscreteValuesBufferSize, const LibMCEnv_double * pDiscreteValuesBuffer) = 0;

	/**
	* IDiscreteFieldData2D::DiscretizeWithMapping - Discretizes the field into a finite set of DiscreteValues. For each field value the nearest DiscreteValue is determined, and the field is set to the element of NewValues with the same index.
	* @param[in] nDiscreteValuesBufferSize - Number of elements in buffer
	* @param[in] pDiscreteValuesBuffer - An array of values. MUST NOT be empty.  
	* @param[in] nNewValuesBufferSize - Number of elements in buffer
	* @param[in] pNewValuesBuffer - An array of values. MUST have the same cardinality as DiscreteValues.
	*/
	virtual void DiscretizeWithMapping(const LibMCEnv_uint64 nDiscreteValuesBufferSize, const LibMCEnv_double * pDiscreteValuesBuffer, const LibMCEnv_uint64 nNewValuesBufferSize, const LibMCEnv_double * pNewValuesBuffer) = 0;

	/**
	* IDiscreteFieldData2D::RenderToImageRaw - Renders the field into a PNG image. The colors will be linearly interpolated into a given color scheme.
	* @param[in] dMinValue - Min point value. Values smaller than MinValue will be clamped to MinValue.
	* @param[in] MinColor - The color assigned to MinValue.
	* @param[in] dMidValue - Mid point value. MUST be at least 1E-6 larger than MinValue.
	* @param[in] MidColor - The color assigned to MidValue
	* @param[in] dMaxValue - Max point value. MUST be at least 1E-6 larger than MidValue. Values larger than MaxValue will be clamped to MaxValue.
	* @param[in] MaxColor - The color assigned to MaxValue
	* @return New Image with the according data. Pixel size and DPI will be equal to the field. Pixel format will be RGB24bit.
	*/
	virtual IImageData * RenderToImageRaw(const LibMCEnv_double dMinValue, const LibMCEnv::sColorRGB MinColor, const LibMCEnv_double dMidValue, const LibMCEnv::sColorRGB MidColor, const LibMCEnv_double dMaxValue, const LibMCEnv::sColorRGB MaxColor) = 0;

	/**
	* IDiscreteFieldData2D::TransformField - Scales the field values with a factor and a translation.
	* @param[in] dScale - A scaling factor will be applied to all values in the field.
	* @param[in] dOffset - The offset will be applied to all values in the field after scaling.
	*/
	virtual void TransformField(const LibMCEnv_double dScale, const LibMCEnv_double dOffset) = 0;

	/**
	* IDiscreteFieldData2D::AddField - Adds another field to the field. Both fields MUST have the same pixel extensions.
	* @param[in] pOtherField - Field Instance to add
	* @param[in] dScale - A scaling factor will be applied to all values in the other field before adding.
	* @param[in] dOffset - The offset will be applied to all values in the field after scaling.
	*/
	virtual void AddField(IDiscreteFieldData2D* pOtherField, const LibMCEnv_double dScale, const LibMCEnv_double dOffset) = 0;

	/**
	* IDiscreteFieldData2D::Duplicate - Creates a copy of the field.
	* @return Scaled Field Instance
	*/
	virtual IDiscreteFieldData2D * Duplicate() = 0;

};

typedef IBaseSharedPtr<IDiscreteFieldData2D> PIDiscreteFieldData2D;


/*************************************************************************************************************************
 Class interface for MeshObject 
**************************************************************************************************************************/

class IMeshObject : public virtual IBase {
public:
	/**
	* IMeshObject::GetName - Returns the name of the Mesh Object.
	* @return Returns the name of the mesh object.
	*/
	virtual std::string GetName() = 0;

	/**
	* IMeshObject::GetUUID - Returns the UUID of the mesh object.
	* @return Returns mesh uuid.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IMeshObject::GetTriangleCount - Returns the number of triangles.
	* @return Number of triangles.
	*/
	virtual LibMCEnv_uint32 GetTriangleCount() = 0;

	/**
	* IMeshObject::GetVertexCount - Returns the number of vertices.
	* @return Number of vertices.
	*/
	virtual LibMCEnv_uint32 GetVertexCount() = 0;

};

typedef IBaseSharedPtr<IMeshObject> PIMeshObject;


/*************************************************************************************************************************
 Class interface for ToolpathPart 
**************************************************************************************************************************/

class IToolpathPart : public virtual IBase {
public:
	/**
	* IToolpathPart::GetName - Returns Part Name.
	* @return Returns toolpath part name.
	*/
	virtual std::string GetName() = 0;

	/**
	* IToolpathPart::GetUUID - Returns Part UUID.
	* @return Returns toolpath part uuid.
	*/
	virtual std::string GetUUID() = 0;

	/**
	* IToolpathPart::GetMeshUUID - Returns Mesh UUID of the part.
	* @return Returns toolpath part mesh uuid.
	*/
	virtual std::string GetMeshUUID() = 0;

	/**
	* IToolpathPart::GetTransform - Returns Mesh Transform of the part.
	* @return Returns the mesh transform of the toolpath.
	*/
	virtual LibMCEnv::sToolpathPartTransform GetTransform() = 0;

};

typedef IBaseSharedPtr<IToolpathPart> PIToolpathPart;


/*************************************************************************************************************************
 Class interface for ToolpathLayer 
**************************************************************************************************************************/

class IToolpathLayer : public virtual IBase {
public:
	/**
	* IToolpathLayer::GetLayerDataUUID - Retrieves the layerdata's uuid
	* @return Returns the uuid value.
	*/
	virtual std::string GetLayerDataUUID() = 0;

	/**
	* IToolpathLayer::GetSegmentCount - Retrieves the count of segments.
	* @return Count
	*/
	virtual LibMCEnv_uint32 GetSegmentCount() = 0;

	/**
	* IToolpathLayer::GetSegmentInfo - Retrieves the segment type and point count information .
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[out] eType - Segment Type
	* @param[out] nPointCount - Point count of segment.
	*/
	virtual void GetSegmentInfo(const LibMCEnv_uint32 nIndex, LibMCEnv::eToolpathSegmentType & eType, LibMCEnv_uint32 & nPointCount) = 0;

	/**
	* IToolpathLayer::GetSegmentType - Retrieves the segment type.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Type
	*/
	virtual LibMCEnv::eToolpathSegmentType GetSegmentType(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::GetSegmentIntegerAttribute - Retrieves the segment integer attribute with the corresponding ID. Fails if attribute does not exist or does have different type.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] nAttributeID - ID of the attribute.
	* @return Attribute Value.
	*/
	virtual LibMCEnv_int64 GetSegmentIntegerAttribute(const LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nAttributeID) = 0;

	/**
	* IToolpathLayer::GetSegmentDoubleAttribute - Retrieves the segment double attribute with the corresponding ID. Fails if attribute does not exist or does have different type.
	* @param[in] nIndex - Segment Index. Must be between 0 and Count - 1.
	* @param[in] nAttributeID - ID of the attribute.
	* @return Attribute Value.
	*/
	virtual LibMCEnv_double GetSegmentDoubleAttribute(const LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nAttributeID) = 0;

	/**
	* IToolpathLayer::HasCustomSegmentAttribute - Checks if a segment attribute is registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @return Flag if attribute is registered.
	*/
	virtual bool HasCustomSegmentAttribute(const std::string & sNamespace, const std::string & sAttributeName) = 0;

	/**
	* IToolpathLayer::FindCustomSegmentAttributeID - Finds a segment attribute ID. Fails if attribute is not registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @return ID of the attribute.
	*/
	virtual LibMCEnv_uint32 FindCustomSegmentAttributeID(const std::string & sNamespace, const std::string & sAttributeName) = 0;

	/**
	* IToolpathLayer::FindCustomSegmentAttributeType - Finds a segment attribute type. Fails if attribute is not registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @return Type of the attribute.
	*/
	virtual LibMCEnv::eToolpathAttributeType FindCustomSegmentAttributeType(const std::string & sNamespace, const std::string & sAttributeName) = 0;

	/**
	* IToolpathLayer::FindCustomSegmentAttributeInfo - Finds a segment attribute ID and type. Fails if attribute is not registered.
	* @param[in] sNamespace - Namespace of the attribute.
	* @param[in] sAttributeName - Name of the attribute.
	* @param[out] nAttributeID - ID of the attribute.
	* @param[out] eAttributeType - Type of the attribute.
	*/
	virtual void FindCustomSegmentAttributeInfo(const std::string & sNamespace, const std::string & sAttributeName, LibMCEnv_uint32 & nAttributeID, LibMCEnv::eToolpathAttributeType & eAttributeType) = 0;

	/**
	* IToolpathLayer::GetSegmentPointCount - Retrieves the number of points in the segment. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Hatch count of segment.
	*/
	virtual LibMCEnv_uint32 GetSegmentPointCount(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::GetSegmentHatchCount - Retrieves the number of hatches in the segment (i.e. PointCount / 2). Returns 0 if segment is not of type hatch.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Hatch count of segment.
	*/
	virtual LibMCEnv_uint32 GetSegmentHatchCount(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileUUID - Retrieves the assigned segment profile uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Profile UUID
	*/
	virtual std::string GetSegmentProfileUUID(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::SegmentProfileHasValue - Retrieves an assigned profile custom value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Returns true if value exist.
	*/
	virtual bool SegmentProfileHasValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileValue - Retrieves an assigned profile custom value. Fails if value does not exist.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return String Value.
	*/
	virtual std::string GetSegmentProfileValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileValueDef - Retrieves an assigned profile custom value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] sDefaultValue - Default value if value does not exist.
	* @return String Value.
	*/
	virtual std::string GetSegmentProfileValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const std::string & sDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileDoubleValue - Retrieves an assigned profile custom double value. Fails if value does not exist or is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Double Value.
	*/
	virtual LibMCEnv_double GetSegmentProfileDoubleValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileDoubleValueDef - Retrieves an assigned profile custom double value. Fails if value exists but is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] dDefaultValue - Default value if value does not exist.
	* @return Double Value.
	*/
	virtual LibMCEnv_double GetSegmentProfileDoubleValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileIntegerValue - Retrieves an assigned profile custom integer value. Fails if value does not exist or is not a integer value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Integer Value.
	*/
	virtual LibMCEnv_int64 GetSegmentProfileIntegerValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileIntegerValueDef - Retrieves an assigned profile custom integer value. Fails if value exists but is not a integer value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] nDefaultValue - Default value if value does not exist.
	* @return Integer Value.
	*/
	virtual LibMCEnv_int64 GetSegmentProfileIntegerValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const LibMCEnv_int64 nDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileBoolValue - Retrieves an assigned profile custom boolean value. A Boolean value is either an integer value, or strings of the form true or false (case insensitive). Fails if value does not exist or is not a bool value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @return Boolean Value.
	*/
	virtual bool GetSegmentProfileBoolValue(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileBoolValueDef - Retrieves an assigned profile custom boolean value. A Boolean value is either an integer value, or strings of the form true or false (case insensitive). Fails if value exists but is not a bool value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] sNamespace - Namespace to query for.
	* @param[in] sValueName - Value Name to query for.
	* @param[in] bDefaultValue - Default value if value does not exist.
	* @return Boolean Value.
	*/
	virtual bool GetSegmentProfileBoolValueDef(const LibMCEnv_uint32 nIndex, const std::string & sNamespace, const std::string & sValueName, const bool bDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileTypedValue - Retrieves an assigned profile value of a standard type. Fails if value does not exist or is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] eValueType - Enum to query for. MUST NOT be custom.
	* @return Double Value
	*/
	virtual LibMCEnv_double GetSegmentProfileTypedValue(const LibMCEnv_uint32 nIndex, const LibMCEnv::eToolpathProfileValueType eValueType) = 0;

	/**
	* IToolpathLayer::GetSegmentProfileTypedValueDef - Retrieves an assigned profile value of a standard type. Fails if value exists but is not a double value.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] eValueType - Enum to query for. MUST NOT be custom.
	* @param[in] dDefaultValue - Default value if value does not exist.
	* @return Double Value
	*/
	virtual LibMCEnv_double GetSegmentProfileTypedValueDef(const LibMCEnv_uint32 nIndex, const LibMCEnv::eToolpathProfileValueType eValueType, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IToolpathLayer::GetSegmentPartUUID - Retrieves the assigned segment part uuid.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @return Segment Part UUID
	*/
	virtual std::string GetSegmentPartUUID(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IToolpathLayer::GetSegmentPointData - Retrieves the assigned segment point list. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] nPointDataBufferSize - Number of elements in buffer
	* @param[out] pPointDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pPointDataBuffer - Position2D buffer of The point data array. Positions are absolute in units.
	*/
	virtual void GetSegmentPointData(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 nPointDataBufferSize, LibMCEnv_uint64* pPointDataNeededCount, LibMCEnv::sPosition2D * pPointDataBuffer) = 0;

	/**
	* IToolpathLayer::GetSegmentHatchData - Retrieves the assigned segment hatch list. Fails if segment type is not hatch.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] nHatchDataBufferSize - Number of elements in buffer
	* @param[out] pHatchDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pHatchDataBuffer - Hatch2D buffer of The hatch data array. Positions are absolute in units.
	*/
	virtual void GetSegmentHatchData(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 nHatchDataBufferSize, LibMCEnv_uint64* pHatchDataNeededCount, LibMCEnv::sHatch2D * pHatchDataBuffer) = 0;

	/**
	* IToolpathLayer::GetSegmentPointDataInMM - Retrieves the assigned segment point list. For type hatch, the points are taken pairwise.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] nPointDataBufferSize - Number of elements in buffer
	* @param[out] pPointDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pPointDataBuffer - FloatPosition2D buffer of The point data array. Positions are absolute in mm.
	*/
	virtual void GetSegmentPointDataInMM(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 nPointDataBufferSize, LibMCEnv_uint64* pPointDataNeededCount, LibMCEnv::sFloatPosition2D * pPointDataBuffer) = 0;

	/**
	* IToolpathLayer::GetSegmentHatchDataInMM - Retrieves the assigned segment hatch list. Fails if segment type is not hatch.
	* @param[in] nIndex - Index. Must be between 0 and Count - 1.
	* @param[in] nHatchDataBufferSize - Number of elements in buffer
	* @param[out] pHatchDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pHatchDataBuffer - FloatHatch2D buffer of The hatch data array. Positions are absolute in mm.
	*/
	virtual void GetSegmentHatchDataInMM(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 nHatchDataBufferSize, LibMCEnv_uint64* pHatchDataNeededCount, LibMCEnv::sFloatHatch2D * pHatchDataBuffer) = 0;

	/**
	* IToolpathLayer::GetZValue - Retrieves the layers Z Value in units.
	* @return Z Value of the layer in units.
	*/
	virtual LibMCEnv_int32 GetZValue() = 0;

	/**
	* IToolpathLayer::GetZValueInMM - Retrieves the layers Z Value in mm.
	* @return Z Value of the layer in mm.
	*/
	virtual LibMCEnv_double GetZValueInMM() = 0;

	/**
	* IToolpathLayer::GetUnits - Retrieves the toolpath units in mm.
	* @return Toolpath units.
	*/
	virtual LibMCEnv_double GetUnits() = 0;

	/**
	* IToolpathLayer::GetMetaDataCount - Retrieves the number of metadata nodes in the build file.
	* @return Meta Data information.
	*/
	virtual LibMCEnv_uint32 GetMetaDataCount() = 0;

	/**
	* IToolpathLayer::GetMetaDataInfo - Returns the namespace and identifier of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @param[out] sNamespace - Namespace of the metadata
	* @param[out] sName - Name of the metadata
	*/
	virtual void GetMetaDataInfo(const LibMCEnv_uint32 nMetaDataIndex, std::string & sNamespace, std::string & sName) = 0;

	/**
	* IToolpathLayer::GetMetaDataContent - Returns the metadata XML content of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @return XML Metadata Object
	*/
	virtual IXMLDocumentNode * GetMetaDataContent(const LibMCEnv_uint32 nMetaDataIndex) = 0;

	/**
	* IToolpathLayer::HasUniqueMetaData - Checks if a metadata exists in the build file.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return Returns true if metadata exists and is unique.
	*/
	virtual bool HasUniqueMetaData(const std::string & sNamespace, const std::string & sName) = 0;

	/**
	* IToolpathLayer::FindUniqueMetaData - Returns the given metadata XML content of the build file. Fails if metadata content does not exist or is not unique.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return XML Metadata Object
	*/
	virtual IXMLDocumentNode * FindUniqueMetaData(const std::string & sNamespace, const std::string & sName) = 0;

};

typedef IBaseSharedPtr<IToolpathLayer> PIToolpathLayer;


/*************************************************************************************************************************
 Class interface for ToolpathAccessor 
**************************************************************************************************************************/

class IToolpathAccessor : public virtual IBase {
public:
	/**
	* IToolpathAccessor::GetStorageUUID - Returns Toolpath storage UUID.
	* @return Returns toolpath storage uuid.
	*/
	virtual std::string GetStorageUUID() = 0;

	/**
	* IToolpathAccessor::GetBuildUUID - Returns UUID of the toolpath's build file.
	* @return Returns build uuid.
	*/
	virtual std::string GetBuildUUID() = 0;

	/**
	* IToolpathAccessor::GetLayerCount - Returns layer count.
	* @return Returns layer count.
	*/
	virtual LibMCEnv_uint32 GetLayerCount() = 0;

	/**
	* IToolpathAccessor::RegisterCustomSegmentAttribute - Registers a new custom segment attribute to be read.
	* @param[in] sNameSpace - Namespace of the custom attribute.
	* @param[in] sAttributeName - Name of the custom attribute.
	* @param[in] eAttributeType - Attribute Type.
	*/
	virtual void RegisterCustomSegmentAttribute(const std::string & sNameSpace, const std::string & sAttributeName, const LibMCEnv::eToolpathAttributeType eAttributeType) = 0;

	/**
	* IToolpathAccessor::LoadLayer - Reads and returns a layer object.
	* @param[in] nLayerIndex - Layer Index.
	* @return Toolpath layer object.
	*/
	virtual IToolpathLayer * LoadLayer(const LibMCEnv_uint32 nLayerIndex) = 0;

	/**
	* IToolpathAccessor::GetUnits - Retrieves the toolpath units in mm.
	* @return Toolpath units.
	*/
	virtual LibMCEnv_double GetUnits() = 0;

	/**
	* IToolpathAccessor::GetPartCount - Retrieves the number of parts in the toolpath.
	* @return Number of parts.
	*/
	virtual LibMCEnv_uint32 GetPartCount() = 0;

	/**
	* IToolpathAccessor::GetPart - Retrieves the part information of a toolpath.
	* @param[in] nPartIndex - Index of part. MUST be between 0 and PartCount-1
	* @return Part Instance
	*/
	virtual IToolpathPart * GetPart(const LibMCEnv_uint32 nPartIndex) = 0;

	/**
	* IToolpathAccessor::FindPartByUUID - Finds the part information of a toolpath.
	* @param[in] sPartUUID - UUID of part.
	* @return Part Instance. Returns null if part does not exist.
	*/
	virtual IToolpathPart * FindPartByUUID(const std::string & sPartUUID) = 0;

	/**
	* IToolpathAccessor::GetBuildHeightInUnits - Retrieves the build height in units.
	* @return Build height in units.
	*/
	virtual LibMCEnv_int32 GetBuildHeightInUnits() = 0;

	/**
	* IToolpathAccessor::GetZValueInUnits - Retrieves the layers Z Value in units.
	* @param[in] nLayerIndex - Layer Index to return.
	* @return Z Value of the layer in units.
	*/
	virtual LibMCEnv_int32 GetZValueInUnits(const LibMCEnv_uint32 nLayerIndex) = 0;

	/**
	* IToolpathAccessor::GetBuildHeightInMM - Retrieves the build height in mm.
	* @return Build height in mm.
	*/
	virtual LibMCEnv_double GetBuildHeightInMM() = 0;

	/**
	* IToolpathAccessor::GetZValueInMM - Retrieves the layers Z Value in mm.
	* @param[in] nLayerIndex - Layer Index to return.
	* @return Z Value of the layer in mm.
	*/
	virtual LibMCEnv_double GetZValueInMM(const LibMCEnv_uint32 nLayerIndex) = 0;

	/**
	* IToolpathAccessor::GetMetaDataCount - Retrieves the number of metadata nodes in the build file.
	* @return Meta Data information.
	*/
	virtual LibMCEnv_uint32 GetMetaDataCount() = 0;

	/**
	* IToolpathAccessor::GetMetaDataInfo - Returns the namespace and identifier of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @param[out] sNamespace - Namespace of the metadata
	* @param[out] sName - Name of the metadata
	*/
	virtual void GetMetaDataInfo(const LibMCEnv_uint32 nMetaDataIndex, std::string & sNamespace, std::string & sName) = 0;

	/**
	* IToolpathAccessor::GetMetaDataContent - Returns the metadata XML content of the given metadata index.
	* @param[in] nMetaDataIndex - Index of metadata to return (0-based).
	* @return XML Metadata Object
	*/
	virtual IXMLDocumentNode * GetMetaDataContent(const LibMCEnv_uint32 nMetaDataIndex) = 0;

	/**
	* IToolpathAccessor::HasUniqueMetaData - Checks if a metadata exists in the build file.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return Returns true if metadata exists and is unique.
	*/
	virtual bool HasUniqueMetaData(const std::string & sNamespace, const std::string & sName) = 0;

	/**
	* IToolpathAccessor::FindUniqueMetaData - Returns the given metadata XML content of the build file. Fails if metadata content does not exist or is not unique.
	* @param[in] sNamespace - Namespace of the metadata
	* @param[in] sName - Name of the metadata
	* @return XML Metadata Object
	*/
	virtual IXMLDocumentNode * FindUniqueMetaData(const std::string & sNamespace, const std::string & sName) = 0;

};

typedef IBaseSharedPtr<IToolpathAccessor> PIToolpathAccessor;


/*************************************************************************************************************************
 Class interface for Build 
**************************************************************************************************************************/

class IBuild : public virtual IBase {
public:
	/**
	* IBuild::GetName - Returns name of the build.
	* @return Name of the build.
	*/
	virtual std::string GetName() = 0;

	/**
	* IBuild::GetBuildUUID - Returns uuid of the build.
	* @return UUID of the build.
	*/
	virtual std::string GetBuildUUID() = 0;

	/**
	* IBuild::GetStorageUUID - Returns storage uuid of the build.
	* @return Storage UUID of the build.
	*/
	virtual std::string GetStorageUUID() = 0;

	/**
	* IBuild::GetStorageSHA256 - Returns SHA256 of the build stream.
	* @return SHA256 of the build stream.
	*/
	virtual std::string GetStorageSHA256() = 0;

	/**
	* IBuild::GetLayerCount - Returns cached layer count of the toolpath.
	* @return Returns layer count.
	*/
	virtual LibMCEnv_uint32 GetLayerCount() = 0;

	/**
	* IBuild::GetBuildHeightInMM - Retrieves the build height in mm.
	* @return Build height in mm.
	*/
	virtual LibMCEnv_double GetBuildHeightInMM() = 0;

	/**
	* IBuild::GetZValueInMM - Retrieves the layers Z Value in mm.
	* @param[in] nLayerIndex - Layer Index to return.
	* @return Z Value of the layer in mm.
	*/
	virtual LibMCEnv_double GetZValueInMM(const LibMCEnv_uint32 nLayerIndex) = 0;

	/**
	* IBuild::LoadToolpath - loads the a toolpath into memory
	*/
	virtual void LoadToolpath() = 0;

	/**
	* IBuild::UnloadToolpath - unloads the a toolpath from memory, if it has been loaded before.
	*/
	virtual void UnloadToolpath() = 0;

	/**
	* IBuild::ToolpathIsLoaded - checks, if a toolpath object is loaded to memory.
	* @return returns if toolpath is loaded.
	*/
	virtual bool ToolpathIsLoaded() = 0;

	/**
	* IBuild::CreateToolpathAccessor - Creates an accessor object for a toolpath. Toolpath MUST have been loaded with LoadToolpath before.
	* @return Toolpath instance.
	*/
	virtual IToolpathAccessor * CreateToolpathAccessor() = 0;

	/**
	* IBuild::AddBinaryData - Adds binary data to store with the build.
	* @param[in] sIdentifier - Unique identifier of the attached data. Fails if ther already exists a binary data with the equal identifier.
	* @param[in] sName - Name of the attache data
	* @param[in] sMIMEType - Mime type of the data.
	* @param[in] nContentBufferSize - Number of elements in buffer
	* @param[in] pContentBuffer - Stream content to store
	* @return Data UUID of the attachment.
	*/
	virtual std::string AddBinaryData(const std::string & sIdentifier, const std::string & sName, const std::string & sMIMEType, const LibMCEnv_uint64 nContentBufferSize, const LibMCEnv_uint8 * pContentBuffer) = 0;

	/**
	* IBuild::LoadDiscreteField2DByIdentifier - Loads a discrete field by context identifier which was previously stored in the build job. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	virtual IDiscreteFieldData2D * LoadDiscreteField2DByIdentifier(const std::string & sContextIdentifier) = 0;

	/**
	* IBuild::LoadDiscreteField2DByUUID - Loads a discrete field by uuid which previously stored in the build job. MIME Type MUST be application/amcf-discretefield2d.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Loaded field instance.
	*/
	virtual IDiscreteFieldData2D * LoadDiscreteField2DByUUID(const std::string & sDataUUID) = 0;

	/**
	* IBuild::StoreDiscreteField2D - Stores a discrete field in the build job. MIME Type will be application/amcf-discretefield2d.
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] sName - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] pFieldDataInstance - Field instance to store.
	* @param[in] pStoreOptions - Field Data Store Options.
	* @return Data UUID of the attachment.
	*/
	virtual std::string StoreDiscreteField2D(const std::string & sContextIdentifier, const std::string & sName, IDiscreteFieldData2D* pFieldDataInstance, IDiscreteFieldData2DStoreOptions* pStoreOptions) = 0;

	/**
	* IBuild::LoadPNGImageByIdentifier - Loads a discrete field by context identifier which was previously stored in the build job. MIME Type MUST be image/png.
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @return Image data instance.
	*/
	virtual IImageData * LoadPNGImageByIdentifier(const std::string & sContextIdentifier) = 0;

	/**
	* IBuild::LoadPNGImageByUUID - Loads a discrete field by uuid which was previously stored in the build job. MIME Type MUST be image/png.
	* @param[in] sDataUUID - Data UUID of the attachment. Fails if name does not exist or has invalid Mime type.
	* @return Image data instance.
	*/
	virtual IImageData * LoadPNGImageByUUID(const std::string & sDataUUID) = 0;

	/**
	* IBuild::StorePNGImage - Stores a discrete field in the build job. MIME Type will be image/png
	* @param[in] sContextIdentifier - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] sName - Unique name of the build attachment. Fails if name does not exist or has invalid Mime type.
	* @param[in] pImageDataInstance - Image data instance.
	* @param[in] pStoreOptions - PNG Store Options.
	* @return Data UUID of the attachment.
	*/
	virtual std::string StorePNGImage(const std::string & sContextIdentifier, const std::string & sName, IImageData* pImageDataInstance, IPNGImageStoreOptions* pStoreOptions) = 0;

};

typedef IBaseSharedPtr<IBuild> PIBuild;


/*************************************************************************************************************************
 Class interface for WorkingFileExecution 
**************************************************************************************************************************/

class IWorkingFileExecution : public virtual IBase {
public:
	/**
	* IWorkingFileExecution::GetStatus - Returns the execution status
	*/
	virtual void GetStatus() = 0;

	/**
	* IWorkingFileExecution::ReturnStdOut - Returns the output of the executable as string buffer
	* @return stdout buffer
	*/
	virtual std::string ReturnStdOut() = 0;

};

typedef IBaseSharedPtr<IWorkingFileExecution> PIWorkingFileExecution;


/*************************************************************************************************************************
 Class interface for WorkingFile 
**************************************************************************************************************************/

class IWorkingFile : public virtual IBase {
public:
	/**
	* IWorkingFile::GetAbsoluteFileName - Retrieves absolute file name of the working file
	* @return global path of the file
	*/
	virtual std::string GetAbsoluteFileName() = 0;

	/**
	* IWorkingFile::GetSize - Returns the size of temporary file.
	* @return file size
	*/
	virtual LibMCEnv_uint64 GetSize() = 0;

	/**
	* IWorkingFile::CalculateSHA2 - Calculates the SHA256 checksum of the file.
	* @return sha256 checksum
	*/
	virtual std::string CalculateSHA2() = 0;

	/**
	* IWorkingFile::ExecuteFile - Executes the temporary file, if it is an executable.
	* @return execution object
	*/
	virtual IWorkingFileExecution * ExecuteFile() = 0;

	/**
	* IWorkingFile::IsManaged - Returns if the file is managed.
	* @return returns if the file is managed.
	*/
	virtual bool IsManaged() = 0;

	/**
	* IWorkingFile::MakeManaged - Makes the file managed if it is not managed yet.
	*/
	virtual void MakeManaged() = 0;

	/**
	* IWorkingFile::FileExists - Returns if the file exists on disk.
	* @return returns if the file exists.
	*/
	virtual bool FileExists() = 0;

	/**
	* IWorkingFile::DeleteFromDisk - Deletes the temporary file.
	* @return returns if deletion was successful or file did not exist in the first place.
	*/
	virtual bool DeleteFromDisk() = 0;

};

typedef IBaseSharedPtr<IWorkingFile> PIWorkingFile;


/*************************************************************************************************************************
 Class interface for WorkingFileIterator 
**************************************************************************************************************************/

class IWorkingFileIterator : public virtual IIterator {
public:
	/**
	* IWorkingFileIterator::GetCurrentFile - Returns the working file the iterator points at.
	* @return returns the WorkingFile instance.
	*/
	virtual IWorkingFile * GetCurrentFile() = 0;

};

typedef IBaseSharedPtr<IWorkingFileIterator> PIWorkingFileIterator;


/*************************************************************************************************************************
 Class interface for WorkingDirectory 
**************************************************************************************************************************/

class IWorkingDirectory : public virtual IBase {
public:
	/**
	* IWorkingDirectory::IsActive - Working directory is active.
	* @return returns true if files can be read and written to the directory.
	*/
	virtual bool IsActive() = 0;

	/**
	* IWorkingDirectory::GetAbsoluteFilePath - Retrieves absolute file path.
	* @return global path of the directory, including path delimiter.
	*/
	virtual std::string GetAbsoluteFilePath() = 0;

	/**
	* IWorkingDirectory::StoreCustomData - Stores a data buffer in a temporary file with a given name.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[in] pDataBufferBuffer - file data to store to.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreCustomData(const std::string & sFileName, const LibMCEnv_uint64 nDataBufferBufferSize, const LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IWorkingDirectory::StoreCustomString - Stores a string in a temporary file with a given name.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] sDataString - file data to store to.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreCustomString(const std::string & sFileName, const std::string & sDataString) = 0;

	/**
	* IWorkingDirectory::StoreDriverData - Stores attached driver data in a temporary file.
	* @param[in] sFileName - filename to store to. Can not include any path delimiters or ..
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreDriverData(const std::string & sFileName, const std::string & sIdentifier) = 0;

	/**
	* IWorkingDirectory::StoreCustomDataInTempFile - Stores a data buffer in a temporary file with a generated name.
	* @param[in] sExtension - extension of the file to store. MAY be an empty string. MUST only include up to 64 alphanumeric characters.
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[in] pDataBufferBuffer - file data to store to.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreCustomDataInTempFile(const std::string & sExtension, const LibMCEnv_uint64 nDataBufferBufferSize, const LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IWorkingDirectory::StoreCustomStringInTempFile - Stores a string in a temporary file.
	* @param[in] sExtension - extension of the file to store. MAY be an empty string. MUST only include up to 64 alphanumeric characters.
	* @param[in] sDataString - file data to store to.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreCustomStringInTempFile(const std::string & sExtension, const std::string & sDataString) = 0;

	/**
	* IWorkingDirectory::StoreDriverDataInTempFile - Stores attached driver data in a temporary file.
	* @param[in] sExtension - extension of the file to store. MAY be an empty string. MUST only include up to 64 alphanumeric characters.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return working file instance.
	*/
	virtual IWorkingFile * StoreDriverDataInTempFile(const std::string & sExtension, const std::string & sIdentifier) = 0;

	/**
	* IWorkingDirectory::CleanUp - Deletes all managed files in the directory and the directory. No storing is possible after a cleanup.
	* @return returns if deletion was successful.
	*/
	virtual bool CleanUp() = 0;

	/**
	* IWorkingDirectory::AddManagedFile - Adds a managed filename in the directory (i.e. this file will be deleted at CleanUp). Subdirectories are not allowed.
	* @param[in] sFileName - Filename to manage. The file does not need to exist yet.
	* @return working file instance.
	*/
	virtual IWorkingFile * AddManagedFile(const std::string & sFileName) = 0;

	/**
	* IWorkingDirectory::HasUnmanagedFiles - Returns if the working directory has unmanaged files. A clean implementation will never deal with unmanaged files.
	* @return returns if there are unmanaged files.
	*/
	virtual bool HasUnmanagedFiles() = 0;

	/**
	* IWorkingDirectory::RetrieveUnmanagedFiles - Returns a list of unmanaged files.
	* @return working file iterator instance.
	*/
	virtual IWorkingFileIterator * RetrieveUnmanagedFiles() = 0;

	/**
	* IWorkingDirectory::RetrieveManagedFiles - Returns a list of managed files.
	* @return working file iterator instance.
	*/
	virtual IWorkingFileIterator * RetrieveManagedFiles() = 0;

	/**
	* IWorkingDirectory::RetrieveAllFiles - Returns a list of all files in the directory.
	* @return working file iterator instance.
	*/
	virtual IWorkingFileIterator * RetrieveAllFiles() = 0;

};

typedef IBaseSharedPtr<IWorkingDirectory> PIWorkingDirectory;


/*************************************************************************************************************************
 Class interface for XMLDocumentAttribute 
**************************************************************************************************************************/

class IXMLDocumentAttribute : public virtual IBase {
public:
	/**
	* IXMLDocumentAttribute::GetNameSpace - Retrieves namespace of the attribute.
	* @return returns the namespace of the attribute.
	*/
	virtual std::string GetNameSpace() = 0;

	/**
	* IXMLDocumentAttribute::GetName - Retrieves name of the attribute.
	* @return returns the name of the attribute.
	*/
	virtual std::string GetName() = 0;

	/**
	* IXMLDocumentAttribute::GetValue - Retrieves value of the attribute as string.
	* @return returns the value of the attribute.
	*/
	virtual std::string GetValue() = 0;

	/**
	* IXMLDocumentAttribute::IsValidUUID - Checks if the value is a valid UUID string.
	* @return returns if the value is a valid UUID string.
	*/
	virtual bool IsValidUUID() = 0;

	/**
	* IXMLDocumentAttribute::GetUUIDValue - Retrieves value of the attribute as UUID string. Fails if value is not a UUID string.
	* @return returns the value of the attribute as normalized UUID string.
	*/
	virtual std::string GetUUIDValue() = 0;

	/**
	* IXMLDocumentAttribute::IsValidInteger - Checks if the value is a valid integer in the given range.
	* @param[in] nMinValue - Minimum allowed value
	* @param[in] nMaxValue - Maximum allowed value
	* @return returns if the value is a valid integer.
	*/
	virtual bool IsValidInteger(const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue) = 0;

	/**
	* IXMLDocumentAttribute::GetIntegerValue - Returns the value as integer. Fails if the value is not a valid integer in the given range.
	* @param[in] nMinValue - Minimum allowed value
	* @param[in] nMaxValue - Maximum allowed value
	* @return returns the value.
	*/
	virtual LibMCEnv_int64 GetIntegerValue(const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue) = 0;

	/**
	* IXMLDocumentAttribute::IsValidDouble - Checks if the value is a valid double in the given range.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return returns if the value is a valid double.
	*/
	virtual bool IsValidDouble(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue) = 0;

	/**
	* IXMLDocumentAttribute::GetDoubleValue - Returns the value as double. Fails if the value is not a valid double in the given range.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return returns the value .
	*/
	virtual LibMCEnv_double GetDoubleValue(const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue) = 0;

	/**
	* IXMLDocumentAttribute::IsValidBool - Checks if the value is a valid boolean value, meaning an integer or true or false as string. The value will be trimmed and any character will be converted to lowercase.
	* @return returns if the value is a valid bool.
	*/
	virtual bool IsValidBool() = 0;

	/**
	* IXMLDocumentAttribute::GetBoolValue - Returns the value as bool. Fails if the value is not a valid boolean value, meaning an integer or true or false as string. The value will be trimmed and any character will be converted to lowercase.
	* @return returns the value .
	*/
	virtual bool GetBoolValue() = 0;

	/**
	* IXMLDocumentAttribute::SetValue - Sets the value of the attribute as string.
	* @param[in] sValue - new value of the attribute.
	*/
	virtual void SetValue(const std::string & sValue) = 0;

	/**
	* IXMLDocumentAttribute::SetUUIDValue - Sets the value of the attribute as UUID string.
	* @param[in] sValue - new value of the attribute. Fails if Value is not a UUID.
	*/
	virtual void SetUUIDValue(const std::string & sValue) = 0;

	/**
	* IXMLDocumentAttribute::SetIntegerValue - Sets the value of the attribute as integer.
	* @param[in] nValue - new value of the attribute.
	*/
	virtual void SetIntegerValue(const LibMCEnv_int64 nValue) = 0;

	/**
	* IXMLDocumentAttribute::SetDoubleValue - Sets the value of the attribute as double.
	* @param[in] dValue - new value of the attribute.
	*/
	virtual void SetDoubleValue(const LibMCEnv_double dValue) = 0;

	/**
	* IXMLDocumentAttribute::SetBoolValue - Sets the value of the attribute as bool.
	* @param[in] bValue - new value of the attribute.
	*/
	virtual void SetBoolValue(const bool bValue) = 0;

	/**
	* IXMLDocumentAttribute::Remove - Removes the attribute from its parent node. All subsequent calls to the class will fail.
	*/
	virtual void Remove() = 0;

};

typedef IBaseSharedPtr<IXMLDocumentAttribute> PIXMLDocumentAttribute;


/*************************************************************************************************************************
 Class interface for XMLDocumentNode 
**************************************************************************************************************************/

class IXMLDocumentNode : public virtual IBase {
public:
	/**
	* IXMLDocumentNode::GetName - Retrieves name of the node.
	* @return returns the name of the node.
	*/
	virtual std::string GetName() = 0;

	/**
	* IXMLDocumentNode::GetNameSpace - Retrieves namespace of the node.
	* @return returns the namespace of the node.
	*/
	virtual std::string GetNameSpace() = 0;

	/**
	* IXMLDocumentNode::GetTextContent - Retrieves the text content of the node. A node with text content MUST NOT have children.
	* @return returns the text content of the node.
	*/
	virtual std::string GetTextContent() = 0;

	/**
	* IXMLDocumentNode::SetTextContent - Sets the text content of the node. Call will fail if node has children.
	* @param[in] sTextContent - the new text content of the node.
	*/
	virtual void SetTextContent(const std::string & sTextContent) = 0;

	/**
	* IXMLDocumentNode::GetAttributeCount - Returns number of attributes.
	* @return returns the number of attributes.
	*/
	virtual LibMCEnv_uint64 GetAttributeCount() = 0;

	/**
	* IXMLDocumentNode::GetAttribute - Returns attribute instance. Fails if Index is out of range.
	* @param[in] nIndex - Index of the attribute to return (0-based).
	* @return XML Document attribute.
	*/
	virtual IXMLDocumentAttribute * GetAttribute(const LibMCEnv_uint64 nIndex) = 0;

	/**
	* IXMLDocumentNode::HasAttribute - Returns if attribute of a specific name exists.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Returns if the attribute exists.
	*/
	virtual bool HasAttribute(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::FindAttribute - Returns attribute instance of a specific name. 
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] bMustExist - If true, the call fails if attribute does not exist. If falls, the call will return null if the attribute does not exist.
	* @return XML Document attribute.
	*/
	virtual IXMLDocumentAttribute * FindAttribute(const std::string & sNameSpace, const std::string & sName, const bool bMustExist) = 0;

	/**
	* IXMLDocumentNode::GetAttributeValue - Returns string value of an attribute. Fails if attribute does not exist.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Attribute value.
	*/
	virtual std::string GetAttributeValue(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::GetAttributeIntegerValue - Returns integer value of an attribute. Fails if attribute does not exist or attribute is not an integer .
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] nMinValue - Minimum allowed value.
	* @param[in] nMaxValue - Maximum allowed value.
	* @return Attribute value.
	*/
	virtual LibMCEnv_int64 GetAttributeIntegerValue(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeDoubleValue - Returns double value of an attribute. Fails if attribute does not exist or attribute is not a double value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @return Attribute value.
	*/
	virtual LibMCEnv_double GetAttributeDoubleValue(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeBoolValue - Returns bool value of an attribute. Fails if attribute does not exist or attribute is not a boolean value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Attribute value.
	*/
	virtual bool GetAttributeBoolValue(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::GetAttributeUUIDValue - Returns UUID value of an attribute. Fails if attribute does not exist or attribute value is not a UUID.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @return Attribute value.
	*/
	virtual std::string GetAttributeUUIDValue(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::GetAttributeValueDef - Returns string value of an attribute. Returns default value if attribute does not exist.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] sDefaultValue - Default value.
	* @return Attribute value.
	*/
	virtual std::string GetAttributeValueDef(const std::string & sNameSpace, const std::string & sName, const std::string & sDefaultValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeIntegerValueDef - Returns integer value of an attribute. Returns default value if attribute does not exist or attribute is not an integer .
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] nMinValue - Minimum allowed value.
	* @param[in] nMaxValue - Maximum allowed value.
	* @param[in] nDefaultValue - Default value. MUST be in valid range.
	* @return Attribute value.
	*/
	virtual LibMCEnv_int64 GetAttributeIntegerValueDef(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nMinValue, const LibMCEnv_int64 nMaxValue, const LibMCEnv_int64 nDefaultValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeDoubleValueDef - Returns double value of an attribute. Returns default value if attribute does not exist or attribute is not a double value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] dMinValue - Minimum allowed value
	* @param[in] dMaxValue - Maximum allowed value
	* @param[in] dDefaultValue - Default value. MUST be in valid range.
	* @return Attribute value.
	*/
	virtual LibMCEnv_double GetAttributeDoubleValueDef(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dMinValue, const LibMCEnv_double dMaxValue, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeBoolValueDef - Returns bool value of an attribute. Returns default value if attribute does not exist or attribute is not a boolean value.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] bDefaultValue - Default value.
	* @return Attribute value.
	*/
	virtual bool GetAttributeBoolValueDef(const std::string & sNameSpace, const std::string & sName, const bool bDefaultValue) = 0;

	/**
	* IXMLDocumentNode::GetAttributeUUIDValueDef - Returns UUID value of an attribute. Returns default value if attribute does not exist or attribute value is not a UUID.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	* @param[in] sDefaultValue - Attribute value. MUST be a valid UUID
	* @return Attribute value.
	*/
	virtual std::string GetAttributeUUIDValueDef(const std::string & sNameSpace, const std::string & sName, const std::string & sDefaultValue) = 0;

	/**
	* IXMLDocumentNode::RemoveAttribute - Removes the attribute with a specific name. Does nothing if attribute does not exist.
	* @param[in] sNameSpace - Namespace of the attribute. If empty, it inherits the namespace of the node.
	* @param[in] sName - Name of the attribute.
	*/
	virtual void RemoveAttribute(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::RemoveAttributeByIndex - Removes the attribute with a specific index. Does nothing if attribute does not exist.
	* @param[in] nIndex - Index of the attribute to remove (0-based).
	*/
	virtual void RemoveAttributeByIndex(const LibMCEnv_uint64 nIndex) = 0;

	/**
	* IXMLDocumentNode::AddAttribute - Adds an attribute with a specific name and string value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the attribute. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] sValue - Value of the attribute.
	*/
	virtual void AddAttribute(const std::string & sNameSpace, const std::string & sName, const std::string & sValue) = 0;

	/**
	* IXMLDocumentNode::AddIntegerAttribute - Adds an attribute with a specific name and integer value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the attribute. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] nValue - Value of the attribute.
	*/
	virtual void AddIntegerAttribute(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IXMLDocumentNode::AddDoubleAttribute - Adds an attribute with a specific name and double value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] dValue - Value of the attribute.
	*/
	virtual void AddDoubleAttribute(const std::string & sNameSpace, const std::string & sName, const LibMCEnv_double dValue) = 0;

	/**
	* IXMLDocumentNode::AddBoolAttribute - Adds an attribute with a specific name and bool value. Fails if attribute already exists.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the attribute.
	* @param[in] bValue - Value of the attribute.
	*/
	virtual void AddBoolAttribute(const std::string & sNameSpace, const std::string & sName, const bool bValue) = 0;

	/**
	* IXMLDocumentNode::GetChildren - Returns all the child nodes of the XML Node.
	* @return returns the list of child nodes.
	*/
	virtual IXMLDocumentNodes * GetChildren() = 0;

	/**
	* IXMLDocumentNode::CountChildrenByName - Returns how many children of the XML Node have a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns the number children with the specified name.
	*/
	virtual LibMCEnv_uint64 CountChildrenByName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::GetChildrenByName - Returns all the child nodes of the XML Node with a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns the list of child nodes.
	*/
	virtual IXMLDocumentNodes * GetChildrenByName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::HasChild - Returns if a child with a specific name exist.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns if a child with a specific name exists.
	*/
	virtual bool HasChild(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::HasUniqueChild - Returns if a child with a specific name exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns if a child with a specific name exists once and only once.
	*/
	virtual bool HasUniqueChild(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::FindChild - Returns child with a specific name. Throws an error if name does not exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @param[in] bMustExist - If true, the call fails if child does not exist. If falls, the call will return null if the child does not exist.
	* @return returns child instance or null.
	*/
	virtual IXMLDocumentNode * FindChild(const std::string & sNameSpace, const std::string & sName, const bool bMustExist) = 0;

	/**
	* IXMLDocumentNode::AddChild - Adds a new child with a specific name. Fails if node has a non-empty text content.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @return returns child instance.
	*/
	virtual IXMLDocumentNode * AddChild(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::AddChildText - Adds a new child with text content and a specific name. Fails if node has a non-empty text content.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the child.
	* @param[in] sTextContent - Text content of the child.
	* @return returns child instance.
	*/
	virtual IXMLDocumentNode * AddChildText(const std::string & sNameSpace, const std::string & sName, const std::string & sTextContent) = 0;

	/**
	* IXMLDocumentNode::RemoveChild - Removes a child with a specific name. All subsequent calls to the child will fail after the call.
	* @param[in] pChildInstance - child instance to remove. Fails if given instance is not a child of the node.
	*/
	virtual void RemoveChild(IXMLDocumentNode* pChildInstance) = 0;

	/**
	* IXMLDocumentNode::RemoveChildrenWithName - Removes all children with a specific name. Does nothing if no child with the name exists. . All subsequent calls to the deleted children will fail after the call.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the children.
	*/
	virtual void RemoveChildrenWithName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNode::Remove - Removes the node from its parent. The root node of the document can not be removed.
	*/
	virtual void Remove() = 0;

};

typedef IBaseSharedPtr<IXMLDocumentNode> PIXMLDocumentNode;


/*************************************************************************************************************************
 Class interface for XMLDocumentNodes 
**************************************************************************************************************************/

class IXMLDocumentNodes : public virtual IBase {
public:
	/**
	* IXMLDocumentNodes::GetNodeCount - Returns number of nodes.
	* @return returns the number of nodes in the list.
	*/
	virtual LibMCEnv_uint64 GetNodeCount() = 0;

	/**
	* IXMLDocumentNodes::GetNode - Returns node instance. Fails if Index is out of range.
	* @param[in] nIndex - Index of the node to return (0-based).
	* @return XML Node node.
	*/
	virtual IXMLDocumentNode * GetNode(const LibMCEnv_uint64 nIndex) = 0;

	/**
	* IXMLDocumentNodes::CountNodesByName - Returns how many nodes of the XML Node have a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns the number of nodes with the specified name.
	*/
	virtual LibMCEnv_uint64 CountNodesByName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNodes::GetNodesByName - Returns all the nodes nodes of the XML Node with a specific name.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns the list of node nodes.
	*/
	virtual IXMLDocumentNodes * GetNodesByName(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNodes::HasNode - Returns if a node with a specific name exist.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns if a node with a specific name exists.
	*/
	virtual bool HasNode(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNodes::HasUniqueNode - Returns if a node with a specific name exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @return returns if a node with a specific name exists once and only once.
	*/
	virtual bool HasUniqueNode(const std::string & sNameSpace, const std::string & sName) = 0;

	/**
	* IXMLDocumentNodes::FindNode - Returns node with a specific name. Throws an error if name does not exist once and only once.
	* @param[in] sNameSpace - New namespace of the child. MUST be either an empty string for the root namespace, or previously being registered with the document.
	* @param[in] sName - Name of the node.
	* @param[in] bMustExist - If true, the call fails if node does not exist. If falls, the call will return null if the node does not exist.
	* @return returns node instance.
	*/
	virtual IXMLDocumentNode * FindNode(const std::string & sNameSpace, const std::string & sName, const bool bMustExist) = 0;

};

typedef IBaseSharedPtr<IXMLDocumentNodes> PIXMLDocumentNodes;


/*************************************************************************************************************************
 Class interface for XMLDocument 
**************************************************************************************************************************/

class IXMLDocument : public virtual IBase {
public:
	/**
	* IXMLDocument::GetDefaultNamespace - Returns default name space of the document.
	* @return name space of the document.
	*/
	virtual std::string GetDefaultNamespace() = 0;

	/**
	* IXMLDocument::GetNamespaceCount - Returns the used number of name spaces of the document.
	* @return number of registered name spaces of the document.
	*/
	virtual LibMCEnv_uint64 GetNamespaceCount() = 0;

	/**
	* IXMLDocument::GetNamespace - Returns a name space of the document. Will fail if index is invalid.
	* @param[in] nIndex - index of name space. 0-based.
	* @param[out] sNamespace - name space of the document.
	* @param[out] sNamespacePrefix - name space prefix of the document. Empty for root namespace.
	*/
	virtual void GetNamespace(const LibMCEnv_uint64 nIndex, std::string & sNamespace, std::string & sNamespacePrefix) = 0;

	/**
	* IXMLDocument::HasNamespace - Returns if the document has a namespace.
	* @param[in] sNamespace - Name space name.
	* @return name space has been registered.
	*/
	virtual bool HasNamespace(const std::string & sNamespace) = 0;

	/**
	* IXMLDocument::GetNamespacePrefix - Returns a name space of the document. Will fail if namespace is not registered.
	* @param[in] sNamespace - name space of the document.
	* @return name space prefix of the document. Empty for root namespace.
	*/
	virtual std::string GetNamespacePrefix(const std::string & sNamespace) = 0;

	/**
	* IXMLDocument::RegisterNamespace - Registers a custom namespace prefix. Given Namespace MUST NOT have been in use before calling this function.
	* @param[in] sNamespace - name space to register
	* @param[in] sNamespacePrefix - name space prefix to use for the namespace. MUST NOT be in use, MUST NOT be an empty string or contain non-alphanumeric characters.
	*/
	virtual void RegisterNamespace(const std::string & sNamespace, const std::string & sNamespacePrefix) = 0;

	/**
	* IXMLDocument::ChangeNamespacePrefix - Changes the prefix of an existing Namespace. New Namespace MUST NOT have been in use before calling this function.
	* @param[in] sOldNamespacePrefix - name space prefix that is currently in use.
	* @param[in] sNewNamespacePrefix - name space prefix to use for the namespace. MUST NOT be in use, MUST NOT be an empty string or contain non-alphanumeric characters.
	*/
	virtual void ChangeNamespacePrefix(const std::string & sOldNamespacePrefix, const std::string & sNewNamespacePrefix) = 0;

	/**
	* IXMLDocument::GetRootNode - Returns root node of the document.
	* @return Root node of the document.
	*/
	virtual IXMLDocumentNode * GetRootNode() = 0;

	/**
	* IXMLDocument::SaveToString - Saves the XML document into a string.
	* @param[in] bAddLineBreaks - If true, line breaks and indentation will be added to the output string.
	* @return String with the XML Content.
	*/
	virtual std::string SaveToString(const bool bAddLineBreaks) = 0;

};

typedef IBaseSharedPtr<IXMLDocument> PIXMLDocument;


/*************************************************************************************************************************
 Class interface for TCPIPPacket 
**************************************************************************************************************************/

class ITCPIPPacket : public virtual IBase {
public:
	/**
	* ITCPIPPacket::IsEmpty - Returns if packet is empty.
	* @return Flag if packet is empty.
	*/
	virtual bool IsEmpty() = 0;

	/**
	* ITCPIPPacket::GetSize - Returns the size of the packet. Returns 0 if packet is empty.
	* @return returns size of packet.
	*/
	virtual LibMCEnv_uint32 GetSize() = 0;

	/**
	* ITCPIPPacket::GetData - Returns the data of the packet. Fails if packet is empty.
	* @param[in] nBufferBufferSize - Number of elements in buffer
	* @param[out] pBufferNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pBufferBuffer - uint8 buffer of packet data.
	*/
	virtual void GetData(LibMCEnv_uint64 nBufferBufferSize, LibMCEnv_uint64* pBufferNeededCount, LibMCEnv_uint8 * pBufferBuffer) = 0;

};

typedef IBaseSharedPtr<ITCPIPPacket> PITCPIPPacket;


/*************************************************************************************************************************
 Class interface for TCPIPConnection 
**************************************************************************************************************************/

class ITCPIPConnection : public virtual IBase {
public:
	/**
	* ITCPIPConnection::GetIPAddress - Returns the IP Address of the Connection.
	* @return IP Address.
	*/
	virtual std::string GetIPAddress() = 0;

	/**
	* ITCPIPConnection::GetPort - Returns the Port of the Connection.
	* @return Port.
	*/
	virtual LibMCEnv_uint32 GetPort() = 0;

	/**
	* ITCPIPConnection::GetTimeout - Returns the Timeout of the Connection.
	* @return Timeout in milliseconds.
	*/
	virtual LibMCEnv_uint32 GetTimeout() = 0;

	/**
	* ITCPIPConnection::IsConnected - Returns if the instance is connected.
	* @return .
	*/
	virtual bool IsConnected() = 0;

	/**
	* ITCPIPConnection::Disconnect - Disconnects from the Server, if connected.
	*/
	virtual void Disconnect() = 0;

	/**
	* ITCPIPConnection::Reconnect - Disconnects and Connects to the Server.
	*/
	virtual void Reconnect() = 0;

	/**
	* ITCPIPConnection::SendBuffer - Sends a buffer of bytes to the Server.
	* @param[in] nBufferBufferSize - Number of elements in buffer
	* @param[in] pBufferBuffer - packet payload.
	*/
	virtual void SendBuffer(const LibMCEnv_uint64 nBufferBufferSize, const LibMCEnv_uint8 * pBufferBuffer) = 0;

	/**
	* ITCPIPConnection::WaitForData - Waits for a server packet to arrive.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return Flag if a new packet has arrived.
	*/
	virtual bool WaitForData(const LibMCEnv_uint32 nTimeOutInMS) = 0;

	/**
	* ITCPIPConnection::ReceiveFixedPacket - Receives a fixed length packet. Blocks until expected number of bytes arrives or timeout is hit. Fails if there is a connection error. Returns empty packet if timeout is hit.
	* @param[in] nPacketSize - Size of packet to receive. MUST be larger than 0.
	* @param[in] nTimeOutInMS - Timeout in Milliseconds.
	* @return Packet instance. Returns empty packet if timeout is hit
	*/
	virtual ITCPIPPacket * ReceiveFixedPacket(const LibMCEnv_uint32 nPacketSize, const LibMCEnv_uint32 nTimeOutInMS) = 0;

	/**
	* ITCPIPConnection::ReceiveData - Receives data. Fails if there is a connection error. Returns empty packet if timeout is hit.
	* @param[in] nDataSize - Size of data to receive.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return Packet instance. Size will be between 0 and DataSize.
	*/
	virtual ITCPIPPacket * ReceiveData(const LibMCEnv_uint32 nDataSize, const LibMCEnv_uint32 nTimeOutInMS) = 0;

};

typedef IBaseSharedPtr<ITCPIPConnection> PITCPIPConnection;


/*************************************************************************************************************************
 Class interface for ModbusTCPDigitalIOStatus 
**************************************************************************************************************************/

class IModbusTCPDigitalIOStatus : public virtual IBase {
public:
	/**
	* IModbusTCPDigitalIOStatus::GetCount - Returns the number of Digital IOs in the instance.
	* @return Count.
	*/
	virtual LibMCEnv_uint32 GetCount() = 0;

	/**
	* IModbusTCPDigitalIOStatus::GetBaseAddress - Returns the base address of Digital IOs in the instance.
	* @return Base Address.
	*/
	virtual LibMCEnv_uint32 GetBaseAddress() = 0;

	/**
	* IModbusTCPDigitalIOStatus::GetValue - Returns the cached state of the Digital IO in the instance.
	* @param[in] nIndex - Index of IO Value. 0-based.
	* @return State Value.
	*/
	virtual bool GetValue(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IModbusTCPDigitalIOStatus::GetValues - Returns all Digital IOs of the instance as byte array.
	* @param[in] nStateArrayBufferSize - Number of elements in buffer
	* @param[out] pStateArrayNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pStateArrayBuffer - uint8 buffer of State Value Array.
	*/
	virtual void GetValues(LibMCEnv_uint64 nStateArrayBufferSize, LibMCEnv_uint64* pStateArrayNeededCount, LibMCEnv_uint8 * pStateArrayBuffer) = 0;

};

typedef IBaseSharedPtr<IModbusTCPDigitalIOStatus> PIModbusTCPDigitalIOStatus;


/*************************************************************************************************************************
 Class interface for ModbusTCPRegisterStatus 
**************************************************************************************************************************/

class IModbusTCPRegisterStatus : public virtual IBase {
public:
	/**
	* IModbusTCPRegisterStatus::GetCount - Returns the number of registers in the instance.
	* @return Count.
	*/
	virtual LibMCEnv_uint32 GetCount() = 0;

	/**
	* IModbusTCPRegisterStatus::GetBaseAddress - Returns the base address of registers in the instance.
	* @return Base Address.
	*/
	virtual LibMCEnv_uint32 GetBaseAddress() = 0;

	/**
	* IModbusTCPRegisterStatus::GetValue - Returns the cached state of the registers in the instance.
	* @param[in] nIndex - Index of IO Value. 0-based.
	* @return State Value.
	*/
	virtual LibMCEnv_uint16 GetValue(const LibMCEnv_uint32 nIndex) = 0;

	/**
	* IModbusTCPRegisterStatus::GetValues - Returns all registers of the instance as word array.
	* @param[in] nStateArrayBufferSize - Number of elements in buffer
	* @param[out] pStateArrayNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pStateArrayBuffer - uint16 buffer of State Value Array.
	*/
	virtual void GetValues(LibMCEnv_uint64 nStateArrayBufferSize, LibMCEnv_uint64* pStateArrayNeededCount, LibMCEnv_uint16 * pStateArrayBuffer) = 0;

};

typedef IBaseSharedPtr<IModbusTCPRegisterStatus> PIModbusTCPRegisterStatus;


/*************************************************************************************************************************
 Class interface for ModbusTCPConnection 
**************************************************************************************************************************/

class IModbusTCPConnection : public virtual IBase {
public:
	/**
	* IModbusTCPConnection::GetIPAddress - Returns the IP Address of the Connection.
	* @return IP Address.
	*/
	virtual std::string GetIPAddress() = 0;

	/**
	* IModbusTCPConnection::GetPort - Returns the Port of the Connection.
	* @return Port.
	*/
	virtual LibMCEnv_uint32 GetPort() = 0;

	/**
	* IModbusTCPConnection::GetTimeout - Returns the Timeout of the Connection.
	* @return Timeout in milliseconds.
	*/
	virtual LibMCEnv_uint32 GetTimeout() = 0;

	/**
	* IModbusTCPConnection::IsConnected - Returns if the instance is connected.
	* @return .
	*/
	virtual bool IsConnected() = 0;

	/**
	* IModbusTCPConnection::Disconnect - Disconnects from the Server.
	*/
	virtual void Disconnect() = 0;

	/**
	* IModbusTCPConnection::Reconnect - Disconnects and Connects to the Server.
	*/
	virtual void Reconnect() = 0;

	/**
	* IModbusTCPConnection::DiagnosisCall - Sends a diagnosis call to the Server.
	* @param[in] nSubFunction - Modbus TCP Subfunction ID.
	* @param[in] nDataField - Modbus TCP Data Field.
	* @return Modbus TCP Data Response.
	*/
	virtual LibMCEnv_uint16 DiagnosisCall(const LibMCEnv_uint16 nSubFunction, const LibMCEnv_uint16 nDataField) = 0;

	/**
	* IModbusTCPConnection::ReadCoilStatus - Reads coil status of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBitCount - Number of coils to read. MUST be larger than 0.
	* @return Coil status instance.
	*/
	virtual IModbusTCPDigitalIOStatus * ReadCoilStatus(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nBitCount) = 0;

	/**
	* IModbusTCPConnection::ReadInputStatus - Reads input status of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBitCount - Number of inputs to read. MUST be larger than 0.
	* @return Input status instance.
	*/
	virtual IModbusTCPDigitalIOStatus * ReadInputStatus(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nBitCount) = 0;

	/**
	* IModbusTCPConnection::ReadHoldingRegisters - Reads holding registers of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nRegisterCount - Number of registers. MUST be larger than 0.
	* @return Holding register instance.
	*/
	virtual IModbusTCPRegisterStatus * ReadHoldingRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nRegisterCount) = 0;

	/**
	* IModbusTCPConnection::ReadInputRegisters - Reads input registers of Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nRegisterCount - Number of registers. MUST be larger than 0.
	* @return Input register instance.
	*/
	virtual IModbusTCPRegisterStatus * ReadInputRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint32 nRegisterCount) = 0;

	/**
	* IModbusTCPConnection::ForceMultipleCoils - Forces multiple coils on Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBufferBufferSize - Number of elements in buffer
	* @param[in] pBufferBuffer - Input coil array. One byte per Input. MUST NOT be empty
	*/
	virtual void ForceMultipleCoils(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint64 nBufferBufferSize, const LibMCEnv_uint8 * pBufferBuffer) = 0;

	/**
	* IModbusTCPConnection::PresetMultipleRegisters - Forces multiple registers on Server.
	* @param[in] nStartAddress - Start Address.
	* @param[in] nBufferBufferSize - Number of elements in buffer
	* @param[in] pBufferBuffer - Input register array. One word per Input. MUST NOT be empty
	*/
	virtual void PresetMultipleRegisters(const LibMCEnv_uint32 nStartAddress, const LibMCEnv_uint64 nBufferBufferSize, const LibMCEnv_uint16 * pBufferBuffer) = 0;

};

typedef IBaseSharedPtr<IModbusTCPConnection> PIModbusTCPConnection;


/*************************************************************************************************************************
 Class interface for DriverStatusUpdateSession 
**************************************************************************************************************************/

class IDriverStatusUpdateSession : public virtual IBase {
public:
	/**
	* IDriverStatusUpdateSession::SetStringParameter - sets a string parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetStringParameter(const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IDriverStatusUpdateSession::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetUUIDParameter(const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IDriverStatusUpdateSession::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	virtual void SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue) = 0;

	/**
	* IDriverStatusUpdateSession::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	virtual void SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IDriverStatusUpdateSession::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	virtual void SetBoolParameter(const std::string & sParameterName, const bool bValue) = 0;

	/**
	* IDriverStatusUpdateSession::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	virtual void LogMessage(const std::string & sLogString) = 0;

	/**
	* IDriverStatusUpdateSession::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	virtual void LogWarning(const std::string & sLogString) = 0;

	/**
	* IDriverStatusUpdateSession::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	virtual void LogInfo(const std::string & sLogString) = 0;

	/**
	* IDriverStatusUpdateSession::Sleep - Sleeps for a definite amount of time.
	* @param[in] nDelay - Milliseconds to sleep.
	*/
	virtual void Sleep(const LibMCEnv_uint32 nDelay) = 0;

};

typedef IBaseSharedPtr<IDriverStatusUpdateSession> PIDriverStatusUpdateSession;


/*************************************************************************************************************************
 Class interface for DriverEnvironment 
**************************************************************************************************************************/

class IDriverEnvironment : public virtual IBase {
public:
	/**
	* IDriverEnvironment::CreateStatusUpdateSession - creates a status update object which can be easily called from an independent thread.
	* @return creates a status update instance
	*/
	virtual IDriverStatusUpdateSession * CreateStatusUpdateSession() = 0;

	/**
	* IDriverEnvironment::CreateWorkingDirectory - creates a temporary working directory.
	* @return creates a working directory
	*/
	virtual IWorkingDirectory * CreateWorkingDirectory() = 0;

	/**
	* IDriverEnvironment::CreateTCPIPConnection - creates a TCP/IP Connection for a specific IP address and port.
	* @param[in] sIPAddress - IP Address.
	* @param[in] nPort - Port.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return connects to the given IP Address
	*/
	virtual ITCPIPConnection * CreateTCPIPConnection(const std::string & sIPAddress, const LibMCEnv_uint32 nPort, const LibMCEnv_uint32 nTimeOutInMS) = 0;

	/**
	* IDriverEnvironment::CreateModbusTCPConnection - creates a Modbus TCP Connection for a specific IP address and port.
	* @param[in] sIPAddress - IP Address.
	* @param[in] nPort - Port.
	* @param[in] nTimeOutInMS - timeout in Milliseconds.
	* @return connects to the given IP Address
	*/
	virtual IModbusTCPConnection * CreateModbusTCPConnection(const std::string & sIPAddress, const LibMCEnv_uint32 nPort, const LibMCEnv_uint32 nTimeOutInMS) = 0;

	/**
	* IDriverEnvironment::CreateXMLDocument - creates an empty XML Document.
	* @param[in] sRootNodeName - Name of the root node. MUST be a valid XML Node Name string.
	* @param[in] sDefaultNamespace - Default namespace of the document. MUST be a valid XML namespace string.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace) = 0;

	/**
	* IDriverEnvironment::ParseXMLString - parses an XML String and returns an XML Document instance. Throws an error if XML is malformatted.
	* @param[in] sXMLString - XML String.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLString(const std::string & sXMLString) = 0;

	/**
	* IDriverEnvironment::ParseXMLData - parses a XML stored in a byte array and returns an XML Document instance. . Throws an error if XML is malformatted.
	* @param[in] nXMLDataBufferSize - Number of elements in buffer
	* @param[in] pXMLDataBuffer - XML Binary data.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLData(const LibMCEnv_uint64 nXMLDataBufferSize, const LibMCEnv_uint8 * pXMLDataBuffer) = 0;

	/**
	* IDriverEnvironment::DriverHasResourceData - retrieves if attached driver has data with the given identifier.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return returns true if the resource exists in the machine resource package.
	*/
	virtual bool DriverHasResourceData(const std::string & sIdentifier) = 0;

	/**
	* IDriverEnvironment::MachineHasResourceData - retrieves if attached driver has data with the given identifier.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @return returns true if the resource exists in the machine resource package.
	*/
	virtual bool MachineHasResourceData(const std::string & sIdentifier) = 0;

	/**
	* IDriverEnvironment::RetrieveDriverData - retrieves attached driver resource data into a memory buffer. (depreciated, equivalent to RetrieveDriverResourceData)
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[out] pDataBufferNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pDataBufferBuffer - uint8 buffer of buffer data.
	*/
	virtual void RetrieveDriverData(const std::string & sIdentifier, LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IDriverEnvironment::RetrieveDriverResourceData - retrieves attached driver resource data into a memory buffer.
	* @param[in] sIdentifier - identifier of the binary data in the driver package.
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[out] pDataBufferNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pDataBufferBuffer - uint8 buffer of buffer data.
	*/
	virtual void RetrieveDriverResourceData(const std::string & sIdentifier, LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IDriverEnvironment::RetrieveMachineResourceData - retrieves a machine resource data (Plugins Directory) driver data into a memory buffer.
	* @param[in] sIdentifier - identifier of the binary data in the machine resource package.
	* @param[in] nDataBufferBufferSize - Number of elements in buffer
	* @param[out] pDataBufferNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pDataBufferBuffer - uint8 buffer of buffer data.
	*/
	virtual void RetrieveMachineResourceData(const std::string & sIdentifier, LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer) = 0;

	/**
	* IDriverEnvironment::CreateToolpathAccessor - Creates an accessor object for a toolpath. Toolpath MUST have been loaded into memory before.
	* @param[in] sStreamUUID - UUID of the stream.
	* @return Toolpath instance.
	*/
	virtual IToolpathAccessor * CreateToolpathAccessor(const std::string & sStreamUUID) = 0;

	/**
	* IDriverEnvironment::ParameterNameIsValid - checks if a name is a valid alphanumerical string for parameters.
	* @param[in] sParameterName - Parameter Name
	* @return returns true if the parameter name is a valid name.
	*/
	virtual bool ParameterNameIsValid(const std::string & sParameterName) = 0;

	/**
	* IDriverEnvironment::RegisterStringParameter - registers a string parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] sDefaultValue - default value to set
	*/
	virtual void RegisterStringParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue) = 0;

	/**
	* IDriverEnvironment::RegisterUUIDParameter - registers a uuid parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] sDefaultValue - default value to set
	*/
	virtual void RegisterUUIDParameter(const std::string & sParameterName, const std::string & sDescription, const std::string & sDefaultValue) = 0;

	/**
	* IDriverEnvironment::RegisterDoubleParameter - registers a double parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] dDefaultValue - default value to set
	*/
	virtual void RegisterDoubleParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IDriverEnvironment::RegisterIntegerParameter - registers an int parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] nDefaultValue - default value to set
	*/
	virtual void RegisterIntegerParameter(const std::string & sParameterName, const std::string & sDescription, const LibMCEnv_int64 nDefaultValue) = 0;

	/**
	* IDriverEnvironment::RegisterBoolParameter - registers a bool parameter. Must only be called during driver creation.
	* @param[in] sParameterName - Parameter Name
	* @param[in] sDescription - Parameter Description
	* @param[in] bDefaultValue - default value to set
	*/
	virtual void RegisterBoolParameter(const std::string & sParameterName, const std::string & sDescription, const bool bDefaultValue) = 0;

	/**
	* IDriverEnvironment::SetStringParameter - sets a string parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetStringParameter(const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IDriverEnvironment::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetUUIDParameter(const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IDriverEnvironment::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	virtual void SetDoubleParameter(const std::string & sParameterName, const LibMCEnv_double dValue) = 0;

	/**
	* IDriverEnvironment::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	virtual void SetIntegerParameter(const std::string & sParameterName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IDriverEnvironment::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	virtual void SetBoolParameter(const std::string & sParameterName, const bool bValue) = 0;

	/**
	* IDriverEnvironment::Sleep - Puts the current instance to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	virtual void Sleep(const LibMCEnv_uint32 nDelay) = 0;

	/**
	* IDriverEnvironment::GetGlobalTimerInMilliseconds - Returns the global timer in milliseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetGlobalTimerInMilliseconds() = 0;

	/**
	* IDriverEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	virtual void LogMessage(const std::string & sLogString) = 0;

	/**
	* IDriverEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	virtual void LogWarning(const std::string & sLogString) = 0;

	/**
	* IDriverEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	virtual void LogInfo(const std::string & sLogString) = 0;

	/**
	* IDriverEnvironment::CreateEmptyImage - creates an empty image object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use.
	* @return Empty image instance.
	*/
	virtual IImageData * CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IDriverEnvironment::LoadPNGImage - creates an image object from a PNG data stream.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[in] pPNGDataBuffer - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image instance containing the PNG image.
	*/
	virtual IImageData * LoadPNGImage(const LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IDriverEnvironment::CreateDiscreteField2D - Creates an empty discrete field.
	* @param[in] nPixelCountX - Pixel count in X. MUST be positive.
	* @param[in] nPixelCountY - Pixel count in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @param[in] dDefaultValue - Default value of the field.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IDriverEnvironment::CreateDiscreteField2DFromImage - Creates a discrete field from the greyscale values of an image. RGB colors in the image will be averaged to obtain a greyscale color.
	* @param[in] pImageDataInstance - Image instance containing the pixel data.
	* @param[in] dBlackValue - Value that the minimum color (black) shall be mapped to.
	* @param[in] dWhiteValue - Value that the maximum color (white) shall be mapped to.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2DFromImage(IImageData* pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY) = 0;

	/**
	* IDriverEnvironment::HasBuildJob - Returns if a build object exists. Fails if BuildUUID is not a valid UUID string.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Returns true if build exists
	*/
	virtual bool HasBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IDriverEnvironment::GetBuildJob - Returns a instance of a build object. Fails if build uuid does not exist.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	virtual IBuild * GetBuildJob(const std::string & sBuildUUID) = 0;

};

typedef IBaseSharedPtr<IDriverEnvironment> PIDriverEnvironment;


/*************************************************************************************************************************
 Class interface for SignalTrigger 
**************************************************************************************************************************/

class ISignalTrigger : public virtual IBase {
public:
	/**
	* ISignalTrigger::CanTrigger - Returns, if signal channel is available.
	* @return Returns true, if signal channel is available.
	*/
	virtual bool CanTrigger() = 0;

	/**
	* ISignalTrigger::Trigger - Triggers a signal, if signal channel is available.
	*/
	virtual void Trigger() = 0;

	/**
	* ISignalTrigger::WaitForHandling - Waits until the signal is reset.
	* @param[in] nTimeOut - Timeout in Milliseconds. 0 for Immediate return.
	* @return Flag if signal handling has been handled.
	*/
	virtual bool WaitForHandling(const LibMCEnv_uint32 nTimeOut) = 0;

	/**
	* ISignalTrigger::GetName - Returns the signal name.
	* @return Name Of Signal
	*/
	virtual std::string GetName() = 0;

	/**
	* ISignalTrigger::GetStateMachine - Returns the signal state machine instance.
	* @return Name Of State Machine
	*/
	virtual std::string GetStateMachine() = 0;

	/**
	* ISignalTrigger::SetString - sets a string value
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	virtual void SetString(const std::string & sName, const std::string & sValue) = 0;

	/**
	* ISignalTrigger::SetUUID - sets a uuid value
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	virtual void SetUUID(const std::string & sName, const std::string & sValue) = 0;

	/**
	* ISignalTrigger::SetDouble - sets a double
	* @param[in] sName - Name
	* @param[in] dValue - Value
	*/
	virtual void SetDouble(const std::string & sName, const LibMCEnv_double dValue) = 0;

	/**
	* ISignalTrigger::SetInteger - sets an int.
	* @param[in] sName - Name
	* @param[in] nValue - Value
	*/
	virtual void SetInteger(const std::string & sName, const LibMCEnv_int64 nValue) = 0;

	/**
	* ISignalTrigger::SetBool - sets a bool
	* @param[in] sName - Name
	* @param[in] bValue - Value
	*/
	virtual void SetBool(const std::string & sName, const bool bValue) = 0;

	/**
	* ISignalTrigger::GetStringResult - returns a string value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	virtual std::string GetStringResult(const std::string & sName) = 0;

	/**
	* ISignalTrigger::GetUUIDResult - returns a uuid value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	virtual std::string GetUUIDResult(const std::string & sName) = 0;

	/**
	* ISignalTrigger::GetDoubleResult - returns a string value of the result
	* @param[in] sName - Name
	* @return Value
	*/
	virtual LibMCEnv_double GetDoubleResult(const std::string & sName) = 0;

	/**
	* ISignalTrigger::GetIntegerResult - returns an int value of the result.
	* @param[in] sName - Name
	* @return Value
	*/
	virtual LibMCEnv_int64 GetIntegerResult(const std::string & sName) = 0;

	/**
	* ISignalTrigger::GetBoolResult - returns a bool value of the result.
	* @param[in] sName - Name
	* @return Value
	*/
	virtual bool GetBoolResult(const std::string & sName) = 0;

};

typedef IBaseSharedPtr<ISignalTrigger> PISignalTrigger;


/*************************************************************************************************************************
 Class interface for SignalHandler 
**************************************************************************************************************************/

class ISignalHandler : public virtual IBase {
public:
	/**
	* ISignalHandler::SignalHandled - Marks signal as handled and resets signal channel.
	*/
	virtual void SignalHandled() = 0;

	/**
	* ISignalHandler::GetName - Returns the signal name.
	* @return Name Of Signal
	*/
	virtual std::string GetName() = 0;

	/**
	* ISignalHandler::GetSignalID - Returns the signal id. Depreciated.
	* @return Signal Identifier
	*/
	virtual std::string GetSignalID() = 0;

	/**
	* ISignalHandler::GetSignalUUID - Returns the signal uuid. Identical to GetSignalID.
	* @return Signal Identifier
	*/
	virtual std::string GetSignalUUID() = 0;

	/**
	* ISignalHandler::GetStateMachine - Returns the signal state machine instance.
	* @return Name Of State Machine
	*/
	virtual std::string GetStateMachine() = 0;

	/**
	* ISignalHandler::GetString - gets a string value
	* @param[in] sName - Name
	* @return Value
	*/
	virtual std::string GetString(const std::string & sName) = 0;

	/**
	* ISignalHandler::GetUUID - gets a uuid value
	* @param[in] sName - Name
	* @return Value
	*/
	virtual std::string GetUUID(const std::string & sName) = 0;

	/**
	* ISignalHandler::GetDouble - gets a double
	* @param[in] sName - Name
	* @return Value
	*/
	virtual LibMCEnv_double GetDouble(const std::string & sName) = 0;

	/**
	* ISignalHandler::GetInteger - gets an int.
	* @param[in] sName - Name
	* @return Value
	*/
	virtual LibMCEnv_int64 GetInteger(const std::string & sName) = 0;

	/**
	* ISignalHandler::GetBool - gets a bool
	* @param[in] sName - Name
	* @return Value
	*/
	virtual bool GetBool(const std::string & sName) = 0;

	/**
	* ISignalHandler::SetStringResult - returns a string value of the result
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	virtual void SetStringResult(const std::string & sName, const std::string & sValue) = 0;

	/**
	* ISignalHandler::SetUUIDResult - returns a uuid value of the result
	* @param[in] sName - Name
	* @param[in] sValue - Value
	*/
	virtual void SetUUIDResult(const std::string & sName, const std::string & sValue) = 0;

	/**
	* ISignalHandler::SetDoubleResult - returns a string value of the result
	* @param[in] sName - Name
	* @param[in] dValue - Value
	*/
	virtual void SetDoubleResult(const std::string & sName, const LibMCEnv_double dValue) = 0;

	/**
	* ISignalHandler::SetIntegerResult - sets an int.
	* @param[in] sName - Name
	* @param[in] nValue - Value
	*/
	virtual void SetIntegerResult(const std::string & sName, const LibMCEnv_int64 nValue) = 0;

	/**
	* ISignalHandler::SetBoolResult - sets a bool
	* @param[in] sName - Name
	* @param[in] bValue - Value
	*/
	virtual void SetBoolResult(const std::string & sName, const bool bValue) = 0;

};

typedef IBaseSharedPtr<ISignalHandler> PISignalHandler;


/*************************************************************************************************************************
 Class interface for UniformJournalSampling 
**************************************************************************************************************************/

class IUniformJournalSampling : public virtual IBase {
public:
	/**
	* IUniformJournalSampling::GetVariableName - returns the name of the recorded variable.
	* @return Path or name.
	*/
	virtual std::string GetVariableName() = 0;

	/**
	* IUniformJournalSampling::GetNumberOfSamples - Returns the number of samples in the interval.
	* @return Number of samples in the sampling.
	*/
	virtual LibMCEnv_uint32 GetNumberOfSamples() = 0;

	/**
	* IUniformJournalSampling::GetStartTimeStamp - Returns the beginning time stamp of the available data point.
	* @return Start Timestamp of Recording in ms.
	*/
	virtual LibMCEnv_uint64 GetStartTimeStamp() = 0;

	/**
	* IUniformJournalSampling::GetEndTimeStamp - Returns the beginning time stamp of the available data point.
	* @return End Timestamp of Recording in ms.
	*/
	virtual LibMCEnv_uint64 GetEndTimeStamp() = 0;

	/**
	* IUniformJournalSampling::GetSample - Returns the timestamp and value of the given sample.
	* @param[in] nIndex - Index of the sample. 0-based. MUST be smaller than NumberOfSamples.
	* @param[out] nTimeStamp - TimeStamp of the sample in ms.
	* @param[out] dValue - Value of the sample in ms.
	*/
	virtual void GetSample(const LibMCEnv_uint32 nIndex, LibMCEnv_uint64 & nTimeStamp, LibMCEnv_double & dValue) = 0;

	/**
	* IUniformJournalSampling::GetAllSamples - Returns all timestamps and values of the sampling.
	* @param[in] nSamplesBufferSize - Number of elements in buffer
	* @param[out] pSamplesNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pSamplesBuffer - TimeStreamEntry buffer of Array of Timestream entries, in increasing order.
	*/
	virtual void GetAllSamples(LibMCEnv_uint64 nSamplesBufferSize, LibMCEnv_uint64* pSamplesNeededCount, LibMCEnv::sTimeStreamEntry * pSamplesBuffer) = 0;

};

typedef IBaseSharedPtr<IUniformJournalSampling> PIUniformJournalSampling;


/*************************************************************************************************************************
 Class interface for JournalVariable 
**************************************************************************************************************************/

class IJournalVariable : public virtual IBase {
public:
	/**
	* IJournalVariable::GetVariableName - returns the name of the recorded variable.
	* @return Path or name.
	*/
	virtual std::string GetVariableName() = 0;

	/**
	* IJournalVariable::GetStartTimeStamp - Returns the beginning time stamp of the available data point.
	* @return Start Timestamp of Recording in ms.
	*/
	virtual LibMCEnv_uint64 GetStartTimeStamp() = 0;

	/**
	* IJournalVariable::GetEndTimeStamp - Returns the beginning time stamp of the available data point.
	* @return End Timestamp of Recording in ms.
	*/
	virtual LibMCEnv_uint64 GetEndTimeStamp() = 0;

	/**
	* IJournalVariable::ComputeFullAverage - Calculates the average value over the full available time interval.
	* @return Average value of the variable.
	*/
	virtual LibMCEnv_double ComputeFullAverage() = 0;

	/**
	* IJournalVariable::ComputeAverage - Calculates the average value over a time interval. Fails if no data is available in this time interval.
	* @param[in] nStartTimeInMS - Start Timestamp of the interval in ms.
	* @param[in] nEndTimeInMS - End Timestamp of the interval in ms. MUST be larger than Timestamp.
	* @param[in] bClampInterval - If ClampInterval is false, the Interval MUST be completely contained in the available recording time. If ClampInterval is false, the Interval will be reduced to the available recording time. If there is no overlap of the Interval with the Recording time at all, the call will fail.
	* @return Average value of the variable.
	*/
	virtual LibMCEnv_double ComputeAverage(const LibMCEnv_uint64 nStartTimeInMS, const LibMCEnv_uint64 nEndTimeInMS, const bool bClampInterval) = 0;

	/**
	* IJournalVariable::ComputeUniformAverageSamples - Retrieves sample values for an interval. Interval MUST be inside the available recording time.
	* @param[in] nStartTimeInMS - Start Timestamp of the interval in ms.
	* @param[in] nEndTimeInMS - End Timestamp of the interval in ms.
	* @param[in] nNumberOfSamples - End Timestamp of the interval in ms. The Length of the Interval (StartTimeInMS - EndTimeInMS) MUST be a multiple of the Number of samples.
	* @param[in] dMovingAverageDelta - Each sample will be averaged from minus MovingAverageDelta to plus MovingAverageDelta.
	* @param[in] bClampInterval - If ClampInterval is false, each moving average interval MUST be completely contained in the available recording time. If ClampInterval is false, the moving average interval will be reduced to the available recording time. If there is no overlap of the Interval with the Recording time at all, the call will fail.
	* @return Returns an instance with the sampling results.
	*/
	virtual IUniformJournalSampling * ComputeUniformAverageSamples(const LibMCEnv_uint64 nStartTimeInMS, const LibMCEnv_uint64 nEndTimeInMS, const LibMCEnv_uint32 nNumberOfSamples, const LibMCEnv_double dMovingAverageDelta, const bool bClampInterval) = 0;

	/**
	* IJournalVariable::ReceiveRawTimeStream - Retrieves the raw timestream data of the variable.
	* @param[in] nTimeStreamEntriesBufferSize - Number of elements in buffer
	* @param[out] pTimeStreamEntriesNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pTimeStreamEntriesBuffer - TimeStreamEntry buffer of All change events of the variable in the accessed interval.
	*/
	virtual void ReceiveRawTimeStream(LibMCEnv_uint64 nTimeStreamEntriesBufferSize, LibMCEnv_uint64* pTimeStreamEntriesNeededCount, LibMCEnv::sTimeStreamEntry * pTimeStreamEntriesBuffer) = 0;

};

typedef IBaseSharedPtr<IJournalVariable> PIJournalVariable;


/*************************************************************************************************************************
 Class interface for JournalHandler 
**************************************************************************************************************************/

class IJournalHandler : public virtual IBase {
public:
	/**
	* IJournalHandler::RetrieveJournalVariable - Retrieves the history of a given variable in the system journal.
	* @param[in] sVariableName - Variable name to analyse. Fails if Variable does not exist.
	* @param[in] nTimeDeltaInMilliseconds - How many milliseconds the journal should be retrieved in the past.
	* @return Journal Instance.
	*/
	virtual IJournalVariable * RetrieveJournalVariable(const std::string & sVariableName, const LibMCEnv_uint64 nTimeDeltaInMilliseconds) = 0;

	/**
	* IJournalHandler::RetrieveJournalVariableFromTimeInterval - Retrieves the history of a given variable in the system journal for an arbitrary time interval.
	* @param[in] sVariableName - Variable name to analyse. Fails if Variable does not exist.
	* @param[in] nStartTimeInMilliseconds - Start time stamp in milliseconds. MUST be smaller than EndTimeInMilliseconds. Fails if larger than recorded time interval.
	* @param[in] nEndTimeInMilliseconds - End time stamp in milliseconds. MUST be larger than StartTimeInMilliseconds. Fails if larger than recorded time interval.
	* @return Journal Instance.
	*/
	virtual IJournalVariable * RetrieveJournalVariableFromTimeInterval(const std::string & sVariableName, const LibMCEnv_uint64 nStartTimeInMilliseconds, const LibMCEnv_uint64 nEndTimeInMilliseconds) = 0;

	/**
	* IJournalHandler::StoreJournalMarker - Stores a journal marker tag at the current time stamp.
	* @param[in] sMarkerType - Marker type to store. MUST be an non-empty alphanumeric string (hypens and underscores are allowed.)
	* @param[in] sMarkerName - Marker name to store. MUST be an non-empty alphanumeric string (hypens and underscores are allowed.)
	* @param[in] bMustBeUnique - If true, it checks for uniqueness of the marker name/type in the current journal.
	* @return Returns the stored time stamp in milliseconds.
	*/
	virtual LibMCEnv_uint64 StoreJournalMarker(const std::string & sMarkerType, const std::string & sMarkerName, const bool bMustBeUnique) = 0;

	/**
	* IJournalHandler::HasJournalMarker - Checks if a journal marker tag exists.
	* @param[in] sMarkerType - Marker type to store. MUST be an non-empty alphanumeric string (hypens and underscores are allowed.)
	* @param[in] sMarkerName - Marker name to store. MUST be an non-empty alphanumeric string (hypens and underscores are allowed.)
	* @return Returns true if the marker exists.
	*/
	virtual bool HasJournalMarker(const std::string & sMarkerType, const std::string & sMarkerName) = 0;

	/**
	* IJournalHandler::RetrieveJournalMarker - Retrieves the first existing journal marker time stamp. Fails if marker does not exist.
	* @param[in] sMarkerType - Marker type to store. MUST be an non-empty alphanumeric string (hypens and underscores are allowed.)
	* @param[in] sMarkerName - Marker name to store. MUST be an non-empty alphanumeric string (hypens and underscores are allowed.)
	* @param[in] bMustBeUnique - If true, it checks for uniqueness of the marker name/type in the current journal and fails if there are multiple.
	* @return Returns the time stamp in milliseconds.
	*/
	virtual LibMCEnv_uint64 RetrieveJournalMarker(const std::string & sMarkerType, const std::string & sMarkerName, const bool bMustBeUnique) = 0;

	/**
	* IJournalHandler::RetrieveJournalMarkers - Retrieves all existing journal marker time stamps. Fails if no marker exists.
	* @param[in] sMarkerType - Marker type to store. MUST be an non-empty alphanumeric string (hypens and underscores are allowed.)
	* @param[in] sMarkerName - Marker name to store. MUST be an non-empty alphanumeric string (hypens and underscores are allowed.)
	* @param[in] nTimeStampsBufferSize - Number of elements in buffer
	* @param[out] pTimeStampsNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pTimeStampsBuffer - uint64 buffer of Returns an array of time stamps in milliseconds.
	*/
	virtual void RetrieveJournalMarkers(const std::string & sMarkerType, const std::string & sMarkerName, LibMCEnv_uint64 nTimeStampsBufferSize, LibMCEnv_uint64* pTimeStampsNeededCount, LibMCEnv_uint64 * pTimeStampsBuffer) = 0;

};

typedef IBaseSharedPtr<IJournalHandler> PIJournalHandler;


/*************************************************************************************************************************
 Class interface for UserManagementHandler 
**************************************************************************************************************************/

class IUserManagementHandler : public virtual IBase {
public:
	/**
	* IUserManagementHandler::UserExists - Checks if a user exist.
	* @param[in] sUsername - User name
	* @return Flag if users exists
	*/
	virtual bool UserExists(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::GetUserProperties - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	virtual void GetUserProperties(const std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier) = 0;

	/**
	* IUserManagementHandler::GetUserPropertiesByUUID - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[out] sUsername - User name
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	virtual void GetUserPropertiesByUUID(const std::string & sUUID, std::string & sUsername, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier) = 0;

	/**
	* IUserManagementHandler::GetUsernameByUUID - Retrieves a users name with a given UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return User name
	*/
	virtual std::string GetUsernameByUUID(const std::string & sUUID) = 0;

	/**
	* IUserManagementHandler::GetUserUUID - Retrieves a users UUID. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return UUID of the user.
	*/
	virtual std::string GetUserUUID(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::GetUserDescription - Retrieves a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Description of the user.
	*/
	virtual std::string GetUserDescription(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::GetUserDescriptionByUUID - Retrieves a users description by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Description of the user.
	*/
	virtual std::string GetUserDescriptionByUUID(const std::string & sUUID) = 0;

	/**
	* IUserManagementHandler::GetUserRole - Retrieves a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Role of the user.
	*/
	virtual std::string GetUserRole(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::GetUserRoleByUUID - Retrieves a users role by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Role of the user.
	*/
	virtual std::string GetUserRoleByUUID(const std::string & sUUID) = 0;

	/**
	* IUserManagementHandler::GetUserLanguage - Retrieves a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Language identifier of the user.
	*/
	virtual std::string GetUserLanguage(const std::string & sUsername) = 0;

	/**
	* IUserManagementHandler::GetUserLanguageByUUID - Retrieves a users language preference by user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Language identifier of the user.
	*/
	virtual std::string GetUserLanguageByUUID(const std::string & sUUID) = 0;

	/**
	* IUserManagementHandler::CreateUser - Creates a new user. Fails if the user already exists.
	* @param[in] sUsername - User name to create. MUST be alphanumeric and not empty.
	* @param[in] sRole - Role of the new user. MUST NOT be empty.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	* @param[in] sDescription - Description of the new user.
	* @return UUID of the new user.
	*/
	virtual std::string CreateUser(const std::string & sUsername, const std::string & sRole, const std::string & sSalt, const std::string & sHashedPassword, const std::string & sDescription) = 0;

	/**
	* IUserManagementHandler::SetUserLanguage - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	virtual void SetUserLanguage(const std::string & sUsername, const std::string & sLanguageIdentifier) = 0;

	/**
	* IUserManagementHandler::SetUserRole - Updates a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sUserRole - New Role identifier of the user.
	*/
	virtual void SetUserRole(const std::string & sUsername, const std::string & sUserRole) = 0;

	/**
	* IUserManagementHandler::SetUserDescription - Updates a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sDescription - New Description of the user.
	*/
	virtual void SetUserDescription(const std::string & sUsername, const std::string & sDescription) = 0;

	/**
	* IUserManagementHandler::SetUserPassword - Updates a users password. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	virtual void SetUserPassword(const std::string & sUsername, const std::string & sSalt, const std::string & sHashedPassword) = 0;

	/**
	* IUserManagementHandler::SetUserLanguageByUUID - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	virtual void SetUserLanguageByUUID(const std::string & sUUID, const std::string & sLanguageIdentifier) = 0;

	/**
	* IUserManagementHandler::SetUserRoleByUUID - Updates a users role. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sUserRole - New Role identifier of the user.
	*/
	virtual void SetUserRoleByUUID(const std::string & sUUID, const std::string & sUserRole) = 0;

	/**
	* IUserManagementHandler::SetUserDescriptionByUUID - Updates a users description. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sDescription - New Description identifier of the user.
	*/
	virtual void SetUserDescriptionByUUID(const std::string & sUUID, const std::string & sDescription) = 0;

	/**
	* IUserManagementHandler::SetUserPasswordByUUID - Updates a users password. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	virtual void SetUserPasswordByUUID(const std::string & sUUID, const std::string & sSalt, const std::string & sHashedPassword) = 0;

};

typedef IBaseSharedPtr<IUserManagementHandler> PIUserManagementHandler;


/*************************************************************************************************************************
 Class interface for StateEnvironment 
**************************************************************************************************************************/

class IStateEnvironment : public virtual IBase {
public:
	/**
	* IStateEnvironment::GetMachineState - Retrieves the machine state
	* @param[in] sMachineInstance - State machine instance name
	* @return Name of current state
	*/
	virtual std::string GetMachineState(const std::string & sMachineInstance) = 0;

	/**
	* IStateEnvironment::PrepareSignal - prepares a signal object to trigger later.
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sSignalName - Name Of signal channel.
	* @return Signal trigger object.
	*/
	virtual ISignalTrigger * PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName) = 0;

	/**
	* IStateEnvironment::WaitForSignal - Waits for a signal for a certain amount of time.
	* @param[in] sSignalName - Name Of Signal
	* @param[in] nTimeOut - Timeout in Milliseconds. 0 for Immediate return.
	* @param[out] pHandlerInstance - Signal object. If Success is false, the Signal Handler Object will be null.
	* @return Signal has been triggered
	*/
	virtual bool WaitForSignal(const std::string & sSignalName, const LibMCEnv_uint32 nTimeOut, ISignalHandler*& pHandlerInstance) = 0;

	/**
	* IStateEnvironment::GetUnhandledSignal - Retrieves an unhandled signal By signal type name.
	* @param[in] sSignalTypeName - Name Of Signal to be returned
	* @return Signal object. If no signal has been found the signal handler object will be null.
	*/
	virtual ISignalHandler * GetUnhandledSignal(const std::string & sSignalTypeName) = 0;

	/**
	* IStateEnvironment::GetUnhandledSignalByUUID - retrieves an unhandled signal from the current state machine by UUID.
	* @param[in] sUUID - Name
	* @param[in] bMustExist - The call fails if MustExist is true and not signal with UUID does exist or a signal with UUID has been handled already.
	* @return Signal handler instance. Returns null, if signal does not exist.
	*/
	virtual ISignalHandler * GetUnhandledSignalByUUID(const std::string & sUUID, const bool bMustExist) = 0;

	/**
	* IStateEnvironment::GetDriverLibrary - Returns the driver type and library lookup for a specific registered driver.
	* @param[in] sDriverName - Name identifier of the driver.
	* @param[out] sDriverType - returns type identifier of the driver.
	* @param[out] dDriverLookup - GetProcAddress Handle of the driver.
	*/
	virtual void GetDriverLibrary(const std::string & sDriverName, std::string & sDriverType, LibMCEnv_pvoid & pDriverLookup) = 0;

	/**
	* IStateEnvironment::CreateDriverAccess - Accesses and locks a driver for the execution of the current state.
	* @param[in] sDriverName - Name identifier of the driver.
	* @param[out] dDriverHandle - Handle of the driver.
	*/
	virtual void CreateDriverAccess(const std::string & sDriverName, LibMCEnv_pvoid & pDriverHandle) = 0;

	/**
	* IStateEnvironment::HasBuildJob - Returns if a build object exists. Fails if BuildUUID is not a valid UUID string.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Returns true if build exists
	*/
	virtual bool HasBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IStateEnvironment::GetBuildJob - Returns a instance of a build object. Fails if build uuid does not exist.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	virtual IBuild * GetBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IStateEnvironment::UnloadAllToolpathes - unloads all toolpath in memory to clean up
	*/
	virtual void UnloadAllToolpathes() = 0;

	/**
	* IStateEnvironment::SetNextState - sets the next state
	* @param[in] sStateName - Name of next state
	*/
	virtual void SetNextState(const std::string & sStateName) = 0;

	/**
	* IStateEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	virtual void LogMessage(const std::string & sLogString) = 0;

	/**
	* IStateEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	virtual void LogWarning(const std::string & sLogString) = 0;

	/**
	* IStateEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	virtual void LogInfo(const std::string & sLogString) = 0;

	/**
	* IStateEnvironment::Sleep - Puts the current instance to sleep for a definite amount of time. MUST be used instead of a blocking sleep call.
	* @param[in] nDelay - Milliseconds to sleeps
	*/
	virtual void Sleep(const LibMCEnv_uint32 nDelay) = 0;

	/**
	* IStateEnvironment::CheckForTermination - checks environment for termination signal. MUST be called frequently in longer-running operations.
	* @return Returns if termination shall appear
	*/
	virtual bool CheckForTermination() = 0;

	/**
	* IStateEnvironment::StoreSignal - DEPRECIATED: stores a signal handler in the current state machine
	* @param[in] sName - Name
	* @param[in] pHandler - Signal handler to store.
	*/
	virtual void StoreSignal(const std::string & sName, ISignalHandler* pHandler) = 0;

	/**
	* IStateEnvironment::RetrieveSignal - DEPRECIATED: retrieves a signal handler from the current state machine. Fails if value has not been stored before or signal has been already handled.
	* @param[in] sName - Name
	* @return Signal handler instance.
	*/
	virtual ISignalHandler * RetrieveSignal(const std::string & sName) = 0;

	/**
	* IStateEnvironment::ClearStoredValue - DEPRECIATED: deletes a value from the data store.
	* @param[in] sName - Name
	*/
	virtual void ClearStoredValue(const std::string & sName) = 0;

	/**
	* IStateEnvironment::SetStringParameter - sets a string parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IStateEnvironment::SetUUIDParameter - sets a uuid parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] sValue - Value to set
	*/
	virtual void SetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName, const std::string & sValue) = 0;

	/**
	* IStateEnvironment::SetDoubleParameter - sets a double parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] dValue - Value to set
	*/
	virtual void SetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_double dValue) = 0;

	/**
	* IStateEnvironment::SetIntegerParameter - sets an int parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] nValue - Value to set
	*/
	virtual void SetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IStateEnvironment::SetBoolParameter - sets a bool parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @param[in] bValue - Value to set
	*/
	virtual void SetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName, const bool bValue) = 0;

	/**
	* IStateEnvironment::GetStringParameter - returns a string parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual std::string GetStringParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::GetUUIDParameter - returns a uuid parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual std::string GetUUIDParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::GetDoubleParameter - returns a double parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual LibMCEnv_double GetDoubleParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::GetIntegerParameter - returns an int parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual LibMCEnv_int64 GetIntegerParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::GetBoolParameter - returns a bool parameter
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Value to set
	*/
	virtual bool GetBoolParameter(const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IStateEnvironment::LoadResourceData - loads a plugin resource file into memory.
	* @param[in] sResourceName - Name of the resource.
	* @param[in] nResourceDataBufferSize - Number of elements in buffer
	* @param[out] pResourceDataNeededCount - will be filled with the count of the written structs, or needed buffer size.
	* @param[out] pResourceDataBuffer - uint8 buffer of Resource Data Buffer.
	*/
	virtual void LoadResourceData(const std::string & sResourceName, LibMCEnv_uint64 nResourceDataBufferSize, LibMCEnv_uint64* pResourceDataNeededCount, LibMCEnv_uint8 * pResourceDataBuffer) = 0;

	/**
	* IStateEnvironment::LoadResourceString - loads a plugin resource file into a string. Fails if content is not a valid UTF8 string.
	* @param[in] sResourceName - Name of the resource.
	* @return Resource Data String.
	*/
	virtual std::string LoadResourceString(const std::string & sResourceName) = 0;

	/**
	* IStateEnvironment::CreateEmptyImage - creates an empty image object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use.
	* @return Empty image instance.
	*/
	virtual IImageData * CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IStateEnvironment::LoadPNGImage - creates an image object from a PNG data stream.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[in] pPNGDataBuffer - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image instance containing the PNG image.
	*/
	virtual IImageData * LoadPNGImage(const LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IStateEnvironment::CreateDiscreteField2D - Creates an empty discrete field.
	* @param[in] nPixelCountX - Pixel count in X. MUST be positive.
	* @param[in] nPixelCountY - Pixel count in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @param[in] dDefaultValue - Default value of the field.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IStateEnvironment::CreateDiscreteField2DFromImage - Creates a discrete field from the greyscale values of an image. RGB colors in the image will be averaged to obtain a greyscale color.
	* @param[in] pImageDataInstance - Image instance containing the pixel data.
	* @param[in] dBlackValue - Value that the minimum color (black) shall be mapped to.
	* @param[in] dWhiteValue - Value that the maximum color (white) shall be mapped to.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2DFromImage(IImageData* pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY) = 0;

	/**
	* IStateEnvironment::GetGlobalTimerInMilliseconds - Returns the global timer in milliseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetGlobalTimerInMilliseconds() = 0;

	/**
	* IStateEnvironment::GetTestEnvironment - Returns a test environment instance.
	* @return Test Environment Instance
	*/
	virtual ITestEnvironment * GetTestEnvironment() = 0;

	/**
	* IStateEnvironment::CreateXMLDocument - creates an empty XML Document.
	* @param[in] sRootNodeName - Name of the root node. MUST be a valid XML Node Name string.
	* @param[in] sDefaultNamespace - Default namespace of the document. MUST be a valid XML namespace string.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace) = 0;

	/**
	* IStateEnvironment::ParseXMLString - parses an XML String and returns an XML Document instance. Throws an error if XML is malformatted.
	* @param[in] sXMLString - XML String.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLString(const std::string & sXMLString) = 0;

	/**
	* IStateEnvironment::ParseXMLData - parses a XML stored in a byte array and returns an XML Document instance. . Throws an error if XML is malformatted.
	* @param[in] nXMLDataBufferSize - Number of elements in buffer
	* @param[in] pXMLDataBuffer - XML Binary data.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLData(const LibMCEnv_uint64 nXMLDataBufferSize, const LibMCEnv_uint8 * pXMLDataBuffer) = 0;

	/**
	* IStateEnvironment::CheckUserPermission - Returns if the a user has a certain permission. Fails if user or permission is not known to the system.
	* @param[in] sUserLogin - Login of user to check
	* @param[in] sPermissionIdentifier - Permission identifier
	* @return Returns if the user has permission
	*/
	virtual bool CheckUserPermission(const std::string & sUserLogin, const std::string & sPermissionIdentifier) = 0;

	/**
	* IStateEnvironment::CreateUserManagement - Returns a user management handler instance.
	* @return Returns a user management handler.
	*/
	virtual IUserManagementHandler * CreateUserManagement() = 0;

	/**
	* IStateEnvironment::GetCurrentJournal - Returns the journal instance of the current session.
	* @return Journal instance.
	*/
	virtual IJournalHandler * GetCurrentJournal() = 0;

	/**
	* IStateEnvironment::RegisterMeshFrom3MFResource - Loads a from a 3MF Resource File. If 3MF contains multiple objects, it will merge them into one mesh.
	* @param[in] sResourceName - Resource name to load.
	* @return Mesh Object instance.
	*/
	virtual IMeshObject * RegisterMeshFrom3MFResource(const std::string & sResourceName) = 0;

	/**
	* IStateEnvironment::MeshIsRegistered - Checks if a mesh uuid is registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Flag is registered.
	*/
	virtual bool MeshIsRegistered(const std::string & sMeshUUID) = 0;

	/**
	* IStateEnvironment::FindRegisteredMesh - Finds a registered mesh by its UUID. Fails if mesh UUID is not registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Mesh Object instance.
	*/
	virtual IMeshObject * FindRegisteredMesh(const std::string & sMeshUUID) = 0;

};

typedef IBaseSharedPtr<IStateEnvironment> PIStateEnvironment;


/*************************************************************************************************************************
 Class interface for UIEnvironment 
**************************************************************************************************************************/

class IUIEnvironment : public virtual IBase {
public:
	/**
	* IUIEnvironment::ActivateModalDialog - activates a modal dialog on the client.
	* @param[in] sDialogName - Name of the dialog to activate.
	*/
	virtual void ActivateModalDialog(const std::string & sDialogName) = 0;

	/**
	* IUIEnvironment::CloseModalDialog - closes the active modal dialog on the client.
	*/
	virtual void CloseModalDialog() = 0;

	/**
	* IUIEnvironment::ActivatePage - changes the current page on the client.
	* @param[in] sPageName - Name of the page to activate.
	*/
	virtual void ActivatePage(const std::string & sPageName) = 0;

	/**
	* IUIEnvironment::LogOut - Logs out the client session.
	*/
	virtual void LogOut() = 0;

	/**
	* IUIEnvironment::ShowHint - Shows a hint message in the user interface.
	* @param[in] sHint - Hint to show.
	* @param[in] nTimeoutInMS - How many milliseconds the snackbar should be shown.
	*/
	virtual void ShowHint(const std::string & sHint, const LibMCEnv_uint32 nTimeoutInMS) = 0;

	/**
	* IUIEnvironment::ShowHintColored - Shows a hint message in the user interface in a certain color.
	* @param[in] sHint - Hint to show.
	* @param[in] nTimeoutInMS - How many milliseconds the snackbar should be shown.
	* @param[in] Color - Background color of hint.
	* @param[in] FontColor - Font color of hint.
	*/
	virtual void ShowHintColored(const std::string & sHint, const LibMCEnv_uint32 nTimeoutInMS, const LibMCEnv::sColorRGB Color, const LibMCEnv::sColorRGB FontColor) = 0;

	/**
	* IUIEnvironment::HideHint - Hides hint if any is displayed.
	*/
	virtual void HideHint() = 0;

	/**
	* IUIEnvironment::ShowMessageDlg - Shows a message dialog in the user interface.
	* @param[in] sCaption - Caption of the dialog
	* @param[in] sTitle - Title of the dialog
	* @param[in] eDialogType - Which dialog type shall be shown.
	* @param[in] sYesEvent - Event to be called when clicked yes or ok.
	* @param[in] sNoEvent - Event to be called when clicked no.
	* @param[in] sCancelEvent - Event to be called when dialog is closed or cancel is pressed.
	* @return Dialog UUID. Will be set as sender for triggered events.
	*/
	virtual std::string ShowMessageDlg(const std::string & sCaption, const std::string & sTitle, const LibMCEnv::eMessageDialogType eDialogType, const std::string & sYesEvent, const std::string & sNoEvent, const std::string & sCancelEvent) = 0;

	/**
	* IUIEnvironment::RetrieveEventSender - returns path of the UI control that triggered the event.
	* @return Path of the sender element.
	*/
	virtual std::string RetrieveEventSender() = 0;

	/**
	* IUIEnvironment::RetrieveEventSenderPage - returns name of the page of the UI control that triggered the event.
	* @return Page of the sender element.
	*/
	virtual std::string RetrieveEventSenderPage() = 0;

	/**
	* IUIEnvironment::RetrieveEventSenderUUID - returns uuid of the UI control that triggered the event.
	* @return Name of the sender uuid.
	*/
	virtual std::string RetrieveEventSenderUUID() = 0;

	/**
	* IUIEnvironment::PrepareSignal - prepares a signal object to trigger later.
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sSignalName - Name Of signal channel.
	* @return Signal trigger object.
	*/
	virtual ISignalTrigger * PrepareSignal(const std::string & sMachineInstance, const std::string & sSignalName) = 0;

	/**
	* IUIEnvironment::GetMachineState - Retrieves the machine state
	* @param[in] sMachineInstance - State machine instance name
	* @return Name of current state
	*/
	virtual std::string GetMachineState(const std::string & sMachineInstance) = 0;

	/**
	* IUIEnvironment::LogMessage - logs a string as message
	* @param[in] sLogString - String to Log
	*/
	virtual void LogMessage(const std::string & sLogString) = 0;

	/**
	* IUIEnvironment::LogWarning - logs a string as warning
	* @param[in] sLogString - String to Log
	*/
	virtual void LogWarning(const std::string & sLogString) = 0;

	/**
	* IUIEnvironment::LogInfo - logs a string as info
	* @param[in] sLogString - String to Log
	*/
	virtual void LogInfo(const std::string & sLogString) = 0;

	/**
	* IUIEnvironment::GetMachineParameter - returns a string parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual std::string GetMachineParameter(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetMachineParameterAsUUID - returns a uuid parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual std::string GetMachineParameterAsUUID(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetMachineParameterAsDouble - returns a double parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual LibMCEnv_double GetMachineParameterAsDouble(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetMachineParameterAsInteger - returns an int parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual LibMCEnv_int64 GetMachineParameterAsInteger(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetMachineParameterAsBool - returns a bool parameter of a state machine
	* @param[in] sMachineInstance - State machine instance name
	* @param[in] sParameterGroup - Parameter Group
	* @param[in] sParameterName - Parameter Name
	* @return Current Parameter Value
	*/
	virtual bool GetMachineParameterAsBool(const std::string & sMachineInstance, const std::string & sParameterGroup, const std::string & sParameterName) = 0;

	/**
	* IUIEnvironment::GetUIProperty - returns a string property of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual std::string GetUIProperty(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::GetUIPropertyAsUUID - returns a uuid variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual std::string GetUIPropertyAsUUID(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::GetUIPropertyAsDouble - returns a double variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual LibMCEnv_double GetUIPropertyAsDouble(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::GetUIPropertyAsInteger - returns a integer variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual LibMCEnv_int64 GetUIPropertyAsInteger(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::GetUIPropertyAsBool - returns a integer variable of a UI element on the client
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist.
	* @return Current property Value
	*/
	virtual bool GetUIPropertyAsBool(const std::string & sElementPath, const std::string & sPropertyName) = 0;

	/**
	* IUIEnvironment::SetUIProperty - sets a string property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] sValue - New property Value
	*/
	virtual void SetUIProperty(const std::string & sElementPath, const std::string & sPropertyName, const std::string & sValue) = 0;

	/**
	* IUIEnvironment::SetUIPropertyAsUUID - sets a uuid property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] sValue - New property Value
	*/
	virtual void SetUIPropertyAsUUID(const std::string & sElementPath, const std::string & sPropertyName, const std::string & sValue) = 0;

	/**
	* IUIEnvironment::SetUIPropertyAsDouble - sets a double property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] dValue - New property Value
	*/
	virtual void SetUIPropertyAsDouble(const std::string & sElementPath, const std::string & sPropertyName, const LibMCEnv_double dValue) = 0;

	/**
	* IUIEnvironment::SetUIPropertyAsInteger - sets a integer property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] nValue - New property Value
	*/
	virtual void SetUIPropertyAsInteger(const std::string & sElementPath, const std::string & sPropertyName, const LibMCEnv_int64 nValue) = 0;

	/**
	* IUIEnvironment::SetUIPropertyAsBool - sets a bool property of a UI element on the client.
	* @param[in] sElementPath - Path of UI Element. Fails if element does not exist.
	* @param[in] sPropertyName - Property name. Fails if property does not exist or is readonly.
	* @param[in] bValue - New property Value
	*/
	virtual void SetUIPropertyAsBool(const std::string & sElementPath, const std::string & sPropertyName, const bool bValue) = 0;

	/**
	* IUIEnvironment::CreateEmptyImage - creates an empty image object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use.
	* @return Empty image instance.
	*/
	virtual IImageData * CreateEmptyImage(const LibMCEnv_uint32 nPixelSizeX, const LibMCEnv_uint32 nPixelSizeY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IUIEnvironment::LoadPNGImage - creates an image object from a PNG data stream.
	* @param[in] nPNGDataBufferSize - Number of elements in buffer
	* @param[in] pPNGDataBuffer - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] ePixelFormat - Pixel format to use. Might lose color and alpha information.
	* @return Image instance containing the PNG image.
	*/
	virtual IImageData * LoadPNGImage(const LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv::eImagePixelFormat ePixelFormat) = 0;

	/**
	* IUIEnvironment::GetGlobalTimerInMilliseconds - Returns the global timer in milliseconds.
	* @return Timer value in Milliseconds
	*/
	virtual LibMCEnv_uint64 GetGlobalTimerInMilliseconds() = 0;

	/**
	* IUIEnvironment::GetTestEnvironment - Returns a test environment instance.
	* @return Test Environment Instance
	*/
	virtual ITestEnvironment * GetTestEnvironment() = 0;

	/**
	* IUIEnvironment::CreateXMLDocument - creates an empty XML Document.
	* @param[in] sRootNodeName - Name of the root node. MUST be a valid XML Node Name string.
	* @param[in] sDefaultNamespace - Default namespace of the document. MUST be a valid XML namespace string.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * CreateXMLDocument(const std::string & sRootNodeName, const std::string & sDefaultNamespace) = 0;

	/**
	* IUIEnvironment::ParseXMLString - parses an XML String and returns an XML Document instance. Throws an error if XML is malformatted.
	* @param[in] sXMLString - XML String.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLString(const std::string & sXMLString) = 0;

	/**
	* IUIEnvironment::ParseXMLData - parses a XML stored in a byte array and returns an XML Document instance. . Throws an error if XML is malformatted.
	* @param[in] nXMLDataBufferSize - Number of elements in buffer
	* @param[in] pXMLDataBuffer - XML Binary data.
	* @return XML Document Instance.
	*/
	virtual IXMLDocument * ParseXMLData(const LibMCEnv_uint64 nXMLDataBufferSize, const LibMCEnv_uint8 * pXMLDataBuffer) = 0;

	/**
	* IUIEnvironment::HasBuildJob - Returns if a build object exists. Fails if BuildUUID is not a valid UUID string.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Returns true if build exists
	*/
	virtual bool HasBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IUIEnvironment::GetBuildJob - Returns a instance of a build object. Fails if build uuid does not exist.
	* @param[in] sBuildUUID - UUID of the build entity.
	* @return Build instance
	*/
	virtual IBuild * GetBuildJob(const std::string & sBuildUUID) = 0;

	/**
	* IUIEnvironment::CreateDiscreteField2D - Creates an empty discrete field.
	* @param[in] nPixelCountX - Pixel count in X. MUST be positive.
	* @param[in] nPixelCountY - Pixel count in Y. MUST be positive.
	* @param[in] dDPIValueX - DPI Value in X. MUST be positive.
	* @param[in] dDPIValueY - DPI Value in Y. MUST be positive.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @param[in] dDefaultValue - Default value of the field.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2D(const LibMCEnv_uint32 nPixelCountX, const LibMCEnv_uint32 nPixelCountY, const LibMCEnv_double dDPIValueX, const LibMCEnv_double dDPIValueY, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY, const LibMCEnv_double dDefaultValue) = 0;

	/**
	* IUIEnvironment::CreateDiscreteField2DFromImage - Creates a discrete field from the greyscale values of an image. RGB colors in the image will be averaged to obtain a greyscale color.
	* @param[in] pImageDataInstance - Image instance containing the pixel data.
	* @param[in] dBlackValue - Value that the minimum color (black) shall be mapped to.
	* @param[in] dWhiteValue - Value that the maximum color (white) shall be mapped to.
	* @param[in] dOriginX - Origin X of the field in mm.
	* @param[in] dOriginY - Origin Y of the field in mm.
	* @return Empty field instance.
	*/
	virtual IDiscreteFieldData2D * CreateDiscreteField2DFromImage(IImageData* pImageDataInstance, const LibMCEnv_double dBlackValue, const LibMCEnv_double dWhiteValue, const LibMCEnv_double dOriginX, const LibMCEnv_double dOriginY) = 0;

	/**
	* IUIEnvironment::CheckPermission - Returns if the current user has a certain permission. Fails if permission is not known to the system.
	* @param[in] sPermissionIdentifier - Permission identifier
	* @return Returns if the user has permission
	*/
	virtual bool CheckPermission(const std::string & sPermissionIdentifier) = 0;

	/**
	* IUIEnvironment::GetCurrentUserLogin - Returns the current user login name.
	* @return Returns the current users login name.
	*/
	virtual std::string GetCurrentUserLogin() = 0;

	/**
	* IUIEnvironment::GetCurrentUserDescription - Returns the current user description.
	* @return Returns the current users description.
	*/
	virtual std::string GetCurrentUserDescription() = 0;

	/**
	* IUIEnvironment::GetCurrentUserRole - Returns the current user role identifier.
	* @return Returns the current users role identifier.
	*/
	virtual std::string GetCurrentUserRole() = 0;

	/**
	* IUIEnvironment::GetCurrentUserLanguage - Returns the current users language identifier.
	* @return Returns the current users language identifier.
	*/
	virtual std::string GetCurrentUserLanguage() = 0;

	/**
	* IUIEnvironment::GetCurrentUserUUID - Returns the current user UUID.
	* @return Returns the current user UUID.
	*/
	virtual std::string GetCurrentUserUUID() = 0;

	/**
	* IUIEnvironment::CreateUserManagement - Returns a user management handler instance.
	* @return Returns a user management handler.
	*/
	virtual IUserManagementHandler * CreateUserManagement() = 0;

	/**
	* IUIEnvironment::GetCurrentJournal - Returns the journal instance of the current session.
	* @return Journal instance.
	*/
	virtual IJournalHandler * GetCurrentJournal() = 0;

	/**
	* IUIEnvironment::RegisterMeshFrom3MFResource - Loads a mesh from a 3MF Resource File. Fails if mesh UUID is already registered.
	* @param[in] sResourceName - Resource name to load.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Mesh Object instance.
	*/
	virtual IMeshObject * RegisterMeshFrom3MFResource(const std::string & sResourceName, const std::string & sMeshUUID) = 0;

	/**
	* IUIEnvironment::MeshIsRegistered - Checks if a mesh uuid is registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Flag is registered.
	*/
	virtual bool MeshIsRegistered(const std::string & sMeshUUID) = 0;

	/**
	* IUIEnvironment::FindRegisteredMesh - Finds a registered mesh by its UUID. Fails if mesh UUID is not registered.
	* @param[in] sMeshUUID - Mesh UUID to load.
	* @return Mesh Object instance.
	*/
	virtual IMeshObject * FindRegisteredMesh(const std::string & sMeshUUID) = 0;

};

typedef IBaseSharedPtr<IUIEnvironment> PIUIEnvironment;


/*************************************************************************************************************************
 Global functions declarations
**************************************************************************************************************************/
class CWrapper {
public:
	/**
	* Ilibmcenv::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	static void GetVersion(LibMCEnv_uint32 & nMajor, LibMCEnv_uint32 & nMinor, LibMCEnv_uint32 & nMicro);

	/**
	* Ilibmcenv::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	static bool GetLastError(IBase* pInstance, std::string & sErrorMessage);

	/**
	* Ilibmcenv::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void ReleaseInstance(IBase* pInstance);

	/**
	* Ilibmcenv::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	static void AcquireInstance(IBase* pInstance);

};

LibMCEnvResult LibMCEnv_GetProcAddress (const char * pProcName, void ** ppProcAddress);

} // namespace Impl
} // namespace LibMCEnv

#endif // __LIBMCENV_CPPINTERFACES
