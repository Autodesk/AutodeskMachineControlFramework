/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of MC Environment Interface. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmcenv_abi.hpp"
#include "libmcenv_interfaces.hpp"
#include "libmcenv_interfaceexception.hpp"

#include <map>

using namespace LibMCEnv::Impl;

LibMCEnvResult handleLibMCEnvException(IBase * pIBaseClass, ELibMCEnvInterfaceException & Exception)
{
	LibMCEnvResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCEnvResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCEnvResult errorCode = LIBMCENV_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCEnvResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCEnvResult errorCode = LIBMCENV_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for ToolpathLayer
**************************************************************************************************************************/
LibMCEnvResult libmcenv_toolpathlayer_getlayerdatauuid(LibMCEnv_ToolpathLayer pToolpathLayer, const LibMCEnv_uint32 nUUIDBufferSize, LibMCEnv_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIToolpathLayer->GetLayerDataUUID();

			pIToolpathLayer->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathLayer->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIToolpathLayer->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCEnv_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentcount(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIToolpathLayer->GetSegmentCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentinfo(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, eLibMCEnvToolpathSegmentType * pType, LibMCEnv_uint32 * pPointCount)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (!pType)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pPointCount)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIToolpathLayer->GetSegmentInfo(nIndex, *pType, *pPointCount);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofileuuid(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nProfileUUIDBufferSize, LibMCEnv_uint32* pProfileUUIDNeededChars, char * pProfileUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ( (!pProfileUUIDBuffer) && !(pProfileUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sProfileUUID("");
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pProfileUUIDBuffer == nullptr);
		if (isCacheCall) {
			sProfileUUID = pIToolpathLayer->GetSegmentProfileUUID(nIndex);

			pIToolpathLayer->_setCache (new ParameterCache_1<std::string> (sProfileUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathLayer->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sProfileUUID);
			pIToolpathLayer->_setCache (nullptr);
		}
		
		if (pProfileUUIDNeededChars)
			*pProfileUUIDNeededChars = (LibMCEnv_uint32) (sProfileUUID.size()+1);
		if (pProfileUUIDBuffer) {
			if (sProfileUUID.size() >= nProfileUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iProfileUUID = 0; iProfileUUID < sProfileUUID.size(); iProfileUUID++)
				pProfileUUIDBuffer[iProfileUUID] = sProfileUUID[iProfileUUID];
			pProfileUUIDBuffer[sProfileUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofilevalue(LibMCEnv_ToolpathLayer pToolpathLayer, const char * pValueName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sValueName(pValueName);
		std::string sValue("");
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIToolpathLayer->GetSegmentProfileValue(sValueName);

			pIToolpathLayer->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathLayer->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIToolpathLayer->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofiletypedvalue(LibMCEnv_ToolpathLayer pToolpathLayer, eLibMCEnvToolpathProfileValueType eValueType, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIToolpathLayer->GetSegmentProfileTypedValue(eValueType);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentpartuuid(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nPartUUIDBufferSize, LibMCEnv_uint32* pPartUUIDNeededChars, char * pPartUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ( (!pPartUUIDBuffer) && !(pPartUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sPartUUID("");
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPartUUIDBuffer == nullptr);
		if (isCacheCall) {
			sPartUUID = pIToolpathLayer->GetSegmentPartUUID(nIndex);

			pIToolpathLayer->_setCache (new ParameterCache_1<std::string> (sPartUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathLayer->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sPartUUID);
			pIToolpathLayer->_setCache (nullptr);
		}
		
		if (pPartUUIDNeededChars)
			*pPartUUIDNeededChars = (LibMCEnv_uint32) (sPartUUID.size()+1);
		if (pPartUUIDBuffer) {
			if (sPartUUID.size() >= nPartUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iPartUUID = 0; iPartUUID < sPartUUID.size(); iPartUUID++)
				pPartUUIDBuffer[iPartUUID] = sPartUUID[iPartUUID];
			pPartUUIDBuffer[sPartUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentpointdata(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const LibMCEnv_uint64 nPointDataBufferSize, LibMCEnv_uint64* pPointDataNeededCount, sLibMCEnvPosition2D * pPointDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ((!pPointDataBuffer) && !(pPointDataNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIToolpathLayer->GetSegmentPointData(nIndex, nPointDataBufferSize, pPointDataNeededCount, pPointDataBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getzvalue(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_int32 * pZValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pZValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pZValue = pIToolpathLayer->GetZValue();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getunits(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_double * pUnits)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pUnits == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pUnits = pIToolpathLayer->GetUnits();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ToolpathAccessor
**************************************************************************************************************************/
LibMCEnvResult libmcenv_toolpathaccessor_getstorageuuid(LibMCEnv_ToolpathAccessor pToolpathAccessor, const LibMCEnv_uint32 nStorageUUIDBufferSize, LibMCEnv_uint32* pStorageUUIDNeededChars, char * pStorageUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if ( (!pStorageUUIDBuffer) && !(pStorageUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStorageUUID("");
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStorageUUIDBuffer == nullptr);
		if (isCacheCall) {
			sStorageUUID = pIToolpathAccessor->GetStorageUUID();

			pIToolpathAccessor->_setCache (new ParameterCache_1<std::string> (sStorageUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathAccessor->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStorageUUID);
			pIToolpathAccessor->_setCache (nullptr);
		}
		
		if (pStorageUUIDNeededChars)
			*pStorageUUIDNeededChars = (LibMCEnv_uint32) (sStorageUUID.size()+1);
		if (pStorageUUIDBuffer) {
			if (sStorageUUID.size() >= nStorageUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStorageUUID = 0; iStorageUUID < sStorageUUID.size(); iStorageUUID++)
				pStorageUUIDBuffer[iStorageUUID] = sStorageUUID[iStorageUUID];
			pStorageUUIDBuffer[sStorageUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getlayercount(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_uint32 * pLayerCount)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pLayerCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pLayerCount = pIToolpathAccessor->GetLayerCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_loadlayer(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_uint32 nLayerIndex, LibMCEnv_ToolpathLayer * pLayerData)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pLayerData == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseLayerData(nullptr);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseLayerData = pIToolpathAccessor->LoadLayer(nLayerIndex);

		*pLayerData = (IBase*)(pBaseLayerData);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getunits(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_double * pUnits)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pUnits == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pUnits = pIToolpathAccessor->GetUnits();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Build
**************************************************************************************************************************/
LibMCEnvResult libmcenv_build_getname(LibMCEnv_Build pBuild, const LibMCEnv_uint32 nNameBufferSize, LibMCEnv_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBuild->GetName();

			pIBuild->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBuild->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCEnv_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getbuilduuid(LibMCEnv_Build pBuild, const LibMCEnv_uint32 nBuildUUIDBufferSize, LibMCEnv_uint32* pBuildUUIDNeededChars, char * pBuildUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if ( (!pBuildUUIDBuffer) && !(pBuildUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sBuildUUID("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildUUIDBuffer == nullptr);
		if (isCacheCall) {
			sBuildUUID = pIBuild->GetBuildUUID();

			pIBuild->_setCache (new ParameterCache_1<std::string> (sBuildUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sBuildUUID);
			pIBuild->_setCache (nullptr);
		}
		
		if (pBuildUUIDNeededChars)
			*pBuildUUIDNeededChars = (LibMCEnv_uint32) (sBuildUUID.size()+1);
		if (pBuildUUIDBuffer) {
			if (sBuildUUID.size() >= nBuildUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iBuildUUID = 0; iBuildUUID < sBuildUUID.size(); iBuildUUID++)
				pBuildUUIDBuffer[iBuildUUID] = sBuildUUID[iBuildUUID];
			pBuildUUIDBuffer[sBuildUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getstorageuuid(LibMCEnv_Build pBuild, const LibMCEnv_uint32 nStorageUUIDBufferSize, LibMCEnv_uint32* pStorageUUIDNeededChars, char * pStorageUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if ( (!pStorageUUIDBuffer) && !(pStorageUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStorageUUID("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStorageUUIDBuffer == nullptr);
		if (isCacheCall) {
			sStorageUUID = pIBuild->GetStorageUUID();

			pIBuild->_setCache (new ParameterCache_1<std::string> (sStorageUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStorageUUID);
			pIBuild->_setCache (nullptr);
		}
		
		if (pStorageUUIDNeededChars)
			*pStorageUUIDNeededChars = (LibMCEnv_uint32) (sStorageUUID.size()+1);
		if (pStorageUUIDBuffer) {
			if (sStorageUUID.size() >= nStorageUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStorageUUID = 0; iStorageUUID < sStorageUUID.size(); iStorageUUID++)
				pStorageUUIDBuffer[iStorageUUID] = sStorageUUID[iStorageUUID];
			pStorageUUIDBuffer[sStorageUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getstoragesha256(LibMCEnv_Build pBuild, const LibMCEnv_uint32 nSHA256BufferSize, LibMCEnv_uint32* pSHA256NeededChars, char * pSHA256Buffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if ( (!pSHA256Buffer) && !(pSHA256NeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSHA256("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSHA256Buffer == nullptr);
		if (isCacheCall) {
			sSHA256 = pIBuild->GetStorageSHA256();

			pIBuild->_setCache (new ParameterCache_1<std::string> (sSHA256));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSHA256);
			pIBuild->_setCache (nullptr);
		}
		
		if (pSHA256NeededChars)
			*pSHA256NeededChars = (LibMCEnv_uint32) (sSHA256.size()+1);
		if (pSHA256Buffer) {
			if (sSHA256.size() >= nSHA256BufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA256 = 0; iSHA256 < sSHA256.size(); iSHA256++)
				pSHA256Buffer[iSHA256] = sSHA256[iSHA256];
			pSHA256Buffer[sSHA256.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getlayercount(LibMCEnv_Build pBuild, LibMCEnv_uint32 * pLayerCount)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pLayerCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pLayerCount = pIBuild->GetLayerCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_loadtoolpath(LibMCEnv_Build pBuild)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIBuild->LoadToolpath();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_unloadtoolpath(LibMCEnv_Build pBuild)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIBuild->UnloadToolpath();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_toolpathisloaded(LibMCEnv_Build pBuild, bool * pIsLoaded)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pIsLoaded == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pIsLoaded = pIBuild->ToolpathIsLoaded();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_createtoolpathaccessor(LibMCEnv_Build pBuild, LibMCEnv_ToolpathAccessor * pToolpathInstance)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pToolpathInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseToolpathInstance(nullptr);
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseToolpathInstance = pIBuild->CreateToolpathAccessor();

		*pToolpathInstance = (IBase*)(pBaseToolpathInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_addbinarydata(LibMCEnv_Build pBuild, const char * pName, const char * pMIMEType, LibMCEnv_uint64 nContentBufferSize, const LibMCEnv_uint8 * pContentBuffer, const LibMCEnv_uint32 nDataUUIDBufferSize, LibMCEnv_uint32* pDataUUIDNeededChars, char * pDataUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pMIMEType == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pContentBuffer) && (nContentBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pDataUUIDBuffer) && !(pDataUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sMIMEType(pMIMEType);
		std::string sDataUUID("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDataUUIDBuffer == nullptr);
		if (isCacheCall) {
			sDataUUID = pIBuild->AddBinaryData(sName, sMIMEType, nContentBufferSize, pContentBuffer);

			pIBuild->_setCache (new ParameterCache_1<std::string> (sDataUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sDataUUID);
			pIBuild->_setCache (nullptr);
		}
		
		if (pDataUUIDNeededChars)
			*pDataUUIDNeededChars = (LibMCEnv_uint32) (sDataUUID.size()+1);
		if (pDataUUIDBuffer) {
			if (sDataUUID.size() >= nDataUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iDataUUID = 0; iDataUUID < sDataUUID.size(); iDataUUID++)
				pDataUUIDBuffer[iDataUUID] = sDataUUID[iDataUUID];
			pDataUUIDBuffer[sDataUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for WorkingFileExecution
**************************************************************************************************************************/
LibMCEnvResult libmcenv_workingfileexecution_getstatus(LibMCEnv_WorkingFileExecution pWorkingFileExecution)
{
	IBase* pIBaseClass = (IBase *)pWorkingFileExecution;

	try {
		IWorkingFileExecution* pIWorkingFileExecution = dynamic_cast<IWorkingFileExecution*>(pIBaseClass);
		if (!pIWorkingFileExecution)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIWorkingFileExecution->GetStatus();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfileexecution_returnstdout(LibMCEnv_WorkingFileExecution pWorkingFileExecution, const LibMCEnv_uint32 nStringBufferBufferSize, LibMCEnv_uint32* pStringBufferNeededChars, char * pStringBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pWorkingFileExecution;

	try {
		if ( (!pStringBufferBuffer) && !(pStringBufferNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStringBuffer("");
		IWorkingFileExecution* pIWorkingFileExecution = dynamic_cast<IWorkingFileExecution*>(pIBaseClass);
		if (!pIWorkingFileExecution)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStringBufferBuffer == nullptr);
		if (isCacheCall) {
			sStringBuffer = pIWorkingFileExecution->ReturnStdOut();

			pIWorkingFileExecution->_setCache (new ParameterCache_1<std::string> (sStringBuffer));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIWorkingFileExecution->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStringBuffer);
			pIWorkingFileExecution->_setCache (nullptr);
		}
		
		if (pStringBufferNeededChars)
			*pStringBufferNeededChars = (LibMCEnv_uint32) (sStringBuffer.size()+1);
		if (pStringBufferBuffer) {
			if (sStringBuffer.size() >= nStringBufferBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStringBuffer = 0; iStringBuffer < sStringBuffer.size(); iStringBuffer++)
				pStringBufferBuffer[iStringBuffer] = sStringBuffer[iStringBuffer];
			pStringBufferBuffer[sStringBuffer.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for WorkingFile
**************************************************************************************************************************/
LibMCEnvResult libmcenv_workingfile_getabsolutefilename(LibMCEnv_WorkingFile pWorkingFile, const LibMCEnv_uint32 nFileNameBufferSize, LibMCEnv_uint32* pFileNameNeededChars, char * pFileNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if ( (!pFileNameBuffer) && !(pFileNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFileName("");
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pFileNameBuffer == nullptr);
		if (isCacheCall) {
			sFileName = pIWorkingFile->GetAbsoluteFileName();

			pIWorkingFile->_setCache (new ParameterCache_1<std::string> (sFileName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIWorkingFile->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sFileName);
			pIWorkingFile->_setCache (nullptr);
		}
		
		if (pFileNameNeededChars)
			*pFileNameNeededChars = (LibMCEnv_uint32) (sFileName.size()+1);
		if (pFileNameBuffer) {
			if (sFileName.size() >= nFileNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iFileName = 0; iFileName < sFileName.size(); iFileName++)
				pFileNameBuffer[iFileName] = sFileName[iFileName];
			pFileNameBuffer[sFileName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_getsize(LibMCEnv_WorkingFile pWorkingFile, LibMCEnv_uint64 * pFileSize)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if (pFileSize == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pFileSize = pIWorkingFile->GetSize();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_calculatesha2(LibMCEnv_WorkingFile pWorkingFile, const LibMCEnv_uint32 nSHA2BufferSize, LibMCEnv_uint32* pSHA2NeededChars, char * pSHA2Buffer)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if ( (!pSHA2Buffer) && !(pSHA2NeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSHA2("");
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSHA2Buffer == nullptr);
		if (isCacheCall) {
			sSHA2 = pIWorkingFile->CalculateSHA2();

			pIWorkingFile->_setCache (new ParameterCache_1<std::string> (sSHA2));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIWorkingFile->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSHA2);
			pIWorkingFile->_setCache (nullptr);
		}
		
		if (pSHA2NeededChars)
			*pSHA2NeededChars = (LibMCEnv_uint32) (sSHA2.size()+1);
		if (pSHA2Buffer) {
			if (sSHA2.size() >= nSHA2BufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA2 = 0; iSHA2 < sSHA2.size(); iSHA2++)
				pSHA2Buffer[iSHA2] = sSHA2[iSHA2];
			pSHA2Buffer[sSHA2.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_deletefile(LibMCEnv_WorkingFile pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIWorkingFile->DeleteFile();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_executefile(LibMCEnv_WorkingFile pWorkingFile, LibMCEnv_WorkingFileExecution * pExecution)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if (pExecution == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseExecution(nullptr);
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseExecution = pIWorkingFile->ExecuteFile();

		*pExecution = (IBase*)(pBaseExecution);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for WorkingDirectory
**************************************************************************************************************************/
LibMCEnvResult libmcenv_workingdirectory_getabsolutefilepath(LibMCEnv_WorkingDirectory pWorkingDirectory, const LibMCEnv_uint32 nFilePathBufferSize, LibMCEnv_uint32* pFilePathNeededChars, char * pFilePathBuffer)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if ( (!pFilePathBuffer) && !(pFilePathNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFilePath("");
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pFilePathBuffer == nullptr);
		if (isCacheCall) {
			sFilePath = pIWorkingDirectory->GetAbsoluteFilePath();

			pIWorkingDirectory->_setCache (new ParameterCache_1<std::string> (sFilePath));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIWorkingDirectory->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sFilePath);
			pIWorkingDirectory->_setCache (nullptr);
		}
		
		if (pFilePathNeededChars)
			*pFilePathNeededChars = (LibMCEnv_uint32) (sFilePath.size()+1);
		if (pFilePathBuffer) {
			if (sFilePath.size() >= nFilePathBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iFilePath = 0; iFilePath < sFilePath.size(); iFilePath++)
				pFilePathBuffer[iFilePath] = sFilePath[iFilePath];
			pFilePathBuffer[sFilePath.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_storecustomdata(LibMCEnv_WorkingDirectory pWorkingDirectory, const char * pFileName, LibMCEnv_uint64 nDataBufferBufferSize, const LibMCEnv_uint8 * pDataBufferBuffer, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pFileName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pDataBufferBuffer) && (nDataBufferBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingDirectory->StoreCustomData(sFileName, nDataBufferBufferSize, pDataBufferBuffer);

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_storedriverdata(LibMCEnv_WorkingDirectory pWorkingDirectory, const char * pFileName, const char * pIdentifier, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pFileName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pIdentifier == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingDirectory->StoreDriverData(sFileName, sIdentifier);

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for DriverEnvironment
**************************************************************************************************************************/
LibMCEnvResult libmcenv_driverenvironment_createworkingdirectory(LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCEnv_WorkingDirectory * pWorkingDirectory)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pWorkingDirectory == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseWorkingDirectory(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingDirectory = pIDriverEnvironment->CreateWorkingDirectory();

		*pWorkingDirectory = (IBase*)(pBaseWorkingDirectory);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_retrievedriverdata(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pIdentifier, const LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ((!pDataBufferBuffer) && !(pDataBufferNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RetrieveDriverData(sIdentifier, nDataBufferBufferSize, pDataBufferNeededCount, pDataBufferBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registerstringparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, const char * pDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDefaultValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		std::string sDefaultValue(pDefaultValue);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterStringParameter(sParameterName, sDescription, sDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registeruuidparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, const char * pDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDefaultValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		std::string sDefaultValue(pDefaultValue);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterUUIDParameter(sParameterName, sDescription, sDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registerdoubleparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, LibMCEnv_double dDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterDoubleParameter(sParameterName, sDescription, dDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registerintegerparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, LibMCEnv_int64 nDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterIntegerParameter(sParameterName, sDescription, nDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registerboolparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, bool bDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterBoolParameter(sParameterName, sDescription, bDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setstringparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetStringParameter(sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setuuidparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetUUIDParameter(sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setdoubleparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetDoubleParameter(sParameterName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setintegerparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetIntegerParameter(sParameterName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setboolparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetBoolParameter(sParameterName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for SignalTrigger
**************************************************************************************************************************/
LibMCEnvResult libmcenv_signaltrigger_cantrigger(LibMCEnv_SignalTrigger pSignalTrigger, bool * pChannelIsAvailable)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pChannelIsAvailable == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pChannelIsAvailable = pISignalTrigger->CanTrigger();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_trigger(LibMCEnv_SignalTrigger pSignalTrigger)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->Trigger();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_waitforhandling(LibMCEnv_SignalTrigger pSignalTrigger, LibMCEnv_uint32 nTimeOut, bool * pSuccess)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pSuccess == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pSuccess = pISignalTrigger->WaitForHandling(nTimeOut);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getname(LibMCEnv_SignalTrigger pSignalTrigger, const LibMCEnv_uint32 nSignalNameBufferSize, LibMCEnv_uint32* pSignalNameNeededChars, char * pSignalNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if ( (!pSignalNameBuffer) && !(pSignalNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalName("");
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSignalNameBuffer == nullptr);
		if (isCacheCall) {
			sSignalName = pISignalTrigger->GetName();

			pISignalTrigger->_setCache (new ParameterCache_1<std::string> (sSignalName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalTrigger->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSignalName);
			pISignalTrigger->_setCache (nullptr);
		}
		
		if (pSignalNameNeededChars)
			*pSignalNameNeededChars = (LibMCEnv_uint32) (sSignalName.size()+1);
		if (pSignalNameBuffer) {
			if (sSignalName.size() >= nSignalNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSignalName = 0; iSignalName < sSignalName.size(); iSignalName++)
				pSignalNameBuffer[iSignalName] = sSignalName[iSignalName];
			pSignalNameBuffer[sSignalName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getstatemachine(LibMCEnv_SignalTrigger pSignalTrigger, const LibMCEnv_uint32 nStateMachineNameBufferSize, LibMCEnv_uint32* pStateMachineNameNeededChars, char * pStateMachineNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if ( (!pStateMachineNameBuffer) && !(pStateMachineNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStateMachineName("");
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStateMachineNameBuffer == nullptr);
		if (isCacheCall) {
			sStateMachineName = pISignalTrigger->GetStateMachine();

			pISignalTrigger->_setCache (new ParameterCache_1<std::string> (sStateMachineName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalTrigger->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStateMachineName);
			pISignalTrigger->_setCache (nullptr);
		}
		
		if (pStateMachineNameNeededChars)
			*pStateMachineNameNeededChars = (LibMCEnv_uint32) (sStateMachineName.size()+1);
		if (pStateMachineNameBuffer) {
			if (sStateMachineName.size() >= nStateMachineNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStateMachineName = 0; iStateMachineName < sStateMachineName.size(); iStateMachineName++)
				pStateMachineNameBuffer[iStateMachineName] = sStateMachineName[iStateMachineName];
			pStateMachineNameBuffer[sStateMachineName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setstring(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue(pValue);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetString(sName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setuuid(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue(pValue);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetUUID(sName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setdouble(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetDouble(sName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setinteger(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetInteger(sName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setbool(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetBool(sName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getstringresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue("");
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pISignalTrigger->GetStringResult(sName);

			pISignalTrigger->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalTrigger->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pISignalTrigger->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getuuidresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue("");
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pISignalTrigger->GetUUIDResult(sName);

			pISignalTrigger->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalTrigger->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pISignalTrigger->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getdoubleresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalTrigger->GetDoubleResult(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getintegerresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalTrigger->GetIntegerResult(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getboolresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalTrigger->GetBoolResult(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for SignalHandler
**************************************************************************************************************************/
LibMCEnvResult libmcenv_signalhandler_signalhandled(LibMCEnv_SignalHandler pSignalHandler)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SignalHandled();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getname(LibMCEnv_SignalHandler pSignalHandler, const LibMCEnv_uint32 nSignalNameBufferSize, LibMCEnv_uint32* pSignalNameNeededChars, char * pSignalNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if ( (!pSignalNameBuffer) && !(pSignalNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalName("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSignalNameBuffer == nullptr);
		if (isCacheCall) {
			sSignalName = pISignalHandler->GetName();

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sSignalName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSignalName);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pSignalNameNeededChars)
			*pSignalNameNeededChars = (LibMCEnv_uint32) (sSignalName.size()+1);
		if (pSignalNameBuffer) {
			if (sSignalName.size() >= nSignalNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSignalName = 0; iSignalName < sSignalName.size(); iSignalName++)
				pSignalNameBuffer[iSignalName] = sSignalName[iSignalName];
			pSignalNameBuffer[sSignalName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getsignalid(LibMCEnv_SignalHandler pSignalHandler, const LibMCEnv_uint32 nSignalIDBufferSize, LibMCEnv_uint32* pSignalIDNeededChars, char * pSignalIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if ( (!pSignalIDBuffer) && !(pSignalIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalID("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSignalIDBuffer == nullptr);
		if (isCacheCall) {
			sSignalID = pISignalHandler->GetSignalID();

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sSignalID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSignalID);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pSignalIDNeededChars)
			*pSignalIDNeededChars = (LibMCEnv_uint32) (sSignalID.size()+1);
		if (pSignalIDBuffer) {
			if (sSignalID.size() >= nSignalIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSignalID = 0; iSignalID < sSignalID.size(); iSignalID++)
				pSignalIDBuffer[iSignalID] = sSignalID[iSignalID];
			pSignalIDBuffer[sSignalID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getstatemachine(LibMCEnv_SignalHandler pSignalHandler, const LibMCEnv_uint32 nStateMachineNameBufferSize, LibMCEnv_uint32* pStateMachineNameNeededChars, char * pStateMachineNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if ( (!pStateMachineNameBuffer) && !(pStateMachineNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStateMachineName("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStateMachineNameBuffer == nullptr);
		if (isCacheCall) {
			sStateMachineName = pISignalHandler->GetStateMachine();

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sStateMachineName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStateMachineName);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pStateMachineNameNeededChars)
			*pStateMachineNameNeededChars = (LibMCEnv_uint32) (sStateMachineName.size()+1);
		if (pStateMachineNameBuffer) {
			if (sStateMachineName.size() >= nStateMachineNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStateMachineName = 0; iStateMachineName < sStateMachineName.size(); iStateMachineName++)
				pStateMachineNameBuffer[iStateMachineName] = sStateMachineName[iStateMachineName];
			pStateMachineNameBuffer[sStateMachineName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getstring(LibMCEnv_SignalHandler pSignalHandler, const char * pName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pISignalHandler->GetString(sName);

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getuuid(LibMCEnv_SignalHandler pSignalHandler, const char * pName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pISignalHandler->GetUUID(sName);

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getdouble(LibMCEnv_SignalHandler pSignalHandler, const char * pName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalHandler->GetDouble(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getinteger(LibMCEnv_SignalHandler pSignalHandler, const char * pName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalHandler->GetInteger(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getbool(LibMCEnv_SignalHandler pSignalHandler, const char * pName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalHandler->GetBool(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setstringresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue(pValue);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetStringResult(sName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setuuidresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue(pValue);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetUUIDResult(sName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setdoubleresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetDoubleResult(sName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setintegerresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetIntegerResult(sName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setboolresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetBoolResult(sName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for StateEnvironment
**************************************************************************************************************************/
LibMCEnvResult libmcenv_stateenvironment_preparesignal(LibMCEnv_StateEnvironment pStateEnvironment, const char * pMachineInstance, const char * pSignalName, LibMCEnv_SignalTrigger * pSignalInstance)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSignalName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSignalInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sSignalName(pSignalName);
		IBase* pBaseSignalInstance(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseSignalInstance = pIStateEnvironment->PrepareSignal(sMachineInstance, sSignalName);

		*pSignalInstance = (IBase*)(pBaseSignalInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_waitforsignal(LibMCEnv_StateEnvironment pStateEnvironment, const char * pSignalName, LibMCEnv_uint32 nTimeOut, LibMCEnv_SignalHandler * pHandlerInstance, bool * pSuccess)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pSignalName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHandlerInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSuccess == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalName(pSignalName);
		ISignalHandler* pBaseHandlerInstance(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pSuccess = pIStateEnvironment->WaitForSignal(sSignalName, nTimeOut, pBaseHandlerInstance);

		*pHandlerInstance = (IBase*)(pBaseHandlerInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getdriverlibrary(LibMCEnv_StateEnvironment pStateEnvironment, const char * pDriverName, const LibMCEnv_uint32 nDriverTypeBufferSize, LibMCEnv_uint32* pDriverTypeNeededChars, char * pDriverTypeBuffer, LibMCEnv_pvoid * pDriverLookup)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pDriverName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pDriverTypeBuffer) && !(pDriverTypeNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pDriverLookup)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sDriverName(pDriverName);
		std::string sDriverType("");
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDriverTypeBuffer == nullptr);
		if (isCacheCall) {
			pIStateEnvironment->GetDriverLibrary(sDriverName, sDriverType, *pDriverLookup);

			pIStateEnvironment->_setCache (new ParameterCache_2<std::string, LibMCEnv_pvoid> (sDriverType, *pDriverLookup));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, LibMCEnv_pvoid>*> (pIStateEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sDriverType, *pDriverLookup);
			pIStateEnvironment->_setCache (nullptr);
		}
		
		if (pDriverTypeNeededChars)
			*pDriverTypeNeededChars = (LibMCEnv_uint32) (sDriverType.size()+1);
		if (pDriverTypeBuffer) {
			if (sDriverType.size() >= nDriverTypeBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iDriverType = 0; iDriverType < sDriverType.size(); iDriverType++)
				pDriverTypeBuffer[iDriverType] = sDriverType[iDriverType];
			pDriverTypeBuffer[sDriverType.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_createdriveraccess(LibMCEnv_StateEnvironment pStateEnvironment, const char * pDriverName, LibMCEnv_pvoid * pDriverHandle)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pDriverName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pDriverHandle)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sDriverName(pDriverName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->CreateDriverAccess(sDriverName, *pDriverHandle);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getbuildjob(LibMCEnv_StateEnvironment pStateEnvironment, const char * pBuildUUID, LibMCEnv_Build * pBuildInstance)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pBuildUUID == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pBuildInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sBuildUUID(pBuildUUID);
		IBase* pBaseBuildInstance(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseBuildInstance = pIStateEnvironment->GetBuildJob(sBuildUUID);

		*pBuildInstance = (IBase*)(pBaseBuildInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_unloadalltoolpathes(LibMCEnv_StateEnvironment pStateEnvironment)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->UnloadAllToolpathes();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setnextstate(LibMCEnv_StateEnvironment pStateEnvironment, const char * pStateName)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pStateName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStateName(pStateName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetNextState(sStateName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_logmessage(LibMCEnv_StateEnvironment pStateEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->LogMessage(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_logwarning(LibMCEnv_StateEnvironment pStateEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->LogWarning(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_loginfo(LibMCEnv_StateEnvironment pStateEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->LogInfo(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_sleep(LibMCEnv_StateEnvironment pStateEnvironment, LibMCEnv_uint32 nDelay)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->Sleep(nDelay);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_checkfortermination(LibMCEnv_StateEnvironment pStateEnvironment, bool * pShallTerminate)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pShallTerminate == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pShallTerminate = pIStateEnvironment->CheckForTermination();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_storesignal(LibMCEnv_StateEnvironment pStateEnvironment, const char * pName, LibMCEnv_SignalHandler pHandler)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBase* pIBaseClassHandler = (IBase *)pHandler;
		ISignalHandler* pIHandler = dynamic_cast<ISignalHandler*>(pIBaseClassHandler);
		if (!pIHandler)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDCAST);
		
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->StoreSignal(sName, pIHandler);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_retrievesignal(LibMCEnv_StateEnvironment pStateEnvironment, const char * pName, LibMCEnv_SignalHandler * pHandler)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHandler == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBase* pBaseHandler(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseHandler = pIStateEnvironment->RetrieveSignal(sName);

		*pHandler = (IBase*)(pBaseHandler);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_clearstoredvalue(LibMCEnv_StateEnvironment pStateEnvironment, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->ClearStoredValue(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setstringparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetStringParameter(sParameterGroup, sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setuuidparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetUUIDParameter(sParameterGroup, sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setdoubleparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetDoubleParameter(sParameterGroup, sParameterName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setintegerparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetIntegerParameter(sParameterGroup, sParameterName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setboolparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetBoolParameter(sParameterGroup, sParameterName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getstringparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue("");
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIStateEnvironment->GetStringParameter(sParameterGroup, sParameterName);

			pIStateEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStateEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIStateEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getuuidparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue("");
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIStateEnvironment->GetUUIDParameter(sParameterGroup, sParameterName);

			pIStateEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStateEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIStateEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getdoubleparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIStateEnvironment->GetDoubleParameter(sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getintegerparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIStateEnvironment->GetIntegerParameter(sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getboolparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIStateEnvironment->GetBoolParameter(sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for UIEnvironment
**************************************************************************************************************************/
LibMCEnvResult libmcenv_uienvironment_preparesignal(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pSignalName, LibMCEnv_SignalTrigger * pSignalInstance)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSignalName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSignalInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sSignalName(pSignalName);
		IBase* pBaseSignalInstance(nullptr);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseSignalInstance = pIUIEnvironment->PrepareSignal(sMachineInstance, sSignalName);

		*pSignalInstance = (IBase*)(pBaseSignalInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getmachinestate(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const LibMCEnv_uint32 nStateNameBufferSize, LibMCEnv_uint32* pStateNameNeededChars, char * pStateNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pStateNameBuffer) && !(pStateNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sStateName("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStateNameBuffer == nullptr);
		if (isCacheCall) {
			sStateName = pIUIEnvironment->GetMachineState(sMachineInstance);

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sStateName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStateName);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pStateNameNeededChars)
			*pStateNameNeededChars = (LibMCEnv_uint32) (sStateName.size()+1);
		if (pStateNameBuffer) {
			if (sStateName.size() >= nStateNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStateName = 0; iStateName < sStateName.size(); iStateName++)
				pStateNameBuffer[iStateName] = sStateName[iStateName];
			pStateNameBuffer[sStateName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_logmessage(LibMCEnv_UIEnvironment pUIEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->LogMessage(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_logwarning(LibMCEnv_UIEnvironment pUIEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->LogWarning(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_loginfo(LibMCEnv_UIEnvironment pUIEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->LogInfo(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getstringparameter(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIUIEnvironment->GetStringParameter(sMachineInstance, sParameterGroup, sParameterName);

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getuuidparameter(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIUIEnvironment->GetUUIDParameter(sMachineInstance, sParameterGroup, sParameterName);

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getdoubleparameter(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIUIEnvironment->GetDoubleParameter(sMachineInstance, sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getintegerparameter(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIUIEnvironment->GetIntegerParameter(sMachineInstance, sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getboolparameter(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIUIEnvironment->GetBoolParameter(sMachineInstance, sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_geteventcontext(LibMCEnv_UIEnvironment pUIEnvironment, const LibMCEnv_uint32 nContextUUIDBufferSize, LibMCEnv_uint32* pContextUUIDNeededChars, char * pContextUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if ( (!pContextUUIDBuffer) && !(pContextUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sContextUUID("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pContextUUIDBuffer == nullptr);
		if (isCacheCall) {
			sContextUUID = pIUIEnvironment->GetEventContext();

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sContextUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sContextUUID);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pContextUUIDNeededChars)
			*pContextUUIDNeededChars = (LibMCEnv_uint32) (sContextUUID.size()+1);
		if (pContextUUIDBuffer) {
			if (sContextUUID.size() >= nContextUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iContextUUID = 0; iContextUUID < sContextUUID.size(); iContextUUID++)
				pContextUUIDBuffer[iContextUUID] = sContextUUID[iContextUUID];
			pContextUUIDBuffer[sContextUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCEnvResult LibMCEnv::Impl::LibMCEnv_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCENV_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCENV_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcenv_toolpathlayer_getlayerdatauuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getlayerdatauuid;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentcount") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentcount;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentinfo") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentinfo;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofileuuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofileuuid;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofilevalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofilevalue;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofiletypedvalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofiletypedvalue;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentpartuuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentpartuuid;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentpointdata") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentpointdata;
	if (sProcName == "libmcenv_toolpathlayer_getzvalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getzvalue;
	if (sProcName == "libmcenv_toolpathlayer_getunits") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getunits;
	if (sProcName == "libmcenv_toolpathaccessor_getstorageuuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getstorageuuid;
	if (sProcName == "libmcenv_toolpathaccessor_getlayercount") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getlayercount;
	if (sProcName == "libmcenv_toolpathaccessor_loadlayer") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_loadlayer;
	if (sProcName == "libmcenv_toolpathaccessor_getunits") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getunits;
	if (sProcName == "libmcenv_build_getname") 
		*ppProcAddress = (void*) &libmcenv_build_getname;
	if (sProcName == "libmcenv_build_getbuilduuid") 
		*ppProcAddress = (void*) &libmcenv_build_getbuilduuid;
	if (sProcName == "libmcenv_build_getstorageuuid") 
		*ppProcAddress = (void*) &libmcenv_build_getstorageuuid;
	if (sProcName == "libmcenv_build_getstoragesha256") 
		*ppProcAddress = (void*) &libmcenv_build_getstoragesha256;
	if (sProcName == "libmcenv_build_getlayercount") 
		*ppProcAddress = (void*) &libmcenv_build_getlayercount;
	if (sProcName == "libmcenv_build_loadtoolpath") 
		*ppProcAddress = (void*) &libmcenv_build_loadtoolpath;
	if (sProcName == "libmcenv_build_unloadtoolpath") 
		*ppProcAddress = (void*) &libmcenv_build_unloadtoolpath;
	if (sProcName == "libmcenv_build_toolpathisloaded") 
		*ppProcAddress = (void*) &libmcenv_build_toolpathisloaded;
	if (sProcName == "libmcenv_build_createtoolpathaccessor") 
		*ppProcAddress = (void*) &libmcenv_build_createtoolpathaccessor;
	if (sProcName == "libmcenv_build_addbinarydata") 
		*ppProcAddress = (void*) &libmcenv_build_addbinarydata;
	if (sProcName == "libmcenv_workingfileexecution_getstatus") 
		*ppProcAddress = (void*) &libmcenv_workingfileexecution_getstatus;
	if (sProcName == "libmcenv_workingfileexecution_returnstdout") 
		*ppProcAddress = (void*) &libmcenv_workingfileexecution_returnstdout;
	if (sProcName == "libmcenv_workingfile_getabsolutefilename") 
		*ppProcAddress = (void*) &libmcenv_workingfile_getabsolutefilename;
	if (sProcName == "libmcenv_workingfile_getsize") 
		*ppProcAddress = (void*) &libmcenv_workingfile_getsize;
	if (sProcName == "libmcenv_workingfile_calculatesha2") 
		*ppProcAddress = (void*) &libmcenv_workingfile_calculatesha2;
	if (sProcName == "libmcenv_workingfile_deletefile") 
		*ppProcAddress = (void*) &libmcenv_workingfile_deletefile;
	if (sProcName == "libmcenv_workingfile_executefile") 
		*ppProcAddress = (void*) &libmcenv_workingfile_executefile;
	if (sProcName == "libmcenv_workingdirectory_getabsolutefilepath") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_getabsolutefilepath;
	if (sProcName == "libmcenv_workingdirectory_storecustomdata") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_storecustomdata;
	if (sProcName == "libmcenv_workingdirectory_storedriverdata") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_storedriverdata;
	if (sProcName == "libmcenv_driverenvironment_createworkingdirectory") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_createworkingdirectory;
	if (sProcName == "libmcenv_driverenvironment_retrievedriverdata") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_retrievedriverdata;
	if (sProcName == "libmcenv_driverenvironment_registerstringparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registerstringparameter;
	if (sProcName == "libmcenv_driverenvironment_registeruuidparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registeruuidparameter;
	if (sProcName == "libmcenv_driverenvironment_registerdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registerdoubleparameter;
	if (sProcName == "libmcenv_driverenvironment_registerintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registerintegerparameter;
	if (sProcName == "libmcenv_driverenvironment_registerboolparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registerboolparameter;
	if (sProcName == "libmcenv_driverenvironment_setstringparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setstringparameter;
	if (sProcName == "libmcenv_driverenvironment_setuuidparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setuuidparameter;
	if (sProcName == "libmcenv_driverenvironment_setdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setdoubleparameter;
	if (sProcName == "libmcenv_driverenvironment_setintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setintegerparameter;
	if (sProcName == "libmcenv_driverenvironment_setboolparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setboolparameter;
	if (sProcName == "libmcenv_signaltrigger_cantrigger") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_cantrigger;
	if (sProcName == "libmcenv_signaltrigger_trigger") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_trigger;
	if (sProcName == "libmcenv_signaltrigger_waitforhandling") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_waitforhandling;
	if (sProcName == "libmcenv_signaltrigger_getname") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getname;
	if (sProcName == "libmcenv_signaltrigger_getstatemachine") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getstatemachine;
	if (sProcName == "libmcenv_signaltrigger_setstring") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setstring;
	if (sProcName == "libmcenv_signaltrigger_setuuid") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setuuid;
	if (sProcName == "libmcenv_signaltrigger_setdouble") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setdouble;
	if (sProcName == "libmcenv_signaltrigger_setinteger") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setinteger;
	if (sProcName == "libmcenv_signaltrigger_setbool") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setbool;
	if (sProcName == "libmcenv_signaltrigger_getstringresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getstringresult;
	if (sProcName == "libmcenv_signaltrigger_getuuidresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getuuidresult;
	if (sProcName == "libmcenv_signaltrigger_getdoubleresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getdoubleresult;
	if (sProcName == "libmcenv_signaltrigger_getintegerresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getintegerresult;
	if (sProcName == "libmcenv_signaltrigger_getboolresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getboolresult;
	if (sProcName == "libmcenv_signalhandler_signalhandled") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_signalhandled;
	if (sProcName == "libmcenv_signalhandler_getname") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getname;
	if (sProcName == "libmcenv_signalhandler_getsignalid") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getsignalid;
	if (sProcName == "libmcenv_signalhandler_getstatemachine") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getstatemachine;
	if (sProcName == "libmcenv_signalhandler_getstring") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getstring;
	if (sProcName == "libmcenv_signalhandler_getuuid") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getuuid;
	if (sProcName == "libmcenv_signalhandler_getdouble") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getdouble;
	if (sProcName == "libmcenv_signalhandler_getinteger") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getinteger;
	if (sProcName == "libmcenv_signalhandler_getbool") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getbool;
	if (sProcName == "libmcenv_signalhandler_setstringresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setstringresult;
	if (sProcName == "libmcenv_signalhandler_setuuidresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setuuidresult;
	if (sProcName == "libmcenv_signalhandler_setdoubleresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setdoubleresult;
	if (sProcName == "libmcenv_signalhandler_setintegerresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setintegerresult;
	if (sProcName == "libmcenv_signalhandler_setboolresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setboolresult;
	if (sProcName == "libmcenv_stateenvironment_preparesignal") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_preparesignal;
	if (sProcName == "libmcenv_stateenvironment_waitforsignal") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_waitforsignal;
	if (sProcName == "libmcenv_stateenvironment_getdriverlibrary") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getdriverlibrary;
	if (sProcName == "libmcenv_stateenvironment_createdriveraccess") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_createdriveraccess;
	if (sProcName == "libmcenv_stateenvironment_getbuildjob") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getbuildjob;
	if (sProcName == "libmcenv_stateenvironment_unloadalltoolpathes") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_unloadalltoolpathes;
	if (sProcName == "libmcenv_stateenvironment_setnextstate") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setnextstate;
	if (sProcName == "libmcenv_stateenvironment_logmessage") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_logmessage;
	if (sProcName == "libmcenv_stateenvironment_logwarning") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_logwarning;
	if (sProcName == "libmcenv_stateenvironment_loginfo") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_loginfo;
	if (sProcName == "libmcenv_stateenvironment_sleep") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_sleep;
	if (sProcName == "libmcenv_stateenvironment_checkfortermination") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_checkfortermination;
	if (sProcName == "libmcenv_stateenvironment_storesignal") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_storesignal;
	if (sProcName == "libmcenv_stateenvironment_retrievesignal") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_retrievesignal;
	if (sProcName == "libmcenv_stateenvironment_clearstoredvalue") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_clearstoredvalue;
	if (sProcName == "libmcenv_stateenvironment_setstringparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setstringparameter;
	if (sProcName == "libmcenv_stateenvironment_setuuidparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setuuidparameter;
	if (sProcName == "libmcenv_stateenvironment_setdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setdoubleparameter;
	if (sProcName == "libmcenv_stateenvironment_setintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setintegerparameter;
	if (sProcName == "libmcenv_stateenvironment_setboolparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setboolparameter;
	if (sProcName == "libmcenv_stateenvironment_getstringparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getstringparameter;
	if (sProcName == "libmcenv_stateenvironment_getuuidparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getuuidparameter;
	if (sProcName == "libmcenv_stateenvironment_getdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getdoubleparameter;
	if (sProcName == "libmcenv_stateenvironment_getintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getintegerparameter;
	if (sProcName == "libmcenv_stateenvironment_getboolparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getboolparameter;
	if (sProcName == "libmcenv_uienvironment_preparesignal") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_preparesignal;
	if (sProcName == "libmcenv_uienvironment_getmachinestate") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getmachinestate;
	if (sProcName == "libmcenv_uienvironment_logmessage") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_logmessage;
	if (sProcName == "libmcenv_uienvironment_logwarning") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_logwarning;
	if (sProcName == "libmcenv_uienvironment_loginfo") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_loginfo;
	if (sProcName == "libmcenv_uienvironment_getstringparameter") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getstringparameter;
	if (sProcName == "libmcenv_uienvironment_getuuidparameter") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getuuidparameter;
	if (sProcName == "libmcenv_uienvironment_getdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getdoubleparameter;
	if (sProcName == "libmcenv_uienvironment_getintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getintegerparameter;
	if (sProcName == "libmcenv_uienvironment_getboolparameter") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getboolparameter;
	if (sProcName == "libmcenv_uienvironment_geteventcontext") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_geteventcontext;
	if (sProcName == "libmcenv_getversion") 
		*ppProcAddress = (void*) &libmcenv_getversion;
	if (sProcName == "libmcenv_getlasterror") 
		*ppProcAddress = (void*) &libmcenv_getlasterror;
	if (sProcName == "libmcenv_releaseinstance") 
		*ppProcAddress = (void*) &libmcenv_releaseinstance;
	if (sProcName == "libmcenv_acquireinstance") 
		*ppProcAddress = (void*) &libmcenv_acquireinstance;
	if (sProcName == "libmcenv_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcenv_getsymbollookupmethod;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCENV_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCEnvResult libmcenv_getversion(LibMCEnv_uint32 * pMajor, LibMCEnv_uint32 * pMinor, LibMCEnv_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_getlasterror(LibMCEnv_Base pInstance, const LibMCEnv_uint32 nErrorMessageBufferSize, LibMCEnv_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCEnv_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_releaseinstance(LibMCEnv_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_acquireinstance(LibMCEnv_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_getsymbollookupmethod(LibMCEnv_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCEnv::Impl::LibMCEnv_GetProcAddress;
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


