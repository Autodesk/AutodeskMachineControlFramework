/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of MC Environment Interface. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmcenv_abi.hpp"
#include "libmcenv_interfaces.hpp"
#include "libmcenv_interfaceexception.hpp"

#include <map>

using namespace LibMCEnv::Impl;

LibMCEnvResult handleLibMCEnvException(IBase * pIBaseClass, ELibMCEnvInterfaceException & Exception)
{
	LibMCEnvResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCEnvResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCEnvResult errorCode = LIBMCENV_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCEnvResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCEnvResult errorCode = LIBMCENV_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Iterator
**************************************************************************************************************************/
LibMCEnvResult libmcenv_iterator_movenext(LibMCEnv_Iterator pIterator, bool * pHasNext)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasNext == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pHasNext = pIIterator->MoveNext();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_iterator_moveprevious(LibMCEnv_Iterator pIterator, bool * pHasPrevious)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasPrevious == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pHasPrevious = pIIterator->MovePrevious();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_iterator_getcurrent(LibMCEnv_Iterator pIterator, LibMCEnv_Base * pInstance)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseInstance = pIIterator->GetCurrent();

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_iterator_clone(LibMCEnv_Iterator pIterator, LibMCEnv_Iterator * pOutIterator)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pOutIterator == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseOutIterator(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseOutIterator = pIIterator->Clone();

		*pOutIterator = (IBase*)(pBaseOutIterator);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_iterator_count(LibMCEnv_Iterator pIterator, LibMCEnv_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIIterator->Count();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for TestEnvironment
**************************************************************************************************************************/
LibMCEnvResult libmcenv_testenvironment_writetestoutput(LibMCEnv_TestEnvironment pTestEnvironment, const char * pOutputName, LibMCEnv_uint64 nDataBufferSize, const LibMCEnv_uint8 * pDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pTestEnvironment;

	try {
		if (pOutputName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pDataBuffer) && (nDataBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sOutputName(pOutputName);
		ITestEnvironment* pITestEnvironment = dynamic_cast<ITestEnvironment*>(pIBaseClass);
		if (!pITestEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pITestEnvironment->WriteTestOutput(sOutputName, nDataBufferSize, pDataBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ImageData
**************************************************************************************************************************/
LibMCEnvResult libmcenv_imagedata_getpixelformat(LibMCEnv_ImageData pImageData, eLibMCEnvImagePixelFormat * pPixelFormat)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if (pPixelFormat == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pPixelFormat = pIImageData->GetPixelFormat();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_changepixelformat(LibMCEnv_ImageData pImageData, eLibMCEnvImagePixelFormat ePixelFormat)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->ChangePixelFormat(ePixelFormat);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_getdpi(LibMCEnv_ImageData pImageData, LibMCEnv_double * pDPIValueX, LibMCEnv_double * pDPIValueY)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if (!pDPIValueX)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pDPIValueY)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->GetDPI(*pDPIValueX, *pDPIValueY);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_setdpi(LibMCEnv_ImageData pImageData, LibMCEnv_double dDPIValueX, LibMCEnv_double dDPIValueY)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->SetDPI(dDPIValueX, dDPIValueY);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_getsizeinmm(LibMCEnv_ImageData pImageData, LibMCEnv_double * pSizeX, LibMCEnv_double * pSizeY)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if (!pSizeX)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pSizeY)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->GetSizeInMM(*pSizeX, *pSizeY);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_getsizeinpixels(LibMCEnv_ImageData pImageData, LibMCEnv_uint32 * pPixelSizeX, LibMCEnv_uint32 * pPixelSizeY)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if (!pPixelSizeX)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pPixelSizeY)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->GetSizeInPixels(*pPixelSizeX, *pPixelSizeY);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_resizeimage(LibMCEnv_ImageData pImageData, LibMCEnv_uint32 * pPixelSizeX, LibMCEnv_uint32 * pPixelSizeY)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if (!pPixelSizeX)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pPixelSizeY)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->ResizeImage(*pPixelSizeX, *pPixelSizeY);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_loadpng(LibMCEnv_ImageData pImageData, const LibMCEnv_uint64 nPNGDataBufferSize, LibMCEnv_uint64* pPNGDataNeededCount, LibMCEnv_uint8 * pPNGDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if ((!pPNGDataBuffer) && !(pPNGDataNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->LoadPNG(nPNGDataBufferSize, pPNGDataNeededCount, pPNGDataBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_encodepng(LibMCEnv_ImageData pImageData)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->EncodePNG();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_getencodedpngdata(LibMCEnv_ImageData pImageData, const LibMCEnv_uint64 nPNGDataBufferSize, LibMCEnv_uint64* pPNGDataNeededCount, LibMCEnv_uint8 * pPNGDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if ((!pPNGDataBuffer) && !(pPNGDataNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->GetEncodedPNGData(nPNGDataBufferSize, pPNGDataNeededCount, pPNGDataBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_clearencodedpngdata(LibMCEnv_ImageData pImageData)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->ClearEncodedPNGData();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_clear(LibMCEnv_ImageData pImageData, LibMCEnv_uint32 nValue)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->Clear(nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_getpixel(LibMCEnv_ImageData pImageData, LibMCEnv_uint32 nX, LibMCEnv_uint32 nY, LibMCEnv_uint32 * pValue)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIImageData->GetPixel(nX, nY);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_setpixel(LibMCEnv_ImageData pImageData, LibMCEnv_uint32 nX, LibMCEnv_uint32 nY, LibMCEnv_uint32 nValue)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->SetPixel(nX, nY, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_getpixelrange(LibMCEnv_ImageData pImageData, LibMCEnv_uint32 nXMin, LibMCEnv_uint32 nYMin, LibMCEnv_uint32 nXMax, LibMCEnv_uint32 nYMax, const LibMCEnv_uint64 nValueBufferSize, LibMCEnv_uint64* pValueNeededCount, LibMCEnv_uint8 * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if ((!pValueBuffer) && !(pValueNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->GetPixelRange(nXMin, nYMin, nXMax, nYMax, nValueBufferSize, pValueNeededCount, pValueBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_imagedata_setpixelrange(LibMCEnv_ImageData pImageData, LibMCEnv_uint32 nXMin, LibMCEnv_uint32 nYMin, LibMCEnv_uint32 nXMax, LibMCEnv_uint32 nYMax, LibMCEnv_uint64 nValueBufferSize, const LibMCEnv_uint8 * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pImageData;

	try {
		if ( (!pValueBuffer) && (nValueBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IImageData* pIImageData = dynamic_cast<IImageData*>(pIBaseClass);
		if (!pIImageData)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIImageData->SetPixelRange(nXMin, nYMin, nXMax, nYMax, nValueBufferSize, pValueBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ToolpathPart
**************************************************************************************************************************/
LibMCEnvResult libmcenv_toolpathpart_getname(LibMCEnv_ToolpathPart pToolpathPart, const LibMCEnv_uint32 nNameBufferSize, LibMCEnv_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathPart;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName("");
		IToolpathPart* pIToolpathPart = dynamic_cast<IToolpathPart*>(pIBaseClass);
		if (!pIToolpathPart)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIToolpathPart->GetName();

			pIToolpathPart->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathPart->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIToolpathPart->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCEnv_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathpart_getuuid(LibMCEnv_ToolpathPart pToolpathPart, const LibMCEnv_uint32 nUUIDBufferSize, LibMCEnv_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathPart;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IToolpathPart* pIToolpathPart = dynamic_cast<IToolpathPart*>(pIBaseClass);
		if (!pIToolpathPart)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIToolpathPart->GetUUID();

			pIToolpathPart->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathPart->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIToolpathPart->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCEnv_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathpart_getmeshuuid(LibMCEnv_ToolpathPart pToolpathPart, const LibMCEnv_uint32 nMeshUUIDBufferSize, LibMCEnv_uint32* pMeshUUIDNeededChars, char * pMeshUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathPart;

	try {
		if ( (!pMeshUUIDBuffer) && !(pMeshUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMeshUUID("");
		IToolpathPart* pIToolpathPart = dynamic_cast<IToolpathPart*>(pIBaseClass);
		if (!pIToolpathPart)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMeshUUIDBuffer == nullptr);
		if (isCacheCall) {
			sMeshUUID = pIToolpathPart->GetMeshUUID();

			pIToolpathPart->_setCache (new ParameterCache_1<std::string> (sMeshUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathPart->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sMeshUUID);
			pIToolpathPart->_setCache (nullptr);
		}
		
		if (pMeshUUIDNeededChars)
			*pMeshUUIDNeededChars = (LibMCEnv_uint32) (sMeshUUID.size()+1);
		if (pMeshUUIDBuffer) {
			if (sMeshUUID.size() >= nMeshUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iMeshUUID = 0; iMeshUUID < sMeshUUID.size(); iMeshUUID++)
				pMeshUUIDBuffer[iMeshUUID] = sMeshUUID[iMeshUUID];
			pMeshUUIDBuffer[sMeshUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathpart_gettransform(LibMCEnv_ToolpathPart pToolpathPart, sLibMCEnvToolpathPartTransform * pMeshUUID)
{
	IBase* pIBaseClass = (IBase *)pToolpathPart;

	try {
		if (pMeshUUID == nullptr)
		throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathPart* pIToolpathPart = dynamic_cast<IToolpathPart*>(pIBaseClass);
		if (!pIToolpathPart)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pMeshUUID = pIToolpathPart->GetTransform();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ToolpathLayer
**************************************************************************************************************************/
LibMCEnvResult libmcenv_toolpathlayer_getlayerdatauuid(LibMCEnv_ToolpathLayer pToolpathLayer, const LibMCEnv_uint32 nUUIDBufferSize, LibMCEnv_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIToolpathLayer->GetLayerDataUUID();

			pIToolpathLayer->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathLayer->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIToolpathLayer->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCEnv_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentcount(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIToolpathLayer->GetSegmentCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentinfo(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, eLibMCEnvToolpathSegmentType * pType, LibMCEnv_uint32 * pPointCount)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (!pType)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pPointCount)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIToolpathLayer->GetSegmentInfo(nIndex, *pType, *pPointCount);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmenttype(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, eLibMCEnvToolpathSegmentType * pType)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pType == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pType = pIToolpathLayer->GetSegmentType(nIndex);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentpointcount(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, LibMCEnv_uint32 * pHatchCount)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pHatchCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pHatchCount = pIToolpathLayer->GetSegmentPointCount(nIndex);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmenthatchcount(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, LibMCEnv_uint32 * pHatchCount)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pHatchCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pHatchCount = pIToolpathLayer->GetSegmentHatchCount(nIndex);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofileuuid(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nProfileUUIDBufferSize, LibMCEnv_uint32* pProfileUUIDNeededChars, char * pProfileUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ( (!pProfileUUIDBuffer) && !(pProfileUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sProfileUUID("");
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pProfileUUIDBuffer == nullptr);
		if (isCacheCall) {
			sProfileUUID = pIToolpathLayer->GetSegmentProfileUUID(nIndex);

			pIToolpathLayer->_setCache (new ParameterCache_1<std::string> (sProfileUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathLayer->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sProfileUUID);
			pIToolpathLayer->_setCache (nullptr);
		}
		
		if (pProfileUUIDNeededChars)
			*pProfileUUIDNeededChars = (LibMCEnv_uint32) (sProfileUUID.size()+1);
		if (pProfileUUIDBuffer) {
			if (sProfileUUID.size() >= nProfileUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iProfileUUID = 0; iProfileUUID < sProfileUUID.size(); iProfileUUID++)
				pProfileUUIDBuffer[iProfileUUID] = sProfileUUID[iProfileUUID];
			pProfileUUIDBuffer[sProfileUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_segmentprofilehasvalue(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const char * pNamespace, const char * pValueName, bool * pHasValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHasValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sValueName(pValueName);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pHasValue = pIToolpathLayer->SegmentProfileHasValue(nIndex, sNamespace, sValueName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofilevalue(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const char * pNamespace, const char * pValueName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sValueName(pValueName);
		std::string sValue("");
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIToolpathLayer->GetSegmentProfileValue(nIndex, sNamespace, sValueName);

			pIToolpathLayer->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathLayer->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIToolpathLayer->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofilevaluedef(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const char * pNamespace, const char * pValueName, const char * pDefaultValue, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDefaultValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sValueName(pValueName);
		std::string sDefaultValue(pDefaultValue);
		std::string sValue("");
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIToolpathLayer->GetSegmentProfileValueDef(nIndex, sNamespace, sValueName, sDefaultValue);

			pIToolpathLayer->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathLayer->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIToolpathLayer->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofiledoublevalue(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const char * pNamespace, const char * pValueName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sValueName(pValueName);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIToolpathLayer->GetSegmentProfileDoubleValue(nIndex, sNamespace, sValueName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofiledoublevaluedef(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const char * pNamespace, const char * pValueName, LibMCEnv_double dDefaultValue, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sValueName(pValueName);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIToolpathLayer->GetSegmentProfileDoubleValueDef(nIndex, sNamespace, sValueName, dDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofileintegervalue(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const char * pNamespace, const char * pValueName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sValueName(pValueName);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIToolpathLayer->GetSegmentProfileIntegerValue(nIndex, sNamespace, sValueName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofileintegervaluedef(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const char * pNamespace, const char * pValueName, LibMCEnv_int64 nDefaultValue, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sValueName(pValueName);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIToolpathLayer->GetSegmentProfileIntegerValueDef(nIndex, sNamespace, sValueName, nDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofileboolvalue(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const char * pNamespace, const char * pValueName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sValueName(pValueName);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIToolpathLayer->GetSegmentProfileBoolValue(nIndex, sNamespace, sValueName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofileboolvaluedef(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const char * pNamespace, const char * pValueName, bool bDefaultValue, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValueName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sValueName(pValueName);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIToolpathLayer->GetSegmentProfileBoolValueDef(nIndex, sNamespace, sValueName, bDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofiletypedvalue(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, eLibMCEnvToolpathProfileValueType eValueType, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIToolpathLayer->GetSegmentProfileTypedValue(nIndex, eValueType);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentprofiletypedvaluedef(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, eLibMCEnvToolpathProfileValueType eValueType, LibMCEnv_double dDefaultValue, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIToolpathLayer->GetSegmentProfileTypedValueDef(nIndex, eValueType, dDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentpartuuid(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const LibMCEnv_uint32 nPartUUIDBufferSize, LibMCEnv_uint32* pPartUUIDNeededChars, char * pPartUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ( (!pPartUUIDBuffer) && !(pPartUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sPartUUID("");
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pPartUUIDBuffer == nullptr);
		if (isCacheCall) {
			sPartUUID = pIToolpathLayer->GetSegmentPartUUID(nIndex);

			pIToolpathLayer->_setCache (new ParameterCache_1<std::string> (sPartUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathLayer->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sPartUUID);
			pIToolpathLayer->_setCache (nullptr);
		}
		
		if (pPartUUIDNeededChars)
			*pPartUUIDNeededChars = (LibMCEnv_uint32) (sPartUUID.size()+1);
		if (pPartUUIDBuffer) {
			if (sPartUUID.size() >= nPartUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iPartUUID = 0; iPartUUID < sPartUUID.size(); iPartUUID++)
				pPartUUIDBuffer[iPartUUID] = sPartUUID[iPartUUID];
			pPartUUIDBuffer[sPartUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentpointdata(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const LibMCEnv_uint64 nPointDataBufferSize, LibMCEnv_uint64* pPointDataNeededCount, sLibMCEnvPosition2D * pPointDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ((!pPointDataBuffer) && !(pPointDataNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIToolpathLayer->GetSegmentPointData(nIndex, nPointDataBufferSize, pPointDataNeededCount, pPointDataBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmenthatchdata(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const LibMCEnv_uint64 nHatchDataBufferSize, LibMCEnv_uint64* pHatchDataNeededCount, sLibMCEnvHatch2D * pHatchDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ((!pHatchDataBuffer) && !(pHatchDataNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIToolpathLayer->GetSegmentHatchData(nIndex, nHatchDataBufferSize, pHatchDataNeededCount, pHatchDataBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmentpointdatainmm(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const LibMCEnv_uint64 nPointDataBufferSize, LibMCEnv_uint64* pPointDataNeededCount, sLibMCEnvFloatPosition2D * pPointDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ((!pPointDataBuffer) && !(pPointDataNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIToolpathLayer->GetSegmentPointDataInMM(nIndex, nPointDataBufferSize, pPointDataNeededCount, pPointDataBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getsegmenthatchdatainmm(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_uint32 nIndex, const LibMCEnv_uint64 nHatchDataBufferSize, LibMCEnv_uint64* pHatchDataNeededCount, sLibMCEnvFloatHatch2D * pHatchDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if ((!pHatchDataBuffer) && !(pHatchDataNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIToolpathLayer->GetSegmentHatchDataInMM(nIndex, nHatchDataBufferSize, pHatchDataNeededCount, pHatchDataBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getzvalue(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_int32 * pZValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pZValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pZValue = pIToolpathLayer->GetZValue();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getzvalueinmm(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_double * pZValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pZValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pZValue = pIToolpathLayer->GetZValueInMM();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathlayer_getunits(LibMCEnv_ToolpathLayer pToolpathLayer, LibMCEnv_double * pUnits)
{
	IBase* pIBaseClass = (IBase *)pToolpathLayer;

	try {
		if (pUnits == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathLayer* pIToolpathLayer = dynamic_cast<IToolpathLayer*>(pIBaseClass);
		if (!pIToolpathLayer)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pUnits = pIToolpathLayer->GetUnits();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ToolpathAccessor
**************************************************************************************************************************/
LibMCEnvResult libmcenv_toolpathaccessor_getstorageuuid(LibMCEnv_ToolpathAccessor pToolpathAccessor, const LibMCEnv_uint32 nStorageUUIDBufferSize, LibMCEnv_uint32* pStorageUUIDNeededChars, char * pStorageUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if ( (!pStorageUUIDBuffer) && !(pStorageUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStorageUUID("");
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStorageUUIDBuffer == nullptr);
		if (isCacheCall) {
			sStorageUUID = pIToolpathAccessor->GetStorageUUID();

			pIToolpathAccessor->_setCache (new ParameterCache_1<std::string> (sStorageUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathAccessor->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStorageUUID);
			pIToolpathAccessor->_setCache (nullptr);
		}
		
		if (pStorageUUIDNeededChars)
			*pStorageUUIDNeededChars = (LibMCEnv_uint32) (sStorageUUID.size()+1);
		if (pStorageUUIDBuffer) {
			if (sStorageUUID.size() >= nStorageUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStorageUUID = 0; iStorageUUID < sStorageUUID.size(); iStorageUUID++)
				pStorageUUIDBuffer[iStorageUUID] = sStorageUUID[iStorageUUID];
			pStorageUUIDBuffer[sStorageUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getlayercount(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_uint32 * pLayerCount)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pLayerCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pLayerCount = pIToolpathAccessor->GetLayerCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_loadlayer(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_uint32 nLayerIndex, LibMCEnv_ToolpathLayer * pLayerData)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pLayerData == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseLayerData(nullptr);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseLayerData = pIToolpathAccessor->LoadLayer(nLayerIndex);

		*pLayerData = (IBase*)(pBaseLayerData);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getunits(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_double * pUnits)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pUnits == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pUnits = pIToolpathAccessor->GetUnits();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_hasmetadata(LibMCEnv_ToolpathAccessor pToolpathAccessor, const char * pNameSpace, const char * pName, bool * pExists)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pExists == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pExists = pIToolpathAccessor->HasMetaData(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getmetadatavalue(LibMCEnv_ToolpathAccessor pToolpathAccessor, const char * pNameSpace, const char * pName, const LibMCEnv_uint32 nMetaDataValueBufferSize, LibMCEnv_uint32* pMetaDataValueNeededChars, char * pMetaDataValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pMetaDataValueBuffer) && !(pMetaDataValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		std::string sMetaDataValue("");
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMetaDataValueBuffer == nullptr);
		if (isCacheCall) {
			sMetaDataValue = pIToolpathAccessor->GetMetaDataValue(sNameSpace, sName);

			pIToolpathAccessor->_setCache (new ParameterCache_1<std::string> (sMetaDataValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathAccessor->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sMetaDataValue);
			pIToolpathAccessor->_setCache (nullptr);
		}
		
		if (pMetaDataValueNeededChars)
			*pMetaDataValueNeededChars = (LibMCEnv_uint32) (sMetaDataValue.size()+1);
		if (pMetaDataValueBuffer) {
			if (sMetaDataValue.size() >= nMetaDataValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iMetaDataValue = 0; iMetaDataValue < sMetaDataValue.size(); iMetaDataValue++)
				pMetaDataValueBuffer[iMetaDataValue] = sMetaDataValue[iMetaDataValue];
			pMetaDataValueBuffer[sMetaDataValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getmetadatatype(LibMCEnv_ToolpathAccessor pToolpathAccessor, const char * pNameSpace, const char * pName, const LibMCEnv_uint32 nMetaDataTypeBufferSize, LibMCEnv_uint32* pMetaDataTypeNeededChars, char * pMetaDataTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pMetaDataTypeBuffer) && !(pMetaDataTypeNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		std::string sMetaDataType("");
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMetaDataTypeBuffer == nullptr);
		if (isCacheCall) {
			sMetaDataType = pIToolpathAccessor->GetMetaDataType(sNameSpace, sName);

			pIToolpathAccessor->_setCache (new ParameterCache_1<std::string> (sMetaDataType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIToolpathAccessor->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sMetaDataType);
			pIToolpathAccessor->_setCache (nullptr);
		}
		
		if (pMetaDataTypeNeededChars)
			*pMetaDataTypeNeededChars = (LibMCEnv_uint32) (sMetaDataType.size()+1);
		if (pMetaDataTypeBuffer) {
			if (sMetaDataType.size() >= nMetaDataTypeBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iMetaDataType = 0; iMetaDataType < sMetaDataType.size(); iMetaDataType++)
				pMetaDataTypeBuffer[iMetaDataType] = sMetaDataType[iMetaDataType];
			pMetaDataTypeBuffer[sMetaDataType.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getpartcount(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_uint32 * pPartCount)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pPartCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pPartCount = pIToolpathAccessor->GetPartCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getpart(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_uint32 nPartIndex, LibMCEnv_ToolpathPart * pPart)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pPart == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBasePart(nullptr);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBasePart = pIToolpathAccessor->GetPart(nPartIndex);

		*pPart = (IBase*)(pBasePart);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_findpartbyuuid(LibMCEnv_ToolpathAccessor pToolpathAccessor, const char * pPartUUID, LibMCEnv_ToolpathPart * pPart)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pPartUUID == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPart == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sPartUUID(pPartUUID);
		IBase* pBasePart(nullptr);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBasePart = pIToolpathAccessor->FindPartByUUID(sPartUUID);

		*pPart = (IBase*)(pBasePart);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getbuildheightinunits(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_int32 * pBuildHeight)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pBuildHeight == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pBuildHeight = pIToolpathAccessor->GetBuildHeightInUnits();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getzvalueinunits(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_uint32 nLayerIndex, LibMCEnv_int32 * pZValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pZValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pZValue = pIToolpathAccessor->GetZValueInUnits(nLayerIndex);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getbuildheightinmm(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_double * pBuildHeight)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pBuildHeight == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pBuildHeight = pIToolpathAccessor->GetBuildHeightInMM();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_toolpathaccessor_getzvalueinmm(LibMCEnv_ToolpathAccessor pToolpathAccessor, LibMCEnv_uint32 nLayerIndex, LibMCEnv_double * pZValue)
{
	IBase* pIBaseClass = (IBase *)pToolpathAccessor;

	try {
		if (pZValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IToolpathAccessor* pIToolpathAccessor = dynamic_cast<IToolpathAccessor*>(pIBaseClass);
		if (!pIToolpathAccessor)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pZValue = pIToolpathAccessor->GetZValueInMM(nLayerIndex);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Build
**************************************************************************************************************************/
LibMCEnvResult libmcenv_build_getname(LibMCEnv_Build pBuild, const LibMCEnv_uint32 nNameBufferSize, LibMCEnv_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBuild->GetName();

			pIBuild->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBuild->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCEnv_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getbuilduuid(LibMCEnv_Build pBuild, const LibMCEnv_uint32 nBuildUUIDBufferSize, LibMCEnv_uint32* pBuildUUIDNeededChars, char * pBuildUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if ( (!pBuildUUIDBuffer) && !(pBuildUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sBuildUUID("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pBuildUUIDBuffer == nullptr);
		if (isCacheCall) {
			sBuildUUID = pIBuild->GetBuildUUID();

			pIBuild->_setCache (new ParameterCache_1<std::string> (sBuildUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sBuildUUID);
			pIBuild->_setCache (nullptr);
		}
		
		if (pBuildUUIDNeededChars)
			*pBuildUUIDNeededChars = (LibMCEnv_uint32) (sBuildUUID.size()+1);
		if (pBuildUUIDBuffer) {
			if (sBuildUUID.size() >= nBuildUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iBuildUUID = 0; iBuildUUID < sBuildUUID.size(); iBuildUUID++)
				pBuildUUIDBuffer[iBuildUUID] = sBuildUUID[iBuildUUID];
			pBuildUUIDBuffer[sBuildUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getstorageuuid(LibMCEnv_Build pBuild, const LibMCEnv_uint32 nStorageUUIDBufferSize, LibMCEnv_uint32* pStorageUUIDNeededChars, char * pStorageUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if ( (!pStorageUUIDBuffer) && !(pStorageUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStorageUUID("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStorageUUIDBuffer == nullptr);
		if (isCacheCall) {
			sStorageUUID = pIBuild->GetStorageUUID();

			pIBuild->_setCache (new ParameterCache_1<std::string> (sStorageUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStorageUUID);
			pIBuild->_setCache (nullptr);
		}
		
		if (pStorageUUIDNeededChars)
			*pStorageUUIDNeededChars = (LibMCEnv_uint32) (sStorageUUID.size()+1);
		if (pStorageUUIDBuffer) {
			if (sStorageUUID.size() >= nStorageUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStorageUUID = 0; iStorageUUID < sStorageUUID.size(); iStorageUUID++)
				pStorageUUIDBuffer[iStorageUUID] = sStorageUUID[iStorageUUID];
			pStorageUUIDBuffer[sStorageUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getstoragesha256(LibMCEnv_Build pBuild, const LibMCEnv_uint32 nSHA256BufferSize, LibMCEnv_uint32* pSHA256NeededChars, char * pSHA256Buffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if ( (!pSHA256Buffer) && !(pSHA256NeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSHA256("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSHA256Buffer == nullptr);
		if (isCacheCall) {
			sSHA256 = pIBuild->GetStorageSHA256();

			pIBuild->_setCache (new ParameterCache_1<std::string> (sSHA256));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSHA256);
			pIBuild->_setCache (nullptr);
		}
		
		if (pSHA256NeededChars)
			*pSHA256NeededChars = (LibMCEnv_uint32) (sSHA256.size()+1);
		if (pSHA256Buffer) {
			if (sSHA256.size() >= nSHA256BufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA256 = 0; iSHA256 < sSHA256.size(); iSHA256++)
				pSHA256Buffer[iSHA256] = sSHA256[iSHA256];
			pSHA256Buffer[sSHA256.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getlayercount(LibMCEnv_Build pBuild, LibMCEnv_uint32 * pLayerCount)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pLayerCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pLayerCount = pIBuild->GetLayerCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getbuildheightinmm(LibMCEnv_Build pBuild, LibMCEnv_double * pBuildHeight)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pBuildHeight == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pBuildHeight = pIBuild->GetBuildHeightInMM();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_getzvalueinmm(LibMCEnv_Build pBuild, LibMCEnv_uint32 nLayerIndex, LibMCEnv_double * pZValue)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pZValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pZValue = pIBuild->GetZValueInMM(nLayerIndex);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_loadtoolpath(LibMCEnv_Build pBuild)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIBuild->LoadToolpath();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_unloadtoolpath(LibMCEnv_Build pBuild)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIBuild->UnloadToolpath();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_toolpathisloaded(LibMCEnv_Build pBuild, bool * pIsLoaded)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pIsLoaded == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pIsLoaded = pIBuild->ToolpathIsLoaded();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_createtoolpathaccessor(LibMCEnv_Build pBuild, LibMCEnv_ToolpathAccessor * pToolpathInstance)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pToolpathInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseToolpathInstance(nullptr);
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseToolpathInstance = pIBuild->CreateToolpathAccessor();

		*pToolpathInstance = (IBase*)(pBaseToolpathInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_build_addbinarydata(LibMCEnv_Build pBuild, const char * pName, const char * pMIMEType, LibMCEnv_uint64 nContentBufferSize, const LibMCEnv_uint8 * pContentBuffer, const LibMCEnv_uint32 nDataUUIDBufferSize, LibMCEnv_uint32* pDataUUIDNeededChars, char * pDataUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuild;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pMIMEType == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pContentBuffer) && (nContentBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pDataUUIDBuffer) && !(pDataUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sMIMEType(pMIMEType);
		std::string sDataUUID("");
		IBuild* pIBuild = dynamic_cast<IBuild*>(pIBaseClass);
		if (!pIBuild)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDataUUIDBuffer == nullptr);
		if (isCacheCall) {
			sDataUUID = pIBuild->AddBinaryData(sName, sMIMEType, nContentBufferSize, pContentBuffer);

			pIBuild->_setCache (new ParameterCache_1<std::string> (sDataUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuild->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sDataUUID);
			pIBuild->_setCache (nullptr);
		}
		
		if (pDataUUIDNeededChars)
			*pDataUUIDNeededChars = (LibMCEnv_uint32) (sDataUUID.size()+1);
		if (pDataUUIDBuffer) {
			if (sDataUUID.size() >= nDataUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iDataUUID = 0; iDataUUID < sDataUUID.size(); iDataUUID++)
				pDataUUIDBuffer[iDataUUID] = sDataUUID[iDataUUID];
			pDataUUIDBuffer[sDataUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for WorkingFileExecution
**************************************************************************************************************************/
LibMCEnvResult libmcenv_workingfileexecution_getstatus(LibMCEnv_WorkingFileExecution pWorkingFileExecution)
{
	IBase* pIBaseClass = (IBase *)pWorkingFileExecution;

	try {
		IWorkingFileExecution* pIWorkingFileExecution = dynamic_cast<IWorkingFileExecution*>(pIBaseClass);
		if (!pIWorkingFileExecution)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIWorkingFileExecution->GetStatus();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfileexecution_returnstdout(LibMCEnv_WorkingFileExecution pWorkingFileExecution, const LibMCEnv_uint32 nStringBufferBufferSize, LibMCEnv_uint32* pStringBufferNeededChars, char * pStringBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pWorkingFileExecution;

	try {
		if ( (!pStringBufferBuffer) && !(pStringBufferNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStringBuffer("");
		IWorkingFileExecution* pIWorkingFileExecution = dynamic_cast<IWorkingFileExecution*>(pIBaseClass);
		if (!pIWorkingFileExecution)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStringBufferBuffer == nullptr);
		if (isCacheCall) {
			sStringBuffer = pIWorkingFileExecution->ReturnStdOut();

			pIWorkingFileExecution->_setCache (new ParameterCache_1<std::string> (sStringBuffer));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIWorkingFileExecution->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStringBuffer);
			pIWorkingFileExecution->_setCache (nullptr);
		}
		
		if (pStringBufferNeededChars)
			*pStringBufferNeededChars = (LibMCEnv_uint32) (sStringBuffer.size()+1);
		if (pStringBufferBuffer) {
			if (sStringBuffer.size() >= nStringBufferBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStringBuffer = 0; iStringBuffer < sStringBuffer.size(); iStringBuffer++)
				pStringBufferBuffer[iStringBuffer] = sStringBuffer[iStringBuffer];
			pStringBufferBuffer[sStringBuffer.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for WorkingFile
**************************************************************************************************************************/
LibMCEnvResult libmcenv_workingfile_getabsolutefilename(LibMCEnv_WorkingFile pWorkingFile, const LibMCEnv_uint32 nFileNameBufferSize, LibMCEnv_uint32* pFileNameNeededChars, char * pFileNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if ( (!pFileNameBuffer) && !(pFileNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFileName("");
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pFileNameBuffer == nullptr);
		if (isCacheCall) {
			sFileName = pIWorkingFile->GetAbsoluteFileName();

			pIWorkingFile->_setCache (new ParameterCache_1<std::string> (sFileName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIWorkingFile->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sFileName);
			pIWorkingFile->_setCache (nullptr);
		}
		
		if (pFileNameNeededChars)
			*pFileNameNeededChars = (LibMCEnv_uint32) (sFileName.size()+1);
		if (pFileNameBuffer) {
			if (sFileName.size() >= nFileNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iFileName = 0; iFileName < sFileName.size(); iFileName++)
				pFileNameBuffer[iFileName] = sFileName[iFileName];
			pFileNameBuffer[sFileName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_getsize(LibMCEnv_WorkingFile pWorkingFile, LibMCEnv_uint64 * pFileSize)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if (pFileSize == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pFileSize = pIWorkingFile->GetSize();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_calculatesha2(LibMCEnv_WorkingFile pWorkingFile, const LibMCEnv_uint32 nSHA2BufferSize, LibMCEnv_uint32* pSHA2NeededChars, char * pSHA2Buffer)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if ( (!pSHA2Buffer) && !(pSHA2NeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSHA2("");
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSHA2Buffer == nullptr);
		if (isCacheCall) {
			sSHA2 = pIWorkingFile->CalculateSHA2();

			pIWorkingFile->_setCache (new ParameterCache_1<std::string> (sSHA2));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIWorkingFile->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSHA2);
			pIWorkingFile->_setCache (nullptr);
		}
		
		if (pSHA2NeededChars)
			*pSHA2NeededChars = (LibMCEnv_uint32) (sSHA2.size()+1);
		if (pSHA2Buffer) {
			if (sSHA2.size() >= nSHA2BufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA2 = 0; iSHA2 < sSHA2.size(); iSHA2++)
				pSHA2Buffer[iSHA2] = sSHA2[iSHA2];
			pSHA2Buffer[sSHA2.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_executefile(LibMCEnv_WorkingFile pWorkingFile, LibMCEnv_WorkingFileExecution * pExecution)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if (pExecution == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseExecution(nullptr);
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseExecution = pIWorkingFile->ExecuteFile();

		*pExecution = (IBase*)(pBaseExecution);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_ismanaged(LibMCEnv_WorkingFile pWorkingFile, bool * pFileIsManaged)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if (pFileIsManaged == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pFileIsManaged = pIWorkingFile->IsManaged();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_makemanaged(LibMCEnv_WorkingFile pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIWorkingFile->MakeManaged();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_fileexists(LibMCEnv_WorkingFile pWorkingFile, bool * pFileDoesExist)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if (pFileDoesExist == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pFileDoesExist = pIWorkingFile->FileExists();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingfile_deletefromdisk(LibMCEnv_WorkingFile pWorkingFile, bool * pSuccess)
{
	IBase* pIBaseClass = (IBase *)pWorkingFile;

	try {
		if (pSuccess == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IWorkingFile* pIWorkingFile = dynamic_cast<IWorkingFile*>(pIBaseClass);
		if (!pIWorkingFile)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pSuccess = pIWorkingFile->DeleteFromDisk();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for WorkingFileIterator
**************************************************************************************************************************/
LibMCEnvResult libmcenv_workingfileiterator_getcurrentfile(LibMCEnv_WorkingFileIterator pWorkingFileIterator, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingFileIterator;

	try {
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingFileIterator* pIWorkingFileIterator = dynamic_cast<IWorkingFileIterator*>(pIBaseClass);
		if (!pIWorkingFileIterator)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingFileIterator->GetCurrentFile();

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for WorkingDirectory
**************************************************************************************************************************/
LibMCEnvResult libmcenv_workingdirectory_isactive(LibMCEnv_WorkingDirectory pWorkingDirectory, bool * pIsActive)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pIsActive == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pIsActive = pIWorkingDirectory->IsActive();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_getabsolutefilepath(LibMCEnv_WorkingDirectory pWorkingDirectory, const LibMCEnv_uint32 nFilePathBufferSize, LibMCEnv_uint32* pFilePathNeededChars, char * pFilePathBuffer)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if ( (!pFilePathBuffer) && !(pFilePathNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFilePath("");
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pFilePathBuffer == nullptr);
		if (isCacheCall) {
			sFilePath = pIWorkingDirectory->GetAbsoluteFilePath();

			pIWorkingDirectory->_setCache (new ParameterCache_1<std::string> (sFilePath));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIWorkingDirectory->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sFilePath);
			pIWorkingDirectory->_setCache (nullptr);
		}
		
		if (pFilePathNeededChars)
			*pFilePathNeededChars = (LibMCEnv_uint32) (sFilePath.size()+1);
		if (pFilePathBuffer) {
			if (sFilePath.size() >= nFilePathBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iFilePath = 0; iFilePath < sFilePath.size(); iFilePath++)
				pFilePathBuffer[iFilePath] = sFilePath[iFilePath];
			pFilePathBuffer[sFilePath.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_storecustomdata(LibMCEnv_WorkingDirectory pWorkingDirectory, const char * pFileName, LibMCEnv_uint64 nDataBufferBufferSize, const LibMCEnv_uint8 * pDataBufferBuffer, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pFileName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pDataBufferBuffer) && (nDataBufferBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingDirectory->StoreCustomData(sFileName, nDataBufferBufferSize, pDataBufferBuffer);

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_storecustomstring(LibMCEnv_WorkingDirectory pWorkingDirectory, const char * pFileName, const char * pDataString, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pFileName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDataString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		std::string sDataString(pDataString);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingDirectory->StoreCustomString(sFileName, sDataString);

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_storedriverdata(LibMCEnv_WorkingDirectory pWorkingDirectory, const char * pFileName, const char * pIdentifier, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pFileName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pIdentifier == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingDirectory->StoreDriverData(sFileName, sIdentifier);

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_storecustomdataintempfile(LibMCEnv_WorkingDirectory pWorkingDirectory, const char * pExtension, LibMCEnv_uint64 nDataBufferBufferSize, const LibMCEnv_uint8 * pDataBufferBuffer, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pExtension == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pDataBufferBuffer) && (nDataBufferBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sExtension(pExtension);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingDirectory->StoreCustomDataInTempFile(sExtension, nDataBufferBufferSize, pDataBufferBuffer);

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_storecustomstringintempfile(LibMCEnv_WorkingDirectory pWorkingDirectory, const char * pExtension, const char * pDataString, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pExtension == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDataString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sExtension(pExtension);
		std::string sDataString(pDataString);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingDirectory->StoreCustomStringInTempFile(sExtension, sDataString);

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_storedriverdataintempfile(LibMCEnv_WorkingDirectory pWorkingDirectory, const char * pExtension, const char * pIdentifier, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pExtension == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pIdentifier == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sExtension(pExtension);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingDirectory->StoreDriverDataInTempFile(sExtension, sIdentifier);

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_cleanup(LibMCEnv_WorkingDirectory pWorkingDirectory, bool * pSuccess)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pSuccess == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pSuccess = pIWorkingDirectory->CleanUp();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_addmanagedfile(LibMCEnv_WorkingDirectory pWorkingDirectory, const char * pFileName, LibMCEnv_WorkingFile * pWorkingFile)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pFileName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pWorkingFile == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		IBase* pBaseWorkingFile(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingFile = pIWorkingDirectory->AddManagedFile(sFileName);

		*pWorkingFile = (IBase*)(pBaseWorkingFile);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_hasunmanagedfiles(LibMCEnv_WorkingDirectory pWorkingDirectory, bool * pHasUnmanagedFiles)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pHasUnmanagedFiles == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pHasUnmanagedFiles = pIWorkingDirectory->HasUnmanagedFiles();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_retrieveunmanagedfiles(LibMCEnv_WorkingDirectory pWorkingDirectory, LibMCEnv_WorkingFileIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIWorkingDirectory->RetrieveUnmanagedFiles();

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_retrievemanagedfiles(LibMCEnv_WorkingDirectory pWorkingDirectory, LibMCEnv_WorkingFileIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIWorkingDirectory->RetrieveManagedFiles();

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_workingdirectory_retrieveallfiles(LibMCEnv_WorkingDirectory pWorkingDirectory, LibMCEnv_WorkingFileIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pWorkingDirectory;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IWorkingDirectory* pIWorkingDirectory = dynamic_cast<IWorkingDirectory*>(pIBaseClass);
		if (!pIWorkingDirectory)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIWorkingDirectory->RetrieveAllFiles();

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for XMLDocumentAttribute
**************************************************************************************************************************/
LibMCEnvResult libmcenv_xmldocumentattribute_getnamespace(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, const LibMCEnv_uint32 nNameSpaceBufferSize, LibMCEnv_uint32* pNameSpaceNeededChars, char * pNameSpaceBuffer)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if ( (!pNameSpaceBuffer) && !(pNameSpaceNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace("");
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameSpaceBuffer == nullptr);
		if (isCacheCall) {
			sNameSpace = pIXMLDocumentAttribute->GetNameSpace();

			pIXMLDocumentAttribute->_setCache (new ParameterCache_1<std::string> (sNameSpace));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIXMLDocumentAttribute->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sNameSpace);
			pIXMLDocumentAttribute->_setCache (nullptr);
		}
		
		if (pNameSpaceNeededChars)
			*pNameSpaceNeededChars = (LibMCEnv_uint32) (sNameSpace.size()+1);
		if (pNameSpaceBuffer) {
			if (sNameSpace.size() >= nNameSpaceBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iNameSpace = 0; iNameSpace < sNameSpace.size(); iNameSpace++)
				pNameSpaceBuffer[iNameSpace] = sNameSpace[iNameSpace];
			pNameSpaceBuffer[sNameSpace.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_getname(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, const LibMCEnv_uint32 nNameBufferSize, LibMCEnv_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName("");
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIXMLDocumentAttribute->GetName();

			pIXMLDocumentAttribute->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIXMLDocumentAttribute->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIXMLDocumentAttribute->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCEnv_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_getvalue(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sValue("");
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIXMLDocumentAttribute->GetValue();

			pIXMLDocumentAttribute->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIXMLDocumentAttribute->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIXMLDocumentAttribute->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_isvalidinteger(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, LibMCEnv_int64 nMinValue, LibMCEnv_int64 nMaxValue, bool * pIsValid)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if (pIsValid == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pIsValid = pIXMLDocumentAttribute->IsValidInteger(nMinValue, nMaxValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_getintegervalue(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, LibMCEnv_int64 nMinValue, LibMCEnv_int64 nMaxValue, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIXMLDocumentAttribute->GetIntegerValue(nMinValue, nMaxValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_isvaliddouble(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, LibMCEnv_double dMinValue, LibMCEnv_double dMaxValue, bool * pIsValid)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if (pIsValid == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pIsValid = pIXMLDocumentAttribute->IsValidDouble(dMinValue, dMaxValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_getdoublevalue(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, LibMCEnv_double dMinValue, LibMCEnv_double dMaxValue, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIXMLDocumentAttribute->GetDoubleValue(dMinValue, dMaxValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_isvalidbool(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, bool * pIsValid)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if (pIsValid == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pIsValid = pIXMLDocumentAttribute->IsValidBool();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_getboolvalue(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, LibMCEnv_double dMinValue, LibMCEnv_double dMaxValue, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIXMLDocumentAttribute->GetBoolValue(dMinValue, dMaxValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_setvalue(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sValue(pValue);
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentAttribute->SetValue(sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_setintegervalue(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentAttribute->SetIntegerValue(nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_setdoublevalue(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentAttribute->SetDoubleValue(dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_setboolvalue(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentAttribute->SetBoolValue(bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentattribute_remove(LibMCEnv_XMLDocumentAttribute pXMLDocumentAttribute)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentAttribute;

	try {
		IXMLDocumentAttribute* pIXMLDocumentAttribute = dynamic_cast<IXMLDocumentAttribute*>(pIBaseClass);
		if (!pIXMLDocumentAttribute)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentAttribute->Remove();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for XMLDocumentNode
**************************************************************************************************************************/
LibMCEnvResult libmcenv_xmldocumentnode_getname(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const LibMCEnv_uint32 nNameBufferSize, LibMCEnv_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName("");
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIXMLDocumentNode->GetName();

			pIXMLDocumentNode->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIXMLDocumentNode->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIXMLDocumentNode->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCEnv_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_getnamespace(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const LibMCEnv_uint32 nNameSpaceBufferSize, LibMCEnv_uint32* pNameSpaceNeededChars, char * pNameSpaceBuffer)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if ( (!pNameSpaceBuffer) && !(pNameSpaceNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace("");
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameSpaceBuffer == nullptr);
		if (isCacheCall) {
			sNameSpace = pIXMLDocumentNode->GetNameSpace();

			pIXMLDocumentNode->_setCache (new ParameterCache_1<std::string> (sNameSpace));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIXMLDocumentNode->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sNameSpace);
			pIXMLDocumentNode->_setCache (nullptr);
		}
		
		if (pNameSpaceNeededChars)
			*pNameSpaceNeededChars = (LibMCEnv_uint32) (sNameSpace.size()+1);
		if (pNameSpaceBuffer) {
			if (sNameSpace.size() >= nNameSpaceBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iNameSpace = 0; iNameSpace < sNameSpace.size(); iNameSpace++)
				pNameSpaceBuffer[iNameSpace] = sNameSpace[iNameSpace];
			pNameSpaceBuffer[sNameSpace.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_getattributecount(LibMCEnv_XMLDocumentNode pXMLDocumentNode, LibMCEnv_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIXMLDocumentNode->GetAttributeCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_getattribute(LibMCEnv_XMLDocumentNode pXMLDocumentNode, LibMCEnv_uint64 nIndex, LibMCEnv_XMLDocumentAttribute * pAttributeInstance)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pAttributeInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseAttributeInstance(nullptr);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseAttributeInstance = pIXMLDocumentNode->GetAttribute(nIndex);

		*pAttributeInstance = (IBase*)(pBaseAttributeInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_hasattribute(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, bool * pAttributeExists)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pAttributeExists == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pAttributeExists = pIXMLDocumentNode->HasAttribute(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_findattribute(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, bool bMustExist, LibMCEnv_XMLDocumentAttribute * pAttributeInstance)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pAttributeInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IBase* pBaseAttributeInstance(nullptr);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseAttributeInstance = pIXMLDocumentNode->FindAttribute(sNameSpace, sName, bMustExist);

		*pAttributeInstance = (IBase*)(pBaseAttributeInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_removeattribute(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentNode->RemoveAttribute(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_removeattributebyindex(LibMCEnv_XMLDocumentNode pXMLDocumentNode, LibMCEnv_uint64 nIndex)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentNode->RemoveAttributeByIndex(nIndex);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_addattribute(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		std::string sValue(pValue);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentNode->AddAttribute(sNameSpace, sName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_addintegerattribute(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentNode->AddIntegerAttribute(sNameSpace, sName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_adddoubleattribute(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentNode->AddDoubleAttribute(sNameSpace, sName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_addboolattribute(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentNode->AddBoolAttribute(sNameSpace, sName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_getchildren(LibMCEnv_XMLDocumentNode pXMLDocumentNode, LibMCEnv_XMLDocumentNodes * pChildNodes)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pChildNodes == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseChildNodes(nullptr);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseChildNodes = pIXMLDocumentNode->GetChildren();

		*pChildNodes = (IBase*)(pBaseChildNodes);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_countchildrenbyname(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, LibMCEnv_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIXMLDocumentNode->CountChildrenByName(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_getchildrenbyname(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, LibMCEnv_XMLDocumentNodes * pChildNodes)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pChildNodes == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IBase* pBaseChildNodes(nullptr);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseChildNodes = pIXMLDocumentNode->GetChildrenByName(sNameSpace, sName);

		*pChildNodes = (IBase*)(pBaseChildNodes);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_haschild(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, bool * pChildExists)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pChildExists == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pChildExists = pIXMLDocumentNode->HasChild(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_hasuniquechild(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, bool * pChildExists)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pChildExists == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pChildExists = pIXMLDocumentNode->HasUniqueChild(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_findchild(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, bool bMustExist, LibMCEnv_XMLDocumentNode * pChildInstance)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pChildInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IBase* pBaseChildInstance(nullptr);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseChildInstance = pIXMLDocumentNode->FindChild(sNameSpace, sName, bMustExist);

		*pChildInstance = (IBase*)(pBaseChildInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_addchild(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName, LibMCEnv_XMLDocumentNode * pChildInstance)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pChildInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IBase* pBaseChildInstance(nullptr);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseChildInstance = pIXMLDocumentNode->AddChild(sNameSpace, sName);

		*pChildInstance = (IBase*)(pBaseChildInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_removechild(LibMCEnv_XMLDocumentNode pXMLDocumentNode, LibMCEnv_XMLDocumentNode pChildInstance)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		IBase* pIBaseClassChildInstance = (IBase *)pChildInstance;
		IXMLDocumentNode* pIChildInstance = dynamic_cast<IXMLDocumentNode*>(pIBaseClassChildInstance);
		if (!pIChildInstance)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDCAST);
		
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentNode->RemoveChild(pIChildInstance);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_removechildrenwithname(LibMCEnv_XMLDocumentNode pXMLDocumentNode, const char * pNameSpace, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentNode->RemoveChildrenWithName(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnode_remove(LibMCEnv_XMLDocumentNode pXMLDocumentNode)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNode;

	try {
		IXMLDocumentNode* pIXMLDocumentNode = dynamic_cast<IXMLDocumentNode*>(pIBaseClass);
		if (!pIXMLDocumentNode)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocumentNode->Remove();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for XMLDocumentNodes
**************************************************************************************************************************/
LibMCEnvResult libmcenv_xmldocumentnodes_getnodecount(LibMCEnv_XMLDocumentNodes pXMLDocumentNodes, LibMCEnv_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNodes;

	try {
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IXMLDocumentNodes* pIXMLDocumentNodes = dynamic_cast<IXMLDocumentNodes*>(pIBaseClass);
		if (!pIXMLDocumentNodes)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIXMLDocumentNodes->GetNodeCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnodes_getnode(LibMCEnv_XMLDocumentNodes pXMLDocumentNodes, LibMCEnv_uint64 nIndex, LibMCEnv_XMLDocumentNode * pNodeInstance)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNodes;

	try {
		if (pNodeInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseNodeInstance(nullptr);
		IXMLDocumentNodes* pIXMLDocumentNodes = dynamic_cast<IXMLDocumentNodes*>(pIBaseClass);
		if (!pIXMLDocumentNodes)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseNodeInstance = pIXMLDocumentNodes->GetNode(nIndex);

		*pNodeInstance = (IBase*)(pBaseNodeInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnodes_countnodesbyname(LibMCEnv_XMLDocumentNodes pXMLDocumentNodes, const char * pNameSpace, const char * pName, LibMCEnv_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNodes;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNodes* pIXMLDocumentNodes = dynamic_cast<IXMLDocumentNodes*>(pIBaseClass);
		if (!pIXMLDocumentNodes)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIXMLDocumentNodes->CountNodesByName(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnodes_getnodesbyname(LibMCEnv_XMLDocumentNodes pXMLDocumentNodes, const char * pNameSpace, const char * pName, LibMCEnv_XMLDocumentNodes * pNodes)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNodes;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pNodes == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IBase* pBaseNodes(nullptr);
		IXMLDocumentNodes* pIXMLDocumentNodes = dynamic_cast<IXMLDocumentNodes*>(pIBaseClass);
		if (!pIXMLDocumentNodes)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseNodes = pIXMLDocumentNodes->GetNodesByName(sNameSpace, sName);

		*pNodes = (IBase*)(pBaseNodes);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnodes_hasnode(LibMCEnv_XMLDocumentNodes pXMLDocumentNodes, const char * pNameSpace, const char * pName, bool * pNodeExists)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNodes;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pNodeExists == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNodes* pIXMLDocumentNodes = dynamic_cast<IXMLDocumentNodes*>(pIBaseClass);
		if (!pIXMLDocumentNodes)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pNodeExists = pIXMLDocumentNodes->HasNode(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnodes_hasuniquenode(LibMCEnv_XMLDocumentNodes pXMLDocumentNodes, const char * pNameSpace, const char * pName, bool * pNodeExists)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNodes;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pNodeExists == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IXMLDocumentNodes* pIXMLDocumentNodes = dynamic_cast<IXMLDocumentNodes*>(pIBaseClass);
		if (!pIXMLDocumentNodes)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pNodeExists = pIXMLDocumentNodes->HasUniqueNode(sNameSpace, sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocumentnodes_findnode(LibMCEnv_XMLDocumentNodes pXMLDocumentNodes, const char * pNameSpace, const char * pName, bool bMustExist, LibMCEnv_XMLDocumentNode * pNodeInstance)
{
	IBase* pIBaseClass = (IBase *)pXMLDocumentNodes;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pNodeInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		std::string sName(pName);
		IBase* pBaseNodeInstance(nullptr);
		IXMLDocumentNodes* pIXMLDocumentNodes = dynamic_cast<IXMLDocumentNodes*>(pIBaseClass);
		if (!pIXMLDocumentNodes)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseNodeInstance = pIXMLDocumentNodes->FindNode(sNameSpace, sName, bMustExist);

		*pNodeInstance = (IBase*)(pBaseNodeInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for XMLDocument
**************************************************************************************************************************/
LibMCEnvResult libmcenv_xmldocument_getdefaultnamespace(LibMCEnv_XMLDocument pXMLDocument, const LibMCEnv_uint32 nNamespaceBufferSize, LibMCEnv_uint32* pNamespaceNeededChars, char * pNamespaceBuffer)
{
	IBase* pIBaseClass = (IBase *)pXMLDocument;

	try {
		if ( (!pNamespaceBuffer) && !(pNamespaceNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace("");
		IXMLDocument* pIXMLDocument = dynamic_cast<IXMLDocument*>(pIBaseClass);
		if (!pIXMLDocument)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNamespaceBuffer == nullptr);
		if (isCacheCall) {
			sNamespace = pIXMLDocument->GetDefaultNamespace();

			pIXMLDocument->_setCache (new ParameterCache_1<std::string> (sNamespace));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIXMLDocument->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sNamespace);
			pIXMLDocument->_setCache (nullptr);
		}
		
		if (pNamespaceNeededChars)
			*pNamespaceNeededChars = (LibMCEnv_uint32) (sNamespace.size()+1);
		if (pNamespaceBuffer) {
			if (sNamespace.size() >= nNamespaceBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iNamespace = 0; iNamespace < sNamespace.size(); iNamespace++)
				pNamespaceBuffer[iNamespace] = sNamespace[iNamespace];
			pNamespaceBuffer[sNamespace.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocument_getnamespacecount(LibMCEnv_XMLDocument pXMLDocument, LibMCEnv_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pXMLDocument;

	try {
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IXMLDocument* pIXMLDocument = dynamic_cast<IXMLDocument*>(pIBaseClass);
		if (!pIXMLDocument)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIXMLDocument->GetNamespaceCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocument_getnamespace(LibMCEnv_XMLDocument pXMLDocument, LibMCEnv_uint64 nIndex, const LibMCEnv_uint32 nNamespaceBufferSize, LibMCEnv_uint32* pNamespaceNeededChars, char * pNamespaceBuffer, const LibMCEnv_uint32 nNamespacePrefixBufferSize, LibMCEnv_uint32* pNamespacePrefixNeededChars, char * pNamespacePrefixBuffer)
{
	IBase* pIBaseClass = (IBase *)pXMLDocument;

	try {
		if ( (!pNamespaceBuffer) && !(pNamespaceNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pNamespacePrefixBuffer) && !(pNamespacePrefixNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace("");
		std::string sNamespacePrefix("");
		IXMLDocument* pIXMLDocument = dynamic_cast<IXMLDocument*>(pIBaseClass);
		if (!pIXMLDocument)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNamespaceBuffer == nullptr) || (pNamespacePrefixBuffer == nullptr);
		if (isCacheCall) {
			pIXMLDocument->GetNamespace(nIndex, sNamespace, sNamespacePrefix);

			pIXMLDocument->_setCache (new ParameterCache_2<std::string, std::string> (sNamespace, sNamespacePrefix));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pIXMLDocument->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sNamespace, sNamespacePrefix);
			pIXMLDocument->_setCache (nullptr);
		}
		
		if (pNamespaceNeededChars)
			*pNamespaceNeededChars = (LibMCEnv_uint32) (sNamespace.size()+1);
		if (pNamespaceBuffer) {
			if (sNamespace.size() >= nNamespaceBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iNamespace = 0; iNamespace < sNamespace.size(); iNamespace++)
				pNamespaceBuffer[iNamespace] = sNamespace[iNamespace];
			pNamespaceBuffer[sNamespace.size()] = 0;
		}
		if (pNamespacePrefixNeededChars)
			*pNamespacePrefixNeededChars = (LibMCEnv_uint32) (sNamespacePrefix.size()+1);
		if (pNamespacePrefixBuffer) {
			if (sNamespacePrefix.size() >= nNamespacePrefixBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iNamespacePrefix = 0; iNamespacePrefix < sNamespacePrefix.size(); iNamespacePrefix++)
				pNamespacePrefixBuffer[iNamespacePrefix] = sNamespacePrefix[iNamespacePrefix];
			pNamespacePrefixBuffer[sNamespacePrefix.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocument_hasnamespace(LibMCEnv_XMLDocument pXMLDocument, const char * pNamespace, bool * pNameSpaceIsRegistered)
{
	IBase* pIBaseClass = (IBase *)pXMLDocument;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pNameSpaceIsRegistered == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		IXMLDocument* pIXMLDocument = dynamic_cast<IXMLDocument*>(pIBaseClass);
		if (!pIXMLDocument)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pNameSpaceIsRegistered = pIXMLDocument->HasNamespace(sNamespace);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocument_getnamespaceprefix(LibMCEnv_XMLDocument pXMLDocument, const char * pNamespace, const LibMCEnv_uint32 nNamespacePrefixBufferSize, LibMCEnv_uint32* pNamespacePrefixNeededChars, char * pNamespacePrefixBuffer)
{
	IBase* pIBaseClass = (IBase *)pXMLDocument;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pNamespacePrefixBuffer) && !(pNamespacePrefixNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sNamespacePrefix("");
		IXMLDocument* pIXMLDocument = dynamic_cast<IXMLDocument*>(pIBaseClass);
		if (!pIXMLDocument)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNamespacePrefixBuffer == nullptr);
		if (isCacheCall) {
			sNamespacePrefix = pIXMLDocument->GetNamespacePrefix(sNamespace);

			pIXMLDocument->_setCache (new ParameterCache_1<std::string> (sNamespacePrefix));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIXMLDocument->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sNamespacePrefix);
			pIXMLDocument->_setCache (nullptr);
		}
		
		if (pNamespacePrefixNeededChars)
			*pNamespacePrefixNeededChars = (LibMCEnv_uint32) (sNamespacePrefix.size()+1);
		if (pNamespacePrefixBuffer) {
			if (sNamespacePrefix.size() >= nNamespacePrefixBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iNamespacePrefix = 0; iNamespacePrefix < sNamespacePrefix.size(); iNamespacePrefix++)
				pNamespacePrefixBuffer[iNamespacePrefix] = sNamespacePrefix[iNamespacePrefix];
			pNamespacePrefixBuffer[sNamespacePrefix.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocument_registernamespace(LibMCEnv_XMLDocument pXMLDocument, const char * pNamespace, const char * pNamespacePrefix)
{
	IBase* pIBaseClass = (IBase *)pXMLDocument;

	try {
		if (pNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pNamespacePrefix == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sNamespace(pNamespace);
		std::string sNamespacePrefix(pNamespacePrefix);
		IXMLDocument* pIXMLDocument = dynamic_cast<IXMLDocument*>(pIBaseClass);
		if (!pIXMLDocument)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIXMLDocument->RegisterNamespace(sNamespace, sNamespacePrefix);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocument_getrootnode(LibMCEnv_XMLDocument pXMLDocument, LibMCEnv_XMLDocumentNode * pRootNode)
{
	IBase* pIBaseClass = (IBase *)pXMLDocument;

	try {
		if (pRootNode == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseRootNode(nullptr);
		IXMLDocument* pIXMLDocument = dynamic_cast<IXMLDocument*>(pIBaseClass);
		if (!pIXMLDocument)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseRootNode = pIXMLDocument->GetRootNode();

		*pRootNode = (IBase*)(pBaseRootNode);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_xmldocument_savetostring(LibMCEnv_XMLDocument pXMLDocument, bool bAddLineBreaks, const LibMCEnv_uint32 nXMLStringBufferSize, LibMCEnv_uint32* pXMLStringNeededChars, char * pXMLStringBuffer)
{
	IBase* pIBaseClass = (IBase *)pXMLDocument;

	try {
		if ( (!pXMLStringBuffer) && !(pXMLStringNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sXMLString("");
		IXMLDocument* pIXMLDocument = dynamic_cast<IXMLDocument*>(pIBaseClass);
		if (!pIXMLDocument)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pXMLStringBuffer == nullptr);
		if (isCacheCall) {
			sXMLString = pIXMLDocument->SaveToString(bAddLineBreaks);

			pIXMLDocument->_setCache (new ParameterCache_1<std::string> (sXMLString));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIXMLDocument->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sXMLString);
			pIXMLDocument->_setCache (nullptr);
		}
		
		if (pXMLStringNeededChars)
			*pXMLStringNeededChars = (LibMCEnv_uint32) (sXMLString.size()+1);
		if (pXMLStringBuffer) {
			if (sXMLString.size() >= nXMLStringBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iXMLString = 0; iXMLString < sXMLString.size(); iXMLString++)
				pXMLStringBuffer[iXMLString] = sXMLString[iXMLString];
			pXMLStringBuffer[sXMLString.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for TCPIPPacket
**************************************************************************************************************************/
LibMCEnvResult libmcenv_tcpippacket_isempty(LibMCEnv_TCPIPPacket pTCPIPPacket, bool * pPacketIsEmpty)
{
	IBase* pIBaseClass = (IBase *)pTCPIPPacket;

	try {
		if (pPacketIsEmpty == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ITCPIPPacket* pITCPIPPacket = dynamic_cast<ITCPIPPacket*>(pIBaseClass);
		if (!pITCPIPPacket)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pPacketIsEmpty = pITCPIPPacket->IsEmpty();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpippacket_getsize(LibMCEnv_TCPIPPacket pTCPIPPacket, LibMCEnv_uint32 * pPacketSize)
{
	IBase* pIBaseClass = (IBase *)pTCPIPPacket;

	try {
		if (pPacketSize == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ITCPIPPacket* pITCPIPPacket = dynamic_cast<ITCPIPPacket*>(pIBaseClass);
		if (!pITCPIPPacket)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pPacketSize = pITCPIPPacket->GetSize();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpippacket_getdata(LibMCEnv_TCPIPPacket pTCPIPPacket, const LibMCEnv_uint64 nBufferBufferSize, LibMCEnv_uint64* pBufferNeededCount, LibMCEnv_uint8 * pBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pTCPIPPacket;

	try {
		if ((!pBufferBuffer) && !(pBufferNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ITCPIPPacket* pITCPIPPacket = dynamic_cast<ITCPIPPacket*>(pIBaseClass);
		if (!pITCPIPPacket)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pITCPIPPacket->GetData(nBufferBufferSize, pBufferNeededCount, pBufferBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for TCPIPConnection
**************************************************************************************************************************/
LibMCEnvResult libmcenv_tcpipconnection_getipaddress(LibMCEnv_TCPIPConnection pTCPIPConnection, const LibMCEnv_uint32 nIPAddressBufferSize, LibMCEnv_uint32* pIPAddressNeededChars, char * pIPAddressBuffer)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		if ( (!pIPAddressBuffer) && !(pIPAddressNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIPAddress("");
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIPAddressBuffer == nullptr);
		if (isCacheCall) {
			sIPAddress = pITCPIPConnection->GetIPAddress();

			pITCPIPConnection->_setCache (new ParameterCache_1<std::string> (sIPAddress));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pITCPIPConnection->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sIPAddress);
			pITCPIPConnection->_setCache (nullptr);
		}
		
		if (pIPAddressNeededChars)
			*pIPAddressNeededChars = (LibMCEnv_uint32) (sIPAddress.size()+1);
		if (pIPAddressBuffer) {
			if (sIPAddress.size() >= nIPAddressBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iIPAddress = 0; iIPAddress < sIPAddress.size(); iIPAddress++)
				pIPAddressBuffer[iIPAddress] = sIPAddress[iIPAddress];
			pIPAddressBuffer[sIPAddress.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpipconnection_getport(LibMCEnv_TCPIPConnection pTCPIPConnection, LibMCEnv_uint32 * pPort)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		if (pPort == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pPort = pITCPIPConnection->GetPort();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpipconnection_gettimeout(LibMCEnv_TCPIPConnection pTCPIPConnection, LibMCEnv_uint32 * pTimeout)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		if (pTimeout == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pTimeout = pITCPIPConnection->GetTimeout();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpipconnection_isconnected(LibMCEnv_TCPIPConnection pTCPIPConnection, bool * pIsConnected)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		if (pIsConnected == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pIsConnected = pITCPIPConnection->IsConnected();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpipconnection_disconnect(LibMCEnv_TCPIPConnection pTCPIPConnection)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pITCPIPConnection->Disconnect();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpipconnection_reconnect(LibMCEnv_TCPIPConnection pTCPIPConnection)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pITCPIPConnection->Reconnect();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpipconnection_sendbuffer(LibMCEnv_TCPIPConnection pTCPIPConnection, LibMCEnv_uint64 nBufferBufferSize, const LibMCEnv_uint8 * pBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		if ( (!pBufferBuffer) && (nBufferBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pITCPIPConnection->SendBuffer(nBufferBufferSize, pBufferBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpipconnection_waitfordata(LibMCEnv_TCPIPConnection pTCPIPConnection, LibMCEnv_uint32 nTimeOutInMS, bool * pDataAvailable)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		if (pDataAvailable == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pDataAvailable = pITCPIPConnection->WaitForData(nTimeOutInMS);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpipconnection_receivefixedpacket(LibMCEnv_TCPIPConnection pTCPIPConnection, LibMCEnv_uint32 nPacketSize, LibMCEnv_uint32 nTimeOutInMS, LibMCEnv_TCPIPPacket * pPacketInstance)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		if (pPacketInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBasePacketInstance(nullptr);
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBasePacketInstance = pITCPIPConnection->ReceiveFixedPacket(nPacketSize, nTimeOutInMS);

		*pPacketInstance = (IBase*)(pBasePacketInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_tcpipconnection_receivedata(LibMCEnv_TCPIPConnection pTCPIPConnection, LibMCEnv_uint32 nDataSize, LibMCEnv_uint32 nTimeOutInMS, LibMCEnv_TCPIPPacket * pPacketInstance)
{
	IBase* pIBaseClass = (IBase *)pTCPIPConnection;

	try {
		if (pPacketInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBasePacketInstance(nullptr);
		ITCPIPConnection* pITCPIPConnection = dynamic_cast<ITCPIPConnection*>(pIBaseClass);
		if (!pITCPIPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBasePacketInstance = pITCPIPConnection->ReceiveData(nDataSize, nTimeOutInMS);

		*pPacketInstance = (IBase*)(pBasePacketInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ModbusTCPDigitalIOStatus
**************************************************************************************************************************/
LibMCEnvResult libmcenv_modbustcpdigitaliostatus_getcount(LibMCEnv_ModbusTCPDigitalIOStatus pModbusTCPDigitalIOStatus, LibMCEnv_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPDigitalIOStatus;

	try {
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPDigitalIOStatus* pIModbusTCPDigitalIOStatus = dynamic_cast<IModbusTCPDigitalIOStatus*>(pIBaseClass);
		if (!pIModbusTCPDigitalIOStatus)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIModbusTCPDigitalIOStatus->GetCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpdigitaliostatus_getbaseaddress(LibMCEnv_ModbusTCPDigitalIOStatus pModbusTCPDigitalIOStatus, LibMCEnv_uint32 * pAddress)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPDigitalIOStatus;

	try {
		if (pAddress == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPDigitalIOStatus* pIModbusTCPDigitalIOStatus = dynamic_cast<IModbusTCPDigitalIOStatus*>(pIBaseClass);
		if (!pIModbusTCPDigitalIOStatus)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pAddress = pIModbusTCPDigitalIOStatus->GetBaseAddress();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpdigitaliostatus_getvalue(LibMCEnv_ModbusTCPDigitalIOStatus pModbusTCPDigitalIOStatus, LibMCEnv_uint32 nIndex, bool * pState)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPDigitalIOStatus;

	try {
		if (pState == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPDigitalIOStatus* pIModbusTCPDigitalIOStatus = dynamic_cast<IModbusTCPDigitalIOStatus*>(pIBaseClass);
		if (!pIModbusTCPDigitalIOStatus)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pState = pIModbusTCPDigitalIOStatus->GetValue(nIndex);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpdigitaliostatus_getvalues(LibMCEnv_ModbusTCPDigitalIOStatus pModbusTCPDigitalIOStatus, const LibMCEnv_uint64 nStateArrayBufferSize, LibMCEnv_uint64* pStateArrayNeededCount, LibMCEnv_uint8 * pStateArrayBuffer)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPDigitalIOStatus;

	try {
		if ((!pStateArrayBuffer) && !(pStateArrayNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPDigitalIOStatus* pIModbusTCPDigitalIOStatus = dynamic_cast<IModbusTCPDigitalIOStatus*>(pIBaseClass);
		if (!pIModbusTCPDigitalIOStatus)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIModbusTCPDigitalIOStatus->GetValues(nStateArrayBufferSize, pStateArrayNeededCount, pStateArrayBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ModbusTCPRegisterStatus
**************************************************************************************************************************/
LibMCEnvResult libmcenv_modbustcpregisterstatus_getcount(LibMCEnv_ModbusTCPRegisterStatus pModbusTCPRegisterStatus, LibMCEnv_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPRegisterStatus;

	try {
		if (pCount == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPRegisterStatus* pIModbusTCPRegisterStatus = dynamic_cast<IModbusTCPRegisterStatus*>(pIBaseClass);
		if (!pIModbusTCPRegisterStatus)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pCount = pIModbusTCPRegisterStatus->GetCount();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpregisterstatus_getbaseaddress(LibMCEnv_ModbusTCPRegisterStatus pModbusTCPRegisterStatus, LibMCEnv_uint32 * pAddress)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPRegisterStatus;

	try {
		if (pAddress == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPRegisterStatus* pIModbusTCPRegisterStatus = dynamic_cast<IModbusTCPRegisterStatus*>(pIBaseClass);
		if (!pIModbusTCPRegisterStatus)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pAddress = pIModbusTCPRegisterStatus->GetBaseAddress();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpregisterstatus_getvalue(LibMCEnv_ModbusTCPRegisterStatus pModbusTCPRegisterStatus, LibMCEnv_uint32 nIndex, LibMCEnv_uint16 * pState)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPRegisterStatus;

	try {
		if (pState == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPRegisterStatus* pIModbusTCPRegisterStatus = dynamic_cast<IModbusTCPRegisterStatus*>(pIBaseClass);
		if (!pIModbusTCPRegisterStatus)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pState = pIModbusTCPRegisterStatus->GetValue(nIndex);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpregisterstatus_getvalues(LibMCEnv_ModbusTCPRegisterStatus pModbusTCPRegisterStatus, const LibMCEnv_uint64 nStateArrayBufferSize, LibMCEnv_uint64* pStateArrayNeededCount, LibMCEnv_uint16 * pStateArrayBuffer)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPRegisterStatus;

	try {
		if ((!pStateArrayBuffer) && !(pStateArrayNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPRegisterStatus* pIModbusTCPRegisterStatus = dynamic_cast<IModbusTCPRegisterStatus*>(pIBaseClass);
		if (!pIModbusTCPRegisterStatus)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIModbusTCPRegisterStatus->GetValues(nStateArrayBufferSize, pStateArrayNeededCount, pStateArrayBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for ModbusTCPConnection
**************************************************************************************************************************/
LibMCEnvResult libmcenv_modbustcpconnection_getipaddress(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, const LibMCEnv_uint32 nIPAddressBufferSize, LibMCEnv_uint32* pIPAddressNeededChars, char * pIPAddressBuffer)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if ( (!pIPAddressBuffer) && !(pIPAddressNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIPAddress("");
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIPAddressBuffer == nullptr);
		if (isCacheCall) {
			sIPAddress = pIModbusTCPConnection->GetIPAddress();

			pIModbusTCPConnection->_setCache (new ParameterCache_1<std::string> (sIPAddress));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIModbusTCPConnection->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sIPAddress);
			pIModbusTCPConnection->_setCache (nullptr);
		}
		
		if (pIPAddressNeededChars)
			*pIPAddressNeededChars = (LibMCEnv_uint32) (sIPAddress.size()+1);
		if (pIPAddressBuffer) {
			if (sIPAddress.size() >= nIPAddressBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iIPAddress = 0; iIPAddress < sIPAddress.size(); iIPAddress++)
				pIPAddressBuffer[iIPAddress] = sIPAddress[iIPAddress];
			pIPAddressBuffer[sIPAddress.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_getport(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, LibMCEnv_uint32 * pPort)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if (pPort == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pPort = pIModbusTCPConnection->GetPort();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_gettimeout(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, LibMCEnv_uint32 * pTimeout)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if (pTimeout == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pTimeout = pIModbusTCPConnection->GetTimeout();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_isconnected(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, bool * pIsConnected)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if (pIsConnected == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pIsConnected = pIModbusTCPConnection->IsConnected();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_disconnect(LibMCEnv_ModbusTCPConnection pModbusTCPConnection)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIModbusTCPConnection->Disconnect();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_reconnect(LibMCEnv_ModbusTCPConnection pModbusTCPConnection)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIModbusTCPConnection->Reconnect();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_diagnosiscall(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, LibMCEnv_uint16 nSubFunction, LibMCEnv_uint16 nDataField, LibMCEnv_uint16 * pDataResponse)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if (pDataResponse == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pDataResponse = pIModbusTCPConnection->DiagnosisCall(nSubFunction, nDataField);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_readcoilstatus(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, LibMCEnv_uint32 nStartAddress, LibMCEnv_uint32 nBitCount, LibMCEnv_ModbusTCPDigitalIOStatus * pCoilStatus)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if (pCoilStatus == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseCoilStatus(nullptr);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseCoilStatus = pIModbusTCPConnection->ReadCoilStatus(nStartAddress, nBitCount);

		*pCoilStatus = (IBase*)(pBaseCoilStatus);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_readinputstatus(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, LibMCEnv_uint32 nStartAddress, LibMCEnv_uint32 nBitCount, LibMCEnv_ModbusTCPDigitalIOStatus * pInputStatus)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if (pInputStatus == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseInputStatus(nullptr);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseInputStatus = pIModbusTCPConnection->ReadInputStatus(nStartAddress, nBitCount);

		*pInputStatus = (IBase*)(pBaseInputStatus);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_readholdingregisters(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, LibMCEnv_uint32 nStartAddress, LibMCEnv_uint32 nRegisterCount, LibMCEnv_ModbusTCPRegisterStatus * pRegisterInstance)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if (pRegisterInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseRegisterInstance(nullptr);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseRegisterInstance = pIModbusTCPConnection->ReadHoldingRegisters(nStartAddress, nRegisterCount);

		*pRegisterInstance = (IBase*)(pBaseRegisterInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_readinputregisters(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, LibMCEnv_uint32 nStartAddress, LibMCEnv_uint32 nRegisterCount, LibMCEnv_ModbusTCPRegisterStatus * pRegisterInstance)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if (pRegisterInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseRegisterInstance(nullptr);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseRegisterInstance = pIModbusTCPConnection->ReadInputRegisters(nStartAddress, nRegisterCount);

		*pRegisterInstance = (IBase*)(pBaseRegisterInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_forcemultiplecoils(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, LibMCEnv_uint32 nStartAddress, LibMCEnv_uint64 nBufferBufferSize, const LibMCEnv_uint8 * pBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if ( (!pBufferBuffer) && (nBufferBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIModbusTCPConnection->ForceMultipleCoils(nStartAddress, nBufferBufferSize, pBufferBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_modbustcpconnection_presetmultipleregisters(LibMCEnv_ModbusTCPConnection pModbusTCPConnection, LibMCEnv_uint32 nStartAddress, LibMCEnv_uint64 nBufferBufferSize, const LibMCEnv_uint16 * pBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pModbusTCPConnection;

	try {
		if ( (!pBufferBuffer) && (nBufferBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IModbusTCPConnection* pIModbusTCPConnection = dynamic_cast<IModbusTCPConnection*>(pIBaseClass);
		if (!pIModbusTCPConnection)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIModbusTCPConnection->PresetMultipleRegisters(nStartAddress, nBufferBufferSize, pBufferBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for DriverStatusUpdateSession
**************************************************************************************************************************/
LibMCEnvResult libmcenv_driverstatusupdatesession_setstringparameter(LibMCEnv_DriverStatusUpdateSession pDriverStatusUpdateSession, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriverStatusUpdateSession;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IDriverStatusUpdateSession* pIDriverStatusUpdateSession = dynamic_cast<IDriverStatusUpdateSession*>(pIBaseClass);
		if (!pIDriverStatusUpdateSession)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverStatusUpdateSession->SetStringParameter(sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverstatusupdatesession_setuuidparameter(LibMCEnv_DriverStatusUpdateSession pDriverStatusUpdateSession, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriverStatusUpdateSession;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IDriverStatusUpdateSession* pIDriverStatusUpdateSession = dynamic_cast<IDriverStatusUpdateSession*>(pIBaseClass);
		if (!pIDriverStatusUpdateSession)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverStatusUpdateSession->SetUUIDParameter(sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverstatusupdatesession_setdoubleparameter(LibMCEnv_DriverStatusUpdateSession pDriverStatusUpdateSession, const char * pParameterName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pDriverStatusUpdateSession;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverStatusUpdateSession* pIDriverStatusUpdateSession = dynamic_cast<IDriverStatusUpdateSession*>(pIBaseClass);
		if (!pIDriverStatusUpdateSession)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverStatusUpdateSession->SetDoubleParameter(sParameterName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverstatusupdatesession_setintegerparameter(LibMCEnv_DriverStatusUpdateSession pDriverStatusUpdateSession, const char * pParameterName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pDriverStatusUpdateSession;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverStatusUpdateSession* pIDriverStatusUpdateSession = dynamic_cast<IDriverStatusUpdateSession*>(pIBaseClass);
		if (!pIDriverStatusUpdateSession)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverStatusUpdateSession->SetIntegerParameter(sParameterName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverstatusupdatesession_setboolparameter(LibMCEnv_DriverStatusUpdateSession pDriverStatusUpdateSession, const char * pParameterName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pDriverStatusUpdateSession;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverStatusUpdateSession* pIDriverStatusUpdateSession = dynamic_cast<IDriverStatusUpdateSession*>(pIBaseClass);
		if (!pIDriverStatusUpdateSession)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverStatusUpdateSession->SetBoolParameter(sParameterName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverstatusupdatesession_logmessage(LibMCEnv_DriverStatusUpdateSession pDriverStatusUpdateSession, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pDriverStatusUpdateSession;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IDriverStatusUpdateSession* pIDriverStatusUpdateSession = dynamic_cast<IDriverStatusUpdateSession*>(pIBaseClass);
		if (!pIDriverStatusUpdateSession)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverStatusUpdateSession->LogMessage(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverstatusupdatesession_logwarning(LibMCEnv_DriverStatusUpdateSession pDriverStatusUpdateSession, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pDriverStatusUpdateSession;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IDriverStatusUpdateSession* pIDriverStatusUpdateSession = dynamic_cast<IDriverStatusUpdateSession*>(pIBaseClass);
		if (!pIDriverStatusUpdateSession)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverStatusUpdateSession->LogWarning(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverstatusupdatesession_loginfo(LibMCEnv_DriverStatusUpdateSession pDriverStatusUpdateSession, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pDriverStatusUpdateSession;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IDriverStatusUpdateSession* pIDriverStatusUpdateSession = dynamic_cast<IDriverStatusUpdateSession*>(pIBaseClass);
		if (!pIDriverStatusUpdateSession)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverStatusUpdateSession->LogInfo(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverstatusupdatesession_sleep(LibMCEnv_DriverStatusUpdateSession pDriverStatusUpdateSession, LibMCEnv_uint32 nDelay)
{
	IBase* pIBaseClass = (IBase *)pDriverStatusUpdateSession;

	try {
		IDriverStatusUpdateSession* pIDriverStatusUpdateSession = dynamic_cast<IDriverStatusUpdateSession*>(pIBaseClass);
		if (!pIDriverStatusUpdateSession)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverStatusUpdateSession->Sleep(nDelay);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for DriverEnvironment
**************************************************************************************************************************/
LibMCEnvResult libmcenv_driverenvironment_createstatusupdatesession(LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCEnv_DriverStatusUpdateSession * pUpdateStatusInstance)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pUpdateStatusInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseUpdateStatusInstance(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseUpdateStatusInstance = pIDriverEnvironment->CreateStatusUpdateSession();

		*pUpdateStatusInstance = (IBase*)(pBaseUpdateStatusInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_createworkingdirectory(LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCEnv_WorkingDirectory * pWorkingDirectory)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pWorkingDirectory == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseWorkingDirectory(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseWorkingDirectory = pIDriverEnvironment->CreateWorkingDirectory();

		*pWorkingDirectory = (IBase*)(pBaseWorkingDirectory);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_createtcpipconnection(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pIPAddress, LibMCEnv_uint32 nPort, LibMCEnv_uint32 nTimeOutInMS, LibMCEnv_TCPIPConnection * pConnectionInstance)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pIPAddress == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pConnectionInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIPAddress(pIPAddress);
		IBase* pBaseConnectionInstance(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseConnectionInstance = pIDriverEnvironment->CreateTCPIPConnection(sIPAddress, nPort, nTimeOutInMS);

		*pConnectionInstance = (IBase*)(pBaseConnectionInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_createmodbustcpconnection(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pIPAddress, LibMCEnv_uint32 nPort, LibMCEnv_uint32 nTimeOutInMS, LibMCEnv_ModbusTCPConnection * pConnectionInstance)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pIPAddress == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pConnectionInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIPAddress(pIPAddress);
		IBase* pBaseConnectionInstance(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseConnectionInstance = pIDriverEnvironment->CreateModbusTCPConnection(sIPAddress, nPort, nTimeOutInMS);

		*pConnectionInstance = (IBase*)(pBaseConnectionInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_createxmldocument(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pRootNodeName, const char * pDefaultNamespace, LibMCEnv_XMLDocument * pXMLDocument)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pRootNodeName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDefaultNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pXMLDocument == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sRootNodeName(pRootNodeName);
		std::string sDefaultNamespace(pDefaultNamespace);
		IBase* pBaseXMLDocument(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseXMLDocument = pIDriverEnvironment->CreateXMLDocument(sRootNodeName, sDefaultNamespace);

		*pXMLDocument = (IBase*)(pBaseXMLDocument);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_parsexmlstring(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pXMLString, LibMCEnv_XMLDocument * pXMLDocument)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pXMLString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pXMLDocument == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sXMLString(pXMLString);
		IBase* pBaseXMLDocument(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseXMLDocument = pIDriverEnvironment->ParseXMLString(sXMLString);

		*pXMLDocument = (IBase*)(pBaseXMLDocument);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_parsexmldata(LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCEnv_uint64 nXMLDataBufferSize, const LibMCEnv_uint8 * pXMLDataBuffer, LibMCEnv_XMLDocument * pXMLDocument)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if ( (!pXMLDataBuffer) && (nXMLDataBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pXMLDocument == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseXMLDocument(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseXMLDocument = pIDriverEnvironment->ParseXMLData(nXMLDataBufferSize, pXMLDataBuffer);

		*pXMLDocument = (IBase*)(pBaseXMLDocument);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_driverhasresourcedata(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pIdentifier, bool * pHasResourceData)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHasResourceData == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pHasResourceData = pIDriverEnvironment->DriverHasResourceData(sIdentifier);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_machinehasresourcedata(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pIdentifier, bool * pHasResourceData)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHasResourceData == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pHasResourceData = pIDriverEnvironment->MachineHasResourceData(sIdentifier);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_retrievedriverdata(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pIdentifier, const LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ((!pDataBufferBuffer) && !(pDataBufferNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RetrieveDriverData(sIdentifier, nDataBufferBufferSize, pDataBufferNeededCount, pDataBufferBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_retrievedriverresourcedata(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pIdentifier, const LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ((!pDataBufferBuffer) && !(pDataBufferNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RetrieveDriverResourceData(sIdentifier, nDataBufferBufferSize, pDataBufferNeededCount, pDataBufferBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_retrievemachineresourcedata(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pIdentifier, const LibMCEnv_uint64 nDataBufferBufferSize, LibMCEnv_uint64* pDataBufferNeededCount, LibMCEnv_uint8 * pDataBufferBuffer)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ((!pDataBufferBuffer) && !(pDataBufferNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RetrieveMachineResourceData(sIdentifier, nDataBufferBufferSize, pDataBufferNeededCount, pDataBufferBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_createtoolpathaccessor(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pStreamUUID, LibMCEnv_ToolpathAccessor * pToolpathInstance)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pStreamUUID == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pToolpathInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStreamUUID(pStreamUUID);
		IBase* pBaseToolpathInstance(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseToolpathInstance = pIDriverEnvironment->CreateToolpathAccessor(sStreamUUID);

		*pToolpathInstance = (IBase*)(pBaseToolpathInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_parameternameisvalid(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, bool * pNameIsValid)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pNameIsValid == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pNameIsValid = pIDriverEnvironment->ParameterNameIsValid(sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registerstringparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, const char * pDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDefaultValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		std::string sDefaultValue(pDefaultValue);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterStringParameter(sParameterName, sDescription, sDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registeruuidparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, const char * pDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDefaultValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		std::string sDefaultValue(pDefaultValue);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterUUIDParameter(sParameterName, sDescription, sDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registerdoubleparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, LibMCEnv_double dDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterDoubleParameter(sParameterName, sDescription, dDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registerintegerparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, LibMCEnv_int64 nDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterIntegerParameter(sParameterName, sDescription, nDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_registerboolparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pDescription, bool bDefaultValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sDescription(pDescription);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->RegisterBoolParameter(sParameterName, sDescription, bDefaultValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setstringparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetStringParameter(sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setuuidparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetUUIDParameter(sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setdoubleparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetDoubleParameter(sParameterName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setintegerparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetIntegerParameter(sParameterName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_setboolparameter(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pParameterName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterName(pParameterName);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->SetBoolParameter(sParameterName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_sleep(LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCEnv_uint32 nDelay)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->Sleep(nDelay);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_getglobaltimerinmilliseconds(LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCEnv_uint64 * pTimerValue)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pTimerValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pTimerValue = pIDriverEnvironment->GetGlobalTimerInMilliseconds();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_logmessage(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->LogMessage(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_logwarning(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->LogWarning(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_loginfo(LibMCEnv_DriverEnvironment pDriverEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIDriverEnvironment->LogInfo(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_createemptyimage(LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCEnv_uint32 nPixelSizeX, LibMCEnv_uint32 nPixelSizeY, LibMCEnv_double dDPIValueX, LibMCEnv_double dDPIValueY, eLibMCEnvImagePixelFormat ePixelFormat, LibMCEnv_ImageData * pImageDataInstance)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if (pImageDataInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseImageDataInstance(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseImageDataInstance = pIDriverEnvironment->CreateEmptyImage(nPixelSizeX, nPixelSizeY, dDPIValueX, dDPIValueY, ePixelFormat);

		*pImageDataInstance = (IBase*)(pBaseImageDataInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_driverenvironment_loadpngimage(LibMCEnv_DriverEnvironment pDriverEnvironment, LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer, LibMCEnv_double dDPIValueX, LibMCEnv_double dDPIValueY, eLibMCEnvImagePixelFormat ePixelFormat, LibMCEnv_ImageData * pImageDataInstance)
{
	IBase* pIBaseClass = (IBase *)pDriverEnvironment;

	try {
		if ( (!pPNGDataBuffer) && (nPNGDataBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pImageDataInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseImageDataInstance(nullptr);
		IDriverEnvironment* pIDriverEnvironment = dynamic_cast<IDriverEnvironment*>(pIBaseClass);
		if (!pIDriverEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseImageDataInstance = pIDriverEnvironment->LoadPNGImage(nPNGDataBufferSize, pPNGDataBuffer, dDPIValueX, dDPIValueY, ePixelFormat);

		*pImageDataInstance = (IBase*)(pBaseImageDataInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for SignalTrigger
**************************************************************************************************************************/
LibMCEnvResult libmcenv_signaltrigger_cantrigger(LibMCEnv_SignalTrigger pSignalTrigger, bool * pChannelIsAvailable)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pChannelIsAvailable == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pChannelIsAvailable = pISignalTrigger->CanTrigger();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_trigger(LibMCEnv_SignalTrigger pSignalTrigger)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->Trigger();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_waitforhandling(LibMCEnv_SignalTrigger pSignalTrigger, LibMCEnv_uint32 nTimeOut, bool * pSuccess)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pSuccess == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pSuccess = pISignalTrigger->WaitForHandling(nTimeOut);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getname(LibMCEnv_SignalTrigger pSignalTrigger, const LibMCEnv_uint32 nSignalNameBufferSize, LibMCEnv_uint32* pSignalNameNeededChars, char * pSignalNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if ( (!pSignalNameBuffer) && !(pSignalNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalName("");
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSignalNameBuffer == nullptr);
		if (isCacheCall) {
			sSignalName = pISignalTrigger->GetName();

			pISignalTrigger->_setCache (new ParameterCache_1<std::string> (sSignalName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalTrigger->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSignalName);
			pISignalTrigger->_setCache (nullptr);
		}
		
		if (pSignalNameNeededChars)
			*pSignalNameNeededChars = (LibMCEnv_uint32) (sSignalName.size()+1);
		if (pSignalNameBuffer) {
			if (sSignalName.size() >= nSignalNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSignalName = 0; iSignalName < sSignalName.size(); iSignalName++)
				pSignalNameBuffer[iSignalName] = sSignalName[iSignalName];
			pSignalNameBuffer[sSignalName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getstatemachine(LibMCEnv_SignalTrigger pSignalTrigger, const LibMCEnv_uint32 nStateMachineNameBufferSize, LibMCEnv_uint32* pStateMachineNameNeededChars, char * pStateMachineNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if ( (!pStateMachineNameBuffer) && !(pStateMachineNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStateMachineName("");
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStateMachineNameBuffer == nullptr);
		if (isCacheCall) {
			sStateMachineName = pISignalTrigger->GetStateMachine();

			pISignalTrigger->_setCache (new ParameterCache_1<std::string> (sStateMachineName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalTrigger->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStateMachineName);
			pISignalTrigger->_setCache (nullptr);
		}
		
		if (pStateMachineNameNeededChars)
			*pStateMachineNameNeededChars = (LibMCEnv_uint32) (sStateMachineName.size()+1);
		if (pStateMachineNameBuffer) {
			if (sStateMachineName.size() >= nStateMachineNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStateMachineName = 0; iStateMachineName < sStateMachineName.size(); iStateMachineName++)
				pStateMachineNameBuffer[iStateMachineName] = sStateMachineName[iStateMachineName];
			pStateMachineNameBuffer[sStateMachineName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setstring(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue(pValue);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetString(sName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setuuid(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue(pValue);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetUUID(sName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setdouble(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetDouble(sName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setinteger(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetInteger(sName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_setbool(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalTrigger->SetBool(sName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getstringresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue("");
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pISignalTrigger->GetStringResult(sName);

			pISignalTrigger->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalTrigger->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pISignalTrigger->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getuuidresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue("");
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pISignalTrigger->GetUUIDResult(sName);

			pISignalTrigger->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalTrigger->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pISignalTrigger->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getdoubleresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalTrigger->GetDoubleResult(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getintegerresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalTrigger->GetIntegerResult(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signaltrigger_getboolresult(LibMCEnv_SignalTrigger pSignalTrigger, const char * pName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalTrigger;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalTrigger* pISignalTrigger = dynamic_cast<ISignalTrigger*>(pIBaseClass);
		if (!pISignalTrigger)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalTrigger->GetBoolResult(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for SignalHandler
**************************************************************************************************************************/
LibMCEnvResult libmcenv_signalhandler_signalhandled(LibMCEnv_SignalHandler pSignalHandler)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SignalHandled();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getname(LibMCEnv_SignalHandler pSignalHandler, const LibMCEnv_uint32 nSignalNameBufferSize, LibMCEnv_uint32* pSignalNameNeededChars, char * pSignalNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if ( (!pSignalNameBuffer) && !(pSignalNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalName("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSignalNameBuffer == nullptr);
		if (isCacheCall) {
			sSignalName = pISignalHandler->GetName();

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sSignalName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSignalName);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pSignalNameNeededChars)
			*pSignalNameNeededChars = (LibMCEnv_uint32) (sSignalName.size()+1);
		if (pSignalNameBuffer) {
			if (sSignalName.size() >= nSignalNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSignalName = 0; iSignalName < sSignalName.size(); iSignalName++)
				pSignalNameBuffer[iSignalName] = sSignalName[iSignalName];
			pSignalNameBuffer[sSignalName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getsignalid(LibMCEnv_SignalHandler pSignalHandler, const LibMCEnv_uint32 nSignalIDBufferSize, LibMCEnv_uint32* pSignalIDNeededChars, char * pSignalIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if ( (!pSignalIDBuffer) && !(pSignalIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalID("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSignalIDBuffer == nullptr);
		if (isCacheCall) {
			sSignalID = pISignalHandler->GetSignalID();

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sSignalID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSignalID);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pSignalIDNeededChars)
			*pSignalIDNeededChars = (LibMCEnv_uint32) (sSignalID.size()+1);
		if (pSignalIDBuffer) {
			if (sSignalID.size() >= nSignalIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSignalID = 0; iSignalID < sSignalID.size(); iSignalID++)
				pSignalIDBuffer[iSignalID] = sSignalID[iSignalID];
			pSignalIDBuffer[sSignalID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getsignaluuid(LibMCEnv_SignalHandler pSignalHandler, const LibMCEnv_uint32 nSignalUUIDBufferSize, LibMCEnv_uint32* pSignalUUIDNeededChars, char * pSignalUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if ( (!pSignalUUIDBuffer) && !(pSignalUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalUUID("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSignalUUIDBuffer == nullptr);
		if (isCacheCall) {
			sSignalUUID = pISignalHandler->GetSignalUUID();

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sSignalUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSignalUUID);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pSignalUUIDNeededChars)
			*pSignalUUIDNeededChars = (LibMCEnv_uint32) (sSignalUUID.size()+1);
		if (pSignalUUIDBuffer) {
			if (sSignalUUID.size() >= nSignalUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSignalUUID = 0; iSignalUUID < sSignalUUID.size(); iSignalUUID++)
				pSignalUUIDBuffer[iSignalUUID] = sSignalUUID[iSignalUUID];
			pSignalUUIDBuffer[sSignalUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getstatemachine(LibMCEnv_SignalHandler pSignalHandler, const LibMCEnv_uint32 nStateMachineNameBufferSize, LibMCEnv_uint32* pStateMachineNameNeededChars, char * pStateMachineNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if ( (!pStateMachineNameBuffer) && !(pStateMachineNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStateMachineName("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStateMachineNameBuffer == nullptr);
		if (isCacheCall) {
			sStateMachineName = pISignalHandler->GetStateMachine();

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sStateMachineName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStateMachineName);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pStateMachineNameNeededChars)
			*pStateMachineNameNeededChars = (LibMCEnv_uint32) (sStateMachineName.size()+1);
		if (pStateMachineNameBuffer) {
			if (sStateMachineName.size() >= nStateMachineNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStateMachineName = 0; iStateMachineName < sStateMachineName.size(); iStateMachineName++)
				pStateMachineNameBuffer[iStateMachineName] = sStateMachineName[iStateMachineName];
			pStateMachineNameBuffer[sStateMachineName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getstring(LibMCEnv_SignalHandler pSignalHandler, const char * pName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pISignalHandler->GetString(sName);

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getuuid(LibMCEnv_SignalHandler pSignalHandler, const char * pName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue("");
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pISignalHandler->GetUUID(sName);

			pISignalHandler->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pISignalHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pISignalHandler->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getdouble(LibMCEnv_SignalHandler pSignalHandler, const char * pName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalHandler->GetDouble(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getinteger(LibMCEnv_SignalHandler pSignalHandler, const char * pName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalHandler->GetInteger(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_getbool(LibMCEnv_SignalHandler pSignalHandler, const char * pName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pISignalHandler->GetBool(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setstringresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue(pValue);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetStringResult(sName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setuuidresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sValue(pValue);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetUUIDResult(sName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setdoubleresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetDoubleResult(sName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setintegerresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetIntegerResult(sName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_signalhandler_setboolresult(LibMCEnv_SignalHandler pSignalHandler, const char * pName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pSignalHandler;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		ISignalHandler* pISignalHandler = dynamic_cast<ISignalHandler*>(pIBaseClass);
		if (!pISignalHandler)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pISignalHandler->SetBoolResult(sName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for StateEnvironment
**************************************************************************************************************************/
LibMCEnvResult libmcenv_stateenvironment_getmachinestate(LibMCEnv_StateEnvironment pStateEnvironment, const char * pMachineInstance, const LibMCEnv_uint32 nStateNameBufferSize, LibMCEnv_uint32* pStateNameNeededChars, char * pStateNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pStateNameBuffer) && !(pStateNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sStateName("");
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStateNameBuffer == nullptr);
		if (isCacheCall) {
			sStateName = pIStateEnvironment->GetMachineState(sMachineInstance);

			pIStateEnvironment->_setCache (new ParameterCache_1<std::string> (sStateName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStateEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStateName);
			pIStateEnvironment->_setCache (nullptr);
		}
		
		if (pStateNameNeededChars)
			*pStateNameNeededChars = (LibMCEnv_uint32) (sStateName.size()+1);
		if (pStateNameBuffer) {
			if (sStateName.size() >= nStateNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStateName = 0; iStateName < sStateName.size(); iStateName++)
				pStateNameBuffer[iStateName] = sStateName[iStateName];
			pStateNameBuffer[sStateName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_preparesignal(LibMCEnv_StateEnvironment pStateEnvironment, const char * pMachineInstance, const char * pSignalName, LibMCEnv_SignalTrigger * pSignalInstance)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSignalName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSignalInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sSignalName(pSignalName);
		IBase* pBaseSignalInstance(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseSignalInstance = pIStateEnvironment->PrepareSignal(sMachineInstance, sSignalName);

		*pSignalInstance = (IBase*)(pBaseSignalInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_waitforsignal(LibMCEnv_StateEnvironment pStateEnvironment, const char * pSignalName, LibMCEnv_uint32 nTimeOut, LibMCEnv_SignalHandler * pHandlerInstance, bool * pSuccess)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pSignalName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHandlerInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSuccess == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalName(pSignalName);
		ISignalHandler* pBaseHandlerInstance(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pSuccess = pIStateEnvironment->WaitForSignal(sSignalName, nTimeOut, pBaseHandlerInstance);

		*pHandlerInstance = (IBase*)(pBaseHandlerInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getunhandledsignal(LibMCEnv_StateEnvironment pStateEnvironment, const char * pSignalTypeName, LibMCEnv_SignalHandler * pHandlerInstance)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pSignalTypeName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHandlerInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSignalTypeName(pSignalTypeName);
		IBase* pBaseHandlerInstance(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseHandlerInstance = pIStateEnvironment->GetUnhandledSignal(sSignalTypeName);

		*pHandlerInstance = (IBase*)(pBaseHandlerInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getunhandledsignalbyuuid(LibMCEnv_StateEnvironment pStateEnvironment, const char * pUUID, bool bMustExist, LibMCEnv_SignalHandler * pHandler)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pUUID == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHandler == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IBase* pBaseHandler(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseHandler = pIStateEnvironment->GetUnhandledSignalByUUID(sUUID, bMustExist);

		*pHandler = (IBase*)(pBaseHandler);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getdriverlibrary(LibMCEnv_StateEnvironment pStateEnvironment, const char * pDriverName, const LibMCEnv_uint32 nDriverTypeBufferSize, LibMCEnv_uint32* pDriverTypeNeededChars, char * pDriverTypeBuffer, LibMCEnv_pvoid * pDriverLookup)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pDriverName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pDriverTypeBuffer) && !(pDriverTypeNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pDriverLookup)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sDriverName(pDriverName);
		std::string sDriverType("");
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDriverTypeBuffer == nullptr);
		if (isCacheCall) {
			pIStateEnvironment->GetDriverLibrary(sDriverName, sDriverType, *pDriverLookup);

			pIStateEnvironment->_setCache (new ParameterCache_2<std::string, LibMCEnv_pvoid> (sDriverType, *pDriverLookup));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, LibMCEnv_pvoid>*> (pIStateEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sDriverType, *pDriverLookup);
			pIStateEnvironment->_setCache (nullptr);
		}
		
		if (pDriverTypeNeededChars)
			*pDriverTypeNeededChars = (LibMCEnv_uint32) (sDriverType.size()+1);
		if (pDriverTypeBuffer) {
			if (sDriverType.size() >= nDriverTypeBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iDriverType = 0; iDriverType < sDriverType.size(); iDriverType++)
				pDriverTypeBuffer[iDriverType] = sDriverType[iDriverType];
			pDriverTypeBuffer[sDriverType.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_createdriveraccess(LibMCEnv_StateEnvironment pStateEnvironment, const char * pDriverName, LibMCEnv_pvoid * pDriverHandle)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pDriverName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pDriverHandle)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sDriverName(pDriverName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->CreateDriverAccess(sDriverName, *pDriverHandle);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getbuildjob(LibMCEnv_StateEnvironment pStateEnvironment, const char * pBuildUUID, LibMCEnv_Build * pBuildInstance)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pBuildUUID == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pBuildInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sBuildUUID(pBuildUUID);
		IBase* pBaseBuildInstance(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseBuildInstance = pIStateEnvironment->GetBuildJob(sBuildUUID);

		*pBuildInstance = (IBase*)(pBaseBuildInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_unloadalltoolpathes(LibMCEnv_StateEnvironment pStateEnvironment)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->UnloadAllToolpathes();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setnextstate(LibMCEnv_StateEnvironment pStateEnvironment, const char * pStateName)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pStateName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sStateName(pStateName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetNextState(sStateName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_logmessage(LibMCEnv_StateEnvironment pStateEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->LogMessage(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_logwarning(LibMCEnv_StateEnvironment pStateEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->LogWarning(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_loginfo(LibMCEnv_StateEnvironment pStateEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->LogInfo(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_sleep(LibMCEnv_StateEnvironment pStateEnvironment, LibMCEnv_uint32 nDelay)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->Sleep(nDelay);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_checkfortermination(LibMCEnv_StateEnvironment pStateEnvironment, bool * pShallTerminate)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pShallTerminate == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pShallTerminate = pIStateEnvironment->CheckForTermination();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_storesignal(LibMCEnv_StateEnvironment pStateEnvironment, const char * pName, LibMCEnv_SignalHandler pHandler)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBase* pIBaseClassHandler = (IBase *)pHandler;
		ISignalHandler* pIHandler = dynamic_cast<ISignalHandler*>(pIBaseClassHandler);
		if (!pIHandler)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDCAST);
		
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->StoreSignal(sName, pIHandler);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_retrievesignal(LibMCEnv_StateEnvironment pStateEnvironment, const char * pName, LibMCEnv_SignalHandler * pHandler)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHandler == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBase* pBaseHandler(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseHandler = pIStateEnvironment->RetrieveSignal(sName);

		*pHandler = (IBase*)(pBaseHandler);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_clearstoredvalue(LibMCEnv_StateEnvironment pStateEnvironment, const char * pName)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->ClearStoredValue(sName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setstringparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetStringParameter(sParameterGroup, sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setuuidparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue(pValue);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetUUIDParameter(sParameterGroup, sParameterName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setdoubleparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetDoubleParameter(sParameterGroup, sParameterName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setintegerparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetIntegerParameter(sParameterGroup, sParameterName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_setboolparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->SetBoolParameter(sParameterGroup, sParameterName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getstringparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue("");
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIStateEnvironment->GetStringParameter(sParameterGroup, sParameterName);

			pIStateEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStateEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIStateEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getuuidparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue("");
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIStateEnvironment->GetUUIDParameter(sParameterGroup, sParameterName);

			pIStateEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStateEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIStateEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getdoubleparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIStateEnvironment->GetDoubleParameter(sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getintegerparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIStateEnvironment->GetIntegerParameter(sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getboolparameter(LibMCEnv_StateEnvironment pStateEnvironment, const char * pParameterGroup, const char * pParameterName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIStateEnvironment->GetBoolParameter(sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_loadresourcedata(LibMCEnv_StateEnvironment pStateEnvironment, const char * pResourceName, const LibMCEnv_uint64 nResourceDataBufferSize, LibMCEnv_uint64* pResourceDataNeededCount, LibMCEnv_uint8 * pResourceDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pResourceName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ((!pResourceDataBuffer) && !(pResourceDataNeededCount))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sResourceName(pResourceName);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIStateEnvironment->LoadResourceData(sResourceName, nResourceDataBufferSize, pResourceDataNeededCount, pResourceDataBuffer);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_loadresourcestring(LibMCEnv_StateEnvironment pStateEnvironment, const char * pResourceName, const LibMCEnv_uint32 nResourceDataBufferSize, LibMCEnv_uint32* pResourceDataNeededChars, char * pResourceDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pResourceName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pResourceDataBuffer) && !(pResourceDataNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sResourceName(pResourceName);
		std::string sResourceData("");
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pResourceDataBuffer == nullptr);
		if (isCacheCall) {
			sResourceData = pIStateEnvironment->LoadResourceString(sResourceName);

			pIStateEnvironment->_setCache (new ParameterCache_1<std::string> (sResourceData));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStateEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sResourceData);
			pIStateEnvironment->_setCache (nullptr);
		}
		
		if (pResourceDataNeededChars)
			*pResourceDataNeededChars = (LibMCEnv_uint32) (sResourceData.size()+1);
		if (pResourceDataBuffer) {
			if (sResourceData.size() >= nResourceDataBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iResourceData = 0; iResourceData < sResourceData.size(); iResourceData++)
				pResourceDataBuffer[iResourceData] = sResourceData[iResourceData];
			pResourceDataBuffer[sResourceData.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_createemptyimage(LibMCEnv_StateEnvironment pStateEnvironment, LibMCEnv_uint32 nPixelSizeX, LibMCEnv_uint32 nPixelSizeY, LibMCEnv_double dDPIValueX, LibMCEnv_double dDPIValueY, eLibMCEnvImagePixelFormat ePixelFormat, LibMCEnv_ImageData * pImageDataInstance)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pImageDataInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseImageDataInstance(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseImageDataInstance = pIStateEnvironment->CreateEmptyImage(nPixelSizeX, nPixelSizeY, dDPIValueX, dDPIValueY, ePixelFormat);

		*pImageDataInstance = (IBase*)(pBaseImageDataInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_loadpngimage(LibMCEnv_StateEnvironment pStateEnvironment, LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer, LibMCEnv_double dDPIValueX, LibMCEnv_double dDPIValueY, eLibMCEnvImagePixelFormat ePixelFormat, LibMCEnv_ImageData * pImageDataInstance)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if ( (!pPNGDataBuffer) && (nPNGDataBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pImageDataInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseImageDataInstance(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseImageDataInstance = pIStateEnvironment->LoadPNGImage(nPNGDataBufferSize, pPNGDataBuffer, dDPIValueX, dDPIValueY, ePixelFormat);

		*pImageDataInstance = (IBase*)(pBaseImageDataInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_getglobaltimerinmilliseconds(LibMCEnv_StateEnvironment pStateEnvironment, LibMCEnv_uint64 * pTimerValue)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pTimerValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pTimerValue = pIStateEnvironment->GetGlobalTimerInMilliseconds();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_gettestenvironment(LibMCEnv_StateEnvironment pStateEnvironment, LibMCEnv_TestEnvironment * pTestEnvironment)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pTestEnvironment == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseTestEnvironment(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseTestEnvironment = pIStateEnvironment->GetTestEnvironment();

		*pTestEnvironment = (IBase*)(pBaseTestEnvironment);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_createxmldocument(LibMCEnv_StateEnvironment pStateEnvironment, const char * pRootNodeName, const char * pDefaultNamespace, LibMCEnv_XMLDocument * pXMLDocument)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pRootNodeName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDefaultNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pXMLDocument == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sRootNodeName(pRootNodeName);
		std::string sDefaultNamespace(pDefaultNamespace);
		IBase* pBaseXMLDocument(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseXMLDocument = pIStateEnvironment->CreateXMLDocument(sRootNodeName, sDefaultNamespace);

		*pXMLDocument = (IBase*)(pBaseXMLDocument);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_parsexmlstring(LibMCEnv_StateEnvironment pStateEnvironment, const char * pXMLString, LibMCEnv_XMLDocument * pXMLDocument)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if (pXMLString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pXMLDocument == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sXMLString(pXMLString);
		IBase* pBaseXMLDocument(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseXMLDocument = pIStateEnvironment->ParseXMLString(sXMLString);

		*pXMLDocument = (IBase*)(pBaseXMLDocument);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_stateenvironment_parsexmldata(LibMCEnv_StateEnvironment pStateEnvironment, LibMCEnv_uint64 nXMLDataBufferSize, const LibMCEnv_uint8 * pXMLDataBuffer, LibMCEnv_XMLDocument * pXMLDocument)
{
	IBase* pIBaseClass = (IBase *)pStateEnvironment;

	try {
		if ( (!pXMLDataBuffer) && (nXMLDataBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pXMLDocument == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseXMLDocument(nullptr);
		IStateEnvironment* pIStateEnvironment = dynamic_cast<IStateEnvironment*>(pIBaseClass);
		if (!pIStateEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseXMLDocument = pIStateEnvironment->ParseXMLData(nXMLDataBufferSize, pXMLDataBuffer);

		*pXMLDocument = (IBase*)(pBaseXMLDocument);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for UIEnvironment
**************************************************************************************************************************/
LibMCEnvResult libmcenv_uienvironment_activatemodaldialog(LibMCEnv_UIEnvironment pUIEnvironment, const char * pDialogName)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pDialogName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sDialogName(pDialogName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->ActivateModalDialog(sDialogName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_closemodaldialog(LibMCEnv_UIEnvironment pUIEnvironment)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->CloseModalDialog();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_activatepage(LibMCEnv_UIEnvironment pUIEnvironment, const char * pPageName)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pPageName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sPageName(pPageName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->ActivatePage(sPageName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_logout(LibMCEnv_UIEnvironment pUIEnvironment)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->LogOut();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_showhint(LibMCEnv_UIEnvironment pUIEnvironment, const char * pHint, LibMCEnv_uint32 nTimeoutInMS)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pHint == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sHint(pHint);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->ShowHint(sHint, nTimeoutInMS);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_showhintcolored(LibMCEnv_UIEnvironment pUIEnvironment, const char * pHint, LibMCEnv_uint32 nTimeoutInMS, const sLibMCEnvColorRGB * pColor, const sLibMCEnvColorRGB * pFontColor)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pHint == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sHint(pHint);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->ShowHintColored(sHint, nTimeoutInMS, *pColor, *pFontColor);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_hidehint(LibMCEnv_UIEnvironment pUIEnvironment)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->HideHint();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_showmessagedlg(LibMCEnv_UIEnvironment pUIEnvironment, const char * pCaption, const char * pTitle, eLibMCEnvMessageDialogType eDialogType, const char * pYesEvent, const char * pNoEvent, const char * pCancelEvent, const LibMCEnv_uint32 nDialogUUIDBufferSize, LibMCEnv_uint32* pDialogUUIDNeededChars, char * pDialogUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pCaption == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pTitle == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pYesEvent == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pNoEvent == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pCancelEvent == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pDialogUUIDBuffer) && !(pDialogUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sCaption(pCaption);
		std::string sTitle(pTitle);
		std::string sYesEvent(pYesEvent);
		std::string sNoEvent(pNoEvent);
		std::string sCancelEvent(pCancelEvent);
		std::string sDialogUUID("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDialogUUIDBuffer == nullptr);
		if (isCacheCall) {
			sDialogUUID = pIUIEnvironment->ShowMessageDlg(sCaption, sTitle, eDialogType, sYesEvent, sNoEvent, sCancelEvent);

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sDialogUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sDialogUUID);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pDialogUUIDNeededChars)
			*pDialogUUIDNeededChars = (LibMCEnv_uint32) (sDialogUUID.size()+1);
		if (pDialogUUIDBuffer) {
			if (sDialogUUID.size() >= nDialogUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iDialogUUID = 0; iDialogUUID < sDialogUUID.size(); iDialogUUID++)
				pDialogUUIDBuffer[iDialogUUID] = sDialogUUID[iDialogUUID];
			pDialogUUIDBuffer[sDialogUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_retrieveeventsender(LibMCEnv_UIEnvironment pUIEnvironment, const LibMCEnv_uint32 nSenderNameBufferSize, LibMCEnv_uint32* pSenderNameNeededChars, char * pSenderNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if ( (!pSenderNameBuffer) && !(pSenderNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSenderName("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSenderNameBuffer == nullptr);
		if (isCacheCall) {
			sSenderName = pIUIEnvironment->RetrieveEventSender();

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sSenderName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSenderName);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pSenderNameNeededChars)
			*pSenderNameNeededChars = (LibMCEnv_uint32) (sSenderName.size()+1);
		if (pSenderNameBuffer) {
			if (sSenderName.size() >= nSenderNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSenderName = 0; iSenderName < sSenderName.size(); iSenderName++)
				pSenderNameBuffer[iSenderName] = sSenderName[iSenderName];
			pSenderNameBuffer[sSenderName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_retrieveeventsenderuuid(LibMCEnv_UIEnvironment pUIEnvironment, const LibMCEnv_uint32 nSenderUUIDBufferSize, LibMCEnv_uint32* pSenderUUIDNeededChars, char * pSenderUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if ( (!pSenderUUIDBuffer) && !(pSenderUUIDNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sSenderUUID("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSenderUUIDBuffer == nullptr);
		if (isCacheCall) {
			sSenderUUID = pIUIEnvironment->RetrieveEventSenderUUID();

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sSenderUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sSenderUUID);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pSenderUUIDNeededChars)
			*pSenderUUIDNeededChars = (LibMCEnv_uint32) (sSenderUUID.size()+1);
		if (pSenderUUIDBuffer) {
			if (sSenderUUID.size() >= nSenderUUIDBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iSenderUUID = 0; iSenderUUID < sSenderUUID.size(); iSenderUUID++)
				pSenderUUIDBuffer[iSenderUUID] = sSenderUUID[iSenderUUID];
			pSenderUUIDBuffer[sSenderUUID.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_preparesignal(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pSignalName, LibMCEnv_SignalTrigger * pSignalInstance)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSignalName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pSignalInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sSignalName(pSignalName);
		IBase* pBaseSignalInstance(nullptr);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseSignalInstance = pIUIEnvironment->PrepareSignal(sMachineInstance, sSignalName);

		*pSignalInstance = (IBase*)(pBaseSignalInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getmachinestate(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const LibMCEnv_uint32 nStateNameBufferSize, LibMCEnv_uint32* pStateNameNeededChars, char * pStateNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pStateNameBuffer) && !(pStateNameNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sStateName("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStateNameBuffer == nullptr);
		if (isCacheCall) {
			sStateName = pIUIEnvironment->GetMachineState(sMachineInstance);

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sStateName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sStateName);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pStateNameNeededChars)
			*pStateNameNeededChars = (LibMCEnv_uint32) (sStateName.size()+1);
		if (pStateNameBuffer) {
			if (sStateName.size() >= nStateNameBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iStateName = 0; iStateName < sStateName.size(); iStateName++)
				pStateNameBuffer[iStateName] = sStateName[iStateName];
			pStateNameBuffer[sStateName.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_logmessage(LibMCEnv_UIEnvironment pUIEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->LogMessage(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_logwarning(LibMCEnv_UIEnvironment pUIEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->LogWarning(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_loginfo(LibMCEnv_UIEnvironment pUIEnvironment, const char * pLogString)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pLogString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sLogString(pLogString);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->LogInfo(sLogString);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getmachineparameter(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIUIEnvironment->GetMachineParameter(sMachineInstance, sParameterGroup, sParameterName);

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getmachineparameterasuuid(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		std::string sValue("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIUIEnvironment->GetMachineParameterAsUUID(sMachineInstance, sParameterGroup, sParameterName);

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getmachineparameterasdouble(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIUIEnvironment->GetMachineParameterAsDouble(sMachineInstance, sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getmachineparameterasinteger(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIUIEnvironment->GetMachineParameterAsInteger(sMachineInstance, sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getmachineparameterasbool(LibMCEnv_UIEnvironment pUIEnvironment, const char * pMachineInstance, const char * pParameterGroup, const char * pParameterName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pMachineInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterGroup == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pParameterName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sMachineInstance(pMachineInstance);
		std::string sParameterGroup(pParameterGroup);
		std::string sParameterName(pParameterName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIUIEnvironment->GetMachineParameterAsBool(sMachineInstance, sParameterGroup, sParameterName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getuiproperty(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		std::string sValue("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIUIEnvironment->GetUIProperty(sElementPath, sPropertyName);

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getuipropertyasuuid(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, const LibMCEnv_uint32 nValueBufferSize, LibMCEnv_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		std::string sValue("");
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIUIEnvironment->GetUIPropertyAsUUID(sElementPath, sPropertyName);

			pIUIEnvironment->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIUIEnvironment->_getCache ());
			if (cache == nullptr)
				throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIUIEnvironment->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCEnv_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getuipropertyasdouble(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, LibMCEnv_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIUIEnvironment->GetUIPropertyAsDouble(sElementPath, sPropertyName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getuipropertyasinteger(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, LibMCEnv_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIUIEnvironment->GetUIPropertyAsInteger(sElementPath, sPropertyName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getuipropertyasbool(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pValue = pIUIEnvironment->GetUIPropertyAsBool(sElementPath, sPropertyName);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_setuiproperty(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		std::string sValue(pValue);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->SetUIProperty(sElementPath, sPropertyName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_setuipropertyasuuid(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		std::string sValue(pValue);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->SetUIPropertyAsUUID(sElementPath, sPropertyName, sValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_setuipropertyasdouble(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, LibMCEnv_double dValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->SetUIPropertyAsDouble(sElementPath, sPropertyName, dValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_setuipropertyasinteger(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, LibMCEnv_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->SetUIPropertyAsInteger(sElementPath, sPropertyName, nValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_setuipropertyasbool(LibMCEnv_UIEnvironment pUIEnvironment, const char * pElementPath, const char * pPropertyName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pElementPath == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pPropertyName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sElementPath(pElementPath);
		std::string sPropertyName(pPropertyName);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pIUIEnvironment->SetUIPropertyAsBool(sElementPath, sPropertyName, bValue);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_createemptyimage(LibMCEnv_UIEnvironment pUIEnvironment, LibMCEnv_uint32 nPixelSizeX, LibMCEnv_uint32 nPixelSizeY, LibMCEnv_double dDPIValueX, LibMCEnv_double dDPIValueY, eLibMCEnvImagePixelFormat ePixelFormat, LibMCEnv_ImageData * pImageDataInstance)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pImageDataInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseImageDataInstance(nullptr);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseImageDataInstance = pIUIEnvironment->CreateEmptyImage(nPixelSizeX, nPixelSizeY, dDPIValueX, dDPIValueY, ePixelFormat);

		*pImageDataInstance = (IBase*)(pBaseImageDataInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_loadpngimage(LibMCEnv_UIEnvironment pUIEnvironment, LibMCEnv_uint64 nPNGDataBufferSize, const LibMCEnv_uint8 * pPNGDataBuffer, LibMCEnv_double dDPIValueX, LibMCEnv_double dDPIValueY, eLibMCEnvImagePixelFormat ePixelFormat, LibMCEnv_ImageData * pImageDataInstance)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if ( (!pPNGDataBuffer) && (nPNGDataBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pImageDataInstance == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseImageDataInstance(nullptr);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseImageDataInstance = pIUIEnvironment->LoadPNGImage(nPNGDataBufferSize, pPNGDataBuffer, dDPIValueX, dDPIValueY, ePixelFormat);

		*pImageDataInstance = (IBase*)(pBaseImageDataInstance);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_getglobaltimerinmilliseconds(LibMCEnv_UIEnvironment pUIEnvironment, LibMCEnv_uint64 * pTimerValue)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pTimerValue == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		*pTimerValue = pIUIEnvironment->GetGlobalTimerInMilliseconds();

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_gettestenvironment(LibMCEnv_UIEnvironment pUIEnvironment, LibMCEnv_TestEnvironment * pTestEnvironment)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pTestEnvironment == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseTestEnvironment(nullptr);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseTestEnvironment = pIUIEnvironment->GetTestEnvironment();

		*pTestEnvironment = (IBase*)(pBaseTestEnvironment);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_createxmldocument(LibMCEnv_UIEnvironment pUIEnvironment, const char * pRootNodeName, const char * pDefaultNamespace, LibMCEnv_XMLDocument * pXMLDocument)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pRootNodeName == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pDefaultNamespace == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pXMLDocument == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sRootNodeName(pRootNodeName);
		std::string sDefaultNamespace(pDefaultNamespace);
		IBase* pBaseXMLDocument(nullptr);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseXMLDocument = pIUIEnvironment->CreateXMLDocument(sRootNodeName, sDefaultNamespace);

		*pXMLDocument = (IBase*)(pBaseXMLDocument);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_parsexmlstring(LibMCEnv_UIEnvironment pUIEnvironment, const char * pXMLString, LibMCEnv_XMLDocument * pXMLDocument)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if (pXMLString == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pXMLDocument == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		std::string sXMLString(pXMLString);
		IBase* pBaseXMLDocument(nullptr);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseXMLDocument = pIUIEnvironment->ParseXMLString(sXMLString);

		*pXMLDocument = (IBase*)(pBaseXMLDocument);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_uienvironment_parsexmldata(LibMCEnv_UIEnvironment pUIEnvironment, LibMCEnv_uint64 nXMLDataBufferSize, const LibMCEnv_uint8 * pXMLDataBuffer, LibMCEnv_XMLDocument * pXMLDocument)
{
	IBase* pIBaseClass = (IBase *)pUIEnvironment;

	try {
		if ( (!pXMLDataBuffer) && (nXMLDataBufferSize>0))
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pXMLDocument == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pBaseXMLDocument(nullptr);
		IUIEnvironment* pIUIEnvironment = dynamic_cast<IUIEnvironment*>(pIBaseClass);
		if (!pIUIEnvironment)
			throw ELibMCEnvInterfaceException(LIBMCENV_ERROR_INVALIDCAST);
		
		pBaseXMLDocument = pIUIEnvironment->ParseXMLData(nXMLDataBufferSize, pXMLDataBuffer);

		*pXMLDocument = (IBase*)(pBaseXMLDocument);
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCEnvResult LibMCEnv::Impl::LibMCEnv_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCENV_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCENV_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcenv_iterator_movenext") 
		*ppProcAddress = (void*) &libmcenv_iterator_movenext;
	if (sProcName == "libmcenv_iterator_moveprevious") 
		*ppProcAddress = (void*) &libmcenv_iterator_moveprevious;
	if (sProcName == "libmcenv_iterator_getcurrent") 
		*ppProcAddress = (void*) &libmcenv_iterator_getcurrent;
	if (sProcName == "libmcenv_iterator_clone") 
		*ppProcAddress = (void*) &libmcenv_iterator_clone;
	if (sProcName == "libmcenv_iterator_count") 
		*ppProcAddress = (void*) &libmcenv_iterator_count;
	if (sProcName == "libmcenv_testenvironment_writetestoutput") 
		*ppProcAddress = (void*) &libmcenv_testenvironment_writetestoutput;
	if (sProcName == "libmcenv_imagedata_getpixelformat") 
		*ppProcAddress = (void*) &libmcenv_imagedata_getpixelformat;
	if (sProcName == "libmcenv_imagedata_changepixelformat") 
		*ppProcAddress = (void*) &libmcenv_imagedata_changepixelformat;
	if (sProcName == "libmcenv_imagedata_getdpi") 
		*ppProcAddress = (void*) &libmcenv_imagedata_getdpi;
	if (sProcName == "libmcenv_imagedata_setdpi") 
		*ppProcAddress = (void*) &libmcenv_imagedata_setdpi;
	if (sProcName == "libmcenv_imagedata_getsizeinmm") 
		*ppProcAddress = (void*) &libmcenv_imagedata_getsizeinmm;
	if (sProcName == "libmcenv_imagedata_getsizeinpixels") 
		*ppProcAddress = (void*) &libmcenv_imagedata_getsizeinpixels;
	if (sProcName == "libmcenv_imagedata_resizeimage") 
		*ppProcAddress = (void*) &libmcenv_imagedata_resizeimage;
	if (sProcName == "libmcenv_imagedata_loadpng") 
		*ppProcAddress = (void*) &libmcenv_imagedata_loadpng;
	if (sProcName == "libmcenv_imagedata_encodepng") 
		*ppProcAddress = (void*) &libmcenv_imagedata_encodepng;
	if (sProcName == "libmcenv_imagedata_getencodedpngdata") 
		*ppProcAddress = (void*) &libmcenv_imagedata_getencodedpngdata;
	if (sProcName == "libmcenv_imagedata_clearencodedpngdata") 
		*ppProcAddress = (void*) &libmcenv_imagedata_clearencodedpngdata;
	if (sProcName == "libmcenv_imagedata_clear") 
		*ppProcAddress = (void*) &libmcenv_imagedata_clear;
	if (sProcName == "libmcenv_imagedata_getpixel") 
		*ppProcAddress = (void*) &libmcenv_imagedata_getpixel;
	if (sProcName == "libmcenv_imagedata_setpixel") 
		*ppProcAddress = (void*) &libmcenv_imagedata_setpixel;
	if (sProcName == "libmcenv_imagedata_getpixelrange") 
		*ppProcAddress = (void*) &libmcenv_imagedata_getpixelrange;
	if (sProcName == "libmcenv_imagedata_setpixelrange") 
		*ppProcAddress = (void*) &libmcenv_imagedata_setpixelrange;
	if (sProcName == "libmcenv_toolpathpart_getname") 
		*ppProcAddress = (void*) &libmcenv_toolpathpart_getname;
	if (sProcName == "libmcenv_toolpathpart_getuuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathpart_getuuid;
	if (sProcName == "libmcenv_toolpathpart_getmeshuuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathpart_getmeshuuid;
	if (sProcName == "libmcenv_toolpathpart_gettransform") 
		*ppProcAddress = (void*) &libmcenv_toolpathpart_gettransform;
	if (sProcName == "libmcenv_toolpathlayer_getlayerdatauuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getlayerdatauuid;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentcount") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentcount;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentinfo") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentinfo;
	if (sProcName == "libmcenv_toolpathlayer_getsegmenttype") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmenttype;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentpointcount") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentpointcount;
	if (sProcName == "libmcenv_toolpathlayer_getsegmenthatchcount") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmenthatchcount;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofileuuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofileuuid;
	if (sProcName == "libmcenv_toolpathlayer_segmentprofilehasvalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_segmentprofilehasvalue;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofilevalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofilevalue;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofilevaluedef") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofilevaluedef;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofiledoublevalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofiledoublevalue;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofiledoublevaluedef") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofiledoublevaluedef;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofileintegervalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofileintegervalue;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofileintegervaluedef") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofileintegervaluedef;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofileboolvalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofileboolvalue;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofileboolvaluedef") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofileboolvaluedef;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofiletypedvalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofiletypedvalue;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentprofiletypedvaluedef") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentprofiletypedvaluedef;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentpartuuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentpartuuid;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentpointdata") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentpointdata;
	if (sProcName == "libmcenv_toolpathlayer_getsegmenthatchdata") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmenthatchdata;
	if (sProcName == "libmcenv_toolpathlayer_getsegmentpointdatainmm") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmentpointdatainmm;
	if (sProcName == "libmcenv_toolpathlayer_getsegmenthatchdatainmm") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getsegmenthatchdatainmm;
	if (sProcName == "libmcenv_toolpathlayer_getzvalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getzvalue;
	if (sProcName == "libmcenv_toolpathlayer_getzvalueinmm") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getzvalueinmm;
	if (sProcName == "libmcenv_toolpathlayer_getunits") 
		*ppProcAddress = (void*) &libmcenv_toolpathlayer_getunits;
	if (sProcName == "libmcenv_toolpathaccessor_getstorageuuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getstorageuuid;
	if (sProcName == "libmcenv_toolpathaccessor_getlayercount") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getlayercount;
	if (sProcName == "libmcenv_toolpathaccessor_loadlayer") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_loadlayer;
	if (sProcName == "libmcenv_toolpathaccessor_getunits") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getunits;
	if (sProcName == "libmcenv_toolpathaccessor_hasmetadata") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_hasmetadata;
	if (sProcName == "libmcenv_toolpathaccessor_getmetadatavalue") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getmetadatavalue;
	if (sProcName == "libmcenv_toolpathaccessor_getmetadatatype") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getmetadatatype;
	if (sProcName == "libmcenv_toolpathaccessor_getpartcount") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getpartcount;
	if (sProcName == "libmcenv_toolpathaccessor_getpart") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getpart;
	if (sProcName == "libmcenv_toolpathaccessor_findpartbyuuid") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_findpartbyuuid;
	if (sProcName == "libmcenv_toolpathaccessor_getbuildheightinunits") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getbuildheightinunits;
	if (sProcName == "libmcenv_toolpathaccessor_getzvalueinunits") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getzvalueinunits;
	if (sProcName == "libmcenv_toolpathaccessor_getbuildheightinmm") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getbuildheightinmm;
	if (sProcName == "libmcenv_toolpathaccessor_getzvalueinmm") 
		*ppProcAddress = (void*) &libmcenv_toolpathaccessor_getzvalueinmm;
	if (sProcName == "libmcenv_build_getname") 
		*ppProcAddress = (void*) &libmcenv_build_getname;
	if (sProcName == "libmcenv_build_getbuilduuid") 
		*ppProcAddress = (void*) &libmcenv_build_getbuilduuid;
	if (sProcName == "libmcenv_build_getstorageuuid") 
		*ppProcAddress = (void*) &libmcenv_build_getstorageuuid;
	if (sProcName == "libmcenv_build_getstoragesha256") 
		*ppProcAddress = (void*) &libmcenv_build_getstoragesha256;
	if (sProcName == "libmcenv_build_getlayercount") 
		*ppProcAddress = (void*) &libmcenv_build_getlayercount;
	if (sProcName == "libmcenv_build_getbuildheightinmm") 
		*ppProcAddress = (void*) &libmcenv_build_getbuildheightinmm;
	if (sProcName == "libmcenv_build_getzvalueinmm") 
		*ppProcAddress = (void*) &libmcenv_build_getzvalueinmm;
	if (sProcName == "libmcenv_build_loadtoolpath") 
		*ppProcAddress = (void*) &libmcenv_build_loadtoolpath;
	if (sProcName == "libmcenv_build_unloadtoolpath") 
		*ppProcAddress = (void*) &libmcenv_build_unloadtoolpath;
	if (sProcName == "libmcenv_build_toolpathisloaded") 
		*ppProcAddress = (void*) &libmcenv_build_toolpathisloaded;
	if (sProcName == "libmcenv_build_createtoolpathaccessor") 
		*ppProcAddress = (void*) &libmcenv_build_createtoolpathaccessor;
	if (sProcName == "libmcenv_build_addbinarydata") 
		*ppProcAddress = (void*) &libmcenv_build_addbinarydata;
	if (sProcName == "libmcenv_workingfileexecution_getstatus") 
		*ppProcAddress = (void*) &libmcenv_workingfileexecution_getstatus;
	if (sProcName == "libmcenv_workingfileexecution_returnstdout") 
		*ppProcAddress = (void*) &libmcenv_workingfileexecution_returnstdout;
	if (sProcName == "libmcenv_workingfile_getabsolutefilename") 
		*ppProcAddress = (void*) &libmcenv_workingfile_getabsolutefilename;
	if (sProcName == "libmcenv_workingfile_getsize") 
		*ppProcAddress = (void*) &libmcenv_workingfile_getsize;
	if (sProcName == "libmcenv_workingfile_calculatesha2") 
		*ppProcAddress = (void*) &libmcenv_workingfile_calculatesha2;
	if (sProcName == "libmcenv_workingfile_executefile") 
		*ppProcAddress = (void*) &libmcenv_workingfile_executefile;
	if (sProcName == "libmcenv_workingfile_ismanaged") 
		*ppProcAddress = (void*) &libmcenv_workingfile_ismanaged;
	if (sProcName == "libmcenv_workingfile_makemanaged") 
		*ppProcAddress = (void*) &libmcenv_workingfile_makemanaged;
	if (sProcName == "libmcenv_workingfile_fileexists") 
		*ppProcAddress = (void*) &libmcenv_workingfile_fileexists;
	if (sProcName == "libmcenv_workingfile_deletefromdisk") 
		*ppProcAddress = (void*) &libmcenv_workingfile_deletefromdisk;
	if (sProcName == "libmcenv_workingfileiterator_getcurrentfile") 
		*ppProcAddress = (void*) &libmcenv_workingfileiterator_getcurrentfile;
	if (sProcName == "libmcenv_workingdirectory_isactive") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_isactive;
	if (sProcName == "libmcenv_workingdirectory_getabsolutefilepath") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_getabsolutefilepath;
	if (sProcName == "libmcenv_workingdirectory_storecustomdata") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_storecustomdata;
	if (sProcName == "libmcenv_workingdirectory_storecustomstring") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_storecustomstring;
	if (sProcName == "libmcenv_workingdirectory_storedriverdata") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_storedriverdata;
	if (sProcName == "libmcenv_workingdirectory_storecustomdataintempfile") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_storecustomdataintempfile;
	if (sProcName == "libmcenv_workingdirectory_storecustomstringintempfile") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_storecustomstringintempfile;
	if (sProcName == "libmcenv_workingdirectory_storedriverdataintempfile") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_storedriverdataintempfile;
	if (sProcName == "libmcenv_workingdirectory_cleanup") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_cleanup;
	if (sProcName == "libmcenv_workingdirectory_addmanagedfile") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_addmanagedfile;
	if (sProcName == "libmcenv_workingdirectory_hasunmanagedfiles") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_hasunmanagedfiles;
	if (sProcName == "libmcenv_workingdirectory_retrieveunmanagedfiles") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_retrieveunmanagedfiles;
	if (sProcName == "libmcenv_workingdirectory_retrievemanagedfiles") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_retrievemanagedfiles;
	if (sProcName == "libmcenv_workingdirectory_retrieveallfiles") 
		*ppProcAddress = (void*) &libmcenv_workingdirectory_retrieveallfiles;
	if (sProcName == "libmcenv_xmldocumentattribute_getnamespace") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_getnamespace;
	if (sProcName == "libmcenv_xmldocumentattribute_getname") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_getname;
	if (sProcName == "libmcenv_xmldocumentattribute_getvalue") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_getvalue;
	if (sProcName == "libmcenv_xmldocumentattribute_isvalidinteger") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_isvalidinteger;
	if (sProcName == "libmcenv_xmldocumentattribute_getintegervalue") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_getintegervalue;
	if (sProcName == "libmcenv_xmldocumentattribute_isvaliddouble") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_isvaliddouble;
	if (sProcName == "libmcenv_xmldocumentattribute_getdoublevalue") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_getdoublevalue;
	if (sProcName == "libmcenv_xmldocumentattribute_isvalidbool") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_isvalidbool;
	if (sProcName == "libmcenv_xmldocumentattribute_getboolvalue") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_getboolvalue;
	if (sProcName == "libmcenv_xmldocumentattribute_setvalue") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_setvalue;
	if (sProcName == "libmcenv_xmldocumentattribute_setintegervalue") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_setintegervalue;
	if (sProcName == "libmcenv_xmldocumentattribute_setdoublevalue") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_setdoublevalue;
	if (sProcName == "libmcenv_xmldocumentattribute_setboolvalue") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_setboolvalue;
	if (sProcName == "libmcenv_xmldocumentattribute_remove") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentattribute_remove;
	if (sProcName == "libmcenv_xmldocumentnode_getname") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_getname;
	if (sProcName == "libmcenv_xmldocumentnode_getnamespace") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_getnamespace;
	if (sProcName == "libmcenv_xmldocumentnode_getattributecount") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_getattributecount;
	if (sProcName == "libmcenv_xmldocumentnode_getattribute") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_getattribute;
	if (sProcName == "libmcenv_xmldocumentnode_hasattribute") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_hasattribute;
	if (sProcName == "libmcenv_xmldocumentnode_findattribute") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_findattribute;
	if (sProcName == "libmcenv_xmldocumentnode_removeattribute") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_removeattribute;
	if (sProcName == "libmcenv_xmldocumentnode_removeattributebyindex") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_removeattributebyindex;
	if (sProcName == "libmcenv_xmldocumentnode_addattribute") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_addattribute;
	if (sProcName == "libmcenv_xmldocumentnode_addintegerattribute") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_addintegerattribute;
	if (sProcName == "libmcenv_xmldocumentnode_adddoubleattribute") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_adddoubleattribute;
	if (sProcName == "libmcenv_xmldocumentnode_addboolattribute") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_addboolattribute;
	if (sProcName == "libmcenv_xmldocumentnode_getchildren") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_getchildren;
	if (sProcName == "libmcenv_xmldocumentnode_countchildrenbyname") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_countchildrenbyname;
	if (sProcName == "libmcenv_xmldocumentnode_getchildrenbyname") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_getchildrenbyname;
	if (sProcName == "libmcenv_xmldocumentnode_haschild") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_haschild;
	if (sProcName == "libmcenv_xmldocumentnode_hasuniquechild") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_hasuniquechild;
	if (sProcName == "libmcenv_xmldocumentnode_findchild") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_findchild;
	if (sProcName == "libmcenv_xmldocumentnode_addchild") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_addchild;
	if (sProcName == "libmcenv_xmldocumentnode_removechild") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_removechild;
	if (sProcName == "libmcenv_xmldocumentnode_removechildrenwithname") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_removechildrenwithname;
	if (sProcName == "libmcenv_xmldocumentnode_remove") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnode_remove;
	if (sProcName == "libmcenv_xmldocumentnodes_getnodecount") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnodes_getnodecount;
	if (sProcName == "libmcenv_xmldocumentnodes_getnode") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnodes_getnode;
	if (sProcName == "libmcenv_xmldocumentnodes_countnodesbyname") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnodes_countnodesbyname;
	if (sProcName == "libmcenv_xmldocumentnodes_getnodesbyname") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnodes_getnodesbyname;
	if (sProcName == "libmcenv_xmldocumentnodes_hasnode") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnodes_hasnode;
	if (sProcName == "libmcenv_xmldocumentnodes_hasuniquenode") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnodes_hasuniquenode;
	if (sProcName == "libmcenv_xmldocumentnodes_findnode") 
		*ppProcAddress = (void*) &libmcenv_xmldocumentnodes_findnode;
	if (sProcName == "libmcenv_xmldocument_getdefaultnamespace") 
		*ppProcAddress = (void*) &libmcenv_xmldocument_getdefaultnamespace;
	if (sProcName == "libmcenv_xmldocument_getnamespacecount") 
		*ppProcAddress = (void*) &libmcenv_xmldocument_getnamespacecount;
	if (sProcName == "libmcenv_xmldocument_getnamespace") 
		*ppProcAddress = (void*) &libmcenv_xmldocument_getnamespace;
	if (sProcName == "libmcenv_xmldocument_hasnamespace") 
		*ppProcAddress = (void*) &libmcenv_xmldocument_hasnamespace;
	if (sProcName == "libmcenv_xmldocument_getnamespaceprefix") 
		*ppProcAddress = (void*) &libmcenv_xmldocument_getnamespaceprefix;
	if (sProcName == "libmcenv_xmldocument_registernamespace") 
		*ppProcAddress = (void*) &libmcenv_xmldocument_registernamespace;
	if (sProcName == "libmcenv_xmldocument_getrootnode") 
		*ppProcAddress = (void*) &libmcenv_xmldocument_getrootnode;
	if (sProcName == "libmcenv_xmldocument_savetostring") 
		*ppProcAddress = (void*) &libmcenv_xmldocument_savetostring;
	if (sProcName == "libmcenv_tcpippacket_isempty") 
		*ppProcAddress = (void*) &libmcenv_tcpippacket_isempty;
	if (sProcName == "libmcenv_tcpippacket_getsize") 
		*ppProcAddress = (void*) &libmcenv_tcpippacket_getsize;
	if (sProcName == "libmcenv_tcpippacket_getdata") 
		*ppProcAddress = (void*) &libmcenv_tcpippacket_getdata;
	if (sProcName == "libmcenv_tcpipconnection_getipaddress") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_getipaddress;
	if (sProcName == "libmcenv_tcpipconnection_getport") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_getport;
	if (sProcName == "libmcenv_tcpipconnection_gettimeout") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_gettimeout;
	if (sProcName == "libmcenv_tcpipconnection_isconnected") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_isconnected;
	if (sProcName == "libmcenv_tcpipconnection_disconnect") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_disconnect;
	if (sProcName == "libmcenv_tcpipconnection_reconnect") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_reconnect;
	if (sProcName == "libmcenv_tcpipconnection_sendbuffer") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_sendbuffer;
	if (sProcName == "libmcenv_tcpipconnection_waitfordata") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_waitfordata;
	if (sProcName == "libmcenv_tcpipconnection_receivefixedpacket") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_receivefixedpacket;
	if (sProcName == "libmcenv_tcpipconnection_receivedata") 
		*ppProcAddress = (void*) &libmcenv_tcpipconnection_receivedata;
	if (sProcName == "libmcenv_modbustcpdigitaliostatus_getcount") 
		*ppProcAddress = (void*) &libmcenv_modbustcpdigitaliostatus_getcount;
	if (sProcName == "libmcenv_modbustcpdigitaliostatus_getbaseaddress") 
		*ppProcAddress = (void*) &libmcenv_modbustcpdigitaliostatus_getbaseaddress;
	if (sProcName == "libmcenv_modbustcpdigitaliostatus_getvalue") 
		*ppProcAddress = (void*) &libmcenv_modbustcpdigitaliostatus_getvalue;
	if (sProcName == "libmcenv_modbustcpdigitaliostatus_getvalues") 
		*ppProcAddress = (void*) &libmcenv_modbustcpdigitaliostatus_getvalues;
	if (sProcName == "libmcenv_modbustcpregisterstatus_getcount") 
		*ppProcAddress = (void*) &libmcenv_modbustcpregisterstatus_getcount;
	if (sProcName == "libmcenv_modbustcpregisterstatus_getbaseaddress") 
		*ppProcAddress = (void*) &libmcenv_modbustcpregisterstatus_getbaseaddress;
	if (sProcName == "libmcenv_modbustcpregisterstatus_getvalue") 
		*ppProcAddress = (void*) &libmcenv_modbustcpregisterstatus_getvalue;
	if (sProcName == "libmcenv_modbustcpregisterstatus_getvalues") 
		*ppProcAddress = (void*) &libmcenv_modbustcpregisterstatus_getvalues;
	if (sProcName == "libmcenv_modbustcpconnection_getipaddress") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_getipaddress;
	if (sProcName == "libmcenv_modbustcpconnection_getport") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_getport;
	if (sProcName == "libmcenv_modbustcpconnection_gettimeout") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_gettimeout;
	if (sProcName == "libmcenv_modbustcpconnection_isconnected") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_isconnected;
	if (sProcName == "libmcenv_modbustcpconnection_disconnect") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_disconnect;
	if (sProcName == "libmcenv_modbustcpconnection_reconnect") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_reconnect;
	if (sProcName == "libmcenv_modbustcpconnection_diagnosiscall") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_diagnosiscall;
	if (sProcName == "libmcenv_modbustcpconnection_readcoilstatus") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_readcoilstatus;
	if (sProcName == "libmcenv_modbustcpconnection_readinputstatus") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_readinputstatus;
	if (sProcName == "libmcenv_modbustcpconnection_readholdingregisters") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_readholdingregisters;
	if (sProcName == "libmcenv_modbustcpconnection_readinputregisters") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_readinputregisters;
	if (sProcName == "libmcenv_modbustcpconnection_forcemultiplecoils") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_forcemultiplecoils;
	if (sProcName == "libmcenv_modbustcpconnection_presetmultipleregisters") 
		*ppProcAddress = (void*) &libmcenv_modbustcpconnection_presetmultipleregisters;
	if (sProcName == "libmcenv_driverstatusupdatesession_setstringparameter") 
		*ppProcAddress = (void*) &libmcenv_driverstatusupdatesession_setstringparameter;
	if (sProcName == "libmcenv_driverstatusupdatesession_setuuidparameter") 
		*ppProcAddress = (void*) &libmcenv_driverstatusupdatesession_setuuidparameter;
	if (sProcName == "libmcenv_driverstatusupdatesession_setdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_driverstatusupdatesession_setdoubleparameter;
	if (sProcName == "libmcenv_driverstatusupdatesession_setintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_driverstatusupdatesession_setintegerparameter;
	if (sProcName == "libmcenv_driverstatusupdatesession_setboolparameter") 
		*ppProcAddress = (void*) &libmcenv_driverstatusupdatesession_setboolparameter;
	if (sProcName == "libmcenv_driverstatusupdatesession_logmessage") 
		*ppProcAddress = (void*) &libmcenv_driverstatusupdatesession_logmessage;
	if (sProcName == "libmcenv_driverstatusupdatesession_logwarning") 
		*ppProcAddress = (void*) &libmcenv_driverstatusupdatesession_logwarning;
	if (sProcName == "libmcenv_driverstatusupdatesession_loginfo") 
		*ppProcAddress = (void*) &libmcenv_driverstatusupdatesession_loginfo;
	if (sProcName == "libmcenv_driverstatusupdatesession_sleep") 
		*ppProcAddress = (void*) &libmcenv_driverstatusupdatesession_sleep;
	if (sProcName == "libmcenv_driverenvironment_createstatusupdatesession") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_createstatusupdatesession;
	if (sProcName == "libmcenv_driverenvironment_createworkingdirectory") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_createworkingdirectory;
	if (sProcName == "libmcenv_driverenvironment_createtcpipconnection") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_createtcpipconnection;
	if (sProcName == "libmcenv_driverenvironment_createmodbustcpconnection") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_createmodbustcpconnection;
	if (sProcName == "libmcenv_driverenvironment_createxmldocument") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_createxmldocument;
	if (sProcName == "libmcenv_driverenvironment_parsexmlstring") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_parsexmlstring;
	if (sProcName == "libmcenv_driverenvironment_parsexmldata") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_parsexmldata;
	if (sProcName == "libmcenv_driverenvironment_driverhasresourcedata") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_driverhasresourcedata;
	if (sProcName == "libmcenv_driverenvironment_machinehasresourcedata") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_machinehasresourcedata;
	if (sProcName == "libmcenv_driverenvironment_retrievedriverdata") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_retrievedriverdata;
	if (sProcName == "libmcenv_driverenvironment_retrievedriverresourcedata") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_retrievedriverresourcedata;
	if (sProcName == "libmcenv_driverenvironment_retrievemachineresourcedata") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_retrievemachineresourcedata;
	if (sProcName == "libmcenv_driverenvironment_createtoolpathaccessor") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_createtoolpathaccessor;
	if (sProcName == "libmcenv_driverenvironment_parameternameisvalid") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_parameternameisvalid;
	if (sProcName == "libmcenv_driverenvironment_registerstringparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registerstringparameter;
	if (sProcName == "libmcenv_driverenvironment_registeruuidparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registeruuidparameter;
	if (sProcName == "libmcenv_driverenvironment_registerdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registerdoubleparameter;
	if (sProcName == "libmcenv_driverenvironment_registerintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registerintegerparameter;
	if (sProcName == "libmcenv_driverenvironment_registerboolparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_registerboolparameter;
	if (sProcName == "libmcenv_driverenvironment_setstringparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setstringparameter;
	if (sProcName == "libmcenv_driverenvironment_setuuidparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setuuidparameter;
	if (sProcName == "libmcenv_driverenvironment_setdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setdoubleparameter;
	if (sProcName == "libmcenv_driverenvironment_setintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setintegerparameter;
	if (sProcName == "libmcenv_driverenvironment_setboolparameter") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_setboolparameter;
	if (sProcName == "libmcenv_driverenvironment_sleep") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_sleep;
	if (sProcName == "libmcenv_driverenvironment_getglobaltimerinmilliseconds") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_getglobaltimerinmilliseconds;
	if (sProcName == "libmcenv_driverenvironment_logmessage") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_logmessage;
	if (sProcName == "libmcenv_driverenvironment_logwarning") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_logwarning;
	if (sProcName == "libmcenv_driverenvironment_loginfo") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_loginfo;
	if (sProcName == "libmcenv_driverenvironment_createemptyimage") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_createemptyimage;
	if (sProcName == "libmcenv_driverenvironment_loadpngimage") 
		*ppProcAddress = (void*) &libmcenv_driverenvironment_loadpngimage;
	if (sProcName == "libmcenv_signaltrigger_cantrigger") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_cantrigger;
	if (sProcName == "libmcenv_signaltrigger_trigger") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_trigger;
	if (sProcName == "libmcenv_signaltrigger_waitforhandling") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_waitforhandling;
	if (sProcName == "libmcenv_signaltrigger_getname") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getname;
	if (sProcName == "libmcenv_signaltrigger_getstatemachine") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getstatemachine;
	if (sProcName == "libmcenv_signaltrigger_setstring") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setstring;
	if (sProcName == "libmcenv_signaltrigger_setuuid") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setuuid;
	if (sProcName == "libmcenv_signaltrigger_setdouble") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setdouble;
	if (sProcName == "libmcenv_signaltrigger_setinteger") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setinteger;
	if (sProcName == "libmcenv_signaltrigger_setbool") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_setbool;
	if (sProcName == "libmcenv_signaltrigger_getstringresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getstringresult;
	if (sProcName == "libmcenv_signaltrigger_getuuidresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getuuidresult;
	if (sProcName == "libmcenv_signaltrigger_getdoubleresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getdoubleresult;
	if (sProcName == "libmcenv_signaltrigger_getintegerresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getintegerresult;
	if (sProcName == "libmcenv_signaltrigger_getboolresult") 
		*ppProcAddress = (void*) &libmcenv_signaltrigger_getboolresult;
	if (sProcName == "libmcenv_signalhandler_signalhandled") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_signalhandled;
	if (sProcName == "libmcenv_signalhandler_getname") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getname;
	if (sProcName == "libmcenv_signalhandler_getsignalid") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getsignalid;
	if (sProcName == "libmcenv_signalhandler_getsignaluuid") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getsignaluuid;
	if (sProcName == "libmcenv_signalhandler_getstatemachine") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getstatemachine;
	if (sProcName == "libmcenv_signalhandler_getstring") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getstring;
	if (sProcName == "libmcenv_signalhandler_getuuid") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getuuid;
	if (sProcName == "libmcenv_signalhandler_getdouble") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getdouble;
	if (sProcName == "libmcenv_signalhandler_getinteger") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getinteger;
	if (sProcName == "libmcenv_signalhandler_getbool") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_getbool;
	if (sProcName == "libmcenv_signalhandler_setstringresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setstringresult;
	if (sProcName == "libmcenv_signalhandler_setuuidresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setuuidresult;
	if (sProcName == "libmcenv_signalhandler_setdoubleresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setdoubleresult;
	if (sProcName == "libmcenv_signalhandler_setintegerresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setintegerresult;
	if (sProcName == "libmcenv_signalhandler_setboolresult") 
		*ppProcAddress = (void*) &libmcenv_signalhandler_setboolresult;
	if (sProcName == "libmcenv_stateenvironment_getmachinestate") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getmachinestate;
	if (sProcName == "libmcenv_stateenvironment_preparesignal") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_preparesignal;
	if (sProcName == "libmcenv_stateenvironment_waitforsignal") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_waitforsignal;
	if (sProcName == "libmcenv_stateenvironment_getunhandledsignal") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getunhandledsignal;
	if (sProcName == "libmcenv_stateenvironment_getunhandledsignalbyuuid") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getunhandledsignalbyuuid;
	if (sProcName == "libmcenv_stateenvironment_getdriverlibrary") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getdriverlibrary;
	if (sProcName == "libmcenv_stateenvironment_createdriveraccess") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_createdriveraccess;
	if (sProcName == "libmcenv_stateenvironment_getbuildjob") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getbuildjob;
	if (sProcName == "libmcenv_stateenvironment_unloadalltoolpathes") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_unloadalltoolpathes;
	if (sProcName == "libmcenv_stateenvironment_setnextstate") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setnextstate;
	if (sProcName == "libmcenv_stateenvironment_logmessage") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_logmessage;
	if (sProcName == "libmcenv_stateenvironment_logwarning") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_logwarning;
	if (sProcName == "libmcenv_stateenvironment_loginfo") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_loginfo;
	if (sProcName == "libmcenv_stateenvironment_sleep") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_sleep;
	if (sProcName == "libmcenv_stateenvironment_checkfortermination") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_checkfortermination;
	if (sProcName == "libmcenv_stateenvironment_storesignal") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_storesignal;
	if (sProcName == "libmcenv_stateenvironment_retrievesignal") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_retrievesignal;
	if (sProcName == "libmcenv_stateenvironment_clearstoredvalue") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_clearstoredvalue;
	if (sProcName == "libmcenv_stateenvironment_setstringparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setstringparameter;
	if (sProcName == "libmcenv_stateenvironment_setuuidparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setuuidparameter;
	if (sProcName == "libmcenv_stateenvironment_setdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setdoubleparameter;
	if (sProcName == "libmcenv_stateenvironment_setintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setintegerparameter;
	if (sProcName == "libmcenv_stateenvironment_setboolparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_setboolparameter;
	if (sProcName == "libmcenv_stateenvironment_getstringparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getstringparameter;
	if (sProcName == "libmcenv_stateenvironment_getuuidparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getuuidparameter;
	if (sProcName == "libmcenv_stateenvironment_getdoubleparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getdoubleparameter;
	if (sProcName == "libmcenv_stateenvironment_getintegerparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getintegerparameter;
	if (sProcName == "libmcenv_stateenvironment_getboolparameter") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getboolparameter;
	if (sProcName == "libmcenv_stateenvironment_loadresourcedata") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_loadresourcedata;
	if (sProcName == "libmcenv_stateenvironment_loadresourcestring") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_loadresourcestring;
	if (sProcName == "libmcenv_stateenvironment_createemptyimage") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_createemptyimage;
	if (sProcName == "libmcenv_stateenvironment_loadpngimage") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_loadpngimage;
	if (sProcName == "libmcenv_stateenvironment_getglobaltimerinmilliseconds") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_getglobaltimerinmilliseconds;
	if (sProcName == "libmcenv_stateenvironment_gettestenvironment") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_gettestenvironment;
	if (sProcName == "libmcenv_stateenvironment_createxmldocument") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_createxmldocument;
	if (sProcName == "libmcenv_stateenvironment_parsexmlstring") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_parsexmlstring;
	if (sProcName == "libmcenv_stateenvironment_parsexmldata") 
		*ppProcAddress = (void*) &libmcenv_stateenvironment_parsexmldata;
	if (sProcName == "libmcenv_uienvironment_activatemodaldialog") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_activatemodaldialog;
	if (sProcName == "libmcenv_uienvironment_closemodaldialog") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_closemodaldialog;
	if (sProcName == "libmcenv_uienvironment_activatepage") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_activatepage;
	if (sProcName == "libmcenv_uienvironment_logout") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_logout;
	if (sProcName == "libmcenv_uienvironment_showhint") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_showhint;
	if (sProcName == "libmcenv_uienvironment_showhintcolored") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_showhintcolored;
	if (sProcName == "libmcenv_uienvironment_hidehint") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_hidehint;
	if (sProcName == "libmcenv_uienvironment_showmessagedlg") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_showmessagedlg;
	if (sProcName == "libmcenv_uienvironment_retrieveeventsender") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_retrieveeventsender;
	if (sProcName == "libmcenv_uienvironment_retrieveeventsenderuuid") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_retrieveeventsenderuuid;
	if (sProcName == "libmcenv_uienvironment_preparesignal") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_preparesignal;
	if (sProcName == "libmcenv_uienvironment_getmachinestate") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getmachinestate;
	if (sProcName == "libmcenv_uienvironment_logmessage") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_logmessage;
	if (sProcName == "libmcenv_uienvironment_logwarning") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_logwarning;
	if (sProcName == "libmcenv_uienvironment_loginfo") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_loginfo;
	if (sProcName == "libmcenv_uienvironment_getmachineparameter") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getmachineparameter;
	if (sProcName == "libmcenv_uienvironment_getmachineparameterasuuid") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getmachineparameterasuuid;
	if (sProcName == "libmcenv_uienvironment_getmachineparameterasdouble") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getmachineparameterasdouble;
	if (sProcName == "libmcenv_uienvironment_getmachineparameterasinteger") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getmachineparameterasinteger;
	if (sProcName == "libmcenv_uienvironment_getmachineparameterasbool") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getmachineparameterasbool;
	if (sProcName == "libmcenv_uienvironment_getuiproperty") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getuiproperty;
	if (sProcName == "libmcenv_uienvironment_getuipropertyasuuid") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getuipropertyasuuid;
	if (sProcName == "libmcenv_uienvironment_getuipropertyasdouble") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getuipropertyasdouble;
	if (sProcName == "libmcenv_uienvironment_getuipropertyasinteger") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getuipropertyasinteger;
	if (sProcName == "libmcenv_uienvironment_getuipropertyasbool") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getuipropertyasbool;
	if (sProcName == "libmcenv_uienvironment_setuiproperty") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_setuiproperty;
	if (sProcName == "libmcenv_uienvironment_setuipropertyasuuid") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_setuipropertyasuuid;
	if (sProcName == "libmcenv_uienvironment_setuipropertyasdouble") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_setuipropertyasdouble;
	if (sProcName == "libmcenv_uienvironment_setuipropertyasinteger") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_setuipropertyasinteger;
	if (sProcName == "libmcenv_uienvironment_setuipropertyasbool") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_setuipropertyasbool;
	if (sProcName == "libmcenv_uienvironment_createemptyimage") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_createemptyimage;
	if (sProcName == "libmcenv_uienvironment_loadpngimage") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_loadpngimage;
	if (sProcName == "libmcenv_uienvironment_getglobaltimerinmilliseconds") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_getglobaltimerinmilliseconds;
	if (sProcName == "libmcenv_uienvironment_gettestenvironment") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_gettestenvironment;
	if (sProcName == "libmcenv_uienvironment_createxmldocument") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_createxmldocument;
	if (sProcName == "libmcenv_uienvironment_parsexmlstring") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_parsexmlstring;
	if (sProcName == "libmcenv_uienvironment_parsexmldata") 
		*ppProcAddress = (void*) &libmcenv_uienvironment_parsexmldata;
	if (sProcName == "libmcenv_getversion") 
		*ppProcAddress = (void*) &libmcenv_getversion;
	if (sProcName == "libmcenv_getlasterror") 
		*ppProcAddress = (void*) &libmcenv_getlasterror;
	if (sProcName == "libmcenv_releaseinstance") 
		*ppProcAddress = (void*) &libmcenv_releaseinstance;
	if (sProcName == "libmcenv_acquireinstance") 
		*ppProcAddress = (void*) &libmcenv_acquireinstance;
	if (sProcName == "libmcenv_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcenv_getsymbollookupmethod;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCENV_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCEnvResult libmcenv_getversion(LibMCEnv_uint32 * pMajor, LibMCEnv_uint32 * pMinor, LibMCEnv_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_getlasterror(LibMCEnv_Base pInstance, const LibMCEnv_uint32 nErrorMessageBufferSize, LibMCEnv_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCEnv_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_releaseinstance(LibMCEnv_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_acquireinstance(LibMCEnv_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCEnvResult libmcenv_getsymbollookupmethod(LibMCEnv_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCEnvInterfaceException (LIBMCENV_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCEnv::Impl::LibMCEnv_GetProcAddress;
		return LIBMCENV_SUCCESS;
	}
	catch (ELibMCEnvInterfaceException & Exception) {
		return handleLibMCEnvException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


