/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Machine Control data model library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmcdata_abi.hpp"
#include "libmcdata_interfaces.hpp"
#include "libmcdata_interfaceexception.hpp"

#include <map>

using namespace LibMCData::Impl;

LibMCDataResult handleLibMCDataException(IBase * pIBaseClass, ELibMCDataInterfaceException & Exception)
{
	LibMCDataResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDataResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDataResult errorCode = LIBMCDATA_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDataResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDataResult errorCode = LIBMCDATA_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Iterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_iterator_movenext(LibMCData_Iterator pIterator, bool * pHasNext)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasNext == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pHasNext = pIIterator->MoveNext();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_moveprevious(LibMCData_Iterator pIterator, bool * pHasPrevious)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasPrevious == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pHasPrevious = pIIterator->MovePrevious();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_getcurrent(LibMCData_Iterator pIterator, LibMCData_Base * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIIterator->GetCurrent();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_clone(LibMCData_Iterator pIterator, LibMCData_Iterator * pOutIterator)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pOutIterator == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseOutIterator(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseOutIterator = pIIterator->Clone();

		*pOutIterator = (IBase*)(pBaseOutIterator);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_count(LibMCData_Iterator pIterator, LibMCData_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pCount == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pCount = pIIterator->Count();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for LogEntryList
**************************************************************************************************************************/
LibMCDataResult libmcdata_logentrylist_count(LibMCData_LogEntryList pLogEntryList, LibMCData_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pLogEntryList;

	try {
		if (pCount == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		ILogEntryList* pILogEntryList = dynamic_cast<ILogEntryList*>(pIBaseClass);
		if (!pILogEntryList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pCount = pILogEntryList->Count();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logentrylist_getentrybyindex(LibMCData_LogEntryList pLogEntryList, LibMCData_uint32 nIndex, LibMCData_uint32 * pID, const LibMCData_uint32 nMessageBufferSize, LibMCData_uint32* pMessageNeededChars, char * pMessageBuffer, const LibMCData_uint32 nSubSystemBufferSize, LibMCData_uint32* pSubSystemNeededChars, char * pSubSystemBuffer, eLibMCDataLogLevel * pLogLevel, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pLogEntryList;

	try {
		if (!pID)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pMessageBuffer) && !(pMessageNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pSubSystemBuffer) && !(pSubSystemNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pLogLevel)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMessage("");
		std::string sSubSystem("");
		std::string sTimestamp("");
		ILogEntryList* pILogEntryList = dynamic_cast<ILogEntryList*>(pIBaseClass);
		if (!pILogEntryList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMessageBuffer == nullptr) || (pSubSystemBuffer == nullptr) || (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			pILogEntryList->GetEntryByIndex(nIndex, *pID, sMessage, sSubSystem, *pLogLevel, sTimestamp);

			pILogEntryList->_setCache (new ParameterCache_5<LibMCData_uint32, std::string, std::string, LibMCData::eLogLevel, std::string> (*pID, sMessage, sSubSystem, *pLogLevel, sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_5<LibMCData_uint32, std::string, std::string, LibMCData::eLogLevel, std::string>*> (pILogEntryList->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (*pID, sMessage, sSubSystem, *pLogLevel, sTimestamp);
			pILogEntryList->_setCache (nullptr);
		}
		
		if (pMessageNeededChars)
			*pMessageNeededChars = (LibMCData_uint32) (sMessage.size()+1);
		if (pMessageBuffer) {
			if (sMessage.size() >= nMessageBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMessage = 0; iMessage < sMessage.size(); iMessage++)
				pMessageBuffer[iMessage] = sMessage[iMessage];
			pMessageBuffer[sMessage.size()] = 0;
		}
		if (pSubSystemNeededChars)
			*pSubSystemNeededChars = (LibMCData_uint32) (sSubSystem.size()+1);
		if (pSubSystemBuffer) {
			if (sSubSystem.size() >= nSubSystemBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSubSystem = 0; iSubSystem < sSubSystem.size(); iSubSystem++)
				pSubSystemBuffer[iSubSystem] = sSubSystem[iSubSystem];
			pSubSystemBuffer[sSubSystem.size()] = 0;
		}
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logentrylist_getentrybyid(LibMCData_LogEntryList pLogEntryList, LibMCData_uint32 nID, const LibMCData_uint32 nMessageBufferSize, LibMCData_uint32* pMessageNeededChars, char * pMessageBuffer, const LibMCData_uint32 nSubSystemBufferSize, LibMCData_uint32* pSubSystemNeededChars, char * pSubSystemBuffer, eLibMCDataLogLevel * pLogLevel, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pLogEntryList;

	try {
		if ( (!pMessageBuffer) && !(pMessageNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pSubSystemBuffer) && !(pSubSystemNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pLogLevel)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMessage("");
		std::string sSubSystem("");
		std::string sTimestamp("");
		ILogEntryList* pILogEntryList = dynamic_cast<ILogEntryList*>(pIBaseClass);
		if (!pILogEntryList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMessageBuffer == nullptr) || (pSubSystemBuffer == nullptr) || (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			pILogEntryList->GetEntryByID(nID, sMessage, sSubSystem, *pLogLevel, sTimestamp);

			pILogEntryList->_setCache (new ParameterCache_4<std::string, std::string, LibMCData::eLogLevel, std::string> (sMessage, sSubSystem, *pLogLevel, sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<std::string, std::string, LibMCData::eLogLevel, std::string>*> (pILogEntryList->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sMessage, sSubSystem, *pLogLevel, sTimestamp);
			pILogEntryList->_setCache (nullptr);
		}
		
		if (pMessageNeededChars)
			*pMessageNeededChars = (LibMCData_uint32) (sMessage.size()+1);
		if (pMessageBuffer) {
			if (sMessage.size() >= nMessageBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMessage = 0; iMessage < sMessage.size(); iMessage++)
				pMessageBuffer[iMessage] = sMessage[iMessage];
			pMessageBuffer[sMessage.size()] = 0;
		}
		if (pSubSystemNeededChars)
			*pSubSystemNeededChars = (LibMCData_uint32) (sSubSystem.size()+1);
		if (pSubSystemBuffer) {
			if (sSubSystem.size() >= nSubSystemBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSubSystem = 0; iSubSystem < sSubSystem.size(); iSubSystem++)
				pSubSystemBuffer[iSubSystem] = sSubSystem[iSubSystem];
			pSubSystemBuffer[sSubSystem.size()] = 0;
		}
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logentrylist_hasentry(LibMCData_LogEntryList pLogEntryList, LibMCData_uint32 nID, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pLogEntryList;

	try {
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		ILogEntryList* pILogEntryList = dynamic_cast<ILogEntryList*>(pIBaseClass);
		if (!pILogEntryList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pValue = pILogEntryList->HasEntry(nID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for LogSession
**************************************************************************************************************************/
LibMCDataResult libmcdata_logsession_getsessionuuid(LibMCData_LogSession pLogSession, const LibMCData_uint32 nSessionUUIDBufferSize, LibMCData_uint32* pSessionUUIDNeededChars, char * pSessionUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pLogSession;

	try {
		if ( (!pSessionUUIDBuffer) && !(pSessionUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sSessionUUID("");
		ILogSession* pILogSession = dynamic_cast<ILogSession*>(pIBaseClass);
		if (!pILogSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSessionUUIDBuffer == nullptr);
		if (isCacheCall) {
			sSessionUUID = pILogSession->GetSessionUUID();

			pILogSession->_setCache (new ParameterCache_1<std::string> (sSessionUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILogSession->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sSessionUUID);
			pILogSession->_setCache (nullptr);
		}
		
		if (pSessionUUIDNeededChars)
			*pSessionUUIDNeededChars = (LibMCData_uint32) (sSessionUUID.size()+1);
		if (pSessionUUIDBuffer) {
			if (sSessionUUID.size() >= nSessionUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSessionUUID = 0; iSessionUUID < sSessionUUID.size(); iSessionUUID++)
				pSessionUUIDBuffer[iSessionUUID] = sSessionUUID[iSessionUUID];
			pSessionUUIDBuffer[sSessionUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logsession_addentry(LibMCData_LogSession pLogSession, const char * pMessage, const char * pSubSystem, eLibMCDataLogLevel eLogLevel, const char * pTimestampUTC)
{
	IBase* pIBaseClass = (IBase *)pLogSession;

	try {
		if (pMessage == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSubSystem == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pTimestampUTC == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMessage(pMessage);
		std::string sSubSystem(pSubSystem);
		std::string sTimestampUTC(pTimestampUTC);
		ILogSession* pILogSession = dynamic_cast<ILogSession*>(pIBaseClass);
		if (!pILogSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILogSession->AddEntry(sMessage, sSubSystem, eLogLevel, sTimestampUTC);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logsession_getmaxlogentryid(LibMCData_LogSession pLogSession, LibMCData_uint32 * pMaxLogID)
{
	IBase* pIBaseClass = (IBase *)pLogSession;

	try {
		if (pMaxLogID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		ILogSession* pILogSession = dynamic_cast<ILogSession*>(pIBaseClass);
		if (!pILogSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pMaxLogID = pILogSession->GetMaxLogEntryID();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logsession_retrievelogentriesbyid(LibMCData_LogSession pLogSession, LibMCData_uint32 nMinLogID, LibMCData_uint32 nMaxLogID, eLibMCDataLogLevel eMinLogLevel, LibMCData_LogEntryList * pLogEntryList)
{
	IBase* pIBaseClass = (IBase *)pLogSession;

	try {
		if (pLogEntryList == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseLogEntryList(nullptr);
		ILogSession* pILogSession = dynamic_cast<ILogSession*>(pIBaseClass);
		if (!pILogSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseLogEntryList = pILogSession->RetrieveLogEntriesByID(nMinLogID, nMaxLogID, eMinLogLevel);

		*pLogEntryList = (IBase*)(pBaseLogEntryList);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Alert
**************************************************************************************************************************/
LibMCDataResult libmcdata_alert_getuuid(LibMCData_Alert pAlert, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIAlert->GetUUID();

			pIAlert->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAlert->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIAlert->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_getidentifier(LibMCData_Alert pAlert, const LibMCData_uint32 nIdentifierBufferSize, LibMCData_uint32* pIdentifierNeededChars, char * pIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if ( (!pIdentifierBuffer) && !(pIdentifierNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sIdentifier("");
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sIdentifier = pIAlert->GetIdentifier();

			pIAlert->_setCache (new ParameterCache_1<std::string> (sIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAlert->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sIdentifier);
			pIAlert->_setCache (nullptr);
		}
		
		if (pIdentifierNeededChars)
			*pIdentifierNeededChars = (LibMCData_uint32) (sIdentifier.size()+1);
		if (pIdentifierBuffer) {
			if (sIdentifier.size() >= nIdentifierBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iIdentifier = 0; iIdentifier < sIdentifier.size(); iIdentifier++)
				pIdentifierBuffer[iIdentifier] = sIdentifier[iIdentifier];
			pIdentifierBuffer[sIdentifier.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_isactive(LibMCData_Alert pAlert, bool * pActive)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if (pActive == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pActive = pIAlert->IsActive();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_getlevel(LibMCData_Alert pAlert, eLibMCDataAlertLevel * pLevel)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if (pLevel == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pLevel = pIAlert->GetLevel();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_getlevelstring(LibMCData_Alert pAlert, const LibMCData_uint32 nLevelStringBufferSize, LibMCData_uint32* pLevelStringNeededChars, char * pLevelStringBuffer)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if ( (!pLevelStringBuffer) && !(pLevelStringNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sLevelString("");
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pLevelStringBuffer == nullptr);
		if (isCacheCall) {
			sLevelString = pIAlert->GetLevelString();

			pIAlert->_setCache (new ParameterCache_1<std::string> (sLevelString));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAlert->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sLevelString);
			pIAlert->_setCache (nullptr);
		}
		
		if (pLevelStringNeededChars)
			*pLevelStringNeededChars = (LibMCData_uint32) (sLevelString.size()+1);
		if (pLevelStringBuffer) {
			if (sLevelString.size() >= nLevelStringBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iLevelString = 0; iLevelString < sLevelString.size(); iLevelString++)
				pLevelStringBuffer[iLevelString] = sLevelString[iLevelString];
			pLevelStringBuffer[sLevelString.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_getdescription(LibMCData_Alert pAlert, const LibMCData_uint32 nDescriptionBufferSize, LibMCData_uint32* pDescriptionNeededChars, char * pDescriptionBuffer)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if ( (!pDescriptionBuffer) && !(pDescriptionNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDescription("");
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDescriptionBuffer == nullptr);
		if (isCacheCall) {
			sDescription = pIAlert->GetDescription();

			pIAlert->_setCache (new ParameterCache_1<std::string> (sDescription));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAlert->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sDescription);
			pIAlert->_setCache (nullptr);
		}
		
		if (pDescriptionNeededChars)
			*pDescriptionNeededChars = (LibMCData_uint32) (sDescription.size()+1);
		if (pDescriptionBuffer) {
			if (sDescription.size() >= nDescriptionBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDescription = 0; iDescription < sDescription.size(); iDescription++)
				pDescriptionBuffer[iDescription] = sDescription[iDescription];
			pDescriptionBuffer[sDescription.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_getdescriptionidentifier(LibMCData_Alert pAlert, const LibMCData_uint32 nDescriptionIdentifierBufferSize, LibMCData_uint32* pDescriptionIdentifierNeededChars, char * pDescriptionIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if ( (!pDescriptionIdentifierBuffer) && !(pDescriptionIdentifierNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDescriptionIdentifier("");
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDescriptionIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sDescriptionIdentifier = pIAlert->GetDescriptionIdentifier();

			pIAlert->_setCache (new ParameterCache_1<std::string> (sDescriptionIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAlert->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sDescriptionIdentifier);
			pIAlert->_setCache (nullptr);
		}
		
		if (pDescriptionIdentifierNeededChars)
			*pDescriptionIdentifierNeededChars = (LibMCData_uint32) (sDescriptionIdentifier.size()+1);
		if (pDescriptionIdentifierBuffer) {
			if (sDescriptionIdentifier.size() >= nDescriptionIdentifierBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDescriptionIdentifier = 0; iDescriptionIdentifier < sDescriptionIdentifier.size(); iDescriptionIdentifier++)
				pDescriptionIdentifierBuffer[iDescriptionIdentifier] = sDescriptionIdentifier[iDescriptionIdentifier];
			pDescriptionIdentifierBuffer[sDescriptionIdentifier.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_getreadablecontextinformation(LibMCData_Alert pAlert, const LibMCData_uint32 nReadableContextInformationBufferSize, LibMCData_uint32* pReadableContextInformationNeededChars, char * pReadableContextInformationBuffer)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if ( (!pReadableContextInformationBuffer) && !(pReadableContextInformationNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sReadableContextInformation("");
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pReadableContextInformationBuffer == nullptr);
		if (isCacheCall) {
			sReadableContextInformation = pIAlert->GetReadableContextInformation();

			pIAlert->_setCache (new ParameterCache_1<std::string> (sReadableContextInformation));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAlert->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sReadableContextInformation);
			pIAlert->_setCache (nullptr);
		}
		
		if (pReadableContextInformationNeededChars)
			*pReadableContextInformationNeededChars = (LibMCData_uint32) (sReadableContextInformation.size()+1);
		if (pReadableContextInformationBuffer) {
			if (sReadableContextInformation.size() >= nReadableContextInformationBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iReadableContextInformation = 0; iReadableContextInformation < sReadableContextInformation.size(); iReadableContextInformation++)
				pReadableContextInformationBuffer[iReadableContextInformation] = sReadableContextInformation[iReadableContextInformation];
			pReadableContextInformationBuffer[sReadableContextInformation.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_getneedsacknowledgement(LibMCData_Alert pAlert, bool * pNeedsAcknowledgement)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if (pNeedsAcknowledgement == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pNeedsAcknowledgement = pIAlert->GetNeedsAcknowledgement();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_gettimestamputc(LibMCData_Alert pAlert, const LibMCData_uint32 nTimestampUTCBufferSize, LibMCData_uint32* pTimestampUTCNeededChars, char * pTimestampUTCBuffer)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if ( (!pTimestampUTCBuffer) && !(pTimestampUTCNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestampUTC("");
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampUTCBuffer == nullptr);
		if (isCacheCall) {
			sTimestampUTC = pIAlert->GetTimestampUTC();

			pIAlert->_setCache (new ParameterCache_1<std::string> (sTimestampUTC));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAlert->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestampUTC);
			pIAlert->_setCache (nullptr);
		}
		
		if (pTimestampUTCNeededChars)
			*pTimestampUTCNeededChars = (LibMCData_uint32) (sTimestampUTC.size()+1);
		if (pTimestampUTCBuffer) {
			if (sTimestampUTC.size() >= nTimestampUTCBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestampUTC = 0; iTimestampUTC < sTimestampUTC.size(); iTimestampUTC++)
				pTimestampUTCBuffer[iTimestampUTC] = sTimestampUTC[iTimestampUTC];
			pTimestampUTCBuffer[sTimestampUTC.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_hasbeenacknowledged(LibMCData_Alert pAlert, bool * pHasBeenAcknowledged)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if (pHasBeenAcknowledged == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pHasBeenAcknowledged = pIAlert->HasBeenAcknowledged();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_getacknowledgementinformation(LibMCData_Alert pAlert, const LibMCData_uint32 nUserUUIDBufferSize, LibMCData_uint32* pUserUUIDNeededChars, char * pUserUUIDBuffer, const LibMCData_uint32 nUserCommentBufferSize, LibMCData_uint32* pUserCommentNeededChars, char * pUserCommentBuffer, const LibMCData_uint32 nAckTimeBufferSize, LibMCData_uint32* pAckTimeNeededChars, char * pAckTimeBuffer)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if ( (!pUserUUIDBuffer) && !(pUserUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pUserCommentBuffer) && !(pUserCommentNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pAckTimeBuffer) && !(pAckTimeNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUserUUID("");
		std::string sUserComment("");
		std::string sAckTime("");
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUserUUIDBuffer == nullptr) || (pUserCommentBuffer == nullptr) || (pAckTimeBuffer == nullptr);
		if (isCacheCall) {
			pIAlert->GetAcknowledgementInformation(sUserUUID, sUserComment, sAckTime);

			pIAlert->_setCache (new ParameterCache_3<std::string, std::string, std::string> (sUserUUID, sUserComment, sAckTime));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_3<std::string, std::string, std::string>*> (pIAlert->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUserUUID, sUserComment, sAckTime);
			pIAlert->_setCache (nullptr);
		}
		
		if (pUserUUIDNeededChars)
			*pUserUUIDNeededChars = (LibMCData_uint32) (sUserUUID.size()+1);
		if (pUserUUIDBuffer) {
			if (sUserUUID.size() >= nUserUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUserUUID = 0; iUserUUID < sUserUUID.size(); iUserUUID++)
				pUserUUIDBuffer[iUserUUID] = sUserUUID[iUserUUID];
			pUserUUIDBuffer[sUserUUID.size()] = 0;
		}
		if (pUserCommentNeededChars)
			*pUserCommentNeededChars = (LibMCData_uint32) (sUserComment.size()+1);
		if (pUserCommentBuffer) {
			if (sUserComment.size() >= nUserCommentBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUserComment = 0; iUserComment < sUserComment.size(); iUserComment++)
				pUserCommentBuffer[iUserComment] = sUserComment[iUserComment];
			pUserCommentBuffer[sUserComment.size()] = 0;
		}
		if (pAckTimeNeededChars)
			*pAckTimeNeededChars = (LibMCData_uint32) (sAckTime.size()+1);
		if (pAckTimeBuffer) {
			if (sAckTime.size() >= nAckTimeBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iAckTime = 0; iAckTime < sAckTime.size(); iAckTime++)
				pAckTimeBuffer[iAckTime] = sAckTime[iAckTime];
			pAckTimeBuffer[sAckTime.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_acknowledgeforuser(LibMCData_Alert pAlert, const char * pUserUUID, const char * pUserComment, const char * pTimestampUTC)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		if (pUserUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserComment == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pTimestampUTC == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUserUUID(pUserUUID);
		std::string sUserComment(pUserComment);
		std::string sTimestampUTC(pTimestampUTC);
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIAlert->AcknowledgeForUser(sUserUUID, sUserComment, sTimestampUTC);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alert_deactivatealert(LibMCData_Alert pAlert)
{
	IBase* pIBaseClass = (IBase *)pAlert;

	try {
		IAlert* pIAlert = dynamic_cast<IAlert*>(pIBaseClass);
		if (!pIAlert)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIAlert->DeactivateAlert();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for AlertIterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_alertiterator_getcurrentalert(LibMCData_AlertIterator pAlertIterator, LibMCData_Alert * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pAlertIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IAlertIterator* pIAlertIterator = dynamic_cast<IAlertIterator*>(pIBaseClass);
		if (!pIAlertIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIAlertIterator->GetCurrentAlert();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for AlertSession
**************************************************************************************************************************/
LibMCDataResult libmcdata_alertsession_addalert(LibMCData_AlertSession pAlertSession, const char * pUUID, const char * pIdentifier, eLibMCDataAlertLevel eLevel, const char * pDescription, const char * pDescriptionIdentifier, const char * pReadableContextInformation, bool bNeedsAcknowledgement, const char * pTimestampUTC, LibMCData_Alert * pAlertInstance)
{
	IBase* pIBaseClass = (IBase *)pAlertSession;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIdentifier == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pDescriptionIdentifier == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pReadableContextInformation == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pTimestampUTC == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pAlertInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sIdentifier(pIdentifier);
		std::string sDescription(pDescription);
		std::string sDescriptionIdentifier(pDescriptionIdentifier);
		std::string sReadableContextInformation(pReadableContextInformation);
		std::string sTimestampUTC(pTimestampUTC);
		IBase* pBaseAlertInstance(nullptr);
		IAlertSession* pIAlertSession = dynamic_cast<IAlertSession*>(pIBaseClass);
		if (!pIAlertSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseAlertInstance = pIAlertSession->AddAlert(sUUID, sIdentifier, eLevel, sDescription, sDescriptionIdentifier, sReadableContextInformation, bNeedsAcknowledgement, sTimestampUTC);

		*pAlertInstance = (IBase*)(pBaseAlertInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alertsession_hasalert(LibMCData_AlertSession pAlertSession, const char * pUUID, bool * pAlertExists)
{
	IBase* pIBaseClass = (IBase *)pAlertSession;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pAlertExists == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IAlertSession* pIAlertSession = dynamic_cast<IAlertSession*>(pIBaseClass);
		if (!pIAlertSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pAlertExists = pIAlertSession->HasAlert(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alertsession_getalertbyuuid(LibMCData_AlertSession pAlertSession, const char * pUUID, LibMCData_Alert * pAlertInstance)
{
	IBase* pIBaseClass = (IBase *)pAlertSession;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pAlertInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IBase* pBaseAlertInstance(nullptr);
		IAlertSession* pIAlertSession = dynamic_cast<IAlertSession*>(pIBaseClass);
		if (!pIAlertSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseAlertInstance = pIAlertSession->GetAlertByUUID(sUUID);

		*pAlertInstance = (IBase*)(pBaseAlertInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alertsession_retrievealerts(LibMCData_AlertSession pAlertSession, bool bOnlyActive, LibMCData_AlertIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pAlertSession;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IAlertSession* pIAlertSession = dynamic_cast<IAlertSession*>(pIBaseClass);
		if (!pIAlertSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIAlertSession->RetrieveAlerts(bOnlyActive);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_alertsession_retrievealertsbytype(LibMCData_AlertSession pAlertSession, const char * pIdentifier, bool bOnlyActive, LibMCData_AlertIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pAlertSession;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		IBase* pBaseIteratorInstance(nullptr);
		IAlertSession* pIAlertSession = dynamic_cast<IAlertSession*>(pIBaseClass);
		if (!pIAlertSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIAlertSession->RetrieveAlertsByType(sIdentifier, bOnlyActive);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for JournalSession
**************************************************************************************************************************/
LibMCDataResult libmcdata_journalsession_getsessionuuid(LibMCData_JournalSession pJournalSession, const LibMCData_uint32 nSessionUUIDBufferSize, LibMCData_uint32* pSessionUUIDNeededChars, char * pSessionUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pJournalSession;

	try {
		if ( (!pSessionUUIDBuffer) && !(pSessionUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sSessionUUID("");
		IJournalSession* pIJournalSession = dynamic_cast<IJournalSession*>(pIBaseClass);
		if (!pIJournalSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSessionUUIDBuffer == nullptr);
		if (isCacheCall) {
			sSessionUUID = pIJournalSession->GetSessionUUID();

			pIJournalSession->_setCache (new ParameterCache_1<std::string> (sSessionUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIJournalSession->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sSessionUUID);
			pIJournalSession->_setCache (nullptr);
		}
		
		if (pSessionUUIDNeededChars)
			*pSessionUUIDNeededChars = (LibMCData_uint32) (sSessionUUID.size()+1);
		if (pSessionUUIDBuffer) {
			if (sSessionUUID.size() >= nSessionUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSessionUUID = 0; iSessionUUID < sSessionUUID.size(); iSessionUUID++)
				pSessionUUIDBuffer[iSessionUUID] = sSessionUUID[iSessionUUID];
			pSessionUUIDBuffer[sSessionUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_journalsession_writejournalchunkintegerdata(LibMCData_JournalSession pJournalSession, LibMCData_uint32 nChunkIndex, LibMCData_uint64 nStartTimeStamp, LibMCData_uint64 nEndTimeStamp, LibMCData_uint64 nVariableInfoBufferSize, const sLibMCDataJournalChunkVariableInfo * pVariableInfoBuffer, LibMCData_uint64 nEntryDataBufferSize, const sLibMCDataJournalChunkIntegerEntry * pEntryDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pJournalSession;

	try {
		if ( (!pVariableInfoBuffer) && (nVariableInfoBufferSize>0))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pEntryDataBuffer) && (nEntryDataBufferSize>0))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IJournalSession* pIJournalSession = dynamic_cast<IJournalSession*>(pIBaseClass);
		if (!pIJournalSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIJournalSession->WriteJournalChunkIntegerData(nChunkIndex, nStartTimeStamp, nEndTimeStamp, nVariableInfoBufferSize, pVariableInfoBuffer, nEntryDataBufferSize, pEntryDataBuffer);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_journalsession_getchunkcapacity(LibMCData_JournalSession pJournalSession, LibMCData_uint32 * pChunkCapacity)
{
	IBase* pIBaseClass = (IBase *)pJournalSession;

	try {
		if (pChunkCapacity == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IJournalSession* pIJournalSession = dynamic_cast<IJournalSession*>(pIBaseClass);
		if (!pIJournalSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pChunkCapacity = pIJournalSession->GetChunkCapacity();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_journalsession_getflushinterval(LibMCData_JournalSession pJournalSession, LibMCData_uint32 * pFlushInterval)
{
	IBase* pIBaseClass = (IBase *)pJournalSession;

	try {
		if (pFlushInterval == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IJournalSession* pIJournalSession = dynamic_cast<IJournalSession*>(pIBaseClass);
		if (!pIJournalSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pFlushInterval = pIJournalSession->GetFlushInterval();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for StorageStream
**************************************************************************************************************************/
LibMCDataResult libmcdata_storagestream_getuuid(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIStorageStream->GetUUID();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_gettimestamp(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestamp("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			sTimestamp = pIStorageStream->GetTimeStamp();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestamp);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getcontextidentifier(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nContextIdentifierBufferSize, LibMCData_uint32* pContextIdentifierNeededChars, char * pContextIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pContextIdentifierBuffer) && !(pContextIdentifierNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sContextIdentifier("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pContextIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sContextIdentifier = pIStorageStream->GetContextIdentifier();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sContextIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sContextIdentifier);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pContextIdentifierNeededChars)
			*pContextIdentifierNeededChars = (LibMCData_uint32) (sContextIdentifier.size()+1);
		if (pContextIdentifierBuffer) {
			if (sContextIdentifier.size() >= nContextIdentifierBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iContextIdentifier = 0; iContextIdentifier < sContextIdentifier.size(); iContextIdentifier++)
				pContextIdentifierBuffer[iContextIdentifier] = sContextIdentifier[iContextIdentifier];
			pContextIdentifierBuffer[sContextIdentifier.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getname(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIStorageStream->GetName();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getmimetype(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nMimeTypeBufferSize, LibMCData_uint32* pMimeTypeNeededChars, char * pMimeTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pMimeTypeBuffer) && !(pMimeTypeNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMimeType("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMimeTypeBuffer == nullptr);
		if (isCacheCall) {
			sMimeType = pIStorageStream->GetMIMEType();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sMimeType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sMimeType);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pMimeTypeNeededChars)
			*pMimeTypeNeededChars = (LibMCData_uint32) (sMimeType.size()+1);
		if (pMimeTypeBuffer) {
			if (sMimeType.size() >= nMimeTypeBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMimeType = 0; iMimeType < sMimeType.size(); iMimeType++)
				pMimeTypeBuffer[iMimeType] = sMimeType[iMimeType];
			pMimeTypeBuffer[sMimeType.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getsha2(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nSHA2BufferSize, LibMCData_uint32* pSHA2NeededChars, char * pSHA2Buffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pSHA2Buffer) && !(pSHA2NeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sSHA2("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSHA2Buffer == nullptr);
		if (isCacheCall) {
			sSHA2 = pIStorageStream->GetSHA2();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sSHA2));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sSHA2);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pSHA2NeededChars)
			*pSHA2NeededChars = (LibMCData_uint32) (sSHA2.size()+1);
		if (pSHA2Buffer) {
			if (sSHA2.size() >= nSHA2BufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA2 = 0; iSHA2 < sSHA2.size(); iSHA2++)
				pSHA2Buffer[iSHA2] = sSHA2[iSHA2];
			pSHA2Buffer[sSHA2.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getsize(LibMCData_StorageStream pStorageStream, LibMCData_uint64 * pSize)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if (pSize == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pSize = pIStorageStream->GetSize();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getcontent(LibMCData_StorageStream pStorageStream, const LibMCData_uint64 nContentBufferSize, LibMCData_uint64* pContentNeededCount, LibMCData_uint8 * pContentBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ((!pContentBuffer) && !(pContentNeededCount))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorageStream->GetContent(nContentBufferSize, pContentNeededCount, pContentBuffer);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getcallbacks(LibMCData_StorageStream pStorageStream, LibMCData_pvoid * pTheReadCallback, LibMCData_pvoid * pTheSeekCallback, LibMCData_pvoid * pStreamHandle)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if (!pTheReadCallback)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pTheSeekCallback)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pStreamHandle)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorageStream->GetCallbacks(*pTheReadCallback, *pTheSeekCallback, *pStreamHandle);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Storage
**************************************************************************************************************************/
LibMCDataResult libmcdata_storage_streamisready(LibMCData_Storage pStorage, const char * pUUID, bool * pIsReady)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIsReady == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pIsReady = pIStorage->StreamIsReady(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_retrievestream(LibMCData_Storage pStorage, const char * pUUID, LibMCData_StorageStream * pStreamInstance)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStreamInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IBase* pBaseStreamInstance(nullptr);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStreamInstance = pIStorage->RetrieveStream(sUUID);

		*pStreamInstance = (IBase*)(pBaseStreamInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_storenewstream(LibMCData_Storage pStorage, const char * pUUID, const char * pContextUUID, const char * pContextIdentifier, const char * pName, const char * pMimeType, LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextIdentifier == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pMimeType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pContentBuffer) && (nContentBufferSize>0))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sContextUUID(pContextUUID);
		std::string sContextIdentifier(pContextIdentifier);
		std::string sName(pName);
		std::string sMimeType(pMimeType);
		std::string sUserID(pUserID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->StoreNewStream(sUUID, sContextUUID, sContextIdentifier, sName, sMimeType, nContentBufferSize, pContentBuffer, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_beginpartialstream(LibMCData_Storage pStorage, const char * pUUID, const char * pContextUUID, const char * pContextIdentifier, const char * pName, const char * pMimeType, LibMCData_uint64 nSize, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextIdentifier == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pMimeType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sContextUUID(pContextUUID);
		std::string sContextIdentifier(pContextIdentifier);
		std::string sName(pName);
		std::string sMimeType(pMimeType);
		std::string sUserID(pUserID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->BeginPartialStream(sUUID, sContextUUID, sContextIdentifier, sName, sMimeType, nSize, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_storepartialstream(LibMCData_Storage pStorage, const char * pUUID, LibMCData_uint64 nOffset, LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pContentBuffer) && (nContentBufferSize>0))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->StorePartialStream(sUUID, nOffset, nContentBufferSize, pContentBuffer);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_finishpartialstream(LibMCData_Storage pStorage, const char * pUUID, const char * pSHA2)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSHA2 == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sSHA2(pSHA2);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->FinishPartialStream(sUUID, sSHA2);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_finishpartialstreamblockwisesha256(LibMCData_Storage pStorage, const char * pUUID, const char * pBlockwiseSHA2)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pBlockwiseSHA2 == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sBlockwiseSHA2(pBlockwiseSHA2);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->FinishPartialStreamBlockwiseSHA256(sUUID, sBlockwiseSHA2);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_beginrandomwritestream(LibMCData_Storage pStorage, const char * pUUID, const char * pContextUUID, const char * pContextIdentifier, const char * pName, const char * pMimeType, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextIdentifier == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pMimeType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sContextUUID(pContextUUID);
		std::string sContextIdentifier(pContextIdentifier);
		std::string sName(pName);
		std::string sMimeType(pMimeType);
		std::string sUserID(pUserID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->BeginRandomWriteStream(sUUID, sContextUUID, sContextIdentifier, sName, sMimeType, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_storerandomwritestream(LibMCData_Storage pStorage, const char * pUUID, LibMCData_uint64 nOffset, LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pContentBuffer) && (nContentBufferSize>0))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->StoreRandomWriteStream(sUUID, nOffset, nContentBufferSize, pContentBuffer);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_getrandomwritestreamsize(LibMCData_Storage pStorage, const char * pUUID, LibMCData_uint64 * pCurrentSize)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pCurrentSize == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pCurrentSize = pIStorage->GetRandomWriteStreamSize(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_finishrandomwritestream(LibMCData_Storage pStorage, const char * pUUID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->FinishRandomWriteStream(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_getmaxstreamsize(LibMCData_Storage pStorage, LibMCData_uint64 * pMaxStreamSize)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pMaxStreamSize == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pMaxStreamSize = pIStorage->GetMaxStreamSize();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_contenttypeisaccepted(LibMCData_Storage pStorage, const char * pContentType, bool * pAccepted)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pContentType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pAccepted == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sContentType(pContentType);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pAccepted = pIStorage->ContentTypeIsAccepted(sContentType);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_streamisimage(LibMCData_Storage pStorage, const char * pUUID, bool * pIsImage)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIsImage == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pIsImage = pIStorage->StreamIsImage(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_createdownloadticket(LibMCData_Storage pStorage, const char * pTicketUUID, const char * pStreamUUID, const char * pClientFileName, const char * pSessionUUID, const char * pUserUUID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pTicketUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStreamUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pClientFileName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSessionUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTicketUUID(pTicketUUID);
		std::string sStreamUUID(pStreamUUID);
		std::string sClientFileName(pClientFileName);
		std::string sSessionUUID(pSessionUUID);
		std::string sUserUUID(pUserUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->CreateDownloadTicket(sTicketUUID, sStreamUUID, sClientFileName, sSessionUUID, sUserUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_requestdownloadticket(LibMCData_Storage pStorage, const char * pTicketUUID, const char * pIPAddress, const LibMCData_uint32 nStreamUUIDBufferSize, LibMCData_uint32* pStreamUUIDNeededChars, char * pStreamUUIDBuffer, const LibMCData_uint32 nClientFileNameBufferSize, LibMCData_uint32* pClientFileNameNeededChars, char * pClientFileNameBuffer, const LibMCData_uint32 nSessionUUIDBufferSize, LibMCData_uint32* pSessionUUIDNeededChars, char * pSessionUUIDBuffer, const LibMCData_uint32 nUserUUIDBufferSize, LibMCData_uint32* pUserUUIDNeededChars, char * pUserUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pTicketUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIPAddress == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pStreamUUIDBuffer) && !(pStreamUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pClientFileNameBuffer) && !(pClientFileNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pSessionUUIDBuffer) && !(pSessionUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pUserUUIDBuffer) && !(pUserUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTicketUUID(pTicketUUID);
		std::string sIPAddress(pIPAddress);
		std::string sStreamUUID("");
		std::string sClientFileName("");
		std::string sSessionUUID("");
		std::string sUserUUID("");
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStreamUUIDBuffer == nullptr) || (pClientFileNameBuffer == nullptr) || (pSessionUUIDBuffer == nullptr) || (pUserUUIDBuffer == nullptr);
		if (isCacheCall) {
			pIStorage->RequestDownloadTicket(sTicketUUID, sIPAddress, sStreamUUID, sClientFileName, sSessionUUID, sUserUUID);

			pIStorage->_setCache (new ParameterCache_4<std::string, std::string, std::string, std::string> (sStreamUUID, sClientFileName, sSessionUUID, sUserUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<std::string, std::string, std::string, std::string>*> (pIStorage->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sStreamUUID, sClientFileName, sSessionUUID, sUserUUID);
			pIStorage->_setCache (nullptr);
		}
		
		if (pStreamUUIDNeededChars)
			*pStreamUUIDNeededChars = (LibMCData_uint32) (sStreamUUID.size()+1);
		if (pStreamUUIDBuffer) {
			if (sStreamUUID.size() >= nStreamUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iStreamUUID = 0; iStreamUUID < sStreamUUID.size(); iStreamUUID++)
				pStreamUUIDBuffer[iStreamUUID] = sStreamUUID[iStreamUUID];
			pStreamUUIDBuffer[sStreamUUID.size()] = 0;
		}
		if (pClientFileNameNeededChars)
			*pClientFileNameNeededChars = (LibMCData_uint32) (sClientFileName.size()+1);
		if (pClientFileNameBuffer) {
			if (sClientFileName.size() >= nClientFileNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iClientFileName = 0; iClientFileName < sClientFileName.size(); iClientFileName++)
				pClientFileNameBuffer[iClientFileName] = sClientFileName[iClientFileName];
			pClientFileNameBuffer[sClientFileName.size()] = 0;
		}
		if (pSessionUUIDNeededChars)
			*pSessionUUIDNeededChars = (LibMCData_uint32) (sSessionUUID.size()+1);
		if (pSessionUUIDBuffer) {
			if (sSessionUUID.size() >= nSessionUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSessionUUID = 0; iSessionUUID < sSessionUUID.size(); iSessionUUID++)
				pSessionUUIDBuffer[iSessionUUID] = sSessionUUID[iSessionUUID];
			pSessionUUIDBuffer[sSessionUUID.size()] = 0;
		}
		if (pUserUUIDNeededChars)
			*pUserUUIDNeededChars = (LibMCData_uint32) (sUserUUID.size()+1);
		if (pUserUUIDBuffer) {
			if (sUserUUID.size() >= nUserUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUserUUID = 0; iUserUUID < sUserUUID.size(); iUserUUID++)
				pUserUUIDBuffer[iUserUUID] = sUserUUID[iUserUUID];
			pUserUUIDBuffer[sUserUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_attachstreamtojournal(LibMCData_Storage pStorage, const char * pStreamUUID, const char * pJournalUUID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pStreamUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pJournalUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sStreamUUID(pStreamUUID);
		std::string sJournalUUID(pJournalUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->AttachStreamToJournal(sStreamUUID, sJournalUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobData
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobdata_getdatauuid(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildJobData->GetDataUUID();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getjobuuid(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildJobData->GetJobUUID();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getname(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBuildJobData->GetName();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getcontextidentifier(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nContextIdentifierBufferSize, LibMCData_uint32* pContextIdentifierNeededChars, char * pContextIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pContextIdentifierBuffer) && !(pContextIdentifierNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sContextIdentifier("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pContextIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sContextIdentifier = pIBuildJobData->GetContextIdentifier();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sContextIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sContextIdentifier);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pContextIdentifierNeededChars)
			*pContextIdentifierNeededChars = (LibMCData_uint32) (sContextIdentifier.size()+1);
		if (pContextIdentifierBuffer) {
			if (sContextIdentifier.size() >= nContextIdentifierBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iContextIdentifier = 0; iContextIdentifier < sContextIdentifier.size(); iContextIdentifier++)
				pContextIdentifierBuffer[iContextIdentifier] = sContextIdentifier[iContextIdentifier];
			pContextIdentifierBuffer[sContextIdentifier.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_gettimestamp(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestamp("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			sTimestamp = pIBuildJobData->GetTimeStamp();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestamp);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getstoragestream(LibMCData_BuildJobData pBuildJobData, LibMCData_StorageStream * pStreamInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if (pStreamInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseStreamInstance(nullptr);
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStreamInstance = pIBuildJobData->GetStorageStream();

		*pStreamInstance = (IBase*)(pBaseStreamInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getstoragestreamsha2(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nSHA2BufferSize, LibMCData_uint32* pSHA2NeededChars, char * pSHA2Buffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pSHA2Buffer) && !(pSHA2NeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sSHA2("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSHA2Buffer == nullptr);
		if (isCacheCall) {
			sSHA2 = pIBuildJobData->GetStorageStreamSHA2();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sSHA2));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sSHA2);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pSHA2NeededChars)
			*pSHA2NeededChars = (LibMCData_uint32) (sSHA2.size()+1);
		if (pSHA2Buffer) {
			if (sSHA2.size() >= nSHA2BufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA2 = 0; iSHA2 < sSHA2.size(); iSHA2++)
				pSHA2Buffer[iSHA2] = sSHA2[iSHA2];
			pSHA2Buffer[sSHA2.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getstoragestreamsize(LibMCData_BuildJobData pBuildJobData, LibMCData_uint64 * pSize)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if (pSize == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pSize = pIBuildJobData->GetStorageStreamSize();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getdatatype(LibMCData_BuildJobData pBuildJobData, eLibMCDataBuildJobDataType * pDataType)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if (pDataType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pDataType = pIBuildJobData->GetDataType();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getdatatypeasstring(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nDataTypeBufferSize, LibMCData_uint32* pDataTypeNeededChars, char * pDataTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pDataTypeBuffer) && !(pDataTypeNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDataType("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDataTypeBuffer == nullptr);
		if (isCacheCall) {
			sDataType = pIBuildJobData->GetDataTypeAsString();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sDataType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sDataType);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pDataTypeNeededChars)
			*pDataTypeNeededChars = (LibMCData_uint32) (sDataType.size()+1);
		if (pDataTypeBuffer) {
			if (sDataType.size() >= nDataTypeBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDataType = 0; iDataType < sDataType.size(); iDataType++)
				pDataTypeBuffer[iDataType] = sDataType[iDataType];
			pDataTypeBuffer[sDataType.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getmimetype(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nMimeTypeBufferSize, LibMCData_uint32* pMimeTypeNeededChars, char * pMimeTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pMimeTypeBuffer) && !(pMimeTypeNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMimeType("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMimeTypeBuffer == nullptr);
		if (isCacheCall) {
			sMimeType = pIBuildJobData->GetMIMEType();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sMimeType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sMimeType);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pMimeTypeNeededChars)
			*pMimeTypeNeededChars = (LibMCData_uint32) (sMimeType.size()+1);
		if (pMimeTypeBuffer) {
			if (sMimeType.size() >= nMimeTypeBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMimeType = 0; iMimeType < sMimeType.size(); iMimeType++)
				pMimeTypeBuffer[iMimeType] = sMimeType[iMimeType];
			pMimeTypeBuffer[sMimeType.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobDataIterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobdataiterator_getcurrentjobdata(LibMCData_BuildJobDataIterator pBuildJobDataIterator, LibMCData_BuildJobData * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobDataIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IBuildJobDataIterator* pIBuildJobDataIterator = dynamic_cast<IBuildJobDataIterator*>(pIBaseClass);
		if (!pIBuildJobDataIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIBuildJobDataIterator->GetCurrentJobData();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobExecution
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobexecution_getexecutionuuid(LibMCData_BuildJobExecution pBuildJobExecution, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildJobExecution->GetExecutionUUID();

			pIBuildJobExecution->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobExecution->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIBuildJobExecution->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_getjobuuid(LibMCData_BuildJobExecution pBuildJobExecution, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildJobExecution->GetJobUUID();

			pIBuildJobExecution->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobExecution->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIBuildJobExecution->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_getstatus(LibMCData_BuildJobExecution pBuildJobExecution, eLibMCDataBuildJobExecutionStatus * pExecutionStatus)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if (pExecutionStatus == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pExecutionStatus = pIBuildJobExecution->GetStatus();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_changestatus(LibMCData_BuildJobExecution pBuildJobExecution, eLibMCDataBuildJobExecutionStatus eNewExecutionStatus)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJobExecution->ChangeStatus(eNewExecutionStatus);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_getdescription(LibMCData_BuildJobExecution pBuildJobExecution, const LibMCData_uint32 nDescriptionBufferSize, LibMCData_uint32* pDescriptionNeededChars, char * pDescriptionBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if ( (!pDescriptionBuffer) && !(pDescriptionNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDescription("");
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDescriptionBuffer == nullptr);
		if (isCacheCall) {
			sDescription = pIBuildJobExecution->GetDescription();

			pIBuildJobExecution->_setCache (new ParameterCache_1<std::string> (sDescription));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobExecution->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sDescription);
			pIBuildJobExecution->_setCache (nullptr);
		}
		
		if (pDescriptionNeededChars)
			*pDescriptionNeededChars = (LibMCData_uint32) (sDescription.size()+1);
		if (pDescriptionBuffer) {
			if (sDescription.size() >= nDescriptionBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDescription = 0; iDescription < sDescription.size(); iDescription++)
				pDescriptionBuffer[iDescription] = sDescription[iDescription];
			pDescriptionBuffer[sDescription.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_setdescription(LibMCData_BuildJobExecution pBuildJobExecution, const char * pNewDescription)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if (pNewDescription == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sNewDescription(pNewDescription);
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJobExecution->SetDescription(sNewDescription);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_getjournaluuid(LibMCData_BuildJobExecution pBuildJobExecution, const LibMCData_uint32 nJournalUUIDBufferSize, LibMCData_uint32* pJournalUUIDNeededChars, char * pJournalUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if ( (!pJournalUUIDBuffer) && !(pJournalUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sJournalUUID("");
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pJournalUUIDBuffer == nullptr);
		if (isCacheCall) {
			sJournalUUID = pIBuildJobExecution->GetJournalUUID();

			pIBuildJobExecution->_setCache (new ParameterCache_1<std::string> (sJournalUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobExecution->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sJournalUUID);
			pIBuildJobExecution->_setCache (nullptr);
		}
		
		if (pJournalUUIDNeededChars)
			*pJournalUUIDNeededChars = (LibMCData_uint32) (sJournalUUID.size()+1);
		if (pJournalUUIDBuffer) {
			if (sJournalUUID.size() >= nJournalUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iJournalUUID = 0; iJournalUUID < sJournalUUID.size(); iJournalUUID++)
				pJournalUUIDBuffer[iJournalUUID] = sJournalUUID[iJournalUUID];
			pJournalUUIDBuffer[sJournalUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_getuseruuid(LibMCData_BuildJobExecution pBuildJobExecution, const LibMCData_uint32 nUserUUIDBufferSize, LibMCData_uint32* pUserUUIDNeededChars, char * pUserUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if ( (!pUserUUIDBuffer) && !(pUserUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUserUUID("");
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUserUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUserUUID = pIBuildJobExecution->GetUserUUID();

			pIBuildJobExecution->_setCache (new ParameterCache_1<std::string> (sUserUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobExecution->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUserUUID);
			pIBuildJobExecution->_setCache (nullptr);
		}
		
		if (pUserUUIDNeededChars)
			*pUserUUIDNeededChars = (LibMCData_uint32) (sUserUUID.size()+1);
		if (pUserUUIDBuffer) {
			if (sUserUUID.size() >= nUserUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUserUUID = 0; iUserUUID < sUserUUID.size(); iUserUUID++)
				pUserUUIDBuffer[iUserUUID] = sUserUUID[iUserUUID];
			pUserUUIDBuffer[sUserUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_getstarttimestampinmicroseconds(LibMCData_BuildJobExecution pBuildJobExecution, LibMCData_uint64 * pTimeStampInMicroseconds)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if (pTimeStampInMicroseconds == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pTimeStampInMicroseconds = pIBuildJobExecution->GetStartTimeStampInMicroseconds();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_getendtimestampinmicroseconds(LibMCData_BuildJobExecution pBuildJobExecution, LibMCData_uint64 * pTimeStampInMicroseconds)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if (pTimeStampInMicroseconds == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pTimeStampInMicroseconds = pIBuildJobExecution->GetEndTimeStampInMicroseconds();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobexecution_computeelapsedtimeinmicroseconds(LibMCData_BuildJobExecution pBuildJobExecution, LibMCData_uint64 nGlobalTimerInMicroseconds, LibMCData_uint64 * pElapsedTimeInMicroseconds)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecution;

	try {
		if (pElapsedTimeInMicroseconds == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJobExecution* pIBuildJobExecution = dynamic_cast<IBuildJobExecution*>(pIBaseClass);
		if (!pIBuildJobExecution)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pElapsedTimeInMicroseconds = pIBuildJobExecution->ComputeElapsedTimeInMicroseconds(nGlobalTimerInMicroseconds);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobExecutionIterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobexecutioniterator_getcurrentjobdata(LibMCData_BuildJobExecutionIterator pBuildJobExecutionIterator, LibMCData_BuildJobExecution * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobExecutionIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IBuildJobExecutionIterator* pIBuildJobExecutionIterator = dynamic_cast<IBuildJobExecutionIterator*>(pIBaseClass);
		if (!pIBuildJobExecutionIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIBuildJobExecutionIterator->GetCurrentJobData();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJob
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjob_getuuid(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildJob->GetUUID();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getname(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBuildJob->GetName();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getstatus(LibMCData_BuildJob pBuildJob, eLibMCDataBuildJobStatus * pStatus)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pStatus == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pStatus = pIBuildJob->GetStatus();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getlayercount(LibMCData_BuildJob pBuildJob, LibMCData_uint32 * pLayerCount)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pLayerCount == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pLayerCount = pIBuildJob->GetLayerCount();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_gettimestamp(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestamp("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			sTimestamp = pIBuildJob->GetTimeStamp();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestamp);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getstoragestream(LibMCData_BuildJob pBuildJob, LibMCData_StorageStream * pStreamInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pStreamInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseStreamInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStreamInstance = pIBuildJob->GetStorageStream();

		*pStreamInstance = (IBase*)(pBaseStreamInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getstoragestreamuuid(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nStreamUUIDBufferSize, LibMCData_uint32* pStreamUUIDNeededChars, char * pStreamUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pStreamUUIDBuffer) && !(pStreamUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sStreamUUID("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStreamUUIDBuffer == nullptr);
		if (isCacheCall) {
			sStreamUUID = pIBuildJob->GetStorageStreamUUID();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sStreamUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sStreamUUID);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pStreamUUIDNeededChars)
			*pStreamUUIDNeededChars = (LibMCData_uint32) (sStreamUUID.size()+1);
		if (pStreamUUIDBuffer) {
			if (sStreamUUID.size() >= nStreamUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iStreamUUID = 0; iStreamUUID < sStreamUUID.size(); iStreamUUID++)
				pStreamUUIDBuffer[iStreamUUID] = sStreamUUID[iStreamUUID];
			pStreamUUIDBuffer[sStreamUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_startvalidating(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->StartValidating();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_finishvalidating(LibMCData_BuildJob pBuildJob, LibMCData_uint32 nLayerCount)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->FinishValidating(nLayerCount);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_archivejob(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->ArchiveJob();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_unarchivejob(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->UnArchiveJob();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_deletejob(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->DeleteJob();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_jobcanbearchived(LibMCData_BuildJob pBuildJob, bool * pCanBeArchived)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pCanBeArchived == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pCanBeArchived = pIBuildJob->JobCanBeArchived();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_addjobdata(LibMCData_BuildJob pBuildJob, const char * pIdentifier, const char * pName, LibMCData_StorageStream pStream, eLibMCDataBuildJobDataType eDataType, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pIdentifier == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sIdentifier(pIdentifier);
		std::string sName(pName);
		IBase* pIBaseClassStream = (IBase *)pStream;
		IStorageStream* pIStream = dynamic_cast<IStorageStream*>(pIBaseClassStream);
		if (!pIStream)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		std::string sUserID(pUserID);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->AddJobData(sIdentifier, sName, pIStream, eDataType, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_listjobdatabytype(LibMCData_BuildJob pBuildJob, eLibMCDataBuildJobDataType eDataType, LibMCData_BuildJobDataIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJob->ListJobDataByType(eDataType);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_listjobdata(LibMCData_BuildJob pBuildJob, LibMCData_BuildJobDataIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJob->ListJobData();

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_retrievejobdata(LibMCData_BuildJob pBuildJob, const char * pDataUUID, LibMCData_BuildJobData * pBuildJobData)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pDataUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pBuildJobData == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDataUUID(pDataUUID);
		IBase* pBaseBuildJobData(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseBuildJobData = pIBuildJob->RetrieveJobData(sDataUUID);

		*pBuildJobData = (IBase*)(pBaseBuildJobData);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_addmetadatastring(LibMCData_BuildJob pBuildJob, const char * pKey, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pKey == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sKey(pKey);
		std::string sValue(pValue);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->AddMetaDataString(sKey, sValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_hasmetadatastring(LibMCData_BuildJob pBuildJob, const char * pKey, bool * pMetaDataStringExists)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pKey == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pMetaDataStringExists == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sKey(pKey);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pMetaDataStringExists = pIBuildJob->HasMetaDataString(sKey);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getmetadatastring(LibMCData_BuildJob pBuildJob, const char * pKey, const LibMCData_uint32 nValueBufferSize, LibMCData_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pKey == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sKey(pKey);
		std::string sValue("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIBuildJob->GetMetaDataString(sKey);

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCData_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_createbuildjobexecution(LibMCData_BuildJob pBuildJob, const char * pDescription, const char * pUserUUID, LibMCData_uint64 nRelativeStartTimeStampInMicroseconds, LibMCData_BuildJobExecution * pExecutionInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pDescription == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pExecutionInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDescription(pDescription);
		std::string sUserUUID(pUserUUID);
		IBase* pBaseExecutionInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseExecutionInstance = pIBuildJob->CreateBuildJobExecution(sDescription, sUserUUID, nRelativeStartTimeStampInMicroseconds);

		*pExecutionInstance = (IBase*)(pBaseExecutionInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_retrievebuildjobexecution(LibMCData_BuildJob pBuildJob, const char * pExecutionUUID, LibMCData_BuildJobExecution * pExecutionInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pExecutionUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pExecutionInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sExecutionUUID(pExecutionUUID);
		IBase* pBaseExecutionInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseExecutionInstance = pIBuildJob->RetrieveBuildJobExecution(sExecutionUUID);

		*pExecutionInstance = (IBase*)(pBaseExecutionInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_retrievebuildjobexecutions(LibMCData_BuildJob pBuildJob, const char * pJournalUUIDFilter, LibMCData_BuildJobExecutionIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pJournalUUIDFilter == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sJournalUUIDFilter(pJournalUUIDFilter);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJob->RetrieveBuildJobExecutions(sJournalUUIDFilter);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_retrievebuildjobexecutionsbystatus(LibMCData_BuildJob pBuildJob, eLibMCDataBuildJobExecutionStatus eStatusFilter, const char * pJournalUUIDFilter, LibMCData_BuildJobExecutionIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pJournalUUIDFilter == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sJournalUUIDFilter(pJournalUUIDFilter);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJob->RetrieveBuildJobExecutionsByStatus(eStatusFilter, sJournalUUIDFilter);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobIterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobiterator_getcurrentjob(LibMCData_BuildJobIterator pBuildJobIterator, LibMCData_BuildJob * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IBuildJobIterator* pIBuildJobIterator = dynamic_cast<IBuildJobIterator*>(pIBaseClass);
		if (!pIBuildJobIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIBuildJobIterator->GetCurrentJob();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobHandler
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobhandler_createjob(LibMCData_BuildJobHandler pBuildJobHandler, const char * pJobUUID, const char * pName, const char * pUserID, const char * pStorageStreamUUID, LibMCData_BuildJob * pJobInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pJobUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStorageStreamUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pJobInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sJobUUID(pJobUUID);
		std::string sName(pName);
		std::string sUserID(pUserID);
		std::string sStorageStreamUUID(pStorageStreamUUID);
		IBase* pBaseJobInstance(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseJobInstance = pIBuildJobHandler->CreateJob(sJobUUID, sName, sUserID, sStorageStreamUUID);

		*pJobInstance = (IBase*)(pBaseJobInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_retrievejob(LibMCData_BuildJobHandler pBuildJobHandler, const char * pJobUUID, LibMCData_BuildJob * pJobInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pJobUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pJobInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sJobUUID(pJobUUID);
		IBase* pBaseJobInstance(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseJobInstance = pIBuildJobHandler->RetrieveJob(sJobUUID);

		*pJobInstance = (IBase*)(pBaseJobInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_findjobofdata(LibMCData_BuildJobHandler pBuildJobHandler, const char * pDataUUID, LibMCData_BuildJob * pBuildJobData)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pDataUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pBuildJobData == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDataUUID(pDataUUID);
		IBase* pBaseBuildJobData(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseBuildJobData = pIBuildJobHandler->FindJobOfData(sDataUUID);

		*pBuildJobData = (IBase*)(pBaseBuildJobData);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_listjobsbystatus(LibMCData_BuildJobHandler pBuildJobHandler, eLibMCDataBuildJobStatus eStatus, LibMCData_BuildJobIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJobHandler->ListJobsByStatus(eStatus);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_convertbuildstatustostring(LibMCData_BuildJobHandler pBuildJobHandler, eLibMCDataBuildJobStatus eStatus, const LibMCData_uint32 nStringBufferSize, LibMCData_uint32* pStringNeededChars, char * pStringBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if ( (!pStringBuffer) && !(pStringNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sString("");
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStringBuffer == nullptr);
		if (isCacheCall) {
			sString = pIBuildJobHandler->ConvertBuildStatusToString(eStatus);

			pIBuildJobHandler->_setCache (new ParameterCache_1<std::string> (sString));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sString);
			pIBuildJobHandler->_setCache (nullptr);
		}
		
		if (pStringNeededChars)
			*pStringNeededChars = (LibMCData_uint32) (sString.size()+1);
		if (pStringBuffer) {
			if (sString.size() >= nStringBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iString = 0; iString < sString.size(); iString++)
				pStringBuffer[iString] = sString[iString];
			pStringBuffer[sString.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_convertstringtobuildstatus(LibMCData_BuildJobHandler pBuildJobHandler, const char * pString, eLibMCDataBuildJobStatus * pStatus)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pString == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStatus == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sString(pString);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pStatus = pIBuildJobHandler->ConvertStringToBuildStatus(sString);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for UserList
**************************************************************************************************************************/
LibMCDataResult libmcdata_userlist_count(LibMCData_UserList pUserList, LibMCData_uint32 * pUserCount)
{
	IBase* pIBaseClass = (IBase *)pUserList;

	try {
		if (pUserCount == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IUserList* pIUserList = dynamic_cast<IUserList*>(pIBaseClass);
		if (!pIUserList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pUserCount = pIUserList->Count();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_userlist_getuserproperties(LibMCData_UserList pUserList, LibMCData_uint32 nUserIndex, const LibMCData_uint32 nUsernameBufferSize, LibMCData_uint32* pUsernameNeededChars, char * pUsernameBuffer, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer, const LibMCData_uint32 nDescriptionBufferSize, LibMCData_uint32* pDescriptionNeededChars, char * pDescriptionBuffer, const LibMCData_uint32 nRoleBufferSize, LibMCData_uint32* pRoleNeededChars, char * pRoleBuffer, const LibMCData_uint32 nLanguageIdentifierBufferSize, LibMCData_uint32* pLanguageIdentifierNeededChars, char * pLanguageIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pUserList;

	try {
		if ( (!pUsernameBuffer) && !(pUsernameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pDescriptionBuffer) && !(pDescriptionNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pRoleBuffer) && !(pRoleNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pLanguageIdentifierBuffer) && !(pLanguageIdentifierNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername("");
		std::string sUUID("");
		std::string sDescription("");
		std::string sRole("");
		std::string sLanguageIdentifier("");
		IUserList* pIUserList = dynamic_cast<IUserList*>(pIBaseClass);
		if (!pIUserList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUsernameBuffer == nullptr) || (pUUIDBuffer == nullptr) || (pDescriptionBuffer == nullptr) || (pRoleBuffer == nullptr) || (pLanguageIdentifierBuffer == nullptr);
		if (isCacheCall) {
			pIUserList->GetUserProperties(nUserIndex, sUsername, sUUID, sDescription, sRole, sLanguageIdentifier);

			pIUserList->_setCache (new ParameterCache_5<std::string, std::string, std::string, std::string, std::string> (sUsername, sUUID, sDescription, sRole, sLanguageIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_5<std::string, std::string, std::string, std::string, std::string>*> (pIUserList->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUsername, sUUID, sDescription, sRole, sLanguageIdentifier);
			pIUserList->_setCache (nullptr);
		}
		
		if (pUsernameNeededChars)
			*pUsernameNeededChars = (LibMCData_uint32) (sUsername.size()+1);
		if (pUsernameBuffer) {
			if (sUsername.size() >= nUsernameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUsername = 0; iUsername < sUsername.size(); iUsername++)
				pUsernameBuffer[iUsername] = sUsername[iUsername];
			pUsernameBuffer[sUsername.size()] = 0;
		}
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		if (pDescriptionNeededChars)
			*pDescriptionNeededChars = (LibMCData_uint32) (sDescription.size()+1);
		if (pDescriptionBuffer) {
			if (sDescription.size() >= nDescriptionBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDescription = 0; iDescription < sDescription.size(); iDescription++)
				pDescriptionBuffer[iDescription] = sDescription[iDescription];
			pDescriptionBuffer[sDescription.size()] = 0;
		}
		if (pRoleNeededChars)
			*pRoleNeededChars = (LibMCData_uint32) (sRole.size()+1);
		if (pRoleBuffer) {
			if (sRole.size() >= nRoleBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iRole = 0; iRole < sRole.size(); iRole++)
				pRoleBuffer[iRole] = sRole[iRole];
			pRoleBuffer[sRole.size()] = 0;
		}
		if (pLanguageIdentifierNeededChars)
			*pLanguageIdentifierNeededChars = (LibMCData_uint32) (sLanguageIdentifier.size()+1);
		if (pLanguageIdentifierBuffer) {
			if (sLanguageIdentifier.size() >= nLanguageIdentifierBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iLanguageIdentifier = 0; iLanguageIdentifier < sLanguageIdentifier.size(); iLanguageIdentifier++)
				pLanguageIdentifierBuffer[iLanguageIdentifier] = sLanguageIdentifier[iLanguageIdentifier];
			pLanguageIdentifierBuffer[sLanguageIdentifier.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for LoginHandler
**************************************************************************************************************************/
LibMCDataResult libmcdata_loginhandler_userexists(LibMCData_LoginHandler pLoginHandler, const char * pUsername, bool * pUserExists)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserExists == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pUserExists = pILoginHandler->UserExists(sUsername);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_useruuidexists(LibMCData_LoginHandler pLoginHandler, const char * pUUID, bool * pUserExists)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserExists == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pUserExists = pILoginHandler->UserUUIDExists(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserdetails(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const LibMCData_uint32 nSaltBufferSize, LibMCData_uint32* pSaltNeededChars, char * pSaltBuffer, const LibMCData_uint32 nHashedPasswordBufferSize, LibMCData_uint32* pHashedPasswordNeededChars, char * pHashedPasswordBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pSaltBuffer) && !(pSaltNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pHashedPasswordBuffer) && !(pHashedPasswordNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sSalt("");
		std::string sHashedPassword("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSaltBuffer == nullptr) || (pHashedPasswordBuffer == nullptr);
		if (isCacheCall) {
			pILoginHandler->GetUserDetails(sUsername, sSalt, sHashedPassword);

			pILoginHandler->_setCache (new ParameterCache_2<std::string, std::string> (sSalt, sHashedPassword));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sSalt, sHashedPassword);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pSaltNeededChars)
			*pSaltNeededChars = (LibMCData_uint32) (sSalt.size()+1);
		if (pSaltBuffer) {
			if (sSalt.size() >= nSaltBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSalt = 0; iSalt < sSalt.size(); iSalt++)
				pSaltBuffer[iSalt] = sSalt[iSalt];
			pSaltBuffer[sSalt.size()] = 0;
		}
		if (pHashedPasswordNeededChars)
			*pHashedPasswordNeededChars = (LibMCData_uint32) (sHashedPassword.size()+1);
		if (pHashedPasswordBuffer) {
			if (sHashedPassword.size() >= nHashedPasswordBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iHashedPassword = 0; iHashedPassword < sHashedPassword.size(); iHashedPassword++)
				pHashedPasswordBuffer[iHashedPassword] = sHashedPassword[iHashedPassword];
			pHashedPasswordBuffer[sHashedPassword.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserproperties(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer, const LibMCData_uint32 nDescriptionBufferSize, LibMCData_uint32* pDescriptionNeededChars, char * pDescriptionBuffer, const LibMCData_uint32 nRoleBufferSize, LibMCData_uint32* pRoleNeededChars, char * pRoleBuffer, const LibMCData_uint32 nLanguageIdentifierBufferSize, LibMCData_uint32* pLanguageIdentifierNeededChars, char * pLanguageIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pDescriptionBuffer) && !(pDescriptionNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pRoleBuffer) && !(pRoleNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pLanguageIdentifierBuffer) && !(pLanguageIdentifierNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sUUID("");
		std::string sDescription("");
		std::string sRole("");
		std::string sLanguageIdentifier("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr) || (pDescriptionBuffer == nullptr) || (pRoleBuffer == nullptr) || (pLanguageIdentifierBuffer == nullptr);
		if (isCacheCall) {
			pILoginHandler->GetUserProperties(sUsername, sUUID, sDescription, sRole, sLanguageIdentifier);

			pILoginHandler->_setCache (new ParameterCache_4<std::string, std::string, std::string, std::string> (sUUID, sDescription, sRole, sLanguageIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<std::string, std::string, std::string, std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID, sDescription, sRole, sLanguageIdentifier);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		if (pDescriptionNeededChars)
			*pDescriptionNeededChars = (LibMCData_uint32) (sDescription.size()+1);
		if (pDescriptionBuffer) {
			if (sDescription.size() >= nDescriptionBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDescription = 0; iDescription < sDescription.size(); iDescription++)
				pDescriptionBuffer[iDescription] = sDescription[iDescription];
			pDescriptionBuffer[sDescription.size()] = 0;
		}
		if (pRoleNeededChars)
			*pRoleNeededChars = (LibMCData_uint32) (sRole.size()+1);
		if (pRoleBuffer) {
			if (sRole.size() >= nRoleBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iRole = 0; iRole < sRole.size(); iRole++)
				pRoleBuffer[iRole] = sRole[iRole];
			pRoleBuffer[sRole.size()] = 0;
		}
		if (pLanguageIdentifierNeededChars)
			*pLanguageIdentifierNeededChars = (LibMCData_uint32) (sLanguageIdentifier.size()+1);
		if (pLanguageIdentifierBuffer) {
			if (sLanguageIdentifier.size() >= nLanguageIdentifierBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iLanguageIdentifier = 0; iLanguageIdentifier < sLanguageIdentifier.size(); iLanguageIdentifier++)
				pLanguageIdentifierBuffer[iLanguageIdentifier] = sLanguageIdentifier[iLanguageIdentifier];
			pLanguageIdentifierBuffer[sLanguageIdentifier.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserpropertiesbyuuid(LibMCData_LoginHandler pLoginHandler, const char * pUUID, const LibMCData_uint32 nUsernameBufferSize, LibMCData_uint32* pUsernameNeededChars, char * pUsernameBuffer, const LibMCData_uint32 nDescriptionBufferSize, LibMCData_uint32* pDescriptionNeededChars, char * pDescriptionBuffer, const LibMCData_uint32 nRoleBufferSize, LibMCData_uint32* pRoleNeededChars, char * pRoleBuffer, const LibMCData_uint32 nLanguageIdentifierBufferSize, LibMCData_uint32* pLanguageIdentifierNeededChars, char * pLanguageIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pUsernameBuffer) && !(pUsernameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pDescriptionBuffer) && !(pDescriptionNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pRoleBuffer) && !(pRoleNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pLanguageIdentifierBuffer) && !(pLanguageIdentifierNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sUsername("");
		std::string sDescription("");
		std::string sRole("");
		std::string sLanguageIdentifier("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUsernameBuffer == nullptr) || (pDescriptionBuffer == nullptr) || (pRoleBuffer == nullptr) || (pLanguageIdentifierBuffer == nullptr);
		if (isCacheCall) {
			pILoginHandler->GetUserPropertiesByUUID(sUUID, sUsername, sDescription, sRole, sLanguageIdentifier);

			pILoginHandler->_setCache (new ParameterCache_4<std::string, std::string, std::string, std::string> (sUsername, sDescription, sRole, sLanguageIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<std::string, std::string, std::string, std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUsername, sDescription, sRole, sLanguageIdentifier);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pUsernameNeededChars)
			*pUsernameNeededChars = (LibMCData_uint32) (sUsername.size()+1);
		if (pUsernameBuffer) {
			if (sUsername.size() >= nUsernameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUsername = 0; iUsername < sUsername.size(); iUsername++)
				pUsernameBuffer[iUsername] = sUsername[iUsername];
			pUsernameBuffer[sUsername.size()] = 0;
		}
		if (pDescriptionNeededChars)
			*pDescriptionNeededChars = (LibMCData_uint32) (sDescription.size()+1);
		if (pDescriptionBuffer) {
			if (sDescription.size() >= nDescriptionBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDescription = 0; iDescription < sDescription.size(); iDescription++)
				pDescriptionBuffer[iDescription] = sDescription[iDescription];
			pDescriptionBuffer[sDescription.size()] = 0;
		}
		if (pRoleNeededChars)
			*pRoleNeededChars = (LibMCData_uint32) (sRole.size()+1);
		if (pRoleBuffer) {
			if (sRole.size() >= nRoleBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iRole = 0; iRole < sRole.size(); iRole++)
				pRoleBuffer[iRole] = sRole[iRole];
			pRoleBuffer[sRole.size()] = 0;
		}
		if (pLanguageIdentifierNeededChars)
			*pLanguageIdentifierNeededChars = (LibMCData_uint32) (sLanguageIdentifier.size()+1);
		if (pLanguageIdentifierBuffer) {
			if (sLanguageIdentifier.size() >= nLanguageIdentifierBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iLanguageIdentifier = 0; iLanguageIdentifier < sLanguageIdentifier.size(); iLanguageIdentifier++)
				pLanguageIdentifierBuffer[iLanguageIdentifier] = sLanguageIdentifier[iLanguageIdentifier];
			pLanguageIdentifierBuffer[sLanguageIdentifier.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getusernamebyuuid(LibMCData_LoginHandler pLoginHandler, const char * pUUID, const LibMCData_uint32 nUsernameBufferSize, LibMCData_uint32* pUsernameNeededChars, char * pUsernameBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pUsernameBuffer) && !(pUsernameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sUsername("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUsernameBuffer == nullptr);
		if (isCacheCall) {
			sUsername = pILoginHandler->GetUsernameByUUID(sUUID);

			pILoginHandler->_setCache (new ParameterCache_1<std::string> (sUsername));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUsername);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pUsernameNeededChars)
			*pUsernameNeededChars = (LibMCData_uint32) (sUsername.size()+1);
		if (pUsernameBuffer) {
			if (sUsername.size() >= nUsernameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUsername = 0; iUsername < sUsername.size(); iUsername++)
				pUsernameBuffer[iUsername] = sUsername[iUsername];
			pUsernameBuffer[sUsername.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuseruuid(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sUUID("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pILoginHandler->GetUserUUID(sUsername);

			pILoginHandler->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserdescription(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const LibMCData_uint32 nDescriptionBufferSize, LibMCData_uint32* pDescriptionNeededChars, char * pDescriptionBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pDescriptionBuffer) && !(pDescriptionNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sDescription("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDescriptionBuffer == nullptr);
		if (isCacheCall) {
			sDescription = pILoginHandler->GetUserDescription(sUsername);

			pILoginHandler->_setCache (new ParameterCache_1<std::string> (sDescription));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sDescription);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pDescriptionNeededChars)
			*pDescriptionNeededChars = (LibMCData_uint32) (sDescription.size()+1);
		if (pDescriptionBuffer) {
			if (sDescription.size() >= nDescriptionBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDescription = 0; iDescription < sDescription.size(); iDescription++)
				pDescriptionBuffer[iDescription] = sDescription[iDescription];
			pDescriptionBuffer[sDescription.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserdescriptionbyuuid(LibMCData_LoginHandler pLoginHandler, const char * pUUID, const LibMCData_uint32 nDescriptionBufferSize, LibMCData_uint32* pDescriptionNeededChars, char * pDescriptionBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pDescriptionBuffer) && !(pDescriptionNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sDescription("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDescriptionBuffer == nullptr);
		if (isCacheCall) {
			sDescription = pILoginHandler->GetUserDescriptionByUUID(sUUID);

			pILoginHandler->_setCache (new ParameterCache_1<std::string> (sDescription));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sDescription);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pDescriptionNeededChars)
			*pDescriptionNeededChars = (LibMCData_uint32) (sDescription.size()+1);
		if (pDescriptionBuffer) {
			if (sDescription.size() >= nDescriptionBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDescription = 0; iDescription < sDescription.size(); iDescription++)
				pDescriptionBuffer[iDescription] = sDescription[iDescription];
			pDescriptionBuffer[sDescription.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserrole(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const LibMCData_uint32 nRoleBufferSize, LibMCData_uint32* pRoleNeededChars, char * pRoleBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pRoleBuffer) && !(pRoleNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sRole("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pRoleBuffer == nullptr);
		if (isCacheCall) {
			sRole = pILoginHandler->GetUserRole(sUsername);

			pILoginHandler->_setCache (new ParameterCache_1<std::string> (sRole));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sRole);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pRoleNeededChars)
			*pRoleNeededChars = (LibMCData_uint32) (sRole.size()+1);
		if (pRoleBuffer) {
			if (sRole.size() >= nRoleBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iRole = 0; iRole < sRole.size(); iRole++)
				pRoleBuffer[iRole] = sRole[iRole];
			pRoleBuffer[sRole.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserrolebyuuid(LibMCData_LoginHandler pLoginHandler, const char * pUUID, const LibMCData_uint32 nRoleBufferSize, LibMCData_uint32* pRoleNeededChars, char * pRoleBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pRoleBuffer) && !(pRoleNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sRole("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pRoleBuffer == nullptr);
		if (isCacheCall) {
			sRole = pILoginHandler->GetUserRoleByUUID(sUUID);

			pILoginHandler->_setCache (new ParameterCache_1<std::string> (sRole));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sRole);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pRoleNeededChars)
			*pRoleNeededChars = (LibMCData_uint32) (sRole.size()+1);
		if (pRoleBuffer) {
			if (sRole.size() >= nRoleBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iRole = 0; iRole < sRole.size(); iRole++)
				pRoleBuffer[iRole] = sRole[iRole];
			pRoleBuffer[sRole.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserlanguage(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const LibMCData_uint32 nLanguageIdentifierBufferSize, LibMCData_uint32* pLanguageIdentifierNeededChars, char * pLanguageIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pLanguageIdentifierBuffer) && !(pLanguageIdentifierNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sLanguageIdentifier("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pLanguageIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sLanguageIdentifier = pILoginHandler->GetUserLanguage(sUsername);

			pILoginHandler->_setCache (new ParameterCache_1<std::string> (sLanguageIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sLanguageIdentifier);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pLanguageIdentifierNeededChars)
			*pLanguageIdentifierNeededChars = (LibMCData_uint32) (sLanguageIdentifier.size()+1);
		if (pLanguageIdentifierBuffer) {
			if (sLanguageIdentifier.size() >= nLanguageIdentifierBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iLanguageIdentifier = 0; iLanguageIdentifier < sLanguageIdentifier.size(); iLanguageIdentifier++)
				pLanguageIdentifierBuffer[iLanguageIdentifier] = sLanguageIdentifier[iLanguageIdentifier];
			pLanguageIdentifierBuffer[sLanguageIdentifier.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserlanguagebyuuid(LibMCData_LoginHandler pLoginHandler, const char * pUUID, const LibMCData_uint32 nLanguageIdentifierBufferSize, LibMCData_uint32* pLanguageIdentifierNeededChars, char * pLanguageIdentifierBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pLanguageIdentifierBuffer) && !(pLanguageIdentifierNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sLanguageIdentifier("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pLanguageIdentifierBuffer == nullptr);
		if (isCacheCall) {
			sLanguageIdentifier = pILoginHandler->GetUserLanguageByUUID(sUUID);

			pILoginHandler->_setCache (new ParameterCache_1<std::string> (sLanguageIdentifier));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sLanguageIdentifier);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pLanguageIdentifierNeededChars)
			*pLanguageIdentifierNeededChars = (LibMCData_uint32) (sLanguageIdentifier.size()+1);
		if (pLanguageIdentifierBuffer) {
			if (sLanguageIdentifier.size() >= nLanguageIdentifierBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iLanguageIdentifier = 0; iLanguageIdentifier < sLanguageIdentifier.size(); iLanguageIdentifier++)
				pLanguageIdentifierBuffer[iLanguageIdentifier] = sLanguageIdentifier[iLanguageIdentifier];
			pLanguageIdentifierBuffer[sLanguageIdentifier.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_createuser(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const char * pRole, const char * pSalt, const char * pHashedPassword, const char * pDescription, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pRole == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSalt == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pHashedPassword == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sRole(pRole);
		std::string sSalt(pSalt);
		std::string sHashedPassword(pHashedPassword);
		std::string sDescription(pDescription);
		std::string sUUID("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pILoginHandler->CreateUser(sUsername, sRole, sSalt, sHashedPassword, sDescription);

			pILoginHandler->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_setuserlanguage(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const char * pLanguageIdentifier)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pLanguageIdentifier == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sLanguageIdentifier(pLanguageIdentifier);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILoginHandler->SetUserLanguage(sUsername, sLanguageIdentifier);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_setuserrole(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const char * pRole)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pRole == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sRole(pRole);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILoginHandler->SetUserRole(sUsername, sRole);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_setuserdescription(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const char * pDescription)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sDescription(pDescription);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILoginHandler->SetUserDescription(sUsername, sDescription);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_setuserpassword(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const char * pSalt, const char * pHashedPassword)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSalt == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pHashedPassword == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sSalt(pSalt);
		std::string sHashedPassword(pHashedPassword);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILoginHandler->SetUserPassword(sUsername, sSalt, sHashedPassword);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_setuserlanguagebyuuid(LibMCData_LoginHandler pLoginHandler, const char * pUUID, const char * pLanguageIdentifier)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pLanguageIdentifier == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sLanguageIdentifier(pLanguageIdentifier);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILoginHandler->SetUserLanguageByUUID(sUUID, sLanguageIdentifier);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_setuserrolebyuuid(LibMCData_LoginHandler pLoginHandler, const char * pUUID, const char * pRole)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pRole == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sRole(pRole);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILoginHandler->SetUserRoleByUUID(sUUID, sRole);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_setuserdescriptionbyuuid(LibMCData_LoginHandler pLoginHandler, const char * pUUID, const char * pDescription)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pDescription == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sDescription(pDescription);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILoginHandler->SetUserDescriptionByUUID(sUUID, sDescription);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_setuserpasswordbyuuid(LibMCData_LoginHandler pLoginHandler, const char * pUUID, const char * pSalt, const char * pHashedPassword)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSalt == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pHashedPassword == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sSalt(pSalt);
		std::string sHashedPassword(pHashedPassword);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILoginHandler->SetUserPasswordByUUID(sUUID, sSalt, sHashedPassword);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getactiveusers(LibMCData_LoginHandler pLoginHandler, LibMCData_UserList * pActiveUsers)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pActiveUsers == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseActiveUsers(nullptr);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseActiveUsers = pILoginHandler->GetActiveUsers();

		*pActiveUsers = (IBase*)(pBaseActiveUsers);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for PersistencyHandler
**************************************************************************************************************************/
LibMCDataResult libmcdata_persistencyhandler_haspersistentparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, bool * pParameterExists)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pParameterExists == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pParameterExists = pIPersistencyHandler->HasPersistentParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_getpersistentparameterdetails(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer, eLibMCDataParameterDataType * pDataType)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pDataType)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName("");
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			pIPersistencyHandler->GetPersistentParameterDetails(sUUID, sName, *pDataType);

			pIPersistencyHandler->_setCache (new ParameterCache_2<std::string, LibMCData::eParameterDataType> (sName, *pDataType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, LibMCData::eParameterDataType>*> (pIPersistencyHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName, *pDataType);
			pIPersistencyHandler->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_deletepersistentparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, bool * pParameterExisted)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pParameterExisted == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pParameterExisted = pIPersistencyHandler->DeletePersistentParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, eLibMCDataParameterDataType eDataType, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		std::string sValue(pValue);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentParameter(sUUID, sName, eDataType, sValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentstringparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		std::string sValue(pValue);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentStringParameter(sUUID, sName, sValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentuuidparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		std::string sValue(pValue);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentUUIDParameter(sUUID, sName, sValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentdoubleparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, LibMCData_double dValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentDoubleParameter(sUUID, sName, dValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentintegerparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, LibMCData_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentIntegerParameter(sUUID, sName, nValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentboolparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentBoolParameter(sUUID, sName, bValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentstringparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const LibMCData_uint32 nValueBufferSize, LibMCData_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sValue("");
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIPersistencyHandler->RetrievePersistentStringParameter(sUUID);

			pIPersistencyHandler->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIPersistencyHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIPersistencyHandler->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCData_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentuuidparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const LibMCData_uint32 nValueBufferSize, LibMCData_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sValue("");
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIPersistencyHandler->RetrievePersistentUUIDParameter(sUUID);

			pIPersistencyHandler->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIPersistencyHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIPersistencyHandler->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCData_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentdoubleparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, LibMCData_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pValue = pIPersistencyHandler->RetrievePersistentDoubleParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentintegerparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, LibMCData_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pValue = pIPersistencyHandler->RetrievePersistentIntegerParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentboolparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pValue = pIPersistencyHandler->RetrievePersistentBoolParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for InstallationInformation
**************************************************************************************************************************/
LibMCDataResult libmcdata_installationinformation_getinstallationuuid(LibMCData_InstallationInformation pInstallationInformation, const LibMCData_uint32 nInstallationUUIDBufferSize, LibMCData_uint32* pInstallationUUIDNeededChars, char * pInstallationUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pInstallationInformation;

	try {
		if ( (!pInstallationUUIDBuffer) && !(pInstallationUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sInstallationUUID("");
		IInstallationInformation* pIInstallationInformation = dynamic_cast<IInstallationInformation*>(pIBaseClass);
		if (!pIInstallationInformation)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pInstallationUUIDBuffer == nullptr);
		if (isCacheCall) {
			sInstallationUUID = pIInstallationInformation->GetInstallationUUID();

			pIInstallationInformation->_setCache (new ParameterCache_1<std::string> (sInstallationUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIInstallationInformation->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sInstallationUUID);
			pIInstallationInformation->_setCache (nullptr);
		}
		
		if (pInstallationUUIDNeededChars)
			*pInstallationUUIDNeededChars = (LibMCData_uint32) (sInstallationUUID.size()+1);
		if (pInstallationUUIDBuffer) {
			if (sInstallationUUID.size() >= nInstallationUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iInstallationUUID = 0; iInstallationUUID < sInstallationUUID.size(); iInstallationUUID++)
				pInstallationUUIDBuffer[iInstallationUUID] = sInstallationUUID[iInstallationUUID];
			pInstallationUUIDBuffer[sInstallationUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_installationinformation_getinstallationsecret(LibMCData_InstallationInformation pInstallationInformation, const LibMCData_uint32 nInstallationSecretBufferSize, LibMCData_uint32* pInstallationSecretNeededChars, char * pInstallationSecretBuffer)
{
	IBase* pIBaseClass = (IBase *)pInstallationInformation;

	try {
		if ( (!pInstallationSecretBuffer) && !(pInstallationSecretNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sInstallationSecret("");
		IInstallationInformation* pIInstallationInformation = dynamic_cast<IInstallationInformation*>(pIBaseClass);
		if (!pIInstallationInformation)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pInstallationSecretBuffer == nullptr);
		if (isCacheCall) {
			sInstallationSecret = pIInstallationInformation->GetInstallationSecret();

			pIInstallationInformation->_setCache (new ParameterCache_1<std::string> (sInstallationSecret));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIInstallationInformation->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sInstallationSecret);
			pIInstallationInformation->_setCache (nullptr);
		}
		
		if (pInstallationSecretNeededChars)
			*pInstallationSecretNeededChars = (LibMCData_uint32) (sInstallationSecret.size()+1);
		if (pInstallationSecretBuffer) {
			if (sInstallationSecret.size() >= nInstallationSecretBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iInstallationSecret = 0; iInstallationSecret < sInstallationSecret.size(); iInstallationSecret++)
				pInstallationSecretBuffer[iInstallationSecret] = sInstallationSecret[iInstallationSecret];
			pInstallationSecretBuffer[sInstallationSecret.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_installationinformation_getbasetempdirectory(LibMCData_InstallationInformation pInstallationInformation, const LibMCData_uint32 nTempDirectoryBufferSize, LibMCData_uint32* pTempDirectoryNeededChars, char * pTempDirectoryBuffer)
{
	IBase* pIBaseClass = (IBase *)pInstallationInformation;

	try {
		if ( (!pTempDirectoryBuffer) && !(pTempDirectoryNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTempDirectory("");
		IInstallationInformation* pIInstallationInformation = dynamic_cast<IInstallationInformation*>(pIBaseClass);
		if (!pIInstallationInformation)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTempDirectoryBuffer == nullptr);
		if (isCacheCall) {
			sTempDirectory = pIInstallationInformation->GetBaseTempDirectory();

			pIInstallationInformation->_setCache (new ParameterCache_1<std::string> (sTempDirectory));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIInstallationInformation->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTempDirectory);
			pIInstallationInformation->_setCache (nullptr);
		}
		
		if (pTempDirectoryNeededChars)
			*pTempDirectoryNeededChars = (LibMCData_uint32) (sTempDirectory.size()+1);
		if (pTempDirectoryBuffer) {
			if (sTempDirectory.size() >= nTempDirectoryBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTempDirectory = 0; iTempDirectory < sTempDirectory.size(); iTempDirectory++)
				pTempDirectoryBuffer[iTempDirectory] = sTempDirectory[iTempDirectory];
			pTempDirectoryBuffer[sTempDirectory.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for DataModel
**************************************************************************************************************************/
LibMCDataResult libmcdata_datamodel_initialisedatabase(LibMCData_DataModel pDataModel, const char * pDataDirectory, eLibMCDataDataBaseType eDataBaseType, const char * pConnectionString)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pDataDirectory == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pConnectionString == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDataDirectory(pDataDirectory);
		std::string sConnectionString(pConnectionString);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIDataModel->InitialiseDatabase(sDataDirectory, eDataBaseType, sConnectionString);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_getdatamodelversion(LibMCData_DataModel pDataModel, LibMCData_uint32 * pVersion)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pVersion == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pVersion = pIDataModel->GetDataModelVersion();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_getinstallationinformation(LibMCData_DataModel pDataModel, const LibMCData_uint32 nDEPRECIATEDInstallationUUIDBufferSize, LibMCData_uint32* pDEPRECIATEDInstallationUUIDNeededChars, char * pDEPRECIATEDInstallationUUIDBuffer, const LibMCData_uint32 nDEPRECIATEDInstallationSecretBufferSize, LibMCData_uint32* pDEPRECIATEDInstallationSecretNeededChars, char * pDEPRECIATEDInstallationSecretBuffer)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if ( (!pDEPRECIATEDInstallationUUIDBuffer) && !(pDEPRECIATEDInstallationUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pDEPRECIATEDInstallationSecretBuffer) && !(pDEPRECIATEDInstallationSecretNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDEPRECIATEDInstallationUUID("");
		std::string sDEPRECIATEDInstallationSecret("");
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDEPRECIATEDInstallationUUIDBuffer == nullptr) || (pDEPRECIATEDInstallationSecretBuffer == nullptr);
		if (isCacheCall) {
			pIDataModel->GetInstallationInformation(sDEPRECIATEDInstallationUUID, sDEPRECIATEDInstallationSecret);

			pIDataModel->_setCache (new ParameterCache_2<std::string, std::string> (sDEPRECIATEDInstallationUUID, sDEPRECIATEDInstallationSecret));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pIDataModel->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sDEPRECIATEDInstallationUUID, sDEPRECIATEDInstallationSecret);
			pIDataModel->_setCache (nullptr);
		}
		
		if (pDEPRECIATEDInstallationUUIDNeededChars)
			*pDEPRECIATEDInstallationUUIDNeededChars = (LibMCData_uint32) (sDEPRECIATEDInstallationUUID.size()+1);
		if (pDEPRECIATEDInstallationUUIDBuffer) {
			if (sDEPRECIATEDInstallationUUID.size() >= nDEPRECIATEDInstallationUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDEPRECIATEDInstallationUUID = 0; iDEPRECIATEDInstallationUUID < sDEPRECIATEDInstallationUUID.size(); iDEPRECIATEDInstallationUUID++)
				pDEPRECIATEDInstallationUUIDBuffer[iDEPRECIATEDInstallationUUID] = sDEPRECIATEDInstallationUUID[iDEPRECIATEDInstallationUUID];
			pDEPRECIATEDInstallationUUIDBuffer[sDEPRECIATEDInstallationUUID.size()] = 0;
		}
		if (pDEPRECIATEDInstallationSecretNeededChars)
			*pDEPRECIATEDInstallationSecretNeededChars = (LibMCData_uint32) (sDEPRECIATEDInstallationSecret.size()+1);
		if (pDEPRECIATEDInstallationSecretBuffer) {
			if (sDEPRECIATEDInstallationSecret.size() >= nDEPRECIATEDInstallationSecretBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDEPRECIATEDInstallationSecret = 0; iDEPRECIATEDInstallationSecret < sDEPRECIATEDInstallationSecret.size(); iDEPRECIATEDInstallationSecret++)
				pDEPRECIATEDInstallationSecretBuffer[iDEPRECIATEDInstallationSecret] = sDEPRECIATEDInstallationSecret[iDEPRECIATEDInstallationSecret];
			pDEPRECIATEDInstallationSecretBuffer[sDEPRECIATEDInstallationSecret.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_getinstallationinformationobject(LibMCData_DataModel pDataModel, LibMCData_InstallationInformation * pInstallationInformation)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pInstallationInformation == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseInstallationInformation(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseInstallationInformation = pIDataModel->GetInstallationInformationObject();

		*pInstallationInformation = (IBase*)(pBaseInstallationInformation);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createstorage(LibMCData_DataModel pDataModel, LibMCData_Storage * pStorage)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pStorage == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseStorage(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStorage = pIDataModel->CreateStorage();

		*pStorage = (IBase*)(pBaseStorage);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createbuildjobhandler(LibMCData_DataModel pDataModel, LibMCData_BuildJobHandler * pBuildJobHandler)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pBuildJobHandler == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseBuildJobHandler(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseBuildJobHandler = pIDataModel->CreateBuildJobHandler();

		*pBuildJobHandler = (IBase*)(pBaseBuildJobHandler);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createnewlogsession(LibMCData_DataModel pDataModel, LibMCData_LogSession * pLogSession)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pLogSession == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseLogSession(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseLogSession = pIDataModel->CreateNewLogSession();

		*pLogSession = (IBase*)(pBaseLogSession);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createjournalsession(LibMCData_DataModel pDataModel, LibMCData_JournalSession * pJournalSession)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pJournalSession == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseJournalSession(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseJournalSession = pIDataModel->CreateJournalSession();

		*pJournalSession = (IBase*)(pBaseJournalSession);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createalertsession(LibMCData_DataModel pDataModel, LibMCData_AlertSession * pAlertSession)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pAlertSession == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseAlertSession(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseAlertSession = pIDataModel->CreateAlertSession();

		*pAlertSession = (IBase*)(pBaseAlertSession);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createloginhandler(LibMCData_DataModel pDataModel, LibMCData_LoginHandler * pLoginHandler)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pLoginHandler == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseLoginHandler(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseLoginHandler = pIDataModel->CreateLoginHandler();

		*pLoginHandler = (IBase*)(pBaseLoginHandler);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createpersistencyhandler(LibMCData_DataModel pDataModel, LibMCData_PersistencyHandler * pPersistencyHandler)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pPersistencyHandler == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBasePersistencyHandler(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBasePersistencyHandler = pIDataModel->CreatePersistencyHandler();

		*pPersistencyHandler = (IBase*)(pBasePersistencyHandler);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_setbasetempdirectory(LibMCData_DataModel pDataModel, const char * pTempDirectory)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pTempDirectory == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTempDirectory(pTempDirectory);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIDataModel->SetBaseTempDirectory(sTempDirectory);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_getbasetempdirectory(LibMCData_DataModel pDataModel, const LibMCData_uint32 nTempDirectoryBufferSize, LibMCData_uint32* pTempDirectoryNeededChars, char * pTempDirectoryBuffer)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if ( (!pTempDirectoryBuffer) && !(pTempDirectoryNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTempDirectory("");
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTempDirectoryBuffer == nullptr);
		if (isCacheCall) {
			sTempDirectory = pIDataModel->GetBaseTempDirectory();

			pIDataModel->_setCache (new ParameterCache_1<std::string> (sTempDirectory));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDataModel->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTempDirectory);
			pIDataModel->_setCache (nullptr);
		}
		
		if (pTempDirectoryNeededChars)
			*pTempDirectoryNeededChars = (LibMCData_uint32) (sTempDirectory.size()+1);
		if (pTempDirectoryBuffer) {
			if (sTempDirectory.size() >= nTempDirectoryBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTempDirectory = 0; iTempDirectory < sTempDirectory.size(); iTempDirectory++)
				pTempDirectoryBuffer[iTempDirectory] = sTempDirectory[iTempDirectory];
			pTempDirectoryBuffer[sTempDirectory.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_setlogcallback(LibMCData_DataModel pDataModel, LibMCDataLogCallback pLogCallback, LibMCData_pvoid pUserData)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIDataModel->SetLogCallback(pLogCallback, pUserData);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_clearlogcallback(LibMCData_DataModel pDataModel)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIDataModel->ClearLogCallback();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_haslogcallback(LibMCData_DataModel pDataModel, bool * pHasCallback)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pHasCallback == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pHasCallback = pIDataModel->HasLogCallback();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_triggerlogcallback(LibMCData_DataModel pDataModel, const char * pLogMessage, const char * pSubSystem, eLibMCDataLogLevel eLogLevel, const char * pTimestamp)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pLogMessage == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSubSystem == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pTimestamp == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sLogMessage(pLogMessage);
		std::string sSubSystem(pSubSystem);
		std::string sTimestamp(pTimestamp);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIDataModel->TriggerLogCallback(sLogMessage, sSubSystem, eLogLevel, sTimestamp);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDataResult LibMCData::Impl::LibMCData_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDATA_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDATA_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdata_iterator_movenext") 
		*ppProcAddress = (void*) &libmcdata_iterator_movenext;
	if (sProcName == "libmcdata_iterator_moveprevious") 
		*ppProcAddress = (void*) &libmcdata_iterator_moveprevious;
	if (sProcName == "libmcdata_iterator_getcurrent") 
		*ppProcAddress = (void*) &libmcdata_iterator_getcurrent;
	if (sProcName == "libmcdata_iterator_clone") 
		*ppProcAddress = (void*) &libmcdata_iterator_clone;
	if (sProcName == "libmcdata_iterator_count") 
		*ppProcAddress = (void*) &libmcdata_iterator_count;
	if (sProcName == "libmcdata_logentrylist_count") 
		*ppProcAddress = (void*) &libmcdata_logentrylist_count;
	if (sProcName == "libmcdata_logentrylist_getentrybyindex") 
		*ppProcAddress = (void*) &libmcdata_logentrylist_getentrybyindex;
	if (sProcName == "libmcdata_logentrylist_getentrybyid") 
		*ppProcAddress = (void*) &libmcdata_logentrylist_getentrybyid;
	if (sProcName == "libmcdata_logentrylist_hasentry") 
		*ppProcAddress = (void*) &libmcdata_logentrylist_hasentry;
	if (sProcName == "libmcdata_logsession_getsessionuuid") 
		*ppProcAddress = (void*) &libmcdata_logsession_getsessionuuid;
	if (sProcName == "libmcdata_logsession_addentry") 
		*ppProcAddress = (void*) &libmcdata_logsession_addentry;
	if (sProcName == "libmcdata_logsession_getmaxlogentryid") 
		*ppProcAddress = (void*) &libmcdata_logsession_getmaxlogentryid;
	if (sProcName == "libmcdata_logsession_retrievelogentriesbyid") 
		*ppProcAddress = (void*) &libmcdata_logsession_retrievelogentriesbyid;
	if (sProcName == "libmcdata_alert_getuuid") 
		*ppProcAddress = (void*) &libmcdata_alert_getuuid;
	if (sProcName == "libmcdata_alert_getidentifier") 
		*ppProcAddress = (void*) &libmcdata_alert_getidentifier;
	if (sProcName == "libmcdata_alert_isactive") 
		*ppProcAddress = (void*) &libmcdata_alert_isactive;
	if (sProcName == "libmcdata_alert_getlevel") 
		*ppProcAddress = (void*) &libmcdata_alert_getlevel;
	if (sProcName == "libmcdata_alert_getlevelstring") 
		*ppProcAddress = (void*) &libmcdata_alert_getlevelstring;
	if (sProcName == "libmcdata_alert_getdescription") 
		*ppProcAddress = (void*) &libmcdata_alert_getdescription;
	if (sProcName == "libmcdata_alert_getdescriptionidentifier") 
		*ppProcAddress = (void*) &libmcdata_alert_getdescriptionidentifier;
	if (sProcName == "libmcdata_alert_getreadablecontextinformation") 
		*ppProcAddress = (void*) &libmcdata_alert_getreadablecontextinformation;
	if (sProcName == "libmcdata_alert_getneedsacknowledgement") 
		*ppProcAddress = (void*) &libmcdata_alert_getneedsacknowledgement;
	if (sProcName == "libmcdata_alert_gettimestamputc") 
		*ppProcAddress = (void*) &libmcdata_alert_gettimestamputc;
	if (sProcName == "libmcdata_alert_hasbeenacknowledged") 
		*ppProcAddress = (void*) &libmcdata_alert_hasbeenacknowledged;
	if (sProcName == "libmcdata_alert_getacknowledgementinformation") 
		*ppProcAddress = (void*) &libmcdata_alert_getacknowledgementinformation;
	if (sProcName == "libmcdata_alert_acknowledgeforuser") 
		*ppProcAddress = (void*) &libmcdata_alert_acknowledgeforuser;
	if (sProcName == "libmcdata_alert_deactivatealert") 
		*ppProcAddress = (void*) &libmcdata_alert_deactivatealert;
	if (sProcName == "libmcdata_alertiterator_getcurrentalert") 
		*ppProcAddress = (void*) &libmcdata_alertiterator_getcurrentalert;
	if (sProcName == "libmcdata_alertsession_addalert") 
		*ppProcAddress = (void*) &libmcdata_alertsession_addalert;
	if (sProcName == "libmcdata_alertsession_hasalert") 
		*ppProcAddress = (void*) &libmcdata_alertsession_hasalert;
	if (sProcName == "libmcdata_alertsession_getalertbyuuid") 
		*ppProcAddress = (void*) &libmcdata_alertsession_getalertbyuuid;
	if (sProcName == "libmcdata_alertsession_retrievealerts") 
		*ppProcAddress = (void*) &libmcdata_alertsession_retrievealerts;
	if (sProcName == "libmcdata_alertsession_retrievealertsbytype") 
		*ppProcAddress = (void*) &libmcdata_alertsession_retrievealertsbytype;
	if (sProcName == "libmcdata_journalsession_getsessionuuid") 
		*ppProcAddress = (void*) &libmcdata_journalsession_getsessionuuid;
	if (sProcName == "libmcdata_journalsession_writejournalchunkintegerdata") 
		*ppProcAddress = (void*) &libmcdata_journalsession_writejournalchunkintegerdata;
	if (sProcName == "libmcdata_journalsession_getchunkcapacity") 
		*ppProcAddress = (void*) &libmcdata_journalsession_getchunkcapacity;
	if (sProcName == "libmcdata_journalsession_getflushinterval") 
		*ppProcAddress = (void*) &libmcdata_journalsession_getflushinterval;
	if (sProcName == "libmcdata_storagestream_getuuid") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getuuid;
	if (sProcName == "libmcdata_storagestream_gettimestamp") 
		*ppProcAddress = (void*) &libmcdata_storagestream_gettimestamp;
	if (sProcName == "libmcdata_storagestream_getcontextidentifier") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getcontextidentifier;
	if (sProcName == "libmcdata_storagestream_getname") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getname;
	if (sProcName == "libmcdata_storagestream_getmimetype") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getmimetype;
	if (sProcName == "libmcdata_storagestream_getsha2") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getsha2;
	if (sProcName == "libmcdata_storagestream_getsize") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getsize;
	if (sProcName == "libmcdata_storagestream_getcontent") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getcontent;
	if (sProcName == "libmcdata_storagestream_getcallbacks") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getcallbacks;
	if (sProcName == "libmcdata_storage_streamisready") 
		*ppProcAddress = (void*) &libmcdata_storage_streamisready;
	if (sProcName == "libmcdata_storage_retrievestream") 
		*ppProcAddress = (void*) &libmcdata_storage_retrievestream;
	if (sProcName == "libmcdata_storage_storenewstream") 
		*ppProcAddress = (void*) &libmcdata_storage_storenewstream;
	if (sProcName == "libmcdata_storage_beginpartialstream") 
		*ppProcAddress = (void*) &libmcdata_storage_beginpartialstream;
	if (sProcName == "libmcdata_storage_storepartialstream") 
		*ppProcAddress = (void*) &libmcdata_storage_storepartialstream;
	if (sProcName == "libmcdata_storage_finishpartialstream") 
		*ppProcAddress = (void*) &libmcdata_storage_finishpartialstream;
	if (sProcName == "libmcdata_storage_finishpartialstreamblockwisesha256") 
		*ppProcAddress = (void*) &libmcdata_storage_finishpartialstreamblockwisesha256;
	if (sProcName == "libmcdata_storage_beginrandomwritestream") 
		*ppProcAddress = (void*) &libmcdata_storage_beginrandomwritestream;
	if (sProcName == "libmcdata_storage_storerandomwritestream") 
		*ppProcAddress = (void*) &libmcdata_storage_storerandomwritestream;
	if (sProcName == "libmcdata_storage_getrandomwritestreamsize") 
		*ppProcAddress = (void*) &libmcdata_storage_getrandomwritestreamsize;
	if (sProcName == "libmcdata_storage_finishrandomwritestream") 
		*ppProcAddress = (void*) &libmcdata_storage_finishrandomwritestream;
	if (sProcName == "libmcdata_storage_getmaxstreamsize") 
		*ppProcAddress = (void*) &libmcdata_storage_getmaxstreamsize;
	if (sProcName == "libmcdata_storage_contenttypeisaccepted") 
		*ppProcAddress = (void*) &libmcdata_storage_contenttypeisaccepted;
	if (sProcName == "libmcdata_storage_streamisimage") 
		*ppProcAddress = (void*) &libmcdata_storage_streamisimage;
	if (sProcName == "libmcdata_storage_createdownloadticket") 
		*ppProcAddress = (void*) &libmcdata_storage_createdownloadticket;
	if (sProcName == "libmcdata_storage_requestdownloadticket") 
		*ppProcAddress = (void*) &libmcdata_storage_requestdownloadticket;
	if (sProcName == "libmcdata_storage_attachstreamtojournal") 
		*ppProcAddress = (void*) &libmcdata_storage_attachstreamtojournal;
	if (sProcName == "libmcdata_buildjobdata_getdatauuid") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getdatauuid;
	if (sProcName == "libmcdata_buildjobdata_getjobuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getjobuuid;
	if (sProcName == "libmcdata_buildjobdata_getname") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getname;
	if (sProcName == "libmcdata_buildjobdata_getcontextidentifier") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getcontextidentifier;
	if (sProcName == "libmcdata_buildjobdata_gettimestamp") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_gettimestamp;
	if (sProcName == "libmcdata_buildjobdata_getstoragestream") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getstoragestream;
	if (sProcName == "libmcdata_buildjobdata_getstoragestreamsha2") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getstoragestreamsha2;
	if (sProcName == "libmcdata_buildjobdata_getstoragestreamsize") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getstoragestreamsize;
	if (sProcName == "libmcdata_buildjobdata_getdatatype") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getdatatype;
	if (sProcName == "libmcdata_buildjobdata_getdatatypeasstring") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getdatatypeasstring;
	if (sProcName == "libmcdata_buildjobdata_getmimetype") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getmimetype;
	if (sProcName == "libmcdata_buildjobdataiterator_getcurrentjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjobdataiterator_getcurrentjobdata;
	if (sProcName == "libmcdata_buildjobexecution_getexecutionuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_getexecutionuuid;
	if (sProcName == "libmcdata_buildjobexecution_getjobuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_getjobuuid;
	if (sProcName == "libmcdata_buildjobexecution_getstatus") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_getstatus;
	if (sProcName == "libmcdata_buildjobexecution_changestatus") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_changestatus;
	if (sProcName == "libmcdata_buildjobexecution_getdescription") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_getdescription;
	if (sProcName == "libmcdata_buildjobexecution_setdescription") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_setdescription;
	if (sProcName == "libmcdata_buildjobexecution_getjournaluuid") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_getjournaluuid;
	if (sProcName == "libmcdata_buildjobexecution_getuseruuid") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_getuseruuid;
	if (sProcName == "libmcdata_buildjobexecution_getstarttimestampinmicroseconds") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_getstarttimestampinmicroseconds;
	if (sProcName == "libmcdata_buildjobexecution_getendtimestampinmicroseconds") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_getendtimestampinmicroseconds;
	if (sProcName == "libmcdata_buildjobexecution_computeelapsedtimeinmicroseconds") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecution_computeelapsedtimeinmicroseconds;
	if (sProcName == "libmcdata_buildjobexecutioniterator_getcurrentjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjobexecutioniterator_getcurrentjobdata;
	if (sProcName == "libmcdata_buildjob_getuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getuuid;
	if (sProcName == "libmcdata_buildjob_getname") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getname;
	if (sProcName == "libmcdata_buildjob_getstatus") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getstatus;
	if (sProcName == "libmcdata_buildjob_getlayercount") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getlayercount;
	if (sProcName == "libmcdata_buildjob_gettimestamp") 
		*ppProcAddress = (void*) &libmcdata_buildjob_gettimestamp;
	if (sProcName == "libmcdata_buildjob_getstoragestream") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getstoragestream;
	if (sProcName == "libmcdata_buildjob_getstoragestreamuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getstoragestreamuuid;
	if (sProcName == "libmcdata_buildjob_startvalidating") 
		*ppProcAddress = (void*) &libmcdata_buildjob_startvalidating;
	if (sProcName == "libmcdata_buildjob_finishvalidating") 
		*ppProcAddress = (void*) &libmcdata_buildjob_finishvalidating;
	if (sProcName == "libmcdata_buildjob_archivejob") 
		*ppProcAddress = (void*) &libmcdata_buildjob_archivejob;
	if (sProcName == "libmcdata_buildjob_unarchivejob") 
		*ppProcAddress = (void*) &libmcdata_buildjob_unarchivejob;
	if (sProcName == "libmcdata_buildjob_deletejob") 
		*ppProcAddress = (void*) &libmcdata_buildjob_deletejob;
	if (sProcName == "libmcdata_buildjob_jobcanbearchived") 
		*ppProcAddress = (void*) &libmcdata_buildjob_jobcanbearchived;
	if (sProcName == "libmcdata_buildjob_addjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjob_addjobdata;
	if (sProcName == "libmcdata_buildjob_listjobdatabytype") 
		*ppProcAddress = (void*) &libmcdata_buildjob_listjobdatabytype;
	if (sProcName == "libmcdata_buildjob_listjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjob_listjobdata;
	if (sProcName == "libmcdata_buildjob_retrievejobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjob_retrievejobdata;
	if (sProcName == "libmcdata_buildjob_addmetadatastring") 
		*ppProcAddress = (void*) &libmcdata_buildjob_addmetadatastring;
	if (sProcName == "libmcdata_buildjob_hasmetadatastring") 
		*ppProcAddress = (void*) &libmcdata_buildjob_hasmetadatastring;
	if (sProcName == "libmcdata_buildjob_getmetadatastring") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getmetadatastring;
	if (sProcName == "libmcdata_buildjob_createbuildjobexecution") 
		*ppProcAddress = (void*) &libmcdata_buildjob_createbuildjobexecution;
	if (sProcName == "libmcdata_buildjob_retrievebuildjobexecution") 
		*ppProcAddress = (void*) &libmcdata_buildjob_retrievebuildjobexecution;
	if (sProcName == "libmcdata_buildjob_retrievebuildjobexecutions") 
		*ppProcAddress = (void*) &libmcdata_buildjob_retrievebuildjobexecutions;
	if (sProcName == "libmcdata_buildjob_retrievebuildjobexecutionsbystatus") 
		*ppProcAddress = (void*) &libmcdata_buildjob_retrievebuildjobexecutionsbystatus;
	if (sProcName == "libmcdata_buildjobiterator_getcurrentjob") 
		*ppProcAddress = (void*) &libmcdata_buildjobiterator_getcurrentjob;
	if (sProcName == "libmcdata_buildjobhandler_createjob") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_createjob;
	if (sProcName == "libmcdata_buildjobhandler_retrievejob") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_retrievejob;
	if (sProcName == "libmcdata_buildjobhandler_findjobofdata") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_findjobofdata;
	if (sProcName == "libmcdata_buildjobhandler_listjobsbystatus") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_listjobsbystatus;
	if (sProcName == "libmcdata_buildjobhandler_convertbuildstatustostring") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_convertbuildstatustostring;
	if (sProcName == "libmcdata_buildjobhandler_convertstringtobuildstatus") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_convertstringtobuildstatus;
	if (sProcName == "libmcdata_userlist_count") 
		*ppProcAddress = (void*) &libmcdata_userlist_count;
	if (sProcName == "libmcdata_userlist_getuserproperties") 
		*ppProcAddress = (void*) &libmcdata_userlist_getuserproperties;
	if (sProcName == "libmcdata_loginhandler_userexists") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_userexists;
	if (sProcName == "libmcdata_loginhandler_useruuidexists") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_useruuidexists;
	if (sProcName == "libmcdata_loginhandler_getuserdetails") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserdetails;
	if (sProcName == "libmcdata_loginhandler_getuserproperties") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserproperties;
	if (sProcName == "libmcdata_loginhandler_getuserpropertiesbyuuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserpropertiesbyuuid;
	if (sProcName == "libmcdata_loginhandler_getusernamebyuuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getusernamebyuuid;
	if (sProcName == "libmcdata_loginhandler_getuseruuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuseruuid;
	if (sProcName == "libmcdata_loginhandler_getuserdescription") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserdescription;
	if (sProcName == "libmcdata_loginhandler_getuserdescriptionbyuuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserdescriptionbyuuid;
	if (sProcName == "libmcdata_loginhandler_getuserrole") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserrole;
	if (sProcName == "libmcdata_loginhandler_getuserrolebyuuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserrolebyuuid;
	if (sProcName == "libmcdata_loginhandler_getuserlanguage") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserlanguage;
	if (sProcName == "libmcdata_loginhandler_getuserlanguagebyuuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserlanguagebyuuid;
	if (sProcName == "libmcdata_loginhandler_createuser") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_createuser;
	if (sProcName == "libmcdata_loginhandler_setuserlanguage") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_setuserlanguage;
	if (sProcName == "libmcdata_loginhandler_setuserrole") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_setuserrole;
	if (sProcName == "libmcdata_loginhandler_setuserdescription") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_setuserdescription;
	if (sProcName == "libmcdata_loginhandler_setuserpassword") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_setuserpassword;
	if (sProcName == "libmcdata_loginhandler_setuserlanguagebyuuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_setuserlanguagebyuuid;
	if (sProcName == "libmcdata_loginhandler_setuserrolebyuuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_setuserrolebyuuid;
	if (sProcName == "libmcdata_loginhandler_setuserdescriptionbyuuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_setuserdescriptionbyuuid;
	if (sProcName == "libmcdata_loginhandler_setuserpasswordbyuuid") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_setuserpasswordbyuuid;
	if (sProcName == "libmcdata_loginhandler_getactiveusers") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getactiveusers;
	if (sProcName == "libmcdata_persistencyhandler_haspersistentparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_haspersistentparameter;
	if (sProcName == "libmcdata_persistencyhandler_getpersistentparameterdetails") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_getpersistentparameterdetails;
	if (sProcName == "libmcdata_persistencyhandler_deletepersistentparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_deletepersistentparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentstringparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentstringparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentuuidparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentuuidparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentdoubleparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentdoubleparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentintegerparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentintegerparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentboolparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentboolparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentstringparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentstringparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentuuidparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentuuidparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentdoubleparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentdoubleparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentintegerparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentintegerparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentboolparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentboolparameter;
	if (sProcName == "libmcdata_installationinformation_getinstallationuuid") 
		*ppProcAddress = (void*) &libmcdata_installationinformation_getinstallationuuid;
	if (sProcName == "libmcdata_installationinformation_getinstallationsecret") 
		*ppProcAddress = (void*) &libmcdata_installationinformation_getinstallationsecret;
	if (sProcName == "libmcdata_installationinformation_getbasetempdirectory") 
		*ppProcAddress = (void*) &libmcdata_installationinformation_getbasetempdirectory;
	if (sProcName == "libmcdata_datamodel_initialisedatabase") 
		*ppProcAddress = (void*) &libmcdata_datamodel_initialisedatabase;
	if (sProcName == "libmcdata_datamodel_getdatamodelversion") 
		*ppProcAddress = (void*) &libmcdata_datamodel_getdatamodelversion;
	if (sProcName == "libmcdata_datamodel_getinstallationinformation") 
		*ppProcAddress = (void*) &libmcdata_datamodel_getinstallationinformation;
	if (sProcName == "libmcdata_datamodel_getinstallationinformationobject") 
		*ppProcAddress = (void*) &libmcdata_datamodel_getinstallationinformationobject;
	if (sProcName == "libmcdata_datamodel_createstorage") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createstorage;
	if (sProcName == "libmcdata_datamodel_createbuildjobhandler") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createbuildjobhandler;
	if (sProcName == "libmcdata_datamodel_createnewlogsession") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createnewlogsession;
	if (sProcName == "libmcdata_datamodel_createjournalsession") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createjournalsession;
	if (sProcName == "libmcdata_datamodel_createalertsession") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createalertsession;
	if (sProcName == "libmcdata_datamodel_createloginhandler") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createloginhandler;
	if (sProcName == "libmcdata_datamodel_createpersistencyhandler") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createpersistencyhandler;
	if (sProcName == "libmcdata_datamodel_setbasetempdirectory") 
		*ppProcAddress = (void*) &libmcdata_datamodel_setbasetempdirectory;
	if (sProcName == "libmcdata_datamodel_getbasetempdirectory") 
		*ppProcAddress = (void*) &libmcdata_datamodel_getbasetempdirectory;
	if (sProcName == "libmcdata_datamodel_setlogcallback") 
		*ppProcAddress = (void*) &libmcdata_datamodel_setlogcallback;
	if (sProcName == "libmcdata_datamodel_clearlogcallback") 
		*ppProcAddress = (void*) &libmcdata_datamodel_clearlogcallback;
	if (sProcName == "libmcdata_datamodel_haslogcallback") 
		*ppProcAddress = (void*) &libmcdata_datamodel_haslogcallback;
	if (sProcName == "libmcdata_datamodel_triggerlogcallback") 
		*ppProcAddress = (void*) &libmcdata_datamodel_triggerlogcallback;
	if (sProcName == "libmcdata_getversion") 
		*ppProcAddress = (void*) &libmcdata_getversion;
	if (sProcName == "libmcdata_getlasterror") 
		*ppProcAddress = (void*) &libmcdata_getlasterror;
	if (sProcName == "libmcdata_releaseinstance") 
		*ppProcAddress = (void*) &libmcdata_releaseinstance;
	if (sProcName == "libmcdata_acquireinstance") 
		*ppProcAddress = (void*) &libmcdata_acquireinstance;
	if (sProcName == "libmcdata_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdata_getsymbollookupmethod;
	if (sProcName == "libmcdata_createdatamodelinstance") 
		*ppProcAddress = (void*) &libmcdata_createdatamodelinstance;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDATA_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDataResult libmcdata_getversion(LibMCData_uint32 * pMajor, LibMCData_uint32 * pMinor, LibMCData_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_getlasterror(LibMCData_Base pInstance, const LibMCData_uint32 nErrorMessageBufferSize, LibMCData_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCData_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_releaseinstance(LibMCData_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_acquireinstance(LibMCData_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_getsymbollookupmethod(LibMCData_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCData::Impl::LibMCData_GetProcAddress;
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_createdatamodelinstance(LibMCData_DataModel * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDataModelInstance();

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


