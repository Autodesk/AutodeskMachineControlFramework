/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Machine Control data model library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmcdata_abi.hpp"
#include "libmcdata_interfaces.hpp"
#include "libmcdata_interfaceexception.hpp"

#include <map>

using namespace LibMCData::Impl;

LibMCDataResult handleLibMCDataException(IBase * pIBaseClass, ELibMCDataInterfaceException & Exception)
{
	LibMCDataResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDataResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDataResult errorCode = LIBMCDATA_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDataResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDataResult errorCode = LIBMCDATA_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Iterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_iterator_movenext(LibMCData_Iterator pIterator, bool * pHasNext)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasNext == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pHasNext = pIIterator->MoveNext();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_moveprevious(LibMCData_Iterator pIterator, bool * pHasPrevious)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasPrevious == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pHasPrevious = pIIterator->MovePrevious();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_getcurrent(LibMCData_Iterator pIterator, LibMCData_Base * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIIterator->GetCurrent();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_clone(LibMCData_Iterator pIterator, LibMCData_Iterator * pOutIterator)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pOutIterator == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseOutIterator(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseOutIterator = pIIterator->Clone();

		*pOutIterator = (IBase*)(pBaseOutIterator);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_count(LibMCData_Iterator pIterator, LibMCData_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pCount == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pCount = pIIterator->Count();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for LogSession
**************************************************************************************************************************/
LibMCDataResult libmcdata_logsession_addentry(LibMCData_LogSession pLogSession, const char * pMessage, const char * pSubSystem, eLibMCDataLogLevel eLogLevel, const char * pTimestamp)
{
	IBase* pIBaseClass = (IBase *)pLogSession;

	try {
		if (pMessage == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSubSystem == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pTimestamp == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMessage(pMessage);
		std::string sSubSystem(pSubSystem);
		std::string sTimestamp(pTimestamp);
		ILogSession* pILogSession = dynamic_cast<ILogSession*>(pIBaseClass);
		if (!pILogSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILogSession->AddEntry(sMessage, sSubSystem, eLogLevel, sTimestamp);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for StorageStream
**************************************************************************************************************************/
LibMCDataResult libmcdata_storagestream_getuuid(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIStorageStream->GetUUID();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_gettimestamp(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestamp("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			sTimestamp = pIStorageStream->GetTimeStamp();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestamp);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getname(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIStorageStream->GetName();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getmimetype(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nMimeTypeBufferSize, LibMCData_uint32* pMimeTypeNeededChars, char * pMimeTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pMimeTypeBuffer) && !(pMimeTypeNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMimeType("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMimeTypeBuffer == nullptr);
		if (isCacheCall) {
			sMimeType = pIStorageStream->GetMIMEType();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sMimeType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sMimeType);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pMimeTypeNeededChars)
			*pMimeTypeNeededChars = (LibMCData_uint32) (sMimeType.size()+1);
		if (pMimeTypeBuffer) {
			if (sMimeType.size() >= nMimeTypeBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMimeType = 0; iMimeType < sMimeType.size(); iMimeType++)
				pMimeTypeBuffer[iMimeType] = sMimeType[iMimeType];
			pMimeTypeBuffer[sMimeType.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getsha2(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nSHA2BufferSize, LibMCData_uint32* pSHA2NeededChars, char * pSHA2Buffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pSHA2Buffer) && !(pSHA2NeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sSHA2("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSHA2Buffer == nullptr);
		if (isCacheCall) {
			sSHA2 = pIStorageStream->GetSHA2();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sSHA2));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sSHA2);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pSHA2NeededChars)
			*pSHA2NeededChars = (LibMCData_uint32) (sSHA2.size()+1);
		if (pSHA2Buffer) {
			if (sSHA2.size() >= nSHA2BufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA2 = 0; iSHA2 < sSHA2.size(); iSHA2++)
				pSHA2Buffer[iSHA2] = sSHA2[iSHA2];
			pSHA2Buffer[sSHA2.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getsize(LibMCData_StorageStream pStorageStream, LibMCData_uint64 * pSize)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if (pSize == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pSize = pIStorageStream->GetSize();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getcontent(LibMCData_StorageStream pStorageStream, const LibMCData_uint64 nContentBufferSize, LibMCData_uint64* pContentNeededCount, LibMCData_uint8 * pContentBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ((!pContentBuffer) && !(pContentNeededCount))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorageStream->GetContent(nContentBufferSize, pContentNeededCount, pContentBuffer);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getcallbacks(LibMCData_StorageStream pStorageStream, LibMCData_pvoid * pTheReadCallback, LibMCData_pvoid * pTheSeekCallback, LibMCData_pvoid * pStreamHandle)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if (!pTheReadCallback)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pTheSeekCallback)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pStreamHandle)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorageStream->GetCallbacks(*pTheReadCallback, *pTheSeekCallback, *pStreamHandle);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Storage
**************************************************************************************************************************/
LibMCDataResult libmcdata_storage_streamisready(LibMCData_Storage pStorage, const char * pUUID, bool * pIsReady)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIsReady == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pIsReady = pIStorage->StreamIsReady(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_retrievestream(LibMCData_Storage pStorage, const char * pUUID, LibMCData_StorageStream * pStreamInstance)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStreamInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IBase* pBaseStreamInstance(nullptr);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStreamInstance = pIStorage->RetrieveStream(sUUID);

		*pStreamInstance = (IBase*)(pBaseStreamInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_storenewstream(LibMCData_Storage pStorage, const char * pUUID, const char * pContextUUID, const char * pName, const char * pMimeType, LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pMimeType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pContentBuffer) && (nContentBufferSize>0))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sContextUUID(pContextUUID);
		std::string sName(pName);
		std::string sMimeType(pMimeType);
		std::string sUserID(pUserID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->StoreNewStream(sUUID, sContextUUID, sName, sMimeType, nContentBufferSize, pContentBuffer, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_beginpartialstream(LibMCData_Storage pStorage, const char * pUUID, const char * pContextUUID, const char * pName, const char * pMimeType, LibMCData_uint64 nSize, const char * pSHA2, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pMimeType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSHA2 == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sContextUUID(pContextUUID);
		std::string sName(pName);
		std::string sMimeType(pMimeType);
		std::string sSHA2(pSHA2);
		std::string sUserID(pUserID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->BeginPartialStream(sUUID, sContextUUID, sName, sMimeType, nSize, sSHA2, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_storepartialstream(LibMCData_Storage pStorage, const char * pUUID, LibMCData_uint64 nOffset, LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pContentBuffer) && (nContentBufferSize>0))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->StorePartialStream(sUUID, nOffset, nContentBufferSize, pContentBuffer);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_finishpartialstream(LibMCData_Storage pStorage, const char * pUUID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->FinishPartialStream(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_getmaxstreamsize(LibMCData_Storage pStorage, LibMCData_uint64 * pMaxStreamSize)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pMaxStreamSize == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pMaxStreamSize = pIStorage->GetMaxStreamSize();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_contenttypeisaccepted(LibMCData_Storage pStorage, const char * pContentType, bool * pAccepted)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pContentType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pAccepted == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sContentType(pContentType);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pAccepted = pIStorage->ContentTypeIsAccepted(sContentType);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobData
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobdata_getname(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBuildJobData->GetName();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_gettimestamp(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestamp("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			sTimestamp = pIBuildJobData->GetTimeStamp();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestamp);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getstoragestream(LibMCData_BuildJobData pBuildJobData, LibMCData_StorageStream * pStreamInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if (pStreamInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseStreamInstance(nullptr);
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStreamInstance = pIBuildJobData->GetStorageStream();

		*pStreamInstance = (IBase*)(pBaseStreamInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getdatatype(LibMCData_BuildJobData pBuildJobData, eLibMCDataBuildJobDataType * pDataType)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if (pDataType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pDataType = pIBuildJobData->GetDataType();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getmimetype(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nMimeTypeBufferSize, LibMCData_uint32* pMimeTypeNeededChars, char * pMimeTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pMimeTypeBuffer) && !(pMimeTypeNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMimeType("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMimeTypeBuffer == nullptr);
		if (isCacheCall) {
			sMimeType = pIBuildJobData->GetMIMEType();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sMimeType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sMimeType);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pMimeTypeNeededChars)
			*pMimeTypeNeededChars = (LibMCData_uint32) (sMimeType.size()+1);
		if (pMimeTypeBuffer) {
			if (sMimeType.size() >= nMimeTypeBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMimeType = 0; iMimeType < sMimeType.size(); iMimeType++)
				pMimeTypeBuffer[iMimeType] = sMimeType[iMimeType];
			pMimeTypeBuffer[sMimeType.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobDataIterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobdataiterator_getcurrentjobdata(LibMCData_BuildJobDataIterator pBuildJobDataIterator, LibMCData_BuildJobData * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobDataIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IBuildJobDataIterator* pIBuildJobDataIterator = dynamic_cast<IBuildJobDataIterator*>(pIBaseClass);
		if (!pIBuildJobDataIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIBuildJobDataIterator->GetCurrentJobData();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJob
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjob_getuuid(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildJob->GetUUID();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getname(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBuildJob->GetName();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getstatus(LibMCData_BuildJob pBuildJob, eLibMCDataBuildJobStatus * pStatus)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pStatus == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pStatus = pIBuildJob->GetStatus();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getlayercount(LibMCData_BuildJob pBuildJob, LibMCData_uint32 * pLayerCount)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pLayerCount == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pLayerCount = pIBuildJob->GetLayerCount();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_gettimestamp(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestamp("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			sTimestamp = pIBuildJob->GetTimeStamp();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestamp);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getstoragestream(LibMCData_BuildJob pBuildJob, LibMCData_StorageStream * pStreamInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pStreamInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseStreamInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStreamInstance = pIBuildJob->GetStorageStream();

		*pStreamInstance = (IBase*)(pBaseStreamInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getstoragestreamuuid(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nStreamUUIDBufferSize, LibMCData_uint32* pStreamUUIDNeededChars, char * pStreamUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pStreamUUIDBuffer) && !(pStreamUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sStreamUUID("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStreamUUIDBuffer == nullptr);
		if (isCacheCall) {
			sStreamUUID = pIBuildJob->GetStorageStreamUUID();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sStreamUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sStreamUUID);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pStreamUUIDNeededChars)
			*pStreamUUIDNeededChars = (LibMCData_uint32) (sStreamUUID.size()+1);
		if (pStreamUUIDBuffer) {
			if (sStreamUUID.size() >= nStreamUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iStreamUUID = 0; iStreamUUID < sStreamUUID.size(); iStreamUUID++)
				pStreamUUIDBuffer[iStreamUUID] = sStreamUUID[iStreamUUID];
			pStreamUUIDBuffer[sStreamUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getbuildjoblogger(LibMCData_BuildJob pBuildJob, LibMCData_LogSession * pLogSession)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pLogSession == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseLogSession(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseLogSession = pIBuildJob->GetBuildJobLogger();

		*pLogSession = (IBase*)(pBaseLogSession);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_startvalidating(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->StartValidating();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_finishvalidating(LibMCData_BuildJob pBuildJob, LibMCData_uint32 nLayerCount)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->FinishValidating(nLayerCount);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_archivejob(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->ArchiveJob();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_unarchivejob(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->UnArchiveJob();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_deletejob(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->DeleteJob();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_jobcanbearchived(LibMCData_BuildJob pBuildJob, bool * pCanBeArchived)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pCanBeArchived == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pCanBeArchived = pIBuildJob->JobCanBeArchived();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_addjobdata(LibMCData_BuildJob pBuildJob, const char * pName, LibMCData_StorageStream pStream, eLibMCDataBuildJobDataType eDataType, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBase* pIBaseClassStream = (IBase *)pStream;
		IStorageStream* pIStream = dynamic_cast<IStorageStream*>(pIBaseClassStream);
		if (!pIStream)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		std::string sUserID(pUserID);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->AddJobData(sName, pIStream, eDataType, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_listjobdatabytype(LibMCData_BuildJob pBuildJob, eLibMCDataBuildJobDataType eDataType, LibMCData_BuildJobDataIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJob->ListJobDataByType(eDataType);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_listjobdata(LibMCData_BuildJob pBuildJob, LibMCData_BuildJobDataIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJob->ListJobData();

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobIterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobiterator_getcurrentjob(LibMCData_BuildJobIterator pBuildJobIterator, LibMCData_BuildJob * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IBuildJobIterator* pIBuildJobIterator = dynamic_cast<IBuildJobIterator*>(pIBaseClass);
		if (!pIBuildJobIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIBuildJobIterator->GetCurrentJob();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobHandler
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobhandler_createjob(LibMCData_BuildJobHandler pBuildJobHandler, const char * pJobUUID, const char * pName, const char * pUserID, const char * pStorageStreamUUID, LibMCData_BuildJob * pJobInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pJobUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStorageStreamUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pJobInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sJobUUID(pJobUUID);
		std::string sName(pName);
		std::string sUserID(pUserID);
		std::string sStorageStreamUUID(pStorageStreamUUID);
		IBase* pBaseJobInstance(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseJobInstance = pIBuildJobHandler->CreateJob(sJobUUID, sName, sUserID, sStorageStreamUUID);

		*pJobInstance = (IBase*)(pBaseJobInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_retrievejob(LibMCData_BuildJobHandler pBuildJobHandler, const char * pJobUUID, LibMCData_BuildJob * pJobInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pJobUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pJobInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sJobUUID(pJobUUID);
		IBase* pBaseJobInstance(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseJobInstance = pIBuildJobHandler->RetrieveJob(sJobUUID);

		*pJobInstance = (IBase*)(pBaseJobInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_listjobsbystatus(LibMCData_BuildJobHandler pBuildJobHandler, eLibMCDataBuildJobStatus eStatus, LibMCData_BuildJobIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJobHandler->ListJobsByStatus(eStatus);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_convertbuildstatustostring(LibMCData_BuildJobHandler pBuildJobHandler, eLibMCDataBuildJobStatus eStatus, const LibMCData_uint32 nStringBufferSize, LibMCData_uint32* pStringNeededChars, char * pStringBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if ( (!pStringBuffer) && !(pStringNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sString("");
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStringBuffer == nullptr);
		if (isCacheCall) {
			sString = pIBuildJobHandler->ConvertBuildStatusToString(eStatus);

			pIBuildJobHandler->_setCache (new ParameterCache_1<std::string> (sString));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sString);
			pIBuildJobHandler->_setCache (nullptr);
		}
		
		if (pStringNeededChars)
			*pStringNeededChars = (LibMCData_uint32) (sString.size()+1);
		if (pStringBuffer) {
			if (sString.size() >= nStringBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iString = 0; iString < sString.size(); iString++)
				pStringBuffer[iString] = sString[iString];
			pStringBuffer[sString.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_convertstringtobuildstatus(LibMCData_BuildJobHandler pBuildJobHandler, const char * pString, eLibMCDataBuildJobStatus * pStatus)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pString == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStatus == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sString(pString);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pStatus = pIBuildJobHandler->ConvertStringToBuildStatus(sString);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for DataModel
**************************************************************************************************************************/
LibMCDataResult libmcdata_datamodel_initialisedatabase(LibMCData_DataModel pDataModel, const char * pDataDirectory, eLibMCDataDataBaseType eDataBaseType, const char * pConnectionString)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pDataDirectory == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pConnectionString == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDataDirectory(pDataDirectory);
		std::string sConnectionString(pConnectionString);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIDataModel->InitialiseDatabase(sDataDirectory, eDataBaseType, sConnectionString);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_getdatamodelversion(LibMCData_DataModel pDataModel, LibMCData_uint32 * pVersion)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pVersion == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pVersion = pIDataModel->GetDataModelVersion();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createstorage(LibMCData_DataModel pDataModel, LibMCData_Storage * pStorage)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pStorage == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseStorage(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStorage = pIDataModel->CreateStorage();

		*pStorage = (IBase*)(pBaseStorage);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createbuildjobhandler(LibMCData_DataModel pDataModel, LibMCData_BuildJobHandler * pBuildJobHandler)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pBuildJobHandler == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseBuildJobHandler(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseBuildJobHandler = pIDataModel->CreateBuildJobHandler();

		*pBuildJobHandler = (IBase*)(pBaseBuildJobHandler);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createnewlogsession(LibMCData_DataModel pDataModel, LibMCData_LogSession * pLogSession)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pLogSession == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseLogSession(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseLogSession = pIDataModel->CreateNewLogSession();

		*pLogSession = (IBase*)(pBaseLogSession);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDataResult LibMCData::Impl::LibMCData_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDATA_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDATA_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdata_iterator_movenext") 
		*ppProcAddress = (void*) &libmcdata_iterator_movenext;
	if (sProcName == "libmcdata_iterator_moveprevious") 
		*ppProcAddress = (void*) &libmcdata_iterator_moveprevious;
	if (sProcName == "libmcdata_iterator_getcurrent") 
		*ppProcAddress = (void*) &libmcdata_iterator_getcurrent;
	if (sProcName == "libmcdata_iterator_clone") 
		*ppProcAddress = (void*) &libmcdata_iterator_clone;
	if (sProcName == "libmcdata_iterator_count") 
		*ppProcAddress = (void*) &libmcdata_iterator_count;
	if (sProcName == "libmcdata_logsession_addentry") 
		*ppProcAddress = (void*) &libmcdata_logsession_addentry;
	if (sProcName == "libmcdata_storagestream_getuuid") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getuuid;
	if (sProcName == "libmcdata_storagestream_gettimestamp") 
		*ppProcAddress = (void*) &libmcdata_storagestream_gettimestamp;
	if (sProcName == "libmcdata_storagestream_getname") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getname;
	if (sProcName == "libmcdata_storagestream_getmimetype") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getmimetype;
	if (sProcName == "libmcdata_storagestream_getsha2") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getsha2;
	if (sProcName == "libmcdata_storagestream_getsize") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getsize;
	if (sProcName == "libmcdata_storagestream_getcontent") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getcontent;
	if (sProcName == "libmcdata_storagestream_getcallbacks") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getcallbacks;
	if (sProcName == "libmcdata_storage_streamisready") 
		*ppProcAddress = (void*) &libmcdata_storage_streamisready;
	if (sProcName == "libmcdata_storage_retrievestream") 
		*ppProcAddress = (void*) &libmcdata_storage_retrievestream;
	if (sProcName == "libmcdata_storage_storenewstream") 
		*ppProcAddress = (void*) &libmcdata_storage_storenewstream;
	if (sProcName == "libmcdata_storage_beginpartialstream") 
		*ppProcAddress = (void*) &libmcdata_storage_beginpartialstream;
	if (sProcName == "libmcdata_storage_storepartialstream") 
		*ppProcAddress = (void*) &libmcdata_storage_storepartialstream;
	if (sProcName == "libmcdata_storage_finishpartialstream") 
		*ppProcAddress = (void*) &libmcdata_storage_finishpartialstream;
	if (sProcName == "libmcdata_storage_getmaxstreamsize") 
		*ppProcAddress = (void*) &libmcdata_storage_getmaxstreamsize;
	if (sProcName == "libmcdata_storage_contenttypeisaccepted") 
		*ppProcAddress = (void*) &libmcdata_storage_contenttypeisaccepted;
	if (sProcName == "libmcdata_buildjobdata_getname") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getname;
	if (sProcName == "libmcdata_buildjobdata_gettimestamp") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_gettimestamp;
	if (sProcName == "libmcdata_buildjobdata_getstoragestream") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getstoragestream;
	if (sProcName == "libmcdata_buildjobdata_getdatatype") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getdatatype;
	if (sProcName == "libmcdata_buildjobdata_getmimetype") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getmimetype;
	if (sProcName == "libmcdata_buildjobdataiterator_getcurrentjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjobdataiterator_getcurrentjobdata;
	if (sProcName == "libmcdata_buildjob_getuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getuuid;
	if (sProcName == "libmcdata_buildjob_getname") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getname;
	if (sProcName == "libmcdata_buildjob_getstatus") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getstatus;
	if (sProcName == "libmcdata_buildjob_getlayercount") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getlayercount;
	if (sProcName == "libmcdata_buildjob_gettimestamp") 
		*ppProcAddress = (void*) &libmcdata_buildjob_gettimestamp;
	if (sProcName == "libmcdata_buildjob_getstoragestream") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getstoragestream;
	if (sProcName == "libmcdata_buildjob_getstoragestreamuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getstoragestreamuuid;
	if (sProcName == "libmcdata_buildjob_getbuildjoblogger") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getbuildjoblogger;
	if (sProcName == "libmcdata_buildjob_startvalidating") 
		*ppProcAddress = (void*) &libmcdata_buildjob_startvalidating;
	if (sProcName == "libmcdata_buildjob_finishvalidating") 
		*ppProcAddress = (void*) &libmcdata_buildjob_finishvalidating;
	if (sProcName == "libmcdata_buildjob_archivejob") 
		*ppProcAddress = (void*) &libmcdata_buildjob_archivejob;
	if (sProcName == "libmcdata_buildjob_unarchivejob") 
		*ppProcAddress = (void*) &libmcdata_buildjob_unarchivejob;
	if (sProcName == "libmcdata_buildjob_deletejob") 
		*ppProcAddress = (void*) &libmcdata_buildjob_deletejob;
	if (sProcName == "libmcdata_buildjob_jobcanbearchived") 
		*ppProcAddress = (void*) &libmcdata_buildjob_jobcanbearchived;
	if (sProcName == "libmcdata_buildjob_addjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjob_addjobdata;
	if (sProcName == "libmcdata_buildjob_listjobdatabytype") 
		*ppProcAddress = (void*) &libmcdata_buildjob_listjobdatabytype;
	if (sProcName == "libmcdata_buildjob_listjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjob_listjobdata;
	if (sProcName == "libmcdata_buildjobiterator_getcurrentjob") 
		*ppProcAddress = (void*) &libmcdata_buildjobiterator_getcurrentjob;
	if (sProcName == "libmcdata_buildjobhandler_createjob") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_createjob;
	if (sProcName == "libmcdata_buildjobhandler_retrievejob") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_retrievejob;
	if (sProcName == "libmcdata_buildjobhandler_listjobsbystatus") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_listjobsbystatus;
	if (sProcName == "libmcdata_buildjobhandler_convertbuildstatustostring") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_convertbuildstatustostring;
	if (sProcName == "libmcdata_buildjobhandler_convertstringtobuildstatus") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_convertstringtobuildstatus;
	if (sProcName == "libmcdata_datamodel_initialisedatabase") 
		*ppProcAddress = (void*) &libmcdata_datamodel_initialisedatabase;
	if (sProcName == "libmcdata_datamodel_getdatamodelversion") 
		*ppProcAddress = (void*) &libmcdata_datamodel_getdatamodelversion;
	if (sProcName == "libmcdata_datamodel_createstorage") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createstorage;
	if (sProcName == "libmcdata_datamodel_createbuildjobhandler") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createbuildjobhandler;
	if (sProcName == "libmcdata_datamodel_createnewlogsession") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createnewlogsession;
	if (sProcName == "libmcdata_getversion") 
		*ppProcAddress = (void*) &libmcdata_getversion;
	if (sProcName == "libmcdata_getlasterror") 
		*ppProcAddress = (void*) &libmcdata_getlasterror;
	if (sProcName == "libmcdata_releaseinstance") 
		*ppProcAddress = (void*) &libmcdata_releaseinstance;
	if (sProcName == "libmcdata_acquireinstance") 
		*ppProcAddress = (void*) &libmcdata_acquireinstance;
	if (sProcName == "libmcdata_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdata_getsymbollookupmethod;
	if (sProcName == "libmcdata_createdatamodelinstance") 
		*ppProcAddress = (void*) &libmcdata_createdatamodelinstance;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDATA_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDataResult libmcdata_getversion(LibMCData_uint32 * pMajor, LibMCData_uint32 * pMinor, LibMCData_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_getlasterror(LibMCData_Base pInstance, const LibMCData_uint32 nErrorMessageBufferSize, LibMCData_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCData_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_releaseinstance(LibMCData_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_acquireinstance(LibMCData_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_getsymbollookupmethod(LibMCData_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCData::Impl::LibMCData_GetProcAddress;
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_createdatamodelinstance(LibMCData_DataModel * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDataModelInstance();

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


