/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Machine Control data model library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmcdata_abi.hpp"
#include "libmcdata_interfaces.hpp"
#include "libmcdata_interfaceexception.hpp"

#include <map>

using namespace LibMCData::Impl;

LibMCDataResult handleLibMCDataException(IBase * pIBaseClass, ELibMCDataInterfaceException & Exception)
{
	LibMCDataResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDataResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCDataResult errorCode = LIBMCDATA_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCDataResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCDataResult errorCode = LIBMCDATA_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for Iterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_iterator_movenext(LibMCData_Iterator pIterator, bool * pHasNext)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasNext == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pHasNext = pIIterator->MoveNext();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_moveprevious(LibMCData_Iterator pIterator, bool * pHasPrevious)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pHasPrevious == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pHasPrevious = pIIterator->MovePrevious();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_getcurrent(LibMCData_Iterator pIterator, LibMCData_Base * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIIterator->GetCurrent();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_clone(LibMCData_Iterator pIterator, LibMCData_Iterator * pOutIterator)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pOutIterator == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseOutIterator(nullptr);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseOutIterator = pIIterator->Clone();

		*pOutIterator = (IBase*)(pBaseOutIterator);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_iterator_count(LibMCData_Iterator pIterator, LibMCData_uint64 * pCount)
{
	IBase* pIBaseClass = (IBase *)pIterator;

	try {
		if (pCount == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IIterator* pIIterator = dynamic_cast<IIterator*>(pIBaseClass);
		if (!pIIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pCount = pIIterator->Count();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for LogEntryList
**************************************************************************************************************************/
LibMCDataResult libmcdata_logentrylist_count(LibMCData_LogEntryList pLogEntryList, LibMCData_uint32 * pCount)
{
	IBase* pIBaseClass = (IBase *)pLogEntryList;

	try {
		if (pCount == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		ILogEntryList* pILogEntryList = dynamic_cast<ILogEntryList*>(pIBaseClass);
		if (!pILogEntryList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pCount = pILogEntryList->Count();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logentrylist_getentrybyindex(LibMCData_LogEntryList pLogEntryList, LibMCData_uint32 nIndex, LibMCData_uint32 * pID, const LibMCData_uint32 nMessageBufferSize, LibMCData_uint32* pMessageNeededChars, char * pMessageBuffer, const LibMCData_uint32 nSubSystemBufferSize, LibMCData_uint32* pSubSystemNeededChars, char * pSubSystemBuffer, eLibMCDataLogLevel * pLogLevel, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pLogEntryList;

	try {
		if (!pID)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pMessageBuffer) && !(pMessageNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pSubSystemBuffer) && !(pSubSystemNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pLogLevel)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMessage("");
		std::string sSubSystem("");
		std::string sTimestamp("");
		ILogEntryList* pILogEntryList = dynamic_cast<ILogEntryList*>(pIBaseClass);
		if (!pILogEntryList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMessageBuffer == nullptr) || (pSubSystemBuffer == nullptr) || (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			pILogEntryList->GetEntryByIndex(nIndex, *pID, sMessage, sSubSystem, *pLogLevel, sTimestamp);

			pILogEntryList->_setCache (new ParameterCache_5<LibMCData_uint32, std::string, std::string, LibMCData::eLogLevel, std::string> (*pID, sMessage, sSubSystem, *pLogLevel, sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_5<LibMCData_uint32, std::string, std::string, LibMCData::eLogLevel, std::string>*> (pILogEntryList->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (*pID, sMessage, sSubSystem, *pLogLevel, sTimestamp);
			pILogEntryList->_setCache (nullptr);
		}
		
		if (pMessageNeededChars)
			*pMessageNeededChars = (LibMCData_uint32) (sMessage.size()+1);
		if (pMessageBuffer) {
			if (sMessage.size() >= nMessageBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMessage = 0; iMessage < sMessage.size(); iMessage++)
				pMessageBuffer[iMessage] = sMessage[iMessage];
			pMessageBuffer[sMessage.size()] = 0;
		}
		if (pSubSystemNeededChars)
			*pSubSystemNeededChars = (LibMCData_uint32) (sSubSystem.size()+1);
		if (pSubSystemBuffer) {
			if (sSubSystem.size() >= nSubSystemBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSubSystem = 0; iSubSystem < sSubSystem.size(); iSubSystem++)
				pSubSystemBuffer[iSubSystem] = sSubSystem[iSubSystem];
			pSubSystemBuffer[sSubSystem.size()] = 0;
		}
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logentrylist_getentrybyid(LibMCData_LogEntryList pLogEntryList, LibMCData_uint32 nID, const LibMCData_uint32 nMessageBufferSize, LibMCData_uint32* pMessageNeededChars, char * pMessageBuffer, const LibMCData_uint32 nSubSystemBufferSize, LibMCData_uint32* pSubSystemNeededChars, char * pSubSystemBuffer, eLibMCDataLogLevel * pLogLevel, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pLogEntryList;

	try {
		if ( (!pMessageBuffer) && !(pMessageNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pSubSystemBuffer) && !(pSubSystemNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pLogLevel)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMessage("");
		std::string sSubSystem("");
		std::string sTimestamp("");
		ILogEntryList* pILogEntryList = dynamic_cast<ILogEntryList*>(pIBaseClass);
		if (!pILogEntryList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMessageBuffer == nullptr) || (pSubSystemBuffer == nullptr) || (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			pILogEntryList->GetEntryByID(nID, sMessage, sSubSystem, *pLogLevel, sTimestamp);

			pILogEntryList->_setCache (new ParameterCache_4<std::string, std::string, LibMCData::eLogLevel, std::string> (sMessage, sSubSystem, *pLogLevel, sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_4<std::string, std::string, LibMCData::eLogLevel, std::string>*> (pILogEntryList->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sMessage, sSubSystem, *pLogLevel, sTimestamp);
			pILogEntryList->_setCache (nullptr);
		}
		
		if (pMessageNeededChars)
			*pMessageNeededChars = (LibMCData_uint32) (sMessage.size()+1);
		if (pMessageBuffer) {
			if (sMessage.size() >= nMessageBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMessage = 0; iMessage < sMessage.size(); iMessage++)
				pMessageBuffer[iMessage] = sMessage[iMessage];
			pMessageBuffer[sMessage.size()] = 0;
		}
		if (pSubSystemNeededChars)
			*pSubSystemNeededChars = (LibMCData_uint32) (sSubSystem.size()+1);
		if (pSubSystemBuffer) {
			if (sSubSystem.size() >= nSubSystemBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSubSystem = 0; iSubSystem < sSubSystem.size(); iSubSystem++)
				pSubSystemBuffer[iSubSystem] = sSubSystem[iSubSystem];
			pSubSystemBuffer[sSubSystem.size()] = 0;
		}
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logentrylist_hasentry(LibMCData_LogEntryList pLogEntryList, LibMCData_uint32 nID, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pLogEntryList;

	try {
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		ILogEntryList* pILogEntryList = dynamic_cast<ILogEntryList*>(pIBaseClass);
		if (!pILogEntryList)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pValue = pILogEntryList->HasEntry(nID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for LogSession
**************************************************************************************************************************/
LibMCDataResult libmcdata_logsession_addentry(LibMCData_LogSession pLogSession, const char * pMessage, const char * pSubSystem, eLibMCDataLogLevel eLogLevel, const char * pTimestamp)
{
	IBase* pIBaseClass = (IBase *)pLogSession;

	try {
		if (pMessage == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSubSystem == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pTimestamp == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMessage(pMessage);
		std::string sSubSystem(pSubSystem);
		std::string sTimestamp(pTimestamp);
		ILogSession* pILogSession = dynamic_cast<ILogSession*>(pIBaseClass);
		if (!pILogSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pILogSession->AddEntry(sMessage, sSubSystem, eLogLevel, sTimestamp);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logsession_getmaxlogentryid(LibMCData_LogSession pLogSession, LibMCData_uint32 * pMaxLogID)
{
	IBase* pIBaseClass = (IBase *)pLogSession;

	try {
		if (pMaxLogID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		ILogSession* pILogSession = dynamic_cast<ILogSession*>(pIBaseClass);
		if (!pILogSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pMaxLogID = pILogSession->GetMaxLogEntryID();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_logsession_retrievelogentriesbyid(LibMCData_LogSession pLogSession, LibMCData_uint32 nMinLogID, LibMCData_uint32 nMaxLogID, eLibMCDataLogLevel eMinLogLevel, LibMCData_LogEntryList * pLogEntryList)
{
	IBase* pIBaseClass = (IBase *)pLogSession;

	try {
		if (pLogEntryList == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseLogEntryList(nullptr);
		ILogSession* pILogSession = dynamic_cast<ILogSession*>(pIBaseClass);
		if (!pILogSession)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseLogEntryList = pILogSession->RetrieveLogEntriesByID(nMinLogID, nMaxLogID, eMinLogLevel);

		*pLogEntryList = (IBase*)(pBaseLogEntryList);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for StorageStream
**************************************************************************************************************************/
LibMCDataResult libmcdata_storagestream_getuuid(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIStorageStream->GetUUID();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_gettimestamp(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestamp("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			sTimestamp = pIStorageStream->GetTimeStamp();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestamp);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getname(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIStorageStream->GetName();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getmimetype(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nMimeTypeBufferSize, LibMCData_uint32* pMimeTypeNeededChars, char * pMimeTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pMimeTypeBuffer) && !(pMimeTypeNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMimeType("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMimeTypeBuffer == nullptr);
		if (isCacheCall) {
			sMimeType = pIStorageStream->GetMIMEType();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sMimeType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sMimeType);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pMimeTypeNeededChars)
			*pMimeTypeNeededChars = (LibMCData_uint32) (sMimeType.size()+1);
		if (pMimeTypeBuffer) {
			if (sMimeType.size() >= nMimeTypeBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMimeType = 0; iMimeType < sMimeType.size(); iMimeType++)
				pMimeTypeBuffer[iMimeType] = sMimeType[iMimeType];
			pMimeTypeBuffer[sMimeType.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getsha2(LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nSHA2BufferSize, LibMCData_uint32* pSHA2NeededChars, char * pSHA2Buffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ( (!pSHA2Buffer) && !(pSHA2NeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sSHA2("");
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSHA2Buffer == nullptr);
		if (isCacheCall) {
			sSHA2 = pIStorageStream->GetSHA2();

			pIStorageStream->_setCache (new ParameterCache_1<std::string> (sSHA2));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIStorageStream->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sSHA2);
			pIStorageStream->_setCache (nullptr);
		}
		
		if (pSHA2NeededChars)
			*pSHA2NeededChars = (LibMCData_uint32) (sSHA2.size()+1);
		if (pSHA2Buffer) {
			if (sSHA2.size() >= nSHA2BufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA2 = 0; iSHA2 < sSHA2.size(); iSHA2++)
				pSHA2Buffer[iSHA2] = sSHA2[iSHA2];
			pSHA2Buffer[sSHA2.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getsize(LibMCData_StorageStream pStorageStream, LibMCData_uint64 * pSize)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if (pSize == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pSize = pIStorageStream->GetSize();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getcontent(LibMCData_StorageStream pStorageStream, const LibMCData_uint64 nContentBufferSize, LibMCData_uint64* pContentNeededCount, LibMCData_uint8 * pContentBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if ((!pContentBuffer) && !(pContentNeededCount))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorageStream->GetContent(nContentBufferSize, pContentNeededCount, pContentBuffer);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storagestream_getcallbacks(LibMCData_StorageStream pStorageStream, LibMCData_pvoid * pTheReadCallback, LibMCData_pvoid * pTheSeekCallback, LibMCData_pvoid * pStreamHandle)
{
	IBase* pIBaseClass = (IBase *)pStorageStream;

	try {
		if (!pTheReadCallback)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pTheSeekCallback)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pStreamHandle)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorageStream* pIStorageStream = dynamic_cast<IStorageStream*>(pIBaseClass);
		if (!pIStorageStream)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorageStream->GetCallbacks(*pTheReadCallback, *pTheSeekCallback, *pStreamHandle);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Storage
**************************************************************************************************************************/
LibMCDataResult libmcdata_storage_streamisready(LibMCData_Storage pStorage, const char * pUUID, bool * pIsReady)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIsReady == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pIsReady = pIStorage->StreamIsReady(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_retrievestream(LibMCData_Storage pStorage, const char * pUUID, LibMCData_StorageStream * pStreamInstance)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStreamInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IBase* pBaseStreamInstance(nullptr);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStreamInstance = pIStorage->RetrieveStream(sUUID);

		*pStreamInstance = (IBase*)(pBaseStreamInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_storenewstream(LibMCData_Storage pStorage, const char * pUUID, const char * pContextUUID, const char * pName, const char * pMimeType, LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pMimeType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pContentBuffer) && (nContentBufferSize>0))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sContextUUID(pContextUUID);
		std::string sName(pName);
		std::string sMimeType(pMimeType);
		std::string sUserID(pUserID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->StoreNewStream(sUUID, sContextUUID, sName, sMimeType, nContentBufferSize, pContentBuffer, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_beginpartialstream(LibMCData_Storage pStorage, const char * pUUID, const char * pContextUUID, const char * pName, const char * pMimeType, LibMCData_uint64 nSize, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pContextUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pMimeType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sContextUUID(pContextUUID);
		std::string sName(pName);
		std::string sMimeType(pMimeType);
		std::string sUserID(pUserID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->BeginPartialStream(sUUID, sContextUUID, sName, sMimeType, nSize, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_storepartialstream(LibMCData_Storage pStorage, const char * pUUID, LibMCData_uint64 nOffset, LibMCData_uint64 nContentBufferSize, const LibMCData_uint8 * pContentBuffer)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pContentBuffer) && (nContentBufferSize>0))
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->StorePartialStream(sUUID, nOffset, nContentBufferSize, pContentBuffer);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_finishpartialstream(LibMCData_Storage pStorage, const char * pUUID, const char * pSHA2)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pSHA2 == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sSHA2(pSHA2);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->FinishPartialStream(sUUID, sSHA2);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_finishpartialstreamblockwisesha256(LibMCData_Storage pStorage, const char * pUUID, const char * pBlockwiseSHA2)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pBlockwiseSHA2 == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sBlockwiseSHA2(pBlockwiseSHA2);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIStorage->FinishPartialStreamBlockwiseSHA256(sUUID, sBlockwiseSHA2);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_getmaxstreamsize(LibMCData_Storage pStorage, LibMCData_uint64 * pMaxStreamSize)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pMaxStreamSize == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pMaxStreamSize = pIStorage->GetMaxStreamSize();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_contenttypeisaccepted(LibMCData_Storage pStorage, const char * pContentType, bool * pAccepted)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pContentType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pAccepted == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sContentType(pContentType);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pAccepted = pIStorage->ContentTypeIsAccepted(sContentType);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_storage_streamisimage(LibMCData_Storage pStorage, const char * pUUID, bool * pIsImage)
{
	IBase* pIBaseClass = (IBase *)pStorage;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pIsImage == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IStorage* pIStorage = dynamic_cast<IStorage*>(pIBaseClass);
		if (!pIStorage)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pIsImage = pIStorage->StreamIsImage(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobData
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobdata_getdatauuid(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildJobData->GetDataUUID();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getjobuuid(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildJobData->GetJobUUID();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getname(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBuildJobData->GetName();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_gettimestamp(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestamp("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			sTimestamp = pIBuildJobData->GetTimeStamp();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestamp);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getstoragestream(LibMCData_BuildJobData pBuildJobData, LibMCData_StorageStream * pStreamInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if (pStreamInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseStreamInstance(nullptr);
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStreamInstance = pIBuildJobData->GetStorageStream();

		*pStreamInstance = (IBase*)(pBaseStreamInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getstoragestreamsha2(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nSHA2BufferSize, LibMCData_uint32* pSHA2NeededChars, char * pSHA2Buffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pSHA2Buffer) && !(pSHA2NeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sSHA2("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSHA2Buffer == nullptr);
		if (isCacheCall) {
			sSHA2 = pIBuildJobData->GetStorageStreamSHA2();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sSHA2));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sSHA2);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pSHA2NeededChars)
			*pSHA2NeededChars = (LibMCData_uint32) (sSHA2.size()+1);
		if (pSHA2Buffer) {
			if (sSHA2.size() >= nSHA2BufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSHA2 = 0; iSHA2 < sSHA2.size(); iSHA2++)
				pSHA2Buffer[iSHA2] = sSHA2[iSHA2];
			pSHA2Buffer[sSHA2.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getstoragestreamsize(LibMCData_BuildJobData pBuildJobData, LibMCData_uint64 * pSize)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if (pSize == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pSize = pIBuildJobData->GetStorageStreamSize();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getdatatype(LibMCData_BuildJobData pBuildJobData, eLibMCDataBuildJobDataType * pDataType)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if (pDataType == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pDataType = pIBuildJobData->GetDataType();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getdatatypeasstring(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nDataTypeBufferSize, LibMCData_uint32* pDataTypeNeededChars, char * pDataTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pDataTypeBuffer) && !(pDataTypeNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDataType("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pDataTypeBuffer == nullptr);
		if (isCacheCall) {
			sDataType = pIBuildJobData->GetDataTypeAsString();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sDataType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sDataType);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pDataTypeNeededChars)
			*pDataTypeNeededChars = (LibMCData_uint32) (sDataType.size()+1);
		if (pDataTypeBuffer) {
			if (sDataType.size() >= nDataTypeBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iDataType = 0; iDataType < sDataType.size(); iDataType++)
				pDataTypeBuffer[iDataType] = sDataType[iDataType];
			pDataTypeBuffer[sDataType.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobdata_getmimetype(LibMCData_BuildJobData pBuildJobData, const LibMCData_uint32 nMimeTypeBufferSize, LibMCData_uint32* pMimeTypeNeededChars, char * pMimeTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobData;

	try {
		if ( (!pMimeTypeBuffer) && !(pMimeTypeNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sMimeType("");
		IBuildJobData* pIBuildJobData = dynamic_cast<IBuildJobData*>(pIBaseClass);
		if (!pIBuildJobData)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pMimeTypeBuffer == nullptr);
		if (isCacheCall) {
			sMimeType = pIBuildJobData->GetMIMEType();

			pIBuildJobData->_setCache (new ParameterCache_1<std::string> (sMimeType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobData->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sMimeType);
			pIBuildJobData->_setCache (nullptr);
		}
		
		if (pMimeTypeNeededChars)
			*pMimeTypeNeededChars = (LibMCData_uint32) (sMimeType.size()+1);
		if (pMimeTypeBuffer) {
			if (sMimeType.size() >= nMimeTypeBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iMimeType = 0; iMimeType < sMimeType.size(); iMimeType++)
				pMimeTypeBuffer[iMimeType] = sMimeType[iMimeType];
			pMimeTypeBuffer[sMimeType.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobDataIterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobdataiterator_getcurrentjobdata(LibMCData_BuildJobDataIterator pBuildJobDataIterator, LibMCData_BuildJobData * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobDataIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IBuildJobDataIterator* pIBuildJobDataIterator = dynamic_cast<IBuildJobDataIterator*>(pIBaseClass);
		if (!pIBuildJobDataIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIBuildJobDataIterator->GetCurrentJobData();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJob
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjob_getuuid(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pUUIDBuffer) && !(pUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pUUIDBuffer == nullptr);
		if (isCacheCall) {
			sUUID = pIBuildJob->GetUUID();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sUUID);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pUUIDNeededChars)
			*pUUIDNeededChars = (LibMCData_uint32) (sUUID.size()+1);
		if (pUUIDBuffer) {
			if (sUUID.size() >= nUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iUUID = 0; iUUID < sUUID.size(); iUUID++)
				pUUIDBuffer[iUUID] = sUUID[iUUID];
			pUUIDBuffer[sUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getname(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			sName = pIBuildJob->GetName();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sName));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getstatus(LibMCData_BuildJob pBuildJob, eLibMCDataBuildJobStatus * pStatus)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pStatus == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pStatus = pIBuildJob->GetStatus();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getlayercount(LibMCData_BuildJob pBuildJob, LibMCData_uint32 * pLayerCount)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pLayerCount == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pLayerCount = pIBuildJob->GetLayerCount();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_gettimestamp(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pTimestampBuffer) && !(pTimestampNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTimestamp("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTimestampBuffer == nullptr);
		if (isCacheCall) {
			sTimestamp = pIBuildJob->GetTimeStamp();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sTimestamp));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTimestamp);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pTimestampNeededChars)
			*pTimestampNeededChars = (LibMCData_uint32) (sTimestamp.size()+1);
		if (pTimestampBuffer) {
			if (sTimestamp.size() >= nTimestampBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTimestamp = 0; iTimestamp < sTimestamp.size(); iTimestamp++)
				pTimestampBuffer[iTimestamp] = sTimestamp[iTimestamp];
			pTimestampBuffer[sTimestamp.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getstoragestream(LibMCData_BuildJob pBuildJob, LibMCData_StorageStream * pStreamInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pStreamInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseStreamInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStreamInstance = pIBuildJob->GetStorageStream();

		*pStreamInstance = (IBase*)(pBaseStreamInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getstoragestreamuuid(LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nStreamUUIDBufferSize, LibMCData_uint32* pStreamUUIDNeededChars, char * pStreamUUIDBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if ( (!pStreamUUIDBuffer) && !(pStreamUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sStreamUUID("");
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStreamUUIDBuffer == nullptr);
		if (isCacheCall) {
			sStreamUUID = pIBuildJob->GetStorageStreamUUID();

			pIBuildJob->_setCache (new ParameterCache_1<std::string> (sStreamUUID));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJob->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sStreamUUID);
			pIBuildJob->_setCache (nullptr);
		}
		
		if (pStreamUUIDNeededChars)
			*pStreamUUIDNeededChars = (LibMCData_uint32) (sStreamUUID.size()+1);
		if (pStreamUUIDBuffer) {
			if (sStreamUUID.size() >= nStreamUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iStreamUUID = 0; iStreamUUID < sStreamUUID.size(); iStreamUUID++)
				pStreamUUIDBuffer[iStreamUUID] = sStreamUUID[iStreamUUID];
			pStreamUUIDBuffer[sStreamUUID.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_getbuildjoblogger(LibMCData_BuildJob pBuildJob, LibMCData_LogSession * pLogSession)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pLogSession == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseLogSession(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseLogSession = pIBuildJob->GetBuildJobLogger();

		*pLogSession = (IBase*)(pBaseLogSession);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_startvalidating(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->StartValidating();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_finishvalidating(LibMCData_BuildJob pBuildJob, LibMCData_uint32 nLayerCount)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->FinishValidating(nLayerCount);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_archivejob(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->ArchiveJob();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_unarchivejob(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->UnArchiveJob();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_deletejob(LibMCData_BuildJob pBuildJob)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->DeleteJob();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_jobcanbearchived(LibMCData_BuildJob pBuildJob, bool * pCanBeArchived)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pCanBeArchived == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pCanBeArchived = pIBuildJob->JobCanBeArchived();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_addjobdata(LibMCData_BuildJob pBuildJob, const char * pName, LibMCData_StorageStream pStream, eLibMCDataBuildJobDataType eDataType, const char * pUserID)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IBase* pIBaseClassStream = (IBase *)pStream;
		IStorageStream* pIStream = dynamic_cast<IStorageStream*>(pIBaseClassStream);
		if (!pIStream)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		std::string sUserID(pUserID);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIBuildJob->AddJobData(sName, pIStream, eDataType, sUserID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_listjobdatabytype(LibMCData_BuildJob pBuildJob, eLibMCDataBuildJobDataType eDataType, LibMCData_BuildJobDataIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJob->ListJobDataByType(eDataType);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_listjobdata(LibMCData_BuildJob pBuildJob, LibMCData_BuildJobDataIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJob->ListJobData();

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjob_retrievejobdata(LibMCData_BuildJob pBuildJob, const char * pDataUUID, LibMCData_BuildJobData * pBuildJobData)
{
	IBase* pIBaseClass = (IBase *)pBuildJob;

	try {
		if (pDataUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pBuildJobData == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDataUUID(pDataUUID);
		IBase* pBaseBuildJobData(nullptr);
		IBuildJob* pIBuildJob = dynamic_cast<IBuildJob*>(pIBaseClass);
		if (!pIBuildJob)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseBuildJobData = pIBuildJob->RetrieveJobData(sDataUUID);

		*pBuildJobData = (IBase*)(pBaseBuildJobData);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobIterator
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobiterator_getcurrentjob(LibMCData_BuildJobIterator pBuildJobIterator, LibMCData_BuildJob * pCurrentInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobIterator;

	try {
		if (pCurrentInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseCurrentInstance(nullptr);
		IBuildJobIterator* pIBuildJobIterator = dynamic_cast<IBuildJobIterator*>(pIBaseClass);
		if (!pIBuildJobIterator)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseCurrentInstance = pIBuildJobIterator->GetCurrentJob();

		*pCurrentInstance = (IBase*)(pBaseCurrentInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for BuildJobHandler
**************************************************************************************************************************/
LibMCDataResult libmcdata_buildjobhandler_createjob(LibMCData_BuildJobHandler pBuildJobHandler, const char * pJobUUID, const char * pName, const char * pUserID, const char * pStorageStreamUUID, LibMCData_BuildJob * pJobInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pJobUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStorageStreamUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pJobInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sJobUUID(pJobUUID);
		std::string sName(pName);
		std::string sUserID(pUserID);
		std::string sStorageStreamUUID(pStorageStreamUUID);
		IBase* pBaseJobInstance(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseJobInstance = pIBuildJobHandler->CreateJob(sJobUUID, sName, sUserID, sStorageStreamUUID);

		*pJobInstance = (IBase*)(pBaseJobInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_retrievejob(LibMCData_BuildJobHandler pBuildJobHandler, const char * pJobUUID, LibMCData_BuildJob * pJobInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pJobUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pJobInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sJobUUID(pJobUUID);
		IBase* pBaseJobInstance(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseJobInstance = pIBuildJobHandler->RetrieveJob(sJobUUID);

		*pJobInstance = (IBase*)(pBaseJobInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_findjobofdata(LibMCData_BuildJobHandler pBuildJobHandler, const char * pDataUUID, LibMCData_BuildJob * pBuildJobData)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pDataUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pBuildJobData == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDataUUID(pDataUUID);
		IBase* pBaseBuildJobData(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseBuildJobData = pIBuildJobHandler->FindJobOfData(sDataUUID);

		*pBuildJobData = (IBase*)(pBaseBuildJobData);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_listjobsbystatus(LibMCData_BuildJobHandler pBuildJobHandler, eLibMCDataBuildJobStatus eStatus, LibMCData_BuildJobIterator * pIteratorInstance)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pIteratorInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseIteratorInstance(nullptr);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseIteratorInstance = pIBuildJobHandler->ListJobsByStatus(eStatus);

		*pIteratorInstance = (IBase*)(pBaseIteratorInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_convertbuildstatustostring(LibMCData_BuildJobHandler pBuildJobHandler, eLibMCDataBuildJobStatus eStatus, const LibMCData_uint32 nStringBufferSize, LibMCData_uint32* pStringNeededChars, char * pStringBuffer)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if ( (!pStringBuffer) && !(pStringNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sString("");
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pStringBuffer == nullptr);
		if (isCacheCall) {
			sString = pIBuildJobHandler->ConvertBuildStatusToString(eStatus);

			pIBuildJobHandler->_setCache (new ParameterCache_1<std::string> (sString));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIBuildJobHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sString);
			pIBuildJobHandler->_setCache (nullptr);
		}
		
		if (pStringNeededChars)
			*pStringNeededChars = (LibMCData_uint32) (sString.size()+1);
		if (pStringBuffer) {
			if (sString.size() >= nStringBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iString = 0; iString < sString.size(); iString++)
				pStringBuffer[iString] = sString[iString];
			pStringBuffer[sString.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_buildjobhandler_convertstringtobuildstatus(LibMCData_BuildJobHandler pBuildJobHandler, const char * pString, eLibMCDataBuildJobStatus * pStatus)
{
	IBase* pIBaseClass = (IBase *)pBuildJobHandler;

	try {
		if (pString == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pStatus == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sString(pString);
		IBuildJobHandler* pIBuildJobHandler = dynamic_cast<IBuildJobHandler*>(pIBaseClass);
		if (!pIBuildJobHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pStatus = pIBuildJobHandler->ConvertStringToBuildStatus(sString);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for LoginHandler
**************************************************************************************************************************/
LibMCDataResult libmcdata_loginhandler_userexists(LibMCData_LoginHandler pLoginHandler, const char * pUsername, bool * pUserExists)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pUserExists == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pUserExists = pILoginHandler->UserExists(sUsername);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_loginhandler_getuserdetails(LibMCData_LoginHandler pLoginHandler, const char * pUsername, const LibMCData_uint32 nSaltBufferSize, LibMCData_uint32* pSaltNeededChars, char * pSaltBuffer, const LibMCData_uint32 nHashedPasswordBufferSize, LibMCData_uint32* pHashedPasswordNeededChars, char * pHashedPasswordBuffer)
{
	IBase* pIBaseClass = (IBase *)pLoginHandler;

	try {
		if (pUsername == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pSaltBuffer) && !(pSaltNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pHashedPasswordBuffer) && !(pHashedPasswordNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUsername(pUsername);
		std::string sSalt("");
		std::string sHashedPassword("");
		ILoginHandler* pILoginHandler = dynamic_cast<ILoginHandler*>(pIBaseClass);
		if (!pILoginHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pSaltBuffer == nullptr) || (pHashedPasswordBuffer == nullptr);
		if (isCacheCall) {
			pILoginHandler->GetUserDetails(sUsername, sSalt, sHashedPassword);

			pILoginHandler->_setCache (new ParameterCache_2<std::string, std::string> (sSalt, sHashedPassword));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pILoginHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sSalt, sHashedPassword);
			pILoginHandler->_setCache (nullptr);
		}
		
		if (pSaltNeededChars)
			*pSaltNeededChars = (LibMCData_uint32) (sSalt.size()+1);
		if (pSaltBuffer) {
			if (sSalt.size() >= nSaltBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iSalt = 0; iSalt < sSalt.size(); iSalt++)
				pSaltBuffer[iSalt] = sSalt[iSalt];
			pSaltBuffer[sSalt.size()] = 0;
		}
		if (pHashedPasswordNeededChars)
			*pHashedPasswordNeededChars = (LibMCData_uint32) (sHashedPassword.size()+1);
		if (pHashedPasswordBuffer) {
			if (sHashedPassword.size() >= nHashedPasswordBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iHashedPassword = 0; iHashedPassword < sHashedPassword.size(); iHashedPassword++)
				pHashedPasswordBuffer[iHashedPassword] = sHashedPassword[iHashedPassword];
			pHashedPasswordBuffer[sHashedPassword.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for PersistencyHandler
**************************************************************************************************************************/
LibMCDataResult libmcdata_persistencyhandler_haspersistentparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, bool * pParameterExists)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pParameterExists == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pParameterExists = pIPersistencyHandler->HasPersistentParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_getpersistentparameterdetails(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer, eLibMCDataParameterDataType * pDataType)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pDataType)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName("");
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			pIPersistencyHandler->GetPersistentParameterDetails(sUUID, sName, *pDataType);

			pIPersistencyHandler->_setCache (new ParameterCache_2<std::string, LibMCData::eParameterDataType> (sName, *pDataType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, LibMCData::eParameterDataType>*> (pIPersistencyHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sName, *pDataType);
			pIPersistencyHandler->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMCData_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_deletepersistentparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, bool * pParameterExisted)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pParameterExisted == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pParameterExisted = pIPersistencyHandler->DeletePersistentParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, eLibMCDataParameterDataType eDataType, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		std::string sValue(pValue);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentParameter(sUUID, sName, eDataType, sValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentstringparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		std::string sValue(pValue);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentStringParameter(sUUID, sName, sValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentuuidparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, const char * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		std::string sValue(pValue);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentUUIDParameter(sUUID, sName, sValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentdoubleparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, LibMCData_double dValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentDoubleParameter(sUUID, sName, dValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentintegerparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, LibMCData_int64 nValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentIntegerParameter(sUUID, sName, nValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_storepersistentboolparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const char * pName, bool bValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pName == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sName(pName);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIPersistencyHandler->StorePersistentBoolParameter(sUUID, sName, bValue);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentstringparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const LibMCData_uint32 nValueBufferSize, LibMCData_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sValue("");
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIPersistencyHandler->RetrievePersistentStringParameter(sUUID);

			pIPersistencyHandler->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIPersistencyHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIPersistencyHandler->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCData_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentuuidparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, const LibMCData_uint32 nValueBufferSize, LibMCData_uint32* pValueNeededChars, char * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pValueBuffer) && !(pValueNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		std::string sValue("");
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pValueBuffer == nullptr);
		if (isCacheCall) {
			sValue = pIPersistencyHandler->RetrievePersistentUUIDParameter(sUUID);

			pIPersistencyHandler->_setCache (new ParameterCache_1<std::string> (sValue));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIPersistencyHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sValue);
			pIPersistencyHandler->_setCache (nullptr);
		}
		
		if (pValueNeededChars)
			*pValueNeededChars = (LibMCData_uint32) (sValue.size()+1);
		if (pValueBuffer) {
			if (sValue.size() >= nValueBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iValue = 0; iValue < sValue.size(); iValue++)
				pValueBuffer[iValue] = sValue[iValue];
			pValueBuffer[sValue.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentdoubleparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, LibMCData_double * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pValue = pIPersistencyHandler->RetrievePersistentDoubleParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentintegerparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, LibMCData_int64 * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pValue = pIPersistencyHandler->RetrievePersistentIntegerParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_persistencyhandler_retrievepersistentboolparameter(LibMCData_PersistencyHandler pPersistencyHandler, const char * pUUID, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pPersistencyHandler;

	try {
		if (pUUID == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sUUID(pUUID);
		IPersistencyHandler* pIPersistencyHandler = dynamic_cast<IPersistencyHandler*>(pIBaseClass);
		if (!pIPersistencyHandler)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pValue = pIPersistencyHandler->RetrievePersistentBoolParameter(sUUID);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for DataModel
**************************************************************************************************************************/
LibMCDataResult libmcdata_datamodel_initialisedatabase(LibMCData_DataModel pDataModel, const char * pDataDirectory, eLibMCDataDataBaseType eDataBaseType, const char * pConnectionString)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pDataDirectory == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pConnectionString == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sDataDirectory(pDataDirectory);
		std::string sConnectionString(pConnectionString);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIDataModel->InitialiseDatabase(sDataDirectory, eDataBaseType, sConnectionString);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_getdatamodelversion(LibMCData_DataModel pDataModel, LibMCData_uint32 * pVersion)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pVersion == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		*pVersion = pIDataModel->GetDataModelVersion();

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_getinstallationinformation(LibMCData_DataModel pDataModel, const LibMCData_uint32 nInstallationUUIDBufferSize, LibMCData_uint32* pInstallationUUIDNeededChars, char * pInstallationUUIDBuffer, const LibMCData_uint32 nInstallationSecretBufferSize, LibMCData_uint32* pInstallationSecretNeededChars, char * pInstallationSecretBuffer)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if ( (!pInstallationUUIDBuffer) && !(pInstallationUUIDNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if ( (!pInstallationSecretBuffer) && !(pInstallationSecretNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sInstallationUUID("");
		std::string sInstallationSecret("");
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pInstallationUUIDBuffer == nullptr) || (pInstallationSecretBuffer == nullptr);
		if (isCacheCall) {
			pIDataModel->GetInstallationInformation(sInstallationUUID, sInstallationSecret);

			pIDataModel->_setCache (new ParameterCache_2<std::string, std::string> (sInstallationUUID, sInstallationSecret));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, std::string>*> (pIDataModel->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sInstallationUUID, sInstallationSecret);
			pIDataModel->_setCache (nullptr);
		}
		
		if (pInstallationUUIDNeededChars)
			*pInstallationUUIDNeededChars = (LibMCData_uint32) (sInstallationUUID.size()+1);
		if (pInstallationUUIDBuffer) {
			if (sInstallationUUID.size() >= nInstallationUUIDBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iInstallationUUID = 0; iInstallationUUID < sInstallationUUID.size(); iInstallationUUID++)
				pInstallationUUIDBuffer[iInstallationUUID] = sInstallationUUID[iInstallationUUID];
			pInstallationUUIDBuffer[sInstallationUUID.size()] = 0;
		}
		if (pInstallationSecretNeededChars)
			*pInstallationSecretNeededChars = (LibMCData_uint32) (sInstallationSecret.size()+1);
		if (pInstallationSecretBuffer) {
			if (sInstallationSecret.size() >= nInstallationSecretBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iInstallationSecret = 0; iInstallationSecret < sInstallationSecret.size(); iInstallationSecret++)
				pInstallationSecretBuffer[iInstallationSecret] = sInstallationSecret[iInstallationSecret];
			pInstallationSecretBuffer[sInstallationSecret.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createstorage(LibMCData_DataModel pDataModel, LibMCData_Storage * pStorage)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pStorage == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseStorage(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseStorage = pIDataModel->CreateStorage();

		*pStorage = (IBase*)(pBaseStorage);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createbuildjobhandler(LibMCData_DataModel pDataModel, LibMCData_BuildJobHandler * pBuildJobHandler)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pBuildJobHandler == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseBuildJobHandler(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseBuildJobHandler = pIDataModel->CreateBuildJobHandler();

		*pBuildJobHandler = (IBase*)(pBaseBuildJobHandler);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createnewlogsession(LibMCData_DataModel pDataModel, LibMCData_LogSession * pLogSession)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pLogSession == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseLogSession(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseLogSession = pIDataModel->CreateNewLogSession();

		*pLogSession = (IBase*)(pBaseLogSession);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createloginhandler(LibMCData_DataModel pDataModel, LibMCData_LoginHandler * pLoginHandler)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pLoginHandler == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseLoginHandler(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBaseLoginHandler = pIDataModel->CreateLoginHandler();

		*pLoginHandler = (IBase*)(pBaseLoginHandler);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_createpersistencyhandler(LibMCData_DataModel pDataModel, LibMCData_PersistencyHandler * pPersistencyHandler)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pPersistencyHandler == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBasePersistencyHandler(nullptr);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pBasePersistencyHandler = pIDataModel->CreatePersistencyHandler();

		*pPersistencyHandler = (IBase*)(pBasePersistencyHandler);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_setbasetempdirectory(LibMCData_DataModel pDataModel, const char * pTempDirectory)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if (pTempDirectory == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTempDirectory(pTempDirectory);
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		pIDataModel->SetBaseTempDirectory(sTempDirectory);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_datamodel_getbasetempdirectory(LibMCData_DataModel pDataModel, const LibMCData_uint32 nTempDirectoryBufferSize, LibMCData_uint32* pTempDirectoryNeededChars, char * pTempDirectoryBuffer)
{
	IBase* pIBaseClass = (IBase *)pDataModel;

	try {
		if ( (!pTempDirectoryBuffer) && !(pTempDirectoryNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		std::string sTempDirectory("");
		IDataModel* pIDataModel = dynamic_cast<IDataModel*>(pIBaseClass);
		if (!pIDataModel)
			throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pTempDirectoryBuffer == nullptr);
		if (isCacheCall) {
			sTempDirectory = pIDataModel->GetBaseTempDirectory();

			pIDataModel->_setCache (new ParameterCache_1<std::string> (sTempDirectory));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIDataModel->_getCache ());
			if (cache == nullptr)
				throw ELibMCDataInterfaceException(LIBMCDATA_ERROR_INVALIDCAST);
			cache->retrieveData (sTempDirectory);
			pIDataModel->_setCache (nullptr);
		}
		
		if (pTempDirectoryNeededChars)
			*pTempDirectoryNeededChars = (LibMCData_uint32) (sTempDirectory.size()+1);
		if (pTempDirectoryBuffer) {
			if (sTempDirectory.size() >= nTempDirectoryBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iTempDirectory = 0; iTempDirectory < sTempDirectory.size(); iTempDirectory++)
				pTempDirectoryBuffer[iTempDirectory] = sTempDirectory[iTempDirectory];
			pTempDirectoryBuffer[sTempDirectory.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCDataResult LibMCData::Impl::LibMCData_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMCDATA_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMCDATA_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmcdata_iterator_movenext") 
		*ppProcAddress = (void*) &libmcdata_iterator_movenext;
	if (sProcName == "libmcdata_iterator_moveprevious") 
		*ppProcAddress = (void*) &libmcdata_iterator_moveprevious;
	if (sProcName == "libmcdata_iterator_getcurrent") 
		*ppProcAddress = (void*) &libmcdata_iterator_getcurrent;
	if (sProcName == "libmcdata_iterator_clone") 
		*ppProcAddress = (void*) &libmcdata_iterator_clone;
	if (sProcName == "libmcdata_iterator_count") 
		*ppProcAddress = (void*) &libmcdata_iterator_count;
	if (sProcName == "libmcdata_logentrylist_count") 
		*ppProcAddress = (void*) &libmcdata_logentrylist_count;
	if (sProcName == "libmcdata_logentrylist_getentrybyindex") 
		*ppProcAddress = (void*) &libmcdata_logentrylist_getentrybyindex;
	if (sProcName == "libmcdata_logentrylist_getentrybyid") 
		*ppProcAddress = (void*) &libmcdata_logentrylist_getentrybyid;
	if (sProcName == "libmcdata_logentrylist_hasentry") 
		*ppProcAddress = (void*) &libmcdata_logentrylist_hasentry;
	if (sProcName == "libmcdata_logsession_addentry") 
		*ppProcAddress = (void*) &libmcdata_logsession_addentry;
	if (sProcName == "libmcdata_logsession_getmaxlogentryid") 
		*ppProcAddress = (void*) &libmcdata_logsession_getmaxlogentryid;
	if (sProcName == "libmcdata_logsession_retrievelogentriesbyid") 
		*ppProcAddress = (void*) &libmcdata_logsession_retrievelogentriesbyid;
	if (sProcName == "libmcdata_storagestream_getuuid") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getuuid;
	if (sProcName == "libmcdata_storagestream_gettimestamp") 
		*ppProcAddress = (void*) &libmcdata_storagestream_gettimestamp;
	if (sProcName == "libmcdata_storagestream_getname") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getname;
	if (sProcName == "libmcdata_storagestream_getmimetype") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getmimetype;
	if (sProcName == "libmcdata_storagestream_getsha2") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getsha2;
	if (sProcName == "libmcdata_storagestream_getsize") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getsize;
	if (sProcName == "libmcdata_storagestream_getcontent") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getcontent;
	if (sProcName == "libmcdata_storagestream_getcallbacks") 
		*ppProcAddress = (void*) &libmcdata_storagestream_getcallbacks;
	if (sProcName == "libmcdata_storage_streamisready") 
		*ppProcAddress = (void*) &libmcdata_storage_streamisready;
	if (sProcName == "libmcdata_storage_retrievestream") 
		*ppProcAddress = (void*) &libmcdata_storage_retrievestream;
	if (sProcName == "libmcdata_storage_storenewstream") 
		*ppProcAddress = (void*) &libmcdata_storage_storenewstream;
	if (sProcName == "libmcdata_storage_beginpartialstream") 
		*ppProcAddress = (void*) &libmcdata_storage_beginpartialstream;
	if (sProcName == "libmcdata_storage_storepartialstream") 
		*ppProcAddress = (void*) &libmcdata_storage_storepartialstream;
	if (sProcName == "libmcdata_storage_finishpartialstream") 
		*ppProcAddress = (void*) &libmcdata_storage_finishpartialstream;
	if (sProcName == "libmcdata_storage_finishpartialstreamblockwisesha256") 
		*ppProcAddress = (void*) &libmcdata_storage_finishpartialstreamblockwisesha256;
	if (sProcName == "libmcdata_storage_getmaxstreamsize") 
		*ppProcAddress = (void*) &libmcdata_storage_getmaxstreamsize;
	if (sProcName == "libmcdata_storage_contenttypeisaccepted") 
		*ppProcAddress = (void*) &libmcdata_storage_contenttypeisaccepted;
	if (sProcName == "libmcdata_storage_streamisimage") 
		*ppProcAddress = (void*) &libmcdata_storage_streamisimage;
	if (sProcName == "libmcdata_buildjobdata_getdatauuid") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getdatauuid;
	if (sProcName == "libmcdata_buildjobdata_getjobuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getjobuuid;
	if (sProcName == "libmcdata_buildjobdata_getname") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getname;
	if (sProcName == "libmcdata_buildjobdata_gettimestamp") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_gettimestamp;
	if (sProcName == "libmcdata_buildjobdata_getstoragestream") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getstoragestream;
	if (sProcName == "libmcdata_buildjobdata_getstoragestreamsha2") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getstoragestreamsha2;
	if (sProcName == "libmcdata_buildjobdata_getstoragestreamsize") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getstoragestreamsize;
	if (sProcName == "libmcdata_buildjobdata_getdatatype") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getdatatype;
	if (sProcName == "libmcdata_buildjobdata_getdatatypeasstring") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getdatatypeasstring;
	if (sProcName == "libmcdata_buildjobdata_getmimetype") 
		*ppProcAddress = (void*) &libmcdata_buildjobdata_getmimetype;
	if (sProcName == "libmcdata_buildjobdataiterator_getcurrentjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjobdataiterator_getcurrentjobdata;
	if (sProcName == "libmcdata_buildjob_getuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getuuid;
	if (sProcName == "libmcdata_buildjob_getname") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getname;
	if (sProcName == "libmcdata_buildjob_getstatus") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getstatus;
	if (sProcName == "libmcdata_buildjob_getlayercount") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getlayercount;
	if (sProcName == "libmcdata_buildjob_gettimestamp") 
		*ppProcAddress = (void*) &libmcdata_buildjob_gettimestamp;
	if (sProcName == "libmcdata_buildjob_getstoragestream") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getstoragestream;
	if (sProcName == "libmcdata_buildjob_getstoragestreamuuid") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getstoragestreamuuid;
	if (sProcName == "libmcdata_buildjob_getbuildjoblogger") 
		*ppProcAddress = (void*) &libmcdata_buildjob_getbuildjoblogger;
	if (sProcName == "libmcdata_buildjob_startvalidating") 
		*ppProcAddress = (void*) &libmcdata_buildjob_startvalidating;
	if (sProcName == "libmcdata_buildjob_finishvalidating") 
		*ppProcAddress = (void*) &libmcdata_buildjob_finishvalidating;
	if (sProcName == "libmcdata_buildjob_archivejob") 
		*ppProcAddress = (void*) &libmcdata_buildjob_archivejob;
	if (sProcName == "libmcdata_buildjob_unarchivejob") 
		*ppProcAddress = (void*) &libmcdata_buildjob_unarchivejob;
	if (sProcName == "libmcdata_buildjob_deletejob") 
		*ppProcAddress = (void*) &libmcdata_buildjob_deletejob;
	if (sProcName == "libmcdata_buildjob_jobcanbearchived") 
		*ppProcAddress = (void*) &libmcdata_buildjob_jobcanbearchived;
	if (sProcName == "libmcdata_buildjob_addjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjob_addjobdata;
	if (sProcName == "libmcdata_buildjob_listjobdatabytype") 
		*ppProcAddress = (void*) &libmcdata_buildjob_listjobdatabytype;
	if (sProcName == "libmcdata_buildjob_listjobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjob_listjobdata;
	if (sProcName == "libmcdata_buildjob_retrievejobdata") 
		*ppProcAddress = (void*) &libmcdata_buildjob_retrievejobdata;
	if (sProcName == "libmcdata_buildjobiterator_getcurrentjob") 
		*ppProcAddress = (void*) &libmcdata_buildjobiterator_getcurrentjob;
	if (sProcName == "libmcdata_buildjobhandler_createjob") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_createjob;
	if (sProcName == "libmcdata_buildjobhandler_retrievejob") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_retrievejob;
	if (sProcName == "libmcdata_buildjobhandler_findjobofdata") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_findjobofdata;
	if (sProcName == "libmcdata_buildjobhandler_listjobsbystatus") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_listjobsbystatus;
	if (sProcName == "libmcdata_buildjobhandler_convertbuildstatustostring") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_convertbuildstatustostring;
	if (sProcName == "libmcdata_buildjobhandler_convertstringtobuildstatus") 
		*ppProcAddress = (void*) &libmcdata_buildjobhandler_convertstringtobuildstatus;
	if (sProcName == "libmcdata_loginhandler_userexists") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_userexists;
	if (sProcName == "libmcdata_loginhandler_getuserdetails") 
		*ppProcAddress = (void*) &libmcdata_loginhandler_getuserdetails;
	if (sProcName == "libmcdata_persistencyhandler_haspersistentparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_haspersistentparameter;
	if (sProcName == "libmcdata_persistencyhandler_getpersistentparameterdetails") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_getpersistentparameterdetails;
	if (sProcName == "libmcdata_persistencyhandler_deletepersistentparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_deletepersistentparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentstringparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentstringparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentuuidparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentuuidparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentdoubleparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentdoubleparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentintegerparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentintegerparameter;
	if (sProcName == "libmcdata_persistencyhandler_storepersistentboolparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_storepersistentboolparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentstringparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentstringparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentuuidparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentuuidparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentdoubleparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentdoubleparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentintegerparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentintegerparameter;
	if (sProcName == "libmcdata_persistencyhandler_retrievepersistentboolparameter") 
		*ppProcAddress = (void*) &libmcdata_persistencyhandler_retrievepersistentboolparameter;
	if (sProcName == "libmcdata_datamodel_initialisedatabase") 
		*ppProcAddress = (void*) &libmcdata_datamodel_initialisedatabase;
	if (sProcName == "libmcdata_datamodel_getdatamodelversion") 
		*ppProcAddress = (void*) &libmcdata_datamodel_getdatamodelversion;
	if (sProcName == "libmcdata_datamodel_getinstallationinformation") 
		*ppProcAddress = (void*) &libmcdata_datamodel_getinstallationinformation;
	if (sProcName == "libmcdata_datamodel_createstorage") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createstorage;
	if (sProcName == "libmcdata_datamodel_createbuildjobhandler") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createbuildjobhandler;
	if (sProcName == "libmcdata_datamodel_createnewlogsession") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createnewlogsession;
	if (sProcName == "libmcdata_datamodel_createloginhandler") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createloginhandler;
	if (sProcName == "libmcdata_datamodel_createpersistencyhandler") 
		*ppProcAddress = (void*) &libmcdata_datamodel_createpersistencyhandler;
	if (sProcName == "libmcdata_datamodel_setbasetempdirectory") 
		*ppProcAddress = (void*) &libmcdata_datamodel_setbasetempdirectory;
	if (sProcName == "libmcdata_datamodel_getbasetempdirectory") 
		*ppProcAddress = (void*) &libmcdata_datamodel_getbasetempdirectory;
	if (sProcName == "libmcdata_getversion") 
		*ppProcAddress = (void*) &libmcdata_getversion;
	if (sProcName == "libmcdata_getlasterror") 
		*ppProcAddress = (void*) &libmcdata_getlasterror;
	if (sProcName == "libmcdata_releaseinstance") 
		*ppProcAddress = (void*) &libmcdata_releaseinstance;
	if (sProcName == "libmcdata_acquireinstance") 
		*ppProcAddress = (void*) &libmcdata_acquireinstance;
	if (sProcName == "libmcdata_getsymbollookupmethod") 
		*ppProcAddress = (void*) &libmcdata_getsymbollookupmethod;
	if (sProcName == "libmcdata_createdatamodelinstance") 
		*ppProcAddress = (void*) &libmcdata_createdatamodelinstance;
	
	if (*ppProcAddress == nullptr) 
		return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMCDATA_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCDataResult libmcdata_getversion(LibMCData_uint32 * pMajor, LibMCData_uint32 * pMinor, LibMCData_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_getlasterror(LibMCData_Base pInstance, const LibMCData_uint32 nErrorMessageBufferSize, LibMCData_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMCData_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_releaseinstance(LibMCData_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_acquireinstance(LibMCData_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_getsymbollookupmethod(LibMCData_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibMCData::Impl::LibMCData_GetProcAddress;
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCDataResult libmcdata_createdatamodelinstance(LibMCData_DataModel * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ELibMCDataInterfaceException (LIBMCDATA_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateDataModelInstance();

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMCDATA_SUCCESS;
	}
	catch (ELibMCDataInterfaceException & Exception) {
		return handleLibMCDataException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


