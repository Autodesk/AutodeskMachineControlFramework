/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Machine Control library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmc_abi.hpp"
#include "libmc_interfaces.hpp"
#include "libmc_interfaceexception.hpp"

#include <map>

using namespace LibMC::Impl;

LibMCResult handleLibMCException(IBase * pIBaseClass, ELibMCInterfaceException & Exception)
{
	LibMCResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCResult errorCode = LIBMC_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCResult errorCode = LIBMC_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for APIResponse
**************************************************************************************************************************/
LibMCResult libmc_apiresponse_gethttpcode(LibMC_APIResponse pAPIResponse, LibMC_uint32 * pHTTPCode)
{
	IBase* pIBaseClass = (IBase *)pAPIResponse;

	try {
		if (pHTTPCode == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		IAPIResponse* pIAPIResponse = dynamic_cast<IAPIResponse*>(pIBaseClass);
		if (!pIAPIResponse)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		*pHTTPCode = pIAPIResponse->GetHTTPCode();

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_apiresponse_getcontenttype(LibMC_APIResponse pAPIResponse, const LibMC_uint32 nContentTypeBufferSize, LibMC_uint32* pContentTypeNeededChars, char * pContentTypeBuffer)
{
	IBase* pIBaseClass = (IBase *)pAPIResponse;

	try {
		if ( (!pContentTypeBuffer) && !(pContentTypeNeededChars) )
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sContentType("");
		IAPIResponse* pIAPIResponse = dynamic_cast<IAPIResponse*>(pIBaseClass);
		if (!pIAPIResponse)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pContentTypeBuffer == nullptr);
		if (isCacheCall) {
			sContentType = pIAPIResponse->GetContentType();

			pIAPIResponse->_setCache (new ParameterCache_1<std::string> (sContentType));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_1<std::string>*> (pIAPIResponse->_getCache ());
			if (cache == nullptr)
				throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
			cache->retrieveData (sContentType);
			pIAPIResponse->_setCache (nullptr);
		}
		
		if (pContentTypeNeededChars)
			*pContentTypeNeededChars = (LibMC_uint32) (sContentType.size()+1);
		if (pContentTypeBuffer) {
			if (sContentType.size() >= nContentTypeBufferSize)
				throw ELibMCInterfaceException (LIBMC_ERROR_BUFFERTOOSMALL);
			for (size_t iContentType = 0; iContentType < sContentType.size(); iContentType++)
				pContentTypeBuffer[iContentType] = sContentType[iContentType];
			pContentTypeBuffer[sContentType.size()] = 0;
		}
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_apiresponse_getdata(LibMC_APIResponse pAPIResponse, const LibMC_uint64 nDataBufferSize, LibMC_uint64* pDataNeededCount, LibMC_uint8 * pDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pAPIResponse;

	try {
		if ((!pDataBuffer) && !(pDataNeededCount))
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		IAPIResponse* pIAPIResponse = dynamic_cast<IAPIResponse*>(pIBaseClass);
		if (!pIAPIResponse)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIAPIResponse->GetData(nDataBufferSize, pDataNeededCount, pDataBuffer);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for MCContext
**************************************************************************************************************************/
LibMCResult libmc_mccontext_registerlibrarypath(LibMC_MCContext pMCContext, const char * pLibraryName, const char * pLibraryPath)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if (pLibraryName == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pLibraryPath == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sLibraryName(pLibraryName);
		std::string sLibraryPath(pLibraryPath);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->RegisterLibraryPath(sLibraryName, sLibraryPath);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_parseconfiguration(LibMC_MCContext pMCContext, const char * pXMLString)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if (pXMLString == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sXMLString(pXMLString);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->ParseConfiguration(sXMLString);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_startallthreads(LibMC_MCContext pMCContext)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->StartAllThreads();

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_terminateallthreads(LibMC_MCContext pMCContext)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->TerminateAllThreads();

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_loadclientpackage(LibMC_MCContext pMCContext, LibMC_uint64 nZIPStreamBufferSize, const LibMC_uint8 * pZIPStreamBuffer)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if ( (!pZIPStreamBuffer) && (nZIPStreamBufferSize>0))
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->LoadClientPackage(nZIPStreamBufferSize, pZIPStreamBuffer);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_log(LibMC_MCContext pMCContext, const char * pMessage, eLibMCLogSubSystem eSubsystem, eLibMCLogLevel eLogLevel)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if (pMessage == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sMessage(pMessage);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->Log(sMessage, eSubsystem, eLogLevel);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_handleapigetrequest(LibMC_MCContext pMCContext, const char * pURI, LibMC_APIResponse * pResponse)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if (pURI == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pResponse == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sURI(pURI);
		IBase* pBaseResponse(nullptr);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pBaseResponse = pIMCContext->HandleAPIGetRequest(sURI);

		*pResponse = (IBase*)(pBaseResponse);
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_handleapipostrequest(LibMC_MCContext pMCContext, const char * pURI, LibMC_uint64 nBodyBufferSize, const LibMC_uint8 * pBodyBuffer, LibMC_APIResponse * pResponse)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if (pURI == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if ( (!pBodyBuffer) && (nBodyBufferSize>0))
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pResponse == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sURI(pURI);
		IBase* pBaseResponse(nullptr);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pBaseResponse = pIMCContext->HandleAPIPostRequest(sURI, nBodyBufferSize, pBodyBuffer);

		*pResponse = (IBase*)(pBaseResponse);
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCResult LibMC::Impl::LibMC_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMC_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMC_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmc_apiresponse_gethttpcode") 
		*ppProcAddress = (void*) &libmc_apiresponse_gethttpcode;
	if (sProcName == "libmc_apiresponse_getcontenttype") 
		*ppProcAddress = (void*) &libmc_apiresponse_getcontenttype;
	if (sProcName == "libmc_apiresponse_getdata") 
		*ppProcAddress = (void*) &libmc_apiresponse_getdata;
	if (sProcName == "libmc_mccontext_registerlibrarypath") 
		*ppProcAddress = (void*) &libmc_mccontext_registerlibrarypath;
	if (sProcName == "libmc_mccontext_parseconfiguration") 
		*ppProcAddress = (void*) &libmc_mccontext_parseconfiguration;
	if (sProcName == "libmc_mccontext_startallthreads") 
		*ppProcAddress = (void*) &libmc_mccontext_startallthreads;
	if (sProcName == "libmc_mccontext_terminateallthreads") 
		*ppProcAddress = (void*) &libmc_mccontext_terminateallthreads;
	if (sProcName == "libmc_mccontext_loadclientpackage") 
		*ppProcAddress = (void*) &libmc_mccontext_loadclientpackage;
	if (sProcName == "libmc_mccontext_log") 
		*ppProcAddress = (void*) &libmc_mccontext_log;
	if (sProcName == "libmc_mccontext_handleapigetrequest") 
		*ppProcAddress = (void*) &libmc_mccontext_handleapigetrequest;
	if (sProcName == "libmc_mccontext_handleapipostrequest") 
		*ppProcAddress = (void*) &libmc_mccontext_handleapipostrequest;
	if (sProcName == "libmc_getversion") 
		*ppProcAddress = (void*) &libmc_getversion;
	if (sProcName == "libmc_getlasterror") 
		*ppProcAddress = (void*) &libmc_getlasterror;
	if (sProcName == "libmc_releaseinstance") 
		*ppProcAddress = (void*) &libmc_releaseinstance;
	if (sProcName == "libmc_acquireinstance") 
		*ppProcAddress = (void*) &libmc_acquireinstance;
	if (sProcName == "libmc_injectcomponent") 
		*ppProcAddress = (void*) &libmc_injectcomponent;
	if (sProcName == "libmc_createmccontext") 
		*ppProcAddress = (void*) &libmc_createmccontext;
	
	if (*ppProcAddress == nullptr) 
		return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMC_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCResult libmc_getversion(LibMC_uint32 * pMajor, LibMC_uint32 * pMinor, LibMC_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_getlasterror(LibMC_Base pInstance, const LibMC_uint32 nErrorMessageBufferSize, LibMC_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMC_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCInterfaceException (LIBMC_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_releaseinstance(LibMC_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_acquireinstance(LibMC_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_injectcomponent(const char * pNameSpace, LibMC_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCData") {
			if (CWrapper::sPLibMCDataWrapper.get() != nullptr) {
				throw ELibMCInterfaceException(LIBMC_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCDataWrapper = LibMCData::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCInterfaceException(LIBMC_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_createmccontext(LibMCData_DataModel pDataModel, LibMC_MCContext * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		LibMCData::PDataModel pIDataModel = std::make_shared<LibMCData::CDataModel>(CWrapper::sPLibMCDataWrapper.get(), pDataModel);
		CWrapper::sPLibMCDataWrapper->AcquireInstance(pIDataModel.get());
		if (!pIDataModel)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateMCContext(pIDataModel);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


