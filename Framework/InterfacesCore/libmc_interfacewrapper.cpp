/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of Machine Control library. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "libmc_abi.hpp"
#include "libmc_interfaces.hpp"
#include "libmc_interfaceexception.hpp"

#include <map>

using namespace LibMC::Impl;

LibMCResult handleLibMCException(IBase * pIBaseClass, ELibMCInterfaceException & Exception)
{
	LibMCResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibMCResult errorCode = LIBMC_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibMCResult handleUnhandledException(IBase * pIBaseClass)
{
	LibMCResult errorCode = LIBMC_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for APIRequestHandler
**************************************************************************************************************************/
LibMCResult libmc_apirequesthandler_expectsrawbody(LibMC_APIRequestHandler pAPIRequestHandler, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pAPIRequestHandler;

	try {
		if (pValue == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		IAPIRequestHandler* pIAPIRequestHandler = dynamic_cast<IAPIRequestHandler*>(pIBaseClass);
		if (!pIAPIRequestHandler)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		*pValue = pIAPIRequestHandler->ExpectsRawBody();

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_apirequesthandler_expectsformdata(LibMC_APIRequestHandler pAPIRequestHandler, LibMC_uint32 * pFieldCount, bool * pValue)
{
	IBase* pIBaseClass = (IBase *)pAPIRequestHandler;

	try {
		if (!pFieldCount)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pValue == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		IAPIRequestHandler* pIAPIRequestHandler = dynamic_cast<IAPIRequestHandler*>(pIBaseClass);
		if (!pIAPIRequestHandler)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		*pValue = pIAPIRequestHandler->ExpectsFormData(*pFieldCount);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_apirequesthandler_getformdatadetails(LibMC_APIRequestHandler pAPIRequestHandler, LibMC_uint32 nFieldIndex, const LibMC_uint32 nNameBufferSize, LibMC_uint32* pNameNeededChars, char * pNameBuffer, bool * pIsFile, bool * pMandatory)
{
	IBase* pIBaseClass = (IBase *)pAPIRequestHandler;

	try {
		if ( (!pNameBuffer) && !(pNameNeededChars) )
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (!pIsFile)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (!pMandatory)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sName("");
		IAPIRequestHandler* pIAPIRequestHandler = dynamic_cast<IAPIRequestHandler*>(pIBaseClass);
		if (!pIAPIRequestHandler)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pNameBuffer == nullptr);
		if (isCacheCall) {
			pIAPIRequestHandler->GetFormDataDetails(nFieldIndex, sName, *pIsFile, *pMandatory);

			pIAPIRequestHandler->_setCache (new ParameterCache_3<std::string, bool, bool> (sName, *pIsFile, *pMandatory));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_3<std::string, bool, bool>*> (pIAPIRequestHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
			cache->retrieveData (sName, *pIsFile, *pMandatory);
			pIAPIRequestHandler->_setCache (nullptr);
		}
		
		if (pNameNeededChars)
			*pNameNeededChars = (LibMC_uint32) (sName.size()+1);
		if (pNameBuffer) {
			if (sName.size() >= nNameBufferSize)
				throw ELibMCInterfaceException (LIBMC_ERROR_BUFFERTOOSMALL);
			for (size_t iName = 0; iName < sName.size(); iName++)
				pNameBuffer[iName] = sName[iName];
			pNameBuffer[sName.size()] = 0;
		}
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_apirequesthandler_setformdatafield(LibMC_APIRequestHandler pAPIRequestHandler, const char * pName, LibMC_uint64 nDataFieldBufferSize, const LibMC_uint8 * pDataFieldBuffer)
{
	IBase* pIBaseClass = (IBase *)pAPIRequestHandler;

	try {
		if (pName == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if ( (!pDataFieldBuffer) && (nDataFieldBufferSize>0))
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sName(pName);
		IAPIRequestHandler* pIAPIRequestHandler = dynamic_cast<IAPIRequestHandler*>(pIBaseClass);
		if (!pIAPIRequestHandler)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIAPIRequestHandler->SetFormDataField(sName, nDataFieldBufferSize, pDataFieldBuffer);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_apirequesthandler_setformstringfield(LibMC_APIRequestHandler pAPIRequestHandler, const char * pName, const char * pString)
{
	IBase* pIBaseClass = (IBase *)pAPIRequestHandler;

	try {
		if (pName == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pString == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sName(pName);
		std::string sString(pString);
		IAPIRequestHandler* pIAPIRequestHandler = dynamic_cast<IAPIRequestHandler*>(pIBaseClass);
		if (!pIAPIRequestHandler)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIAPIRequestHandler->SetFormStringField(sName, sString);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_apirequesthandler_handle(LibMC_APIRequestHandler pAPIRequestHandler, LibMC_uint64 nRawBodyBufferSize, const LibMC_uint8 * pRawBodyBuffer, const LibMC_uint32 nContentTypeBufferSize, LibMC_uint32* pContentTypeNeededChars, char * pContentTypeBuffer, LibMC_uint32 * pHTTPCode)
{
	IBase* pIBaseClass = (IBase *)pAPIRequestHandler;

	try {
		if ( (!pRawBodyBuffer) && (nRawBodyBufferSize>0))
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if ( (!pContentTypeBuffer) && !(pContentTypeNeededChars) )
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (!pHTTPCode)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sContentType("");
		IAPIRequestHandler* pIAPIRequestHandler = dynamic_cast<IAPIRequestHandler*>(pIBaseClass);
		if (!pIAPIRequestHandler)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		bool isCacheCall = (pContentTypeBuffer == nullptr);
		if (isCacheCall) {
			pIAPIRequestHandler->Handle(nRawBodyBufferSize, pRawBodyBuffer, sContentType, *pHTTPCode);

			pIAPIRequestHandler->_setCache (new ParameterCache_2<std::string, LibMC_uint32> (sContentType, *pHTTPCode));
		}
		else {
			auto cache = dynamic_cast<ParameterCache_2<std::string, LibMC_uint32>*> (pIAPIRequestHandler->_getCache ());
			if (cache == nullptr)
				throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
			cache->retrieveData (sContentType, *pHTTPCode);
			pIAPIRequestHandler->_setCache (nullptr);
		}
		
		if (pContentTypeNeededChars)
			*pContentTypeNeededChars = (LibMC_uint32) (sContentType.size()+1);
		if (pContentTypeBuffer) {
			if (sContentType.size() >= nContentTypeBufferSize)
				throw ELibMCInterfaceException (LIBMC_ERROR_BUFFERTOOSMALL);
			for (size_t iContentType = 0; iContentType < sContentType.size(); iContentType++)
				pContentTypeBuffer[iContentType] = sContentType[iContentType];
			pContentTypeBuffer[sContentType.size()] = 0;
		}
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_apirequesthandler_getresultdata(LibMC_APIRequestHandler pAPIRequestHandler, const LibMC_uint64 nDataBufferSize, LibMC_uint64* pDataNeededCount, LibMC_uint8 * pDataBuffer)
{
	IBase* pIBaseClass = (IBase *)pAPIRequestHandler;

	try {
		if ((!pDataBuffer) && !(pDataNeededCount))
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		IAPIRequestHandler* pIAPIRequestHandler = dynamic_cast<IAPIRequestHandler*>(pIBaseClass);
		if (!pIAPIRequestHandler)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIAPIRequestHandler->GetResultData(nDataBufferSize, pDataNeededCount, pDataBuffer);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for MCContext
**************************************************************************************************************************/
LibMCResult libmc_mccontext_registerlibrarypath(LibMC_MCContext pMCContext, const char * pLibraryName, const char * pLibraryPath)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if (pLibraryName == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pLibraryPath == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sLibraryName(pLibraryName);
		std::string sLibraryPath(pLibraryPath);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->RegisterLibraryPath(sLibraryName, sLibraryPath);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_parseconfiguration(LibMC_MCContext pMCContext, const char * pXMLString)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if (pXMLString == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sXMLString(pXMLString);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->ParseConfiguration(sXMLString);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_startallthreads(LibMC_MCContext pMCContext)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->StartAllThreads();

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_terminateallthreads(LibMC_MCContext pMCContext)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->TerminateAllThreads();

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_loadclientpackage(LibMC_MCContext pMCContext, LibMC_uint64 nZIPStreamBufferSize, const LibMC_uint8 * pZIPStreamBuffer)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if ( (!pZIPStreamBuffer) && (nZIPStreamBufferSize>0))
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->LoadClientPackage(nZIPStreamBufferSize, pZIPStreamBuffer);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_log(LibMC_MCContext pMCContext, const char * pMessage, eLibMCLogSubSystem eSubsystem, eLibMCLogLevel eLogLevel)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if (pMessage == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sMessage(pMessage);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pIMCContext->Log(sMessage, eSubsystem, eLogLevel);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_mccontext_createapirequesthandler(LibMC_MCContext pMCContext, const char * pURI, const char * pRequestMethod, const char * pAuthorization, LibMC_APIRequestHandler * pHandlerInstance)
{
	IBase* pIBaseClass = (IBase *)pMCContext;

	try {
		if (pURI == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pRequestMethod == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pAuthorization == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pHandlerInstance == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sURI(pURI);
		std::string sRequestMethod(pRequestMethod);
		std::string sAuthorization(pAuthorization);
		IBase* pBaseHandlerInstance(nullptr);
		IMCContext* pIMCContext = dynamic_cast<IMCContext*>(pIBaseClass);
		if (!pIMCContext)
			throw ELibMCInterfaceException(LIBMC_ERROR_INVALIDCAST);
		
		pBaseHandlerInstance = pIMCContext->CreateAPIRequestHandler(sURI, sRequestMethod, sAuthorization);

		*pHandlerInstance = (IBase*)(pBaseHandlerInstance);
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibMCResult LibMC::Impl::LibMC_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBMC_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBMC_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "libmc_apirequesthandler_expectsrawbody") 
		*ppProcAddress = (void*) &libmc_apirequesthandler_expectsrawbody;
	if (sProcName == "libmc_apirequesthandler_expectsformdata") 
		*ppProcAddress = (void*) &libmc_apirequesthandler_expectsformdata;
	if (sProcName == "libmc_apirequesthandler_getformdatadetails") 
		*ppProcAddress = (void*) &libmc_apirequesthandler_getformdatadetails;
	if (sProcName == "libmc_apirequesthandler_setformdatafield") 
		*ppProcAddress = (void*) &libmc_apirequesthandler_setformdatafield;
	if (sProcName == "libmc_apirequesthandler_setformstringfield") 
		*ppProcAddress = (void*) &libmc_apirequesthandler_setformstringfield;
	if (sProcName == "libmc_apirequesthandler_handle") 
		*ppProcAddress = (void*) &libmc_apirequesthandler_handle;
	if (sProcName == "libmc_apirequesthandler_getresultdata") 
		*ppProcAddress = (void*) &libmc_apirequesthandler_getresultdata;
	if (sProcName == "libmc_mccontext_registerlibrarypath") 
		*ppProcAddress = (void*) &libmc_mccontext_registerlibrarypath;
	if (sProcName == "libmc_mccontext_parseconfiguration") 
		*ppProcAddress = (void*) &libmc_mccontext_parseconfiguration;
	if (sProcName == "libmc_mccontext_startallthreads") 
		*ppProcAddress = (void*) &libmc_mccontext_startallthreads;
	if (sProcName == "libmc_mccontext_terminateallthreads") 
		*ppProcAddress = (void*) &libmc_mccontext_terminateallthreads;
	if (sProcName == "libmc_mccontext_loadclientpackage") 
		*ppProcAddress = (void*) &libmc_mccontext_loadclientpackage;
	if (sProcName == "libmc_mccontext_log") 
		*ppProcAddress = (void*) &libmc_mccontext_log;
	if (sProcName == "libmc_mccontext_createapirequesthandler") 
		*ppProcAddress = (void*) &libmc_mccontext_createapirequesthandler;
	if (sProcName == "libmc_getversion") 
		*ppProcAddress = (void*) &libmc_getversion;
	if (sProcName == "libmc_getlasterror") 
		*ppProcAddress = (void*) &libmc_getlasterror;
	if (sProcName == "libmc_releaseinstance") 
		*ppProcAddress = (void*) &libmc_releaseinstance;
	if (sProcName == "libmc_acquireinstance") 
		*ppProcAddress = (void*) &libmc_acquireinstance;
	if (sProcName == "libmc_injectcomponent") 
		*ppProcAddress = (void*) &libmc_injectcomponent;
	if (sProcName == "libmc_createmccontext") 
		*ppProcAddress = (void*) &libmc_createmccontext;
	
	if (*ppProcAddress == nullptr) 
		return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBMC_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibMCResult libmc_getversion(LibMC_uint32 * pMajor, LibMC_uint32 * pMinor, LibMC_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_getlasterror(LibMC_Base pInstance, const LibMC_uint32 nErrorMessageBufferSize, LibMC_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibMC_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibMCInterfaceException (LIBMC_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_releaseinstance(LibMC_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_acquireinstance(LibMC_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_injectcomponent(const char * pNameSpace, LibMC_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		if (sNameSpace == "LibMCData") {
			if (CWrapper::sPLibMCDataWrapper.get() != nullptr) {
				throw ELibMCInterfaceException(LIBMC_ERROR_COULDNOTLOADLIBRARY);
			}
			CWrapper::sPLibMCDataWrapper = LibMCData::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		
		if (!bNameSpaceFound)
			throw ELibMCInterfaceException(LIBMC_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibMCResult libmc_createmccontext(LibMCData_DataModel pDataModel, LibMC_MCContext * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDPARAM);
		LibMCData::PDataModel pIDataModel = std::make_shared<LibMCData::CDataModel>(CWrapper::sPLibMCDataWrapper.get(), pDataModel);
		CWrapper::sPLibMCDataWrapper->AcquireInstance(pIDataModel.get());
		if (!pIDataModel)
			throw ELibMCInterfaceException (LIBMC_ERROR_INVALIDCAST);
		
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateMCContext(pIDataModel);

		*pInstance = (IBase*)(pBaseInstance);
		return LIBMC_SUCCESS;
	}
	catch (ELibMCInterfaceException & Exception) {
		return handleLibMCException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


