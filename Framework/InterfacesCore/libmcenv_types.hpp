/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file with basic types in
order to allow an easy use of MC Environment Interface

Interface version: 1.0.0

*/

#ifndef __LIBMCENV_TYPES_HEADER_CPP
#define __LIBMCENV_TYPES_HEADER_CPP


/*************************************************************************************************************************
 Scalar types definition
**************************************************************************************************************************/

#ifdef LIBMCENV_USELEGACYINTEGERTYPES

typedef unsigned char LibMCEnv_uint8;
typedef unsigned short LibMCEnv_uint16 ;
typedef unsigned int LibMCEnv_uint32;
typedef unsigned long long LibMCEnv_uint64;
typedef char LibMCEnv_int8;
typedef short LibMCEnv_int16;
typedef int LibMCEnv_int32;
typedef long long LibMCEnv_int64;

#else // LIBMCENV_USELEGACYINTEGERTYPES

#include <stdint.h>

typedef uint8_t LibMCEnv_uint8;
typedef uint16_t LibMCEnv_uint16;
typedef uint32_t LibMCEnv_uint32;
typedef uint64_t LibMCEnv_uint64;
typedef int8_t LibMCEnv_int8;
typedef int16_t LibMCEnv_int16;
typedef int32_t LibMCEnv_int32;
typedef int64_t LibMCEnv_int64 ;

#endif // LIBMCENV_USELEGACYINTEGERTYPES

typedef float LibMCEnv_single;
typedef double LibMCEnv_double;

/*************************************************************************************************************************
 General type definitions
**************************************************************************************************************************/

typedef LibMCEnv_int32 LibMCEnvResult;
typedef void * LibMCEnvHandle;
typedef void * LibMCEnv_pvoid;

/*************************************************************************************************************************
 Version for LibMCEnv
**************************************************************************************************************************/

#define LIBMCENV_VERSION_MAJOR 1
#define LIBMCENV_VERSION_MINOR 0
#define LIBMCENV_VERSION_MICRO 0
#define LIBMCENV_VERSION_PRERELEASEINFO ""
#define LIBMCENV_VERSION_BUILDINFO ""

/*************************************************************************************************************************
 Error constants for LibMCEnv
**************************************************************************************************************************/

#define LIBMCENV_SUCCESS 0
#define LIBMCENV_ERROR_NOTIMPLEMENTED 10001 /** functionality not implemented */
#define LIBMCENV_ERROR_INVALIDPARAM 10002 /** an invalid parameter was passed */
#define LIBMCENV_ERROR_INVALIDCAST 10003 /** a type cast failed */
#define LIBMCENV_ERROR_BUFFERTOOSMALL 10004 /** a provided buffer is too small */
#define LIBMCENV_ERROR_GENERICEXCEPTION 10005 /** a generic exception occurred */
#define LIBMCENV_ERROR_COULDNOTLOADLIBRARY 10006 /** the library could not be loaded */
#define LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT 10007 /** a required exported symbol could not be found in the library */
#define LIBMCENV_ERROR_INCOMPATIBLEBINARYVERSION 10008 /** the version of the binary interface does not match the bindings interface */
#define LIBMCENV_ERROR_PARAMETERGROUPNOTFOUND 10009 /** Parameter group not found */
#define LIBMCENV_ERROR_PARAMETERNOTFOUND 10010 /** Parameter not found */
#define LIBMCENV_ERROR_COULDNOTFINDSIGNALDEFINITON 10011 /** Could not find signal definition */
#define LIBMCENV_ERROR_COULDNOTTRIGGERSIGNAL 10012 /** Could not trigger signal */
#define LIBMCENV_ERROR_SIGNALNOTFOUND 10013 /** Signal not found */
#define LIBMCENV_ERROR_TERMINATED 10014 /** operation has been terminated. */
#define LIBMCENV_ERROR_SIGNALHASTRIGGEREDTWICE 10015 /** signal has been triggered twice. */
#define LIBMCENV_ERROR_SIGNALHASNOTBEENTRIGGERED 10016 /** signal has not been triggered. */
#define LIBMCENV_ERROR_DRIVERISNOTINITIALISING 10017 /** driver is not in initialisation mode. */
#define LIBMCENV_ERROR_RESOURCEENTRYNOTFOUND 10018 /** resource entry not found. */
#define LIBMCENV_ERROR_INTERNALERROR 10019 /** internal error. */
#define LIBMCENV_ERROR_INVALIDCHARACTERINFILENAME 10020 /** invalid character in filename. */
#define LIBMCENV_ERROR_WORKINGDIRECTORYHASBEENCLEANED 10021 /** working directory has been cleaned. */
#define LIBMCENV_ERROR_INVALIDITERATOR 10022 /** invalid iterator. */
#define LIBMCENV_ERROR_FORMVALUENOTFOUND 10023 /** Form value not found. */
#define LIBMCENV_ERROR_INVALIDDOUBLEFORMVALUE 10024 /** Invalid double form value. */
#define LIBMCENV_ERROR_INVALIDINTEGERFORMVALUE 10025 /** Invalid integer form value. */
#define LIBMCENV_ERROR_COULDNNOTACCESSCLIENTVARIABLES 10026 /** Could not access client variables. */
#define LIBMCENV_ERROR_INVALIDPIXELCOUNT 10027 /** Invalid pixel count. */
#define LIBMCENV_ERROR_INVALIDDPIVALUE 10028 /** Invalid dpi value. */
#define LIBMCENV_ERROR_COULDNOTCOMPRESSPNGIMAGE 10029 /** Could not compress PNG image. */
#define LIBMCENV_ERROR_COULDNOTSTOREPNGIMAGE 10030 /** Could not store PNG image. */
#define LIBMCENV_ERROR_EMPTYPNGIMAGEDATA 10031 /** Empty PNG image data. */
#define LIBMCENV_ERROR_INVALIDXCOORDINATE 10032 /** Invalid X coordinate. */
#define LIBMCENV_ERROR_INVALIDYCOORDINATE 10033 /** Invalid Y coordinate. */
#define LIBMCENV_ERROR_INVALIDXCOORDINATERANGE 10034 /** Invalid X coordinate range. */
#define LIBMCENV_ERROR_INVALIDYCOORDINATERANGE 10035 /** Invalid Y coordinate range. */
#define LIBMCENV_ERROR_INVALIDPIXELDATACOUNT 10036 /** Invalid pixel data count. */
#define LIBMCENV_ERROR_INVALIDIMAGEBUFFER 10037 /** Invalid image buffer. */
#define LIBMCENV_ERROR_INVALIDPIXELFORMAT 10038 /** Invalid pixel format. */
#define LIBMCENV_ERROR_INVALIDTESTOUTPUTNAME 10039 /** Invalid test output name. */
#define LIBMCENV_ERROR_TOOLPATHNOTLOADED 10040 /** Toolpath has not been loaded. */
#define LIBMCENV_ERROR_INVALIDLAYERINDEX 10041 /** Invalid layer index. */
#define LIBMCENV_ERROR_INVALIDHATCHCOUNT 10042 /** Invalid hatch count. */
#define LIBMCENV_ERROR_SEGMENTISNOTOFTYPEHATCH 10043 /** Segment is not of type hatch. */
#define LIBMCENV_ERROR_TEMPFILEEXTENSIONEXCEEDS64CHARACTERS 10044 /** Temp file extension exceeds 64 characters. */
#define LIBMCENV_ERROR_TEMPFILEEXTENSIONCONTAINSINVALIDCHARACTERS 10045 /** Temp file extension contains invalid characters. */
#define LIBMCENV_ERROR_COULDNOTGENERATETEMPFILENAME 10046 /** Could not generate temp file name. */
#define LIBMCENV_ERROR_EMPTYTCPIPPACKET 10047 /** Empty TCP/IP Packet. */
#define LIBMCENV_ERROR_COULDNOTGETADDRESSINFO 10048 /** Could not get address info. */
#define LIBMCENV_ERROR_COULDNOTCREATESOCKET 10049 /** Could not create socket. */
#define LIBMCENV_ERROR_COULDNOTCONNECT 10050 /** Could not connect. */
#define LIBMCENV_ERROR_SENDERROR 10051 /** Send error. */
#define LIBMCENV_ERROR_RECEIVECOUNTEXCEEDSMAXIMUM 10052 /** Receive count exceeds maximum. */
#define LIBMCENV_ERROR_CONNECTIONCLOSED 10053 /** Connection closed. */
#define LIBMCENV_ERROR_RECEIVEERROR 10054 /** Receive error. */
#define LIBMCENV_ERROR_SENDCOUNTEXCEEDSMAXIMUM 10055 /** Send count exceeds maximum. */
#define LIBMCENV_ERROR_SOCKETNOTCONNECTED 10056 /** Socket not connected. */
#define LIBMCENV_ERROR_INVALIDSENDBUFFER 10057 /** Invalid send buffer. */
#define LIBMCENV_ERROR_INVALIDMODBUSTCPPAYLOADSIZE 10058 /** Invalid modbus TCP payload size */
#define LIBMCENV_ERROR_INVALIDMODBUSTCPREQUEST 10059 /** Invalid modbus TCP request */
#define LIBMCENV_ERROR_INSUFFICIENTMODBUSTCPRESPONSEHEADER 10060 /** Insufficient modbus tcp response header */
#define LIBMCENV_ERROR_MODBUSTCPRESPONSEOVERFLOW 10061 /** modbus tcp response overflow */
#define LIBMCENV_ERROR_INVALIDMODBUSTCPTRANSACTIONIDRESPONSE 10062 /** invalid modbus tcp transaction ID response */
#define LIBMCENV_ERROR_INVALIDMODBUSTCPPROTOCOLIDRESPONSE 10063 /** invalid modbus tcp protocol ID response */
#define LIBMCENV_ERROR_INVALIDMODBUSTCPUNITIDENTIFIERRESPONSE 10064 /** invalid modbus tcp unit identifier response */
#define LIBMCENV_ERROR_MODBUSTCPRESPONSELENGTHMISMATCH 10065 /** modbus tcp response length mismatch */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSBITCOUNT 10066 /** modbus TCP Invalid coils status bit count. */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSRESPONSE 10067 /** modbus TCP Invalid coils status response. */
#define LIBMCENV_ERROR_MODBUSTCPCOILSTATUSRESPONSEEMPTY 10068 /** modbus TCP coils status response empty. */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSRESPONSESIZE 10069 /** modbus TCP invalid coil status response size. */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSBITCOUNT 10070 /** modbus TCP invalid input status bit count. */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSRESPONSE 10071 /** modbus TCP invalid input status response. */
#define LIBMCENV_ERROR_MODBUSTCPINPUTSTATUSRESPONSEEMPTY 10072 /** modbus TCP input status response empty. */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSRESPONSESIZE 10073 /** modbus TCP invalid input status response size. */
#define LIBMCENV_ERROR_INVALIDMODBUSTCPCOILCOUNT 10074 /** invalid modbus tcp coil count. */
#define LIBMCENV_ERROR_INVALIDMODBUSTCPREGISTERCOUNT 10075 /** invalid modbus tcp register count. */
#define LIBMCENV_ERROR_INVALIDMODBUSIOINDEX 10076 /** invalid modbus IO index. */
#define LIBMCENV_ERROR_MODBUSIOSTATUSEMPTY 10077 /** modbus io status empty. */
#define LIBMCENV_ERROR_INVALIDMODBUSREGISTERINDEX 10078 /** invalid modbus register index. */
#define LIBMCENV_ERROR_MODBUSREGISTERSTATUSEMPTY 10079 /** modbus register status empty. */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTREGISTERSRESPONSE 10080 /** modbus TCP invalid input registers response */
#define LIBMCENV_ERROR_MODBUSTCPINPUTREGISTERSRESPONSEEMPTY 10081 /** modbus TCP input registers response empty */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTREGISTERSRESPONSESIZE 10083 /** modbus TCP invalid input registers response size */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSE 10084 /** modbus TCP invalid holding registers response */
#define LIBMCENV_ERROR_MODBUSTCPHOLDINGREGISTERSRESPONSEEMPTY 10085 /** modbus TCP holding registers response empty */
#define LIBMCENV_ERROR_MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSESIZE 10086 /** modbus TCP invalid holding registers response size */
#define LIBMCENV_ERROR_SIGNALUUIDNOTACTIVE 10087 /** signal UUID not active. */
#define LIBMCENV_ERROR_COULDNOTPARSEXMLSTRING 10088 /** could not parse XML string. */
#define LIBMCENV_ERROR_COULDNOTPARSEXMLDATA 10089 /** could not parse XML data. */
#define LIBMCENV_ERROR_INVALIDPROFILEVALUETYPE 10090 /** Invalid profile value type. */

/*************************************************************************************************************************
 Error strings for LibMCEnv
**************************************************************************************************************************/

inline const char * LIBMCENV_GETERRORSTRING (LibMCEnvResult nErrorCode) {
  switch (nErrorCode) {
    case LIBMCENV_SUCCESS: return "no error";
    case LIBMCENV_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
    case LIBMCENV_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
    case LIBMCENV_ERROR_INVALIDCAST: return "a type cast failed";
    case LIBMCENV_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
    case LIBMCENV_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
    case LIBMCENV_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
    case LIBMCENV_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
    case LIBMCENV_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
    case LIBMCENV_ERROR_PARAMETERGROUPNOTFOUND: return "Parameter group not found";
    case LIBMCENV_ERROR_PARAMETERNOTFOUND: return "Parameter not found";
    case LIBMCENV_ERROR_COULDNOTFINDSIGNALDEFINITON: return "Could not find signal definition";
    case LIBMCENV_ERROR_COULDNOTTRIGGERSIGNAL: return "Could not trigger signal";
    case LIBMCENV_ERROR_SIGNALNOTFOUND: return "Signal not found";
    case LIBMCENV_ERROR_TERMINATED: return "operation has been terminated.";
    case LIBMCENV_ERROR_SIGNALHASTRIGGEREDTWICE: return "signal has been triggered twice.";
    case LIBMCENV_ERROR_SIGNALHASNOTBEENTRIGGERED: return "signal has not been triggered.";
    case LIBMCENV_ERROR_DRIVERISNOTINITIALISING: return "driver is not in initialisation mode.";
    case LIBMCENV_ERROR_RESOURCEENTRYNOTFOUND: return "resource entry not found.";
    case LIBMCENV_ERROR_INTERNALERROR: return "internal error.";
    case LIBMCENV_ERROR_INVALIDCHARACTERINFILENAME: return "invalid character in filename.";
    case LIBMCENV_ERROR_WORKINGDIRECTORYHASBEENCLEANED: return "working directory has been cleaned.";
    case LIBMCENV_ERROR_INVALIDITERATOR: return "invalid iterator.";
    case LIBMCENV_ERROR_FORMVALUENOTFOUND: return "Form value not found.";
    case LIBMCENV_ERROR_INVALIDDOUBLEFORMVALUE: return "Invalid double form value.";
    case LIBMCENV_ERROR_INVALIDINTEGERFORMVALUE: return "Invalid integer form value.";
    case LIBMCENV_ERROR_COULDNNOTACCESSCLIENTVARIABLES: return "Could not access client variables.";
    case LIBMCENV_ERROR_INVALIDPIXELCOUNT: return "Invalid pixel count.";
    case LIBMCENV_ERROR_INVALIDDPIVALUE: return "Invalid dpi value.";
    case LIBMCENV_ERROR_COULDNOTCOMPRESSPNGIMAGE: return "Could not compress PNG image.";
    case LIBMCENV_ERROR_COULDNOTSTOREPNGIMAGE: return "Could not store PNG image.";
    case LIBMCENV_ERROR_EMPTYPNGIMAGEDATA: return "Empty PNG image data.";
    case LIBMCENV_ERROR_INVALIDXCOORDINATE: return "Invalid X coordinate.";
    case LIBMCENV_ERROR_INVALIDYCOORDINATE: return "Invalid Y coordinate.";
    case LIBMCENV_ERROR_INVALIDXCOORDINATERANGE: return "Invalid X coordinate range.";
    case LIBMCENV_ERROR_INVALIDYCOORDINATERANGE: return "Invalid Y coordinate range.";
    case LIBMCENV_ERROR_INVALIDPIXELDATACOUNT: return "Invalid pixel data count.";
    case LIBMCENV_ERROR_INVALIDIMAGEBUFFER: return "Invalid image buffer.";
    case LIBMCENV_ERROR_INVALIDPIXELFORMAT: return "Invalid pixel format.";
    case LIBMCENV_ERROR_INVALIDTESTOUTPUTNAME: return "Invalid test output name.";
    case LIBMCENV_ERROR_TOOLPATHNOTLOADED: return "Toolpath has not been loaded.";
    case LIBMCENV_ERROR_INVALIDLAYERINDEX: return "Invalid layer index.";
    case LIBMCENV_ERROR_INVALIDHATCHCOUNT: return "Invalid hatch count.";
    case LIBMCENV_ERROR_SEGMENTISNOTOFTYPEHATCH: return "Segment is not of type hatch.";
    case LIBMCENV_ERROR_TEMPFILEEXTENSIONEXCEEDS64CHARACTERS: return "Temp file extension exceeds 64 characters.";
    case LIBMCENV_ERROR_TEMPFILEEXTENSIONCONTAINSINVALIDCHARACTERS: return "Temp file extension contains invalid characters.";
    case LIBMCENV_ERROR_COULDNOTGENERATETEMPFILENAME: return "Could not generate temp file name.";
    case LIBMCENV_ERROR_EMPTYTCPIPPACKET: return "Empty TCP/IP Packet.";
    case LIBMCENV_ERROR_COULDNOTGETADDRESSINFO: return "Could not get address info.";
    case LIBMCENV_ERROR_COULDNOTCREATESOCKET: return "Could not create socket.";
    case LIBMCENV_ERROR_COULDNOTCONNECT: return "Could not connect.";
    case LIBMCENV_ERROR_SENDERROR: return "Send error.";
    case LIBMCENV_ERROR_RECEIVECOUNTEXCEEDSMAXIMUM: return "Receive count exceeds maximum.";
    case LIBMCENV_ERROR_CONNECTIONCLOSED: return "Connection closed.";
    case LIBMCENV_ERROR_RECEIVEERROR: return "Receive error.";
    case LIBMCENV_ERROR_SENDCOUNTEXCEEDSMAXIMUM: return "Send count exceeds maximum.";
    case LIBMCENV_ERROR_SOCKETNOTCONNECTED: return "Socket not connected.";
    case LIBMCENV_ERROR_INVALIDSENDBUFFER: return "Invalid send buffer.";
    case LIBMCENV_ERROR_INVALIDMODBUSTCPPAYLOADSIZE: return "Invalid modbus TCP payload size";
    case LIBMCENV_ERROR_INVALIDMODBUSTCPREQUEST: return "Invalid modbus TCP request";
    case LIBMCENV_ERROR_INSUFFICIENTMODBUSTCPRESPONSEHEADER: return "Insufficient modbus tcp response header";
    case LIBMCENV_ERROR_MODBUSTCPRESPONSEOVERFLOW: return "modbus tcp response overflow";
    case LIBMCENV_ERROR_INVALIDMODBUSTCPTRANSACTIONIDRESPONSE: return "invalid modbus tcp transaction ID response";
    case LIBMCENV_ERROR_INVALIDMODBUSTCPPROTOCOLIDRESPONSE: return "invalid modbus tcp protocol ID response";
    case LIBMCENV_ERROR_INVALIDMODBUSTCPUNITIDENTIFIERRESPONSE: return "invalid modbus tcp unit identifier response";
    case LIBMCENV_ERROR_MODBUSTCPRESPONSELENGTHMISMATCH: return "modbus tcp response length mismatch";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSBITCOUNT: return "modbus TCP Invalid coils status bit count.";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSRESPONSE: return "modbus TCP Invalid coils status response.";
    case LIBMCENV_ERROR_MODBUSTCPCOILSTATUSRESPONSEEMPTY: return "modbus TCP coils status response empty.";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDCOILSTATUSRESPONSESIZE: return "modbus TCP invalid coil status response size.";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSBITCOUNT: return "modbus TCP invalid input status bit count.";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSRESPONSE: return "modbus TCP invalid input status response.";
    case LIBMCENV_ERROR_MODBUSTCPINPUTSTATUSRESPONSEEMPTY: return "modbus TCP input status response empty.";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTSTATUSRESPONSESIZE: return "modbus TCP invalid input status response size.";
    case LIBMCENV_ERROR_INVALIDMODBUSTCPCOILCOUNT: return "invalid modbus tcp coil count.";
    case LIBMCENV_ERROR_INVALIDMODBUSTCPREGISTERCOUNT: return "invalid modbus tcp register count.";
    case LIBMCENV_ERROR_INVALIDMODBUSIOINDEX: return "invalid modbus IO index.";
    case LIBMCENV_ERROR_MODBUSIOSTATUSEMPTY: return "modbus io status empty.";
    case LIBMCENV_ERROR_INVALIDMODBUSREGISTERINDEX: return "invalid modbus register index.";
    case LIBMCENV_ERROR_MODBUSREGISTERSTATUSEMPTY: return "modbus register status empty.";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTREGISTERSRESPONSE: return "modbus TCP invalid input registers response";
    case LIBMCENV_ERROR_MODBUSTCPINPUTREGISTERSRESPONSEEMPTY: return "modbus TCP input registers response empty";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDINPUTREGISTERSRESPONSESIZE: return "modbus TCP invalid input registers response size";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSE: return "modbus TCP invalid holding registers response";
    case LIBMCENV_ERROR_MODBUSTCPHOLDINGREGISTERSRESPONSEEMPTY: return "modbus TCP holding registers response empty";
    case LIBMCENV_ERROR_MODBUSTCPINVALIDHOLDINGREGISTERSRESPONSESIZE: return "modbus TCP invalid holding registers response size";
    case LIBMCENV_ERROR_SIGNALUUIDNOTACTIVE: return "signal UUID not active.";
    case LIBMCENV_ERROR_COULDNOTPARSEXMLSTRING: return "could not parse XML string.";
    case LIBMCENV_ERROR_COULDNOTPARSEXMLDATA: return "could not parse XML data.";
    case LIBMCENV_ERROR_INVALIDPROFILEVALUETYPE: return "Invalid profile value type.";
    default: return "unknown error";
  }
}

/*************************************************************************************************************************
 Declaration of handle classes 
**************************************************************************************************************************/

typedef LibMCEnvHandle LibMCEnv_Base;
typedef LibMCEnvHandle LibMCEnv_Iterator;
typedef LibMCEnvHandle LibMCEnv_TestEnvironment;
typedef LibMCEnvHandle LibMCEnv_ImageData;
typedef LibMCEnvHandle LibMCEnv_ToolpathPart;
typedef LibMCEnvHandle LibMCEnv_ToolpathLayer;
typedef LibMCEnvHandle LibMCEnv_ToolpathAccessor;
typedef LibMCEnvHandle LibMCEnv_Build;
typedef LibMCEnvHandle LibMCEnv_WorkingFileExecution;
typedef LibMCEnvHandle LibMCEnv_WorkingFile;
typedef LibMCEnvHandle LibMCEnv_WorkingFileIterator;
typedef LibMCEnvHandle LibMCEnv_WorkingDirectory;
typedef LibMCEnvHandle LibMCEnv_XMLDocumentAttribute;
typedef LibMCEnvHandle LibMCEnv_XMLDocumentNode;
typedef LibMCEnvHandle LibMCEnv_XMLDocumentNodes;
typedef LibMCEnvHandle LibMCEnv_XMLDocument;
typedef LibMCEnvHandle LibMCEnv_TCPIPPacket;
typedef LibMCEnvHandle LibMCEnv_TCPIPConnection;
typedef LibMCEnvHandle LibMCEnv_ModbusTCPDigitalIOStatus;
typedef LibMCEnvHandle LibMCEnv_ModbusTCPRegisterStatus;
typedef LibMCEnvHandle LibMCEnv_ModbusTCPConnection;
typedef LibMCEnvHandle LibMCEnv_DriverStatusUpdateSession;
typedef LibMCEnvHandle LibMCEnv_DriverEnvironment;
typedef LibMCEnvHandle LibMCEnv_SignalTrigger;
typedef LibMCEnvHandle LibMCEnv_SignalHandler;
typedef LibMCEnvHandle LibMCEnv_StateEnvironment;
typedef LibMCEnvHandle LibMCEnv_UIEnvironment;

namespace LibMCEnv {

  /*************************************************************************************************************************
   Declaration of enums
  **************************************************************************************************************************/
  
  enum class eImagePixelFormat : LibMCEnv_int32 {
    Unknown = 0,
    GreyScale8bit = 1,
    RGB24bit = 2,
    RGBA32bit = 3
  };
  
  enum class eToolpathSegmentType : LibMCEnv_int32 {
    Unknown = 0,
    Hatch = 1,
    Loop = 2,
    Polyline = 3
  };
  
  enum class eToolpathProfileValueType : LibMCEnv_int32 {
    Custom = 0,
    Speed = 1,
    JumpSpeed = 2,
    ExtrusionFactor = 3,
    LaserPower = 4,
    StartDelay = 5,
    EndDelay = 6,
    PolyDelay = 7,
    PolyDelayAngleDependent = 8,
    LaserOnDelay = 9,
    LaserOffDelay = 10,
    JumpDelay = 11,
    MarkDelay = 12,
    LaserFocus = 13
  };
  
  enum class eMessageDialogType : LibMCEnv_int32 {
    Unknown = 0,
    DialogOK = 1,
    DialogOKCancel = 2,
    DialogYesNo = 3,
    DialogYesNoCancel = 4
  };
  
  /*************************************************************************************************************************
   Declaration of structs
  **************************************************************************************************************************/
  
  #pragma pack (1)
  
  typedef struct sPosition2D {
      LibMCEnv_int32 m_Coordinates[2];
  } sPosition2D;
  
  typedef struct sHatch2D {
      LibMCEnv_int32 m_X1;
      LibMCEnv_int32 m_Y1;
      LibMCEnv_int32 m_X2;
      LibMCEnv_int32 m_Y2;
  } sHatch2D;
  
  typedef struct sFloatPosition2D {
      LibMCEnv_double m_Coordinates[2];
  } sFloatPosition2D;
  
  typedef struct sFloatHatch2D {
      LibMCEnv_double m_X1;
      LibMCEnv_double m_Y1;
      LibMCEnv_double m_X2;
      LibMCEnv_double m_Y2;
  } sFloatHatch2D;
  
  typedef struct sToolpathPartTransform {
      LibMCEnv_double m_Matrix[3][3];
      LibMCEnv_double m_Translation[3];
  } sToolpathPartTransform;
  
  typedef struct sColorRGB {
      LibMCEnv_double m_Red;
      LibMCEnv_double m_Green;
      LibMCEnv_double m_Blue;
  } sColorRGB;
  
  #pragma pack ()
  
} // namespace LibMCEnv;

// define legacy C-names for enums, structs and function types
typedef LibMCEnv::eImagePixelFormat eLibMCEnvImagePixelFormat;
typedef LibMCEnv::eToolpathSegmentType eLibMCEnvToolpathSegmentType;
typedef LibMCEnv::eToolpathProfileValueType eLibMCEnvToolpathProfileValueType;
typedef LibMCEnv::eMessageDialogType eLibMCEnvMessageDialogType;
typedef LibMCEnv::sPosition2D sLibMCEnvPosition2D;
typedef LibMCEnv::sHatch2D sLibMCEnvHatch2D;
typedef LibMCEnv::sFloatPosition2D sLibMCEnvFloatPosition2D;
typedef LibMCEnv::sFloatHatch2D sLibMCEnvFloatHatch2D;
typedef LibMCEnv::sToolpathPartTransform sLibMCEnvToolpathPartTransform;
typedef LibMCEnv::sColorRGB sLibMCEnvColorRGB;

#endif // __LIBMCENV_TYPES_HEADER_CPP
