/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Machine Control data model library

Interface version: 1.0.0

*/

#ifndef __LIBMCDATA_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDATA_CPPHEADER_DYNAMIC_CPP

#include "libmcdata_types.hpp"
#include "libmcdata_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCData {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CIterator;
class CLogSession;
class CStorageStream;
class CStorage;
class CBuildJobData;
class CBuildJobDataIterator;
class CBuildJob;
class CBuildJobIterator;
class CBuildJobHandler;
class CLoginHandler;
class CDataModel;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDataWrapper;
typedef CBase CLibMCDataBase;
typedef CIterator CLibMCDataIterator;
typedef CLogSession CLibMCDataLogSession;
typedef CStorageStream CLibMCDataStorageStream;
typedef CStorage CLibMCDataStorage;
typedef CBuildJobData CLibMCDataBuildJobData;
typedef CBuildJobDataIterator CLibMCDataBuildJobDataIterator;
typedef CBuildJob CLibMCDataBuildJob;
typedef CBuildJobIterator CLibMCDataBuildJobIterator;
typedef CBuildJobHandler CLibMCDataBuildJobHandler;
typedef CLoginHandler CLibMCDataLoginHandler;
typedef CDataModel CLibMCDataDataModel;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CIterator> PIterator;
typedef std::shared_ptr<CLogSession> PLogSession;
typedef std::shared_ptr<CStorageStream> PStorageStream;
typedef std::shared_ptr<CStorage> PStorage;
typedef std::shared_ptr<CBuildJobData> PBuildJobData;
typedef std::shared_ptr<CBuildJobDataIterator> PBuildJobDataIterator;
typedef std::shared_ptr<CBuildJob> PBuildJob;
typedef std::shared_ptr<CBuildJobIterator> PBuildJobIterator;
typedef std::shared_ptr<CBuildJobHandler> PBuildJobHandler;
typedef std::shared_ptr<CLoginHandler> PLoginHandler;
typedef std::shared_ptr<CDataModel> PDataModel;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDataWrapper;
typedef PBase PLibMCDataBase;
typedef PIterator PLibMCDataIterator;
typedef PLogSession PLibMCDataLogSession;
typedef PStorageStream PLibMCDataStorageStream;
typedef PStorage PLibMCDataStorage;
typedef PBuildJobData PLibMCDataBuildJobData;
typedef PBuildJobDataIterator PLibMCDataBuildJobDataIterator;
typedef PBuildJob PLibMCDataBuildJob;
typedef PBuildJobIterator PLibMCDataBuildJobIterator;
typedef PBuildJobHandler PLibMCDataBuildJobHandler;
typedef PLoginHandler PLibMCDataLoginHandler;
typedef PDataModel PLibMCDataDataModel;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDataHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDataException 
**************************************************************************************************************************/
class ELibMCDataException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDataResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDataException(LibMCDataResult errorCode, const std::string & sErrorMessage)
		: m_errorMessage("LibMCData Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
	{
		m_errorCode = errorCode;
	}

	/**
	* Returns error code
	*/
	LibMCDataResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector( const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector( const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDataInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDataResult nResult);

	inline void GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline LibMCData_pvoid GetSymbolLookupMethod();
	inline PDataModel CreateDataModelInstance();

private:
	sLibMCDataDynamicWrapperTable m_WrapperTable;
	
	LibMCDataResult checkBinaryVersion()
	{
		LibMCData_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != LIBMCDATA_VERSION_MAJOR) || (nMinor < LIBMCDATA_VERSION_MINOR) ) {
			return LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDATA_SUCCESS;
	}
	LibMCDataResult initWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable);
	LibMCDataResult releaseWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable);
	LibMCDataResult loadWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDataResult loadWrapperTableFromSymbolLookupMethod(sLibMCDataDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CIterator;
	friend class CLogSession;
	friend class CStorageStream;
	friend class CStorage;
	friend class CBuildJobData;
	friend class CBuildJobDataIterator;
	friend class CBuildJob;
	friend class CBuildJobIterator;
	friend class CBuildJobHandler;
	friend class CLoginHandler;
	friend class CDataModel;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDataHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDataResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDataHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDataHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CIterator 
**************************************************************************************************************************/
class CIterator : public CBase {
public:
	
	/**
	* CIterator::CIterator - Constructor for Iterator class.
	*/
	CIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MoveNext();
	inline bool MovePrevious();
	inline PBase GetCurrent();
	inline PIterator Clone();
	inline LibMCData_uint64 Count();
};
	
/*************************************************************************************************************************
 Class CLogSession 
**************************************************************************************************************************/
class CLogSession : public CBase {
public:
	
	/**
	* CLogSession::CLogSession - Constructor for LogSession class.
	*/
	CLogSession(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void AddEntry(const std::string & sMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp);
};
	
/*************************************************************************************************************************
 Class CStorageStream 
**************************************************************************************************************************/
class CStorageStream : public CBase {
public:
	
	/**
	* CStorageStream::CStorageStream - Constructor for StorageStream class.
	*/
	CStorageStream(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetTimeStamp();
	inline std::string GetName();
	inline std::string GetMIMEType();
	inline std::string GetSHA2();
	inline LibMCData_uint64 GetSize();
	inline void GetContent(std::vector<LibMCData_uint8> & ContentBuffer);
	inline void GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle);
};
	
/*************************************************************************************************************************
 Class CStorage 
**************************************************************************************************************************/
class CStorage : public CBase {
public:
	
	/**
	* CStorage::CStorage - Constructor for Storage class.
	*/
	CStorage(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool StreamIsReady(const std::string & sUUID);
	inline PStorageStream RetrieveStream(const std::string & sUUID);
	inline void StoreNewStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sName, const std::string & sMimeType, const CInputVector<LibMCData_uint8> & ContentBuffer, const std::string & sUserID);
	inline void BeginPartialStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID);
	inline void StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer);
	inline void FinishPartialStream(const std::string & sUUID, const std::string & sSHA2);
	inline LibMCData_uint64 GetMaxStreamSize();
	inline bool ContentTypeIsAccepted(const std::string & sContentType);
	inline bool StreamIsImage(const std::string & sUUID);
};
	
/*************************************************************************************************************************
 Class CBuildJobData 
**************************************************************************************************************************/
class CBuildJobData : public CBase {
public:
	
	/**
	* CBuildJobData::CBuildJobData - Constructor for BuildJobData class.
	*/
	CBuildJobData(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetName();
	inline std::string GetTimeStamp();
	inline PStorageStream GetStorageStream();
	inline eBuildJobDataType GetDataType();
	inline std::string GetMIMEType();
};
	
/*************************************************************************************************************************
 Class CBuildJobDataIterator 
**************************************************************************************************************************/
class CBuildJobDataIterator : public CIterator {
public:
	
	/**
	* CBuildJobDataIterator::CBuildJobDataIterator - Constructor for BuildJobDataIterator class.
	*/
	CBuildJobDataIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJobData GetCurrentJobData();
};
	
/*************************************************************************************************************************
 Class CBuildJob 
**************************************************************************************************************************/
class CBuildJob : public CBase {
public:
	
	/**
	* CBuildJob::CBuildJob - Constructor for BuildJob class.
	*/
	CBuildJob(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetName();
	inline eBuildJobStatus GetStatus();
	inline LibMCData_uint32 GetLayerCount();
	inline std::string GetTimeStamp();
	inline PStorageStream GetStorageStream();
	inline std::string GetStorageStreamUUID();
	inline PLogSession GetBuildJobLogger();
	inline void StartValidating();
	inline void FinishValidating(const LibMCData_uint32 nLayerCount);
	inline void ArchiveJob();
	inline void UnArchiveJob();
	inline void DeleteJob();
	inline bool JobCanBeArchived();
	inline void AddJobData(const std::string & sName, classParam<CStorageStream> pStream, const eBuildJobDataType eDataType, const std::string & sUserID);
	inline PBuildJobDataIterator ListJobDataByType(const eBuildJobDataType eDataType);
	inline PBuildJobDataIterator ListJobData();
};
	
/*************************************************************************************************************************
 Class CBuildJobIterator 
**************************************************************************************************************************/
class CBuildJobIterator : public CIterator {
public:
	
	/**
	* CBuildJobIterator::CBuildJobIterator - Constructor for BuildJobIterator class.
	*/
	CBuildJobIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJob GetCurrentJob();
};
	
/*************************************************************************************************************************
 Class CBuildJobHandler 
**************************************************************************************************************************/
class CBuildJobHandler : public CBase {
public:
	
	/**
	* CBuildJobHandler::CBuildJobHandler - Constructor for BuildJobHandler class.
	*/
	CBuildJobHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PBuildJob CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID);
	inline PBuildJob RetrieveJob(const std::string & sJobUUID);
	inline PBuildJobIterator ListJobsByStatus(const eBuildJobStatus eStatus);
	inline std::string ConvertBuildStatusToString(const eBuildJobStatus eStatus);
	inline eBuildJobStatus ConvertStringToBuildStatus(const std::string & sString);
};
	
/*************************************************************************************************************************
 Class CLoginHandler 
**************************************************************************************************************************/
class CLoginHandler : public CBase {
public:
	
	/**
	* CLoginHandler::CLoginHandler - Constructor for LoginHandler class.
	*/
	CLoginHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool UserExists(const std::string & sUsername);
	inline void GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword);
};
	
/*************************************************************************************************************************
 Class CDataModel 
**************************************************************************************************************************/
class CDataModel : public CBase {
public:
	
	/**
	* CDataModel::CDataModel - Constructor for DataModel class.
	*/
	CDataModel(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void InitialiseDatabase(const std::string & sDataDirectory, const eDataBaseType eDataBaseType, const std::string & sConnectionString);
	inline LibMCData_uint32 GetDataModelVersion();
	inline void GetInstallationInformation(std::string & sInstallationUUID, std::string & sInstallationSecret);
	inline PStorage CreateStorage();
	inline PBuildJobHandler CreateBuildJobHandler();
	inline PLogSession CreateNewLogSession();
	inline PLoginHandler CreateLoginHandler();
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		LibMCData_uint32 bytesNeededErrorMessage = 0;
		LibMCData_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCData_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCData_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDataModelInstance - Creates and initializes new MC DataModel Instance.
	* @return New DataModel instance
	*/
	inline PDataModel CWrapper::CreateDataModelInstance()
	{
		LibMCDataHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDataModelInstance(&hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataModel>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDataResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDataException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDataResult CWrapper::initWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Iterator_MoveNext = nullptr;
		pWrapperTable->m_Iterator_MovePrevious = nullptr;
		pWrapperTable->m_Iterator_GetCurrent = nullptr;
		pWrapperTable->m_Iterator_Clone = nullptr;
		pWrapperTable->m_Iterator_Count = nullptr;
		pWrapperTable->m_LogSession_AddEntry = nullptr;
		pWrapperTable->m_StorageStream_GetUUID = nullptr;
		pWrapperTable->m_StorageStream_GetTimeStamp = nullptr;
		pWrapperTable->m_StorageStream_GetName = nullptr;
		pWrapperTable->m_StorageStream_GetMIMEType = nullptr;
		pWrapperTable->m_StorageStream_GetSHA2 = nullptr;
		pWrapperTable->m_StorageStream_GetSize = nullptr;
		pWrapperTable->m_StorageStream_GetContent = nullptr;
		pWrapperTable->m_StorageStream_GetCallbacks = nullptr;
		pWrapperTable->m_Storage_StreamIsReady = nullptr;
		pWrapperTable->m_Storage_RetrieveStream = nullptr;
		pWrapperTable->m_Storage_StoreNewStream = nullptr;
		pWrapperTable->m_Storage_BeginPartialStream = nullptr;
		pWrapperTable->m_Storage_StorePartialStream = nullptr;
		pWrapperTable->m_Storage_FinishPartialStream = nullptr;
		pWrapperTable->m_Storage_GetMaxStreamSize = nullptr;
		pWrapperTable->m_Storage_ContentTypeIsAccepted = nullptr;
		pWrapperTable->m_Storage_StreamIsImage = nullptr;
		pWrapperTable->m_BuildJobData_GetName = nullptr;
		pWrapperTable->m_BuildJobData_GetTimeStamp = nullptr;
		pWrapperTable->m_BuildJobData_GetStorageStream = nullptr;
		pWrapperTable->m_BuildJobData_GetDataType = nullptr;
		pWrapperTable->m_BuildJobData_GetMIMEType = nullptr;
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = nullptr;
		pWrapperTable->m_BuildJob_GetUUID = nullptr;
		pWrapperTable->m_BuildJob_GetName = nullptr;
		pWrapperTable->m_BuildJob_GetStatus = nullptr;
		pWrapperTable->m_BuildJob_GetLayerCount = nullptr;
		pWrapperTable->m_BuildJob_GetTimeStamp = nullptr;
		pWrapperTable->m_BuildJob_GetStorageStream = nullptr;
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = nullptr;
		pWrapperTable->m_BuildJob_GetBuildJobLogger = nullptr;
		pWrapperTable->m_BuildJob_StartValidating = nullptr;
		pWrapperTable->m_BuildJob_FinishValidating = nullptr;
		pWrapperTable->m_BuildJob_ArchiveJob = nullptr;
		pWrapperTable->m_BuildJob_UnArchiveJob = nullptr;
		pWrapperTable->m_BuildJob_DeleteJob = nullptr;
		pWrapperTable->m_BuildJob_JobCanBeArchived = nullptr;
		pWrapperTable->m_BuildJob_AddJobData = nullptr;
		pWrapperTable->m_BuildJob_ListJobDataByType = nullptr;
		pWrapperTable->m_BuildJob_ListJobData = nullptr;
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = nullptr;
		pWrapperTable->m_BuildJobHandler_CreateJob = nullptr;
		pWrapperTable->m_BuildJobHandler_RetrieveJob = nullptr;
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = nullptr;
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = nullptr;
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = nullptr;
		pWrapperTable->m_LoginHandler_UserExists = nullptr;
		pWrapperTable->m_LoginHandler_GetUserDetails = nullptr;
		pWrapperTable->m_DataModel_InitialiseDatabase = nullptr;
		pWrapperTable->m_DataModel_GetDataModelVersion = nullptr;
		pWrapperTable->m_DataModel_GetInstallationInformation = nullptr;
		pWrapperTable->m_DataModel_CreateStorage = nullptr;
		pWrapperTable->m_DataModel_CreateBuildJobHandler = nullptr;
		pWrapperTable->m_DataModel_CreateNewLogSession = nullptr;
		pWrapperTable->m_DataModel_CreateLoginHandler = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDataModelInstance = nullptr;
		
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::releaseWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::loadWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = (int)strlen(pLibraryFileName);
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCDataIterator_MoveNextPtr) GetProcAddress(hLibrary, "libmcdata_iterator_movenext");
		#else // _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCDataIterator_MoveNextPtr) dlsym(hLibrary, "libmcdata_iterator_movenext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MoveNext == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCDataIterator_MovePreviousPtr) GetProcAddress(hLibrary, "libmcdata_iterator_moveprevious");
		#else // _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCDataIterator_MovePreviousPtr) dlsym(hLibrary, "libmcdata_iterator_moveprevious");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MovePrevious == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCDataIterator_GetCurrentPtr) GetProcAddress(hLibrary, "libmcdata_iterator_getcurrent");
		#else // _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCDataIterator_GetCurrentPtr) dlsym(hLibrary, "libmcdata_iterator_getcurrent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_GetCurrent == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCDataIterator_ClonePtr) GetProcAddress(hLibrary, "libmcdata_iterator_clone");
		#else // _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCDataIterator_ClonePtr) dlsym(hLibrary, "libmcdata_iterator_clone");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Clone == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCDataIterator_CountPtr) GetProcAddress(hLibrary, "libmcdata_iterator_count");
		#else // _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCDataIterator_CountPtr) dlsym(hLibrary, "libmcdata_iterator_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Count == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogSession_AddEntry = (PLibMCDataLogSession_AddEntryPtr) GetProcAddress(hLibrary, "libmcdata_logsession_addentry");
		#else // _WIN32
		pWrapperTable->m_LogSession_AddEntry = (PLibMCDataLogSession_AddEntryPtr) dlsym(hLibrary, "libmcdata_logsession_addentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogSession_AddEntry == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetUUID = (PLibMCDataStorageStream_GetUUIDPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getuuid");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetUUID = (PLibMCDataStorageStream_GetUUIDPtr) dlsym(hLibrary, "libmcdata_storagestream_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetTimeStamp = (PLibMCDataStorageStream_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetTimeStamp = (PLibMCDataStorageStream_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_storagestream_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetName = (PLibMCDataStorageStream_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getname");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetName = (PLibMCDataStorageStream_GetNamePtr) dlsym(hLibrary, "libmcdata_storagestream_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetMIMEType = (PLibMCDataStorageStream_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getmimetype");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetMIMEType = (PLibMCDataStorageStream_GetMIMETypePtr) dlsym(hLibrary, "libmcdata_storagestream_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetMIMEType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetSHA2 = (PLibMCDataStorageStream_GetSHA2Ptr) GetProcAddress(hLibrary, "libmcdata_storagestream_getsha2");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetSHA2 = (PLibMCDataStorageStream_GetSHA2Ptr) dlsym(hLibrary, "libmcdata_storagestream_getsha2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetSHA2 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetSize = (PLibMCDataStorageStream_GetSizePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getsize");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetSize = (PLibMCDataStorageStream_GetSizePtr) dlsym(hLibrary, "libmcdata_storagestream_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetContent = (PLibMCDataStorageStream_GetContentPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcontent");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetContent = (PLibMCDataStorageStream_GetContentPtr) dlsym(hLibrary, "libmcdata_storagestream_getcontent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetContent == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetCallbacks = (PLibMCDataStorageStream_GetCallbacksPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcallbacks");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetCallbacks = (PLibMCDataStorageStream_GetCallbacksPtr) dlsym(hLibrary, "libmcdata_storagestream_getcallbacks");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetCallbacks == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StreamIsReady = (PLibMCDataStorage_StreamIsReadyPtr) GetProcAddress(hLibrary, "libmcdata_storage_streamisready");
		#else // _WIN32
		pWrapperTable->m_Storage_StreamIsReady = (PLibMCDataStorage_StreamIsReadyPtr) dlsym(hLibrary, "libmcdata_storage_streamisready");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StreamIsReady == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_RetrieveStream = (PLibMCDataStorage_RetrieveStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_retrievestream");
		#else // _WIN32
		pWrapperTable->m_Storage_RetrieveStream = (PLibMCDataStorage_RetrieveStreamPtr) dlsym(hLibrary, "libmcdata_storage_retrievestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_RetrieveStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StoreNewStream = (PLibMCDataStorage_StoreNewStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_storenewstream");
		#else // _WIN32
		pWrapperTable->m_Storage_StoreNewStream = (PLibMCDataStorage_StoreNewStreamPtr) dlsym(hLibrary, "libmcdata_storage_storenewstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StoreNewStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_BeginPartialStream = (PLibMCDataStorage_BeginPartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_beginpartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_BeginPartialStream = (PLibMCDataStorage_BeginPartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_beginpartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_BeginPartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StorePartialStream = (PLibMCDataStorage_StorePartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_storepartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_StorePartialStream = (PLibMCDataStorage_StorePartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_storepartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StorePartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_FinishPartialStream = (PLibMCDataStorage_FinishPartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_finishpartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_FinishPartialStream = (PLibMCDataStorage_FinishPartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_finishpartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_FinishPartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_GetMaxStreamSize = (PLibMCDataStorage_GetMaxStreamSizePtr) GetProcAddress(hLibrary, "libmcdata_storage_getmaxstreamsize");
		#else // _WIN32
		pWrapperTable->m_Storage_GetMaxStreamSize = (PLibMCDataStorage_GetMaxStreamSizePtr) dlsym(hLibrary, "libmcdata_storage_getmaxstreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_GetMaxStreamSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_ContentTypeIsAccepted = (PLibMCDataStorage_ContentTypeIsAcceptedPtr) GetProcAddress(hLibrary, "libmcdata_storage_contenttypeisaccepted");
		#else // _WIN32
		pWrapperTable->m_Storage_ContentTypeIsAccepted = (PLibMCDataStorage_ContentTypeIsAcceptedPtr) dlsym(hLibrary, "libmcdata_storage_contenttypeisaccepted");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_ContentTypeIsAccepted == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StreamIsImage = (PLibMCDataStorage_StreamIsImagePtr) GetProcAddress(hLibrary, "libmcdata_storage_streamisimage");
		#else // _WIN32
		pWrapperTable->m_Storage_StreamIsImage = (PLibMCDataStorage_StreamIsImagePtr) dlsym(hLibrary, "libmcdata_storage_streamisimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StreamIsImage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetName = (PLibMCDataBuildJobData_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getname");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetName = (PLibMCDataBuildJobData_GetNamePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetTimeStamp = (PLibMCDataBuildJobData_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetTimeStamp = (PLibMCDataBuildJobData_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_buildjobdata_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStream = (PLibMCDataBuildJobData_GetStorageStreamPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getstoragestream");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStream = (PLibMCDataBuildJobData_GetStorageStreamPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getstoragestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetStorageStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetDataType = (PLibMCDataBuildJobData_GetDataTypePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getdatatype");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetDataType = (PLibMCDataBuildJobData_GetDataTypePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getdatatype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetDataType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetMIMEType = (PLibMCDataBuildJobData_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getmimetype");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetMIMEType = (PLibMCDataBuildJobData_GetMIMETypePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetMIMEType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = (PLibMCDataBuildJobDataIterator_GetCurrentJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdataiterator_getcurrentjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = (PLibMCDataBuildJobDataIterator_GetCurrentJobDataPtr) dlsym(hLibrary, "libmcdata_buildjobdataiterator_getcurrentjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetUUID = (PLibMCDataBuildJob_GetUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetUUID = (PLibMCDataBuildJob_GetUUIDPtr) dlsym(hLibrary, "libmcdata_buildjob_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetName = (PLibMCDataBuildJob_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getname");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetName = (PLibMCDataBuildJob_GetNamePtr) dlsym(hLibrary, "libmcdata_buildjob_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStatus = (PLibMCDataBuildJob_GetStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstatus");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStatus = (PLibMCDataBuildJob_GetStatusPtr) dlsym(hLibrary, "libmcdata_buildjob_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetLayerCount = (PLibMCDataBuildJob_GetLayerCountPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getlayercount");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetLayerCount = (PLibMCDataBuildJob_GetLayerCountPtr) dlsym(hLibrary, "libmcdata_buildjob_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetLayerCount == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetTimeStamp = (PLibMCDataBuildJob_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetTimeStamp = (PLibMCDataBuildJob_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_buildjob_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStorageStream = (PLibMCDataBuildJob_GetStorageStreamPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstoragestream");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStorageStream = (PLibMCDataBuildJob_GetStorageStreamPtr) dlsym(hLibrary, "libmcdata_buildjob_getstoragestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStorageStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = (PLibMCDataBuildJob_GetStorageStreamUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstoragestreamuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = (PLibMCDataBuildJob_GetStorageStreamUUIDPtr) dlsym(hLibrary, "libmcdata_buildjob_getstoragestreamuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStorageStreamUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetBuildJobLogger = (PLibMCDataBuildJob_GetBuildJobLoggerPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getbuildjoblogger");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetBuildJobLogger = (PLibMCDataBuildJob_GetBuildJobLoggerPtr) dlsym(hLibrary, "libmcdata_buildjob_getbuildjoblogger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetBuildJobLogger == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_StartValidating = (PLibMCDataBuildJob_StartValidatingPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_startvalidating");
		#else // _WIN32
		pWrapperTable->m_BuildJob_StartValidating = (PLibMCDataBuildJob_StartValidatingPtr) dlsym(hLibrary, "libmcdata_buildjob_startvalidating");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_StartValidating == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_FinishValidating = (PLibMCDataBuildJob_FinishValidatingPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_finishvalidating");
		#else // _WIN32
		pWrapperTable->m_BuildJob_FinishValidating = (PLibMCDataBuildJob_FinishValidatingPtr) dlsym(hLibrary, "libmcdata_buildjob_finishvalidating");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_FinishValidating == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ArchiveJob = (PLibMCDataBuildJob_ArchiveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_archivejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ArchiveJob = (PLibMCDataBuildJob_ArchiveJobPtr) dlsym(hLibrary, "libmcdata_buildjob_archivejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ArchiveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_UnArchiveJob = (PLibMCDataBuildJob_UnArchiveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_unarchivejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_UnArchiveJob = (PLibMCDataBuildJob_UnArchiveJobPtr) dlsym(hLibrary, "libmcdata_buildjob_unarchivejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_UnArchiveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_DeleteJob = (PLibMCDataBuildJob_DeleteJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_deletejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_DeleteJob = (PLibMCDataBuildJob_DeleteJobPtr) dlsym(hLibrary, "libmcdata_buildjob_deletejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_DeleteJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_JobCanBeArchived = (PLibMCDataBuildJob_JobCanBeArchivedPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_jobcanbearchived");
		#else // _WIN32
		pWrapperTable->m_BuildJob_JobCanBeArchived = (PLibMCDataBuildJob_JobCanBeArchivedPtr) dlsym(hLibrary, "libmcdata_buildjob_jobcanbearchived");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_JobCanBeArchived == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_AddJobData = (PLibMCDataBuildJob_AddJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_addjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_AddJobData = (PLibMCDataBuildJob_AddJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_addjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_AddJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ListJobDataByType = (PLibMCDataBuildJob_ListJobDataByTypePtr) GetProcAddress(hLibrary, "libmcdata_buildjob_listjobdatabytype");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ListJobDataByType = (PLibMCDataBuildJob_ListJobDataByTypePtr) dlsym(hLibrary, "libmcdata_buildjob_listjobdatabytype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ListJobDataByType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ListJobData = (PLibMCDataBuildJob_ListJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_listjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ListJobData = (PLibMCDataBuildJob_ListJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_listjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ListJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = (PLibMCDataBuildJobIterator_GetCurrentJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobiterator_getcurrentjob");
		#else // _WIN32
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = (PLibMCDataBuildJobIterator_GetCurrentJobPtr) dlsym(hLibrary, "libmcdata_buildjobiterator_getcurrentjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobIterator_GetCurrentJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_CreateJob = (PLibMCDataBuildJobHandler_CreateJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_createjob");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_CreateJob = (PLibMCDataBuildJobHandler_CreateJobPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_createjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_CreateJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_RetrieveJob = (PLibMCDataBuildJobHandler_RetrieveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_retrievejob");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_RetrieveJob = (PLibMCDataBuildJobHandler_RetrieveJobPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_retrievejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_RetrieveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = (PLibMCDataBuildJobHandler_ListJobsByStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_listjobsbystatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = (PLibMCDataBuildJobHandler_ListJobsByStatusPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_listjobsbystatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ListJobsByStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = (PLibMCDataBuildJobHandler_ConvertBuildStatusToStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_convertbuildstatustostring");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = (PLibMCDataBuildJobHandler_ConvertBuildStatusToStringPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_convertbuildstatustostring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = (PLibMCDataBuildJobHandler_ConvertStringToBuildStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_convertstringtobuildstatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = (PLibMCDataBuildJobHandler_ConvertStringToBuildStatusPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_convertstringtobuildstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_UserExists = (PLibMCDataLoginHandler_UserExistsPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_userexists");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_UserExists = (PLibMCDataLoginHandler_UserExistsPtr) dlsym(hLibrary, "libmcdata_loginhandler_userexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_UserExists == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserDetails = (PLibMCDataLoginHandler_GetUserDetailsPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserdetails");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserDetails = (PLibMCDataLoginHandler_GetUserDetailsPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserdetails");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserDetails == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_InitialiseDatabase = (PLibMCDataDataModel_InitialiseDatabasePtr) GetProcAddress(hLibrary, "libmcdata_datamodel_initialisedatabase");
		#else // _WIN32
		pWrapperTable->m_DataModel_InitialiseDatabase = (PLibMCDataDataModel_InitialiseDatabasePtr) dlsym(hLibrary, "libmcdata_datamodel_initialisedatabase");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_InitialiseDatabase == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetDataModelVersion = (PLibMCDataDataModel_GetDataModelVersionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getdatamodelversion");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetDataModelVersion = (PLibMCDataDataModel_GetDataModelVersionPtr) dlsym(hLibrary, "libmcdata_datamodel_getdatamodelversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetDataModelVersion == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformation = (PLibMCDataDataModel_GetInstallationInformationPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getinstallationinformation");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformation = (PLibMCDataDataModel_GetInstallationInformationPtr) dlsym(hLibrary, "libmcdata_datamodel_getinstallationinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetInstallationInformation == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateStorage = (PLibMCDataDataModel_CreateStoragePtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createstorage");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateStorage = (PLibMCDataDataModel_CreateStoragePtr) dlsym(hLibrary, "libmcdata_datamodel_createstorage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateStorage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateBuildJobHandler = (PLibMCDataDataModel_CreateBuildJobHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createbuildjobhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateBuildJobHandler = (PLibMCDataDataModel_CreateBuildJobHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createbuildjobhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateBuildJobHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateNewLogSession = (PLibMCDataDataModel_CreateNewLogSessionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createnewlogsession");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateNewLogSession = (PLibMCDataDataModel_CreateNewLogSessionPtr) dlsym(hLibrary, "libmcdata_datamodel_createnewlogsession");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateNewLogSession == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateLoginHandler = (PLibMCDataDataModel_CreateLoginHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createloginhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateLoginHandler = (PLibMCDataDataModel_CreateLoginHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createloginhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateLoginHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDataGetVersionPtr) GetProcAddress(hLibrary, "libmcdata_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDataGetVersionPtr) dlsym(hLibrary, "libmcdata_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDataGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdata_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDataGetLastErrorPtr) dlsym(hLibrary, "libmcdata_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDataReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdata_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDataReleaseInstancePtr) dlsym(hLibrary, "libmcdata_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDataAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdata_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDataAcquireInstancePtr) dlsym(hLibrary, "libmcdata_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDataGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdata_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDataGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdata_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDataModelInstance = (PLibMCDataCreateDataModelInstancePtr) GetProcAddress(hLibrary, "libmcdata_createdatamodelinstance");
		#else // _WIN32
		pWrapperTable->m_CreateDataModelInstance = (PLibMCDataCreateDataModelInstancePtr) dlsym(hLibrary, "libmcdata_createdatamodelinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDataModelInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDataDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		typedef LibMCDataResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDataResult eLookupError = LIBMCDATA_SUCCESS;
		eLookupError = (*pLookup)("libmcdata_iterator_movenext", (void**)&(pWrapperTable->m_Iterator_MoveNext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MoveNext == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_moveprevious", (void**)&(pWrapperTable->m_Iterator_MovePrevious));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MovePrevious == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_getcurrent", (void**)&(pWrapperTable->m_Iterator_GetCurrent));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_GetCurrent == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_clone", (void**)&(pWrapperTable->m_Iterator_Clone));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Clone == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_count", (void**)&(pWrapperTable->m_Iterator_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Count == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logsession_addentry", (void**)&(pWrapperTable->m_LogSession_AddEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogSession_AddEntry == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getuuid", (void**)&(pWrapperTable->m_StorageStream_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_gettimestamp", (void**)&(pWrapperTable->m_StorageStream_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getname", (void**)&(pWrapperTable->m_StorageStream_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getmimetype", (void**)&(pWrapperTable->m_StorageStream_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetMIMEType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getsha2", (void**)&(pWrapperTable->m_StorageStream_GetSHA2));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetSHA2 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getsize", (void**)&(pWrapperTable->m_StorageStream_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcontent", (void**)&(pWrapperTable->m_StorageStream_GetContent));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetContent == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcallbacks", (void**)&(pWrapperTable->m_StorageStream_GetCallbacks));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetCallbacks == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_streamisready", (void**)&(pWrapperTable->m_Storage_StreamIsReady));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StreamIsReady == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_retrievestream", (void**)&(pWrapperTable->m_Storage_RetrieveStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_RetrieveStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_storenewstream", (void**)&(pWrapperTable->m_Storage_StoreNewStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StoreNewStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_beginpartialstream", (void**)&(pWrapperTable->m_Storage_BeginPartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_BeginPartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_storepartialstream", (void**)&(pWrapperTable->m_Storage_StorePartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StorePartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_finishpartialstream", (void**)&(pWrapperTable->m_Storage_FinishPartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_FinishPartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_getmaxstreamsize", (void**)&(pWrapperTable->m_Storage_GetMaxStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_GetMaxStreamSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_contenttypeisaccepted", (void**)&(pWrapperTable->m_Storage_ContentTypeIsAccepted));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_ContentTypeIsAccepted == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_streamisimage", (void**)&(pWrapperTable->m_Storage_StreamIsImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StreamIsImage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getname", (void**)&(pWrapperTable->m_BuildJobData_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_gettimestamp", (void**)&(pWrapperTable->m_BuildJobData_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getstoragestream", (void**)&(pWrapperTable->m_BuildJobData_GetStorageStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetStorageStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getdatatype", (void**)&(pWrapperTable->m_BuildJobData_GetDataType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetDataType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getmimetype", (void**)&(pWrapperTable->m_BuildJobData_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetMIMEType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdataiterator_getcurrentjobdata", (void**)&(pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getuuid", (void**)&(pWrapperTable->m_BuildJob_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getname", (void**)&(pWrapperTable->m_BuildJob_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstatus", (void**)&(pWrapperTable->m_BuildJob_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getlayercount", (void**)&(pWrapperTable->m_BuildJob_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetLayerCount == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_gettimestamp", (void**)&(pWrapperTable->m_BuildJob_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstoragestream", (void**)&(pWrapperTable->m_BuildJob_GetStorageStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStorageStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstoragestreamuuid", (void**)&(pWrapperTable->m_BuildJob_GetStorageStreamUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStorageStreamUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getbuildjoblogger", (void**)&(pWrapperTable->m_BuildJob_GetBuildJobLogger));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetBuildJobLogger == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_startvalidating", (void**)&(pWrapperTable->m_BuildJob_StartValidating));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_StartValidating == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_finishvalidating", (void**)&(pWrapperTable->m_BuildJob_FinishValidating));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_FinishValidating == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_archivejob", (void**)&(pWrapperTable->m_BuildJob_ArchiveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ArchiveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_unarchivejob", (void**)&(pWrapperTable->m_BuildJob_UnArchiveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_UnArchiveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_deletejob", (void**)&(pWrapperTable->m_BuildJob_DeleteJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_DeleteJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_jobcanbearchived", (void**)&(pWrapperTable->m_BuildJob_JobCanBeArchived));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_JobCanBeArchived == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_addjobdata", (void**)&(pWrapperTable->m_BuildJob_AddJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_AddJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_listjobdatabytype", (void**)&(pWrapperTable->m_BuildJob_ListJobDataByType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ListJobDataByType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_listjobdata", (void**)&(pWrapperTable->m_BuildJob_ListJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ListJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobiterator_getcurrentjob", (void**)&(pWrapperTable->m_BuildJobIterator_GetCurrentJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobIterator_GetCurrentJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_createjob", (void**)&(pWrapperTable->m_BuildJobHandler_CreateJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_CreateJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_retrievejob", (void**)&(pWrapperTable->m_BuildJobHandler_RetrieveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_RetrieveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_listjobsbystatus", (void**)&(pWrapperTable->m_BuildJobHandler_ListJobsByStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ListJobsByStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_convertbuildstatustostring", (void**)&(pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_convertstringtobuildstatus", (void**)&(pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_userexists", (void**)&(pWrapperTable->m_LoginHandler_UserExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_UserExists == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserdetails", (void**)&(pWrapperTable->m_LoginHandler_GetUserDetails));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserDetails == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_initialisedatabase", (void**)&(pWrapperTable->m_DataModel_InitialiseDatabase));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_InitialiseDatabase == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getdatamodelversion", (void**)&(pWrapperTable->m_DataModel_GetDataModelVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetDataModelVersion == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getinstallationinformation", (void**)&(pWrapperTable->m_DataModel_GetInstallationInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetInstallationInformation == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createstorage", (void**)&(pWrapperTable->m_DataModel_CreateStorage));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateStorage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createbuildjobhandler", (void**)&(pWrapperTable->m_DataModel_CreateBuildJobHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateBuildJobHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createnewlogsession", (void**)&(pWrapperTable->m_DataModel_CreateNewLogSession));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateNewLogSession == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createloginhandler", (void**)&(pWrapperTable->m_DataModel_CreateLoginHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateLoginHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_createdatamodelinstance", (void**)&(pWrapperTable->m_CreateDataModelInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDataModelInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDATA_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CIterator
	 */
	
	/**
	* CIterator::MoveNext - Iterates to the next resource in the list.
	* @return Iterates to the next resource in the list.
	*/
	bool CIterator::MoveNext()
	{
		bool resultHasNext = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MoveNext(m_pHandle, &resultHasNext));
		
		return resultHasNext;
	}
	
	/**
	* CIterator::MovePrevious - Iterates to the previous resource in the list.
	* @return Iterates to the previous resource in the list.
	*/
	bool CIterator::MovePrevious()
	{
		bool resultHasPrevious = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MovePrevious(m_pHandle, &resultHasPrevious));
		
		return resultHasPrevious;
	}
	
	/**
	* CIterator::GetCurrent - Returns the resource the iterator points at.
	* @return returns the resource instance.
	*/
	PBase CIterator::GetCurrent()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_GetCurrent(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBase>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	* CIterator::Clone - Creates a new resource iterator with the same resource list.
	* @return returns the cloned Iterator instance
	*/
	PIterator CIterator::Clone()
	{
		LibMCDataHandle hOutIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Clone(m_pHandle, &hOutIterator));
		
		if (!hOutIterator) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CIterator>(m_pWrapper, hOutIterator);
	}
	
	/**
	* CIterator::Count - Returns the number of resoucres the iterator captures.
	* @return returns the number of resources the iterator captures.
	*/
	LibMCData_uint64 CIterator::Count()
	{
		LibMCData_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CLogSession
	 */
	
	/**
	* CLogSession::AddEntry - adds a new log entry.
	* @param[in] sMessage - Log Message
	* @param[in] sSubSystem - Sub System identifier
	* @param[in] eLogLevel - Log Level
	* @param[in] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	void CLogSession::AddEntry(const std::string & sMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_AddEntry(m_pHandle, sMessage.c_str(), sSubSystem.c_str(), eLogLevel, sTimestamp.c_str()));
	}
	
	/**
	 * Method definitions for class CStorageStream
	 */
	
	/**
	* CStorageStream::GetUUID - returns the uuid of a storage stream.
	* @return UUID String
	*/
	std::string CStorageStream::GetUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CStorageStream::GetTimeStamp - returns the timestamp of a storage stream.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CStorageStream::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CStorageStream::GetName - returns the name of a storage stream.
	* @return Name String
	*/
	std::string CStorageStream::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CStorageStream::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	std::string CStorageStream::GetMIMEType()
	{
		LibMCData_uint32 bytesNeededMimeType = 0;
		LibMCData_uint32 bytesWrittenMimeType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetMIMEType(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetMIMEType(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	* CStorageStream::GetSHA2 - returns the sha256 checksum of a storage stream.
	* @return SHA1 String
	*/
	std::string CStorageStream::GetSHA2()
	{
		LibMCData_uint32 bytesNeededSHA2 = 0;
		LibMCData_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSHA2(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSHA2(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CStorageStream::GetSize - returns the size of a storage stream.
	* @return Size
	*/
	LibMCData_uint64 CStorageStream::GetSize()
	{
		LibMCData_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CStorageStream::GetContent - returns the content of a storage stream.
	* @param[out] ContentBuffer - Byte Content of the stream
	*/
	void CStorageStream::GetContent(std::vector<LibMCData_uint8> & ContentBuffer)
	{
		LibMCData_uint64 elementsNeededContent = 0;
		LibMCData_uint64 elementsWrittenContent = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContent(m_pHandle, 0, &elementsNeededContent, nullptr));
		ContentBuffer.resize((size_t) elementsNeededContent);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContent(m_pHandle, elementsNeededContent, &elementsWrittenContent, ContentBuffer.data()));
	}
	
	/**
	* CStorageStream::GetCallbacks - returns direct read access to the storage stream. The callbacks are only valid throughout the existence of the StorageStream instance.
	* @param[out] pTheReadCallback - Callback to call for reading a data chunk
	* @param[out] pTheSeekCallback - Callback to call for seeking in the stream.
	* @param[out] pStreamHandle - Handle of the stream.
	*/
	void CStorageStream::GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetCallbacks(m_pHandle, &pTheReadCallback, &pTheSeekCallback, &pStreamHandle));
	}
	
	/**
	 * Method definitions for class CStorage
	 */
	
	/**
	* CStorage::StreamIsReady - checks if a stream exists and is written to disk.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream is ready.
	*/
	bool CStorage::StreamIsReady(const std::string & sUUID)
	{
		bool resultIsReady = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StreamIsReady(m_pHandle, sUUID.c_str(), &resultIsReady));
		
		return resultIsReady;
	}
	
	/**
	* CStorage::RetrieveStream - retrieves an existing stream.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream Instance.
	*/
	PStorageStream CStorage::RetrieveStream(const std::string & sUUID)
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_RetrieveStream(m_pHandle, sUUID.c_str(), &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CStorage::StoreNewStream - stores a new stream.
	* @param[in] sUUID - UUID of storage stream. Must be unique and newly generated.
	* @param[in] sContextUUID - Context UUID of storage stream. Important for ownership and deletion.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] ContentBuffer - Data of stream
	* @param[in] sUserID - Currently authenticated user
	*/
	void CStorage::StoreNewStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sName, const std::string & sMimeType, const CInputVector<LibMCData_uint8> & ContentBuffer, const std::string & sUserID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StoreNewStream(m_pHandle, sUUID.c_str(), sContextUUID.c_str(), sName.c_str(), sMimeType.c_str(), (LibMCData_uint64)ContentBuffer.size(), ContentBuffer.data(), sUserID.c_str()));
	}
	
	/**
	* CStorage::BeginPartialStream - starts storing a stream with partial uploads.
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sContextUUID - Context UUID of storage stream. Important for ownership and deletion.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] nSize - Final size of the stream. MUST NOT be 0.
	* @param[in] sUserID - Currently authenticated user
	*/
	void CStorage::BeginPartialStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_BeginPartialStream(m_pHandle, sUUID.c_str(), sContextUUID.c_str(), sName.c_str(), sMimeType.c_str(), nSize, sUserID.c_str()));
	}
	
	/**
	* CStorage::StorePartialStream - stores data in a stream with partial uploads. Uploads should be sequential for optimal performance, but may be in arbitrary order.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] nOffset - Offset in stream to store to. Can be an arbitrary position, but storage MUST NOT override already uploaded data.
	* @param[in] ContentBuffer - Data block to store in stream.
	*/
	void CStorage::StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StorePartialStream(m_pHandle, sUUID.c_str(), nOffset, (LibMCData_uint64)ContentBuffer.size(), ContentBuffer.data()));
	}
	
	/**
	* CStorage::FinishPartialStream - Finishes storing a stream.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sSHA2 - SHA256 of the uploaded data. If given initially, MUST be identical.
	*/
	void CStorage::FinishPartialStream(const std::string & sUUID, const std::string & sSHA2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_FinishPartialStream(m_pHandle, sUUID.c_str(), sSHA2.c_str()));
	}
	
	/**
	* CStorage::GetMaxStreamSize - Returns the maximum stream size that the data model allows.
	* @return Maximum Stream Size in Bytes.
	*/
	LibMCData_uint64 CStorage::GetMaxStreamSize()
	{
		LibMCData_uint64 resultMaxStreamSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_GetMaxStreamSize(m_pHandle, &resultMaxStreamSize));
		
		return resultMaxStreamSize;
	}
	
	/**
	* CStorage::ContentTypeIsAccepted - Returns if the given content type is an acceptable value.
	* @param[in] sContentType - Content type string (is taken case-insensitive)
	* @return Content type is accepted.
	*/
	bool CStorage::ContentTypeIsAccepted(const std::string & sContentType)
	{
		bool resultAccepted = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_ContentTypeIsAccepted(m_pHandle, sContentType.c_str(), &resultAccepted));
		
		return resultAccepted;
	}
	
	/**
	* CStorage::StreamIsImage - checks if a stream is an image.
	* @param[in] sUUID - UUID of storage stream.
	* @return Returns if the stream is an image.
	*/
	bool CStorage::StreamIsImage(const std::string & sUUID)
	{
		bool resultIsImage = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StreamIsImage(m_pHandle, sUUID.c_str(), &resultIsImage));
		
		return resultIsImage;
	}
	
	/**
	 * Method definitions for class CBuildJobData
	 */
	
	/**
	* CBuildJobData::GetName - returns the name of a build job.
	* @return Name String
	*/
	std::string CBuildJobData::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBuildJobData::GetTimeStamp - returns the timestamp when the job was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CBuildJobData::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CBuildJobData::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	PStorageStream CBuildJobData::GetStorageStream()
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetStorageStream(m_pHandle, &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CBuildJobData::GetDataType - returns the data type of the job data.
	* @return Data type of the job data
	*/
	eBuildJobDataType CBuildJobData::GetDataType()
	{
		eBuildJobDataType resultDataType = (eBuildJobDataType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataType(m_pHandle, &resultDataType));
		
		return resultDataType;
	}
	
	/**
	* CBuildJobData::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	std::string CBuildJobData::GetMIMEType()
	{
		LibMCData_uint32 bytesNeededMimeType = 0;
		LibMCData_uint32 bytesWrittenMimeType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetMIMEType(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetMIMEType(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	 * Method definitions for class CBuildJobDataIterator
	 */
	
	/**
	* CBuildJobDataIterator::GetCurrentJobData - Returns the build job data the iterator points at.
	* @return returns the build job instance.
	*/
	PBuildJobData CBuildJobDataIterator::GetCurrentJobData()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobDataIterator_GetCurrentJobData(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobData>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJob
	 */
	
	/**
	* CBuildJob::GetUUID - returns the uuid of a build job.
	* @return UUID String
	*/
	std::string CBuildJob::GetUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJob::GetName - returns the name of a build job.
	* @return Name String
	*/
	std::string CBuildJob::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBuildJob::GetStatus - returns the status of a build job.
	* @return Status of build job.
	*/
	eBuildJobStatus CBuildJob::GetStatus()
	{
		eBuildJobStatus resultStatus = (eBuildJobStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStatus(m_pHandle, &resultStatus));
		
		return resultStatus;
	}
	
	/**
	* CBuildJob::GetLayerCount - returns the layer count of a build job.
	* @return Layer Count of build job
	*/
	LibMCData_uint32 CBuildJob::GetLayerCount()
	{
		LibMCData_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CBuildJob::GetTimeStamp - returns the timestamp when the job was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CBuildJob::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CBuildJob::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	PStorageStream CBuildJob::GetStorageStream()
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStream(m_pHandle, &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CBuildJob::GetStorageStreamUUID - returns the storage stream uuid of the build.
	* @return Stream UUID.
	*/
	std::string CBuildJob::GetStorageStreamUUID()
	{
		LibMCData_uint32 bytesNeededStreamUUID = 0;
		LibMCData_uint32 bytesWrittenStreamUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStreamUUID(m_pHandle, 0, &bytesNeededStreamUUID, nullptr));
		std::vector<char> bufferStreamUUID(bytesNeededStreamUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStreamUUID(m_pHandle, bytesNeededStreamUUID, &bytesWrittenStreamUUID, &bufferStreamUUID[0]));
		
		return std::string(&bufferStreamUUID[0]);
	}
	
	/**
	* CBuildJob::GetBuildJobLogger - creates a build job log session access class.
	* @return LogSession class instance.
	*/
	PLogSession CBuildJob::GetBuildJobLogger()
	{
		LibMCDataHandle hLogSession = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetBuildJobLogger(m_pHandle, &hLogSession));
		
		if (!hLogSession) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogSession>(m_pWrapper, hLogSession);
	}
	
	/**
	* CBuildJob::StartValidating - Starts validation of a build job.
	*/
	void CBuildJob::StartValidating()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_StartValidating(m_pHandle));
	}
	
	/**
	* CBuildJob::FinishValidating - Finishes validation of a build job.
	* @param[in] nLayerCount - Layer count
	*/
	void CBuildJob::FinishValidating(const LibMCData_uint32 nLayerCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_FinishValidating(m_pHandle, nLayerCount));
	}
	
	/**
	* CBuildJob::ArchiveJob - Archives a Job. Job MUST not be opened in the system. Job MUST be of state validated.
	*/
	void CBuildJob::ArchiveJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ArchiveJob(m_pHandle));
	}
	
	/**
	* CBuildJob::UnArchiveJob - Unarchives a Job. Job MUST be of state archived.
	*/
	void CBuildJob::UnArchiveJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_UnArchiveJob(m_pHandle));
	}
	
	/**
	* CBuildJob::DeleteJob - Deletes a Job permanently including all referencing data objects. Job MUST be of state archived to succeed.
	*/
	void CBuildJob::DeleteJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_DeleteJob(m_pHandle));
	}
	
	/**
	* CBuildJob::JobCanBeArchived - Returns if a job is opened.
	* @return returns if the job can be archived.
	*/
	bool CBuildJob::JobCanBeArchived()
	{
		bool resultCanBeArchived = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_JobCanBeArchived(m_pHandle, &resultCanBeArchived));
		
		return resultCanBeArchived;
	}
	
	/**
	* CBuildJob::AddJobData - Adds additional data to the Job. Job MUST be of state validated in order to add job data.
	* @param[in] sName - Name of the job
	* @param[in] pStream - Storage Stream Instance
	* @param[in] eDataType - Datatype of Job data
	* @param[in] sUserID - Currently authenticated user
	*/
	void CBuildJob::AddJobData(const std::string & sName, classParam<CStorageStream> pStream, const eBuildJobDataType eDataType, const std::string & sUserID)
	{
		LibMCDataHandle hStream = pStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_AddJobData(m_pHandle, sName.c_str(), hStream, eDataType, sUserID.c_str()));
	}
	
	/**
	* CBuildJob::ListJobDataByType - Retrieves a list of build job data objects, filtered by type.
	* @param[in] eDataType - Datatype of Job data.
	* @return Build Job Data Iterator Instance.
	*/
	PBuildJobDataIterator CBuildJob::ListJobDataByType(const eBuildJobDataType eDataType)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ListJobDataByType(m_pHandle, eDataType, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJob::ListJobData - Retrieves a list of build job data objects.
	* @return Build Job Data Iterator Instance.
	*/
	PBuildJobDataIterator CBuildJob::ListJobData()
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ListJobData(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	 * Method definitions for class CBuildJobIterator
	 */
	
	/**
	* CBuildJobIterator::GetCurrentJob - Returns the build job the iterator points at.
	* @return returns the build job instance.
	*/
	PBuildJob CBuildJobIterator::GetCurrentJob()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobIterator_GetCurrentJob(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJobHandler
	 */
	
	/**
	* CBuildJobHandler::CreateJob - Creates a new build job.
	* @param[in] sJobUUID - UUID String for the build job. Must be unique and newly generated.
	* @param[in] sName - Name String
	* @param[in] sUserID - Currently authenticated user
	* @param[in] sStorageStreamUUID - Storage stream uuid for the job. Needs not exist yet.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID)
	{
		LibMCDataHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_CreateJob(m_pHandle, sJobUUID.c_str(), sName.c_str(), sUserID.c_str(), sStorageStreamUUID.c_str(), &hJobInstance));
		
		if (!hJobInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hJobInstance);
	}
	
	/**
	* CBuildJobHandler::RetrieveJob - Retrieves a job with a specific UUID.
	* @param[in] sJobUUID - UUID String for the build job. Must be an existing Job.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::RetrieveJob(const std::string & sJobUUID)
	{
		LibMCDataHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_RetrieveJob(m_pHandle, sJobUUID.c_str(), &hJobInstance));
		
		if (!hJobInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hJobInstance);
	}
	
	/**
	* CBuildJobHandler::ListJobsByStatus - Retrieves a list of build jobs, filtered by status.
	* @param[in] eStatus - Job Status to list.
	* @return Build Job Iterator Instance.
	*/
	PBuildJobIterator CBuildJobHandler::ListJobsByStatus(const eBuildJobStatus eStatus)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ListJobsByStatus(m_pHandle, eStatus, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJobHandler::ConvertBuildStatusToString - Converts a status enum to a string identifier.
	* @param[in] eStatus - Status Enum.
	* @return String Identifier.
	*/
	std::string CBuildJobHandler::ConvertBuildStatusToString(const eBuildJobStatus eStatus)
	{
		LibMCData_uint32 bytesNeededString = 0;
		LibMCData_uint32 bytesWrittenString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertBuildStatusToString(m_pHandle, eStatus, 0, &bytesNeededString, nullptr));
		std::vector<char> bufferString(bytesNeededString);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertBuildStatusToString(m_pHandle, eStatus, bytesNeededString, &bytesWrittenString, &bufferString[0]));
		
		return std::string(&bufferString[0]);
	}
	
	/**
	* CBuildJobHandler::ConvertStringToBuildStatus - Converts a string identifier to a status enum. Case sensitive. Fails if invalid.
	* @param[in] sString - String Identifier.
	* @return Status Enum.
	*/
	eBuildJobStatus CBuildJobHandler::ConvertStringToBuildStatus(const std::string & sString)
	{
		eBuildJobStatus resultStatus = (eBuildJobStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertStringToBuildStatus(m_pHandle, sString.c_str(), &resultStatus));
		
		return resultStatus;
	}
	
	/**
	 * Method definitions for class CLoginHandler
	 */
	
	/**
	* CLoginHandler::UserExists - Checks if a user exist.
	* @param[in] sUsername - User name
	* @return Flag if users exists
	*/
	bool CLoginHandler::UserExists(const std::string & sUsername)
	{
		bool resultUserExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_UserExists(m_pHandle, sUsername.c_str(), &resultUserExists));
		
		return resultUserExists;
	}
	
	/**
	* CLoginHandler::GetUserDetails - Retrieves a users data.
	* @param[in] sUsername - User name
	* @param[out] sSalt - Salt of the user.
	* @param[out] sHashedPassword - Hashed Password.
	*/
	void CLoginHandler::GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword)
	{
		LibMCData_uint32 bytesNeededSalt = 0;
		LibMCData_uint32 bytesWrittenSalt = 0;
		LibMCData_uint32 bytesNeededHashedPassword = 0;
		LibMCData_uint32 bytesWrittenHashedPassword = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDetails(m_pHandle, sUsername.c_str(), 0, &bytesNeededSalt, nullptr, 0, &bytesNeededHashedPassword, nullptr));
		std::vector<char> bufferSalt(bytesNeededSalt);
		std::vector<char> bufferHashedPassword(bytesNeededHashedPassword);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDetails(m_pHandle, sUsername.c_str(), bytesNeededSalt, &bytesWrittenSalt, &bufferSalt[0], bytesNeededHashedPassword, &bytesWrittenHashedPassword, &bufferHashedPassword[0]));
		sSalt = std::string(&bufferSalt[0]);
		sHashedPassword = std::string(&bufferHashedPassword[0]);
	}
	
	/**
	 * Method definitions for class CDataModel
	 */
	
	/**
	* CDataModel::InitialiseDatabase - initializes the database connection.
	* @param[in] sDataDirectory - Directory that stores the data.
	* @param[in] eDataBaseType - Type of database.
	* @param[in] sConnectionString - Connection string.
	*/
	void CDataModel::InitialiseDatabase(const std::string & sDataDirectory, const eDataBaseType eDataBaseType, const std::string & sConnectionString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_InitialiseDatabase(m_pHandle, sDataDirectory.c_str(), eDataBaseType, sConnectionString.c_str()));
	}
	
	/**
	* CDataModel::GetDataModelVersion - returns the linear data model version.
	* @return Data model version.
	*/
	LibMCData_uint32 CDataModel::GetDataModelVersion()
	{
		LibMCData_uint32 resultVersion = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetDataModelVersion(m_pHandle, &resultVersion));
		
		return resultVersion;
	}
	
	/**
	* CDataModel::GetInstallationInformation - returns unique identifiers for the current installation.
	* @param[out] sInstallationUUID - Installation UUID. Public value to document which installation was used for something.
	* @param[out] sInstallationSecret - Secret SHA256 key for seeding external-facing pseudo-randomness. MUST NOT be given outside of the application.
	*/
	void CDataModel::GetInstallationInformation(std::string & sInstallationUUID, std::string & sInstallationSecret)
	{
		LibMCData_uint32 bytesNeededInstallationUUID = 0;
		LibMCData_uint32 bytesWrittenInstallationUUID = 0;
		LibMCData_uint32 bytesNeededInstallationSecret = 0;
		LibMCData_uint32 bytesWrittenInstallationSecret = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetInstallationInformation(m_pHandle, 0, &bytesNeededInstallationUUID, nullptr, 0, &bytesNeededInstallationSecret, nullptr));
		std::vector<char> bufferInstallationUUID(bytesNeededInstallationUUID);
		std::vector<char> bufferInstallationSecret(bytesNeededInstallationSecret);
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetInstallationInformation(m_pHandle, bytesNeededInstallationUUID, &bytesWrittenInstallationUUID, &bufferInstallationUUID[0], bytesNeededInstallationSecret, &bytesWrittenInstallationSecret, &bufferInstallationSecret[0]));
		sInstallationUUID = std::string(&bufferInstallationUUID[0]);
		sInstallationSecret = std::string(&bufferInstallationSecret[0]);
	}
	
	/**
	* CDataModel::CreateStorage - creates a storage access class.
	* @return Storage class instance.
	*/
	PStorage CDataModel::CreateStorage()
	{
		LibMCDataHandle hStorage = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateStorage(m_pHandle, &hStorage));
		
		if (!hStorage) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorage>(m_pWrapper, hStorage);
	}
	
	/**
	* CDataModel::CreateBuildJobHandler - creates a build job access class.
	* @return BuildJobHandler class instance.
	*/
	PBuildJobHandler CDataModel::CreateBuildJobHandler()
	{
		LibMCDataHandle hBuildJobHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateBuildJobHandler(m_pHandle, &hBuildJobHandler));
		
		if (!hBuildJobHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobHandler>(m_pWrapper, hBuildJobHandler);
	}
	
	/**
	* CDataModel::CreateNewLogSession - creates a global log session access class.
	* @return LogSession class instance.
	*/
	PLogSession CDataModel::CreateNewLogSession()
	{
		LibMCDataHandle hLogSession = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateNewLogSession(m_pHandle, &hLogSession));
		
		if (!hLogSession) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogSession>(m_pWrapper, hLogSession);
	}
	
	/**
	* CDataModel::CreateLoginHandler - creates a login handler instance.
	* @return LoginHandler instance.
	*/
	PLoginHandler CDataModel::CreateLoginHandler()
	{
		LibMCDataHandle hLoginHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateLoginHandler(m_pHandle, &hLoginHandler));
		
		if (!hLoginHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLoginHandler>(m_pWrapper, hLoginHandler);
	}

} // namespace LibMCData

#endif // __LIBMCDATA_CPPHEADER_DYNAMIC_CPP

