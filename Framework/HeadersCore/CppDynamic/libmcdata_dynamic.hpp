/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Machine Control data model library

Interface version: 1.0.0

*/

#ifndef __LIBMCDATA_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDATA_CPPHEADER_DYNAMIC_CPP

#include "libmcdata_types.hpp"
#include "libmcdata_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCData {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CIterator;
class CLogEntryList;
class CLogSession;
class CStorageStream;
class CStorage;
class CBuildJobData;
class CBuildJobDataIterator;
class CBuildJob;
class CBuildJobIterator;
class CBuildJobHandler;
class CUserList;
class CLoginHandler;
class CPersistencyHandler;
class CDataModel;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDataWrapper;
typedef CBase CLibMCDataBase;
typedef CIterator CLibMCDataIterator;
typedef CLogEntryList CLibMCDataLogEntryList;
typedef CLogSession CLibMCDataLogSession;
typedef CStorageStream CLibMCDataStorageStream;
typedef CStorage CLibMCDataStorage;
typedef CBuildJobData CLibMCDataBuildJobData;
typedef CBuildJobDataIterator CLibMCDataBuildJobDataIterator;
typedef CBuildJob CLibMCDataBuildJob;
typedef CBuildJobIterator CLibMCDataBuildJobIterator;
typedef CBuildJobHandler CLibMCDataBuildJobHandler;
typedef CUserList CLibMCDataUserList;
typedef CLoginHandler CLibMCDataLoginHandler;
typedef CPersistencyHandler CLibMCDataPersistencyHandler;
typedef CDataModel CLibMCDataDataModel;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CIterator> PIterator;
typedef std::shared_ptr<CLogEntryList> PLogEntryList;
typedef std::shared_ptr<CLogSession> PLogSession;
typedef std::shared_ptr<CStorageStream> PStorageStream;
typedef std::shared_ptr<CStorage> PStorage;
typedef std::shared_ptr<CBuildJobData> PBuildJobData;
typedef std::shared_ptr<CBuildJobDataIterator> PBuildJobDataIterator;
typedef std::shared_ptr<CBuildJob> PBuildJob;
typedef std::shared_ptr<CBuildJobIterator> PBuildJobIterator;
typedef std::shared_ptr<CBuildJobHandler> PBuildJobHandler;
typedef std::shared_ptr<CUserList> PUserList;
typedef std::shared_ptr<CLoginHandler> PLoginHandler;
typedef std::shared_ptr<CPersistencyHandler> PPersistencyHandler;
typedef std::shared_ptr<CDataModel> PDataModel;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDataWrapper;
typedef PBase PLibMCDataBase;
typedef PIterator PLibMCDataIterator;
typedef PLogEntryList PLibMCDataLogEntryList;
typedef PLogSession PLibMCDataLogSession;
typedef PStorageStream PLibMCDataStorageStream;
typedef PStorage PLibMCDataStorage;
typedef PBuildJobData PLibMCDataBuildJobData;
typedef PBuildJobDataIterator PLibMCDataBuildJobDataIterator;
typedef PBuildJob PLibMCDataBuildJob;
typedef PBuildJobIterator PLibMCDataBuildJobIterator;
typedef PBuildJobHandler PLibMCDataBuildJobHandler;
typedef PUserList PLibMCDataUserList;
typedef PLoginHandler PLibMCDataLoginHandler;
typedef PPersistencyHandler PLibMCDataPersistencyHandler;
typedef PDataModel PLibMCDataDataModel;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDataHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDataException 
**************************************************************************************************************************/
class ELibMCDataException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDataResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDataException(LibMCDataResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDataResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDATA_SUCCESS: return "SUCCESS";
			case LIBMCDATA_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDATA_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDATA_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDATA_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDATA_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDATA_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDATA_ERROR_COULDNOTPARSECONFIGURATION: return "COULDNOTPARSECONFIGURATION";
			case LIBMCDATA_ERROR_DUPLICATESTATENAME: return "DUPLICATESTATENAME";
			case LIBMCDATA_ERROR_STATENOTFOUND: return "STATENOTFOUND";
			case LIBMCDATA_ERROR_DUPLICATEOUTSTATE: return "DUPLICATEOUTSTATE";
			case LIBMCDATA_ERROR_MISSINGMACHINEDEFINITION: return "MISSINGMACHINEDEFINITION";
			case LIBMCDATA_ERROR_MISSINGINSTANCENAME: return "MISSINGINSTANCENAME";
			case LIBMCDATA_ERROR_DUPLICATEMACHINEINSTANCE: return "DUPLICATEMACHINEINSTANCE";
			case LIBMCDATA_ERROR_MISSINGXMLSCHEMA: return "MISSINGXMLSCHEMA";
			case LIBMCDATA_ERROR_INVALIDXMLSCHEMA: return "INVALIDXMLSCHEMA";
			case LIBMCDATA_ERROR_MISSINGSTATENAME: return "MISSINGSTATENAME";
			case LIBMCDATA_ERROR_MISSINGOUTSTATETARGET: return "MISSINGOUTSTATETARGET";
			case LIBMCDATA_ERROR_INVALIDOUTSTATETARGET: return "INVALIDOUTSTATETARGET";
			case LIBMCDATA_ERROR_NOINITSTATE: return "NOINITSTATE";
			case LIBMCDATA_ERROR_NOFAILEDSTATE: return "NOFAILEDSTATE";
			case LIBMCDATA_ERROR_INITSTATENOTFOUND: return "INITSTATENOTFOUND";
			case LIBMCDATA_ERROR_FAILEDSTATENOTFOUND: return "FAILEDSTATENOTFOUND";
			case LIBMCDATA_ERROR_MISSINGINITSTATE: return "MISSINGINITSTATE";
			case LIBMCDATA_ERROR_MISSINGFAILEDSTATE: return "MISSINGFAILEDSTATE";
			case LIBMCDATA_ERROR_MISSINGPLUGINNAME: return "MISSINGPLUGINNAME";
			case LIBMCDATA_ERROR_EMPTYINITSTATE: return "EMPTYINITSTATE";
			case LIBMCDATA_ERROR_EMPTYFAILEDSTATE: return "EMPTYFAILEDSTATE";
			case LIBMCDATA_ERROR_EMPTYPLUGINNAME: return "EMPTYPLUGINNAME";
			case LIBMCDATA_ERROR_COULDNOTCREATESTATEFACTORY: return "COULDNOTCREATESTATEFACTORY";
			case LIBMCDATA_ERROR_INVALIDSTATENAME: return "INVALIDSTATENAME";
			case LIBMCDATA_ERROR_COULDNOTCREATESTATE: return "COULDNOTCREATESTATE";
			case LIBMCDATA_ERROR_COULDNOTINITIALIZEFACTORY: return "COULDNOTINITIALIZEFACTORY";
			case LIBMCDATA_ERROR_COULDNOTFINALIZEFACTORY: return "COULDNOTFINALIZEFACTORY";
			case LIBMCDATA_ERROR_COULDNOTLOADPLUGIN: return "COULDNOTLOADPLUGIN";
			case LIBMCDATA_ERROR_NOCURRENTSTATE: return "NOCURRENTSTATE";
			case LIBMCDATA_ERROR_NOPLUGINSTATE: return "NOPLUGINSTATE";
			case LIBMCDATA_ERROR_COULDNOTEXECUTEPLUGIN: return "COULDNOTEXECUTEPLUGIN";
			case LIBMCDATA_ERROR_TOOMANYMACHINEINSTANCES: return "TOOMANYMACHINEINSTANCES";
			case LIBMCDATA_ERROR_INVALIDINDEX: return "INVALIDINDEX";
			case LIBMCDATA_ERROR_NOOUTSTATEGIVEN: return "NOOUTSTATEGIVEN";
			case LIBMCDATA_ERROR_INVALIDOUTSTATEGIVEN: return "INVALIDOUTSTATEGIVEN";
			case LIBMCDATA_ERROR_INVALIDREPEATDELAY: return "INVALIDREPEATDELAY";
			case LIBMCDATA_ERROR_INVALIDEXECUTIONDELAY: return "INVALIDEXECUTIONDELAY";
			case LIBMCDATA_ERROR_MISSINGREPEATDELAY: return "MISSINGREPEATDELAY";
			case LIBMCDATA_ERROR_THREADISRUNNING: return "THREADISRUNNING";
			case LIBMCDATA_ERROR_THREADISNOTRUNNING: return "THREADISNOTRUNNING";
			case LIBMCDATA_ERROR_DUPLICATESIGNAL: return "DUPLICATESIGNAL";
			case LIBMCDATA_ERROR_INVALIDSIGNALNAME: return "INVALIDSIGNALNAME";
			case LIBMCDATA_ERROR_MISSINGSIGNALNAME: return "MISSINGSIGNALNAME";
			case LIBMCDATA_ERROR_MISSINGSERVERNODE: return "MISSINGSERVERNODE";
			case LIBMCDATA_ERROR_MISSINGHOSTNAME: return "MISSINGHOSTNAME";
			case LIBMCDATA_ERROR_MISSINGPORT: return "MISSINGPORT";
			case LIBMCDATA_ERROR_UUIDGENERATIONFAILED: return "UUIDGENERATIONFAILED";
			case LIBMCDATA_ERROR_INVALIDBUFFERSIZE: return "INVALIDBUFFERSIZE";
			case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF8: return "COULDNOTCONVERTTOUTF8";
			case LIBMCDATA_ERROR_NOCOLUMNAVAILABLE: return "NOCOLUMNAVAILABLE";
			case LIBMCDATA_ERROR_INVALIDTEXTCOLUMN: return "INVALIDTEXTCOLUMN";
			case LIBMCDATA_ERROR_INVALIDCOLUMNTYPE: return "INVALIDCOLUMNTYPE";
			case LIBMCDATA_ERROR_TOOMANYREQUESTEDLOGS: return "TOOMANYREQUESTEDLOGS";
			case LIBMCDATA_ERROR_MISSINGINSTANCEDESCRIPTION: return "MISSINGINSTANCEDESCRIPTION";
			case LIBMCDATA_ERROR_DUPLICATEPARAMETERGROUPNAME: return "DUPLICATEPARAMETERGROUPNAME";
			case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPNAME: return "MISSINGPARAMETERGROUPNAME";
			case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPNAME: return "EMPTYPARAMETERGROUPNAME";
			case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPDESCRIPTION: return "MISSINGPARAMETERGROUPDESCRIPTION";
			case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPDESCRIPTION: return "EMPTYPARAMETERGROUPDESCRIPTION";
			case LIBMCDATA_ERROR_TOOMANYPARAMETERS: return "TOOMANYPARAMETERS";
			case LIBMCDATA_ERROR_TOOMANYPARAMETERGROUPS: return "TOOMANYPARAMETERGROUPS";
			case LIBMCDATA_ERROR_DUPLICATEPARAMETERNAME: return "DUPLICATEPARAMETERNAME";
			case LIBMCDATA_ERROR_MISSINGPARAMETERNAME: return "MISSINGPARAMETERNAME";
			case LIBMCDATA_ERROR_EMPTYPARAMETERNAME: return "EMPTYPARAMETERNAME";
			case LIBMCDATA_ERROR_MISSINGPARAMETERDESCRIPTION: return "MISSINGPARAMETERDESCRIPTION";
			case LIBMCDATA_ERROR_EMPTYPARAMETERDESCRIPTION: return "EMPTYPARAMETERDESCRIPTION";
			case LIBMCDATA_ERROR_PARAMETERNOTFOUND: return "PARAMETERNOTFOUND";
			case LIBMCDATA_ERROR_MISSINGPARAMETERDEFAULTVALUE: return "MISSINGPARAMETERDEFAULTVALUE";
			case LIBMCDATA_ERROR_MISSINGDATACONFIGNODE: return "MISSINGDATACONFIGNODE";
			case LIBMCDATA_ERROR_MISSINGDIRECTORY: return "MISSINGDIRECTORY";
			case LIBMCDATA_ERROR_MISSINGDATABASETYPE: return "MISSINGDATABASETYPE";
			case LIBMCDATA_ERROR_MISSINGSQLITEINFO: return "MISSINGSQLITEINFO";
			case LIBMCDATA_ERROR_UNKNOWNDATABASETYPE: return "UNKNOWNDATABASETYPE";
			case LIBMCDATA_ERROR_STORAGENOTINITIALISED: return "STORAGENOTINITIALISED";
			case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF16: return "COULDNOTCONVERTTOUTF16";
			case LIBMCDATA_ERROR_COULDNOTCREATEFILE: return "COULDNOTCREATEFILE";
			case LIBMCDATA_ERROR_COULDNOTSEEKSTREAM: return "COULDNOTSEEKSTREAM";
			case LIBMCDATA_ERROR_COULDNOTGETSTREAMPOSITION: return "COULDNOTGETSTREAMPOSITION";
			case LIBMCDATA_ERROR_COULDNOTWRITESTREAM: return "COULDNOTWRITESTREAM";
			case LIBMCDATA_ERROR_INVALIDDATABASEMIGRATION: return "INVALIDDATABASEMIGRATION";
			case LIBMCDATA_ERROR_INTERNALERROR: return "INTERNALERROR";
			case LIBMCDATA_ERROR_COULDNOTSTORECONTENTSTREAM: return "COULDNOTSTORECONTENTSTREAM";
			case LIBMCDATA_ERROR_DATABASENOTINITIALISED: return "DATABASENOTINITIALISED";
			case LIBMCDATA_ERROR_PARAMETERGROUPNOTFOUND: return "PARAMETERGROUPNOTFOUND";
			case LIBMCDATA_ERROR_SIGNALNOTFOUND: return "SIGNALNOTFOUND";
			case LIBMCDATA_ERROR_STATEMACHINENOTFOUND: return "STATEMACHINENOTFOUND";
			case LIBMCDATA_ERROR_MISSINGPARAMETERTYPE: return "MISSINGPARAMETERTYPE";
			case LIBMCDATA_ERROR_INVALIDPARAMETERTYPE: return "INVALIDPARAMETERTYPE";
			case LIBMCDATA_ERROR_COULDNOTPARSEJSON: return "COULDNOTPARSEJSON";
			case LIBMCDATA_ERROR_INVALIDJSONFORMAT: return "INVALIDJSONFORMAT";
			case LIBMCDATA_ERROR_URLNOTFOUND: return "URLNOTFOUND";
			case LIBMCDATA_ERROR_GENERICBADREQUEST: return "GENERICBADREQUEST";
			case LIBMCDATA_ERROR_SQLITE_ERROR: return "SQLITE_ERROR";
			case LIBMCDATA_ERROR_SQLITE_INTERNAL: return "SQLITE_INTERNAL";
			case LIBMCDATA_ERROR_SQLITE_PERM: return "SQLITE_PERM";
			case LIBMCDATA_ERROR_SQLITE_ABORT: return "SQLITE_ABORT";
			case LIBMCDATA_ERROR_SQLITE_BUSY: return "SQLITE_BUSY";
			case LIBMCDATA_ERROR_SQLITE_LOCKED: return "SQLITE_LOCKED";
			case LIBMCDATA_ERROR_SQLITE_NOMEM: return "SQLITE_NOMEM";
			case LIBMCDATA_ERROR_SQLITE_READONLY: return "SQLITE_READONLY";
			case LIBMCDATA_ERROR_SQLITE_INTERRUPT: return "SQLITE_INTERRUPT";
			case LIBMCDATA_ERROR_SQLITE_IOERR: return "SQLITE_IOERR";
			case LIBMCDATA_ERROR_SQLITE_CORRUPT: return "SQLITE_CORRUPT";
			case LIBMCDATA_ERROR_SQLITE_NOTFOUND: return "SQLITE_NOTFOUND";
			case LIBMCDATA_ERROR_SQLITE_FULL: return "SQLITE_FULL";
			case LIBMCDATA_ERROR_SQLITE_CANTOPEN: return "SQLITE_CANTOPEN";
			case LIBMCDATA_ERROR_SQLITE_PROTOCOL: return "SQLITE_PROTOCOL";
			case LIBMCDATA_ERROR_SQLITE_SCHEMA: return "SQLITE_SCHEMA";
			case LIBMCDATA_ERROR_SQLITE_TOOBIG: return "SQLITE_TOOBIG";
			case LIBMCDATA_ERROR_SQLITE_CONSTRAINT: return "SQLITE_CONSTRAINT";
			case LIBMCDATA_ERROR_SQLITE_MISMATCH: return "SQLITE_MISMATCH";
			case LIBMCDATA_ERROR_SQLITE_MISUSE: return "SQLITE_MISUSE";
			case LIBMCDATA_ERROR_SQLITE_NOLFS: return "SQLITE_NOLFS";
			case LIBMCDATA_ERROR_SQLITE_AUTH: return "SQLITE_AUTH";
			case LIBMCDATA_ERROR_SQLITE_RANGE: return "SQLITE_RANGE";
			case LIBMCDATA_ERROR_SQLITE_NOTADB: return "SQLITE_NOTADB";
			case LIBMCDATA_ERROR_SQLITE_NOTICE: return "SQLITE_NOTICE";
			case LIBMCDATA_ERROR_SQLITE_WARNING: return "SQLITE_WARNING";
			case LIBMCDATA_ERROR_SQLITE_OTHER: return "SQLITE_OTHER";
			case LIBMCDATA_ERROR_SQLITE_TOOMANYRESULTROWS: return "SQLITE_TOOMANYRESULTROWS";
			case LIBMCDATA_ERROR_COULDNOTREADZIPFILE: return "COULDNOTREADZIPFILE";
			case LIBMCDATA_ERROR_COULDNOTOPENZIPFILE: return "COULDNOTOPENZIPFILE";
			case LIBMCDATA_ERROR_COULDNOTGETZIPENTRIES: return "COULDNOTGETZIPENTRIES";
			case LIBMCDATA_ERROR_ZIPENTRYNOTFOUND: return "ZIPENTRYNOTFOUND";
			case LIBMCDATA_ERROR_COULDNOTSTATZIPENTRY: return "COULDNOTSTATZIPENTRY";
			case LIBMCDATA_ERROR_COULDNOTOPENZIPENTRY: return "COULDNOTOPENZIPENTRY";
			case LIBMCDATA_ERROR_COULDNOTREADZIPSTREAM: return "COULDNOTREADZIPSTREAM";
			case LIBMCDATA_ERROR_COULDNOTREADFULLZIPDATA: return "COULDNOTREADFULLZIPDATA";
			case LIBMCDATA_ERROR_COULDNOTFINDRESOURCEINDEX: return "COULDNOTFINDRESOURCEINDEX";
			case LIBMCDATA_ERROR_COULDNOTPARSERESOURCEINDEX: return "COULDNOTPARSERESOURCEINDEX";
			case LIBMCDATA_ERROR_EMPTYRESOURCEINDEX: return "EMPTYRESOURCEINDEX";
			case LIBMCDATA_ERROR_MISSINGRESOURCEINDEX: return "MISSINGRESOURCEINDEX";
			case LIBMCDATA_ERROR_MISSINGRESOURCENAME: return "MISSINGRESOURCENAME";
			case LIBMCDATA_ERROR_MISSINGRESOURCEFILENAME: return "MISSINGRESOURCEFILENAME";
			case LIBMCDATA_ERROR_MISSINGRESOURCESIZE: return "MISSINGRESOURCESIZE";
			case LIBMCDATA_ERROR_MISSINGRESOURCECONTENTTYPE: return "MISSINGRESOURCECONTENTTYPE";
			case LIBMCDATA_ERROR_DRIVERALREADYREGISTERED: return "DRIVERALREADYREGISTERED";
			case LIBMCDATA_ERROR_DRIVERNOTFOUND: return "DRIVERNOTFOUND";
			case LIBMCDATA_ERROR_MISSINGDRIVERNAME: return "MISSINGDRIVERNAME";
			case LIBMCDATA_ERROR_MISSINGDRIVERTYPE: return "MISSINGDRIVERTYPE";
			case LIBMCDATA_ERROR_MISSINGDRIVERLIBRARY: return "MISSINGDRIVERLIBRARY";
			case LIBMCDATA_ERROR_DRIVERALREADYRESERVED: return "DRIVERALREADYRESERVED";
			case LIBMCDATA_ERROR_LIBRARYPATHNOTFOUND: return "LIBRARYPATHNOTFOUND";
			case LIBMCDATA_ERROR_TOOLPATHENTITYNOTLOADED: return "TOOLPATHENTITYNOTLOADED";
			case LIBMCDATA_ERROR_TOOLPATHENTITYREFERENCEERROR: return "TOOLPATHENTITYREFERENCEERROR";
			case LIBMCDATA_ERROR_TOOLPATHENTITYINVALIDFILE: return "TOOLPATHENTITYINVALIDFILE";
			case LIBMCDATA_ERROR_NO3MFLIBRARY: return "NO3MFLIBRARY";
			case LIBMCDATA_ERROR_INVALIDPOINTCOUNT: return "INVALIDPOINTCOUNT";
			case LIBMCDATA_ERROR_DUPLICATEJOBUUID: return "DUPLICATEJOBUUID";
			case LIBMCDATA_ERROR_INVALIDJOBSTATUS: return "INVALIDJOBSTATUS";
			case LIBMCDATA_ERROR_INVALIDSTREAMCONTEXT: return "INVALIDSTREAMCONTEXT";
			case LIBMCDATA_ERROR_JOBUUIDNOTFOUND: return "JOBUUIDNOTFOUND";
			case LIBMCDATA_ERROR_INVALIDJOBNAME: return "INVALIDJOBNAME";
			case LIBMCDATA_ERROR_INVALIDJOBTIMESTAMP: return "INVALIDJOBTIMESTAMP";
			case LIBMCDATA_ERROR_INVALIDUSERID: return "INVALIDUSERID";
			case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSIGNATURE: return "INVALIDSTORAGECALLBACKSIGNATURE";
			case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSTREAM: return "INVALIDSTORAGECALLBACKSTREAM";
			case LIBMCDATA_ERROR_INVALIDSTORAGEPATH: return "INVALIDSTORAGEPATH";
			case LIBMCDATA_ERROR_STORAGESTREAMNOTFOUND: return "STORAGESTREAMNOTFOUND";
			case LIBMCDATA_ERROR_DUPLICATESTORAGESTREAM: return "DUPLICATESTORAGESTREAM";
			case LIBMCDATA_ERROR_INVALIDPARTIALUPLOAD: return "INVALIDPARTIALUPLOAD";
			case LIBMCDATA_ERROR_PARTIALUPLOADNOTFINISHED: return "PARTIALUPLOADNOTFINISHED";
			case LIBMCDATA_ERROR_APIREQUESTNOTHANDLED: return "APIREQUESTNOTHANDLED";
			case LIBMCDATA_ERROR_APIREQUESTALREADYHANDLED: return "APIREQUESTALREADYHANDLED";
			case LIBMCDATA_ERROR_INVALIDAPIREQUESTTYPE: return "INVALIDAPIREQUESTTYPE";
			case LIBMCDATA_ERROR_INVALIDUPLOADSTREAM: return "INVALIDUPLOADSTREAM";
			case LIBMCDATA_ERROR_COULDNOTPARSEJSONREQUEST: return "COULDNOTPARSEJSONREQUEST";
			case LIBMCDATA_ERROR_INVALIDCONTEXTUUID: return "INVALIDCONTEXTUUID";
			case LIBMCDATA_ERROR_INVALIDUPLOADNAME: return "INVALIDUPLOADNAME";
			case LIBMCDATA_ERROR_INVALIDMIMETYPE: return "INVALIDMIMETYPE";
			case LIBMCDATA_ERROR_INVALIDSTREAMSIZE: return "INVALIDSTREAMSIZE";
			case LIBMCDATA_ERROR_INVALIDSHA256SUM: return "INVALIDSHA256SUM";
			case LIBMCDATA_ERROR_INVALIDSTREAMUUID: return "INVALIDSTREAMUUID";
			case LIBMCDATA_ERROR_INVALIDFIELDNAME: return "INVALIDFIELDNAME";
			case LIBMCDATA_ERROR_UPLOADSIZEMISMATCH: return "UPLOADSIZEMISMATCH";
			case LIBMCDATA_ERROR_CONTENTTYPENOTACCEPTED: return "CONTENTTYPENOTACCEPTED";
			case LIBMCDATA_ERROR_NOCURRENTUPLOAD: return "NOCURRENTUPLOAD";
			case LIBMCDATA_ERROR_UPLOADCHECKSUMMISMATCH: return "UPLOADCHECKSUMMISMATCH";
			case LIBMCDATA_ERROR_INVALIDSTORAGESTREAMSTATUS: return "INVALIDSTORAGESTREAMSTATUS";
			case LIBMCDATA_ERROR_CONTEXTUUIDNOTACCEPTED: return "CONTEXTUUIDNOTACCEPTED";
			case LIBMCDATA_ERROR_INVALIDBUILDUUID: return "INVALIDBUILDUUID";
			case LIBMCDATA_ERROR_MISSINGTHREADCOUNT: return "MISSINGTHREADCOUNT";
			case LIBMCDATA_ERROR_INVALIDTHREADCOUNT: return "INVALIDTHREADCOUNT";
			case LIBMCDATA_ERROR_COULDNOTUPDATEBUILDSTATUS: return "COULDNOTUPDATEBUILDSTATUS";
			case LIBMCDATA_ERROR_INVALIDITERATOR: return "INVALIDITERATOR";
			case LIBMCDATA_ERROR_INVALIDDATATYPE: return "INVALIDDATATYPE";
			case LIBMCDATA_ERROR_COULDNOTSENDSIGNAL: return "COULDNOTSENDSIGNAL";
			case LIBMCDATA_ERROR_MISSINGSIGNALPARAMETER: return "MISSINGSIGNALPARAMETER";
			case LIBMCDATA_ERROR_NOUSERINTERFACEDEFINITION: return "NOUSERINTERFACEDEFINITION";
			case LIBMCDATA_ERROR_MISSINGAPPNAME: return "MISSINGAPPNAME";
			case LIBMCDATA_ERROR_MISSINGCOPYRIGHT: return "MISSINGCOPYRIGHT";
			case LIBMCDATA_ERROR_MISSINGMAINPAGE: return "MISSINGMAINPAGE";
			case LIBMCDATA_ERROR_MISSINGMENUITEMID: return "MISSINGMENUITEMID";
			case LIBMCDATA_ERROR_MISSINGMENUITEMICON: return "MISSINGMENUITEMICON";
			case LIBMCDATA_ERROR_MISSINGMENUITEMCAPTION: return "MISSINGMENUITEMCAPTION";
			case LIBMCDATA_ERROR_MISSINGTARGETPAGE: return "MISSINGTARGETPAGE";
			case LIBMCDATA_ERROR_MISSINGMENUNODE: return "MISSINGMENUNODE";
			case LIBMCDATA_ERROR_MISSINGTOOLBARNODE: return "MISSINGTOOLBARNODE";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMID: return "MISSINGTOOLBARITEMID";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMICON: return "MISSINGTOOLBARITEMICON";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMCAPTION: return "MISSINGTOOLBARITEMCAPTION";
			case LIBMCDATA_ERROR_MISSINGSERVICESNODE: return "MISSINGSERVICESNODE";
			case LIBMCDATA_ERROR_INVALIDSESSIONUUID: return "INVALIDSESSIONUUID";
			case LIBMCDATA_ERROR_INVALIDSESSIONKEY: return "INVALIDSESSIONKEY";
			case LIBMCDATA_ERROR_SESSIONNOTAUTHORIZED: return "SESSIONNOTAUTHORIZED";
			case LIBMCDATA_ERROR_INVALIDUSERNAME: return "INVALIDUSERNAME";
			case LIBMCDATA_ERROR_INVALIDPASSWORD: return "INVALIDPASSWORD";
			case LIBMCDATA_ERROR_INVALIDAUTHORIZATION: return "INVALIDAUTHORIZATION";
			case LIBMCDATA_ERROR_USERALREADYAUTHORIZED: return "USERALREADYAUTHORIZED";
			case LIBMCDATA_ERROR_INVALIDSESSIONTOKEN: return "INVALIDSESSIONTOKEN";
			case LIBMCDATA_ERROR_INVALIDCLIENTKEY: return "INVALIDCLIENTKEY";
			case LIBMCDATA_ERROR_INVALIDLOGIN: return "INVALIDLOGIN";
			case LIBMCDATA_ERROR_DUPLICATEPAGE: return "DUPLICATEPAGE";
			case LIBMCDATA_ERROR_PAGENOTFOUND: return "PAGENOTFOUND";
			case LIBMCDATA_ERROR_MISSINGPAGENAME: return "MISSINGPAGENAME";
			case LIBMCDATA_ERROR_INVALIDPAGENAME: return "INVALIDPAGENAME";
			case LIBMCDATA_ERROR_MODULENOTFOUND: return "MODULENOTFOUND";
			case LIBMCDATA_ERROR_DUPLICATEMODULE: return "DUPLICATEMODULE";
			case LIBMCDATA_ERROR_INVALIDMODULENAME: return "INVALIDMODULENAME";
			case LIBMCDATA_ERROR_INVALIDMODULETYPE: return "INVALIDMODULETYPE";
			case LIBMCDATA_ERROR_INVALIDHEADLINE: return "INVALIDHEADLINE";
			case LIBMCDATA_ERROR_USERNOTFOUND: return "USERNOTFOUND";
			case LIBMCDATA_ERROR_STREAMISNOTIMAGE: return "STREAMISNOTIMAGE";
			case LIBMCDATA_ERROR_TOOMANYCONTENTPARAMETERS: return "TOOMANYCONTENTPARAMETERS";
			case LIBMCDATA_ERROR_MISSINGCONTENTSTATEMACHINENAME: return "MISSINGCONTENTSTATEMACHINENAME";
			case LIBMCDATA_ERROR_MISSINGCONTENTGROUPNAME: return "MISSINGCONTENTGROUPNAME";
			case LIBMCDATA_ERROR_INVALIDENTRIESPERPAGE: return "INVALIDENTRIESPERPAGE";
			case LIBMCDATA_ERROR_MODULEITEMNOTFOUND: return "MODULEITEMNOTFOUND";
			case LIBMCDATA_ERROR_DERIVEDPARAMETERSREADONLY: return "DERIVEDPARAMETERSREADONLY";
			case LIBMCDATA_ERROR_TOOMANYJOURNALVARIABLES: return "TOOMANYJOURNALVARIABLES";
			case LIBMCDATA_ERROR_JOURNALISNOTINITIALISING: return "JOURNALISNOTINITIALISING";
			case LIBMCDATA_ERROR_JOURNALISNOTRECORDING: return "JOURNALISNOTRECORDING";
			case LIBMCDATA_ERROR_INVALIDVARIABLETYPE: return "INVALIDVARIABLETYPE";
			case LIBMCDATA_ERROR_INVALIDVARIABLEUNITS: return "INVALIDVARIABLEUNITS";
			case LIBMCDATA_ERROR_UNITSHAVEALREADYBEENSET: return "UNITSHAVEALREADYBEENSET";
			case LIBMCDATA_ERROR_UNITSHAVENOTBEENSET: return "UNITSHAVENOTBEENSET";
			case LIBMCDATA_ERROR_INVALIDTIMESTAMP: return "INVALIDTIMESTAMP";
			case LIBMCDATA_ERROR_NOCURRENTJOURNALCHUNK: return "NOCURRENTJOURNALCHUNK";
			case LIBMCDATA_ERROR_DUPLICATEJOURNALID: return "DUPLICATEJOURNALID";
			case LIBMCDATA_ERROR_RESOURCEENTRYNOTFOUND: return "RESOURCEENTRYNOTFOUND";
			case LIBMCDATA_ERROR_NOCORERESOURCEPACKAGE: return "NOCORERESOURCEPACKAGE";
			case LIBMCDATA_ERROR_INVALIDASPECTRATIO: return "INVALIDASPECTRATIO";
			case LIBMCDATA_ERROR_MISSINGLOGORESOURCE: return "MISSINGLOGORESOURCE";
			case LIBMCDATA_ERROR_NOUSERINTERFACEPLUGIN: return "NOUSERINTERFACEPLUGIN";
			case LIBMCDATA_ERROR_COULDNOTLOADUILIBRARY: return "COULDNOTLOADUILIBRARY";
			case LIBMCDATA_ERROR_EVENTNAMENOTFOUND: return "EVENTNAMENOTFOUND";
			case LIBMCDATA_ERROR_INVALIDEVENTSENDER: return "INVALIDEVENTSENDER";
			case LIBMCDATA_ERROR_INVALIDEVENTCONTEXT: return "INVALIDEVENTCONTEXT";
			case LIBMCDATA_ERROR_INVALIDLAYERINDEX: return "INVALIDLAYERINDEX";
			case LIBMCDATA_ERROR_TEMPBASEPATHEMPTY: return "TEMPBASEPATHEMPTY";
			case LIBMCDATA_ERROR_BUILDJOBDATANOTFOUND: return "BUILDJOBDATANOTFOUND";
			case LIBMCDATA_ERROR_INVALIDNAMESTRING: return "INVALIDNAMESTRING";
			case LIBMCDATA_ERROR_NAMESTRINGMISMATCH: return "NAMESTRINGMISMATCH";
			case LIBMCDATA_ERROR_DATATYPEMISMATCH: return "DATATYPEMISMATCH";
			case LIBMCDATA_ERROR_COULDNOTFINDLOGENTRY: return "COULDNOTFINDLOGENTRY";
			case LIBMCDATA_ERROR_NOLOGCALLBACK: return "NOLOGCALLBACK";
			case LIBMCDATA_ERROR_EMPTYUSERNAME: return "EMPTYUSERNAME";
			case LIBMCDATA_ERROR_EMPTYUSERUUID: return "EMPTYUSERUUID";
			case LIBMCDATA_ERROR_USERNOTUNIQUE: return "USERNOTUNIQUE";
			case LIBMCDATA_ERROR_EMPTYUSERROLE: return "EMPTYUSERROLE";
			case LIBMCDATA_ERROR_EMPTYUSERSALT: return "EMPTYUSERSALT";
			case LIBMCDATA_ERROR_EMPTYUSERPASSWORD: return "EMPTYUSERPASSWORD";
			case LIBMCDATA_ERROR_INVALIDUSERROLE: return "INVALIDUSERROLE";
			case LIBMCDATA_ERROR_USERALREADYEXISTS: return "USERALREADYEXISTS";
			case LIBMCDATA_ERROR_INVALIDUSERLANGUAGE: return "INVALIDUSERLANGUAGE";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERLANGUAGE: return "COULDNOTUPDATEUSERLANGUAGE";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERROLE: return "COULDNOTUPDATEUSERROLE";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERDESCRIPTION: return "COULDNOTUPDATEUSERDESCRIPTION";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERPASSWORD: return "COULDNOTUPDATEUSERPASSWORD";
			case LIBMCDATA_ERROR_INVALIDUSERINDEX: return "INVALIDUSERINDEX";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDATA_SUCCESS: return "success";
			case LIBMCDATA_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDATA_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDATA_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDATA_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDATA_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDATA_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDATA_ERROR_COULDNOTPARSECONFIGURATION: return "could not parse configuration";
			case LIBMCDATA_ERROR_DUPLICATESTATENAME: return "duplicate state name";
			case LIBMCDATA_ERROR_STATENOTFOUND: return "state not found";
			case LIBMCDATA_ERROR_DUPLICATEOUTSTATE: return "duplicate out state";
			case LIBMCDATA_ERROR_MISSINGMACHINEDEFINITION: return "missing machine definition";
			case LIBMCDATA_ERROR_MISSINGINSTANCENAME: return "missing instance name";
			case LIBMCDATA_ERROR_DUPLICATEMACHINEINSTANCE: return "duplicate machine instance";
			case LIBMCDATA_ERROR_MISSINGXMLSCHEMA: return "missing XML schema";
			case LIBMCDATA_ERROR_INVALIDXMLSCHEMA: return "invalid XML schema";
			case LIBMCDATA_ERROR_MISSINGSTATENAME: return "missing state name";
			case LIBMCDATA_ERROR_MISSINGOUTSTATETARGET: return "missing outstate target";
			case LIBMCDATA_ERROR_INVALIDOUTSTATETARGET: return "invalid outstate target";
			case LIBMCDATA_ERROR_NOINITSTATE: return "no init state";
			case LIBMCDATA_ERROR_NOFAILEDSTATE: return "no failed state";
			case LIBMCDATA_ERROR_INITSTATENOTFOUND: return "init state not found";
			case LIBMCDATA_ERROR_FAILEDSTATENOTFOUND: return "failed state not found";
			case LIBMCDATA_ERROR_MISSINGINITSTATE: return "missing init state";
			case LIBMCDATA_ERROR_MISSINGFAILEDSTATE: return "missing failed state";
			case LIBMCDATA_ERROR_MISSINGPLUGINNAME: return "missing plugin name";
			case LIBMCDATA_ERROR_EMPTYINITSTATE: return "empty init state";
			case LIBMCDATA_ERROR_EMPTYFAILEDSTATE: return "empty failed state";
			case LIBMCDATA_ERROR_EMPTYPLUGINNAME: return "empty plugin name";
			case LIBMCDATA_ERROR_COULDNOTCREATESTATEFACTORY: return "could not create state factory";
			case LIBMCDATA_ERROR_INVALIDSTATENAME: return "invalid state name";
			case LIBMCDATA_ERROR_COULDNOTCREATESTATE: return "could not create state";
			case LIBMCDATA_ERROR_COULDNOTINITIALIZEFACTORY: return "could not initialize factory";
			case LIBMCDATA_ERROR_COULDNOTFINALIZEFACTORY: return "could not finalize factory";
			case LIBMCDATA_ERROR_COULDNOTLOADPLUGIN: return "could not load plugin";
			case LIBMCDATA_ERROR_NOCURRENTSTATE: return "no current state";
			case LIBMCDATA_ERROR_NOPLUGINSTATE: return "no plugin state";
			case LIBMCDATA_ERROR_COULDNOTEXECUTEPLUGIN: return "could not execute plugin";
			case LIBMCDATA_ERROR_TOOMANYMACHINEINSTANCES: return "too many machine instances";
			case LIBMCDATA_ERROR_INVALIDINDEX: return "invalid index";
			case LIBMCDATA_ERROR_NOOUTSTATEGIVEN: return "no new outstate has been given";
			case LIBMCDATA_ERROR_INVALIDOUTSTATEGIVEN: return "invalid outstate has been given";
			case LIBMCDATA_ERROR_INVALIDREPEATDELAY: return "invalid repeat delay";
			case LIBMCDATA_ERROR_INVALIDEXECUTIONDELAY: return "invalid execution delay";
			case LIBMCDATA_ERROR_MISSINGREPEATDELAY: return "missing repeat delay";
			case LIBMCDATA_ERROR_THREADISRUNNING: return "thread is running";
			case LIBMCDATA_ERROR_THREADISNOTRUNNING: return "thread is not running";
			case LIBMCDATA_ERROR_DUPLICATESIGNAL: return "duplicate signal";
			case LIBMCDATA_ERROR_INVALIDSIGNALNAME: return "invalid signal name";
			case LIBMCDATA_ERROR_MISSINGSIGNALNAME: return "missing signal name";
			case LIBMCDATA_ERROR_MISSINGSERVERNODE: return "missing server node";
			case LIBMCDATA_ERROR_MISSINGHOSTNAME: return "missing host name";
			case LIBMCDATA_ERROR_MISSINGPORT: return "missing port";
			case LIBMCDATA_ERROR_UUIDGENERATIONFAILED: return "uuid generation failed";
			case LIBMCDATA_ERROR_INVALIDBUFFERSIZE: return "invalid buffer size";
			case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF8: return "could not convert to utf8";
			case LIBMCDATA_ERROR_NOCOLUMNAVAILABLE: return "no column available";
			case LIBMCDATA_ERROR_INVALIDTEXTCOLUMN: return "invalid text column";
			case LIBMCDATA_ERROR_INVALIDCOLUMNTYPE: return "invalid column type";
			case LIBMCDATA_ERROR_TOOMANYREQUESTEDLOGS: return "too many requested logs";
			case LIBMCDATA_ERROR_MISSINGINSTANCEDESCRIPTION: return "missing instance description";
			case LIBMCDATA_ERROR_DUPLICATEPARAMETERGROUPNAME: return "duplicate parameter group name";
			case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPNAME: return "missing parameter group name";
			case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPNAME: return "empty parameter group name";
			case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPDESCRIPTION: return "missing parameter group description";
			case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPDESCRIPTION: return "empty parameter group description";
			case LIBMCDATA_ERROR_TOOMANYPARAMETERS: return "too many parameters";
			case LIBMCDATA_ERROR_TOOMANYPARAMETERGROUPS: return "too many parameter groups";
			case LIBMCDATA_ERROR_DUPLICATEPARAMETERNAME: return "duplicate parameter name";
			case LIBMCDATA_ERROR_MISSINGPARAMETERNAME: return "missing parameter name";
			case LIBMCDATA_ERROR_EMPTYPARAMETERNAME: return "empty parameter name";
			case LIBMCDATA_ERROR_MISSINGPARAMETERDESCRIPTION: return "missing parameter description";
			case LIBMCDATA_ERROR_EMPTYPARAMETERDESCRIPTION: return "empty parameter description";
			case LIBMCDATA_ERROR_PARAMETERNOTFOUND: return "parameter not found";
			case LIBMCDATA_ERROR_MISSINGPARAMETERDEFAULTVALUE: return "missing parameter default value";
			case LIBMCDATA_ERROR_MISSINGDATACONFIGNODE: return "missing data config node";
			case LIBMCDATA_ERROR_MISSINGDIRECTORY: return "missing directory";
			case LIBMCDATA_ERROR_MISSINGDATABASETYPE: return "missing database type";
			case LIBMCDATA_ERROR_MISSINGSQLITEINFO: return "missing sqlite info";
			case LIBMCDATA_ERROR_UNKNOWNDATABASETYPE: return "unknown database type";
			case LIBMCDATA_ERROR_STORAGENOTINITIALISED: return "storage not initialised";
			case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF16: return "could not convert to utf 16";
			case LIBMCDATA_ERROR_COULDNOTCREATEFILE: return "could not create file";
			case LIBMCDATA_ERROR_COULDNOTSEEKSTREAM: return "could not seek stream";
			case LIBMCDATA_ERROR_COULDNOTGETSTREAMPOSITION: return "could not get stream position";
			case LIBMCDATA_ERROR_COULDNOTWRITESTREAM: return "could not write stream";
			case LIBMCDATA_ERROR_INVALIDDATABASEMIGRATION: return "invalid database migration";
			case LIBMCDATA_ERROR_INTERNALERROR: return "internal error";
			case LIBMCDATA_ERROR_COULDNOTSTORECONTENTSTREAM: return "could not store content stream";
			case LIBMCDATA_ERROR_DATABASENOTINITIALISED: return "database not initialised";
			case LIBMCDATA_ERROR_PARAMETERGROUPNOTFOUND: return "parameter group not found";
			case LIBMCDATA_ERROR_SIGNALNOTFOUND: return "signal not found";
			case LIBMCDATA_ERROR_STATEMACHINENOTFOUND: return "state machine not found.";
			case LIBMCDATA_ERROR_MISSINGPARAMETERTYPE: return "missing parameter type.";
			case LIBMCDATA_ERROR_INVALIDPARAMETERTYPE: return "invalid parameter type.";
			case LIBMCDATA_ERROR_COULDNOTPARSEJSON: return "could not parse json.";
			case LIBMCDATA_ERROR_INVALIDJSONFORMAT: return "invalid json format.";
			case LIBMCDATA_ERROR_URLNOTFOUND: return "url not found.";
			case LIBMCDATA_ERROR_GENERICBADREQUEST: return "generic bad request.";
			case LIBMCDATA_ERROR_SQLITE_ERROR: return "SQLite: Generic Error";
			case LIBMCDATA_ERROR_SQLITE_INTERNAL: return "SQLite: Internal logic error in SQLite";
			case LIBMCDATA_ERROR_SQLITE_PERM: return "SQLite: Access permission denied";
			case LIBMCDATA_ERROR_SQLITE_ABORT: return "SQLite: Callback routine requested an abort";
			case LIBMCDATA_ERROR_SQLITE_BUSY: return "SQLite: The database file is locked";
			case LIBMCDATA_ERROR_SQLITE_LOCKED: return "SQLite: A table in the database is locked";
			case LIBMCDATA_ERROR_SQLITE_NOMEM: return "SQLite: A malloc failed";
			case LIBMCDATA_ERROR_SQLITE_READONLY: return "SQLite: Attempt to write a readonly database";
			case LIBMCDATA_ERROR_SQLITE_INTERRUPT: return "SQLite: Operation terminated by sqlite3_interrupt";
			case LIBMCDATA_ERROR_SQLITE_IOERR: return "SQLite: Some kind of disk I/O error occurred";
			case LIBMCDATA_ERROR_SQLITE_CORRUPT: return "SQLite: The database disk image is malformed";
			case LIBMCDATA_ERROR_SQLITE_NOTFOUND: return "SQLite: Unknown opcode in sqlite3_file_control";
			case LIBMCDATA_ERROR_SQLITE_FULL: return "SQLite: Insertion failed because database is full";
			case LIBMCDATA_ERROR_SQLITE_CANTOPEN: return "SQLite: Unable to open the database file";
			case LIBMCDATA_ERROR_SQLITE_PROTOCOL: return "SQLite: Database lock protocol error";
			case LIBMCDATA_ERROR_SQLITE_SCHEMA: return "SQLite: The database schema changed";
			case LIBMCDATA_ERROR_SQLITE_TOOBIG: return "SQLite: String or BLOB exceeds size limit";
			case LIBMCDATA_ERROR_SQLITE_CONSTRAINT: return "SQLite: Abort due to constraint violation";
			case LIBMCDATA_ERROR_SQLITE_MISMATCH: return "SQLite: Data type mismatch";
			case LIBMCDATA_ERROR_SQLITE_MISUSE: return "SQLite: Library used incorrectly";
			case LIBMCDATA_ERROR_SQLITE_NOLFS: return "SQLite: Uses OS features not supported on host";
			case LIBMCDATA_ERROR_SQLITE_AUTH: return "SQLite: Authorization denied";
			case LIBMCDATA_ERROR_SQLITE_RANGE: return "SQLite: 2nd parameter to sqlite3_bind out of range";
			case LIBMCDATA_ERROR_SQLITE_NOTADB: return "SQLite: File opened that is not a database file";
			case LIBMCDATA_ERROR_SQLITE_NOTICE: return "SQLite: Notifications from sqlite3_log";
			case LIBMCDATA_ERROR_SQLITE_WARNING: return "SQLite: Warnings from sqlite3_log";
			case LIBMCDATA_ERROR_SQLITE_OTHER: return "SQLite: Other Error";
			case LIBMCDATA_ERROR_SQLITE_TOOMANYRESULTROWS: return "too many result rows";
			case LIBMCDATA_ERROR_COULDNOTREADZIPFILE: return "Could not read ZIP file";
			case LIBMCDATA_ERROR_COULDNOTOPENZIPFILE: return "Could not open ZIP file";
			case LIBMCDATA_ERROR_COULDNOTGETZIPENTRIES: return "Could not get ZIP file entries";
			case LIBMCDATA_ERROR_ZIPENTRYNOTFOUND: return "ZIP Entry not found";
			case LIBMCDATA_ERROR_COULDNOTSTATZIPENTRY: return "Could not stat ZIP entry";
			case LIBMCDATA_ERROR_COULDNOTOPENZIPENTRY: return "Could not open ZIP entry";
			case LIBMCDATA_ERROR_COULDNOTREADZIPSTREAM: return "Could not read ZIP stream";
			case LIBMCDATA_ERROR_COULDNOTREADFULLZIPDATA: return "Could not read full zip data";
			case LIBMCDATA_ERROR_COULDNOTFINDRESOURCEINDEX: return "Could not find resource index.";
			case LIBMCDATA_ERROR_COULDNOTPARSERESOURCEINDEX: return "Could not parse resource index.";
			case LIBMCDATA_ERROR_EMPTYRESOURCEINDEX: return "Empty resource index.";
			case LIBMCDATA_ERROR_MISSINGRESOURCEINDEX: return "Missing resource index.";
			case LIBMCDATA_ERROR_MISSINGRESOURCENAME: return "Missing resource name.";
			case LIBMCDATA_ERROR_MISSINGRESOURCEFILENAME: return "Missing resource filename.";
			case LIBMCDATA_ERROR_MISSINGRESOURCESIZE: return "Missing resource size.";
			case LIBMCDATA_ERROR_MISSINGRESOURCECONTENTTYPE: return "Missing resource content type.";
			case LIBMCDATA_ERROR_DRIVERALREADYREGISTERED: return "Driver already registered.";
			case LIBMCDATA_ERROR_DRIVERNOTFOUND: return "Driver not found.";
			case LIBMCDATA_ERROR_MISSINGDRIVERNAME: return "Missing driver name.";
			case LIBMCDATA_ERROR_MISSINGDRIVERTYPE: return "Missing driver type.";
			case LIBMCDATA_ERROR_MISSINGDRIVERLIBRARY: return "Missing driver library.";
			case LIBMCDATA_ERROR_DRIVERALREADYRESERVED: return "Driver has already been reserved by an instance.";
			case LIBMCDATA_ERROR_LIBRARYPATHNOTFOUND: return "Library path not found.";
			case LIBMCDATA_ERROR_TOOLPATHENTITYNOTLOADED: return "Toolpath entity not loaded";
			case LIBMCDATA_ERROR_TOOLPATHENTITYREFERENCEERROR: return "Toolpath entity reference error";
			case LIBMCDATA_ERROR_TOOLPATHENTITYINVALIDFILE: return "Toolpath entity is invalid";
			case LIBMCDATA_ERROR_NO3MFLIBRARY: return "No 3MF Library specified";
			case LIBMCDATA_ERROR_INVALIDPOINTCOUNT: return "Invalid point count";
			case LIBMCDATA_ERROR_DUPLICATEJOBUUID: return "Duplicate job uuid";
			case LIBMCDATA_ERROR_INVALIDJOBSTATUS: return "Invalid job status";
			case LIBMCDATA_ERROR_INVALIDSTREAMCONTEXT: return "Invalid stream context";
			case LIBMCDATA_ERROR_JOBUUIDNOTFOUND: return "Job uuid not found";
			case LIBMCDATA_ERROR_INVALIDJOBNAME: return "Invalid job name";
			case LIBMCDATA_ERROR_INVALIDJOBTIMESTAMP: return "Invalid job timestamp";
			case LIBMCDATA_ERROR_INVALIDUSERID: return "Invalid job name";
			case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSIGNATURE: return "Invalid storage callback signature";
			case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSTREAM: return "Invalid storage callback stream";
			case LIBMCDATA_ERROR_INVALIDSTORAGEPATH: return "Invalid storage path";
			case LIBMCDATA_ERROR_STORAGESTREAMNOTFOUND: return "Storage Stream not found";
			case LIBMCDATA_ERROR_DUPLICATESTORAGESTREAM: return "Duplicate Storage Stream";
			case LIBMCDATA_ERROR_INVALIDPARTIALUPLOAD: return "Invalid Partial Upload";
			case LIBMCDATA_ERROR_PARTIALUPLOADNOTFINISHED: return "Partial Upload not finished";
			case LIBMCDATA_ERROR_APIREQUESTNOTHANDLED: return "API Request not handled";
			case LIBMCDATA_ERROR_APIREQUESTALREADYHANDLED: return "API Request already handled";
			case LIBMCDATA_ERROR_INVALIDAPIREQUESTTYPE: return "Invalid API Request type";
			case LIBMCDATA_ERROR_INVALIDUPLOADSTREAM: return "Invalid Upload Stream";
			case LIBMCDATA_ERROR_COULDNOTPARSEJSONREQUEST: return "Could not parse JSON request";
			case LIBMCDATA_ERROR_INVALIDCONTEXTUUID: return "Invalid Context UUID";
			case LIBMCDATA_ERROR_INVALIDUPLOADNAME: return "Invalid Upload Name";
			case LIBMCDATA_ERROR_INVALIDMIMETYPE: return "Invalid Mime Type";
			case LIBMCDATA_ERROR_INVALIDSTREAMSIZE: return "Invalid Stream Size";
			case LIBMCDATA_ERROR_INVALIDSHA256SUM: return "Invalid SHA256 Sum";
			case LIBMCDATA_ERROR_INVALIDSTREAMUUID: return "Invalid Stream UUID";
			case LIBMCDATA_ERROR_INVALIDFIELDNAME: return "Invalid field name";
			case LIBMCDATA_ERROR_UPLOADSIZEMISMATCH: return "Upload size mismatch";
			case LIBMCDATA_ERROR_CONTENTTYPENOTACCEPTED: return "Content type not accepted";
			case LIBMCDATA_ERROR_NOCURRENTUPLOAD: return "No current upload";
			case LIBMCDATA_ERROR_UPLOADCHECKSUMMISMATCH: return "Upload checksum mismatch";
			case LIBMCDATA_ERROR_INVALIDSTORAGESTREAMSTATUS: return "Invalid storage stream status";
			case LIBMCDATA_ERROR_CONTEXTUUIDNOTACCEPTED: return "Context uuid not accepted";
			case LIBMCDATA_ERROR_INVALIDBUILDUUID: return "Invalid build uuid";
			case LIBMCDATA_ERROR_MISSINGTHREADCOUNT: return "Missing thread count";
			case LIBMCDATA_ERROR_INVALIDTHREADCOUNT: return "Invalid thread count";
			case LIBMCDATA_ERROR_COULDNOTUPDATEBUILDSTATUS: return "Could not update build status";
			case LIBMCDATA_ERROR_INVALIDITERATOR: return "Invalid iterator";
			case LIBMCDATA_ERROR_INVALIDDATATYPE: return "Invalid data type";
			case LIBMCDATA_ERROR_COULDNOTSENDSIGNAL: return "Could not send signal";
			case LIBMCDATA_ERROR_MISSINGSIGNALPARAMETER: return "Missing signal parameter";
			case LIBMCDATA_ERROR_NOUSERINTERFACEDEFINITION: return "No user interface definition";
			case LIBMCDATA_ERROR_MISSINGAPPNAME: return "Missing app name";
			case LIBMCDATA_ERROR_MISSINGCOPYRIGHT: return "Missing copyright";
			case LIBMCDATA_ERROR_MISSINGMAINPAGE: return "Missing main page";
			case LIBMCDATA_ERROR_MISSINGMENUITEMID: return "Missing menu item id";
			case LIBMCDATA_ERROR_MISSINGMENUITEMICON: return "Missing menu item icon";
			case LIBMCDATA_ERROR_MISSINGMENUITEMCAPTION: return "Missing menu item caption";
			case LIBMCDATA_ERROR_MISSINGTARGETPAGE: return "Missing menu item target page";
			case LIBMCDATA_ERROR_MISSINGMENUNODE: return "Missing menu node";
			case LIBMCDATA_ERROR_MISSINGTOOLBARNODE: return "Missing toolbar node";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMID: return "Missing toolbar item id";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMICON: return "Missing toolbar item icon";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMCAPTION: return "Missing toolbar item caption";
			case LIBMCDATA_ERROR_MISSINGSERVICESNODE: return "Missing services node";
			case LIBMCDATA_ERROR_INVALIDSESSIONUUID: return "Invalid session UUID";
			case LIBMCDATA_ERROR_INVALIDSESSIONKEY: return "Invalid session Key";
			case LIBMCDATA_ERROR_SESSIONNOTAUTHORIZED: return "Session not authorized";
			case LIBMCDATA_ERROR_INVALIDUSERNAME: return "Invalid user name";
			case LIBMCDATA_ERROR_INVALIDPASSWORD: return "Invalid password";
			case LIBMCDATA_ERROR_INVALIDAUTHORIZATION: return "Invalid Authorization";
			case LIBMCDATA_ERROR_USERALREADYAUTHORIZED: return "User already authorized";
			case LIBMCDATA_ERROR_INVALIDSESSIONTOKEN: return "Invalid session token";
			case LIBMCDATA_ERROR_INVALIDCLIENTKEY: return "Invalid client key";
			case LIBMCDATA_ERROR_INVALIDLOGIN: return "Invalid login credentials";
			case LIBMCDATA_ERROR_DUPLICATEPAGE: return "Duplicate page";
			case LIBMCDATA_ERROR_PAGENOTFOUND: return "Page not found";
			case LIBMCDATA_ERROR_MISSINGPAGENAME: return "Missing page name";
			case LIBMCDATA_ERROR_INVALIDPAGENAME: return "Invalid page name";
			case LIBMCDATA_ERROR_MODULENOTFOUND: return "Module not found";
			case LIBMCDATA_ERROR_DUPLICATEMODULE: return "Duplicate module";
			case LIBMCDATA_ERROR_INVALIDMODULENAME: return "Invalid module name";
			case LIBMCDATA_ERROR_INVALIDMODULETYPE: return "Invalid module type";
			case LIBMCDATA_ERROR_INVALIDHEADLINE: return "Invalid headline";
			case LIBMCDATA_ERROR_USERNOTFOUND: return "User not found";
			case LIBMCDATA_ERROR_STREAMISNOTIMAGE: return "Stream is not image";
			case LIBMCDATA_ERROR_TOOMANYCONTENTPARAMETERS: return "Too many content parameters";
			case LIBMCDATA_ERROR_MISSINGCONTENTSTATEMACHINENAME: return "Missing content state machine name";
			case LIBMCDATA_ERROR_MISSINGCONTENTGROUPNAME: return "Missing content group name";
			case LIBMCDATA_ERROR_INVALIDENTRIESPERPAGE: return "Invalid entries per page";
			case LIBMCDATA_ERROR_MODULEITEMNOTFOUND: return "Module item not found";
			case LIBMCDATA_ERROR_DERIVEDPARAMETERSREADONLY: return "Derived parameters are read only.";
			case LIBMCDATA_ERROR_TOOMANYJOURNALVARIABLES: return "Too many journal variables";
			case LIBMCDATA_ERROR_JOURNALISNOTINITIALISING: return "Too many journal variables";
			case LIBMCDATA_ERROR_JOURNALISNOTRECORDING: return "Too many journal variables";
			case LIBMCDATA_ERROR_INVALIDVARIABLETYPE: return "Invalid variable type";
			case LIBMCDATA_ERROR_INVALIDVARIABLEUNITS: return "Invalid variable units";
			case LIBMCDATA_ERROR_UNITSHAVEALREADYBEENSET: return "Units have already been set";
			case LIBMCDATA_ERROR_UNITSHAVENOTBEENSET: return "Units have not been set";
			case LIBMCDATA_ERROR_INVALIDTIMESTAMP: return "Invalid time stamp";
			case LIBMCDATA_ERROR_NOCURRENTJOURNALCHUNK: return "No current journal chunk";
			case LIBMCDATA_ERROR_DUPLICATEJOURNALID: return "Duplicate journal id";
			case LIBMCDATA_ERROR_RESOURCEENTRYNOTFOUND: return "Resource entry not found";
			case LIBMCDATA_ERROR_NOCORERESOURCEPACKAGE: return "No core resource package";
			case LIBMCDATA_ERROR_INVALIDASPECTRATIO: return "Invalid aspect ratio";
			case LIBMCDATA_ERROR_MISSINGLOGORESOURCE: return "Missing logo resource";
			case LIBMCDATA_ERROR_NOUSERINTERFACEPLUGIN: return "No user interface plugin";
			case LIBMCDATA_ERROR_COULDNOTLOADUILIBRARY: return "Could not load UI library";
			case LIBMCDATA_ERROR_EVENTNAMENOTFOUND: return "Event name not found";
			case LIBMCDATA_ERROR_INVALIDEVENTSENDER: return "Invalid event context";
			case LIBMCDATA_ERROR_INVALIDEVENTCONTEXT: return "Invalid event sender";
			case LIBMCDATA_ERROR_INVALIDLAYERINDEX: return "Invalid layer index";
			case LIBMCDATA_ERROR_TEMPBASEPATHEMPTY: return "Empty base path for temporary files";
			case LIBMCDATA_ERROR_BUILDJOBDATANOTFOUND: return "Build job data not found";
			case LIBMCDATA_ERROR_INVALIDNAMESTRING: return "Invalid name string";
			case LIBMCDATA_ERROR_NAMESTRINGMISMATCH: return "Name string mismatch";
			case LIBMCDATA_ERROR_DATATYPEMISMATCH: return "Datatype mismatch";
			case LIBMCDATA_ERROR_COULDNOTFINDLOGENTRY: return "Could not find log entry";
			case LIBMCDATA_ERROR_NOLOGCALLBACK: return "No log callback";
			case LIBMCDATA_ERROR_EMPTYUSERNAME: return "Empty user name";
			case LIBMCDATA_ERROR_EMPTYUSERUUID: return "Empty user UUID";
			case LIBMCDATA_ERROR_USERNOTUNIQUE: return "User not unique";
			case LIBMCDATA_ERROR_EMPTYUSERROLE: return "Empty user role";
			case LIBMCDATA_ERROR_EMPTYUSERSALT: return "Empty user salt";
			case LIBMCDATA_ERROR_EMPTYUSERPASSWORD: return "Empty user password";
			case LIBMCDATA_ERROR_INVALIDUSERROLE: return "Invalid user role";
			case LIBMCDATA_ERROR_USERALREADYEXISTS: return "User already exists";
			case LIBMCDATA_ERROR_INVALIDUSERLANGUAGE: return "Invalid user language";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERLANGUAGE: return "Could not update user language";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERROLE: return "Could not update user role";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERDESCRIPTION: return "Could not update user description";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERPASSWORD: return "Could not update user password";
			case LIBMCDATA_ERROR_INVALIDUSERINDEX: return "Invalid user index";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDataInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDataResult nResult);

	inline void GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline LibMCData_pvoid GetSymbolLookupMethod();
	inline PDataModel CreateDataModelInstance();

private:
	sLibMCDataDynamicWrapperTable m_WrapperTable;
	
	LibMCDataResult checkBinaryVersion()
	{
		LibMCData_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDATA_VERSION_MAJOR) {
			return LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDATA_SUCCESS;
	}
	LibMCDataResult initWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable);
	LibMCDataResult releaseWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable);
	LibMCDataResult loadWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDataResult loadWrapperTableFromSymbolLookupMethod(sLibMCDataDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CIterator;
	friend class CLogEntryList;
	friend class CLogSession;
	friend class CStorageStream;
	friend class CStorage;
	friend class CBuildJobData;
	friend class CBuildJobDataIterator;
	friend class CBuildJob;
	friend class CBuildJobIterator;
	friend class CBuildJobHandler;
	friend class CUserList;
	friend class CLoginHandler;
	friend class CPersistencyHandler;
	friend class CDataModel;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDataHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDataResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDataHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDataHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CIterator 
**************************************************************************************************************************/
class CIterator : public CBase {
public:
	
	/**
	* CIterator::CIterator - Constructor for Iterator class.
	*/
	CIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MoveNext();
	inline bool MovePrevious();
	inline PBase GetCurrent();
	inline PIterator Clone();
	inline LibMCData_uint64 Count();
};
	
/*************************************************************************************************************************
 Class CLogEntryList 
**************************************************************************************************************************/
class CLogEntryList : public CBase {
public:
	
	/**
	* CLogEntryList::CLogEntryList - Constructor for LogEntryList class.
	*/
	CLogEntryList(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCData_uint32 Count();
	inline void GetEntryByIndex(const LibMCData_uint32 nIndex, LibMCData_uint32 & nID, std::string & sMessage, std::string & sSubSystem, eLogLevel & eLogLevel, std::string & sTimestamp);
	inline void GetEntryByID(const LibMCData_uint32 nID, std::string & sMessage, std::string & sSubSystem, eLogLevel & eLogLevel, std::string & sTimestamp);
	inline bool HasEntry(const LibMCData_uint32 nID);
};
	
/*************************************************************************************************************************
 Class CLogSession 
**************************************************************************************************************************/
class CLogSession : public CBase {
public:
	
	/**
	* CLogSession::CLogSession - Constructor for LogSession class.
	*/
	CLogSession(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void AddEntry(const std::string & sMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp);
	inline LibMCData_uint32 GetMaxLogEntryID();
	inline PLogEntryList RetrieveLogEntriesByID(const LibMCData_uint32 nMinLogID, const LibMCData_uint32 nMaxLogID, const eLogLevel eMinLogLevel);
};
	
/*************************************************************************************************************************
 Class CStorageStream 
**************************************************************************************************************************/
class CStorageStream : public CBase {
public:
	
	/**
	* CStorageStream::CStorageStream - Constructor for StorageStream class.
	*/
	CStorageStream(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetTimeStamp();
	inline std::string GetContextIdentifier();
	inline std::string GetName();
	inline std::string GetMIMEType();
	inline std::string GetSHA2();
	inline LibMCData_uint64 GetSize();
	inline void GetContent(std::vector<LibMCData_uint8> & ContentBuffer);
	inline void GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle);
};
	
/*************************************************************************************************************************
 Class CStorage 
**************************************************************************************************************************/
class CStorage : public CBase {
public:
	
	/**
	* CStorage::CStorage - Constructor for Storage class.
	*/
	CStorage(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool StreamIsReady(const std::string & sUUID);
	inline PStorageStream RetrieveStream(const std::string & sUUID);
	inline void StoreNewStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sContextIdentifier, const std::string & sName, const std::string & sMimeType, const CInputVector<LibMCData_uint8> & ContentBuffer, const std::string & sUserID);
	inline void BeginPartialStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sContextIdentifier, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID);
	inline void StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer);
	inline void FinishPartialStream(const std::string & sUUID, const std::string & sSHA2);
	inline void FinishPartialStreamBlockwiseSHA256(const std::string & sUUID, const std::string & sBlockwiseSHA2);
	inline LibMCData_uint64 GetMaxStreamSize();
	inline bool ContentTypeIsAccepted(const std::string & sContentType);
	inline bool StreamIsImage(const std::string & sUUID);
};
	
/*************************************************************************************************************************
 Class CBuildJobData 
**************************************************************************************************************************/
class CBuildJobData : public CBase {
public:
	
	/**
	* CBuildJobData::CBuildJobData - Constructor for BuildJobData class.
	*/
	CBuildJobData(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetDataUUID();
	inline std::string GetJobUUID();
	inline std::string GetName();
	inline std::string GetContextIdentifier();
	inline std::string GetTimeStamp();
	inline PStorageStream GetStorageStream();
	inline std::string GetStorageStreamSHA2();
	inline LibMCData_uint64 GetStorageStreamSize();
	inline eBuildJobDataType GetDataType();
	inline std::string GetDataTypeAsString();
	inline std::string GetMIMEType();
};
	
/*************************************************************************************************************************
 Class CBuildJobDataIterator 
**************************************************************************************************************************/
class CBuildJobDataIterator : public CIterator {
public:
	
	/**
	* CBuildJobDataIterator::CBuildJobDataIterator - Constructor for BuildJobDataIterator class.
	*/
	CBuildJobDataIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJobData GetCurrentJobData();
};
	
/*************************************************************************************************************************
 Class CBuildJob 
**************************************************************************************************************************/
class CBuildJob : public CBase {
public:
	
	/**
	* CBuildJob::CBuildJob - Constructor for BuildJob class.
	*/
	CBuildJob(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetName();
	inline eBuildJobStatus GetStatus();
	inline LibMCData_uint32 GetLayerCount();
	inline std::string GetTimeStamp();
	inline PStorageStream GetStorageStream();
	inline std::string GetStorageStreamUUID();
	inline PLogSession GetBuildJobLogger();
	inline void StartValidating();
	inline void FinishValidating(const LibMCData_uint32 nLayerCount);
	inline void ArchiveJob();
	inline void UnArchiveJob();
	inline void DeleteJob();
	inline bool JobCanBeArchived();
	inline void AddJobData(const std::string & sIdentifier, const std::string & sName, classParam<CStorageStream> pStream, const eBuildJobDataType eDataType, const std::string & sUserID);
	inline PBuildJobDataIterator ListJobDataByType(const eBuildJobDataType eDataType);
	inline PBuildJobDataIterator ListJobData();
	inline PBuildJobData RetrieveJobData(const std::string & sDataUUID);
};
	
/*************************************************************************************************************************
 Class CBuildJobIterator 
**************************************************************************************************************************/
class CBuildJobIterator : public CIterator {
public:
	
	/**
	* CBuildJobIterator::CBuildJobIterator - Constructor for BuildJobIterator class.
	*/
	CBuildJobIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJob GetCurrentJob();
};
	
/*************************************************************************************************************************
 Class CBuildJobHandler 
**************************************************************************************************************************/
class CBuildJobHandler : public CBase {
public:
	
	/**
	* CBuildJobHandler::CBuildJobHandler - Constructor for BuildJobHandler class.
	*/
	CBuildJobHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PBuildJob CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID);
	inline PBuildJob RetrieveJob(const std::string & sJobUUID);
	inline PBuildJob FindJobOfData(const std::string & sDataUUID);
	inline PBuildJobIterator ListJobsByStatus(const eBuildJobStatus eStatus);
	inline std::string ConvertBuildStatusToString(const eBuildJobStatus eStatus);
	inline eBuildJobStatus ConvertStringToBuildStatus(const std::string & sString);
};
	
/*************************************************************************************************************************
 Class CUserList 
**************************************************************************************************************************/
class CUserList : public CBase {
public:
	
	/**
	* CUserList::CUserList - Constructor for UserList class.
	*/
	CUserList(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCData_uint32 Count();
	inline void GetUserProperties(const LibMCData_uint32 nUserIndex, std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier);
};
	
/*************************************************************************************************************************
 Class CLoginHandler 
**************************************************************************************************************************/
class CLoginHandler : public CBase {
public:
	
	/**
	* CLoginHandler::CLoginHandler - Constructor for LoginHandler class.
	*/
	CLoginHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool UserExists(const std::string & sUsername);
	inline void GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword);
	inline void GetUserProperties(const std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier);
	inline void GetUserPropertiesByUUID(const std::string & sUUID, std::string & sUsername, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier);
	inline std::string GetUsernameByUUID(const std::string & sUUID);
	inline std::string GetUserUUID(const std::string & sUsername);
	inline std::string GetUserDescription(const std::string & sUsername);
	inline std::string GetUserDescriptionByUUID(const std::string & sUUID);
	inline std::string GetUserRole(const std::string & sUsername);
	inline std::string GetUserRoleByUUID(const std::string & sUUID);
	inline std::string GetUserLanguage(const std::string & sUsername);
	inline std::string GetUserLanguageByUUID(const std::string & sUUID);
	inline std::string CreateUser(const std::string & sUsername, const std::string & sRole, const std::string & sSalt, const std::string & sHashedPassword, const std::string & sDescription);
	inline void SetUserLanguage(const std::string & sUsername, const std::string & sLanguageIdentifier);
	inline void SetUserRole(const std::string & sUsername, const std::string & sRole);
	inline void SetUserDescription(const std::string & sUsername, const std::string & sDescription);
	inline void SetUserPassword(const std::string & sUsername, const std::string & sSalt, const std::string & sHashedPassword);
	inline void SetUserLanguageByUUID(const std::string & sUUID, const std::string & sLanguageIdentifier);
	inline void SetUserRoleByUUID(const std::string & sUUID, const std::string & sRole);
	inline void SetUserDescriptionByUUID(const std::string & sUUID, const std::string & sDescription);
	inline void SetUserPasswordByUUID(const std::string & sUUID, const std::string & sSalt, const std::string & sHashedPassword);
	inline PUserList GetActiveUsers();
};
	
/*************************************************************************************************************************
 Class CPersistencyHandler 
**************************************************************************************************************************/
class CPersistencyHandler : public CBase {
public:
	
	/**
	* CPersistencyHandler::CPersistencyHandler - Constructor for PersistencyHandler class.
	*/
	CPersistencyHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool HasPersistentParameter(const std::string & sUUID);
	inline void GetPersistentParameterDetails(const std::string & sUUID, std::string & sName, eParameterDataType & eDataType);
	inline bool DeletePersistentParameter(const std::string & sUUID);
	inline void StorePersistentParameter(const std::string & sUUID, const std::string & sName, const eParameterDataType eDataType, const std::string & sValue);
	inline void StorePersistentStringParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue);
	inline void StorePersistentUUIDParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue);
	inline void StorePersistentDoubleParameter(const std::string & sUUID, const std::string & sName, const LibMCData_double dValue);
	inline void StorePersistentIntegerParameter(const std::string & sUUID, const std::string & sName, const LibMCData_int64 nValue);
	inline void StorePersistentBoolParameter(const std::string & sUUID, const std::string & sName, const bool bValue);
	inline std::string RetrievePersistentStringParameter(const std::string & sUUID);
	inline std::string RetrievePersistentUUIDParameter(const std::string & sUUID);
	inline LibMCData_double RetrievePersistentDoubleParameter(const std::string & sUUID);
	inline LibMCData_int64 RetrievePersistentIntegerParameter(const std::string & sUUID);
	inline bool RetrievePersistentBoolParameter(const std::string & sUUID);
};
	
/*************************************************************************************************************************
 Class CDataModel 
**************************************************************************************************************************/
class CDataModel : public CBase {
public:
	
	/**
	* CDataModel::CDataModel - Constructor for DataModel class.
	*/
	CDataModel(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void InitialiseDatabase(const std::string & sDataDirectory, const eDataBaseType eDataBaseType, const std::string & sConnectionString);
	inline LibMCData_uint32 GetDataModelVersion();
	inline void GetInstallationInformation(std::string & sInstallationUUID, std::string & sInstallationSecret);
	inline PStorage CreateStorage();
	inline PBuildJobHandler CreateBuildJobHandler();
	inline PLogSession CreateNewLogSession();
	inline PLoginHandler CreateLoginHandler();
	inline PPersistencyHandler CreatePersistencyHandler();
	inline void SetBaseTempDirectory(const std::string & sTempDirectory);
	inline std::string GetBaseTempDirectory();
	inline void SetLogCallback(const LogCallback pLogCallback, const LibMCData_pvoid pUserData);
	inline void ClearLogCallback();
	inline bool HasLogCallback();
	inline void TriggerLogCallback(const std::string & sLogMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		LibMCData_uint32 bytesNeededErrorMessage = 0;
		LibMCData_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCData_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCData_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDataModelInstance - Creates and initializes new MC DataModel Instance.
	* @return New DataModel instance
	*/
	inline PDataModel CWrapper::CreateDataModelInstance()
	{
		LibMCDataHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDataModelInstance(&hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataModel>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDataResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDataException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDataResult CWrapper::initWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Iterator_MoveNext = nullptr;
		pWrapperTable->m_Iterator_MovePrevious = nullptr;
		pWrapperTable->m_Iterator_GetCurrent = nullptr;
		pWrapperTable->m_Iterator_Clone = nullptr;
		pWrapperTable->m_Iterator_Count = nullptr;
		pWrapperTable->m_LogEntryList_Count = nullptr;
		pWrapperTable->m_LogEntryList_GetEntryByIndex = nullptr;
		pWrapperTable->m_LogEntryList_GetEntryByID = nullptr;
		pWrapperTable->m_LogEntryList_HasEntry = nullptr;
		pWrapperTable->m_LogSession_AddEntry = nullptr;
		pWrapperTable->m_LogSession_GetMaxLogEntryID = nullptr;
		pWrapperTable->m_LogSession_RetrieveLogEntriesByID = nullptr;
		pWrapperTable->m_StorageStream_GetUUID = nullptr;
		pWrapperTable->m_StorageStream_GetTimeStamp = nullptr;
		pWrapperTable->m_StorageStream_GetContextIdentifier = nullptr;
		pWrapperTable->m_StorageStream_GetName = nullptr;
		pWrapperTable->m_StorageStream_GetMIMEType = nullptr;
		pWrapperTable->m_StorageStream_GetSHA2 = nullptr;
		pWrapperTable->m_StorageStream_GetSize = nullptr;
		pWrapperTable->m_StorageStream_GetContent = nullptr;
		pWrapperTable->m_StorageStream_GetCallbacks = nullptr;
		pWrapperTable->m_Storage_StreamIsReady = nullptr;
		pWrapperTable->m_Storage_RetrieveStream = nullptr;
		pWrapperTable->m_Storage_StoreNewStream = nullptr;
		pWrapperTable->m_Storage_BeginPartialStream = nullptr;
		pWrapperTable->m_Storage_StorePartialStream = nullptr;
		pWrapperTable->m_Storage_FinishPartialStream = nullptr;
		pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 = nullptr;
		pWrapperTable->m_Storage_GetMaxStreamSize = nullptr;
		pWrapperTable->m_Storage_ContentTypeIsAccepted = nullptr;
		pWrapperTable->m_Storage_StreamIsImage = nullptr;
		pWrapperTable->m_BuildJobData_GetDataUUID = nullptr;
		pWrapperTable->m_BuildJobData_GetJobUUID = nullptr;
		pWrapperTable->m_BuildJobData_GetName = nullptr;
		pWrapperTable->m_BuildJobData_GetContextIdentifier = nullptr;
		pWrapperTable->m_BuildJobData_GetTimeStamp = nullptr;
		pWrapperTable->m_BuildJobData_GetStorageStream = nullptr;
		pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 = nullptr;
		pWrapperTable->m_BuildJobData_GetStorageStreamSize = nullptr;
		pWrapperTable->m_BuildJobData_GetDataType = nullptr;
		pWrapperTable->m_BuildJobData_GetDataTypeAsString = nullptr;
		pWrapperTable->m_BuildJobData_GetMIMEType = nullptr;
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = nullptr;
		pWrapperTable->m_BuildJob_GetUUID = nullptr;
		pWrapperTable->m_BuildJob_GetName = nullptr;
		pWrapperTable->m_BuildJob_GetStatus = nullptr;
		pWrapperTable->m_BuildJob_GetLayerCount = nullptr;
		pWrapperTable->m_BuildJob_GetTimeStamp = nullptr;
		pWrapperTable->m_BuildJob_GetStorageStream = nullptr;
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = nullptr;
		pWrapperTable->m_BuildJob_GetBuildJobLogger = nullptr;
		pWrapperTable->m_BuildJob_StartValidating = nullptr;
		pWrapperTable->m_BuildJob_FinishValidating = nullptr;
		pWrapperTable->m_BuildJob_ArchiveJob = nullptr;
		pWrapperTable->m_BuildJob_UnArchiveJob = nullptr;
		pWrapperTable->m_BuildJob_DeleteJob = nullptr;
		pWrapperTable->m_BuildJob_JobCanBeArchived = nullptr;
		pWrapperTable->m_BuildJob_AddJobData = nullptr;
		pWrapperTable->m_BuildJob_ListJobDataByType = nullptr;
		pWrapperTable->m_BuildJob_ListJobData = nullptr;
		pWrapperTable->m_BuildJob_RetrieveJobData = nullptr;
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = nullptr;
		pWrapperTable->m_BuildJobHandler_CreateJob = nullptr;
		pWrapperTable->m_BuildJobHandler_RetrieveJob = nullptr;
		pWrapperTable->m_BuildJobHandler_FindJobOfData = nullptr;
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = nullptr;
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = nullptr;
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = nullptr;
		pWrapperTable->m_UserList_Count = nullptr;
		pWrapperTable->m_UserList_GetUserProperties = nullptr;
		pWrapperTable->m_LoginHandler_UserExists = nullptr;
		pWrapperTable->m_LoginHandler_GetUserDetails = nullptr;
		pWrapperTable->m_LoginHandler_GetUserProperties = nullptr;
		pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUsernameByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUserUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUserDescription = nullptr;
		pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUserRole = nullptr;
		pWrapperTable->m_LoginHandler_GetUserRoleByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUserLanguage = nullptr;
		pWrapperTable->m_LoginHandler_GetUserLanguageByUUID = nullptr;
		pWrapperTable->m_LoginHandler_CreateUser = nullptr;
		pWrapperTable->m_LoginHandler_SetUserLanguage = nullptr;
		pWrapperTable->m_LoginHandler_SetUserRole = nullptr;
		pWrapperTable->m_LoginHandler_SetUserDescription = nullptr;
		pWrapperTable->m_LoginHandler_SetUserPassword = nullptr;
		pWrapperTable->m_LoginHandler_SetUserLanguageByUUID = nullptr;
		pWrapperTable->m_LoginHandler_SetUserRoleByUUID = nullptr;
		pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID = nullptr;
		pWrapperTable->m_LoginHandler_SetUserPasswordByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetActiveUsers = nullptr;
		pWrapperTable->m_PersistencyHandler_HasPersistentParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails = nullptr;
		pWrapperTable->m_PersistencyHandler_DeletePersistentParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter = nullptr;
		pWrapperTable->m_DataModel_InitialiseDatabase = nullptr;
		pWrapperTable->m_DataModel_GetDataModelVersion = nullptr;
		pWrapperTable->m_DataModel_GetInstallationInformation = nullptr;
		pWrapperTable->m_DataModel_CreateStorage = nullptr;
		pWrapperTable->m_DataModel_CreateBuildJobHandler = nullptr;
		pWrapperTable->m_DataModel_CreateNewLogSession = nullptr;
		pWrapperTable->m_DataModel_CreateLoginHandler = nullptr;
		pWrapperTable->m_DataModel_CreatePersistencyHandler = nullptr;
		pWrapperTable->m_DataModel_SetBaseTempDirectory = nullptr;
		pWrapperTable->m_DataModel_GetBaseTempDirectory = nullptr;
		pWrapperTable->m_DataModel_SetLogCallback = nullptr;
		pWrapperTable->m_DataModel_ClearLogCallback = nullptr;
		pWrapperTable->m_DataModel_HasLogCallback = nullptr;
		pWrapperTable->m_DataModel_TriggerLogCallback = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDataModelInstance = nullptr;
		
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::releaseWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::loadWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCDataIterator_MoveNextPtr) GetProcAddress(hLibrary, "libmcdata_iterator_movenext");
		#else // _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCDataIterator_MoveNextPtr) dlsym(hLibrary, "libmcdata_iterator_movenext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MoveNext == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCDataIterator_MovePreviousPtr) GetProcAddress(hLibrary, "libmcdata_iterator_moveprevious");
		#else // _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCDataIterator_MovePreviousPtr) dlsym(hLibrary, "libmcdata_iterator_moveprevious");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MovePrevious == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCDataIterator_GetCurrentPtr) GetProcAddress(hLibrary, "libmcdata_iterator_getcurrent");
		#else // _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCDataIterator_GetCurrentPtr) dlsym(hLibrary, "libmcdata_iterator_getcurrent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_GetCurrent == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCDataIterator_ClonePtr) GetProcAddress(hLibrary, "libmcdata_iterator_clone");
		#else // _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCDataIterator_ClonePtr) dlsym(hLibrary, "libmcdata_iterator_clone");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Clone == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCDataIterator_CountPtr) GetProcAddress(hLibrary, "libmcdata_iterator_count");
		#else // _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCDataIterator_CountPtr) dlsym(hLibrary, "libmcdata_iterator_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Count == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_Count = (PLibMCDataLogEntryList_CountPtr) GetProcAddress(hLibrary, "libmcdata_logentrylist_count");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_Count = (PLibMCDataLogEntryList_CountPtr) dlsym(hLibrary, "libmcdata_logentrylist_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_Count == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_GetEntryByIndex = (PLibMCDataLogEntryList_GetEntryByIndexPtr) GetProcAddress(hLibrary, "libmcdata_logentrylist_getentrybyindex");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_GetEntryByIndex = (PLibMCDataLogEntryList_GetEntryByIndexPtr) dlsym(hLibrary, "libmcdata_logentrylist_getentrybyindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_GetEntryByIndex == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_GetEntryByID = (PLibMCDataLogEntryList_GetEntryByIDPtr) GetProcAddress(hLibrary, "libmcdata_logentrylist_getentrybyid");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_GetEntryByID = (PLibMCDataLogEntryList_GetEntryByIDPtr) dlsym(hLibrary, "libmcdata_logentrylist_getentrybyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_GetEntryByID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_HasEntry = (PLibMCDataLogEntryList_HasEntryPtr) GetProcAddress(hLibrary, "libmcdata_logentrylist_hasentry");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_HasEntry = (PLibMCDataLogEntryList_HasEntryPtr) dlsym(hLibrary, "libmcdata_logentrylist_hasentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_HasEntry == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogSession_AddEntry = (PLibMCDataLogSession_AddEntryPtr) GetProcAddress(hLibrary, "libmcdata_logsession_addentry");
		#else // _WIN32
		pWrapperTable->m_LogSession_AddEntry = (PLibMCDataLogSession_AddEntryPtr) dlsym(hLibrary, "libmcdata_logsession_addentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogSession_AddEntry == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogSession_GetMaxLogEntryID = (PLibMCDataLogSession_GetMaxLogEntryIDPtr) GetProcAddress(hLibrary, "libmcdata_logsession_getmaxlogentryid");
		#else // _WIN32
		pWrapperTable->m_LogSession_GetMaxLogEntryID = (PLibMCDataLogSession_GetMaxLogEntryIDPtr) dlsym(hLibrary, "libmcdata_logsession_getmaxlogentryid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogSession_GetMaxLogEntryID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogSession_RetrieveLogEntriesByID = (PLibMCDataLogSession_RetrieveLogEntriesByIDPtr) GetProcAddress(hLibrary, "libmcdata_logsession_retrievelogentriesbyid");
		#else // _WIN32
		pWrapperTable->m_LogSession_RetrieveLogEntriesByID = (PLibMCDataLogSession_RetrieveLogEntriesByIDPtr) dlsym(hLibrary, "libmcdata_logsession_retrievelogentriesbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogSession_RetrieveLogEntriesByID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetUUID = (PLibMCDataStorageStream_GetUUIDPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getuuid");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetUUID = (PLibMCDataStorageStream_GetUUIDPtr) dlsym(hLibrary, "libmcdata_storagestream_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetTimeStamp = (PLibMCDataStorageStream_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetTimeStamp = (PLibMCDataStorageStream_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_storagestream_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetContextIdentifier = (PLibMCDataStorageStream_GetContextIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcontextidentifier");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetContextIdentifier = (PLibMCDataStorageStream_GetContextIdentifierPtr) dlsym(hLibrary, "libmcdata_storagestream_getcontextidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetContextIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetName = (PLibMCDataStorageStream_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getname");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetName = (PLibMCDataStorageStream_GetNamePtr) dlsym(hLibrary, "libmcdata_storagestream_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetMIMEType = (PLibMCDataStorageStream_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getmimetype");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetMIMEType = (PLibMCDataStorageStream_GetMIMETypePtr) dlsym(hLibrary, "libmcdata_storagestream_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetMIMEType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetSHA2 = (PLibMCDataStorageStream_GetSHA2Ptr) GetProcAddress(hLibrary, "libmcdata_storagestream_getsha2");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetSHA2 = (PLibMCDataStorageStream_GetSHA2Ptr) dlsym(hLibrary, "libmcdata_storagestream_getsha2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetSHA2 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetSize = (PLibMCDataStorageStream_GetSizePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getsize");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetSize = (PLibMCDataStorageStream_GetSizePtr) dlsym(hLibrary, "libmcdata_storagestream_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetContent = (PLibMCDataStorageStream_GetContentPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcontent");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetContent = (PLibMCDataStorageStream_GetContentPtr) dlsym(hLibrary, "libmcdata_storagestream_getcontent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetContent == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetCallbacks = (PLibMCDataStorageStream_GetCallbacksPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcallbacks");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetCallbacks = (PLibMCDataStorageStream_GetCallbacksPtr) dlsym(hLibrary, "libmcdata_storagestream_getcallbacks");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetCallbacks == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StreamIsReady = (PLibMCDataStorage_StreamIsReadyPtr) GetProcAddress(hLibrary, "libmcdata_storage_streamisready");
		#else // _WIN32
		pWrapperTable->m_Storage_StreamIsReady = (PLibMCDataStorage_StreamIsReadyPtr) dlsym(hLibrary, "libmcdata_storage_streamisready");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StreamIsReady == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_RetrieveStream = (PLibMCDataStorage_RetrieveStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_retrievestream");
		#else // _WIN32
		pWrapperTable->m_Storage_RetrieveStream = (PLibMCDataStorage_RetrieveStreamPtr) dlsym(hLibrary, "libmcdata_storage_retrievestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_RetrieveStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StoreNewStream = (PLibMCDataStorage_StoreNewStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_storenewstream");
		#else // _WIN32
		pWrapperTable->m_Storage_StoreNewStream = (PLibMCDataStorage_StoreNewStreamPtr) dlsym(hLibrary, "libmcdata_storage_storenewstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StoreNewStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_BeginPartialStream = (PLibMCDataStorage_BeginPartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_beginpartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_BeginPartialStream = (PLibMCDataStorage_BeginPartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_beginpartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_BeginPartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StorePartialStream = (PLibMCDataStorage_StorePartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_storepartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_StorePartialStream = (PLibMCDataStorage_StorePartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_storepartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StorePartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_FinishPartialStream = (PLibMCDataStorage_FinishPartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_finishpartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_FinishPartialStream = (PLibMCDataStorage_FinishPartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_finishpartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_FinishPartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 = (PLibMCDataStorage_FinishPartialStreamBlockwiseSHA256Ptr) GetProcAddress(hLibrary, "libmcdata_storage_finishpartialstreamblockwisesha256");
		#else // _WIN32
		pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 = (PLibMCDataStorage_FinishPartialStreamBlockwiseSHA256Ptr) dlsym(hLibrary, "libmcdata_storage_finishpartialstreamblockwisesha256");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_GetMaxStreamSize = (PLibMCDataStorage_GetMaxStreamSizePtr) GetProcAddress(hLibrary, "libmcdata_storage_getmaxstreamsize");
		#else // _WIN32
		pWrapperTable->m_Storage_GetMaxStreamSize = (PLibMCDataStorage_GetMaxStreamSizePtr) dlsym(hLibrary, "libmcdata_storage_getmaxstreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_GetMaxStreamSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_ContentTypeIsAccepted = (PLibMCDataStorage_ContentTypeIsAcceptedPtr) GetProcAddress(hLibrary, "libmcdata_storage_contenttypeisaccepted");
		#else // _WIN32
		pWrapperTable->m_Storage_ContentTypeIsAccepted = (PLibMCDataStorage_ContentTypeIsAcceptedPtr) dlsym(hLibrary, "libmcdata_storage_contenttypeisaccepted");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_ContentTypeIsAccepted == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StreamIsImage = (PLibMCDataStorage_StreamIsImagePtr) GetProcAddress(hLibrary, "libmcdata_storage_streamisimage");
		#else // _WIN32
		pWrapperTable->m_Storage_StreamIsImage = (PLibMCDataStorage_StreamIsImagePtr) dlsym(hLibrary, "libmcdata_storage_streamisimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StreamIsImage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetDataUUID = (PLibMCDataBuildJobData_GetDataUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getdatauuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetDataUUID = (PLibMCDataBuildJobData_GetDataUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getdatauuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetDataUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetJobUUID = (PLibMCDataBuildJobData_GetJobUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getjobuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetJobUUID = (PLibMCDataBuildJobData_GetJobUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getjobuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetJobUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetName = (PLibMCDataBuildJobData_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getname");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetName = (PLibMCDataBuildJobData_GetNamePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetContextIdentifier = (PLibMCDataBuildJobData_GetContextIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getcontextidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetContextIdentifier = (PLibMCDataBuildJobData_GetContextIdentifierPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getcontextidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetContextIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetTimeStamp = (PLibMCDataBuildJobData_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetTimeStamp = (PLibMCDataBuildJobData_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_buildjobdata_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStream = (PLibMCDataBuildJobData_GetStorageStreamPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getstoragestream");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStream = (PLibMCDataBuildJobData_GetStorageStreamPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getstoragestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetStorageStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 = (PLibMCDataBuildJobData_GetStorageStreamSHA2Ptr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getstoragestreamsha2");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 = (PLibMCDataBuildJobData_GetStorageStreamSHA2Ptr) dlsym(hLibrary, "libmcdata_buildjobdata_getstoragestreamsha2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStreamSize = (PLibMCDataBuildJobData_GetStorageStreamSizePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getstoragestreamsize");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStreamSize = (PLibMCDataBuildJobData_GetStorageStreamSizePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getstoragestreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetStorageStreamSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetDataType = (PLibMCDataBuildJobData_GetDataTypePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getdatatype");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetDataType = (PLibMCDataBuildJobData_GetDataTypePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getdatatype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetDataType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetDataTypeAsString = (PLibMCDataBuildJobData_GetDataTypeAsStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getdatatypeasstring");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetDataTypeAsString = (PLibMCDataBuildJobData_GetDataTypeAsStringPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getdatatypeasstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetDataTypeAsString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetMIMEType = (PLibMCDataBuildJobData_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getmimetype");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetMIMEType = (PLibMCDataBuildJobData_GetMIMETypePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetMIMEType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = (PLibMCDataBuildJobDataIterator_GetCurrentJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdataiterator_getcurrentjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = (PLibMCDataBuildJobDataIterator_GetCurrentJobDataPtr) dlsym(hLibrary, "libmcdata_buildjobdataiterator_getcurrentjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetUUID = (PLibMCDataBuildJob_GetUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetUUID = (PLibMCDataBuildJob_GetUUIDPtr) dlsym(hLibrary, "libmcdata_buildjob_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetName = (PLibMCDataBuildJob_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getname");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetName = (PLibMCDataBuildJob_GetNamePtr) dlsym(hLibrary, "libmcdata_buildjob_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStatus = (PLibMCDataBuildJob_GetStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstatus");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStatus = (PLibMCDataBuildJob_GetStatusPtr) dlsym(hLibrary, "libmcdata_buildjob_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetLayerCount = (PLibMCDataBuildJob_GetLayerCountPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getlayercount");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetLayerCount = (PLibMCDataBuildJob_GetLayerCountPtr) dlsym(hLibrary, "libmcdata_buildjob_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetLayerCount == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetTimeStamp = (PLibMCDataBuildJob_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetTimeStamp = (PLibMCDataBuildJob_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_buildjob_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStorageStream = (PLibMCDataBuildJob_GetStorageStreamPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstoragestream");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStorageStream = (PLibMCDataBuildJob_GetStorageStreamPtr) dlsym(hLibrary, "libmcdata_buildjob_getstoragestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStorageStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = (PLibMCDataBuildJob_GetStorageStreamUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstoragestreamuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = (PLibMCDataBuildJob_GetStorageStreamUUIDPtr) dlsym(hLibrary, "libmcdata_buildjob_getstoragestreamuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStorageStreamUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetBuildJobLogger = (PLibMCDataBuildJob_GetBuildJobLoggerPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getbuildjoblogger");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetBuildJobLogger = (PLibMCDataBuildJob_GetBuildJobLoggerPtr) dlsym(hLibrary, "libmcdata_buildjob_getbuildjoblogger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetBuildJobLogger == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_StartValidating = (PLibMCDataBuildJob_StartValidatingPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_startvalidating");
		#else // _WIN32
		pWrapperTable->m_BuildJob_StartValidating = (PLibMCDataBuildJob_StartValidatingPtr) dlsym(hLibrary, "libmcdata_buildjob_startvalidating");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_StartValidating == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_FinishValidating = (PLibMCDataBuildJob_FinishValidatingPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_finishvalidating");
		#else // _WIN32
		pWrapperTable->m_BuildJob_FinishValidating = (PLibMCDataBuildJob_FinishValidatingPtr) dlsym(hLibrary, "libmcdata_buildjob_finishvalidating");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_FinishValidating == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ArchiveJob = (PLibMCDataBuildJob_ArchiveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_archivejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ArchiveJob = (PLibMCDataBuildJob_ArchiveJobPtr) dlsym(hLibrary, "libmcdata_buildjob_archivejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ArchiveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_UnArchiveJob = (PLibMCDataBuildJob_UnArchiveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_unarchivejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_UnArchiveJob = (PLibMCDataBuildJob_UnArchiveJobPtr) dlsym(hLibrary, "libmcdata_buildjob_unarchivejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_UnArchiveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_DeleteJob = (PLibMCDataBuildJob_DeleteJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_deletejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_DeleteJob = (PLibMCDataBuildJob_DeleteJobPtr) dlsym(hLibrary, "libmcdata_buildjob_deletejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_DeleteJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_JobCanBeArchived = (PLibMCDataBuildJob_JobCanBeArchivedPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_jobcanbearchived");
		#else // _WIN32
		pWrapperTable->m_BuildJob_JobCanBeArchived = (PLibMCDataBuildJob_JobCanBeArchivedPtr) dlsym(hLibrary, "libmcdata_buildjob_jobcanbearchived");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_JobCanBeArchived == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_AddJobData = (PLibMCDataBuildJob_AddJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_addjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_AddJobData = (PLibMCDataBuildJob_AddJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_addjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_AddJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ListJobDataByType = (PLibMCDataBuildJob_ListJobDataByTypePtr) GetProcAddress(hLibrary, "libmcdata_buildjob_listjobdatabytype");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ListJobDataByType = (PLibMCDataBuildJob_ListJobDataByTypePtr) dlsym(hLibrary, "libmcdata_buildjob_listjobdatabytype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ListJobDataByType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ListJobData = (PLibMCDataBuildJob_ListJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_listjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ListJobData = (PLibMCDataBuildJob_ListJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_listjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ListJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_RetrieveJobData = (PLibMCDataBuildJob_RetrieveJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_retrievejobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_RetrieveJobData = (PLibMCDataBuildJob_RetrieveJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_retrievejobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_RetrieveJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = (PLibMCDataBuildJobIterator_GetCurrentJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobiterator_getcurrentjob");
		#else // _WIN32
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = (PLibMCDataBuildJobIterator_GetCurrentJobPtr) dlsym(hLibrary, "libmcdata_buildjobiterator_getcurrentjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobIterator_GetCurrentJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_CreateJob = (PLibMCDataBuildJobHandler_CreateJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_createjob");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_CreateJob = (PLibMCDataBuildJobHandler_CreateJobPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_createjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_CreateJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_RetrieveJob = (PLibMCDataBuildJobHandler_RetrieveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_retrievejob");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_RetrieveJob = (PLibMCDataBuildJobHandler_RetrieveJobPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_retrievejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_RetrieveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_FindJobOfData = (PLibMCDataBuildJobHandler_FindJobOfDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_findjobofdata");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_FindJobOfData = (PLibMCDataBuildJobHandler_FindJobOfDataPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_findjobofdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_FindJobOfData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = (PLibMCDataBuildJobHandler_ListJobsByStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_listjobsbystatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = (PLibMCDataBuildJobHandler_ListJobsByStatusPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_listjobsbystatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ListJobsByStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = (PLibMCDataBuildJobHandler_ConvertBuildStatusToStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_convertbuildstatustostring");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = (PLibMCDataBuildJobHandler_ConvertBuildStatusToStringPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_convertbuildstatustostring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = (PLibMCDataBuildJobHandler_ConvertStringToBuildStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_convertstringtobuildstatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = (PLibMCDataBuildJobHandler_ConvertStringToBuildStatusPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_convertstringtobuildstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserList_Count = (PLibMCDataUserList_CountPtr) GetProcAddress(hLibrary, "libmcdata_userlist_count");
		#else // _WIN32
		pWrapperTable->m_UserList_Count = (PLibMCDataUserList_CountPtr) dlsym(hLibrary, "libmcdata_userlist_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserList_Count == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserList_GetUserProperties = (PLibMCDataUserList_GetUserPropertiesPtr) GetProcAddress(hLibrary, "libmcdata_userlist_getuserproperties");
		#else // _WIN32
		pWrapperTable->m_UserList_GetUserProperties = (PLibMCDataUserList_GetUserPropertiesPtr) dlsym(hLibrary, "libmcdata_userlist_getuserproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserList_GetUserProperties == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_UserExists = (PLibMCDataLoginHandler_UserExistsPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_userexists");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_UserExists = (PLibMCDataLoginHandler_UserExistsPtr) dlsym(hLibrary, "libmcdata_loginhandler_userexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_UserExists == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserDetails = (PLibMCDataLoginHandler_GetUserDetailsPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserdetails");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserDetails = (PLibMCDataLoginHandler_GetUserDetailsPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserdetails");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserDetails == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserProperties = (PLibMCDataLoginHandler_GetUserPropertiesPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserproperties");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserProperties = (PLibMCDataLoginHandler_GetUserPropertiesPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserProperties == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID = (PLibMCDataLoginHandler_GetUserPropertiesByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserpropertiesbyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID = (PLibMCDataLoginHandler_GetUserPropertiesByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserpropertiesbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUsernameByUUID = (PLibMCDataLoginHandler_GetUsernameByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getusernamebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUsernameByUUID = (PLibMCDataLoginHandler_GetUsernameByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getusernamebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUsernameByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserUUID = (PLibMCDataLoginHandler_GetUserUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuseruuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserUUID = (PLibMCDataLoginHandler_GetUserUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuseruuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserDescription = (PLibMCDataLoginHandler_GetUserDescriptionPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserdescription");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserDescription = (PLibMCDataLoginHandler_GetUserDescriptionPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserDescription == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID = (PLibMCDataLoginHandler_GetUserDescriptionByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserdescriptionbyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID = (PLibMCDataLoginHandler_GetUserDescriptionByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserdescriptionbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserRole = (PLibMCDataLoginHandler_GetUserRolePtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserrole");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserRole = (PLibMCDataLoginHandler_GetUserRolePtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserrole");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserRole == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserRoleByUUID = (PLibMCDataLoginHandler_GetUserRoleByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserrolebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserRoleByUUID = (PLibMCDataLoginHandler_GetUserRoleByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserrolebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserRoleByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserLanguage = (PLibMCDataLoginHandler_GetUserLanguagePtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserlanguage");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserLanguage = (PLibMCDataLoginHandler_GetUserLanguagePtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserLanguage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserLanguageByUUID = (PLibMCDataLoginHandler_GetUserLanguageByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserlanguagebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserLanguageByUUID = (PLibMCDataLoginHandler_GetUserLanguageByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserlanguagebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserLanguageByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_CreateUser = (PLibMCDataLoginHandler_CreateUserPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_createuser");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_CreateUser = (PLibMCDataLoginHandler_CreateUserPtr) dlsym(hLibrary, "libmcdata_loginhandler_createuser");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_CreateUser == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserLanguage = (PLibMCDataLoginHandler_SetUserLanguagePtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserlanguage");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserLanguage = (PLibMCDataLoginHandler_SetUserLanguagePtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserLanguage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserRole = (PLibMCDataLoginHandler_SetUserRolePtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserrole");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserRole = (PLibMCDataLoginHandler_SetUserRolePtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserrole");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserRole == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserDescription = (PLibMCDataLoginHandler_SetUserDescriptionPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserdescription");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserDescription = (PLibMCDataLoginHandler_SetUserDescriptionPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserDescription == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserPassword = (PLibMCDataLoginHandler_SetUserPasswordPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserpassword");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserPassword = (PLibMCDataLoginHandler_SetUserPasswordPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserpassword");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserPassword == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserLanguageByUUID = (PLibMCDataLoginHandler_SetUserLanguageByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserlanguagebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserLanguageByUUID = (PLibMCDataLoginHandler_SetUserLanguageByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserlanguagebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserLanguageByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserRoleByUUID = (PLibMCDataLoginHandler_SetUserRoleByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserrolebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserRoleByUUID = (PLibMCDataLoginHandler_SetUserRoleByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserrolebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserRoleByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID = (PLibMCDataLoginHandler_SetUserDescriptionByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserdescriptionbyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID = (PLibMCDataLoginHandler_SetUserDescriptionByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserdescriptionbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserPasswordByUUID = (PLibMCDataLoginHandler_SetUserPasswordByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserpasswordbyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserPasswordByUUID = (PLibMCDataLoginHandler_SetUserPasswordByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserpasswordbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserPasswordByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetActiveUsers = (PLibMCDataLoginHandler_GetActiveUsersPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getactiveusers");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetActiveUsers = (PLibMCDataLoginHandler_GetActiveUsersPtr) dlsym(hLibrary, "libmcdata_loginhandler_getactiveusers");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetActiveUsers == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_HasPersistentParameter = (PLibMCDataPersistencyHandler_HasPersistentParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_haspersistentparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_HasPersistentParameter = (PLibMCDataPersistencyHandler_HasPersistentParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_haspersistentparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_HasPersistentParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails = (PLibMCDataPersistencyHandler_GetPersistentParameterDetailsPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_getpersistentparameterdetails");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails = (PLibMCDataPersistencyHandler_GetPersistentParameterDetailsPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_getpersistentparameterdetails");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_DeletePersistentParameter = (PLibMCDataPersistencyHandler_DeletePersistentParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_deletepersistentparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_DeletePersistentParameter = (PLibMCDataPersistencyHandler_DeletePersistentParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_deletepersistentparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_DeletePersistentParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentParameter = (PLibMCDataPersistencyHandler_StorePersistentParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentParameter = (PLibMCDataPersistencyHandler_StorePersistentParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter = (PLibMCDataPersistencyHandler_StorePersistentStringParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentstringparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter = (PLibMCDataPersistencyHandler_StorePersistentStringParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter = (PLibMCDataPersistencyHandler_StorePersistentUUIDParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentuuidparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter = (PLibMCDataPersistencyHandler_StorePersistentUUIDParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter = (PLibMCDataPersistencyHandler_StorePersistentDoubleParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter = (PLibMCDataPersistencyHandler_StorePersistentDoubleParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter = (PLibMCDataPersistencyHandler_StorePersistentIntegerParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentintegerparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter = (PLibMCDataPersistencyHandler_StorePersistentIntegerParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter = (PLibMCDataPersistencyHandler_StorePersistentBoolParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentboolparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter = (PLibMCDataPersistencyHandler_StorePersistentBoolParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter = (PLibMCDataPersistencyHandler_RetrievePersistentStringParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentstringparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter = (PLibMCDataPersistencyHandler_RetrievePersistentStringParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter = (PLibMCDataPersistencyHandler_RetrievePersistentUUIDParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentuuidparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter = (PLibMCDataPersistencyHandler_RetrievePersistentUUIDParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter = (PLibMCDataPersistencyHandler_RetrievePersistentDoubleParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter = (PLibMCDataPersistencyHandler_RetrievePersistentDoubleParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter = (PLibMCDataPersistencyHandler_RetrievePersistentIntegerParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentintegerparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter = (PLibMCDataPersistencyHandler_RetrievePersistentIntegerParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter = (PLibMCDataPersistencyHandler_RetrievePersistentBoolParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentboolparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter = (PLibMCDataPersistencyHandler_RetrievePersistentBoolParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_InitialiseDatabase = (PLibMCDataDataModel_InitialiseDatabasePtr) GetProcAddress(hLibrary, "libmcdata_datamodel_initialisedatabase");
		#else // _WIN32
		pWrapperTable->m_DataModel_InitialiseDatabase = (PLibMCDataDataModel_InitialiseDatabasePtr) dlsym(hLibrary, "libmcdata_datamodel_initialisedatabase");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_InitialiseDatabase == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetDataModelVersion = (PLibMCDataDataModel_GetDataModelVersionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getdatamodelversion");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetDataModelVersion = (PLibMCDataDataModel_GetDataModelVersionPtr) dlsym(hLibrary, "libmcdata_datamodel_getdatamodelversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetDataModelVersion == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformation = (PLibMCDataDataModel_GetInstallationInformationPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getinstallationinformation");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformation = (PLibMCDataDataModel_GetInstallationInformationPtr) dlsym(hLibrary, "libmcdata_datamodel_getinstallationinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetInstallationInformation == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateStorage = (PLibMCDataDataModel_CreateStoragePtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createstorage");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateStorage = (PLibMCDataDataModel_CreateStoragePtr) dlsym(hLibrary, "libmcdata_datamodel_createstorage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateStorage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateBuildJobHandler = (PLibMCDataDataModel_CreateBuildJobHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createbuildjobhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateBuildJobHandler = (PLibMCDataDataModel_CreateBuildJobHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createbuildjobhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateBuildJobHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateNewLogSession = (PLibMCDataDataModel_CreateNewLogSessionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createnewlogsession");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateNewLogSession = (PLibMCDataDataModel_CreateNewLogSessionPtr) dlsym(hLibrary, "libmcdata_datamodel_createnewlogsession");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateNewLogSession == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateLoginHandler = (PLibMCDataDataModel_CreateLoginHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createloginhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateLoginHandler = (PLibMCDataDataModel_CreateLoginHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createloginhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateLoginHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreatePersistencyHandler = (PLibMCDataDataModel_CreatePersistencyHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createpersistencyhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreatePersistencyHandler = (PLibMCDataDataModel_CreatePersistencyHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createpersistencyhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreatePersistencyHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_SetBaseTempDirectory = (PLibMCDataDataModel_SetBaseTempDirectoryPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_setbasetempdirectory");
		#else // _WIN32
		pWrapperTable->m_DataModel_SetBaseTempDirectory = (PLibMCDataDataModel_SetBaseTempDirectoryPtr) dlsym(hLibrary, "libmcdata_datamodel_setbasetempdirectory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_SetBaseTempDirectory == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetBaseTempDirectory = (PLibMCDataDataModel_GetBaseTempDirectoryPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getbasetempdirectory");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetBaseTempDirectory = (PLibMCDataDataModel_GetBaseTempDirectoryPtr) dlsym(hLibrary, "libmcdata_datamodel_getbasetempdirectory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetBaseTempDirectory == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_SetLogCallback = (PLibMCDataDataModel_SetLogCallbackPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_setlogcallback");
		#else // _WIN32
		pWrapperTable->m_DataModel_SetLogCallback = (PLibMCDataDataModel_SetLogCallbackPtr) dlsym(hLibrary, "libmcdata_datamodel_setlogcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_SetLogCallback == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_ClearLogCallback = (PLibMCDataDataModel_ClearLogCallbackPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_clearlogcallback");
		#else // _WIN32
		pWrapperTable->m_DataModel_ClearLogCallback = (PLibMCDataDataModel_ClearLogCallbackPtr) dlsym(hLibrary, "libmcdata_datamodel_clearlogcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_ClearLogCallback == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_HasLogCallback = (PLibMCDataDataModel_HasLogCallbackPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_haslogcallback");
		#else // _WIN32
		pWrapperTable->m_DataModel_HasLogCallback = (PLibMCDataDataModel_HasLogCallbackPtr) dlsym(hLibrary, "libmcdata_datamodel_haslogcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_HasLogCallback == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_TriggerLogCallback = (PLibMCDataDataModel_TriggerLogCallbackPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_triggerlogcallback");
		#else // _WIN32
		pWrapperTable->m_DataModel_TriggerLogCallback = (PLibMCDataDataModel_TriggerLogCallbackPtr) dlsym(hLibrary, "libmcdata_datamodel_triggerlogcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_TriggerLogCallback == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDataGetVersionPtr) GetProcAddress(hLibrary, "libmcdata_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDataGetVersionPtr) dlsym(hLibrary, "libmcdata_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDataGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdata_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDataGetLastErrorPtr) dlsym(hLibrary, "libmcdata_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDataReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdata_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDataReleaseInstancePtr) dlsym(hLibrary, "libmcdata_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDataAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdata_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDataAcquireInstancePtr) dlsym(hLibrary, "libmcdata_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDataGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdata_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDataGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdata_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDataModelInstance = (PLibMCDataCreateDataModelInstancePtr) GetProcAddress(hLibrary, "libmcdata_createdatamodelinstance");
		#else // _WIN32
		pWrapperTable->m_CreateDataModelInstance = (PLibMCDataCreateDataModelInstancePtr) dlsym(hLibrary, "libmcdata_createdatamodelinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDataModelInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDataDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		typedef LibMCDataResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDataResult eLookupError = LIBMCDATA_SUCCESS;
		eLookupError = (*pLookup)("libmcdata_iterator_movenext", (void**)&(pWrapperTable->m_Iterator_MoveNext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MoveNext == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_moveprevious", (void**)&(pWrapperTable->m_Iterator_MovePrevious));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MovePrevious == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_getcurrent", (void**)&(pWrapperTable->m_Iterator_GetCurrent));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_GetCurrent == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_clone", (void**)&(pWrapperTable->m_Iterator_Clone));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Clone == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_count", (void**)&(pWrapperTable->m_Iterator_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Count == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logentrylist_count", (void**)&(pWrapperTable->m_LogEntryList_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_Count == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logentrylist_getentrybyindex", (void**)&(pWrapperTable->m_LogEntryList_GetEntryByIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_GetEntryByIndex == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logentrylist_getentrybyid", (void**)&(pWrapperTable->m_LogEntryList_GetEntryByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_GetEntryByID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logentrylist_hasentry", (void**)&(pWrapperTable->m_LogEntryList_HasEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_HasEntry == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logsession_addentry", (void**)&(pWrapperTable->m_LogSession_AddEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogSession_AddEntry == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logsession_getmaxlogentryid", (void**)&(pWrapperTable->m_LogSession_GetMaxLogEntryID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogSession_GetMaxLogEntryID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logsession_retrievelogentriesbyid", (void**)&(pWrapperTable->m_LogSession_RetrieveLogEntriesByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogSession_RetrieveLogEntriesByID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getuuid", (void**)&(pWrapperTable->m_StorageStream_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_gettimestamp", (void**)&(pWrapperTable->m_StorageStream_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcontextidentifier", (void**)&(pWrapperTable->m_StorageStream_GetContextIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetContextIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getname", (void**)&(pWrapperTable->m_StorageStream_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getmimetype", (void**)&(pWrapperTable->m_StorageStream_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetMIMEType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getsha2", (void**)&(pWrapperTable->m_StorageStream_GetSHA2));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetSHA2 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getsize", (void**)&(pWrapperTable->m_StorageStream_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcontent", (void**)&(pWrapperTable->m_StorageStream_GetContent));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetContent == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcallbacks", (void**)&(pWrapperTable->m_StorageStream_GetCallbacks));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetCallbacks == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_streamisready", (void**)&(pWrapperTable->m_Storage_StreamIsReady));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StreamIsReady == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_retrievestream", (void**)&(pWrapperTable->m_Storage_RetrieveStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_RetrieveStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_storenewstream", (void**)&(pWrapperTable->m_Storage_StoreNewStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StoreNewStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_beginpartialstream", (void**)&(pWrapperTable->m_Storage_BeginPartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_BeginPartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_storepartialstream", (void**)&(pWrapperTable->m_Storage_StorePartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StorePartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_finishpartialstream", (void**)&(pWrapperTable->m_Storage_FinishPartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_FinishPartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_finishpartialstreamblockwisesha256", (void**)&(pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_getmaxstreamsize", (void**)&(pWrapperTable->m_Storage_GetMaxStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_GetMaxStreamSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_contenttypeisaccepted", (void**)&(pWrapperTable->m_Storage_ContentTypeIsAccepted));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_ContentTypeIsAccepted == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_streamisimage", (void**)&(pWrapperTable->m_Storage_StreamIsImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StreamIsImage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getdatauuid", (void**)&(pWrapperTable->m_BuildJobData_GetDataUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetDataUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getjobuuid", (void**)&(pWrapperTable->m_BuildJobData_GetJobUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetJobUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getname", (void**)&(pWrapperTable->m_BuildJobData_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getcontextidentifier", (void**)&(pWrapperTable->m_BuildJobData_GetContextIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetContextIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_gettimestamp", (void**)&(pWrapperTable->m_BuildJobData_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getstoragestream", (void**)&(pWrapperTable->m_BuildJobData_GetStorageStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetStorageStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getstoragestreamsha2", (void**)&(pWrapperTable->m_BuildJobData_GetStorageStreamSHA2));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getstoragestreamsize", (void**)&(pWrapperTable->m_BuildJobData_GetStorageStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetStorageStreamSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getdatatype", (void**)&(pWrapperTable->m_BuildJobData_GetDataType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetDataType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getdatatypeasstring", (void**)&(pWrapperTable->m_BuildJobData_GetDataTypeAsString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetDataTypeAsString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getmimetype", (void**)&(pWrapperTable->m_BuildJobData_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetMIMEType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdataiterator_getcurrentjobdata", (void**)&(pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getuuid", (void**)&(pWrapperTable->m_BuildJob_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getname", (void**)&(pWrapperTable->m_BuildJob_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstatus", (void**)&(pWrapperTable->m_BuildJob_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getlayercount", (void**)&(pWrapperTable->m_BuildJob_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetLayerCount == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_gettimestamp", (void**)&(pWrapperTable->m_BuildJob_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstoragestream", (void**)&(pWrapperTable->m_BuildJob_GetStorageStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStorageStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstoragestreamuuid", (void**)&(pWrapperTable->m_BuildJob_GetStorageStreamUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStorageStreamUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getbuildjoblogger", (void**)&(pWrapperTable->m_BuildJob_GetBuildJobLogger));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetBuildJobLogger == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_startvalidating", (void**)&(pWrapperTable->m_BuildJob_StartValidating));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_StartValidating == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_finishvalidating", (void**)&(pWrapperTable->m_BuildJob_FinishValidating));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_FinishValidating == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_archivejob", (void**)&(pWrapperTable->m_BuildJob_ArchiveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ArchiveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_unarchivejob", (void**)&(pWrapperTable->m_BuildJob_UnArchiveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_UnArchiveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_deletejob", (void**)&(pWrapperTable->m_BuildJob_DeleteJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_DeleteJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_jobcanbearchived", (void**)&(pWrapperTable->m_BuildJob_JobCanBeArchived));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_JobCanBeArchived == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_addjobdata", (void**)&(pWrapperTable->m_BuildJob_AddJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_AddJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_listjobdatabytype", (void**)&(pWrapperTable->m_BuildJob_ListJobDataByType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ListJobDataByType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_listjobdata", (void**)&(pWrapperTable->m_BuildJob_ListJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ListJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_retrievejobdata", (void**)&(pWrapperTable->m_BuildJob_RetrieveJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_RetrieveJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobiterator_getcurrentjob", (void**)&(pWrapperTable->m_BuildJobIterator_GetCurrentJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobIterator_GetCurrentJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_createjob", (void**)&(pWrapperTable->m_BuildJobHandler_CreateJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_CreateJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_retrievejob", (void**)&(pWrapperTable->m_BuildJobHandler_RetrieveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_RetrieveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_findjobofdata", (void**)&(pWrapperTable->m_BuildJobHandler_FindJobOfData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_FindJobOfData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_listjobsbystatus", (void**)&(pWrapperTable->m_BuildJobHandler_ListJobsByStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ListJobsByStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_convertbuildstatustostring", (void**)&(pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_convertstringtobuildstatus", (void**)&(pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_userlist_count", (void**)&(pWrapperTable->m_UserList_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserList_Count == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_userlist_getuserproperties", (void**)&(pWrapperTable->m_UserList_GetUserProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserList_GetUserProperties == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_userexists", (void**)&(pWrapperTable->m_LoginHandler_UserExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_UserExists == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserdetails", (void**)&(pWrapperTable->m_LoginHandler_GetUserDetails));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserDetails == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserproperties", (void**)&(pWrapperTable->m_LoginHandler_GetUserProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserProperties == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserpropertiesbyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getusernamebyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUsernameByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUsernameByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuseruuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserdescription", (void**)&(pWrapperTable->m_LoginHandler_GetUserDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserDescription == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserdescriptionbyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserrole", (void**)&(pWrapperTable->m_LoginHandler_GetUserRole));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserRole == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserrolebyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserRoleByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserRoleByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserlanguage", (void**)&(pWrapperTable->m_LoginHandler_GetUserLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserLanguage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserlanguagebyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserLanguageByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserLanguageByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_createuser", (void**)&(pWrapperTable->m_LoginHandler_CreateUser));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_CreateUser == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserlanguage", (void**)&(pWrapperTable->m_LoginHandler_SetUserLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserLanguage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserrole", (void**)&(pWrapperTable->m_LoginHandler_SetUserRole));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserRole == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserdescription", (void**)&(pWrapperTable->m_LoginHandler_SetUserDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserDescription == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserpassword", (void**)&(pWrapperTable->m_LoginHandler_SetUserPassword));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserPassword == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserlanguagebyuuid", (void**)&(pWrapperTable->m_LoginHandler_SetUserLanguageByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserLanguageByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserrolebyuuid", (void**)&(pWrapperTable->m_LoginHandler_SetUserRoleByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserRoleByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserdescriptionbyuuid", (void**)&(pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserpasswordbyuuid", (void**)&(pWrapperTable->m_LoginHandler_SetUserPasswordByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserPasswordByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getactiveusers", (void**)&(pWrapperTable->m_LoginHandler_GetActiveUsers));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetActiveUsers == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_haspersistentparameter", (void**)&(pWrapperTable->m_PersistencyHandler_HasPersistentParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_HasPersistentParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_getpersistentparameterdetails", (void**)&(pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_deletepersistentparameter", (void**)&(pWrapperTable->m_PersistencyHandler_DeletePersistentParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_DeletePersistentParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentstringparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentuuidparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentdoubleparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentintegerparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentboolparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentstringparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentuuidparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentdoubleparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentintegerparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentboolparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_initialisedatabase", (void**)&(pWrapperTable->m_DataModel_InitialiseDatabase));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_InitialiseDatabase == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getdatamodelversion", (void**)&(pWrapperTable->m_DataModel_GetDataModelVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetDataModelVersion == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getinstallationinformation", (void**)&(pWrapperTable->m_DataModel_GetInstallationInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetInstallationInformation == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createstorage", (void**)&(pWrapperTable->m_DataModel_CreateStorage));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateStorage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createbuildjobhandler", (void**)&(pWrapperTable->m_DataModel_CreateBuildJobHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateBuildJobHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createnewlogsession", (void**)&(pWrapperTable->m_DataModel_CreateNewLogSession));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateNewLogSession == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createloginhandler", (void**)&(pWrapperTable->m_DataModel_CreateLoginHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateLoginHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createpersistencyhandler", (void**)&(pWrapperTable->m_DataModel_CreatePersistencyHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreatePersistencyHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_setbasetempdirectory", (void**)&(pWrapperTable->m_DataModel_SetBaseTempDirectory));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_SetBaseTempDirectory == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getbasetempdirectory", (void**)&(pWrapperTable->m_DataModel_GetBaseTempDirectory));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetBaseTempDirectory == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_setlogcallback", (void**)&(pWrapperTable->m_DataModel_SetLogCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_SetLogCallback == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_clearlogcallback", (void**)&(pWrapperTable->m_DataModel_ClearLogCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_ClearLogCallback == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_haslogcallback", (void**)&(pWrapperTable->m_DataModel_HasLogCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_HasLogCallback == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_triggerlogcallback", (void**)&(pWrapperTable->m_DataModel_TriggerLogCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_TriggerLogCallback == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_createdatamodelinstance", (void**)&(pWrapperTable->m_CreateDataModelInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDataModelInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDATA_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CIterator
	 */
	
	/**
	* CIterator::MoveNext - Iterates to the next resource in the list.
	* @return Iterates to the next resource in the list.
	*/
	bool CIterator::MoveNext()
	{
		bool resultHasNext = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MoveNext(m_pHandle, &resultHasNext));
		
		return resultHasNext;
	}
	
	/**
	* CIterator::MovePrevious - Iterates to the previous resource in the list.
	* @return Iterates to the previous resource in the list.
	*/
	bool CIterator::MovePrevious()
	{
		bool resultHasPrevious = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MovePrevious(m_pHandle, &resultHasPrevious));
		
		return resultHasPrevious;
	}
	
	/**
	* CIterator::GetCurrent - Returns the resource the iterator points at.
	* @return returns the resource instance.
	*/
	PBase CIterator::GetCurrent()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_GetCurrent(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBase>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	* CIterator::Clone - Creates a new resource iterator with the same resource list.
	* @return returns the cloned Iterator instance
	*/
	PIterator CIterator::Clone()
	{
		LibMCDataHandle hOutIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Clone(m_pHandle, &hOutIterator));
		
		if (!hOutIterator) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CIterator>(m_pWrapper, hOutIterator);
	}
	
	/**
	* CIterator::Count - Returns the number of resources the iterator captures.
	* @return returns the number of resources the iterator captures.
	*/
	LibMCData_uint64 CIterator::Count()
	{
		LibMCData_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CLogEntryList
	 */
	
	/**
	* CLogEntryList::Count - Returns the number of log entries in the list.
	* @return returns the number of retrieved log entries.
	*/
	LibMCData_uint32 CLogEntryList::Count()
	{
		LibMCData_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CLogEntryList::GetEntryByIndex - Returns a log entry in the list by its index.
	* @param[in] nIndex - Index of log entry, 0-based.
	* @param[out] nID - ID of log entry.
	* @param[out] sMessage - Log Message
	* @param[out] sSubSystem - Sub System identifier
	* @param[out] eLogLevel - Log Level
	* @param[out] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	void CLogEntryList::GetEntryByIndex(const LibMCData_uint32 nIndex, LibMCData_uint32 & nID, std::string & sMessage, std::string & sSubSystem, eLogLevel & eLogLevel, std::string & sTimestamp)
	{
		LibMCData_uint32 bytesNeededMessage = 0;
		LibMCData_uint32 bytesWrittenMessage = 0;
		LibMCData_uint32 bytesNeededSubSystem = 0;
		LibMCData_uint32 bytesWrittenSubSystem = 0;
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntryByIndex(m_pHandle, nIndex, &nID, 0, &bytesNeededMessage, nullptr, 0, &bytesNeededSubSystem, nullptr, &eLogLevel, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferMessage(bytesNeededMessage);
		std::vector<char> bufferSubSystem(bytesNeededSubSystem);
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntryByIndex(m_pHandle, nIndex, &nID, bytesNeededMessage, &bytesWrittenMessage, &bufferMessage[0], bytesNeededSubSystem, &bytesWrittenSubSystem, &bufferSubSystem[0], &eLogLevel, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		sMessage = std::string(&bufferMessage[0]);
		sSubSystem = std::string(&bufferSubSystem[0]);
		sTimestamp = std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CLogEntryList::GetEntryByID - Returns a log entry in the list by its ID.
	* @param[in] nID - ID of log entry.
	* @param[out] sMessage - Log Message
	* @param[out] sSubSystem - Sub System identifier
	* @param[out] eLogLevel - Log Level
	* @param[out] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	void CLogEntryList::GetEntryByID(const LibMCData_uint32 nID, std::string & sMessage, std::string & sSubSystem, eLogLevel & eLogLevel, std::string & sTimestamp)
	{
		LibMCData_uint32 bytesNeededMessage = 0;
		LibMCData_uint32 bytesWrittenMessage = 0;
		LibMCData_uint32 bytesNeededSubSystem = 0;
		LibMCData_uint32 bytesWrittenSubSystem = 0;
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntryByID(m_pHandle, nID, 0, &bytesNeededMessage, nullptr, 0, &bytesNeededSubSystem, nullptr, &eLogLevel, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferMessage(bytesNeededMessage);
		std::vector<char> bufferSubSystem(bytesNeededSubSystem);
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntryByID(m_pHandle, nID, bytesNeededMessage, &bytesWrittenMessage, &bufferMessage[0], bytesNeededSubSystem, &bytesWrittenSubSystem, &bufferSubSystem[0], &eLogLevel, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		sMessage = std::string(&bufferMessage[0]);
		sSubSystem = std::string(&bufferSubSystem[0]);
		sTimestamp = std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CLogEntryList::HasEntry - Returns if a log entry in the list exists.
	* @param[in] nID - ID of log entry.
	* @return Returns if a list exists.
	*/
	bool CLogEntryList::HasEntry(const LibMCData_uint32 nID)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_HasEntry(m_pHandle, nID, &resultValue));
		
		return resultValue;
	}
	
	/**
	 * Method definitions for class CLogSession
	 */
	
	/**
	* CLogSession::AddEntry - adds a new log entry.
	* @param[in] sMessage - Log Message
	* @param[in] sSubSystem - Sub System identifier
	* @param[in] eLogLevel - Log Level
	* @param[in] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	void CLogSession::AddEntry(const std::string & sMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_AddEntry(m_pHandle, sMessage.c_str(), sSubSystem.c_str(), eLogLevel, sTimestamp.c_str()));
	}
	
	/**
	* CLogSession::GetMaxLogEntryID - retrieves the maximum log entry ID in the log.
	* @return Log entry ID
	*/
	LibMCData_uint32 CLogSession::GetMaxLogEntryID()
	{
		LibMCData_uint32 resultMaxLogID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_GetMaxLogEntryID(m_pHandle, &resultMaxLogID));
		
		return resultMaxLogID;
	}
	
	/**
	* CLogSession::RetrieveLogEntriesByID - retrieves an excerpt of the log.
	* @param[in] nMinLogID - Minimum log entry ID to receive.
	* @param[in] nMaxLogID - Maximum log entry ID to receive. MUST be between (MinLogID + 1) and (MinLogID + 65536).
	* @param[in] eMinLogLevel - Minimum Log Level to return.
	* @return Log Entry List.
	*/
	PLogEntryList CLogSession::RetrieveLogEntriesByID(const LibMCData_uint32 nMinLogID, const LibMCData_uint32 nMaxLogID, const eLogLevel eMinLogLevel)
	{
		LibMCDataHandle hLogEntryList = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_RetrieveLogEntriesByID(m_pHandle, nMinLogID, nMaxLogID, eMinLogLevel, &hLogEntryList));
		
		if (!hLogEntryList) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogEntryList>(m_pWrapper, hLogEntryList);
	}
	
	/**
	 * Method definitions for class CStorageStream
	 */
	
	/**
	* CStorageStream::GetUUID - returns the uuid of a storage stream.
	* @return UUID String
	*/
	std::string CStorageStream::GetUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CStorageStream::GetTimeStamp - returns the timestamp of a storage stream.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CStorageStream::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CStorageStream::GetContextIdentifier - returns the context identifier of a storage stream.
	* @return Context Identifier String
	*/
	std::string CStorageStream::GetContextIdentifier()
	{
		LibMCData_uint32 bytesNeededContextIdentifier = 0;
		LibMCData_uint32 bytesWrittenContextIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContextIdentifier(m_pHandle, 0, &bytesNeededContextIdentifier, nullptr));
		std::vector<char> bufferContextIdentifier(bytesNeededContextIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContextIdentifier(m_pHandle, bytesNeededContextIdentifier, &bytesWrittenContextIdentifier, &bufferContextIdentifier[0]));
		
		return std::string(&bufferContextIdentifier[0]);
	}
	
	/**
	* CStorageStream::GetName - returns the name description of a storage stream.
	* @return Name String
	*/
	std::string CStorageStream::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CStorageStream::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	std::string CStorageStream::GetMIMEType()
	{
		LibMCData_uint32 bytesNeededMimeType = 0;
		LibMCData_uint32 bytesWrittenMimeType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetMIMEType(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetMIMEType(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	* CStorageStream::GetSHA2 - returns the sha256 checksum of a storage stream.
	* @return SHA1 String
	*/
	std::string CStorageStream::GetSHA2()
	{
		LibMCData_uint32 bytesNeededSHA2 = 0;
		LibMCData_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSHA2(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSHA2(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CStorageStream::GetSize - returns the size of a storage stream.
	* @return Size
	*/
	LibMCData_uint64 CStorageStream::GetSize()
	{
		LibMCData_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CStorageStream::GetContent - returns the content of a storage stream.
	* @param[out] ContentBuffer - Byte Content of the stream
	*/
	void CStorageStream::GetContent(std::vector<LibMCData_uint8> & ContentBuffer)
	{
		LibMCData_uint64 elementsNeededContent = 0;
		LibMCData_uint64 elementsWrittenContent = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContent(m_pHandle, 0, &elementsNeededContent, nullptr));
		ContentBuffer.resize((size_t) elementsNeededContent);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContent(m_pHandle, elementsNeededContent, &elementsWrittenContent, ContentBuffer.data()));
	}
	
	/**
	* CStorageStream::GetCallbacks - returns direct read access to the storage stream. The callbacks are only valid throughout the existence of the StorageStream instance.
	* @param[out] pTheReadCallback - Callback to call for reading a data chunk
	* @param[out] pTheSeekCallback - Callback to call for seeking in the stream.
	* @param[out] pStreamHandle - Handle of the stream.
	*/
	void CStorageStream::GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetCallbacks(m_pHandle, &pTheReadCallback, &pTheSeekCallback, &pStreamHandle));
	}
	
	/**
	 * Method definitions for class CStorage
	 */
	
	/**
	* CStorage::StreamIsReady - checks if a stream exists and is written to disk.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream is ready.
	*/
	bool CStorage::StreamIsReady(const std::string & sUUID)
	{
		bool resultIsReady = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StreamIsReady(m_pHandle, sUUID.c_str(), &resultIsReady));
		
		return resultIsReady;
	}
	
	/**
	* CStorage::RetrieveStream - retrieves an existing stream.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream Instance.
	*/
	PStorageStream CStorage::RetrieveStream(const std::string & sUUID)
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_RetrieveStream(m_pHandle, sUUID.c_str(), &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CStorage::StoreNewStream - stores a new stream.
	* @param[in] sUUID - UUID of storage stream. Must be unique and newly generated.
	* @param[in] sContextUUID - Context UUID of storage stream. Important for ownership and deletion.
	* @param[in] sContextIdentifier - Identifier of the stream. MUST be unique within the given context.
	* @param[in] sName - Name Description of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] ContentBuffer - Data of stream
	* @param[in] sUserID - Currently authenticated user
	*/
	void CStorage::StoreNewStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sContextIdentifier, const std::string & sName, const std::string & sMimeType, const CInputVector<LibMCData_uint8> & ContentBuffer, const std::string & sUserID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StoreNewStream(m_pHandle, sUUID.c_str(), sContextUUID.c_str(), sContextIdentifier.c_str(), sName.c_str(), sMimeType.c_str(), (LibMCData_uint64)ContentBuffer.size(), ContentBuffer.data(), sUserID.c_str()));
	}
	
	/**
	* CStorage::BeginPartialStream - starts storing a stream with partial uploads.
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sContextUUID - Context UUID of storage stream. Important for ownership and deletion.
	* @param[in] sContextIdentifier - Identifier of the stream. MUST be unique within the given context.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] nSize - Final size of the stream. MUST NOT be 0.
	* @param[in] sUserID - Currently authenticated user
	*/
	void CStorage::BeginPartialStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sContextIdentifier, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_BeginPartialStream(m_pHandle, sUUID.c_str(), sContextUUID.c_str(), sContextIdentifier.c_str(), sName.c_str(), sMimeType.c_str(), nSize, sUserID.c_str()));
	}
	
	/**
	* CStorage::StorePartialStream - stores data in a stream with partial uploads. Uploads should be sequential for optimal performance, but may be in arbitrary order.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] nOffset - Offset in stream to store to. Can be an arbitrary position, but storage MUST NOT override already uploaded data.
	* @param[in] ContentBuffer - Data block to store in stream.
	*/
	void CStorage::StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StorePartialStream(m_pHandle, sUUID.c_str(), nOffset, (LibMCData_uint64)ContentBuffer.size(), ContentBuffer.data()));
	}
	
	/**
	* CStorage::FinishPartialStream - Finishes storing a stream.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sSHA2 - SHA256 of the uploaded data. If given initially, MUST be identical.
	*/
	void CStorage::FinishPartialStream(const std::string & sUUID, const std::string & sSHA2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_FinishPartialStream(m_pHandle, sUUID.c_str(), sSHA2.c_str()));
	}
	
	/**
	* CStorage::FinishPartialStreamBlockwiseSHA256 - Finishes storing a stream with a 64k-Blockwise calculated Checksum.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sBlockwiseSHA2 - 64kB hashlist SHA256 checksum of the uploaded data. If given initially, MUST be identical.
	*/
	void CStorage::FinishPartialStreamBlockwiseSHA256(const std::string & sUUID, const std::string & sBlockwiseSHA2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_FinishPartialStreamBlockwiseSHA256(m_pHandle, sUUID.c_str(), sBlockwiseSHA2.c_str()));
	}
	
	/**
	* CStorage::GetMaxStreamSize - Returns the maximum stream size that the data model allows.
	* @return Maximum Stream Size in Bytes.
	*/
	LibMCData_uint64 CStorage::GetMaxStreamSize()
	{
		LibMCData_uint64 resultMaxStreamSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_GetMaxStreamSize(m_pHandle, &resultMaxStreamSize));
		
		return resultMaxStreamSize;
	}
	
	/**
	* CStorage::ContentTypeIsAccepted - Returns if the given content type is an acceptable value.
	* @param[in] sContentType - Content type string (is taken case-insensitive)
	* @return Content type is accepted.
	*/
	bool CStorage::ContentTypeIsAccepted(const std::string & sContentType)
	{
		bool resultAccepted = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_ContentTypeIsAccepted(m_pHandle, sContentType.c_str(), &resultAccepted));
		
		return resultAccepted;
	}
	
	/**
	* CStorage::StreamIsImage - checks if a stream is an image.
	* @param[in] sUUID - UUID of storage stream.
	* @return Returns if the stream is an image.
	*/
	bool CStorage::StreamIsImage(const std::string & sUUID)
	{
		bool resultIsImage = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StreamIsImage(m_pHandle, sUUID.c_str(), &resultIsImage));
		
		return resultIsImage;
	}
	
	/**
	 * Method definitions for class CBuildJobData
	 */
	
	/**
	* CBuildJobData::GetDataUUID - returns the uuid of a build job data.
	* @return UUID String
	*/
	std::string CBuildJobData::GetDataUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJobData::GetJobUUID - returns the uuid of the parent build job.
	* @return UUID String
	*/
	std::string CBuildJobData::GetJobUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetJobUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetJobUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJobData::GetName - returns the name of the job data.
	* @return Name String
	*/
	std::string CBuildJobData::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBuildJobData::GetContextIdentifier - returns the unique context identifier of the job data.
	* @return Context Identifier String
	*/
	std::string CBuildJobData::GetContextIdentifier()
	{
		LibMCData_uint32 bytesNeededContextIdentifier = 0;
		LibMCData_uint32 bytesWrittenContextIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetContextIdentifier(m_pHandle, 0, &bytesNeededContextIdentifier, nullptr));
		std::vector<char> bufferContextIdentifier(bytesNeededContextIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetContextIdentifier(m_pHandle, bytesNeededContextIdentifier, &bytesWrittenContextIdentifier, &bufferContextIdentifier[0]));
		
		return std::string(&bufferContextIdentifier[0]);
	}
	
	/**
	* CBuildJobData::GetTimeStamp - returns the timestamp when the job data was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CBuildJobData::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CBuildJobData::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	PStorageStream CBuildJobData::GetStorageStream()
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetStorageStream(m_pHandle, &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CBuildJobData::GetStorageStreamSHA2 - returns the checksum of the storage stream of the build.
	* @return SHA256 of the storage stream.
	*/
	std::string CBuildJobData::GetStorageStreamSHA2()
	{
		LibMCData_uint32 bytesNeededSHA2 = 0;
		LibMCData_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetStorageStreamSHA2(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetStorageStreamSHA2(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CBuildJobData::GetStorageStreamSize - returns the size of the storage stream of the build.
	* @return size of the storage stream in bytes.
	*/
	LibMCData_uint64 CBuildJobData::GetStorageStreamSize()
	{
		LibMCData_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetStorageStreamSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CBuildJobData::GetDataType - returns the data type of the job data.
	* @return Data type of the job data
	*/
	eBuildJobDataType CBuildJobData::GetDataType()
	{
		eBuildJobDataType resultDataType = (eBuildJobDataType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataType(m_pHandle, &resultDataType));
		
		return resultDataType;
	}
	
	/**
	* CBuildJobData::GetDataTypeAsString - returns the data type of the job data as string.
	* @return Data type of the job data
	*/
	std::string CBuildJobData::GetDataTypeAsString()
	{
		LibMCData_uint32 bytesNeededDataType = 0;
		LibMCData_uint32 bytesWrittenDataType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataTypeAsString(m_pHandle, 0, &bytesNeededDataType, nullptr));
		std::vector<char> bufferDataType(bytesNeededDataType);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataTypeAsString(m_pHandle, bytesNeededDataType, &bytesWrittenDataType, &bufferDataType[0]));
		
		return std::string(&bufferDataType[0]);
	}
	
	/**
	* CBuildJobData::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	std::string CBuildJobData::GetMIMEType()
	{
		LibMCData_uint32 bytesNeededMimeType = 0;
		LibMCData_uint32 bytesWrittenMimeType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetMIMEType(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetMIMEType(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	 * Method definitions for class CBuildJobDataIterator
	 */
	
	/**
	* CBuildJobDataIterator::GetCurrentJobData - Returns the build job data the iterator points at.
	* @return returns the build job instance.
	*/
	PBuildJobData CBuildJobDataIterator::GetCurrentJobData()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobDataIterator_GetCurrentJobData(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobData>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJob
	 */
	
	/**
	* CBuildJob::GetUUID - returns the uuid of a build job.
	* @return UUID String
	*/
	std::string CBuildJob::GetUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJob::GetName - returns the name of a build job.
	* @return Name String
	*/
	std::string CBuildJob::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBuildJob::GetStatus - returns the status of a build job.
	* @return Status of build job.
	*/
	eBuildJobStatus CBuildJob::GetStatus()
	{
		eBuildJobStatus resultStatus = (eBuildJobStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStatus(m_pHandle, &resultStatus));
		
		return resultStatus;
	}
	
	/**
	* CBuildJob::GetLayerCount - returns the layer count of a build job.
	* @return Layer Count of build job
	*/
	LibMCData_uint32 CBuildJob::GetLayerCount()
	{
		LibMCData_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CBuildJob::GetTimeStamp - returns the timestamp when the job was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CBuildJob::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CBuildJob::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	PStorageStream CBuildJob::GetStorageStream()
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStream(m_pHandle, &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CBuildJob::GetStorageStreamUUID - returns the storage stream uuid of the build.
	* @return Stream UUID.
	*/
	std::string CBuildJob::GetStorageStreamUUID()
	{
		LibMCData_uint32 bytesNeededStreamUUID = 0;
		LibMCData_uint32 bytesWrittenStreamUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStreamUUID(m_pHandle, 0, &bytesNeededStreamUUID, nullptr));
		std::vector<char> bufferStreamUUID(bytesNeededStreamUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStreamUUID(m_pHandle, bytesNeededStreamUUID, &bytesWrittenStreamUUID, &bufferStreamUUID[0]));
		
		return std::string(&bufferStreamUUID[0]);
	}
	
	/**
	* CBuildJob::GetBuildJobLogger - creates a build job log session access class.
	* @return LogSession class instance.
	*/
	PLogSession CBuildJob::GetBuildJobLogger()
	{
		LibMCDataHandle hLogSession = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetBuildJobLogger(m_pHandle, &hLogSession));
		
		if (!hLogSession) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogSession>(m_pWrapper, hLogSession);
	}
	
	/**
	* CBuildJob::StartValidating - Starts validation of a build job.
	*/
	void CBuildJob::StartValidating()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_StartValidating(m_pHandle));
	}
	
	/**
	* CBuildJob::FinishValidating - Finishes validation of a build job.
	* @param[in] nLayerCount - Layer count
	*/
	void CBuildJob::FinishValidating(const LibMCData_uint32 nLayerCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_FinishValidating(m_pHandle, nLayerCount));
	}
	
	/**
	* CBuildJob::ArchiveJob - Archives a Job. Job MUST not be opened in the system. Job MUST be of state validated.
	*/
	void CBuildJob::ArchiveJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ArchiveJob(m_pHandle));
	}
	
	/**
	* CBuildJob::UnArchiveJob - Unarchives a Job. Job MUST be of state archived.
	*/
	void CBuildJob::UnArchiveJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_UnArchiveJob(m_pHandle));
	}
	
	/**
	* CBuildJob::DeleteJob - Deletes a Job permanently including all referencing data objects. Job MUST be of state archived to succeed.
	*/
	void CBuildJob::DeleteJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_DeleteJob(m_pHandle));
	}
	
	/**
	* CBuildJob::JobCanBeArchived - Returns if a job is opened.
	* @return returns if the job can be archived.
	*/
	bool CBuildJob::JobCanBeArchived()
	{
		bool resultCanBeArchived = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_JobCanBeArchived(m_pHandle, &resultCanBeArchived));
		
		return resultCanBeArchived;
	}
	
	/**
	* CBuildJob::AddJobData - Adds additional data to the Job. Job MUST be of state validated in order to add job data.
	* @param[in] sIdentifier - Unique identifier for the job data.
	* @param[in] sName - Name of the job data
	* @param[in] pStream - Storage Stream Instance
	* @param[in] eDataType - Datatype of Job data
	* @param[in] sUserID - Currently authenticated user
	*/
	void CBuildJob::AddJobData(const std::string & sIdentifier, const std::string & sName, classParam<CStorageStream> pStream, const eBuildJobDataType eDataType, const std::string & sUserID)
	{
		LibMCDataHandle hStream = pStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_AddJobData(m_pHandle, sIdentifier.c_str(), sName.c_str(), hStream, eDataType, sUserID.c_str()));
	}
	
	/**
	* CBuildJob::ListJobDataByType - Retrieves a list of build job data objects, filtered by type.
	* @param[in] eDataType - Datatype of Job data.
	* @return Build Job Data Iterator Instance.
	*/
	PBuildJobDataIterator CBuildJob::ListJobDataByType(const eBuildJobDataType eDataType)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ListJobDataByType(m_pHandle, eDataType, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJob::ListJobData - Retrieves a list of build job data objects.
	* @return Build Job Data Iterator Instance.
	*/
	PBuildJobDataIterator CBuildJob::ListJobData()
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ListJobData(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJob::RetrieveJobData - Retrieves a build job data instance by its uuid.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Data Instance.
	*/
	PBuildJobData CBuildJob::RetrieveJobData(const std::string & sDataUUID)
	{
		LibMCDataHandle hBuildJobData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_RetrieveJobData(m_pHandle, sDataUUID.c_str(), &hBuildJobData));
		
		if (!hBuildJobData) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobData>(m_pWrapper, hBuildJobData);
	}
	
	/**
	 * Method definitions for class CBuildJobIterator
	 */
	
	/**
	* CBuildJobIterator::GetCurrentJob - Returns the build job the iterator points at.
	* @return returns the build job instance.
	*/
	PBuildJob CBuildJobIterator::GetCurrentJob()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobIterator_GetCurrentJob(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJobHandler
	 */
	
	/**
	* CBuildJobHandler::CreateJob - Creates a new build job.
	* @param[in] sJobUUID - UUID String for the build job. Must be unique and newly generated.
	* @param[in] sName - Name String
	* @param[in] sUserID - Currently authenticated user
	* @param[in] sStorageStreamUUID - Storage stream uuid for the job. Needs not exist yet.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID)
	{
		LibMCDataHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_CreateJob(m_pHandle, sJobUUID.c_str(), sName.c_str(), sUserID.c_str(), sStorageStreamUUID.c_str(), &hJobInstance));
		
		if (!hJobInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hJobInstance);
	}
	
	/**
	* CBuildJobHandler::RetrieveJob - Retrieves a job with a specific UUID.
	* @param[in] sJobUUID - UUID String for the build job. Must be an existing Job.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::RetrieveJob(const std::string & sJobUUID)
	{
		LibMCDataHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_RetrieveJob(m_pHandle, sJobUUID.c_str(), &hJobInstance));
		
		if (!hJobInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hJobInstance);
	}
	
	/**
	* CBuildJobHandler::FindJobOfData - Finds the parent build job of a given data uuid. Fails if data does not exist.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::FindJobOfData(const std::string & sDataUUID)
	{
		LibMCDataHandle hBuildJobData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_FindJobOfData(m_pHandle, sDataUUID.c_str(), &hBuildJobData));
		
		if (!hBuildJobData) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hBuildJobData);
	}
	
	/**
	* CBuildJobHandler::ListJobsByStatus - Retrieves a list of build jobs, filtered by status.
	* @param[in] eStatus - Job Status to list.
	* @return Build Job Iterator Instance.
	*/
	PBuildJobIterator CBuildJobHandler::ListJobsByStatus(const eBuildJobStatus eStatus)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ListJobsByStatus(m_pHandle, eStatus, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJobHandler::ConvertBuildStatusToString - Converts a status enum to a string identifier.
	* @param[in] eStatus - Status Enum.
	* @return String Identifier.
	*/
	std::string CBuildJobHandler::ConvertBuildStatusToString(const eBuildJobStatus eStatus)
	{
		LibMCData_uint32 bytesNeededString = 0;
		LibMCData_uint32 bytesWrittenString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertBuildStatusToString(m_pHandle, eStatus, 0, &bytesNeededString, nullptr));
		std::vector<char> bufferString(bytesNeededString);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertBuildStatusToString(m_pHandle, eStatus, bytesNeededString, &bytesWrittenString, &bufferString[0]));
		
		return std::string(&bufferString[0]);
	}
	
	/**
	* CBuildJobHandler::ConvertStringToBuildStatus - Converts a string identifier to a status enum. Case sensitive. Fails if invalid.
	* @param[in] sString - String Identifier.
	* @return Status Enum.
	*/
	eBuildJobStatus CBuildJobHandler::ConvertStringToBuildStatus(const std::string & sString)
	{
		eBuildJobStatus resultStatus = (eBuildJobStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertStringToBuildStatus(m_pHandle, sString.c_str(), &resultStatus));
		
		return resultStatus;
	}
	
	/**
	 * Method definitions for class CUserList
	 */
	
	/**
	* CUserList::Count - Result Number of Users in the list.
	* @return Number of users in the list
	*/
	LibMCData_uint32 CUserList::Count()
	{
		LibMCData_uint32 resultUserCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserList_Count(m_pHandle, &resultUserCount));
		
		return resultUserCount;
	}
	
	/**
	* CUserList::GetUserProperties - Retrieves all the data of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @param[out] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	void CUserList::GetUserProperties(const LibMCData_uint32 nUserIndex, std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier)
	{
		LibMCData_uint32 bytesNeededUsername = 0;
		LibMCData_uint32 bytesWrittenUsername = 0;
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserList_GetUserProperties(m_pHandle, nUserIndex, 0, &bytesNeededUsername, nullptr, 0, &bytesNeededUUID, nullptr, 0, &bytesNeededDescription, nullptr, 0, &bytesNeededRole, nullptr, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		std::vector<char> bufferUUID(bytesNeededUUID);
		std::vector<char> bufferDescription(bytesNeededDescription);
		std::vector<char> bufferRole(bytesNeededRole);
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_UserList_GetUserProperties(m_pHandle, nUserIndex, bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0], bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0], bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], bytesNeededRole, &bytesWrittenRole, &bufferRole[0], bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		sUsername = std::string(&bufferUsername[0]);
		sUUID = std::string(&bufferUUID[0]);
		sDescription = std::string(&bufferDescription[0]);
		sRole = std::string(&bufferRole[0]);
		sLanguageIdentifier = std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	 * Method definitions for class CLoginHandler
	 */
	
	/**
	* CLoginHandler::UserExists - Checks if a user exist.
	* @param[in] sUsername - User name
	* @return Flag if users exists
	*/
	bool CLoginHandler::UserExists(const std::string & sUsername)
	{
		bool resultUserExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_UserExists(m_pHandle, sUsername.c_str(), &resultUserExists));
		
		return resultUserExists;
	}
	
	/**
	* CLoginHandler::GetUserDetails - Retrieves login relevant users data. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sSalt - Salt of the user.
	* @param[out] sHashedPassword - Hashed Password.
	*/
	void CLoginHandler::GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword)
	{
		LibMCData_uint32 bytesNeededSalt = 0;
		LibMCData_uint32 bytesWrittenSalt = 0;
		LibMCData_uint32 bytesNeededHashedPassword = 0;
		LibMCData_uint32 bytesWrittenHashedPassword = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDetails(m_pHandle, sUsername.c_str(), 0, &bytesNeededSalt, nullptr, 0, &bytesNeededHashedPassword, nullptr));
		std::vector<char> bufferSalt(bytesNeededSalt);
		std::vector<char> bufferHashedPassword(bytesNeededHashedPassword);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDetails(m_pHandle, sUsername.c_str(), bytesNeededSalt, &bytesWrittenSalt, &bufferSalt[0], bytesNeededHashedPassword, &bytesWrittenHashedPassword, &bufferHashedPassword[0]));
		sSalt = std::string(&bufferSalt[0]);
		sHashedPassword = std::string(&bufferHashedPassword[0]);
	}
	
	/**
	* CLoginHandler::GetUserProperties - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	void CLoginHandler::GetUserProperties(const std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier)
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserProperties(m_pHandle, sUsername.c_str(), 0, &bytesNeededUUID, nullptr, 0, &bytesNeededDescription, nullptr, 0, &bytesNeededRole, nullptr, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		std::vector<char> bufferDescription(bytesNeededDescription);
		std::vector<char> bufferRole(bytesNeededRole);
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserProperties(m_pHandle, sUsername.c_str(), bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0], bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], bytesNeededRole, &bytesWrittenRole, &bufferRole[0], bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		sUUID = std::string(&bufferUUID[0]);
		sDescription = std::string(&bufferDescription[0]);
		sRole = std::string(&bufferRole[0]);
		sLanguageIdentifier = std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CLoginHandler::GetUserPropertiesByUUID - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[out] sUsername - User name
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	void CLoginHandler::GetUserPropertiesByUUID(const std::string & sUUID, std::string & sUsername, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier)
	{
		LibMCData_uint32 bytesNeededUsername = 0;
		LibMCData_uint32 bytesWrittenUsername = 0;
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserPropertiesByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededUsername, nullptr, 0, &bytesNeededDescription, nullptr, 0, &bytesNeededRole, nullptr, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		std::vector<char> bufferDescription(bytesNeededDescription);
		std::vector<char> bufferRole(bytesNeededRole);
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserPropertiesByUUID(m_pHandle, sUUID.c_str(), bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0], bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], bytesNeededRole, &bytesWrittenRole, &bufferRole[0], bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		sUsername = std::string(&bufferUsername[0]);
		sDescription = std::string(&bufferDescription[0]);
		sRole = std::string(&bufferRole[0]);
		sLanguageIdentifier = std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CLoginHandler::GetUsernameByUUID - Retrieves a users name with a given UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return User name
	*/
	std::string CLoginHandler::GetUsernameByUUID(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededUsername = 0;
		LibMCData_uint32 bytesWrittenUsername = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUsernameByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededUsername, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUsernameByUUID(m_pHandle, sUUID.c_str(), bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0]));
		
		return std::string(&bufferUsername[0]);
	}
	
	/**
	* CLoginHandler::GetUserUUID - Retrieves a users UUID. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return UUID of the user.
	*/
	std::string CLoginHandler::GetUserUUID(const std::string & sUsername)
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserUUID(m_pHandle, sUsername.c_str(), 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserUUID(m_pHandle, sUsername.c_str(), bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CLoginHandler::GetUserDescription - Retrieves a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Description of the user.
	*/
	std::string CLoginHandler::GetUserDescription(const std::string & sUsername)
	{
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDescription(m_pHandle, sUsername.c_str(), 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDescription(m_pHandle, sUsername.c_str(), bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CLoginHandler::GetUserDescriptionByUUID - Retrieves a users description by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Description of the user.
	*/
	std::string CLoginHandler::GetUserDescriptionByUUID(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDescriptionByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDescriptionByUUID(m_pHandle, sUUID.c_str(), bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CLoginHandler::GetUserRole - Retrieves a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Role of the user.
	*/
	std::string CLoginHandler::GetUserRole(const std::string & sUsername)
	{
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserRole(m_pHandle, sUsername.c_str(), 0, &bytesNeededRole, nullptr));
		std::vector<char> bufferRole(bytesNeededRole);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserRole(m_pHandle, sUsername.c_str(), bytesNeededRole, &bytesWrittenRole, &bufferRole[0]));
		
		return std::string(&bufferRole[0]);
	}
	
	/**
	* CLoginHandler::GetUserRoleByUUID - Retrieves a users role by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Role of the user.
	*/
	std::string CLoginHandler::GetUserRoleByUUID(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserRoleByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededRole, nullptr));
		std::vector<char> bufferRole(bytesNeededRole);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserRoleByUUID(m_pHandle, sUUID.c_str(), bytesNeededRole, &bytesWrittenRole, &bufferRole[0]));
		
		return std::string(&bufferRole[0]);
	}
	
	/**
	* CLoginHandler::GetUserLanguage - Retrieves a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Language identifier of the user.
	*/
	std::string CLoginHandler::GetUserLanguage(const std::string & sUsername)
	{
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserLanguage(m_pHandle, sUsername.c_str(), 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserLanguage(m_pHandle, sUsername.c_str(), bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		
		return std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CLoginHandler::GetUserLanguageByUUID - Retrieves a users language preference by user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Language identifier of the user.
	*/
	std::string CLoginHandler::GetUserLanguageByUUID(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserLanguageByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserLanguageByUUID(m_pHandle, sUUID.c_str(), bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		
		return std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CLoginHandler::CreateUser - Creates a new user. Fails if the user already exists.
	* @param[in] sUsername - User name to create. MUST be alphanumeric and not empty.
	* @param[in] sRole - Role of the new user. MUST NOT be empty.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	* @param[in] sDescription - Description of the new user.
	* @return UUID of the new user.
	*/
	std::string CLoginHandler::CreateUser(const std::string & sUsername, const std::string & sRole, const std::string & sSalt, const std::string & sHashedPassword, const std::string & sDescription)
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_CreateUser(m_pHandle, sUsername.c_str(), sRole.c_str(), sSalt.c_str(), sHashedPassword.c_str(), sDescription.c_str(), 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_CreateUser(m_pHandle, sUsername.c_str(), sRole.c_str(), sSalt.c_str(), sHashedPassword.c_str(), sDescription.c_str(), bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CLoginHandler::SetUserLanguage - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	void CLoginHandler::SetUserLanguage(const std::string & sUsername, const std::string & sLanguageIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserLanguage(m_pHandle, sUsername.c_str(), sLanguageIdentifier.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserRole - Updates a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sRole - New Role identifier of the user.
	*/
	void CLoginHandler::SetUserRole(const std::string & sUsername, const std::string & sRole)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserRole(m_pHandle, sUsername.c_str(), sRole.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserDescription - Updates a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sDescription - New Description of the user.
	*/
	void CLoginHandler::SetUserDescription(const std::string & sUsername, const std::string & sDescription)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserDescription(m_pHandle, sUsername.c_str(), sDescription.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserPassword - Updates a users password. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	void CLoginHandler::SetUserPassword(const std::string & sUsername, const std::string & sSalt, const std::string & sHashedPassword)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserPassword(m_pHandle, sUsername.c_str(), sSalt.c_str(), sHashedPassword.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserLanguageByUUID - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	void CLoginHandler::SetUserLanguageByUUID(const std::string & sUUID, const std::string & sLanguageIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserLanguageByUUID(m_pHandle, sUUID.c_str(), sLanguageIdentifier.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserRoleByUUID - Updates a users role. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sRole - New Role identifier of the user.
	*/
	void CLoginHandler::SetUserRoleByUUID(const std::string & sUUID, const std::string & sRole)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserRoleByUUID(m_pHandle, sUUID.c_str(), sRole.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserDescriptionByUUID - Updates a users description. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sDescription - New Language identifier of the user.
	*/
	void CLoginHandler::SetUserDescriptionByUUID(const std::string & sUUID, const std::string & sDescription)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserDescriptionByUUID(m_pHandle, sUUID.c_str(), sDescription.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserPasswordByUUID - Updates a users password. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	void CLoginHandler::SetUserPasswordByUUID(const std::string & sUUID, const std::string & sSalt, const std::string & sHashedPassword)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserPasswordByUUID(m_pHandle, sUUID.c_str(), sSalt.c_str(), sHashedPassword.c_str()));
	}
	
	/**
	* CLoginHandler::GetActiveUsers - Returns a list of active users.
	* @return New instance of active users.
	*/
	PUserList CLoginHandler::GetActiveUsers()
	{
		LibMCDataHandle hActiveUsers = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetActiveUsers(m_pHandle, &hActiveUsers));
		
		if (!hActiveUsers) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CUserList>(m_pWrapper, hActiveUsers);
	}
	
	/**
	 * Method definitions for class CPersistencyHandler
	 */
	
	/**
	* CPersistencyHandler::HasPersistentParameter - Retrieves if a persistent parameter has been stored.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter exists.
	*/
	bool CPersistencyHandler::HasPersistentParameter(const std::string & sUUID)
	{
		bool resultParameterExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_HasPersistentParameter(m_pHandle, sUUID.c_str(), &resultParameterExists));
		
		return resultParameterExists;
	}
	
	/**
	* CPersistencyHandler::GetPersistentParameterDetails - Retrieves details of a persistent parameter. Fails if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @param[out] sName - Returns name of the parameter
	* @param[out] eDataType - Returns data type of the parameter
	*/
	void CPersistencyHandler::GetPersistentParameterDetails(const std::string & sUUID, std::string & sName, eParameterDataType & eDataType)
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_GetPersistentParameterDetails(m_pHandle, sUUID.c_str(), 0, &bytesNeededName, nullptr, &eDataType));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_GetPersistentParameterDetails(m_pHandle, sUUID.c_str(), bytesNeededName, &bytesWrittenName, &bufferName[0], &eDataType));
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* CPersistencyHandler::DeletePersistentParameter - Removes a persistent parameter from database. Does nothing if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter existed.
	*/
	bool CPersistencyHandler::DeletePersistentParameter(const std::string & sUUID)
	{
		bool resultParameterExisted = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_DeletePersistentParameter(m_pHandle, sUUID.c_str(), &resultParameterExisted));
		
		return resultParameterExisted;
	}
	
	/**
	* CPersistencyHandler::StorePersistentParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] eDataType - Data type of the parameter. If parameter exists, MUST be the same as the stored parameter data type.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	*/
	void CPersistencyHandler::StorePersistentParameter(const std::string & sUUID, const std::string & sName, const eParameterDataType eDataType, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentParameter(m_pHandle, sUUID.c_str(), sName.c_str(), eDataType, sValue.c_str()));
	}
	
	/**
	* CPersistencyHandler::StorePersistentStringParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter.
	*/
	void CPersistencyHandler::StorePersistentStringParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentStringParameter(m_pHandle, sUUID.c_str(), sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CPersistencyHandler::StorePersistentUUIDParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	*/
	void CPersistencyHandler::StorePersistentUUIDParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentUUIDParameter(m_pHandle, sUUID.c_str(), sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CPersistencyHandler::StorePersistentDoubleParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] dValue - Value of the parameter.
	*/
	void CPersistencyHandler::StorePersistentDoubleParameter(const std::string & sUUID, const std::string & sName, const LibMCData_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentDoubleParameter(m_pHandle, sUUID.c_str(), sName.c_str(), dValue));
	}
	
	/**
	* CPersistencyHandler::StorePersistentIntegerParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] nValue - Value of the parameter.
	*/
	void CPersistencyHandler::StorePersistentIntegerParameter(const std::string & sUUID, const std::string & sName, const LibMCData_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentIntegerParameter(m_pHandle, sUUID.c_str(), sName.c_str(), nValue));
	}
	
	/**
	* CPersistencyHandler::StorePersistentBoolParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] bValue - Value of the parameter.
	*/
	void CPersistencyHandler::StorePersistentBoolParameter(const std::string & sUUID, const std::string & sName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentBoolParameter(m_pHandle, sUUID.c_str(), sName.c_str(), bValue));
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentStringParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	std::string CPersistencyHandler::RetrievePersistentStringParameter(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededValue = 0;
		LibMCData_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentStringParameter(m_pHandle, sUUID.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentStringParameter(m_pHandle, sUUID.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentUUIDParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	std::string CPersistencyHandler::RetrievePersistentUUIDParameter(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededValue = 0;
		LibMCData_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentUUIDParameter(m_pHandle, sUUID.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentUUIDParameter(m_pHandle, sUUID.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentDoubleParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	LibMCData_double CPersistencyHandler::RetrievePersistentDoubleParameter(const std::string & sUUID)
	{
		LibMCData_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentDoubleParameter(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentIntegerParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	LibMCData_int64 CPersistencyHandler::RetrievePersistentIntegerParameter(const std::string & sUUID)
	{
		LibMCData_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentIntegerParameter(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentBoolParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	bool CPersistencyHandler::RetrievePersistentBoolParameter(const std::string & sUUID)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentBoolParameter(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	 * Method definitions for class CDataModel
	 */
	
	/**
	* CDataModel::InitialiseDatabase - initializes the database connection.
	* @param[in] sDataDirectory - Directory that stores the data.
	* @param[in] eDataBaseType - Type of database.
	* @param[in] sConnectionString - Connection string.
	*/
	void CDataModel::InitialiseDatabase(const std::string & sDataDirectory, const eDataBaseType eDataBaseType, const std::string & sConnectionString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_InitialiseDatabase(m_pHandle, sDataDirectory.c_str(), eDataBaseType, sConnectionString.c_str()));
	}
	
	/**
	* CDataModel::GetDataModelVersion - returns the linear data model version.
	* @return Data model version.
	*/
	LibMCData_uint32 CDataModel::GetDataModelVersion()
	{
		LibMCData_uint32 resultVersion = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetDataModelVersion(m_pHandle, &resultVersion));
		
		return resultVersion;
	}
	
	/**
	* CDataModel::GetInstallationInformation - returns unique identifiers for the current installation.
	* @param[out] sInstallationUUID - Installation UUID. Public value to document which installation was used for something.
	* @param[out] sInstallationSecret - Secret SHA256 key for seeding external-facing pseudo-randomness. MUST NOT be given outside of the application.
	*/
	void CDataModel::GetInstallationInformation(std::string & sInstallationUUID, std::string & sInstallationSecret)
	{
		LibMCData_uint32 bytesNeededInstallationUUID = 0;
		LibMCData_uint32 bytesWrittenInstallationUUID = 0;
		LibMCData_uint32 bytesNeededInstallationSecret = 0;
		LibMCData_uint32 bytesWrittenInstallationSecret = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetInstallationInformation(m_pHandle, 0, &bytesNeededInstallationUUID, nullptr, 0, &bytesNeededInstallationSecret, nullptr));
		std::vector<char> bufferInstallationUUID(bytesNeededInstallationUUID);
		std::vector<char> bufferInstallationSecret(bytesNeededInstallationSecret);
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetInstallationInformation(m_pHandle, bytesNeededInstallationUUID, &bytesWrittenInstallationUUID, &bufferInstallationUUID[0], bytesNeededInstallationSecret, &bytesWrittenInstallationSecret, &bufferInstallationSecret[0]));
		sInstallationUUID = std::string(&bufferInstallationUUID[0]);
		sInstallationSecret = std::string(&bufferInstallationSecret[0]);
	}
	
	/**
	* CDataModel::CreateStorage - creates a storage access class.
	* @return Storage class instance.
	*/
	PStorage CDataModel::CreateStorage()
	{
		LibMCDataHandle hStorage = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateStorage(m_pHandle, &hStorage));
		
		if (!hStorage) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorage>(m_pWrapper, hStorage);
	}
	
	/**
	* CDataModel::CreateBuildJobHandler - creates a build job access class.
	* @return BuildJobHandler class instance.
	*/
	PBuildJobHandler CDataModel::CreateBuildJobHandler()
	{
		LibMCDataHandle hBuildJobHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateBuildJobHandler(m_pHandle, &hBuildJobHandler));
		
		if (!hBuildJobHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobHandler>(m_pWrapper, hBuildJobHandler);
	}
	
	/**
	* CDataModel::CreateNewLogSession - creates a global log session access class.
	* @return LogSession class instance.
	*/
	PLogSession CDataModel::CreateNewLogSession()
	{
		LibMCDataHandle hLogSession = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateNewLogSession(m_pHandle, &hLogSession));
		
		if (!hLogSession) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogSession>(m_pWrapper, hLogSession);
	}
	
	/**
	* CDataModel::CreateLoginHandler - creates a login handler instance.
	* @return LoginHandler instance.
	*/
	PLoginHandler CDataModel::CreateLoginHandler()
	{
		LibMCDataHandle hLoginHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateLoginHandler(m_pHandle, &hLoginHandler));
		
		if (!hLoginHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLoginHandler>(m_pWrapper, hLoginHandler);
	}
	
	/**
	* CDataModel::CreatePersistencyHandler - creates a persistency handler instance.
	* @return PersistencyHandler instance.
	*/
	PPersistencyHandler CDataModel::CreatePersistencyHandler()
	{
		LibMCDataHandle hPersistencyHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreatePersistencyHandler(m_pHandle, &hPersistencyHandler));
		
		if (!hPersistencyHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPersistencyHandler>(m_pWrapper, hPersistencyHandler);
	}
	
	/**
	* CDataModel::SetBaseTempDirectory - Sets a custom base temp directory. An empty string defaults to the system temp directory.
	* @param[in] sTempDirectory - Temp directory path to use. SHOULD be an absolute path, if not empty. Directory MUST exist, if not empty.
	*/
	void CDataModel::SetBaseTempDirectory(const std::string & sTempDirectory)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_SetBaseTempDirectory(m_pHandle, sTempDirectory.c_str()));
	}
	
	/**
	* CDataModel::GetBaseTempDirectory - Returns a custom base temp directory. An empty string defaults to the system temp directory.
	* @return Temp directory path.
	*/
	std::string CDataModel::GetBaseTempDirectory()
	{
		LibMCData_uint32 bytesNeededTempDirectory = 0;
		LibMCData_uint32 bytesWrittenTempDirectory = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetBaseTempDirectory(m_pHandle, 0, &bytesNeededTempDirectory, nullptr));
		std::vector<char> bufferTempDirectory(bytesNeededTempDirectory);
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetBaseTempDirectory(m_pHandle, bytesNeededTempDirectory, &bytesWrittenTempDirectory, &bufferTempDirectory[0]));
		
		return std::string(&bufferTempDirectory[0]);
	}
	
	/**
	* CDataModel::SetLogCallback - Sets a log callback to be used for the execution.
	* @param[in] pLogCallback - LogCallback.
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CDataModel::SetLogCallback(const LogCallback pLogCallback, const LibMCData_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_SetLogCallback(m_pHandle, pLogCallback, pUserData));
	}
	
	/**
	* CDataModel::ClearLogCallback - Resets the log callback to be used for the execution.
	*/
	void CDataModel::ClearLogCallback()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_ClearLogCallback(m_pHandle));
	}
	
	/**
	* CDataModel::HasLogCallback - Returns if a log callback has been set.
	* @return Flag if log callback has been set.
	*/
	bool CDataModel::HasLogCallback()
	{
		bool resultHasCallback = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_HasLogCallback(m_pHandle, &resultHasCallback));
		
		return resultHasCallback;
	}
	
	/**
	* CDataModel::TriggerLogCallback - Triggers the log callback. Fails if no log callback has been set.
	* @param[in] sLogMessage - Log message to be logged.
	* @param[in] sSubSystem - SubSystem of Log Message.
	* @param[in] eLogLevel - Log Level to be used.
	* @param[in] sTimestamp - Timestamp of the log message.
	*/
	void CDataModel::TriggerLogCallback(const std::string & sLogMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_TriggerLogCallback(m_pHandle, sLogMessage.c_str(), sSubSystem.c_str(), eLogLevel, sTimestamp.c_str()));
	}

} // namespace LibMCData

#endif // __LIBMCDATA_CPPHEADER_DYNAMIC_CPP

