/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Machine Control data model library

Interface version: 1.0.0

*/

#ifndef __LIBMCDATA_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDATA_CPPHEADER_DYNAMIC_CPP

#include "libmcdata_types.hpp"
#include "libmcdata_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCData {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CIterator;
class CLogEntryList;
class CLogSession;
class CAlert;
class CAlertIterator;
class CAlertSession;
class CJournalSession;
class CStorageStream;
class CStorageZIPWriter;
class CStorage;
class CCustomDataStream;
class CBuildJobData;
class CBuildJobDataIterator;
class CBuildJobExecutionData;
class CBuildJobExecutionDataIterator;
class CBuildJobExecution;
class CBuildJobExecutionIterator;
class CBuildJob;
class CBuildJobIterator;
class CBuildJobHandler;
class CUserList;
class CLoginHandler;
class CPersistencyHandler;
class CInstallationInformation;
class CDataModel;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDataWrapper;
typedef CBase CLibMCDataBase;
typedef CIterator CLibMCDataIterator;
typedef CLogEntryList CLibMCDataLogEntryList;
typedef CLogSession CLibMCDataLogSession;
typedef CAlert CLibMCDataAlert;
typedef CAlertIterator CLibMCDataAlertIterator;
typedef CAlertSession CLibMCDataAlertSession;
typedef CJournalSession CLibMCDataJournalSession;
typedef CStorageStream CLibMCDataStorageStream;
typedef CStorageZIPWriter CLibMCDataStorageZIPWriter;
typedef CStorage CLibMCDataStorage;
typedef CCustomDataStream CLibMCDataCustomDataStream;
typedef CBuildJobData CLibMCDataBuildJobData;
typedef CBuildJobDataIterator CLibMCDataBuildJobDataIterator;
typedef CBuildJobExecutionData CLibMCDataBuildJobExecutionData;
typedef CBuildJobExecutionDataIterator CLibMCDataBuildJobExecutionDataIterator;
typedef CBuildJobExecution CLibMCDataBuildJobExecution;
typedef CBuildJobExecutionIterator CLibMCDataBuildJobExecutionIterator;
typedef CBuildJob CLibMCDataBuildJob;
typedef CBuildJobIterator CLibMCDataBuildJobIterator;
typedef CBuildJobHandler CLibMCDataBuildJobHandler;
typedef CUserList CLibMCDataUserList;
typedef CLoginHandler CLibMCDataLoginHandler;
typedef CPersistencyHandler CLibMCDataPersistencyHandler;
typedef CInstallationInformation CLibMCDataInstallationInformation;
typedef CDataModel CLibMCDataDataModel;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CIterator> PIterator;
typedef std::shared_ptr<CLogEntryList> PLogEntryList;
typedef std::shared_ptr<CLogSession> PLogSession;
typedef std::shared_ptr<CAlert> PAlert;
typedef std::shared_ptr<CAlertIterator> PAlertIterator;
typedef std::shared_ptr<CAlertSession> PAlertSession;
typedef std::shared_ptr<CJournalSession> PJournalSession;
typedef std::shared_ptr<CStorageStream> PStorageStream;
typedef std::shared_ptr<CStorageZIPWriter> PStorageZIPWriter;
typedef std::shared_ptr<CStorage> PStorage;
typedef std::shared_ptr<CCustomDataStream> PCustomDataStream;
typedef std::shared_ptr<CBuildJobData> PBuildJobData;
typedef std::shared_ptr<CBuildJobDataIterator> PBuildJobDataIterator;
typedef std::shared_ptr<CBuildJobExecutionData> PBuildJobExecutionData;
typedef std::shared_ptr<CBuildJobExecutionDataIterator> PBuildJobExecutionDataIterator;
typedef std::shared_ptr<CBuildJobExecution> PBuildJobExecution;
typedef std::shared_ptr<CBuildJobExecutionIterator> PBuildJobExecutionIterator;
typedef std::shared_ptr<CBuildJob> PBuildJob;
typedef std::shared_ptr<CBuildJobIterator> PBuildJobIterator;
typedef std::shared_ptr<CBuildJobHandler> PBuildJobHandler;
typedef std::shared_ptr<CUserList> PUserList;
typedef std::shared_ptr<CLoginHandler> PLoginHandler;
typedef std::shared_ptr<CPersistencyHandler> PPersistencyHandler;
typedef std::shared_ptr<CInstallationInformation> PInstallationInformation;
typedef std::shared_ptr<CDataModel> PDataModel;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDataWrapper;
typedef PBase PLibMCDataBase;
typedef PIterator PLibMCDataIterator;
typedef PLogEntryList PLibMCDataLogEntryList;
typedef PLogSession PLibMCDataLogSession;
typedef PAlert PLibMCDataAlert;
typedef PAlertIterator PLibMCDataAlertIterator;
typedef PAlertSession PLibMCDataAlertSession;
typedef PJournalSession PLibMCDataJournalSession;
typedef PStorageStream PLibMCDataStorageStream;
typedef PStorageZIPWriter PLibMCDataStorageZIPWriter;
typedef PStorage PLibMCDataStorage;
typedef PCustomDataStream PLibMCDataCustomDataStream;
typedef PBuildJobData PLibMCDataBuildJobData;
typedef PBuildJobDataIterator PLibMCDataBuildJobDataIterator;
typedef PBuildJobExecutionData PLibMCDataBuildJobExecutionData;
typedef PBuildJobExecutionDataIterator PLibMCDataBuildJobExecutionDataIterator;
typedef PBuildJobExecution PLibMCDataBuildJobExecution;
typedef PBuildJobExecutionIterator PLibMCDataBuildJobExecutionIterator;
typedef PBuildJob PLibMCDataBuildJob;
typedef PBuildJobIterator PLibMCDataBuildJobIterator;
typedef PBuildJobHandler PLibMCDataBuildJobHandler;
typedef PUserList PLibMCDataUserList;
typedef PLoginHandler PLibMCDataLoginHandler;
typedef PPersistencyHandler PLibMCDataPersistencyHandler;
typedef PInstallationInformation PLibMCDataInstallationInformation;
typedef PDataModel PLibMCDataDataModel;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDataHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDataException 
**************************************************************************************************************************/
class ELibMCDataException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDataResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDataException(LibMCDataResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCDataResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDATA_SUCCESS: return "SUCCESS";
			case LIBMCDATA_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMCDATA_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMCDATA_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMCDATA_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMCDATA_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMCDATA_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMCDATA_ERROR_COULDNOTPARSECONFIGURATION: return "COULDNOTPARSECONFIGURATION";
			case LIBMCDATA_ERROR_DUPLICATESTATENAME: return "DUPLICATESTATENAME";
			case LIBMCDATA_ERROR_STATENOTFOUND: return "STATENOTFOUND";
			case LIBMCDATA_ERROR_DUPLICATEOUTSTATE: return "DUPLICATEOUTSTATE";
			case LIBMCDATA_ERROR_MISSINGMACHINEDEFINITION: return "MISSINGMACHINEDEFINITION";
			case LIBMCDATA_ERROR_MISSINGINSTANCENAME: return "MISSINGINSTANCENAME";
			case LIBMCDATA_ERROR_DUPLICATEMACHINEINSTANCE: return "DUPLICATEMACHINEINSTANCE";
			case LIBMCDATA_ERROR_MISSINGXMLSCHEMA: return "MISSINGXMLSCHEMA";
			case LIBMCDATA_ERROR_INVALIDXMLSCHEMA: return "INVALIDXMLSCHEMA";
			case LIBMCDATA_ERROR_MISSINGSTATENAME: return "MISSINGSTATENAME";
			case LIBMCDATA_ERROR_MISSINGOUTSTATETARGET: return "MISSINGOUTSTATETARGET";
			case LIBMCDATA_ERROR_INVALIDOUTSTATETARGET: return "INVALIDOUTSTATETARGET";
			case LIBMCDATA_ERROR_NOINITSTATE: return "NOINITSTATE";
			case LIBMCDATA_ERROR_NOFAILEDSTATE: return "NOFAILEDSTATE";
			case LIBMCDATA_ERROR_INITSTATENOTFOUND: return "INITSTATENOTFOUND";
			case LIBMCDATA_ERROR_FAILEDSTATENOTFOUND: return "FAILEDSTATENOTFOUND";
			case LIBMCDATA_ERROR_MISSINGINITSTATE: return "MISSINGINITSTATE";
			case LIBMCDATA_ERROR_MISSINGFAILEDSTATE: return "MISSINGFAILEDSTATE";
			case LIBMCDATA_ERROR_MISSINGPLUGINNAME: return "MISSINGPLUGINNAME";
			case LIBMCDATA_ERROR_EMPTYINITSTATE: return "EMPTYINITSTATE";
			case LIBMCDATA_ERROR_EMPTYFAILEDSTATE: return "EMPTYFAILEDSTATE";
			case LIBMCDATA_ERROR_EMPTYPLUGINNAME: return "EMPTYPLUGINNAME";
			case LIBMCDATA_ERROR_COULDNOTCREATESTATEFACTORY: return "COULDNOTCREATESTATEFACTORY";
			case LIBMCDATA_ERROR_INVALIDSTATENAME: return "INVALIDSTATENAME";
			case LIBMCDATA_ERROR_COULDNOTCREATESTATE: return "COULDNOTCREATESTATE";
			case LIBMCDATA_ERROR_COULDNOTINITIALIZEFACTORY: return "COULDNOTINITIALIZEFACTORY";
			case LIBMCDATA_ERROR_COULDNOTFINALIZEFACTORY: return "COULDNOTFINALIZEFACTORY";
			case LIBMCDATA_ERROR_COULDNOTLOADPLUGIN: return "COULDNOTLOADPLUGIN";
			case LIBMCDATA_ERROR_NOCURRENTSTATE: return "NOCURRENTSTATE";
			case LIBMCDATA_ERROR_NOPLUGINSTATE: return "NOPLUGINSTATE";
			case LIBMCDATA_ERROR_COULDNOTEXECUTEPLUGIN: return "COULDNOTEXECUTEPLUGIN";
			case LIBMCDATA_ERROR_TOOMANYMACHINEINSTANCES: return "TOOMANYMACHINEINSTANCES";
			case LIBMCDATA_ERROR_INVALIDINDEX: return "INVALIDINDEX";
			case LIBMCDATA_ERROR_NOOUTSTATEGIVEN: return "NOOUTSTATEGIVEN";
			case LIBMCDATA_ERROR_INVALIDOUTSTATEGIVEN: return "INVALIDOUTSTATEGIVEN";
			case LIBMCDATA_ERROR_INVALIDREPEATDELAY: return "INVALIDREPEATDELAY";
			case LIBMCDATA_ERROR_INVALIDEXECUTIONDELAY: return "INVALIDEXECUTIONDELAY";
			case LIBMCDATA_ERROR_MISSINGREPEATDELAY: return "MISSINGREPEATDELAY";
			case LIBMCDATA_ERROR_THREADISRUNNING: return "THREADISRUNNING";
			case LIBMCDATA_ERROR_THREADISNOTRUNNING: return "THREADISNOTRUNNING";
			case LIBMCDATA_ERROR_DUPLICATESIGNAL: return "DUPLICATESIGNAL";
			case LIBMCDATA_ERROR_INVALIDSIGNALNAME: return "INVALIDSIGNALNAME";
			case LIBMCDATA_ERROR_MISSINGSIGNALNAME: return "MISSINGSIGNALNAME";
			case LIBMCDATA_ERROR_MISSINGSERVERNODE: return "MISSINGSERVERNODE";
			case LIBMCDATA_ERROR_MISSINGHOSTNAME: return "MISSINGHOSTNAME";
			case LIBMCDATA_ERROR_MISSINGPORT: return "MISSINGPORT";
			case LIBMCDATA_ERROR_UUIDGENERATIONFAILED: return "UUIDGENERATIONFAILED";
			case LIBMCDATA_ERROR_INVALIDBUFFERSIZE: return "INVALIDBUFFERSIZE";
			case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF8: return "COULDNOTCONVERTTOUTF8";
			case LIBMCDATA_ERROR_NOCOLUMNAVAILABLE: return "NOCOLUMNAVAILABLE";
			case LIBMCDATA_ERROR_INVALIDTEXTCOLUMN: return "INVALIDTEXTCOLUMN";
			case LIBMCDATA_ERROR_INVALIDCOLUMNTYPE: return "INVALIDCOLUMNTYPE";
			case LIBMCDATA_ERROR_TOOMANYREQUESTEDLOGS: return "TOOMANYREQUESTEDLOGS";
			case LIBMCDATA_ERROR_MISSINGINSTANCEDESCRIPTION: return "MISSINGINSTANCEDESCRIPTION";
			case LIBMCDATA_ERROR_DUPLICATEPARAMETERGROUPNAME: return "DUPLICATEPARAMETERGROUPNAME";
			case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPNAME: return "MISSINGPARAMETERGROUPNAME";
			case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPNAME: return "EMPTYPARAMETERGROUPNAME";
			case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPDESCRIPTION: return "MISSINGPARAMETERGROUPDESCRIPTION";
			case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPDESCRIPTION: return "EMPTYPARAMETERGROUPDESCRIPTION";
			case LIBMCDATA_ERROR_TOOMANYPARAMETERS: return "TOOMANYPARAMETERS";
			case LIBMCDATA_ERROR_TOOMANYPARAMETERGROUPS: return "TOOMANYPARAMETERGROUPS";
			case LIBMCDATA_ERROR_DUPLICATEPARAMETERNAME: return "DUPLICATEPARAMETERNAME";
			case LIBMCDATA_ERROR_MISSINGPARAMETERNAME: return "MISSINGPARAMETERNAME";
			case LIBMCDATA_ERROR_EMPTYPARAMETERNAME: return "EMPTYPARAMETERNAME";
			case LIBMCDATA_ERROR_MISSINGPARAMETERDESCRIPTION: return "MISSINGPARAMETERDESCRIPTION";
			case LIBMCDATA_ERROR_EMPTYPARAMETERDESCRIPTION: return "EMPTYPARAMETERDESCRIPTION";
			case LIBMCDATA_ERROR_PARAMETERNOTFOUND: return "PARAMETERNOTFOUND";
			case LIBMCDATA_ERROR_MISSINGPARAMETERDEFAULTVALUE: return "MISSINGPARAMETERDEFAULTVALUE";
			case LIBMCDATA_ERROR_MISSINGDATACONFIGNODE: return "MISSINGDATACONFIGNODE";
			case LIBMCDATA_ERROR_MISSINGDIRECTORY: return "MISSINGDIRECTORY";
			case LIBMCDATA_ERROR_MISSINGDATABASETYPE: return "MISSINGDATABASETYPE";
			case LIBMCDATA_ERROR_MISSINGSQLITEINFO: return "MISSINGSQLITEINFO";
			case LIBMCDATA_ERROR_UNKNOWNDATABASETYPE: return "UNKNOWNDATABASETYPE";
			case LIBMCDATA_ERROR_STORAGENOTINITIALISED: return "STORAGENOTINITIALISED";
			case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF16: return "COULDNOTCONVERTTOUTF16";
			case LIBMCDATA_ERROR_COULDNOTCREATEFILE: return "COULDNOTCREATEFILE";
			case LIBMCDATA_ERROR_COULDNOTSEEKSTREAM: return "COULDNOTSEEKSTREAM";
			case LIBMCDATA_ERROR_COULDNOTGETSTREAMPOSITION: return "COULDNOTGETSTREAMPOSITION";
			case LIBMCDATA_ERROR_COULDNOTWRITESTREAM: return "COULDNOTWRITESTREAM";
			case LIBMCDATA_ERROR_INVALIDDATABASEMIGRATION: return "INVALIDDATABASEMIGRATION";
			case LIBMCDATA_ERROR_INTERNALERROR: return "INTERNALERROR";
			case LIBMCDATA_ERROR_COULDNOTSTORECONTENTSTREAM: return "COULDNOTSTORECONTENTSTREAM";
			case LIBMCDATA_ERROR_DATABASENOTINITIALISED: return "DATABASENOTINITIALISED";
			case LIBMCDATA_ERROR_PARAMETERGROUPNOTFOUND: return "PARAMETERGROUPNOTFOUND";
			case LIBMCDATA_ERROR_SIGNALNOTFOUND: return "SIGNALNOTFOUND";
			case LIBMCDATA_ERROR_STATEMACHINENOTFOUND: return "STATEMACHINENOTFOUND";
			case LIBMCDATA_ERROR_MISSINGPARAMETERTYPE: return "MISSINGPARAMETERTYPE";
			case LIBMCDATA_ERROR_INVALIDPARAMETERTYPE: return "INVALIDPARAMETERTYPE";
			case LIBMCDATA_ERROR_COULDNOTPARSEJSON: return "COULDNOTPARSEJSON";
			case LIBMCDATA_ERROR_INVALIDJSONFORMAT: return "INVALIDJSONFORMAT";
			case LIBMCDATA_ERROR_URLNOTFOUND: return "URLNOTFOUND";
			case LIBMCDATA_ERROR_GENERICBADREQUEST: return "GENERICBADREQUEST";
			case LIBMCDATA_ERROR_SQLITE_ERROR: return "SQLITE_ERROR";
			case LIBMCDATA_ERROR_SQLITE_INTERNAL: return "SQLITE_INTERNAL";
			case LIBMCDATA_ERROR_SQLITE_PERM: return "SQLITE_PERM";
			case LIBMCDATA_ERROR_SQLITE_ABORT: return "SQLITE_ABORT";
			case LIBMCDATA_ERROR_SQLITE_BUSY: return "SQLITE_BUSY";
			case LIBMCDATA_ERROR_SQLITE_LOCKED: return "SQLITE_LOCKED";
			case LIBMCDATA_ERROR_SQLITE_NOMEM: return "SQLITE_NOMEM";
			case LIBMCDATA_ERROR_SQLITE_READONLY: return "SQLITE_READONLY";
			case LIBMCDATA_ERROR_SQLITE_INTERRUPT: return "SQLITE_INTERRUPT";
			case LIBMCDATA_ERROR_SQLITE_IOERR: return "SQLITE_IOERR";
			case LIBMCDATA_ERROR_SQLITE_CORRUPT: return "SQLITE_CORRUPT";
			case LIBMCDATA_ERROR_SQLITE_NOTFOUND: return "SQLITE_NOTFOUND";
			case LIBMCDATA_ERROR_SQLITE_FULL: return "SQLITE_FULL";
			case LIBMCDATA_ERROR_SQLITE_CANTOPEN: return "SQLITE_CANTOPEN";
			case LIBMCDATA_ERROR_SQLITE_PROTOCOL: return "SQLITE_PROTOCOL";
			case LIBMCDATA_ERROR_SQLITE_SCHEMA: return "SQLITE_SCHEMA";
			case LIBMCDATA_ERROR_SQLITE_TOOBIG: return "SQLITE_TOOBIG";
			case LIBMCDATA_ERROR_SQLITE_CONSTRAINT: return "SQLITE_CONSTRAINT";
			case LIBMCDATA_ERROR_SQLITE_MISMATCH: return "SQLITE_MISMATCH";
			case LIBMCDATA_ERROR_SQLITE_MISUSE: return "SQLITE_MISUSE";
			case LIBMCDATA_ERROR_SQLITE_NOLFS: return "SQLITE_NOLFS";
			case LIBMCDATA_ERROR_SQLITE_AUTH: return "SQLITE_AUTH";
			case LIBMCDATA_ERROR_SQLITE_RANGE: return "SQLITE_RANGE";
			case LIBMCDATA_ERROR_SQLITE_NOTADB: return "SQLITE_NOTADB";
			case LIBMCDATA_ERROR_SQLITE_NOTICE: return "SQLITE_NOTICE";
			case LIBMCDATA_ERROR_SQLITE_WARNING: return "SQLITE_WARNING";
			case LIBMCDATA_ERROR_SQLITE_OTHER: return "SQLITE_OTHER";
			case LIBMCDATA_ERROR_SQLITE_TOOMANYRESULTROWS: return "SQLITE_TOOMANYRESULTROWS";
			case LIBMCDATA_ERROR_COULDNOTREADZIPFILE: return "COULDNOTREADZIPFILE";
			case LIBMCDATA_ERROR_COULDNOTOPENZIPFILE: return "COULDNOTOPENZIPFILE";
			case LIBMCDATA_ERROR_COULDNOTGETZIPENTRIES: return "COULDNOTGETZIPENTRIES";
			case LIBMCDATA_ERROR_ZIPENTRYNOTFOUND: return "ZIPENTRYNOTFOUND";
			case LIBMCDATA_ERROR_COULDNOTSTATZIPENTRY: return "COULDNOTSTATZIPENTRY";
			case LIBMCDATA_ERROR_COULDNOTOPENZIPENTRY: return "COULDNOTOPENZIPENTRY";
			case LIBMCDATA_ERROR_COULDNOTREADZIPSTREAM: return "COULDNOTREADZIPSTREAM";
			case LIBMCDATA_ERROR_COULDNOTREADFULLZIPDATA: return "COULDNOTREADFULLZIPDATA";
			case LIBMCDATA_ERROR_COULDNOTFINDRESOURCEINDEX: return "COULDNOTFINDRESOURCEINDEX";
			case LIBMCDATA_ERROR_COULDNOTPARSERESOURCEINDEX: return "COULDNOTPARSERESOURCEINDEX";
			case LIBMCDATA_ERROR_EMPTYRESOURCEINDEX: return "EMPTYRESOURCEINDEX";
			case LIBMCDATA_ERROR_MISSINGRESOURCEINDEX: return "MISSINGRESOURCEINDEX";
			case LIBMCDATA_ERROR_MISSINGRESOURCENAME: return "MISSINGRESOURCENAME";
			case LIBMCDATA_ERROR_MISSINGRESOURCEFILENAME: return "MISSINGRESOURCEFILENAME";
			case LIBMCDATA_ERROR_MISSINGRESOURCESIZE: return "MISSINGRESOURCESIZE";
			case LIBMCDATA_ERROR_MISSINGRESOURCECONTENTTYPE: return "MISSINGRESOURCECONTENTTYPE";
			case LIBMCDATA_ERROR_DRIVERALREADYREGISTERED: return "DRIVERALREADYREGISTERED";
			case LIBMCDATA_ERROR_DRIVERNOTFOUND: return "DRIVERNOTFOUND";
			case LIBMCDATA_ERROR_MISSINGDRIVERNAME: return "MISSINGDRIVERNAME";
			case LIBMCDATA_ERROR_MISSINGDRIVERTYPE: return "MISSINGDRIVERTYPE";
			case LIBMCDATA_ERROR_MISSINGDRIVERLIBRARY: return "MISSINGDRIVERLIBRARY";
			case LIBMCDATA_ERROR_DRIVERALREADYRESERVED: return "DRIVERALREADYRESERVED";
			case LIBMCDATA_ERROR_LIBRARYPATHNOTFOUND: return "LIBRARYPATHNOTFOUND";
			case LIBMCDATA_ERROR_TOOLPATHENTITYNOTLOADED: return "TOOLPATHENTITYNOTLOADED";
			case LIBMCDATA_ERROR_TOOLPATHENTITYREFERENCEERROR: return "TOOLPATHENTITYREFERENCEERROR";
			case LIBMCDATA_ERROR_TOOLPATHENTITYINVALIDFILE: return "TOOLPATHENTITYINVALIDFILE";
			case LIBMCDATA_ERROR_NO3MFLIBRARY: return "NO3MFLIBRARY";
			case LIBMCDATA_ERROR_INVALIDPOINTCOUNT: return "INVALIDPOINTCOUNT";
			case LIBMCDATA_ERROR_DUPLICATEJOBUUID: return "DUPLICATEJOBUUID";
			case LIBMCDATA_ERROR_INVALIDJOBSTATUS: return "INVALIDJOBSTATUS";
			case LIBMCDATA_ERROR_INVALIDSTREAMCONTEXT: return "INVALIDSTREAMCONTEXT";
			case LIBMCDATA_ERROR_JOBUUIDNOTFOUND: return "JOBUUIDNOTFOUND";
			case LIBMCDATA_ERROR_INVALIDJOBNAME: return "INVALIDJOBNAME";
			case LIBMCDATA_ERROR_INVALIDJOBTIMESTAMP: return "INVALIDJOBTIMESTAMP";
			case LIBMCDATA_ERROR_INVALIDUSERID: return "INVALIDUSERID";
			case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSIGNATURE: return "INVALIDSTORAGECALLBACKSIGNATURE";
			case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSTREAM: return "INVALIDSTORAGECALLBACKSTREAM";
			case LIBMCDATA_ERROR_INVALIDSTORAGEPATH: return "INVALIDSTORAGEPATH";
			case LIBMCDATA_ERROR_STORAGESTREAMNOTFOUND: return "STORAGESTREAMNOTFOUND";
			case LIBMCDATA_ERROR_DUPLICATESTORAGESTREAM: return "DUPLICATESTORAGESTREAM";
			case LIBMCDATA_ERROR_INVALIDPARTIALUPLOAD: return "INVALIDPARTIALUPLOAD";
			case LIBMCDATA_ERROR_PARTIALUPLOADNOTFINISHED: return "PARTIALUPLOADNOTFINISHED";
			case LIBMCDATA_ERROR_APIREQUESTNOTHANDLED: return "APIREQUESTNOTHANDLED";
			case LIBMCDATA_ERROR_APIREQUESTALREADYHANDLED: return "APIREQUESTALREADYHANDLED";
			case LIBMCDATA_ERROR_INVALIDAPIREQUESTTYPE: return "INVALIDAPIREQUESTTYPE";
			case LIBMCDATA_ERROR_INVALIDUPLOADSTREAM: return "INVALIDUPLOADSTREAM";
			case LIBMCDATA_ERROR_COULDNOTPARSEJSONREQUEST: return "COULDNOTPARSEJSONREQUEST";
			case LIBMCDATA_ERROR_INVALIDCONTEXTUUID: return "INVALIDCONTEXTUUID";
			case LIBMCDATA_ERROR_INVALIDUPLOADNAME: return "INVALIDUPLOADNAME";
			case LIBMCDATA_ERROR_INVALIDMIMETYPE: return "INVALIDMIMETYPE";
			case LIBMCDATA_ERROR_INVALIDSTREAMSIZE: return "INVALIDSTREAMSIZE";
			case LIBMCDATA_ERROR_INVALIDSHA256SUM: return "INVALIDSHA256SUM";
			case LIBMCDATA_ERROR_INVALIDSTREAMUUID: return "INVALIDSTREAMUUID";
			case LIBMCDATA_ERROR_INVALIDFIELDNAME: return "INVALIDFIELDNAME";
			case LIBMCDATA_ERROR_UPLOADSIZEMISMATCH: return "UPLOADSIZEMISMATCH";
			case LIBMCDATA_ERROR_CONTENTTYPENOTACCEPTED: return "CONTENTTYPENOTACCEPTED";
			case LIBMCDATA_ERROR_NOCURRENTUPLOAD: return "NOCURRENTUPLOAD";
			case LIBMCDATA_ERROR_UPLOADCHECKSUMMISMATCH: return "UPLOADCHECKSUMMISMATCH";
			case LIBMCDATA_ERROR_INVALIDSTORAGESTREAMSTATUS: return "INVALIDSTORAGESTREAMSTATUS";
			case LIBMCDATA_ERROR_CONTEXTUUIDNOTACCEPTED: return "CONTEXTUUIDNOTACCEPTED";
			case LIBMCDATA_ERROR_INVALIDBUILDUUID: return "INVALIDBUILDUUID";
			case LIBMCDATA_ERROR_MISSINGTHREADCOUNT: return "MISSINGTHREADCOUNT";
			case LIBMCDATA_ERROR_INVALIDTHREADCOUNT: return "INVALIDTHREADCOUNT";
			case LIBMCDATA_ERROR_COULDNOTUPDATEBUILDSTATUS: return "COULDNOTUPDATEBUILDSTATUS";
			case LIBMCDATA_ERROR_INVALIDITERATOR: return "INVALIDITERATOR";
			case LIBMCDATA_ERROR_INVALIDDATATYPE: return "INVALIDDATATYPE";
			case LIBMCDATA_ERROR_COULDNOTSENDSIGNAL: return "COULDNOTSENDSIGNAL";
			case LIBMCDATA_ERROR_MISSINGSIGNALPARAMETER: return "MISSINGSIGNALPARAMETER";
			case LIBMCDATA_ERROR_NOUSERINTERFACEDEFINITION: return "NOUSERINTERFACEDEFINITION";
			case LIBMCDATA_ERROR_MISSINGAPPNAME: return "MISSINGAPPNAME";
			case LIBMCDATA_ERROR_MISSINGCOPYRIGHT: return "MISSINGCOPYRIGHT";
			case LIBMCDATA_ERROR_MISSINGMAINPAGE: return "MISSINGMAINPAGE";
			case LIBMCDATA_ERROR_MISSINGMENUITEMID: return "MISSINGMENUITEMID";
			case LIBMCDATA_ERROR_MISSINGMENUITEMICON: return "MISSINGMENUITEMICON";
			case LIBMCDATA_ERROR_MISSINGMENUITEMCAPTION: return "MISSINGMENUITEMCAPTION";
			case LIBMCDATA_ERROR_MISSINGTARGETPAGE: return "MISSINGTARGETPAGE";
			case LIBMCDATA_ERROR_MISSINGMENUNODE: return "MISSINGMENUNODE";
			case LIBMCDATA_ERROR_MISSINGTOOLBARNODE: return "MISSINGTOOLBARNODE";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMID: return "MISSINGTOOLBARITEMID";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMICON: return "MISSINGTOOLBARITEMICON";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMCAPTION: return "MISSINGTOOLBARITEMCAPTION";
			case LIBMCDATA_ERROR_MISSINGSERVICESNODE: return "MISSINGSERVICESNODE";
			case LIBMCDATA_ERROR_INVALIDSESSIONUUID: return "INVALIDSESSIONUUID";
			case LIBMCDATA_ERROR_INVALIDSESSIONKEY: return "INVALIDSESSIONKEY";
			case LIBMCDATA_ERROR_SESSIONNOTAUTHORIZED: return "SESSIONNOTAUTHORIZED";
			case LIBMCDATA_ERROR_INVALIDUSERNAME: return "INVALIDUSERNAME";
			case LIBMCDATA_ERROR_INVALIDPASSWORD: return "INVALIDPASSWORD";
			case LIBMCDATA_ERROR_INVALIDAUTHORIZATION: return "INVALIDAUTHORIZATION";
			case LIBMCDATA_ERROR_USERALREADYAUTHORIZED: return "USERALREADYAUTHORIZED";
			case LIBMCDATA_ERROR_INVALIDSESSIONTOKEN: return "INVALIDSESSIONTOKEN";
			case LIBMCDATA_ERROR_INVALIDCLIENTKEY: return "INVALIDCLIENTKEY";
			case LIBMCDATA_ERROR_INVALIDLOGIN: return "INVALIDLOGIN";
			case LIBMCDATA_ERROR_DUPLICATEPAGE: return "DUPLICATEPAGE";
			case LIBMCDATA_ERROR_PAGENOTFOUND: return "PAGENOTFOUND";
			case LIBMCDATA_ERROR_MISSINGPAGENAME: return "MISSINGPAGENAME";
			case LIBMCDATA_ERROR_INVALIDPAGENAME: return "INVALIDPAGENAME";
			case LIBMCDATA_ERROR_MODULENOTFOUND: return "MODULENOTFOUND";
			case LIBMCDATA_ERROR_DUPLICATEMODULE: return "DUPLICATEMODULE";
			case LIBMCDATA_ERROR_INVALIDMODULENAME: return "INVALIDMODULENAME";
			case LIBMCDATA_ERROR_INVALIDMODULETYPE: return "INVALIDMODULETYPE";
			case LIBMCDATA_ERROR_INVALIDHEADLINE: return "INVALIDHEADLINE";
			case LIBMCDATA_ERROR_USERNOTFOUND: return "USERNOTFOUND";
			case LIBMCDATA_ERROR_STREAMISNOTIMAGE: return "STREAMISNOTIMAGE";
			case LIBMCDATA_ERROR_TOOMANYCONTENTPARAMETERS: return "TOOMANYCONTENTPARAMETERS";
			case LIBMCDATA_ERROR_MISSINGCONTENTSTATEMACHINENAME: return "MISSINGCONTENTSTATEMACHINENAME";
			case LIBMCDATA_ERROR_MISSINGCONTENTGROUPNAME: return "MISSINGCONTENTGROUPNAME";
			case LIBMCDATA_ERROR_INVALIDENTRIESPERPAGE: return "INVALIDENTRIESPERPAGE";
			case LIBMCDATA_ERROR_MODULEITEMNOTFOUND: return "MODULEITEMNOTFOUND";
			case LIBMCDATA_ERROR_DERIVEDPARAMETERSREADONLY: return "DERIVEDPARAMETERSREADONLY";
			case LIBMCDATA_ERROR_TOOMANYJOURNALVARIABLES: return "TOOMANYJOURNALVARIABLES";
			case LIBMCDATA_ERROR_JOURNALISNOTINITIALISING: return "JOURNALISNOTINITIALISING";
			case LIBMCDATA_ERROR_JOURNALISNOTRECORDING: return "JOURNALISNOTRECORDING";
			case LIBMCDATA_ERROR_INVALIDVARIABLETYPE: return "INVALIDVARIABLETYPE";
			case LIBMCDATA_ERROR_INVALIDVARIABLEUNITS: return "INVALIDVARIABLEUNITS";
			case LIBMCDATA_ERROR_UNITSHAVEALREADYBEENSET: return "UNITSHAVEALREADYBEENSET";
			case LIBMCDATA_ERROR_UNITSHAVENOTBEENSET: return "UNITSHAVENOTBEENSET";
			case LIBMCDATA_ERROR_INVALIDTIMESTAMP: return "INVALIDTIMESTAMP";
			case LIBMCDATA_ERROR_NOCURRENTJOURNALCHUNK: return "NOCURRENTJOURNALCHUNK";
			case LIBMCDATA_ERROR_DUPLICATEJOURNALID: return "DUPLICATEJOURNALID";
			case LIBMCDATA_ERROR_RESOURCEENTRYNOTFOUND: return "RESOURCEENTRYNOTFOUND";
			case LIBMCDATA_ERROR_NOCORERESOURCEPACKAGE: return "NOCORERESOURCEPACKAGE";
			case LIBMCDATA_ERROR_INVALIDASPECTRATIO: return "INVALIDASPECTRATIO";
			case LIBMCDATA_ERROR_MISSINGLOGORESOURCE: return "MISSINGLOGORESOURCE";
			case LIBMCDATA_ERROR_NOUSERINTERFACEPLUGIN: return "NOUSERINTERFACEPLUGIN";
			case LIBMCDATA_ERROR_COULDNOTLOADUILIBRARY: return "COULDNOTLOADUILIBRARY";
			case LIBMCDATA_ERROR_EVENTNAMENOTFOUND: return "EVENTNAMENOTFOUND";
			case LIBMCDATA_ERROR_INVALIDEVENTSENDER: return "INVALIDEVENTSENDER";
			case LIBMCDATA_ERROR_INVALIDEVENTCONTEXT: return "INVALIDEVENTCONTEXT";
			case LIBMCDATA_ERROR_INVALIDLAYERINDEX: return "INVALIDLAYERINDEX";
			case LIBMCDATA_ERROR_TEMPBASEPATHEMPTY: return "TEMPBASEPATHEMPTY";
			case LIBMCDATA_ERROR_BUILDJOBDATANOTFOUND: return "BUILDJOBDATANOTFOUND";
			case LIBMCDATA_ERROR_INVALIDNAMESTRING: return "INVALIDNAMESTRING";
			case LIBMCDATA_ERROR_NAMESTRINGMISMATCH: return "NAMESTRINGMISMATCH";
			case LIBMCDATA_ERROR_DATATYPEMISMATCH: return "DATATYPEMISMATCH";
			case LIBMCDATA_ERROR_COULDNOTFINDLOGENTRY: return "COULDNOTFINDLOGENTRY";
			case LIBMCDATA_ERROR_NOLOGCALLBACK: return "NOLOGCALLBACK";
			case LIBMCDATA_ERROR_EMPTYUSERNAME: return "EMPTYUSERNAME";
			case LIBMCDATA_ERROR_EMPTYUSERUUID: return "EMPTYUSERUUID";
			case LIBMCDATA_ERROR_USERNOTUNIQUE: return "USERNOTUNIQUE";
			case LIBMCDATA_ERROR_EMPTYUSERROLE: return "EMPTYUSERROLE";
			case LIBMCDATA_ERROR_EMPTYUSERSALT: return "EMPTYUSERSALT";
			case LIBMCDATA_ERROR_EMPTYUSERPASSWORD: return "EMPTYUSERPASSWORD";
			case LIBMCDATA_ERROR_INVALIDUSERROLE: return "INVALIDUSERROLE";
			case LIBMCDATA_ERROR_USERALREADYEXISTS: return "USERALREADYEXISTS";
			case LIBMCDATA_ERROR_INVALIDUSERLANGUAGE: return "INVALIDUSERLANGUAGE";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERLANGUAGE: return "COULDNOTUPDATEUSERLANGUAGE";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERROLE: return "COULDNOTUPDATEUSERROLE";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERDESCRIPTION: return "COULDNOTUPDATEUSERDESCRIPTION";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERPASSWORD: return "COULDNOTUPDATEUSERPASSWORD";
			case LIBMCDATA_ERROR_INVALIDUSERINDEX: return "INVALIDUSERINDEX";
			case LIBMCDATA_ERROR_INVALIDJOURNAL: return "INVALIDJOURNAL";
			case LIBMCDATA_ERROR_EMPTYALERTIDENTIFIER: return "EMPTYALERTIDENTIFIER";
			case LIBMCDATA_ERROR_INVALIDALERTIDENTIFIER: return "INVALIDALERTIDENTIFIER";
			case LIBMCDATA_ERROR_INVALIDALERTDESCRIPTIONIDENTIFIER: return "INVALIDALERTDESCRIPTIONIDENTIFIER";
			case LIBMCDATA_ERROR_INVALIDALERTLEVEL: return "INVALIDALERTLEVEL";
			case LIBMCDATA_ERROR_ALERTNOTFOUND: return "ALERTNOTFOUND";
			case LIBMCDATA_ERROR_ALERTNOTACKNOWLEDGED: return "ALERTNOTACKNOWLEDGED";
			case LIBMCDATA_ERROR_INVALIDSTORAGESTATE: return "INVALIDSTORAGESTATE";
			case LIBMCDATA_ERROR_STORAGEWRITERALREADYEXISTS: return "STORAGEWRITERALREADYEXISTS";
			case LIBMCDATA_ERROR_STORAGEWRITERDOESNOTEXIST: return "STORAGEWRITERDOESNOTEXIST";
			case LIBMCDATA_ERROR_STORAGESTREAMNOTPARTIAL: return "STORAGESTREAMNOTPARTIAL";
			case LIBMCDATA_ERROR_STORAGESTREAMNOTRANDOMACCESS: return "STORAGESTREAMNOTRANDOMACCESS";
			case LIBMCDATA_ERROR_DOWNLOADTICKETNOTFOUND: return "DOWNLOADTICKETNOTFOUND";
			case LIBMCDATA_ERROR_EMPTYCLIENTFILENAME: return "EMPTYCLIENTFILENAME";
			case LIBMCDATA_ERROR_INVALIDCLIENTFILENAME: return "INVALIDCLIENTFILENAME";
			case LIBMCDATA_ERROR_CANNOTCHANGESTATUSOFBUILDJOBEXECUTION: return "CANNOTCHANGESTATUSOFBUILDJOBEXECUTION";
			case LIBMCDATA_ERROR_BUILDJOBMETADATAKEYEMPTY: return "BUILDJOBMETADATAKEYEMPTY";
			case LIBMCDATA_ERROR_BUILDJOBMETADATAKEYINVALID: return "BUILDJOBMETADATAKEYINVALID";
			case LIBMCDATA_ERROR_BUILDJOBMETADATAKEYDUPLICATE: return "BUILDJOBMETADATAKEYDUPLICATE";
			case LIBMCDATA_ERROR_BUILDJOBMETADATAKEYNOTFOUND: return "BUILDJOBMETADATAKEYNOTFOUND";
			case LIBMCDATA_ERROR_INVALIDBUILDJOBEXECUTIONSTATUS: return "INVALIDBUILDJOBEXECUTIONSTATUS";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONNOTFOUND: return "BUILDJOBEXECUTIONNOTFOUND";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONISNOTINPROCESS: return "BUILDJOBEXECUTIONISNOTINPROCESS";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONENDNOTAVAILABLE: return "BUILDJOBEXECUTIONENDNOTAVAILABLE";
			case LIBMCDATA_ERROR_INVALIDBUILDJOBEXECUTIONSTART: return "INVALIDBUILDJOBEXECUTIONSTART";
			case LIBMCDATA_ERROR_INVALIDBUILDJOBEXECUTIONEND: return "INVALIDBUILDJOBEXECUTIONEND";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONENDISBEFORESTART: return "BUILDJOBEXECUTIONENDISBEFORESTART";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONISFROMPASTJOURNAL: return "BUILDJOBEXECUTIONISFROMPASTJOURNAL";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONSTARTISINTHEFUTURE: return "BUILDJOBEXECUTIONSTARTISINTHEFUTURE";
			case LIBMCDATA_ERROR_BUILDJOBDURATIONNOTAVAILABLE: return "BUILDJOBDURATIONNOTAVAILABLE";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONMETADATAKEYEMPTY: return "BUILDJOBEXECUTIONMETADATAKEYEMPTY";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONMETADATAKEYINVALID: return "BUILDJOBEXECUTIONMETADATAKEYINVALID";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONMETADATAKEYNOTFOUND: return "BUILDJOBEXECUTIONMETADATAKEYNOTFOUND";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONMETADATAKEYDUPLICATE: return "BUILDJOBEXECUTIONMETADATAKEYDUPLICATE";
			case LIBMCDATA_ERROR_EMPTYJOBDATAIDENTIFIER: return "EMPTYJOBDATAIDENTIFIER";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONDATANOTFOUND: return "BUILDJOBEXECUTIONDATANOTFOUND";
			case LIBMCDATA_ERROR_EMPTYJOBEXECUTIONDATAIDENTIFIER: return "EMPTYJOBEXECUTIONDATAIDENTIFIER";
			case LIBMCDATA_ERROR_ZIPSTREAMSDONOTSUPPORTASYNCCHUNKWRITE: return "ZIPSTREAMSDONOTSUPPORTASYNCCHUNKWRITE";
			case LIBMCDATA_ERROR_ZIPSTREAMEXCEEDSMAXIMUMNUMBEROFENTRIES: return "ZIPSTREAMEXCEEDSMAXIMUMNUMBEROFENTRIES";
			case LIBMCDATA_ERROR_ATTEMPTEDTOWRITETOFINISHEDZIPSTREAMENTRY: return "ATTEMPTEDTOWRITETOFINISHEDZIPSTREAMENTRY";
			case LIBMCDATA_ERROR_INVALIDZIPSTREAMENTRYID: return "INVALIDZIPSTREAMENTRYID";
			case LIBMCDATA_ERROR_ZIPSTREAMENTRYIDNOTFOUND: return "ZIPSTREAMENTRYIDNOTFOUND";
			case LIBMCDATA_ERROR_ZIPWRITINGALREADYFINISHED: return "ZIPWRITINGALREADYFINISHED";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMCDATA_SUCCESS: return "success";
			case LIBMCDATA_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMCDATA_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMCDATA_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMCDATA_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMCDATA_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMCDATA_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMCDATA_ERROR_COULDNOTPARSECONFIGURATION: return "could not parse configuration";
			case LIBMCDATA_ERROR_DUPLICATESTATENAME: return "duplicate state name";
			case LIBMCDATA_ERROR_STATENOTFOUND: return "state not found";
			case LIBMCDATA_ERROR_DUPLICATEOUTSTATE: return "duplicate out state";
			case LIBMCDATA_ERROR_MISSINGMACHINEDEFINITION: return "missing machine definition";
			case LIBMCDATA_ERROR_MISSINGINSTANCENAME: return "missing instance name";
			case LIBMCDATA_ERROR_DUPLICATEMACHINEINSTANCE: return "duplicate machine instance";
			case LIBMCDATA_ERROR_MISSINGXMLSCHEMA: return "missing XML schema";
			case LIBMCDATA_ERROR_INVALIDXMLSCHEMA: return "invalid XML schema";
			case LIBMCDATA_ERROR_MISSINGSTATENAME: return "missing state name";
			case LIBMCDATA_ERROR_MISSINGOUTSTATETARGET: return "missing outstate target";
			case LIBMCDATA_ERROR_INVALIDOUTSTATETARGET: return "invalid outstate target";
			case LIBMCDATA_ERROR_NOINITSTATE: return "no init state";
			case LIBMCDATA_ERROR_NOFAILEDSTATE: return "no failed state";
			case LIBMCDATA_ERROR_INITSTATENOTFOUND: return "init state not found";
			case LIBMCDATA_ERROR_FAILEDSTATENOTFOUND: return "failed state not found";
			case LIBMCDATA_ERROR_MISSINGINITSTATE: return "missing init state";
			case LIBMCDATA_ERROR_MISSINGFAILEDSTATE: return "missing failed state";
			case LIBMCDATA_ERROR_MISSINGPLUGINNAME: return "missing plugin name";
			case LIBMCDATA_ERROR_EMPTYINITSTATE: return "empty init state";
			case LIBMCDATA_ERROR_EMPTYFAILEDSTATE: return "empty failed state";
			case LIBMCDATA_ERROR_EMPTYPLUGINNAME: return "empty plugin name";
			case LIBMCDATA_ERROR_COULDNOTCREATESTATEFACTORY: return "could not create state factory";
			case LIBMCDATA_ERROR_INVALIDSTATENAME: return "invalid state name";
			case LIBMCDATA_ERROR_COULDNOTCREATESTATE: return "could not create state";
			case LIBMCDATA_ERROR_COULDNOTINITIALIZEFACTORY: return "could not initialize factory";
			case LIBMCDATA_ERROR_COULDNOTFINALIZEFACTORY: return "could not finalize factory";
			case LIBMCDATA_ERROR_COULDNOTLOADPLUGIN: return "could not load plugin";
			case LIBMCDATA_ERROR_NOCURRENTSTATE: return "no current state";
			case LIBMCDATA_ERROR_NOPLUGINSTATE: return "no plugin state";
			case LIBMCDATA_ERROR_COULDNOTEXECUTEPLUGIN: return "could not execute plugin";
			case LIBMCDATA_ERROR_TOOMANYMACHINEINSTANCES: return "too many machine instances";
			case LIBMCDATA_ERROR_INVALIDINDEX: return "invalid index";
			case LIBMCDATA_ERROR_NOOUTSTATEGIVEN: return "no new outstate has been given";
			case LIBMCDATA_ERROR_INVALIDOUTSTATEGIVEN: return "invalid outstate has been given";
			case LIBMCDATA_ERROR_INVALIDREPEATDELAY: return "invalid repeat delay";
			case LIBMCDATA_ERROR_INVALIDEXECUTIONDELAY: return "invalid execution delay";
			case LIBMCDATA_ERROR_MISSINGREPEATDELAY: return "missing repeat delay";
			case LIBMCDATA_ERROR_THREADISRUNNING: return "thread is running";
			case LIBMCDATA_ERROR_THREADISNOTRUNNING: return "thread is not running";
			case LIBMCDATA_ERROR_DUPLICATESIGNAL: return "duplicate signal";
			case LIBMCDATA_ERROR_INVALIDSIGNALNAME: return "invalid signal name";
			case LIBMCDATA_ERROR_MISSINGSIGNALNAME: return "missing signal name";
			case LIBMCDATA_ERROR_MISSINGSERVERNODE: return "missing server node";
			case LIBMCDATA_ERROR_MISSINGHOSTNAME: return "missing host name";
			case LIBMCDATA_ERROR_MISSINGPORT: return "missing port";
			case LIBMCDATA_ERROR_UUIDGENERATIONFAILED: return "uuid generation failed";
			case LIBMCDATA_ERROR_INVALIDBUFFERSIZE: return "invalid buffer size";
			case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF8: return "could not convert to utf8";
			case LIBMCDATA_ERROR_NOCOLUMNAVAILABLE: return "no column available";
			case LIBMCDATA_ERROR_INVALIDTEXTCOLUMN: return "invalid text column";
			case LIBMCDATA_ERROR_INVALIDCOLUMNTYPE: return "invalid column type";
			case LIBMCDATA_ERROR_TOOMANYREQUESTEDLOGS: return "too many requested logs";
			case LIBMCDATA_ERROR_MISSINGINSTANCEDESCRIPTION: return "missing instance description";
			case LIBMCDATA_ERROR_DUPLICATEPARAMETERGROUPNAME: return "duplicate parameter group name";
			case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPNAME: return "missing parameter group name";
			case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPNAME: return "empty parameter group name";
			case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPDESCRIPTION: return "missing parameter group description";
			case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPDESCRIPTION: return "empty parameter group description";
			case LIBMCDATA_ERROR_TOOMANYPARAMETERS: return "too many parameters";
			case LIBMCDATA_ERROR_TOOMANYPARAMETERGROUPS: return "too many parameter groups";
			case LIBMCDATA_ERROR_DUPLICATEPARAMETERNAME: return "duplicate parameter name";
			case LIBMCDATA_ERROR_MISSINGPARAMETERNAME: return "missing parameter name";
			case LIBMCDATA_ERROR_EMPTYPARAMETERNAME: return "empty parameter name";
			case LIBMCDATA_ERROR_MISSINGPARAMETERDESCRIPTION: return "missing parameter description";
			case LIBMCDATA_ERROR_EMPTYPARAMETERDESCRIPTION: return "empty parameter description";
			case LIBMCDATA_ERROR_PARAMETERNOTFOUND: return "parameter not found";
			case LIBMCDATA_ERROR_MISSINGPARAMETERDEFAULTVALUE: return "missing parameter default value";
			case LIBMCDATA_ERROR_MISSINGDATACONFIGNODE: return "missing data config node";
			case LIBMCDATA_ERROR_MISSINGDIRECTORY: return "missing directory";
			case LIBMCDATA_ERROR_MISSINGDATABASETYPE: return "missing database type";
			case LIBMCDATA_ERROR_MISSINGSQLITEINFO: return "missing sqlite info";
			case LIBMCDATA_ERROR_UNKNOWNDATABASETYPE: return "unknown database type";
			case LIBMCDATA_ERROR_STORAGENOTINITIALISED: return "storage not initialised";
			case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF16: return "could not convert to utf 16";
			case LIBMCDATA_ERROR_COULDNOTCREATEFILE: return "could not create file";
			case LIBMCDATA_ERROR_COULDNOTSEEKSTREAM: return "could not seek stream";
			case LIBMCDATA_ERROR_COULDNOTGETSTREAMPOSITION: return "could not get stream position";
			case LIBMCDATA_ERROR_COULDNOTWRITESTREAM: return "could not write stream";
			case LIBMCDATA_ERROR_INVALIDDATABASEMIGRATION: return "invalid database migration";
			case LIBMCDATA_ERROR_INTERNALERROR: return "internal error";
			case LIBMCDATA_ERROR_COULDNOTSTORECONTENTSTREAM: return "could not store content stream";
			case LIBMCDATA_ERROR_DATABASENOTINITIALISED: return "database not initialised";
			case LIBMCDATA_ERROR_PARAMETERGROUPNOTFOUND: return "parameter group not found";
			case LIBMCDATA_ERROR_SIGNALNOTFOUND: return "signal not found";
			case LIBMCDATA_ERROR_STATEMACHINENOTFOUND: return "state machine not found.";
			case LIBMCDATA_ERROR_MISSINGPARAMETERTYPE: return "missing parameter type.";
			case LIBMCDATA_ERROR_INVALIDPARAMETERTYPE: return "invalid parameter type.";
			case LIBMCDATA_ERROR_COULDNOTPARSEJSON: return "could not parse json.";
			case LIBMCDATA_ERROR_INVALIDJSONFORMAT: return "invalid json format.";
			case LIBMCDATA_ERROR_URLNOTFOUND: return "url not found.";
			case LIBMCDATA_ERROR_GENERICBADREQUEST: return "generic bad request.";
			case LIBMCDATA_ERROR_SQLITE_ERROR: return "SQLite: Generic Error";
			case LIBMCDATA_ERROR_SQLITE_INTERNAL: return "SQLite: Internal logic error in SQLite";
			case LIBMCDATA_ERROR_SQLITE_PERM: return "SQLite: Access permission denied";
			case LIBMCDATA_ERROR_SQLITE_ABORT: return "SQLite: Callback routine requested an abort";
			case LIBMCDATA_ERROR_SQLITE_BUSY: return "SQLite: The database file is locked";
			case LIBMCDATA_ERROR_SQLITE_LOCKED: return "SQLite: A table in the database is locked";
			case LIBMCDATA_ERROR_SQLITE_NOMEM: return "SQLite: A malloc failed";
			case LIBMCDATA_ERROR_SQLITE_READONLY: return "SQLite: Attempt to write a readonly database";
			case LIBMCDATA_ERROR_SQLITE_INTERRUPT: return "SQLite: Operation terminated by sqlite3_interrupt";
			case LIBMCDATA_ERROR_SQLITE_IOERR: return "SQLite: Some kind of disk I/O error occurred";
			case LIBMCDATA_ERROR_SQLITE_CORRUPT: return "SQLite: The database disk image is malformed";
			case LIBMCDATA_ERROR_SQLITE_NOTFOUND: return "SQLite: Unknown opcode in sqlite3_file_control";
			case LIBMCDATA_ERROR_SQLITE_FULL: return "SQLite: Insertion failed because database is full";
			case LIBMCDATA_ERROR_SQLITE_CANTOPEN: return "SQLite: Unable to open the database file";
			case LIBMCDATA_ERROR_SQLITE_PROTOCOL: return "SQLite: Database lock protocol error";
			case LIBMCDATA_ERROR_SQLITE_SCHEMA: return "SQLite: The database schema changed";
			case LIBMCDATA_ERROR_SQLITE_TOOBIG: return "SQLite: String or BLOB exceeds size limit";
			case LIBMCDATA_ERROR_SQLITE_CONSTRAINT: return "SQLite: Abort due to constraint violation";
			case LIBMCDATA_ERROR_SQLITE_MISMATCH: return "SQLite: Data type mismatch";
			case LIBMCDATA_ERROR_SQLITE_MISUSE: return "SQLite: Library used incorrectly";
			case LIBMCDATA_ERROR_SQLITE_NOLFS: return "SQLite: Uses OS features not supported on host";
			case LIBMCDATA_ERROR_SQLITE_AUTH: return "SQLite: Authorization denied";
			case LIBMCDATA_ERROR_SQLITE_RANGE: return "SQLite: 2nd parameter to sqlite3_bind out of range";
			case LIBMCDATA_ERROR_SQLITE_NOTADB: return "SQLite: File opened that is not a database file";
			case LIBMCDATA_ERROR_SQLITE_NOTICE: return "SQLite: Notifications from sqlite3_log";
			case LIBMCDATA_ERROR_SQLITE_WARNING: return "SQLite: Warnings from sqlite3_log";
			case LIBMCDATA_ERROR_SQLITE_OTHER: return "SQLite: Other Error";
			case LIBMCDATA_ERROR_SQLITE_TOOMANYRESULTROWS: return "too many result rows";
			case LIBMCDATA_ERROR_COULDNOTREADZIPFILE: return "Could not read ZIP file";
			case LIBMCDATA_ERROR_COULDNOTOPENZIPFILE: return "Could not open ZIP file";
			case LIBMCDATA_ERROR_COULDNOTGETZIPENTRIES: return "Could not get ZIP file entries";
			case LIBMCDATA_ERROR_ZIPENTRYNOTFOUND: return "ZIP Entry not found";
			case LIBMCDATA_ERROR_COULDNOTSTATZIPENTRY: return "Could not stat ZIP entry";
			case LIBMCDATA_ERROR_COULDNOTOPENZIPENTRY: return "Could not open ZIP entry";
			case LIBMCDATA_ERROR_COULDNOTREADZIPSTREAM: return "Could not read ZIP stream";
			case LIBMCDATA_ERROR_COULDNOTREADFULLZIPDATA: return "Could not read full zip data";
			case LIBMCDATA_ERROR_COULDNOTFINDRESOURCEINDEX: return "Could not find resource index.";
			case LIBMCDATA_ERROR_COULDNOTPARSERESOURCEINDEX: return "Could not parse resource index.";
			case LIBMCDATA_ERROR_EMPTYRESOURCEINDEX: return "Empty resource index.";
			case LIBMCDATA_ERROR_MISSINGRESOURCEINDEX: return "Missing resource index.";
			case LIBMCDATA_ERROR_MISSINGRESOURCENAME: return "Missing resource name.";
			case LIBMCDATA_ERROR_MISSINGRESOURCEFILENAME: return "Missing resource filename.";
			case LIBMCDATA_ERROR_MISSINGRESOURCESIZE: return "Missing resource size.";
			case LIBMCDATA_ERROR_MISSINGRESOURCECONTENTTYPE: return "Missing resource content type.";
			case LIBMCDATA_ERROR_DRIVERALREADYREGISTERED: return "Driver already registered.";
			case LIBMCDATA_ERROR_DRIVERNOTFOUND: return "Driver not found.";
			case LIBMCDATA_ERROR_MISSINGDRIVERNAME: return "Missing driver name.";
			case LIBMCDATA_ERROR_MISSINGDRIVERTYPE: return "Missing driver type.";
			case LIBMCDATA_ERROR_MISSINGDRIVERLIBRARY: return "Missing driver library.";
			case LIBMCDATA_ERROR_DRIVERALREADYRESERVED: return "Driver has already been reserved by an instance.";
			case LIBMCDATA_ERROR_LIBRARYPATHNOTFOUND: return "Library path not found.";
			case LIBMCDATA_ERROR_TOOLPATHENTITYNOTLOADED: return "Toolpath entity not loaded";
			case LIBMCDATA_ERROR_TOOLPATHENTITYREFERENCEERROR: return "Toolpath entity reference error";
			case LIBMCDATA_ERROR_TOOLPATHENTITYINVALIDFILE: return "Toolpath entity is invalid";
			case LIBMCDATA_ERROR_NO3MFLIBRARY: return "No 3MF Library specified";
			case LIBMCDATA_ERROR_INVALIDPOINTCOUNT: return "Invalid point count";
			case LIBMCDATA_ERROR_DUPLICATEJOBUUID: return "Duplicate job uuid";
			case LIBMCDATA_ERROR_INVALIDJOBSTATUS: return "Invalid job status";
			case LIBMCDATA_ERROR_INVALIDSTREAMCONTEXT: return "Invalid stream context";
			case LIBMCDATA_ERROR_JOBUUIDNOTFOUND: return "Job uuid not found";
			case LIBMCDATA_ERROR_INVALIDJOBNAME: return "Invalid job name";
			case LIBMCDATA_ERROR_INVALIDJOBTIMESTAMP: return "Invalid job timestamp";
			case LIBMCDATA_ERROR_INVALIDUSERID: return "Invalid job name";
			case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSIGNATURE: return "Invalid storage callback signature";
			case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSTREAM: return "Invalid storage callback stream";
			case LIBMCDATA_ERROR_INVALIDSTORAGEPATH: return "Invalid storage path";
			case LIBMCDATA_ERROR_STORAGESTREAMNOTFOUND: return "Storage Stream not found";
			case LIBMCDATA_ERROR_DUPLICATESTORAGESTREAM: return "Duplicate Storage Stream";
			case LIBMCDATA_ERROR_INVALIDPARTIALUPLOAD: return "Invalid Partial Upload";
			case LIBMCDATA_ERROR_PARTIALUPLOADNOTFINISHED: return "Partial Upload not finished";
			case LIBMCDATA_ERROR_APIREQUESTNOTHANDLED: return "API Request not handled";
			case LIBMCDATA_ERROR_APIREQUESTALREADYHANDLED: return "API Request already handled";
			case LIBMCDATA_ERROR_INVALIDAPIREQUESTTYPE: return "Invalid API Request type";
			case LIBMCDATA_ERROR_INVALIDUPLOADSTREAM: return "Invalid Upload Stream";
			case LIBMCDATA_ERROR_COULDNOTPARSEJSONREQUEST: return "Could not parse JSON request";
			case LIBMCDATA_ERROR_INVALIDCONTEXTUUID: return "Invalid Context UUID";
			case LIBMCDATA_ERROR_INVALIDUPLOADNAME: return "Invalid Upload Name";
			case LIBMCDATA_ERROR_INVALIDMIMETYPE: return "Invalid Mime Type";
			case LIBMCDATA_ERROR_INVALIDSTREAMSIZE: return "Invalid Stream Size";
			case LIBMCDATA_ERROR_INVALIDSHA256SUM: return "Invalid SHA256 Sum";
			case LIBMCDATA_ERROR_INVALIDSTREAMUUID: return "Invalid Stream UUID";
			case LIBMCDATA_ERROR_INVALIDFIELDNAME: return "Invalid field name";
			case LIBMCDATA_ERROR_UPLOADSIZEMISMATCH: return "Upload size mismatch";
			case LIBMCDATA_ERROR_CONTENTTYPENOTACCEPTED: return "Content type not accepted";
			case LIBMCDATA_ERROR_NOCURRENTUPLOAD: return "No current upload";
			case LIBMCDATA_ERROR_UPLOADCHECKSUMMISMATCH: return "Upload checksum mismatch";
			case LIBMCDATA_ERROR_INVALIDSTORAGESTREAMSTATUS: return "Invalid storage stream status";
			case LIBMCDATA_ERROR_CONTEXTUUIDNOTACCEPTED: return "Context uuid not accepted";
			case LIBMCDATA_ERROR_INVALIDBUILDUUID: return "Invalid build uuid";
			case LIBMCDATA_ERROR_MISSINGTHREADCOUNT: return "Missing thread count";
			case LIBMCDATA_ERROR_INVALIDTHREADCOUNT: return "Invalid thread count";
			case LIBMCDATA_ERROR_COULDNOTUPDATEBUILDSTATUS: return "Could not update build status";
			case LIBMCDATA_ERROR_INVALIDITERATOR: return "Invalid iterator";
			case LIBMCDATA_ERROR_INVALIDDATATYPE: return "Invalid data type";
			case LIBMCDATA_ERROR_COULDNOTSENDSIGNAL: return "Could not send signal";
			case LIBMCDATA_ERROR_MISSINGSIGNALPARAMETER: return "Missing signal parameter";
			case LIBMCDATA_ERROR_NOUSERINTERFACEDEFINITION: return "No user interface definition";
			case LIBMCDATA_ERROR_MISSINGAPPNAME: return "Missing app name";
			case LIBMCDATA_ERROR_MISSINGCOPYRIGHT: return "Missing copyright";
			case LIBMCDATA_ERROR_MISSINGMAINPAGE: return "Missing main page";
			case LIBMCDATA_ERROR_MISSINGMENUITEMID: return "Missing menu item id";
			case LIBMCDATA_ERROR_MISSINGMENUITEMICON: return "Missing menu item icon";
			case LIBMCDATA_ERROR_MISSINGMENUITEMCAPTION: return "Missing menu item caption";
			case LIBMCDATA_ERROR_MISSINGTARGETPAGE: return "Missing menu item target page";
			case LIBMCDATA_ERROR_MISSINGMENUNODE: return "Missing menu node";
			case LIBMCDATA_ERROR_MISSINGTOOLBARNODE: return "Missing toolbar node";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMID: return "Missing toolbar item id";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMICON: return "Missing toolbar item icon";
			case LIBMCDATA_ERROR_MISSINGTOOLBARITEMCAPTION: return "Missing toolbar item caption";
			case LIBMCDATA_ERROR_MISSINGSERVICESNODE: return "Missing services node";
			case LIBMCDATA_ERROR_INVALIDSESSIONUUID: return "Invalid session UUID";
			case LIBMCDATA_ERROR_INVALIDSESSIONKEY: return "Invalid session Key";
			case LIBMCDATA_ERROR_SESSIONNOTAUTHORIZED: return "Session not authorized";
			case LIBMCDATA_ERROR_INVALIDUSERNAME: return "Invalid user name";
			case LIBMCDATA_ERROR_INVALIDPASSWORD: return "Invalid password";
			case LIBMCDATA_ERROR_INVALIDAUTHORIZATION: return "Invalid Authorization";
			case LIBMCDATA_ERROR_USERALREADYAUTHORIZED: return "User already authorized";
			case LIBMCDATA_ERROR_INVALIDSESSIONTOKEN: return "Invalid session token";
			case LIBMCDATA_ERROR_INVALIDCLIENTKEY: return "Invalid client key";
			case LIBMCDATA_ERROR_INVALIDLOGIN: return "Invalid login credentials";
			case LIBMCDATA_ERROR_DUPLICATEPAGE: return "Duplicate page";
			case LIBMCDATA_ERROR_PAGENOTFOUND: return "Page not found";
			case LIBMCDATA_ERROR_MISSINGPAGENAME: return "Missing page name";
			case LIBMCDATA_ERROR_INVALIDPAGENAME: return "Invalid page name";
			case LIBMCDATA_ERROR_MODULENOTFOUND: return "Module not found";
			case LIBMCDATA_ERROR_DUPLICATEMODULE: return "Duplicate module";
			case LIBMCDATA_ERROR_INVALIDMODULENAME: return "Invalid module name";
			case LIBMCDATA_ERROR_INVALIDMODULETYPE: return "Invalid module type";
			case LIBMCDATA_ERROR_INVALIDHEADLINE: return "Invalid headline";
			case LIBMCDATA_ERROR_USERNOTFOUND: return "User not found";
			case LIBMCDATA_ERROR_STREAMISNOTIMAGE: return "Stream is not image";
			case LIBMCDATA_ERROR_TOOMANYCONTENTPARAMETERS: return "Too many content parameters";
			case LIBMCDATA_ERROR_MISSINGCONTENTSTATEMACHINENAME: return "Missing content state machine name";
			case LIBMCDATA_ERROR_MISSINGCONTENTGROUPNAME: return "Missing content group name";
			case LIBMCDATA_ERROR_INVALIDENTRIESPERPAGE: return "Invalid entries per page";
			case LIBMCDATA_ERROR_MODULEITEMNOTFOUND: return "Module item not found";
			case LIBMCDATA_ERROR_DERIVEDPARAMETERSREADONLY: return "Derived parameters are read only.";
			case LIBMCDATA_ERROR_TOOMANYJOURNALVARIABLES: return "Too many journal variables";
			case LIBMCDATA_ERROR_JOURNALISNOTINITIALISING: return "Too many journal variables";
			case LIBMCDATA_ERROR_JOURNALISNOTRECORDING: return "Too many journal variables";
			case LIBMCDATA_ERROR_INVALIDVARIABLETYPE: return "Invalid variable type";
			case LIBMCDATA_ERROR_INVALIDVARIABLEUNITS: return "Invalid variable units";
			case LIBMCDATA_ERROR_UNITSHAVEALREADYBEENSET: return "Units have already been set";
			case LIBMCDATA_ERROR_UNITSHAVENOTBEENSET: return "Units have not been set";
			case LIBMCDATA_ERROR_INVALIDTIMESTAMP: return "Invalid time stamp";
			case LIBMCDATA_ERROR_NOCURRENTJOURNALCHUNK: return "No current journal chunk";
			case LIBMCDATA_ERROR_DUPLICATEJOURNALID: return "Duplicate journal id";
			case LIBMCDATA_ERROR_RESOURCEENTRYNOTFOUND: return "Resource entry not found";
			case LIBMCDATA_ERROR_NOCORERESOURCEPACKAGE: return "No core resource package";
			case LIBMCDATA_ERROR_INVALIDASPECTRATIO: return "Invalid aspect ratio";
			case LIBMCDATA_ERROR_MISSINGLOGORESOURCE: return "Missing logo resource";
			case LIBMCDATA_ERROR_NOUSERINTERFACEPLUGIN: return "No user interface plugin";
			case LIBMCDATA_ERROR_COULDNOTLOADUILIBRARY: return "Could not load UI library";
			case LIBMCDATA_ERROR_EVENTNAMENOTFOUND: return "Event name not found";
			case LIBMCDATA_ERROR_INVALIDEVENTSENDER: return "Invalid event context";
			case LIBMCDATA_ERROR_INVALIDEVENTCONTEXT: return "Invalid event sender";
			case LIBMCDATA_ERROR_INVALIDLAYERINDEX: return "Invalid layer index";
			case LIBMCDATA_ERROR_TEMPBASEPATHEMPTY: return "Empty base path for temporary files";
			case LIBMCDATA_ERROR_BUILDJOBDATANOTFOUND: return "Build job data not found";
			case LIBMCDATA_ERROR_INVALIDNAMESTRING: return "Invalid name string";
			case LIBMCDATA_ERROR_NAMESTRINGMISMATCH: return "Name string mismatch";
			case LIBMCDATA_ERROR_DATATYPEMISMATCH: return "Datatype mismatch";
			case LIBMCDATA_ERROR_COULDNOTFINDLOGENTRY: return "Could not find log entry";
			case LIBMCDATA_ERROR_NOLOGCALLBACK: return "No log callback";
			case LIBMCDATA_ERROR_EMPTYUSERNAME: return "Empty user name";
			case LIBMCDATA_ERROR_EMPTYUSERUUID: return "Empty user UUID";
			case LIBMCDATA_ERROR_USERNOTUNIQUE: return "User not unique";
			case LIBMCDATA_ERROR_EMPTYUSERROLE: return "Empty user role";
			case LIBMCDATA_ERROR_EMPTYUSERSALT: return "Empty user salt";
			case LIBMCDATA_ERROR_EMPTYUSERPASSWORD: return "Empty user password";
			case LIBMCDATA_ERROR_INVALIDUSERROLE: return "Invalid user role";
			case LIBMCDATA_ERROR_USERALREADYEXISTS: return "User already exists";
			case LIBMCDATA_ERROR_INVALIDUSERLANGUAGE: return "Invalid user language";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERLANGUAGE: return "Could not update user language";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERROLE: return "Could not update user role";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERDESCRIPTION: return "Could not update user description";
			case LIBMCDATA_ERROR_COULDNOTUPDATEUSERPASSWORD: return "Could not update user password";
			case LIBMCDATA_ERROR_INVALIDUSERINDEX: return "Invalid user index";
			case LIBMCDATA_ERROR_INVALIDJOURNAL: return "Invalid journal";
			case LIBMCDATA_ERROR_EMPTYALERTIDENTIFIER: return "Empty alert identifier";
			case LIBMCDATA_ERROR_INVALIDALERTIDENTIFIER: return "Invalid alert identifier";
			case LIBMCDATA_ERROR_INVALIDALERTDESCRIPTIONIDENTIFIER: return "Invalid alert description identifier";
			case LIBMCDATA_ERROR_INVALIDALERTLEVEL: return "Invalid alert level";
			case LIBMCDATA_ERROR_ALERTNOTFOUND: return "Alert not found";
			case LIBMCDATA_ERROR_ALERTNOTACKNOWLEDGED: return "Alert has not been acknowledged.";
			case LIBMCDATA_ERROR_INVALIDSTORAGESTATE: return "Invalid storage state.";
			case LIBMCDATA_ERROR_STORAGEWRITERALREADYEXISTS: return "Storage writer already exists.";
			case LIBMCDATA_ERROR_STORAGEWRITERDOESNOTEXIST: return "Storage writer does not exist.";
			case LIBMCDATA_ERROR_STORAGESTREAMNOTPARTIAL: return "Storage stream is not partial.";
			case LIBMCDATA_ERROR_STORAGESTREAMNOTRANDOMACCESS: return "Storage stream is not random access.";
			case LIBMCDATA_ERROR_DOWNLOADTICKETNOTFOUND: return "Download ticket not found.";
			case LIBMCDATA_ERROR_EMPTYCLIENTFILENAME: return "Empty client file name.";
			case LIBMCDATA_ERROR_INVALIDCLIENTFILENAME: return "Invalid client file name.";
			case LIBMCDATA_ERROR_CANNOTCHANGESTATUSOFBUILDJOBEXECUTION: return "Can not change status of build job execution.";
			case LIBMCDATA_ERROR_BUILDJOBMETADATAKEYEMPTY: return "Build job metadata key empty.";
			case LIBMCDATA_ERROR_BUILDJOBMETADATAKEYINVALID: return "Build job metadata key is invalid.";
			case LIBMCDATA_ERROR_BUILDJOBMETADATAKEYDUPLICATE: return "Build job metadata key is not unique.";
			case LIBMCDATA_ERROR_BUILDJOBMETADATAKEYNOTFOUND: return "Build job metadata key not found.";
			case LIBMCDATA_ERROR_INVALIDBUILDJOBEXECUTIONSTATUS: return "Invalid build job execution status.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONNOTFOUND: return "Build job execution not found.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONISNOTINPROCESS: return "Build job execution is not in process.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONENDNOTAVAILABLE: return "Build job execution end is not available.";
			case LIBMCDATA_ERROR_INVALIDBUILDJOBEXECUTIONSTART: return "Invalid build job execution start.";
			case LIBMCDATA_ERROR_INVALIDBUILDJOBEXECUTIONEND: return "Invalid build job execution end.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONENDISBEFORESTART: return "Build job execution end is before start.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONISFROMPASTJOURNAL: return "Build job execution is from past journal.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONSTARTISINTHEFUTURE: return "Build job execution start is in the future.";
			case LIBMCDATA_ERROR_BUILDJOBDURATIONNOTAVAILABLE: return "Build job duration is not available.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONMETADATAKEYEMPTY: return "Build job execution metadata key is empty.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONMETADATAKEYINVALID: return "Build job execution metadata key is invalid.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONMETADATAKEYNOTFOUND: return "Build job execution metadata key not found.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONMETADATAKEYDUPLICATE: return "Build job execution metadata key is duplicate.";
			case LIBMCDATA_ERROR_EMPTYJOBDATAIDENTIFIER: return "Empty job data identifier.";
			case LIBMCDATA_ERROR_BUILDJOBEXECUTIONDATANOTFOUND: return "Build job execution data not found.";
			case LIBMCDATA_ERROR_EMPTYJOBEXECUTIONDATAIDENTIFIER: return "Empty job execution data identifier.";
			case LIBMCDATA_ERROR_ZIPSTREAMSDONOTSUPPORTASYNCCHUNKWRITE: return "ZIP Streams to not support async chunk write.";
			case LIBMCDATA_ERROR_ZIPSTREAMEXCEEDSMAXIMUMNUMBEROFENTRIES: return "ZIP Stream exceeds maximum number of entries.";
			case LIBMCDATA_ERROR_ATTEMPTEDTOWRITETOFINISHEDZIPSTREAMENTRY: return "Attempted to write to finished ZIP stream entry.";
			case LIBMCDATA_ERROR_INVALIDZIPSTREAMENTRYID: return "Invalid ZIP Stream entry ID.";
			case LIBMCDATA_ERROR_ZIPSTREAMENTRYIDNOTFOUND: return "ZIP Stream entry ID not found.";
			case LIBMCDATA_ERROR_ZIPWRITINGALREADYFINISHED: return "ZIP Writing already finished.";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDataInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDataResult nResult);

	inline void GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline LibMCData_pvoid GetSymbolLookupMethod();
	inline PDataModel CreateDataModelInstance();

private:
	sLibMCDataDynamicWrapperTable m_WrapperTable;
	
	LibMCDataResult checkBinaryVersion()
	{
		LibMCData_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMCDATA_VERSION_MAJOR) {
			return LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDATA_SUCCESS;
	}
	LibMCDataResult initWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable);
	LibMCDataResult releaseWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable);
	LibMCDataResult loadWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDataResult loadWrapperTableFromSymbolLookupMethod(sLibMCDataDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CIterator;
	friend class CLogEntryList;
	friend class CLogSession;
	friend class CAlert;
	friend class CAlertIterator;
	friend class CAlertSession;
	friend class CJournalSession;
	friend class CStorageStream;
	friend class CStorageZIPWriter;
	friend class CStorage;
	friend class CCustomDataStream;
	friend class CBuildJobData;
	friend class CBuildJobDataIterator;
	friend class CBuildJobExecutionData;
	friend class CBuildJobExecutionDataIterator;
	friend class CBuildJobExecution;
	friend class CBuildJobExecutionIterator;
	friend class CBuildJob;
	friend class CBuildJobIterator;
	friend class CBuildJobHandler;
	friend class CUserList;
	friend class CLoginHandler;
	friend class CPersistencyHandler;
	friend class CInstallationInformation;
	friend class CDataModel;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDataHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDataResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDataHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDataHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CIterator 
**************************************************************************************************************************/
class CIterator : public CBase {
public:
	
	/**
	* CIterator::CIterator - Constructor for Iterator class.
	*/
	CIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MoveNext();
	inline bool MovePrevious();
	inline PBase GetCurrent();
	inline PIterator Clone();
	inline LibMCData_uint64 Count();
};
	
/*************************************************************************************************************************
 Class CLogEntryList 
**************************************************************************************************************************/
class CLogEntryList : public CBase {
public:
	
	/**
	* CLogEntryList::CLogEntryList - Constructor for LogEntryList class.
	*/
	CLogEntryList(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCData_uint32 Count();
	inline void GetEntryByIndex(const LibMCData_uint32 nIndex, LibMCData_uint32 & nID, std::string & sMessage, std::string & sSubSystem, eLogLevel & eLogLevel, std::string & sTimestamp);
	inline void GetEntryByID(const LibMCData_uint32 nID, std::string & sMessage, std::string & sSubSystem, eLogLevel & eLogLevel, std::string & sTimestamp);
	inline bool HasEntry(const LibMCData_uint32 nID);
};
	
/*************************************************************************************************************************
 Class CLogSession 
**************************************************************************************************************************/
class CLogSession : public CBase {
public:
	
	/**
	* CLogSession::CLogSession - Constructor for LogSession class.
	*/
	CLogSession(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetSessionUUID();
	inline void AddEntry(const std::string & sMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestampUTC);
	inline LibMCData_uint32 GetMaxLogEntryID();
	inline PLogEntryList RetrieveLogEntriesByID(const LibMCData_uint32 nMinLogID, const LibMCData_uint32 nMaxLogID, const eLogLevel eMinLogLevel);
};
	
/*************************************************************************************************************************
 Class CAlert 
**************************************************************************************************************************/
class CAlert : public CBase {
public:
	
	/**
	* CAlert::CAlert - Constructor for Alert class.
	*/
	CAlert(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetIdentifier();
	inline bool IsActive();
	inline eAlertLevel GetLevel();
	inline std::string GetLevelString();
	inline std::string GetDescription();
	inline std::string GetDescriptionIdentifier();
	inline std::string GetReadableContextInformation();
	inline bool GetNeedsAcknowledgement();
	inline std::string GetTimestampUTC();
	inline bool HasBeenAcknowledged();
	inline void GetAcknowledgementInformation(std::string & sUserUUID, std::string & sUserComment, std::string & sAckTime);
	inline void AcknowledgeForUser(const std::string & sUserUUID, const std::string & sUserComment, const std::string & sTimestampUTC);
	inline void DeactivateAlert();
};
	
/*************************************************************************************************************************
 Class CAlertIterator 
**************************************************************************************************************************/
class CAlertIterator : public CIterator {
public:
	
	/**
	* CAlertIterator::CAlertIterator - Constructor for AlertIterator class.
	*/
	CAlertIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PAlert GetCurrentAlert();
};
	
/*************************************************************************************************************************
 Class CAlertSession 
**************************************************************************************************************************/
class CAlertSession : public CBase {
public:
	
	/**
	* CAlertSession::CAlertSession - Constructor for AlertSession class.
	*/
	CAlertSession(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PAlert AddAlert(const std::string & sUUID, const std::string & sIdentifier, const eAlertLevel eLevel, const std::string & sDescription, const std::string & sDescriptionIdentifier, const std::string & sReadableContextInformation, const bool bNeedsAcknowledgement, const std::string & sTimestampUTC);
	inline bool HasAlert(const std::string & sUUID);
	inline PAlert GetAlertByUUID(const std::string & sUUID);
	inline PAlertIterator RetrieveAlerts(const bool bOnlyActive);
	inline PAlertIterator RetrieveAlertsByType(const std::string & sIdentifier, const bool bOnlyActive);
};
	
/*************************************************************************************************************************
 Class CJournalSession 
**************************************************************************************************************************/
class CJournalSession : public CBase {
public:
	
	/**
	* CJournalSession::CJournalSession - Constructor for JournalSession class.
	*/
	CJournalSession(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetSessionUUID();
	inline void WriteJournalChunkIntegerData(const LibMCData_uint32 nChunkIndex, const LibMCData_uint64 nStartTimeStamp, const LibMCData_uint64 nEndTimeStamp, const CInputVector<sJournalChunkVariableInfo> & VariableInfoBuffer, const CInputVector<sJournalChunkIntegerEntry> & EntryDataBuffer);
	inline LibMCData_uint32 GetChunkCapacity();
	inline LibMCData_uint32 GetFlushInterval();
};
	
/*************************************************************************************************************************
 Class CStorageStream 
**************************************************************************************************************************/
class CStorageStream : public CBase {
public:
	
	/**
	* CStorageStream::CStorageStream - Constructor for StorageStream class.
	*/
	CStorageStream(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetTimeStamp();
	inline std::string GetContextIdentifier();
	inline std::string GetName();
	inline std::string GetMIMEType();
	inline std::string GetSHA2();
	inline LibMCData_uint64 GetSize();
	inline void GetContent(std::vector<LibMCData_uint8> & ContentBuffer);
	inline void GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle);
};
	
/*************************************************************************************************************************
 Class CStorageZIPWriter 
**************************************************************************************************************************/
class CStorageZIPWriter : public CBase {
public:
	
	/**
	* CStorageZIPWriter::CStorageZIPWriter - Constructor for StorageZIPWriter class.
	*/
	CStorageZIPWriter(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCData_uint32 StartNewEntry(const std::string & sFileName, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void FinishCurrentEntry();
	inline LibMCData_uint32 GetOpenEntryID();
	inline void WriteData(const LibMCData_uint32 nEntryID, const CInputVector<LibMCData_uint8> & DataBuffer);
	inline LibMCData_uint64 GetEntrySize(const LibMCData_uint32 nEntryID);
	inline LibMCData_uint64 GetZIPStreamSize();
	inline void Finish();
	inline bool IsFinished();
};
	
/*************************************************************************************************************************
 Class CStorage 
**************************************************************************************************************************/
class CStorage : public CBase {
public:
	
	/**
	* CStorage::CStorage - Constructor for Storage class.
	*/
	CStorage(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool StreamIsReady(const std::string & sUUID);
	inline PStorageStream RetrieveStream(const std::string & sUUID);
	inline void StoreNewStream(const std::string & sUUID, const std::string & sName, const std::string & sMimeType, const CInputVector<LibMCData_uint8> & ContentBuffer, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void BeginPartialStream(const std::string & sUUID, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer);
	inline void FinishPartialStream(const std::string & sUUID, const std::string & sSHA2);
	inline void FinishPartialStreamBlockwiseSHA256(const std::string & sUUID, const std::string & sBlockwiseSHA2);
	inline void BeginRandomWriteStream(const std::string & sUUID, const std::string & sName, const std::string & sMimeType, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void StoreRandomWriteStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer);
	inline LibMCData_uint64 GetRandomWriteStreamSize(const std::string & sUUID);
	inline void FinishRandomWriteStream(const std::string & sUUID);
	inline LibMCData_uint64 GetMaxStreamSize();
	inline PStorageZIPWriter CreateZIPStream(const std::string & sUUID, const std::string & sName, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline bool ContentTypeIsAccepted(const std::string & sContentType);
	inline bool StreamIsImage(const std::string & sUUID);
	inline void CreateDownloadTicket(const std::string & sTicketUUID, const std::string & sStreamUUID, const std::string & sClientFileName, const std::string & sSessionUUID, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void RequestDownloadTicket(const std::string & sTicketUUID, const std::string & sIPAddress, const LibMCData_uint64 nAbsoluteTimeStamp, std::string & sStreamUUID, std::string & sClientFileName, std::string & sSessionUUID, std::string & sUserUUID);
	inline void AttachStreamToJournal(const std::string & sStreamUUID, const std::string & sJournalUUID);
};
	
/*************************************************************************************************************************
 Class CCustomDataStream 
**************************************************************************************************************************/
class CCustomDataStream : public CBase {
public:
	
	/**
	* CCustomDataStream::CCustomDataStream - Constructor for CustomDataStream class.
	*/
	CCustomDataStream(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetDataUUID();
	inline std::string GetIdentifier();
	inline std::string GetName();
	inline std::string GetTimeStamp();
	inline PStorageStream GetStorageStream();
	inline std::string GetStorageStreamUUID();
	inline std::string GetStorageStreamSHA2();
	inline LibMCData_uint64 GetStorageStreamSize();
	inline std::string GetUserUUID();
	inline eCustomDataType GetDataType();
	inline std::string GetDataTypeAsString();
	inline std::string GetMIMEType();
};
	
/*************************************************************************************************************************
 Class CBuildJobData 
**************************************************************************************************************************/
class CBuildJobData : public CCustomDataStream {
public:
	
	/**
	* CBuildJobData::CBuildJobData - Constructor for BuildJobData class.
	*/
	CBuildJobData(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CCustomDataStream(pWrapper, pHandle)
	{
	}
	
	inline std::string GetJobUUID();
};
	
/*************************************************************************************************************************
 Class CBuildJobDataIterator 
**************************************************************************************************************************/
class CBuildJobDataIterator : public CIterator {
public:
	
	/**
	* CBuildJobDataIterator::CBuildJobDataIterator - Constructor for BuildJobDataIterator class.
	*/
	CBuildJobDataIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJobData GetCurrentJobData();
};
	
/*************************************************************************************************************************
 Class CBuildJobExecutionData 
**************************************************************************************************************************/
class CBuildJobExecutionData : public CCustomDataStream {
public:
	
	/**
	* CBuildJobExecutionData::CBuildJobExecutionData - Constructor for BuildJobExecutionData class.
	*/
	CBuildJobExecutionData(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CCustomDataStream(pWrapper, pHandle)
	{
	}
	
	inline std::string GetExecutionUUID();
};
	
/*************************************************************************************************************************
 Class CBuildJobExecutionDataIterator 
**************************************************************************************************************************/
class CBuildJobExecutionDataIterator : public CIterator {
public:
	
	/**
	* CBuildJobExecutionDataIterator::CBuildJobExecutionDataIterator - Constructor for BuildJobExecutionDataIterator class.
	*/
	CBuildJobExecutionDataIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJobExecutionData GetCurrentJobExecutionData();
};
	
/*************************************************************************************************************************
 Class CBuildJobExecution 
**************************************************************************************************************************/
class CBuildJobExecution : public CBase {
public:
	
	/**
	* CBuildJobExecution::CBuildJobExecution - Constructor for BuildJobExecution class.
	*/
	CBuildJobExecution(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetExecutionUUID();
	inline std::string GetJobUUID();
	inline eBuildJobExecutionStatus GetStatus();
	inline void ChangeStatus(const eBuildJobExecutionStatus eNewExecutionStatus, const LibMCData_uint64 nAbsoluteEndTimeStampInMicrosecondsSince1970);
	inline std::string GetDescription();
	inline void SetDescription(const std::string & sNewDescription);
	inline std::string GetJournalUUID();
	inline std::string GetUserUUID();
	inline LibMCData_uint64 GetStartTimeStampInMicroseconds();
	inline LibMCData_uint64 GetEndTimeStampInMicroseconds();
	inline LibMCData_uint64 ComputeElapsedTimeInMicroseconds(const LibMCData_uint64 nGlobalTimerInMicroseconds);
	inline void AddJobExecutionData(const std::string & sIdentifier, const std::string & sName, classParam<CStorageStream> pStream, const eCustomDataType eDataType, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline PBuildJobExecutionDataIterator ListJobExecutionDataByType(const eCustomDataType eDataType);
	inline PBuildJobExecutionDataIterator ListJobExecutionData();
	inline PBuildJobExecutionData RetrieveJobExecutionData(const std::string & sDataUUID);
	inline PBuildJobExecutionData RetrieveJobExecutionDataByIdentifier(const std::string & sIdentifier);
	inline bool HasJobExecutionDataUUID(const std::string & sUUID);
	inline bool HasJobExecutionDataIdentifier(const std::string & sIdentifier);
	inline void StoreMetaDataString(const std::string & sKey, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline bool HasMetaDataString(const std::string & sKey);
	inline std::string GetMetaDataString(const std::string & sKey);
};
	
/*************************************************************************************************************************
 Class CBuildJobExecutionIterator 
**************************************************************************************************************************/
class CBuildJobExecutionIterator : public CIterator {
public:
	
	/**
	* CBuildJobExecutionIterator::CBuildJobExecutionIterator - Constructor for BuildJobExecutionIterator class.
	*/
	CBuildJobExecutionIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJobExecution GetCurrentJobExecution();
};
	
/*************************************************************************************************************************
 Class CBuildJob 
**************************************************************************************************************************/
class CBuildJob : public CBase {
public:
	
	/**
	* CBuildJob::CBuildJob - Constructor for BuildJob class.
	*/
	CBuildJob(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetName();
	inline eBuildJobStatus GetStatus();
	inline LibMCData_uint32 GetLayerCount();
	inline std::string GetTimeStamp();
	inline PStorageStream GetStorageStream();
	inline std::string GetStorageStreamUUID();
	inline void StartValidating();
	inline void FinishValidating(const LibMCData_uint32 nLayerCount);
	inline void ArchiveJob();
	inline void UnArchiveJob();
	inline void DeleteJob();
	inline bool JobCanBeArchived();
	inline void AddJobData(const std::string & sIdentifier, const std::string & sName, classParam<CStorageStream> pStream, const eCustomDataType eDataType, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline PBuildJobDataIterator ListJobDataByType(const eCustomDataType eDataType);
	inline PBuildJobDataIterator ListJobData();
	inline PBuildJobData RetrieveJobData(const std::string & sDataUUID);
	inline PBuildJobData RetrieveJobDataByIdentifier(const std::string & sIdentifier);
	inline bool HasJobDataUUID(const std::string & sUUID);
	inline bool HasJobDataIdentifier(const std::string & sIdentifier);
	inline void StoreMetaDataString(const std::string & sKey, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline bool HasMetaDataString(const std::string & sKey);
	inline std::string GetMetaDataString(const std::string & sKey);
	inline PBuildJobExecution CreateBuildJobExecution(const std::string & sDescription, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteStartTimeStampInMicrosecondsSince1970);
	inline PBuildJobExecution RetrieveBuildJobExecution(const std::string & sExecutionUUID);
	inline PBuildJobExecutionIterator RetrieveBuildJobExecutions(const std::string & sJournalUUIDFilter);
	inline PBuildJobExecutionIterator RetrieveBuildJobExecutionsByStatus(const eBuildJobExecutionStatus eStatusFilter, const std::string & sJournalUUIDFilter);
};
	
/*************************************************************************************************************************
 Class CBuildJobIterator 
**************************************************************************************************************************/
class CBuildJobIterator : public CIterator {
public:
	
	/**
	* CBuildJobIterator::CBuildJobIterator - Constructor for BuildJobIterator class.
	*/
	CBuildJobIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJob GetCurrentJob();
};
	
/*************************************************************************************************************************
 Class CBuildJobHandler 
**************************************************************************************************************************/
class CBuildJobHandler : public CBase {
public:
	
	/**
	* CBuildJobHandler::CBuildJobHandler - Constructor for BuildJobHandler class.
	*/
	CBuildJobHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PBuildJob CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline PBuildJob RetrieveJob(const std::string & sJobUUID);
	inline PBuildJob FindJobOfData(const std::string & sDataUUID);
	inline PBuildJobIterator ListJobsByStatus(const eBuildJobStatus eStatus);
	inline std::string ConvertBuildStatusToString(const eBuildJobStatus eStatus);
	inline eBuildJobStatus ConvertStringToBuildStatus(const std::string & sString);
};
	
/*************************************************************************************************************************
 Class CUserList 
**************************************************************************************************************************/
class CUserList : public CBase {
public:
	
	/**
	* CUserList::CUserList - Constructor for UserList class.
	*/
	CUserList(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibMCData_uint32 Count();
	inline void GetUserProperties(const LibMCData_uint32 nUserIndex, std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier);
};
	
/*************************************************************************************************************************
 Class CLoginHandler 
**************************************************************************************************************************/
class CLoginHandler : public CBase {
public:
	
	/**
	* CLoginHandler::CLoginHandler - Constructor for LoginHandler class.
	*/
	CLoginHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool UserExists(const std::string & sUsername);
	inline bool UserUUIDExists(const std::string & sUUID);
	inline void GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword);
	inline void GetUserProperties(const std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier);
	inline void GetUserPropertiesByUUID(const std::string & sUUID, std::string & sUsername, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier);
	inline std::string GetUsernameByUUID(const std::string & sUUID);
	inline std::string GetUserUUID(const std::string & sUsername);
	inline std::string GetUserDescription(const std::string & sUsername);
	inline std::string GetUserDescriptionByUUID(const std::string & sUUID);
	inline std::string GetUserRole(const std::string & sUsername);
	inline std::string GetUserRoleByUUID(const std::string & sUUID);
	inline std::string GetUserLanguage(const std::string & sUsername);
	inline std::string GetUserLanguageByUUID(const std::string & sUUID);
	inline std::string CreateUser(const std::string & sUsername, const std::string & sRole, const std::string & sSalt, const std::string & sHashedPassword, const std::string & sDescription);
	inline void SetUserLanguage(const std::string & sUsername, const std::string & sLanguageIdentifier);
	inline void SetUserRole(const std::string & sUsername, const std::string & sRole);
	inline void SetUserDescription(const std::string & sUsername, const std::string & sDescription);
	inline void SetUserPassword(const std::string & sUsername, const std::string & sSalt, const std::string & sHashedPassword);
	inline void SetUserLanguageByUUID(const std::string & sUUID, const std::string & sLanguageIdentifier);
	inline void SetUserRoleByUUID(const std::string & sUUID, const std::string & sRole);
	inline void SetUserDescriptionByUUID(const std::string & sUUID, const std::string & sDescription);
	inline void SetUserPasswordByUUID(const std::string & sUUID, const std::string & sSalt, const std::string & sHashedPassword);
	inline PUserList GetActiveUsers();
};
	
/*************************************************************************************************************************
 Class CPersistencyHandler 
**************************************************************************************************************************/
class CPersistencyHandler : public CBase {
public:
	
	/**
	* CPersistencyHandler::CPersistencyHandler - Constructor for PersistencyHandler class.
	*/
	CPersistencyHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool HasPersistentParameter(const std::string & sUUID);
	inline void GetPersistentParameterDetails(const std::string & sUUID, std::string & sName, eParameterDataType & eDataType);
	inline bool DeletePersistentParameter(const std::string & sUUID);
	inline void StorePersistentParameter(const std::string & sUUID, const std::string & sName, const eParameterDataType eDataType, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void StorePersistentStringParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void StorePersistentUUIDParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void StorePersistentDoubleParameter(const std::string & sUUID, const std::string & sName, const LibMCData_double dValue, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void StorePersistentIntegerParameter(const std::string & sUUID, const std::string & sName, const LibMCData_int64 nValue, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline void StorePersistentBoolParameter(const std::string & sUUID, const std::string & sName, const bool bValue, const LibMCData_uint64 nAbsoluteTimeStamp);
	inline std::string RetrievePersistentStringParameter(const std::string & sUUID);
	inline std::string RetrievePersistentUUIDParameter(const std::string & sUUID);
	inline LibMCData_double RetrievePersistentDoubleParameter(const std::string & sUUID);
	inline LibMCData_int64 RetrievePersistentIntegerParameter(const std::string & sUUID);
	inline bool RetrievePersistentBoolParameter(const std::string & sUUID);
};
	
/*************************************************************************************************************************
 Class CInstallationInformation 
**************************************************************************************************************************/
class CInstallationInformation : public CBase {
public:
	
	/**
	* CInstallationInformation::CInstallationInformation - Constructor for InstallationInformation class.
	*/
	CInstallationInformation(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetInstallationUUID();
	inline std::string GetInstallationSecret();
	inline std::string GetBaseTempDirectory();
};
	
/*************************************************************************************************************************
 Class CDataModel 
**************************************************************************************************************************/
class CDataModel : public CBase {
public:
	
	/**
	* CDataModel::CDataModel - Constructor for DataModel class.
	*/
	CDataModel(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void InitialiseDatabase(const std::string & sDataDirectory, const eDataBaseType eDataBaseType, const std::string & sConnectionString);
	inline LibMCData_uint32 GetDataModelVersion();
	inline void GetInstallationInformation(std::string & sDEPRECIATEDInstallationUUID, std::string & sDEPRECIATEDInstallationSecret);
	inline PInstallationInformation GetInstallationInformationObject();
	inline PStorage CreateStorage();
	inline PBuildJobHandler CreateBuildJobHandler();
	inline PLogSession CreateNewLogSession();
	inline PJournalSession CreateJournalSession();
	inline PAlertSession CreateAlertSession();
	inline PLoginHandler CreateLoginHandler();
	inline PPersistencyHandler CreatePersistencyHandler();
	inline void SetBaseTempDirectory(const std::string & sTempDirectory);
	inline std::string GetBaseTempDirectory();
	inline void SetLogCallback(const LogCallback pLogCallback, const LibMCData_pvoid pUserData);
	inline void ClearLogCallback();
	inline bool HasLogCallback();
	inline void TriggerLogCallback(const std::string & sLogMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		LibMCData_uint32 bytesNeededErrorMessage = 0;
		LibMCData_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCData_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCData_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDataModelInstance - Creates and initializes new MC DataModel Instance.
	* @return New DataModel instance
	*/
	inline PDataModel CWrapper::CreateDataModelInstance()
	{
		LibMCDataHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDataModelInstance(&hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataModel>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDataResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDataException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDataResult CWrapper::initWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Iterator_MoveNext = nullptr;
		pWrapperTable->m_Iterator_MovePrevious = nullptr;
		pWrapperTable->m_Iterator_GetCurrent = nullptr;
		pWrapperTable->m_Iterator_Clone = nullptr;
		pWrapperTable->m_Iterator_Count = nullptr;
		pWrapperTable->m_LogEntryList_Count = nullptr;
		pWrapperTable->m_LogEntryList_GetEntryByIndex = nullptr;
		pWrapperTable->m_LogEntryList_GetEntryByID = nullptr;
		pWrapperTable->m_LogEntryList_HasEntry = nullptr;
		pWrapperTable->m_LogSession_GetSessionUUID = nullptr;
		pWrapperTable->m_LogSession_AddEntry = nullptr;
		pWrapperTable->m_LogSession_GetMaxLogEntryID = nullptr;
		pWrapperTable->m_LogSession_RetrieveLogEntriesByID = nullptr;
		pWrapperTable->m_Alert_GetUUID = nullptr;
		pWrapperTable->m_Alert_GetIdentifier = nullptr;
		pWrapperTable->m_Alert_IsActive = nullptr;
		pWrapperTable->m_Alert_GetLevel = nullptr;
		pWrapperTable->m_Alert_GetLevelString = nullptr;
		pWrapperTable->m_Alert_GetDescription = nullptr;
		pWrapperTable->m_Alert_GetDescriptionIdentifier = nullptr;
		pWrapperTable->m_Alert_GetReadableContextInformation = nullptr;
		pWrapperTable->m_Alert_GetNeedsAcknowledgement = nullptr;
		pWrapperTable->m_Alert_GetTimestampUTC = nullptr;
		pWrapperTable->m_Alert_HasBeenAcknowledged = nullptr;
		pWrapperTable->m_Alert_GetAcknowledgementInformation = nullptr;
		pWrapperTable->m_Alert_AcknowledgeForUser = nullptr;
		pWrapperTable->m_Alert_DeactivateAlert = nullptr;
		pWrapperTable->m_AlertIterator_GetCurrentAlert = nullptr;
		pWrapperTable->m_AlertSession_AddAlert = nullptr;
		pWrapperTable->m_AlertSession_HasAlert = nullptr;
		pWrapperTable->m_AlertSession_GetAlertByUUID = nullptr;
		pWrapperTable->m_AlertSession_RetrieveAlerts = nullptr;
		pWrapperTable->m_AlertSession_RetrieveAlertsByType = nullptr;
		pWrapperTable->m_JournalSession_GetSessionUUID = nullptr;
		pWrapperTable->m_JournalSession_WriteJournalChunkIntegerData = nullptr;
		pWrapperTable->m_JournalSession_GetChunkCapacity = nullptr;
		pWrapperTable->m_JournalSession_GetFlushInterval = nullptr;
		pWrapperTable->m_StorageStream_GetUUID = nullptr;
		pWrapperTable->m_StorageStream_GetTimeStamp = nullptr;
		pWrapperTable->m_StorageStream_GetContextIdentifier = nullptr;
		pWrapperTable->m_StorageStream_GetName = nullptr;
		pWrapperTable->m_StorageStream_GetMIMEType = nullptr;
		pWrapperTable->m_StorageStream_GetSHA2 = nullptr;
		pWrapperTable->m_StorageStream_GetSize = nullptr;
		pWrapperTable->m_StorageStream_GetContent = nullptr;
		pWrapperTable->m_StorageStream_GetCallbacks = nullptr;
		pWrapperTable->m_StorageZIPWriter_StartNewEntry = nullptr;
		pWrapperTable->m_StorageZIPWriter_FinishCurrentEntry = nullptr;
		pWrapperTable->m_StorageZIPWriter_GetOpenEntryID = nullptr;
		pWrapperTable->m_StorageZIPWriter_WriteData = nullptr;
		pWrapperTable->m_StorageZIPWriter_GetEntrySize = nullptr;
		pWrapperTable->m_StorageZIPWriter_GetZIPStreamSize = nullptr;
		pWrapperTable->m_StorageZIPWriter_Finish = nullptr;
		pWrapperTable->m_StorageZIPWriter_IsFinished = nullptr;
		pWrapperTable->m_Storage_StreamIsReady = nullptr;
		pWrapperTable->m_Storage_RetrieveStream = nullptr;
		pWrapperTable->m_Storage_StoreNewStream = nullptr;
		pWrapperTable->m_Storage_BeginPartialStream = nullptr;
		pWrapperTable->m_Storage_StorePartialStream = nullptr;
		pWrapperTable->m_Storage_FinishPartialStream = nullptr;
		pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 = nullptr;
		pWrapperTable->m_Storage_BeginRandomWriteStream = nullptr;
		pWrapperTable->m_Storage_StoreRandomWriteStream = nullptr;
		pWrapperTable->m_Storage_GetRandomWriteStreamSize = nullptr;
		pWrapperTable->m_Storage_FinishRandomWriteStream = nullptr;
		pWrapperTable->m_Storage_GetMaxStreamSize = nullptr;
		pWrapperTable->m_Storage_CreateZIPStream = nullptr;
		pWrapperTable->m_Storage_ContentTypeIsAccepted = nullptr;
		pWrapperTable->m_Storage_StreamIsImage = nullptr;
		pWrapperTable->m_Storage_CreateDownloadTicket = nullptr;
		pWrapperTable->m_Storage_RequestDownloadTicket = nullptr;
		pWrapperTable->m_Storage_AttachStreamToJournal = nullptr;
		pWrapperTable->m_CustomDataStream_GetDataUUID = nullptr;
		pWrapperTable->m_CustomDataStream_GetIdentifier = nullptr;
		pWrapperTable->m_CustomDataStream_GetName = nullptr;
		pWrapperTable->m_CustomDataStream_GetTimeStamp = nullptr;
		pWrapperTable->m_CustomDataStream_GetStorageStream = nullptr;
		pWrapperTable->m_CustomDataStream_GetStorageStreamUUID = nullptr;
		pWrapperTable->m_CustomDataStream_GetStorageStreamSHA2 = nullptr;
		pWrapperTable->m_CustomDataStream_GetStorageStreamSize = nullptr;
		pWrapperTable->m_CustomDataStream_GetUserUUID = nullptr;
		pWrapperTable->m_CustomDataStream_GetDataType = nullptr;
		pWrapperTable->m_CustomDataStream_GetDataTypeAsString = nullptr;
		pWrapperTable->m_CustomDataStream_GetMIMEType = nullptr;
		pWrapperTable->m_BuildJobData_GetJobUUID = nullptr;
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = nullptr;
		pWrapperTable->m_BuildJobExecutionData_GetExecutionUUID = nullptr;
		pWrapperTable->m_BuildJobExecutionDataIterator_GetCurrentJobExecutionData = nullptr;
		pWrapperTable->m_BuildJobExecution_GetExecutionUUID = nullptr;
		pWrapperTable->m_BuildJobExecution_GetJobUUID = nullptr;
		pWrapperTable->m_BuildJobExecution_GetStatus = nullptr;
		pWrapperTable->m_BuildJobExecution_ChangeStatus = nullptr;
		pWrapperTable->m_BuildJobExecution_GetDescription = nullptr;
		pWrapperTable->m_BuildJobExecution_SetDescription = nullptr;
		pWrapperTable->m_BuildJobExecution_GetJournalUUID = nullptr;
		pWrapperTable->m_BuildJobExecution_GetUserUUID = nullptr;
		pWrapperTable->m_BuildJobExecution_GetStartTimeStampInMicroseconds = nullptr;
		pWrapperTable->m_BuildJobExecution_GetEndTimeStampInMicroseconds = nullptr;
		pWrapperTable->m_BuildJobExecution_ComputeElapsedTimeInMicroseconds = nullptr;
		pWrapperTable->m_BuildJobExecution_AddJobExecutionData = nullptr;
		pWrapperTable->m_BuildJobExecution_ListJobExecutionDataByType = nullptr;
		pWrapperTable->m_BuildJobExecution_ListJobExecutionData = nullptr;
		pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionData = nullptr;
		pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionDataByIdentifier = nullptr;
		pWrapperTable->m_BuildJobExecution_HasJobExecutionDataUUID = nullptr;
		pWrapperTable->m_BuildJobExecution_HasJobExecutionDataIdentifier = nullptr;
		pWrapperTable->m_BuildJobExecution_StoreMetaDataString = nullptr;
		pWrapperTable->m_BuildJobExecution_HasMetaDataString = nullptr;
		pWrapperTable->m_BuildJobExecution_GetMetaDataString = nullptr;
		pWrapperTable->m_BuildJobExecutionIterator_GetCurrentJobExecution = nullptr;
		pWrapperTable->m_BuildJob_GetUUID = nullptr;
		pWrapperTable->m_BuildJob_GetName = nullptr;
		pWrapperTable->m_BuildJob_GetStatus = nullptr;
		pWrapperTable->m_BuildJob_GetLayerCount = nullptr;
		pWrapperTable->m_BuildJob_GetTimeStamp = nullptr;
		pWrapperTable->m_BuildJob_GetStorageStream = nullptr;
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = nullptr;
		pWrapperTable->m_BuildJob_StartValidating = nullptr;
		pWrapperTable->m_BuildJob_FinishValidating = nullptr;
		pWrapperTable->m_BuildJob_ArchiveJob = nullptr;
		pWrapperTable->m_BuildJob_UnArchiveJob = nullptr;
		pWrapperTable->m_BuildJob_DeleteJob = nullptr;
		pWrapperTable->m_BuildJob_JobCanBeArchived = nullptr;
		pWrapperTable->m_BuildJob_AddJobData = nullptr;
		pWrapperTable->m_BuildJob_ListJobDataByType = nullptr;
		pWrapperTable->m_BuildJob_ListJobData = nullptr;
		pWrapperTable->m_BuildJob_RetrieveJobData = nullptr;
		pWrapperTable->m_BuildJob_RetrieveJobDataByIdentifier = nullptr;
		pWrapperTable->m_BuildJob_HasJobDataUUID = nullptr;
		pWrapperTable->m_BuildJob_HasJobDataIdentifier = nullptr;
		pWrapperTable->m_BuildJob_StoreMetaDataString = nullptr;
		pWrapperTable->m_BuildJob_HasMetaDataString = nullptr;
		pWrapperTable->m_BuildJob_GetMetaDataString = nullptr;
		pWrapperTable->m_BuildJob_CreateBuildJobExecution = nullptr;
		pWrapperTable->m_BuildJob_RetrieveBuildJobExecution = nullptr;
		pWrapperTable->m_BuildJob_RetrieveBuildJobExecutions = nullptr;
		pWrapperTable->m_BuildJob_RetrieveBuildJobExecutionsByStatus = nullptr;
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = nullptr;
		pWrapperTable->m_BuildJobHandler_CreateJob = nullptr;
		pWrapperTable->m_BuildJobHandler_RetrieveJob = nullptr;
		pWrapperTable->m_BuildJobHandler_FindJobOfData = nullptr;
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = nullptr;
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = nullptr;
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = nullptr;
		pWrapperTable->m_UserList_Count = nullptr;
		pWrapperTable->m_UserList_GetUserProperties = nullptr;
		pWrapperTable->m_LoginHandler_UserExists = nullptr;
		pWrapperTable->m_LoginHandler_UserUUIDExists = nullptr;
		pWrapperTable->m_LoginHandler_GetUserDetails = nullptr;
		pWrapperTable->m_LoginHandler_GetUserProperties = nullptr;
		pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUsernameByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUserUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUserDescription = nullptr;
		pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUserRole = nullptr;
		pWrapperTable->m_LoginHandler_GetUserRoleByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetUserLanguage = nullptr;
		pWrapperTable->m_LoginHandler_GetUserLanguageByUUID = nullptr;
		pWrapperTable->m_LoginHandler_CreateUser = nullptr;
		pWrapperTable->m_LoginHandler_SetUserLanguage = nullptr;
		pWrapperTable->m_LoginHandler_SetUserRole = nullptr;
		pWrapperTable->m_LoginHandler_SetUserDescription = nullptr;
		pWrapperTable->m_LoginHandler_SetUserPassword = nullptr;
		pWrapperTable->m_LoginHandler_SetUserLanguageByUUID = nullptr;
		pWrapperTable->m_LoginHandler_SetUserRoleByUUID = nullptr;
		pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID = nullptr;
		pWrapperTable->m_LoginHandler_SetUserPasswordByUUID = nullptr;
		pWrapperTable->m_LoginHandler_GetActiveUsers = nullptr;
		pWrapperTable->m_PersistencyHandler_HasPersistentParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails = nullptr;
		pWrapperTable->m_PersistencyHandler_DeletePersistentParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter = nullptr;
		pWrapperTable->m_InstallationInformation_GetInstallationUUID = nullptr;
		pWrapperTable->m_InstallationInformation_GetInstallationSecret = nullptr;
		pWrapperTable->m_InstallationInformation_GetBaseTempDirectory = nullptr;
		pWrapperTable->m_DataModel_InitialiseDatabase = nullptr;
		pWrapperTable->m_DataModel_GetDataModelVersion = nullptr;
		pWrapperTable->m_DataModel_GetInstallationInformation = nullptr;
		pWrapperTable->m_DataModel_GetInstallationInformationObject = nullptr;
		pWrapperTable->m_DataModel_CreateStorage = nullptr;
		pWrapperTable->m_DataModel_CreateBuildJobHandler = nullptr;
		pWrapperTable->m_DataModel_CreateNewLogSession = nullptr;
		pWrapperTable->m_DataModel_CreateJournalSession = nullptr;
		pWrapperTable->m_DataModel_CreateAlertSession = nullptr;
		pWrapperTable->m_DataModel_CreateLoginHandler = nullptr;
		pWrapperTable->m_DataModel_CreatePersistencyHandler = nullptr;
		pWrapperTable->m_DataModel_SetBaseTempDirectory = nullptr;
		pWrapperTable->m_DataModel_GetBaseTempDirectory = nullptr;
		pWrapperTable->m_DataModel_SetLogCallback = nullptr;
		pWrapperTable->m_DataModel_ClearLogCallback = nullptr;
		pWrapperTable->m_DataModel_HasLogCallback = nullptr;
		pWrapperTable->m_DataModel_TriggerLogCallback = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDataModelInstance = nullptr;
		
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::releaseWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::loadWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCDataIterator_MoveNextPtr) GetProcAddress(hLibrary, "libmcdata_iterator_movenext");
		#else // _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCDataIterator_MoveNextPtr) dlsym(hLibrary, "libmcdata_iterator_movenext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MoveNext == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCDataIterator_MovePreviousPtr) GetProcAddress(hLibrary, "libmcdata_iterator_moveprevious");
		#else // _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCDataIterator_MovePreviousPtr) dlsym(hLibrary, "libmcdata_iterator_moveprevious");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MovePrevious == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCDataIterator_GetCurrentPtr) GetProcAddress(hLibrary, "libmcdata_iterator_getcurrent");
		#else // _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCDataIterator_GetCurrentPtr) dlsym(hLibrary, "libmcdata_iterator_getcurrent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_GetCurrent == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCDataIterator_ClonePtr) GetProcAddress(hLibrary, "libmcdata_iterator_clone");
		#else // _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCDataIterator_ClonePtr) dlsym(hLibrary, "libmcdata_iterator_clone");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Clone == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCDataIterator_CountPtr) GetProcAddress(hLibrary, "libmcdata_iterator_count");
		#else // _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCDataIterator_CountPtr) dlsym(hLibrary, "libmcdata_iterator_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Count == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_Count = (PLibMCDataLogEntryList_CountPtr) GetProcAddress(hLibrary, "libmcdata_logentrylist_count");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_Count = (PLibMCDataLogEntryList_CountPtr) dlsym(hLibrary, "libmcdata_logentrylist_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_Count == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_GetEntryByIndex = (PLibMCDataLogEntryList_GetEntryByIndexPtr) GetProcAddress(hLibrary, "libmcdata_logentrylist_getentrybyindex");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_GetEntryByIndex = (PLibMCDataLogEntryList_GetEntryByIndexPtr) dlsym(hLibrary, "libmcdata_logentrylist_getentrybyindex");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_GetEntryByIndex == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_GetEntryByID = (PLibMCDataLogEntryList_GetEntryByIDPtr) GetProcAddress(hLibrary, "libmcdata_logentrylist_getentrybyid");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_GetEntryByID = (PLibMCDataLogEntryList_GetEntryByIDPtr) dlsym(hLibrary, "libmcdata_logentrylist_getentrybyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_GetEntryByID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogEntryList_HasEntry = (PLibMCDataLogEntryList_HasEntryPtr) GetProcAddress(hLibrary, "libmcdata_logentrylist_hasentry");
		#else // _WIN32
		pWrapperTable->m_LogEntryList_HasEntry = (PLibMCDataLogEntryList_HasEntryPtr) dlsym(hLibrary, "libmcdata_logentrylist_hasentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogEntryList_HasEntry == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogSession_GetSessionUUID = (PLibMCDataLogSession_GetSessionUUIDPtr) GetProcAddress(hLibrary, "libmcdata_logsession_getsessionuuid");
		#else // _WIN32
		pWrapperTable->m_LogSession_GetSessionUUID = (PLibMCDataLogSession_GetSessionUUIDPtr) dlsym(hLibrary, "libmcdata_logsession_getsessionuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogSession_GetSessionUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogSession_AddEntry = (PLibMCDataLogSession_AddEntryPtr) GetProcAddress(hLibrary, "libmcdata_logsession_addentry");
		#else // _WIN32
		pWrapperTable->m_LogSession_AddEntry = (PLibMCDataLogSession_AddEntryPtr) dlsym(hLibrary, "libmcdata_logsession_addentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogSession_AddEntry == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogSession_GetMaxLogEntryID = (PLibMCDataLogSession_GetMaxLogEntryIDPtr) GetProcAddress(hLibrary, "libmcdata_logsession_getmaxlogentryid");
		#else // _WIN32
		pWrapperTable->m_LogSession_GetMaxLogEntryID = (PLibMCDataLogSession_GetMaxLogEntryIDPtr) dlsym(hLibrary, "libmcdata_logsession_getmaxlogentryid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogSession_GetMaxLogEntryID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogSession_RetrieveLogEntriesByID = (PLibMCDataLogSession_RetrieveLogEntriesByIDPtr) GetProcAddress(hLibrary, "libmcdata_logsession_retrievelogentriesbyid");
		#else // _WIN32
		pWrapperTable->m_LogSession_RetrieveLogEntriesByID = (PLibMCDataLogSession_RetrieveLogEntriesByIDPtr) dlsym(hLibrary, "libmcdata_logsession_retrievelogentriesbyid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogSession_RetrieveLogEntriesByID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetUUID = (PLibMCDataAlert_GetUUIDPtr) GetProcAddress(hLibrary, "libmcdata_alert_getuuid");
		#else // _WIN32
		pWrapperTable->m_Alert_GetUUID = (PLibMCDataAlert_GetUUIDPtr) dlsym(hLibrary, "libmcdata_alert_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetIdentifier = (PLibMCDataAlert_GetIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_alert_getidentifier");
		#else // _WIN32
		pWrapperTable->m_Alert_GetIdentifier = (PLibMCDataAlert_GetIdentifierPtr) dlsym(hLibrary, "libmcdata_alert_getidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_IsActive = (PLibMCDataAlert_IsActivePtr) GetProcAddress(hLibrary, "libmcdata_alert_isactive");
		#else // _WIN32
		pWrapperTable->m_Alert_IsActive = (PLibMCDataAlert_IsActivePtr) dlsym(hLibrary, "libmcdata_alert_isactive");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_IsActive == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetLevel = (PLibMCDataAlert_GetLevelPtr) GetProcAddress(hLibrary, "libmcdata_alert_getlevel");
		#else // _WIN32
		pWrapperTable->m_Alert_GetLevel = (PLibMCDataAlert_GetLevelPtr) dlsym(hLibrary, "libmcdata_alert_getlevel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetLevel == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetLevelString = (PLibMCDataAlert_GetLevelStringPtr) GetProcAddress(hLibrary, "libmcdata_alert_getlevelstring");
		#else // _WIN32
		pWrapperTable->m_Alert_GetLevelString = (PLibMCDataAlert_GetLevelStringPtr) dlsym(hLibrary, "libmcdata_alert_getlevelstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetLevelString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetDescription = (PLibMCDataAlert_GetDescriptionPtr) GetProcAddress(hLibrary, "libmcdata_alert_getdescription");
		#else // _WIN32
		pWrapperTable->m_Alert_GetDescription = (PLibMCDataAlert_GetDescriptionPtr) dlsym(hLibrary, "libmcdata_alert_getdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetDescription == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetDescriptionIdentifier = (PLibMCDataAlert_GetDescriptionIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_alert_getdescriptionidentifier");
		#else // _WIN32
		pWrapperTable->m_Alert_GetDescriptionIdentifier = (PLibMCDataAlert_GetDescriptionIdentifierPtr) dlsym(hLibrary, "libmcdata_alert_getdescriptionidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetDescriptionIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetReadableContextInformation = (PLibMCDataAlert_GetReadableContextInformationPtr) GetProcAddress(hLibrary, "libmcdata_alert_getreadablecontextinformation");
		#else // _WIN32
		pWrapperTable->m_Alert_GetReadableContextInformation = (PLibMCDataAlert_GetReadableContextInformationPtr) dlsym(hLibrary, "libmcdata_alert_getreadablecontextinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetReadableContextInformation == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetNeedsAcknowledgement = (PLibMCDataAlert_GetNeedsAcknowledgementPtr) GetProcAddress(hLibrary, "libmcdata_alert_getneedsacknowledgement");
		#else // _WIN32
		pWrapperTable->m_Alert_GetNeedsAcknowledgement = (PLibMCDataAlert_GetNeedsAcknowledgementPtr) dlsym(hLibrary, "libmcdata_alert_getneedsacknowledgement");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetNeedsAcknowledgement == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetTimestampUTC = (PLibMCDataAlert_GetTimestampUTCPtr) GetProcAddress(hLibrary, "libmcdata_alert_gettimestamputc");
		#else // _WIN32
		pWrapperTable->m_Alert_GetTimestampUTC = (PLibMCDataAlert_GetTimestampUTCPtr) dlsym(hLibrary, "libmcdata_alert_gettimestamputc");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetTimestampUTC == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_HasBeenAcknowledged = (PLibMCDataAlert_HasBeenAcknowledgedPtr) GetProcAddress(hLibrary, "libmcdata_alert_hasbeenacknowledged");
		#else // _WIN32
		pWrapperTable->m_Alert_HasBeenAcknowledged = (PLibMCDataAlert_HasBeenAcknowledgedPtr) dlsym(hLibrary, "libmcdata_alert_hasbeenacknowledged");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_HasBeenAcknowledged == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_GetAcknowledgementInformation = (PLibMCDataAlert_GetAcknowledgementInformationPtr) GetProcAddress(hLibrary, "libmcdata_alert_getacknowledgementinformation");
		#else // _WIN32
		pWrapperTable->m_Alert_GetAcknowledgementInformation = (PLibMCDataAlert_GetAcknowledgementInformationPtr) dlsym(hLibrary, "libmcdata_alert_getacknowledgementinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_GetAcknowledgementInformation == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_AcknowledgeForUser = (PLibMCDataAlert_AcknowledgeForUserPtr) GetProcAddress(hLibrary, "libmcdata_alert_acknowledgeforuser");
		#else // _WIN32
		pWrapperTable->m_Alert_AcknowledgeForUser = (PLibMCDataAlert_AcknowledgeForUserPtr) dlsym(hLibrary, "libmcdata_alert_acknowledgeforuser");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_AcknowledgeForUser == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Alert_DeactivateAlert = (PLibMCDataAlert_DeactivateAlertPtr) GetProcAddress(hLibrary, "libmcdata_alert_deactivatealert");
		#else // _WIN32
		pWrapperTable->m_Alert_DeactivateAlert = (PLibMCDataAlert_DeactivateAlertPtr) dlsym(hLibrary, "libmcdata_alert_deactivatealert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Alert_DeactivateAlert == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AlertIterator_GetCurrentAlert = (PLibMCDataAlertIterator_GetCurrentAlertPtr) GetProcAddress(hLibrary, "libmcdata_alertiterator_getcurrentalert");
		#else // _WIN32
		pWrapperTable->m_AlertIterator_GetCurrentAlert = (PLibMCDataAlertIterator_GetCurrentAlertPtr) dlsym(hLibrary, "libmcdata_alertiterator_getcurrentalert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AlertIterator_GetCurrentAlert == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AlertSession_AddAlert = (PLibMCDataAlertSession_AddAlertPtr) GetProcAddress(hLibrary, "libmcdata_alertsession_addalert");
		#else // _WIN32
		pWrapperTable->m_AlertSession_AddAlert = (PLibMCDataAlertSession_AddAlertPtr) dlsym(hLibrary, "libmcdata_alertsession_addalert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AlertSession_AddAlert == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AlertSession_HasAlert = (PLibMCDataAlertSession_HasAlertPtr) GetProcAddress(hLibrary, "libmcdata_alertsession_hasalert");
		#else // _WIN32
		pWrapperTable->m_AlertSession_HasAlert = (PLibMCDataAlertSession_HasAlertPtr) dlsym(hLibrary, "libmcdata_alertsession_hasalert");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AlertSession_HasAlert == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AlertSession_GetAlertByUUID = (PLibMCDataAlertSession_GetAlertByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_alertsession_getalertbyuuid");
		#else // _WIN32
		pWrapperTable->m_AlertSession_GetAlertByUUID = (PLibMCDataAlertSession_GetAlertByUUIDPtr) dlsym(hLibrary, "libmcdata_alertsession_getalertbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AlertSession_GetAlertByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AlertSession_RetrieveAlerts = (PLibMCDataAlertSession_RetrieveAlertsPtr) GetProcAddress(hLibrary, "libmcdata_alertsession_retrievealerts");
		#else // _WIN32
		pWrapperTable->m_AlertSession_RetrieveAlerts = (PLibMCDataAlertSession_RetrieveAlertsPtr) dlsym(hLibrary, "libmcdata_alertsession_retrievealerts");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AlertSession_RetrieveAlerts == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AlertSession_RetrieveAlertsByType = (PLibMCDataAlertSession_RetrieveAlertsByTypePtr) GetProcAddress(hLibrary, "libmcdata_alertsession_retrievealertsbytype");
		#else // _WIN32
		pWrapperTable->m_AlertSession_RetrieveAlertsByType = (PLibMCDataAlertSession_RetrieveAlertsByTypePtr) dlsym(hLibrary, "libmcdata_alertsession_retrievealertsbytype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AlertSession_RetrieveAlertsByType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalSession_GetSessionUUID = (PLibMCDataJournalSession_GetSessionUUIDPtr) GetProcAddress(hLibrary, "libmcdata_journalsession_getsessionuuid");
		#else // _WIN32
		pWrapperTable->m_JournalSession_GetSessionUUID = (PLibMCDataJournalSession_GetSessionUUIDPtr) dlsym(hLibrary, "libmcdata_journalsession_getsessionuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalSession_GetSessionUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalSession_WriteJournalChunkIntegerData = (PLibMCDataJournalSession_WriteJournalChunkIntegerDataPtr) GetProcAddress(hLibrary, "libmcdata_journalsession_writejournalchunkintegerdata");
		#else // _WIN32
		pWrapperTable->m_JournalSession_WriteJournalChunkIntegerData = (PLibMCDataJournalSession_WriteJournalChunkIntegerDataPtr) dlsym(hLibrary, "libmcdata_journalsession_writejournalchunkintegerdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalSession_WriteJournalChunkIntegerData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalSession_GetChunkCapacity = (PLibMCDataJournalSession_GetChunkCapacityPtr) GetProcAddress(hLibrary, "libmcdata_journalsession_getchunkcapacity");
		#else // _WIN32
		pWrapperTable->m_JournalSession_GetChunkCapacity = (PLibMCDataJournalSession_GetChunkCapacityPtr) dlsym(hLibrary, "libmcdata_journalsession_getchunkcapacity");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalSession_GetChunkCapacity == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_JournalSession_GetFlushInterval = (PLibMCDataJournalSession_GetFlushIntervalPtr) GetProcAddress(hLibrary, "libmcdata_journalsession_getflushinterval");
		#else // _WIN32
		pWrapperTable->m_JournalSession_GetFlushInterval = (PLibMCDataJournalSession_GetFlushIntervalPtr) dlsym(hLibrary, "libmcdata_journalsession_getflushinterval");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_JournalSession_GetFlushInterval == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetUUID = (PLibMCDataStorageStream_GetUUIDPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getuuid");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetUUID = (PLibMCDataStorageStream_GetUUIDPtr) dlsym(hLibrary, "libmcdata_storagestream_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetTimeStamp = (PLibMCDataStorageStream_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetTimeStamp = (PLibMCDataStorageStream_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_storagestream_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetContextIdentifier = (PLibMCDataStorageStream_GetContextIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcontextidentifier");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetContextIdentifier = (PLibMCDataStorageStream_GetContextIdentifierPtr) dlsym(hLibrary, "libmcdata_storagestream_getcontextidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetContextIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetName = (PLibMCDataStorageStream_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getname");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetName = (PLibMCDataStorageStream_GetNamePtr) dlsym(hLibrary, "libmcdata_storagestream_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetMIMEType = (PLibMCDataStorageStream_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getmimetype");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetMIMEType = (PLibMCDataStorageStream_GetMIMETypePtr) dlsym(hLibrary, "libmcdata_storagestream_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetMIMEType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetSHA2 = (PLibMCDataStorageStream_GetSHA2Ptr) GetProcAddress(hLibrary, "libmcdata_storagestream_getsha2");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetSHA2 = (PLibMCDataStorageStream_GetSHA2Ptr) dlsym(hLibrary, "libmcdata_storagestream_getsha2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetSHA2 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetSize = (PLibMCDataStorageStream_GetSizePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getsize");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetSize = (PLibMCDataStorageStream_GetSizePtr) dlsym(hLibrary, "libmcdata_storagestream_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetContent = (PLibMCDataStorageStream_GetContentPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcontent");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetContent = (PLibMCDataStorageStream_GetContentPtr) dlsym(hLibrary, "libmcdata_storagestream_getcontent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetContent == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetCallbacks = (PLibMCDataStorageStream_GetCallbacksPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcallbacks");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetCallbacks = (PLibMCDataStorageStream_GetCallbacksPtr) dlsym(hLibrary, "libmcdata_storagestream_getcallbacks");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetCallbacks == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageZIPWriter_StartNewEntry = (PLibMCDataStorageZIPWriter_StartNewEntryPtr) GetProcAddress(hLibrary, "libmcdata_storagezipwriter_startnewentry");
		#else // _WIN32
		pWrapperTable->m_StorageZIPWriter_StartNewEntry = (PLibMCDataStorageZIPWriter_StartNewEntryPtr) dlsym(hLibrary, "libmcdata_storagezipwriter_startnewentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageZIPWriter_StartNewEntry == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageZIPWriter_FinishCurrentEntry = (PLibMCDataStorageZIPWriter_FinishCurrentEntryPtr) GetProcAddress(hLibrary, "libmcdata_storagezipwriter_finishcurrententry");
		#else // _WIN32
		pWrapperTable->m_StorageZIPWriter_FinishCurrentEntry = (PLibMCDataStorageZIPWriter_FinishCurrentEntryPtr) dlsym(hLibrary, "libmcdata_storagezipwriter_finishcurrententry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageZIPWriter_FinishCurrentEntry == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageZIPWriter_GetOpenEntryID = (PLibMCDataStorageZIPWriter_GetOpenEntryIDPtr) GetProcAddress(hLibrary, "libmcdata_storagezipwriter_getopenentryid");
		#else // _WIN32
		pWrapperTable->m_StorageZIPWriter_GetOpenEntryID = (PLibMCDataStorageZIPWriter_GetOpenEntryIDPtr) dlsym(hLibrary, "libmcdata_storagezipwriter_getopenentryid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageZIPWriter_GetOpenEntryID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageZIPWriter_WriteData = (PLibMCDataStorageZIPWriter_WriteDataPtr) GetProcAddress(hLibrary, "libmcdata_storagezipwriter_writedata");
		#else // _WIN32
		pWrapperTable->m_StorageZIPWriter_WriteData = (PLibMCDataStorageZIPWriter_WriteDataPtr) dlsym(hLibrary, "libmcdata_storagezipwriter_writedata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageZIPWriter_WriteData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageZIPWriter_GetEntrySize = (PLibMCDataStorageZIPWriter_GetEntrySizePtr) GetProcAddress(hLibrary, "libmcdata_storagezipwriter_getentrysize");
		#else // _WIN32
		pWrapperTable->m_StorageZIPWriter_GetEntrySize = (PLibMCDataStorageZIPWriter_GetEntrySizePtr) dlsym(hLibrary, "libmcdata_storagezipwriter_getentrysize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageZIPWriter_GetEntrySize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageZIPWriter_GetZIPStreamSize = (PLibMCDataStorageZIPWriter_GetZIPStreamSizePtr) GetProcAddress(hLibrary, "libmcdata_storagezipwriter_getzipstreamsize");
		#else // _WIN32
		pWrapperTable->m_StorageZIPWriter_GetZIPStreamSize = (PLibMCDataStorageZIPWriter_GetZIPStreamSizePtr) dlsym(hLibrary, "libmcdata_storagezipwriter_getzipstreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageZIPWriter_GetZIPStreamSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageZIPWriter_Finish = (PLibMCDataStorageZIPWriter_FinishPtr) GetProcAddress(hLibrary, "libmcdata_storagezipwriter_finish");
		#else // _WIN32
		pWrapperTable->m_StorageZIPWriter_Finish = (PLibMCDataStorageZIPWriter_FinishPtr) dlsym(hLibrary, "libmcdata_storagezipwriter_finish");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageZIPWriter_Finish == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageZIPWriter_IsFinished = (PLibMCDataStorageZIPWriter_IsFinishedPtr) GetProcAddress(hLibrary, "libmcdata_storagezipwriter_isfinished");
		#else // _WIN32
		pWrapperTable->m_StorageZIPWriter_IsFinished = (PLibMCDataStorageZIPWriter_IsFinishedPtr) dlsym(hLibrary, "libmcdata_storagezipwriter_isfinished");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageZIPWriter_IsFinished == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StreamIsReady = (PLibMCDataStorage_StreamIsReadyPtr) GetProcAddress(hLibrary, "libmcdata_storage_streamisready");
		#else // _WIN32
		pWrapperTable->m_Storage_StreamIsReady = (PLibMCDataStorage_StreamIsReadyPtr) dlsym(hLibrary, "libmcdata_storage_streamisready");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StreamIsReady == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_RetrieveStream = (PLibMCDataStorage_RetrieveStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_retrievestream");
		#else // _WIN32
		pWrapperTable->m_Storage_RetrieveStream = (PLibMCDataStorage_RetrieveStreamPtr) dlsym(hLibrary, "libmcdata_storage_retrievestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_RetrieveStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StoreNewStream = (PLibMCDataStorage_StoreNewStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_storenewstream");
		#else // _WIN32
		pWrapperTable->m_Storage_StoreNewStream = (PLibMCDataStorage_StoreNewStreamPtr) dlsym(hLibrary, "libmcdata_storage_storenewstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StoreNewStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_BeginPartialStream = (PLibMCDataStorage_BeginPartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_beginpartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_BeginPartialStream = (PLibMCDataStorage_BeginPartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_beginpartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_BeginPartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StorePartialStream = (PLibMCDataStorage_StorePartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_storepartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_StorePartialStream = (PLibMCDataStorage_StorePartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_storepartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StorePartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_FinishPartialStream = (PLibMCDataStorage_FinishPartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_finishpartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_FinishPartialStream = (PLibMCDataStorage_FinishPartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_finishpartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_FinishPartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 = (PLibMCDataStorage_FinishPartialStreamBlockwiseSHA256Ptr) GetProcAddress(hLibrary, "libmcdata_storage_finishpartialstreamblockwisesha256");
		#else // _WIN32
		pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 = (PLibMCDataStorage_FinishPartialStreamBlockwiseSHA256Ptr) dlsym(hLibrary, "libmcdata_storage_finishpartialstreamblockwisesha256");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_BeginRandomWriteStream = (PLibMCDataStorage_BeginRandomWriteStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_beginrandomwritestream");
		#else // _WIN32
		pWrapperTable->m_Storage_BeginRandomWriteStream = (PLibMCDataStorage_BeginRandomWriteStreamPtr) dlsym(hLibrary, "libmcdata_storage_beginrandomwritestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_BeginRandomWriteStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StoreRandomWriteStream = (PLibMCDataStorage_StoreRandomWriteStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_storerandomwritestream");
		#else // _WIN32
		pWrapperTable->m_Storage_StoreRandomWriteStream = (PLibMCDataStorage_StoreRandomWriteStreamPtr) dlsym(hLibrary, "libmcdata_storage_storerandomwritestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StoreRandomWriteStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_GetRandomWriteStreamSize = (PLibMCDataStorage_GetRandomWriteStreamSizePtr) GetProcAddress(hLibrary, "libmcdata_storage_getrandomwritestreamsize");
		#else // _WIN32
		pWrapperTable->m_Storage_GetRandomWriteStreamSize = (PLibMCDataStorage_GetRandomWriteStreamSizePtr) dlsym(hLibrary, "libmcdata_storage_getrandomwritestreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_GetRandomWriteStreamSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_FinishRandomWriteStream = (PLibMCDataStorage_FinishRandomWriteStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_finishrandomwritestream");
		#else // _WIN32
		pWrapperTable->m_Storage_FinishRandomWriteStream = (PLibMCDataStorage_FinishRandomWriteStreamPtr) dlsym(hLibrary, "libmcdata_storage_finishrandomwritestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_FinishRandomWriteStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_GetMaxStreamSize = (PLibMCDataStorage_GetMaxStreamSizePtr) GetProcAddress(hLibrary, "libmcdata_storage_getmaxstreamsize");
		#else // _WIN32
		pWrapperTable->m_Storage_GetMaxStreamSize = (PLibMCDataStorage_GetMaxStreamSizePtr) dlsym(hLibrary, "libmcdata_storage_getmaxstreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_GetMaxStreamSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_CreateZIPStream = (PLibMCDataStorage_CreateZIPStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_createzipstream");
		#else // _WIN32
		pWrapperTable->m_Storage_CreateZIPStream = (PLibMCDataStorage_CreateZIPStreamPtr) dlsym(hLibrary, "libmcdata_storage_createzipstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_CreateZIPStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_ContentTypeIsAccepted = (PLibMCDataStorage_ContentTypeIsAcceptedPtr) GetProcAddress(hLibrary, "libmcdata_storage_contenttypeisaccepted");
		#else // _WIN32
		pWrapperTable->m_Storage_ContentTypeIsAccepted = (PLibMCDataStorage_ContentTypeIsAcceptedPtr) dlsym(hLibrary, "libmcdata_storage_contenttypeisaccepted");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_ContentTypeIsAccepted == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StreamIsImage = (PLibMCDataStorage_StreamIsImagePtr) GetProcAddress(hLibrary, "libmcdata_storage_streamisimage");
		#else // _WIN32
		pWrapperTable->m_Storage_StreamIsImage = (PLibMCDataStorage_StreamIsImagePtr) dlsym(hLibrary, "libmcdata_storage_streamisimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StreamIsImage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_CreateDownloadTicket = (PLibMCDataStorage_CreateDownloadTicketPtr) GetProcAddress(hLibrary, "libmcdata_storage_createdownloadticket");
		#else // _WIN32
		pWrapperTable->m_Storage_CreateDownloadTicket = (PLibMCDataStorage_CreateDownloadTicketPtr) dlsym(hLibrary, "libmcdata_storage_createdownloadticket");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_CreateDownloadTicket == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_RequestDownloadTicket = (PLibMCDataStorage_RequestDownloadTicketPtr) GetProcAddress(hLibrary, "libmcdata_storage_requestdownloadticket");
		#else // _WIN32
		pWrapperTable->m_Storage_RequestDownloadTicket = (PLibMCDataStorage_RequestDownloadTicketPtr) dlsym(hLibrary, "libmcdata_storage_requestdownloadticket");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_RequestDownloadTicket == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_AttachStreamToJournal = (PLibMCDataStorage_AttachStreamToJournalPtr) GetProcAddress(hLibrary, "libmcdata_storage_attachstreamtojournal");
		#else // _WIN32
		pWrapperTable->m_Storage_AttachStreamToJournal = (PLibMCDataStorage_AttachStreamToJournalPtr) dlsym(hLibrary, "libmcdata_storage_attachstreamtojournal");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_AttachStreamToJournal == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetDataUUID = (PLibMCDataCustomDataStream_GetDataUUIDPtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getdatauuid");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetDataUUID = (PLibMCDataCustomDataStream_GetDataUUIDPtr) dlsym(hLibrary, "libmcdata_customdatastream_getdatauuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetDataUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetIdentifier = (PLibMCDataCustomDataStream_GetIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getidentifier");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetIdentifier = (PLibMCDataCustomDataStream_GetIdentifierPtr) dlsym(hLibrary, "libmcdata_customdatastream_getidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetName = (PLibMCDataCustomDataStream_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getname");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetName = (PLibMCDataCustomDataStream_GetNamePtr) dlsym(hLibrary, "libmcdata_customdatastream_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetTimeStamp = (PLibMCDataCustomDataStream_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetTimeStamp = (PLibMCDataCustomDataStream_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_customdatastream_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetStorageStream = (PLibMCDataCustomDataStream_GetStorageStreamPtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getstoragestream");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetStorageStream = (PLibMCDataCustomDataStream_GetStorageStreamPtr) dlsym(hLibrary, "libmcdata_customdatastream_getstoragestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetStorageStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetStorageStreamUUID = (PLibMCDataCustomDataStream_GetStorageStreamUUIDPtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getstoragestreamuuid");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetStorageStreamUUID = (PLibMCDataCustomDataStream_GetStorageStreamUUIDPtr) dlsym(hLibrary, "libmcdata_customdatastream_getstoragestreamuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetStorageStreamUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetStorageStreamSHA2 = (PLibMCDataCustomDataStream_GetStorageStreamSHA2Ptr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getstoragestreamsha2");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetStorageStreamSHA2 = (PLibMCDataCustomDataStream_GetStorageStreamSHA2Ptr) dlsym(hLibrary, "libmcdata_customdatastream_getstoragestreamsha2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetStorageStreamSHA2 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetStorageStreamSize = (PLibMCDataCustomDataStream_GetStorageStreamSizePtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getstoragestreamsize");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetStorageStreamSize = (PLibMCDataCustomDataStream_GetStorageStreamSizePtr) dlsym(hLibrary, "libmcdata_customdatastream_getstoragestreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetStorageStreamSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetUserUUID = (PLibMCDataCustomDataStream_GetUserUUIDPtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getuseruuid");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetUserUUID = (PLibMCDataCustomDataStream_GetUserUUIDPtr) dlsym(hLibrary, "libmcdata_customdatastream_getuseruuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetUserUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetDataType = (PLibMCDataCustomDataStream_GetDataTypePtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getdatatype");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetDataType = (PLibMCDataCustomDataStream_GetDataTypePtr) dlsym(hLibrary, "libmcdata_customdatastream_getdatatype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetDataType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetDataTypeAsString = (PLibMCDataCustomDataStream_GetDataTypeAsStringPtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getdatatypeasstring");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetDataTypeAsString = (PLibMCDataCustomDataStream_GetDataTypeAsStringPtr) dlsym(hLibrary, "libmcdata_customdatastream_getdatatypeasstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetDataTypeAsString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CustomDataStream_GetMIMEType = (PLibMCDataCustomDataStream_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcdata_customdatastream_getmimetype");
		#else // _WIN32
		pWrapperTable->m_CustomDataStream_GetMIMEType = (PLibMCDataCustomDataStream_GetMIMETypePtr) dlsym(hLibrary, "libmcdata_customdatastream_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CustomDataStream_GetMIMEType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetJobUUID = (PLibMCDataBuildJobData_GetJobUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getjobuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetJobUUID = (PLibMCDataBuildJobData_GetJobUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getjobuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetJobUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = (PLibMCDataBuildJobDataIterator_GetCurrentJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdataiterator_getcurrentjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = (PLibMCDataBuildJobDataIterator_GetCurrentJobDataPtr) dlsym(hLibrary, "libmcdata_buildjobdataiterator_getcurrentjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecutionData_GetExecutionUUID = (PLibMCDataBuildJobExecutionData_GetExecutionUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecutiondata_getexecutionuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecutionData_GetExecutionUUID = (PLibMCDataBuildJobExecutionData_GetExecutionUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobexecutiondata_getexecutionuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecutionData_GetExecutionUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecutionDataIterator_GetCurrentJobExecutionData = (PLibMCDataBuildJobExecutionDataIterator_GetCurrentJobExecutionDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecutiondataiterator_getcurrentjobexecutiondata");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecutionDataIterator_GetCurrentJobExecutionData = (PLibMCDataBuildJobExecutionDataIterator_GetCurrentJobExecutionDataPtr) dlsym(hLibrary, "libmcdata_buildjobexecutiondataiterator_getcurrentjobexecutiondata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecutionDataIterator_GetCurrentJobExecutionData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_GetExecutionUUID = (PLibMCDataBuildJobExecution_GetExecutionUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_getexecutionuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_GetExecutionUUID = (PLibMCDataBuildJobExecution_GetExecutionUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_getexecutionuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_GetExecutionUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_GetJobUUID = (PLibMCDataBuildJobExecution_GetJobUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_getjobuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_GetJobUUID = (PLibMCDataBuildJobExecution_GetJobUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_getjobuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_GetJobUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_GetStatus = (PLibMCDataBuildJobExecution_GetStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_getstatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_GetStatus = (PLibMCDataBuildJobExecution_GetStatusPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_GetStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_ChangeStatus = (PLibMCDataBuildJobExecution_ChangeStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_changestatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_ChangeStatus = (PLibMCDataBuildJobExecution_ChangeStatusPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_changestatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_ChangeStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_GetDescription = (PLibMCDataBuildJobExecution_GetDescriptionPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_getdescription");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_GetDescription = (PLibMCDataBuildJobExecution_GetDescriptionPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_getdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_GetDescription == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_SetDescription = (PLibMCDataBuildJobExecution_SetDescriptionPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_setdescription");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_SetDescription = (PLibMCDataBuildJobExecution_SetDescriptionPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_setdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_SetDescription == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_GetJournalUUID = (PLibMCDataBuildJobExecution_GetJournalUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_getjournaluuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_GetJournalUUID = (PLibMCDataBuildJobExecution_GetJournalUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_getjournaluuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_GetJournalUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_GetUserUUID = (PLibMCDataBuildJobExecution_GetUserUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_getuseruuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_GetUserUUID = (PLibMCDataBuildJobExecution_GetUserUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_getuseruuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_GetUserUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_GetStartTimeStampInMicroseconds = (PLibMCDataBuildJobExecution_GetStartTimeStampInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_getstarttimestampinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_GetStartTimeStampInMicroseconds = (PLibMCDataBuildJobExecution_GetStartTimeStampInMicrosecondsPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_getstarttimestampinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_GetStartTimeStampInMicroseconds == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_GetEndTimeStampInMicroseconds = (PLibMCDataBuildJobExecution_GetEndTimeStampInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_getendtimestampinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_GetEndTimeStampInMicroseconds = (PLibMCDataBuildJobExecution_GetEndTimeStampInMicrosecondsPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_getendtimestampinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_GetEndTimeStampInMicroseconds == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_ComputeElapsedTimeInMicroseconds = (PLibMCDataBuildJobExecution_ComputeElapsedTimeInMicrosecondsPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_computeelapsedtimeinmicroseconds");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_ComputeElapsedTimeInMicroseconds = (PLibMCDataBuildJobExecution_ComputeElapsedTimeInMicrosecondsPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_computeelapsedtimeinmicroseconds");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_ComputeElapsedTimeInMicroseconds == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_AddJobExecutionData = (PLibMCDataBuildJobExecution_AddJobExecutionDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_addjobexecutiondata");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_AddJobExecutionData = (PLibMCDataBuildJobExecution_AddJobExecutionDataPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_addjobexecutiondata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_AddJobExecutionData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_ListJobExecutionDataByType = (PLibMCDataBuildJobExecution_ListJobExecutionDataByTypePtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_listjobexecutiondatabytype");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_ListJobExecutionDataByType = (PLibMCDataBuildJobExecution_ListJobExecutionDataByTypePtr) dlsym(hLibrary, "libmcdata_buildjobexecution_listjobexecutiondatabytype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_ListJobExecutionDataByType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_ListJobExecutionData = (PLibMCDataBuildJobExecution_ListJobExecutionDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_listjobexecutiondata");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_ListJobExecutionData = (PLibMCDataBuildJobExecution_ListJobExecutionDataPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_listjobexecutiondata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_ListJobExecutionData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionData = (PLibMCDataBuildJobExecution_RetrieveJobExecutionDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_retrievejobexecutiondata");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionData = (PLibMCDataBuildJobExecution_RetrieveJobExecutionDataPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_retrievejobexecutiondata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionDataByIdentifier = (PLibMCDataBuildJobExecution_RetrieveJobExecutionDataByIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_retrievejobexecutiondatabyidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionDataByIdentifier = (PLibMCDataBuildJobExecution_RetrieveJobExecutionDataByIdentifierPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_retrievejobexecutiondatabyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionDataByIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_HasJobExecutionDataUUID = (PLibMCDataBuildJobExecution_HasJobExecutionDataUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_hasjobexecutiondatauuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_HasJobExecutionDataUUID = (PLibMCDataBuildJobExecution_HasJobExecutionDataUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_hasjobexecutiondatauuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_HasJobExecutionDataUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_HasJobExecutionDataIdentifier = (PLibMCDataBuildJobExecution_HasJobExecutionDataIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_hasjobexecutiondataidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_HasJobExecutionDataIdentifier = (PLibMCDataBuildJobExecution_HasJobExecutionDataIdentifierPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_hasjobexecutiondataidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_HasJobExecutionDataIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_StoreMetaDataString = (PLibMCDataBuildJobExecution_StoreMetaDataStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_storemetadatastring");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_StoreMetaDataString = (PLibMCDataBuildJobExecution_StoreMetaDataStringPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_storemetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_StoreMetaDataString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_HasMetaDataString = (PLibMCDataBuildJobExecution_HasMetaDataStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_hasmetadatastring");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_HasMetaDataString = (PLibMCDataBuildJobExecution_HasMetaDataStringPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_hasmetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_HasMetaDataString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecution_GetMetaDataString = (PLibMCDataBuildJobExecution_GetMetaDataStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecution_getmetadatastring");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecution_GetMetaDataString = (PLibMCDataBuildJobExecution_GetMetaDataStringPtr) dlsym(hLibrary, "libmcdata_buildjobexecution_getmetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecution_GetMetaDataString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobExecutionIterator_GetCurrentJobExecution = (PLibMCDataBuildJobExecutionIterator_GetCurrentJobExecutionPtr) GetProcAddress(hLibrary, "libmcdata_buildjobexecutioniterator_getcurrentjobexecution");
		#else // _WIN32
		pWrapperTable->m_BuildJobExecutionIterator_GetCurrentJobExecution = (PLibMCDataBuildJobExecutionIterator_GetCurrentJobExecutionPtr) dlsym(hLibrary, "libmcdata_buildjobexecutioniterator_getcurrentjobexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobExecutionIterator_GetCurrentJobExecution == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetUUID = (PLibMCDataBuildJob_GetUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetUUID = (PLibMCDataBuildJob_GetUUIDPtr) dlsym(hLibrary, "libmcdata_buildjob_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetName = (PLibMCDataBuildJob_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getname");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetName = (PLibMCDataBuildJob_GetNamePtr) dlsym(hLibrary, "libmcdata_buildjob_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStatus = (PLibMCDataBuildJob_GetStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstatus");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStatus = (PLibMCDataBuildJob_GetStatusPtr) dlsym(hLibrary, "libmcdata_buildjob_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetLayerCount = (PLibMCDataBuildJob_GetLayerCountPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getlayercount");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetLayerCount = (PLibMCDataBuildJob_GetLayerCountPtr) dlsym(hLibrary, "libmcdata_buildjob_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetLayerCount == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetTimeStamp = (PLibMCDataBuildJob_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetTimeStamp = (PLibMCDataBuildJob_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_buildjob_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStorageStream = (PLibMCDataBuildJob_GetStorageStreamPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstoragestream");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStorageStream = (PLibMCDataBuildJob_GetStorageStreamPtr) dlsym(hLibrary, "libmcdata_buildjob_getstoragestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStorageStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = (PLibMCDataBuildJob_GetStorageStreamUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstoragestreamuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = (PLibMCDataBuildJob_GetStorageStreamUUIDPtr) dlsym(hLibrary, "libmcdata_buildjob_getstoragestreamuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStorageStreamUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_StartValidating = (PLibMCDataBuildJob_StartValidatingPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_startvalidating");
		#else // _WIN32
		pWrapperTable->m_BuildJob_StartValidating = (PLibMCDataBuildJob_StartValidatingPtr) dlsym(hLibrary, "libmcdata_buildjob_startvalidating");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_StartValidating == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_FinishValidating = (PLibMCDataBuildJob_FinishValidatingPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_finishvalidating");
		#else // _WIN32
		pWrapperTable->m_BuildJob_FinishValidating = (PLibMCDataBuildJob_FinishValidatingPtr) dlsym(hLibrary, "libmcdata_buildjob_finishvalidating");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_FinishValidating == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ArchiveJob = (PLibMCDataBuildJob_ArchiveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_archivejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ArchiveJob = (PLibMCDataBuildJob_ArchiveJobPtr) dlsym(hLibrary, "libmcdata_buildjob_archivejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ArchiveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_UnArchiveJob = (PLibMCDataBuildJob_UnArchiveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_unarchivejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_UnArchiveJob = (PLibMCDataBuildJob_UnArchiveJobPtr) dlsym(hLibrary, "libmcdata_buildjob_unarchivejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_UnArchiveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_DeleteJob = (PLibMCDataBuildJob_DeleteJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_deletejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_DeleteJob = (PLibMCDataBuildJob_DeleteJobPtr) dlsym(hLibrary, "libmcdata_buildjob_deletejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_DeleteJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_JobCanBeArchived = (PLibMCDataBuildJob_JobCanBeArchivedPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_jobcanbearchived");
		#else // _WIN32
		pWrapperTable->m_BuildJob_JobCanBeArchived = (PLibMCDataBuildJob_JobCanBeArchivedPtr) dlsym(hLibrary, "libmcdata_buildjob_jobcanbearchived");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_JobCanBeArchived == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_AddJobData = (PLibMCDataBuildJob_AddJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_addjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_AddJobData = (PLibMCDataBuildJob_AddJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_addjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_AddJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ListJobDataByType = (PLibMCDataBuildJob_ListJobDataByTypePtr) GetProcAddress(hLibrary, "libmcdata_buildjob_listjobdatabytype");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ListJobDataByType = (PLibMCDataBuildJob_ListJobDataByTypePtr) dlsym(hLibrary, "libmcdata_buildjob_listjobdatabytype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ListJobDataByType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ListJobData = (PLibMCDataBuildJob_ListJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_listjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ListJobData = (PLibMCDataBuildJob_ListJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_listjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ListJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_RetrieveJobData = (PLibMCDataBuildJob_RetrieveJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_retrievejobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_RetrieveJobData = (PLibMCDataBuildJob_RetrieveJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_retrievejobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_RetrieveJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_RetrieveJobDataByIdentifier = (PLibMCDataBuildJob_RetrieveJobDataByIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_retrievejobdatabyidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildJob_RetrieveJobDataByIdentifier = (PLibMCDataBuildJob_RetrieveJobDataByIdentifierPtr) dlsym(hLibrary, "libmcdata_buildjob_retrievejobdatabyidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_RetrieveJobDataByIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_HasJobDataUUID = (PLibMCDataBuildJob_HasJobDataUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_hasjobdatauuid");
		#else // _WIN32
		pWrapperTable->m_BuildJob_HasJobDataUUID = (PLibMCDataBuildJob_HasJobDataUUIDPtr) dlsym(hLibrary, "libmcdata_buildjob_hasjobdatauuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_HasJobDataUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_HasJobDataIdentifier = (PLibMCDataBuildJob_HasJobDataIdentifierPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_hasjobdataidentifier");
		#else // _WIN32
		pWrapperTable->m_BuildJob_HasJobDataIdentifier = (PLibMCDataBuildJob_HasJobDataIdentifierPtr) dlsym(hLibrary, "libmcdata_buildjob_hasjobdataidentifier");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_HasJobDataIdentifier == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_StoreMetaDataString = (PLibMCDataBuildJob_StoreMetaDataStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_storemetadatastring");
		#else // _WIN32
		pWrapperTable->m_BuildJob_StoreMetaDataString = (PLibMCDataBuildJob_StoreMetaDataStringPtr) dlsym(hLibrary, "libmcdata_buildjob_storemetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_StoreMetaDataString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_HasMetaDataString = (PLibMCDataBuildJob_HasMetaDataStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_hasmetadatastring");
		#else // _WIN32
		pWrapperTable->m_BuildJob_HasMetaDataString = (PLibMCDataBuildJob_HasMetaDataStringPtr) dlsym(hLibrary, "libmcdata_buildjob_hasmetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_HasMetaDataString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetMetaDataString = (PLibMCDataBuildJob_GetMetaDataStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getmetadatastring");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetMetaDataString = (PLibMCDataBuildJob_GetMetaDataStringPtr) dlsym(hLibrary, "libmcdata_buildjob_getmetadatastring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetMetaDataString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_CreateBuildJobExecution = (PLibMCDataBuildJob_CreateBuildJobExecutionPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_createbuildjobexecution");
		#else // _WIN32
		pWrapperTable->m_BuildJob_CreateBuildJobExecution = (PLibMCDataBuildJob_CreateBuildJobExecutionPtr) dlsym(hLibrary, "libmcdata_buildjob_createbuildjobexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_CreateBuildJobExecution == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_RetrieveBuildJobExecution = (PLibMCDataBuildJob_RetrieveBuildJobExecutionPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_retrievebuildjobexecution");
		#else // _WIN32
		pWrapperTable->m_BuildJob_RetrieveBuildJobExecution = (PLibMCDataBuildJob_RetrieveBuildJobExecutionPtr) dlsym(hLibrary, "libmcdata_buildjob_retrievebuildjobexecution");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_RetrieveBuildJobExecution == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_RetrieveBuildJobExecutions = (PLibMCDataBuildJob_RetrieveBuildJobExecutionsPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_retrievebuildjobexecutions");
		#else // _WIN32
		pWrapperTable->m_BuildJob_RetrieveBuildJobExecutions = (PLibMCDataBuildJob_RetrieveBuildJobExecutionsPtr) dlsym(hLibrary, "libmcdata_buildjob_retrievebuildjobexecutions");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_RetrieveBuildJobExecutions == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_RetrieveBuildJobExecutionsByStatus = (PLibMCDataBuildJob_RetrieveBuildJobExecutionsByStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_retrievebuildjobexecutionsbystatus");
		#else // _WIN32
		pWrapperTable->m_BuildJob_RetrieveBuildJobExecutionsByStatus = (PLibMCDataBuildJob_RetrieveBuildJobExecutionsByStatusPtr) dlsym(hLibrary, "libmcdata_buildjob_retrievebuildjobexecutionsbystatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_RetrieveBuildJobExecutionsByStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = (PLibMCDataBuildJobIterator_GetCurrentJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobiterator_getcurrentjob");
		#else // _WIN32
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = (PLibMCDataBuildJobIterator_GetCurrentJobPtr) dlsym(hLibrary, "libmcdata_buildjobiterator_getcurrentjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobIterator_GetCurrentJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_CreateJob = (PLibMCDataBuildJobHandler_CreateJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_createjob");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_CreateJob = (PLibMCDataBuildJobHandler_CreateJobPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_createjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_CreateJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_RetrieveJob = (PLibMCDataBuildJobHandler_RetrieveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_retrievejob");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_RetrieveJob = (PLibMCDataBuildJobHandler_RetrieveJobPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_retrievejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_RetrieveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_FindJobOfData = (PLibMCDataBuildJobHandler_FindJobOfDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_findjobofdata");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_FindJobOfData = (PLibMCDataBuildJobHandler_FindJobOfDataPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_findjobofdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_FindJobOfData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = (PLibMCDataBuildJobHandler_ListJobsByStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_listjobsbystatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = (PLibMCDataBuildJobHandler_ListJobsByStatusPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_listjobsbystatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ListJobsByStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = (PLibMCDataBuildJobHandler_ConvertBuildStatusToStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_convertbuildstatustostring");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = (PLibMCDataBuildJobHandler_ConvertBuildStatusToStringPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_convertbuildstatustostring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = (PLibMCDataBuildJobHandler_ConvertStringToBuildStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_convertstringtobuildstatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = (PLibMCDataBuildJobHandler_ConvertStringToBuildStatusPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_convertstringtobuildstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserList_Count = (PLibMCDataUserList_CountPtr) GetProcAddress(hLibrary, "libmcdata_userlist_count");
		#else // _WIN32
		pWrapperTable->m_UserList_Count = (PLibMCDataUserList_CountPtr) dlsym(hLibrary, "libmcdata_userlist_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserList_Count == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_UserList_GetUserProperties = (PLibMCDataUserList_GetUserPropertiesPtr) GetProcAddress(hLibrary, "libmcdata_userlist_getuserproperties");
		#else // _WIN32
		pWrapperTable->m_UserList_GetUserProperties = (PLibMCDataUserList_GetUserPropertiesPtr) dlsym(hLibrary, "libmcdata_userlist_getuserproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_UserList_GetUserProperties == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_UserExists = (PLibMCDataLoginHandler_UserExistsPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_userexists");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_UserExists = (PLibMCDataLoginHandler_UserExistsPtr) dlsym(hLibrary, "libmcdata_loginhandler_userexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_UserExists == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_UserUUIDExists = (PLibMCDataLoginHandler_UserUUIDExistsPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_useruuidexists");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_UserUUIDExists = (PLibMCDataLoginHandler_UserUUIDExistsPtr) dlsym(hLibrary, "libmcdata_loginhandler_useruuidexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_UserUUIDExists == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserDetails = (PLibMCDataLoginHandler_GetUserDetailsPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserdetails");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserDetails = (PLibMCDataLoginHandler_GetUserDetailsPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserdetails");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserDetails == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserProperties = (PLibMCDataLoginHandler_GetUserPropertiesPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserproperties");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserProperties = (PLibMCDataLoginHandler_GetUserPropertiesPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserproperties");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserProperties == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID = (PLibMCDataLoginHandler_GetUserPropertiesByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserpropertiesbyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID = (PLibMCDataLoginHandler_GetUserPropertiesByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserpropertiesbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUsernameByUUID = (PLibMCDataLoginHandler_GetUsernameByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getusernamebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUsernameByUUID = (PLibMCDataLoginHandler_GetUsernameByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getusernamebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUsernameByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserUUID = (PLibMCDataLoginHandler_GetUserUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuseruuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserUUID = (PLibMCDataLoginHandler_GetUserUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuseruuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserDescription = (PLibMCDataLoginHandler_GetUserDescriptionPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserdescription");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserDescription = (PLibMCDataLoginHandler_GetUserDescriptionPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserDescription == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID = (PLibMCDataLoginHandler_GetUserDescriptionByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserdescriptionbyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID = (PLibMCDataLoginHandler_GetUserDescriptionByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserdescriptionbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserRole = (PLibMCDataLoginHandler_GetUserRolePtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserrole");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserRole = (PLibMCDataLoginHandler_GetUserRolePtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserrole");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserRole == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserRoleByUUID = (PLibMCDataLoginHandler_GetUserRoleByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserrolebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserRoleByUUID = (PLibMCDataLoginHandler_GetUserRoleByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserrolebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserRoleByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserLanguage = (PLibMCDataLoginHandler_GetUserLanguagePtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserlanguage");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserLanguage = (PLibMCDataLoginHandler_GetUserLanguagePtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserLanguage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserLanguageByUUID = (PLibMCDataLoginHandler_GetUserLanguageByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserlanguagebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserLanguageByUUID = (PLibMCDataLoginHandler_GetUserLanguageByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserlanguagebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserLanguageByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_CreateUser = (PLibMCDataLoginHandler_CreateUserPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_createuser");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_CreateUser = (PLibMCDataLoginHandler_CreateUserPtr) dlsym(hLibrary, "libmcdata_loginhandler_createuser");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_CreateUser == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserLanguage = (PLibMCDataLoginHandler_SetUserLanguagePtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserlanguage");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserLanguage = (PLibMCDataLoginHandler_SetUserLanguagePtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserlanguage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserLanguage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserRole = (PLibMCDataLoginHandler_SetUserRolePtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserrole");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserRole = (PLibMCDataLoginHandler_SetUserRolePtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserrole");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserRole == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserDescription = (PLibMCDataLoginHandler_SetUserDescriptionPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserdescription");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserDescription = (PLibMCDataLoginHandler_SetUserDescriptionPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserdescription");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserDescription == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserPassword = (PLibMCDataLoginHandler_SetUserPasswordPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserpassword");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserPassword = (PLibMCDataLoginHandler_SetUserPasswordPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserpassword");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserPassword == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserLanguageByUUID = (PLibMCDataLoginHandler_SetUserLanguageByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserlanguagebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserLanguageByUUID = (PLibMCDataLoginHandler_SetUserLanguageByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserlanguagebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserLanguageByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserRoleByUUID = (PLibMCDataLoginHandler_SetUserRoleByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserrolebyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserRoleByUUID = (PLibMCDataLoginHandler_SetUserRoleByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserrolebyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserRoleByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID = (PLibMCDataLoginHandler_SetUserDescriptionByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserdescriptionbyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID = (PLibMCDataLoginHandler_SetUserDescriptionByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserdescriptionbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_SetUserPasswordByUUID = (PLibMCDataLoginHandler_SetUserPasswordByUUIDPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_setuserpasswordbyuuid");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_SetUserPasswordByUUID = (PLibMCDataLoginHandler_SetUserPasswordByUUIDPtr) dlsym(hLibrary, "libmcdata_loginhandler_setuserpasswordbyuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_SetUserPasswordByUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetActiveUsers = (PLibMCDataLoginHandler_GetActiveUsersPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getactiveusers");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetActiveUsers = (PLibMCDataLoginHandler_GetActiveUsersPtr) dlsym(hLibrary, "libmcdata_loginhandler_getactiveusers");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetActiveUsers == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_HasPersistentParameter = (PLibMCDataPersistencyHandler_HasPersistentParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_haspersistentparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_HasPersistentParameter = (PLibMCDataPersistencyHandler_HasPersistentParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_haspersistentparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_HasPersistentParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails = (PLibMCDataPersistencyHandler_GetPersistentParameterDetailsPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_getpersistentparameterdetails");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails = (PLibMCDataPersistencyHandler_GetPersistentParameterDetailsPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_getpersistentparameterdetails");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_DeletePersistentParameter = (PLibMCDataPersistencyHandler_DeletePersistentParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_deletepersistentparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_DeletePersistentParameter = (PLibMCDataPersistencyHandler_DeletePersistentParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_deletepersistentparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_DeletePersistentParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentParameter = (PLibMCDataPersistencyHandler_StorePersistentParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentParameter = (PLibMCDataPersistencyHandler_StorePersistentParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter = (PLibMCDataPersistencyHandler_StorePersistentStringParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentstringparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter = (PLibMCDataPersistencyHandler_StorePersistentStringParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter = (PLibMCDataPersistencyHandler_StorePersistentUUIDParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentuuidparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter = (PLibMCDataPersistencyHandler_StorePersistentUUIDParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter = (PLibMCDataPersistencyHandler_StorePersistentDoubleParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter = (PLibMCDataPersistencyHandler_StorePersistentDoubleParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter = (PLibMCDataPersistencyHandler_StorePersistentIntegerParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentintegerparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter = (PLibMCDataPersistencyHandler_StorePersistentIntegerParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter = (PLibMCDataPersistencyHandler_StorePersistentBoolParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentboolparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter = (PLibMCDataPersistencyHandler_StorePersistentBoolParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter = (PLibMCDataPersistencyHandler_RetrievePersistentStringParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentstringparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter = (PLibMCDataPersistencyHandler_RetrievePersistentStringParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter = (PLibMCDataPersistencyHandler_RetrievePersistentUUIDParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentuuidparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter = (PLibMCDataPersistencyHandler_RetrievePersistentUUIDParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter = (PLibMCDataPersistencyHandler_RetrievePersistentDoubleParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter = (PLibMCDataPersistencyHandler_RetrievePersistentDoubleParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter = (PLibMCDataPersistencyHandler_RetrievePersistentIntegerParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentintegerparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter = (PLibMCDataPersistencyHandler_RetrievePersistentIntegerParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter = (PLibMCDataPersistencyHandler_RetrievePersistentBoolParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentboolparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter = (PLibMCDataPersistencyHandler_RetrievePersistentBoolParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InstallationInformation_GetInstallationUUID = (PLibMCDataInstallationInformation_GetInstallationUUIDPtr) GetProcAddress(hLibrary, "libmcdata_installationinformation_getinstallationuuid");
		#else // _WIN32
		pWrapperTable->m_InstallationInformation_GetInstallationUUID = (PLibMCDataInstallationInformation_GetInstallationUUIDPtr) dlsym(hLibrary, "libmcdata_installationinformation_getinstallationuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InstallationInformation_GetInstallationUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InstallationInformation_GetInstallationSecret = (PLibMCDataInstallationInformation_GetInstallationSecretPtr) GetProcAddress(hLibrary, "libmcdata_installationinformation_getinstallationsecret");
		#else // _WIN32
		pWrapperTable->m_InstallationInformation_GetInstallationSecret = (PLibMCDataInstallationInformation_GetInstallationSecretPtr) dlsym(hLibrary, "libmcdata_installationinformation_getinstallationsecret");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InstallationInformation_GetInstallationSecret == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InstallationInformation_GetBaseTempDirectory = (PLibMCDataInstallationInformation_GetBaseTempDirectoryPtr) GetProcAddress(hLibrary, "libmcdata_installationinformation_getbasetempdirectory");
		#else // _WIN32
		pWrapperTable->m_InstallationInformation_GetBaseTempDirectory = (PLibMCDataInstallationInformation_GetBaseTempDirectoryPtr) dlsym(hLibrary, "libmcdata_installationinformation_getbasetempdirectory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InstallationInformation_GetBaseTempDirectory == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_InitialiseDatabase = (PLibMCDataDataModel_InitialiseDatabasePtr) GetProcAddress(hLibrary, "libmcdata_datamodel_initialisedatabase");
		#else // _WIN32
		pWrapperTable->m_DataModel_InitialiseDatabase = (PLibMCDataDataModel_InitialiseDatabasePtr) dlsym(hLibrary, "libmcdata_datamodel_initialisedatabase");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_InitialiseDatabase == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetDataModelVersion = (PLibMCDataDataModel_GetDataModelVersionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getdatamodelversion");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetDataModelVersion = (PLibMCDataDataModel_GetDataModelVersionPtr) dlsym(hLibrary, "libmcdata_datamodel_getdatamodelversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetDataModelVersion == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformation = (PLibMCDataDataModel_GetInstallationInformationPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getinstallationinformation");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformation = (PLibMCDataDataModel_GetInstallationInformationPtr) dlsym(hLibrary, "libmcdata_datamodel_getinstallationinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetInstallationInformation == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformationObject = (PLibMCDataDataModel_GetInstallationInformationObjectPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getinstallationinformationobject");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformationObject = (PLibMCDataDataModel_GetInstallationInformationObjectPtr) dlsym(hLibrary, "libmcdata_datamodel_getinstallationinformationobject");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetInstallationInformationObject == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateStorage = (PLibMCDataDataModel_CreateStoragePtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createstorage");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateStorage = (PLibMCDataDataModel_CreateStoragePtr) dlsym(hLibrary, "libmcdata_datamodel_createstorage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateStorage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateBuildJobHandler = (PLibMCDataDataModel_CreateBuildJobHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createbuildjobhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateBuildJobHandler = (PLibMCDataDataModel_CreateBuildJobHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createbuildjobhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateBuildJobHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateNewLogSession = (PLibMCDataDataModel_CreateNewLogSessionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createnewlogsession");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateNewLogSession = (PLibMCDataDataModel_CreateNewLogSessionPtr) dlsym(hLibrary, "libmcdata_datamodel_createnewlogsession");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateNewLogSession == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateJournalSession = (PLibMCDataDataModel_CreateJournalSessionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createjournalsession");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateJournalSession = (PLibMCDataDataModel_CreateJournalSessionPtr) dlsym(hLibrary, "libmcdata_datamodel_createjournalsession");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateJournalSession == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateAlertSession = (PLibMCDataDataModel_CreateAlertSessionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createalertsession");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateAlertSession = (PLibMCDataDataModel_CreateAlertSessionPtr) dlsym(hLibrary, "libmcdata_datamodel_createalertsession");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateAlertSession == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateLoginHandler = (PLibMCDataDataModel_CreateLoginHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createloginhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateLoginHandler = (PLibMCDataDataModel_CreateLoginHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createloginhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateLoginHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreatePersistencyHandler = (PLibMCDataDataModel_CreatePersistencyHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createpersistencyhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreatePersistencyHandler = (PLibMCDataDataModel_CreatePersistencyHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createpersistencyhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreatePersistencyHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_SetBaseTempDirectory = (PLibMCDataDataModel_SetBaseTempDirectoryPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_setbasetempdirectory");
		#else // _WIN32
		pWrapperTable->m_DataModel_SetBaseTempDirectory = (PLibMCDataDataModel_SetBaseTempDirectoryPtr) dlsym(hLibrary, "libmcdata_datamodel_setbasetempdirectory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_SetBaseTempDirectory == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetBaseTempDirectory = (PLibMCDataDataModel_GetBaseTempDirectoryPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getbasetempdirectory");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetBaseTempDirectory = (PLibMCDataDataModel_GetBaseTempDirectoryPtr) dlsym(hLibrary, "libmcdata_datamodel_getbasetempdirectory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetBaseTempDirectory == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_SetLogCallback = (PLibMCDataDataModel_SetLogCallbackPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_setlogcallback");
		#else // _WIN32
		pWrapperTable->m_DataModel_SetLogCallback = (PLibMCDataDataModel_SetLogCallbackPtr) dlsym(hLibrary, "libmcdata_datamodel_setlogcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_SetLogCallback == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_ClearLogCallback = (PLibMCDataDataModel_ClearLogCallbackPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_clearlogcallback");
		#else // _WIN32
		pWrapperTable->m_DataModel_ClearLogCallback = (PLibMCDataDataModel_ClearLogCallbackPtr) dlsym(hLibrary, "libmcdata_datamodel_clearlogcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_ClearLogCallback == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_HasLogCallback = (PLibMCDataDataModel_HasLogCallbackPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_haslogcallback");
		#else // _WIN32
		pWrapperTable->m_DataModel_HasLogCallback = (PLibMCDataDataModel_HasLogCallbackPtr) dlsym(hLibrary, "libmcdata_datamodel_haslogcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_HasLogCallback == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_TriggerLogCallback = (PLibMCDataDataModel_TriggerLogCallbackPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_triggerlogcallback");
		#else // _WIN32
		pWrapperTable->m_DataModel_TriggerLogCallback = (PLibMCDataDataModel_TriggerLogCallbackPtr) dlsym(hLibrary, "libmcdata_datamodel_triggerlogcallback");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_TriggerLogCallback == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDataGetVersionPtr) GetProcAddress(hLibrary, "libmcdata_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDataGetVersionPtr) dlsym(hLibrary, "libmcdata_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDataGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdata_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDataGetLastErrorPtr) dlsym(hLibrary, "libmcdata_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDataReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdata_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDataReleaseInstancePtr) dlsym(hLibrary, "libmcdata_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDataAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdata_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDataAcquireInstancePtr) dlsym(hLibrary, "libmcdata_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDataGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdata_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDataGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdata_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDataModelInstance = (PLibMCDataCreateDataModelInstancePtr) GetProcAddress(hLibrary, "libmcdata_createdatamodelinstance");
		#else // _WIN32
		pWrapperTable->m_CreateDataModelInstance = (PLibMCDataCreateDataModelInstancePtr) dlsym(hLibrary, "libmcdata_createdatamodelinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDataModelInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDataDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		typedef LibMCDataResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDataResult eLookupError = LIBMCDATA_SUCCESS;
		eLookupError = (*pLookup)("libmcdata_iterator_movenext", (void**)&(pWrapperTable->m_Iterator_MoveNext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MoveNext == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_moveprevious", (void**)&(pWrapperTable->m_Iterator_MovePrevious));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MovePrevious == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_getcurrent", (void**)&(pWrapperTable->m_Iterator_GetCurrent));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_GetCurrent == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_clone", (void**)&(pWrapperTable->m_Iterator_Clone));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Clone == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_count", (void**)&(pWrapperTable->m_Iterator_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Count == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logentrylist_count", (void**)&(pWrapperTable->m_LogEntryList_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_Count == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logentrylist_getentrybyindex", (void**)&(pWrapperTable->m_LogEntryList_GetEntryByIndex));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_GetEntryByIndex == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logentrylist_getentrybyid", (void**)&(pWrapperTable->m_LogEntryList_GetEntryByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_GetEntryByID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logentrylist_hasentry", (void**)&(pWrapperTable->m_LogEntryList_HasEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogEntryList_HasEntry == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logsession_getsessionuuid", (void**)&(pWrapperTable->m_LogSession_GetSessionUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogSession_GetSessionUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logsession_addentry", (void**)&(pWrapperTable->m_LogSession_AddEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogSession_AddEntry == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logsession_getmaxlogentryid", (void**)&(pWrapperTable->m_LogSession_GetMaxLogEntryID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogSession_GetMaxLogEntryID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logsession_retrievelogentriesbyid", (void**)&(pWrapperTable->m_LogSession_RetrieveLogEntriesByID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogSession_RetrieveLogEntriesByID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_getuuid", (void**)&(pWrapperTable->m_Alert_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_getidentifier", (void**)&(pWrapperTable->m_Alert_GetIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_isactive", (void**)&(pWrapperTable->m_Alert_IsActive));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_IsActive == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_getlevel", (void**)&(pWrapperTable->m_Alert_GetLevel));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetLevel == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_getlevelstring", (void**)&(pWrapperTable->m_Alert_GetLevelString));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetLevelString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_getdescription", (void**)&(pWrapperTable->m_Alert_GetDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetDescription == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_getdescriptionidentifier", (void**)&(pWrapperTable->m_Alert_GetDescriptionIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetDescriptionIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_getreadablecontextinformation", (void**)&(pWrapperTable->m_Alert_GetReadableContextInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetReadableContextInformation == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_getneedsacknowledgement", (void**)&(pWrapperTable->m_Alert_GetNeedsAcknowledgement));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetNeedsAcknowledgement == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_gettimestamputc", (void**)&(pWrapperTable->m_Alert_GetTimestampUTC));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetTimestampUTC == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_hasbeenacknowledged", (void**)&(pWrapperTable->m_Alert_HasBeenAcknowledged));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_HasBeenAcknowledged == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_getacknowledgementinformation", (void**)&(pWrapperTable->m_Alert_GetAcknowledgementInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_GetAcknowledgementInformation == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_acknowledgeforuser", (void**)&(pWrapperTable->m_Alert_AcknowledgeForUser));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_AcknowledgeForUser == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alert_deactivatealert", (void**)&(pWrapperTable->m_Alert_DeactivateAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_Alert_DeactivateAlert == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alertiterator_getcurrentalert", (void**)&(pWrapperTable->m_AlertIterator_GetCurrentAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_AlertIterator_GetCurrentAlert == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alertsession_addalert", (void**)&(pWrapperTable->m_AlertSession_AddAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_AlertSession_AddAlert == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alertsession_hasalert", (void**)&(pWrapperTable->m_AlertSession_HasAlert));
		if ( (eLookupError != 0) || (pWrapperTable->m_AlertSession_HasAlert == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alertsession_getalertbyuuid", (void**)&(pWrapperTable->m_AlertSession_GetAlertByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_AlertSession_GetAlertByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alertsession_retrievealerts", (void**)&(pWrapperTable->m_AlertSession_RetrieveAlerts));
		if ( (eLookupError != 0) || (pWrapperTable->m_AlertSession_RetrieveAlerts == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_alertsession_retrievealertsbytype", (void**)&(pWrapperTable->m_AlertSession_RetrieveAlertsByType));
		if ( (eLookupError != 0) || (pWrapperTable->m_AlertSession_RetrieveAlertsByType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_journalsession_getsessionuuid", (void**)&(pWrapperTable->m_JournalSession_GetSessionUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalSession_GetSessionUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_journalsession_writejournalchunkintegerdata", (void**)&(pWrapperTable->m_JournalSession_WriteJournalChunkIntegerData));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalSession_WriteJournalChunkIntegerData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_journalsession_getchunkcapacity", (void**)&(pWrapperTable->m_JournalSession_GetChunkCapacity));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalSession_GetChunkCapacity == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_journalsession_getflushinterval", (void**)&(pWrapperTable->m_JournalSession_GetFlushInterval));
		if ( (eLookupError != 0) || (pWrapperTable->m_JournalSession_GetFlushInterval == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getuuid", (void**)&(pWrapperTable->m_StorageStream_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_gettimestamp", (void**)&(pWrapperTable->m_StorageStream_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcontextidentifier", (void**)&(pWrapperTable->m_StorageStream_GetContextIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetContextIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getname", (void**)&(pWrapperTable->m_StorageStream_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getmimetype", (void**)&(pWrapperTable->m_StorageStream_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetMIMEType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getsha2", (void**)&(pWrapperTable->m_StorageStream_GetSHA2));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetSHA2 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getsize", (void**)&(pWrapperTable->m_StorageStream_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcontent", (void**)&(pWrapperTable->m_StorageStream_GetContent));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetContent == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcallbacks", (void**)&(pWrapperTable->m_StorageStream_GetCallbacks));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetCallbacks == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagezipwriter_startnewentry", (void**)&(pWrapperTable->m_StorageZIPWriter_StartNewEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageZIPWriter_StartNewEntry == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagezipwriter_finishcurrententry", (void**)&(pWrapperTable->m_StorageZIPWriter_FinishCurrentEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageZIPWriter_FinishCurrentEntry == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagezipwriter_getopenentryid", (void**)&(pWrapperTable->m_StorageZIPWriter_GetOpenEntryID));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageZIPWriter_GetOpenEntryID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagezipwriter_writedata", (void**)&(pWrapperTable->m_StorageZIPWriter_WriteData));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageZIPWriter_WriteData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagezipwriter_getentrysize", (void**)&(pWrapperTable->m_StorageZIPWriter_GetEntrySize));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageZIPWriter_GetEntrySize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagezipwriter_getzipstreamsize", (void**)&(pWrapperTable->m_StorageZIPWriter_GetZIPStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageZIPWriter_GetZIPStreamSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagezipwriter_finish", (void**)&(pWrapperTable->m_StorageZIPWriter_Finish));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageZIPWriter_Finish == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagezipwriter_isfinished", (void**)&(pWrapperTable->m_StorageZIPWriter_IsFinished));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageZIPWriter_IsFinished == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_streamisready", (void**)&(pWrapperTable->m_Storage_StreamIsReady));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StreamIsReady == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_retrievestream", (void**)&(pWrapperTable->m_Storage_RetrieveStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_RetrieveStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_storenewstream", (void**)&(pWrapperTable->m_Storage_StoreNewStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StoreNewStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_beginpartialstream", (void**)&(pWrapperTable->m_Storage_BeginPartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_BeginPartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_storepartialstream", (void**)&(pWrapperTable->m_Storage_StorePartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StorePartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_finishpartialstream", (void**)&(pWrapperTable->m_Storage_FinishPartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_FinishPartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_finishpartialstreamblockwisesha256", (void**)&(pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_beginrandomwritestream", (void**)&(pWrapperTable->m_Storage_BeginRandomWriteStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_BeginRandomWriteStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_storerandomwritestream", (void**)&(pWrapperTable->m_Storage_StoreRandomWriteStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StoreRandomWriteStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_getrandomwritestreamsize", (void**)&(pWrapperTable->m_Storage_GetRandomWriteStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_GetRandomWriteStreamSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_finishrandomwritestream", (void**)&(pWrapperTable->m_Storage_FinishRandomWriteStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_FinishRandomWriteStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_getmaxstreamsize", (void**)&(pWrapperTable->m_Storage_GetMaxStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_GetMaxStreamSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_createzipstream", (void**)&(pWrapperTable->m_Storage_CreateZIPStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_CreateZIPStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_contenttypeisaccepted", (void**)&(pWrapperTable->m_Storage_ContentTypeIsAccepted));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_ContentTypeIsAccepted == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_streamisimage", (void**)&(pWrapperTable->m_Storage_StreamIsImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StreamIsImage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_createdownloadticket", (void**)&(pWrapperTable->m_Storage_CreateDownloadTicket));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_CreateDownloadTicket == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_requestdownloadticket", (void**)&(pWrapperTable->m_Storage_RequestDownloadTicket));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_RequestDownloadTicket == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_attachstreamtojournal", (void**)&(pWrapperTable->m_Storage_AttachStreamToJournal));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_AttachStreamToJournal == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getdatauuid", (void**)&(pWrapperTable->m_CustomDataStream_GetDataUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetDataUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getidentifier", (void**)&(pWrapperTable->m_CustomDataStream_GetIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getname", (void**)&(pWrapperTable->m_CustomDataStream_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_gettimestamp", (void**)&(pWrapperTable->m_CustomDataStream_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getstoragestream", (void**)&(pWrapperTable->m_CustomDataStream_GetStorageStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetStorageStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getstoragestreamuuid", (void**)&(pWrapperTable->m_CustomDataStream_GetStorageStreamUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetStorageStreamUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getstoragestreamsha2", (void**)&(pWrapperTable->m_CustomDataStream_GetStorageStreamSHA2));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetStorageStreamSHA2 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getstoragestreamsize", (void**)&(pWrapperTable->m_CustomDataStream_GetStorageStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetStorageStreamSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getuseruuid", (void**)&(pWrapperTable->m_CustomDataStream_GetUserUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetUserUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getdatatype", (void**)&(pWrapperTable->m_CustomDataStream_GetDataType));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetDataType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getdatatypeasstring", (void**)&(pWrapperTable->m_CustomDataStream_GetDataTypeAsString));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetDataTypeAsString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_customdatastream_getmimetype", (void**)&(pWrapperTable->m_CustomDataStream_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_CustomDataStream_GetMIMEType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getjobuuid", (void**)&(pWrapperTable->m_BuildJobData_GetJobUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetJobUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdataiterator_getcurrentjobdata", (void**)&(pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecutiondata_getexecutionuuid", (void**)&(pWrapperTable->m_BuildJobExecutionData_GetExecutionUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecutionData_GetExecutionUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecutiondataiterator_getcurrentjobexecutiondata", (void**)&(pWrapperTable->m_BuildJobExecutionDataIterator_GetCurrentJobExecutionData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecutionDataIterator_GetCurrentJobExecutionData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_getexecutionuuid", (void**)&(pWrapperTable->m_BuildJobExecution_GetExecutionUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_GetExecutionUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_getjobuuid", (void**)&(pWrapperTable->m_BuildJobExecution_GetJobUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_GetJobUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_getstatus", (void**)&(pWrapperTable->m_BuildJobExecution_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_GetStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_changestatus", (void**)&(pWrapperTable->m_BuildJobExecution_ChangeStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_ChangeStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_getdescription", (void**)&(pWrapperTable->m_BuildJobExecution_GetDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_GetDescription == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_setdescription", (void**)&(pWrapperTable->m_BuildJobExecution_SetDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_SetDescription == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_getjournaluuid", (void**)&(pWrapperTable->m_BuildJobExecution_GetJournalUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_GetJournalUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_getuseruuid", (void**)&(pWrapperTable->m_BuildJobExecution_GetUserUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_GetUserUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_getstarttimestampinmicroseconds", (void**)&(pWrapperTable->m_BuildJobExecution_GetStartTimeStampInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_GetStartTimeStampInMicroseconds == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_getendtimestampinmicroseconds", (void**)&(pWrapperTable->m_BuildJobExecution_GetEndTimeStampInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_GetEndTimeStampInMicroseconds == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_computeelapsedtimeinmicroseconds", (void**)&(pWrapperTable->m_BuildJobExecution_ComputeElapsedTimeInMicroseconds));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_ComputeElapsedTimeInMicroseconds == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_addjobexecutiondata", (void**)&(pWrapperTable->m_BuildJobExecution_AddJobExecutionData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_AddJobExecutionData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_listjobexecutiondatabytype", (void**)&(pWrapperTable->m_BuildJobExecution_ListJobExecutionDataByType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_ListJobExecutionDataByType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_listjobexecutiondata", (void**)&(pWrapperTable->m_BuildJobExecution_ListJobExecutionData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_ListJobExecutionData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_retrievejobexecutiondata", (void**)&(pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_retrievejobexecutiondatabyidentifier", (void**)&(pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionDataByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_RetrieveJobExecutionDataByIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_hasjobexecutiondatauuid", (void**)&(pWrapperTable->m_BuildJobExecution_HasJobExecutionDataUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_HasJobExecutionDataUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_hasjobexecutiondataidentifier", (void**)&(pWrapperTable->m_BuildJobExecution_HasJobExecutionDataIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_HasJobExecutionDataIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_storemetadatastring", (void**)&(pWrapperTable->m_BuildJobExecution_StoreMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_StoreMetaDataString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_hasmetadatastring", (void**)&(pWrapperTable->m_BuildJobExecution_HasMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_HasMetaDataString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecution_getmetadatastring", (void**)&(pWrapperTable->m_BuildJobExecution_GetMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecution_GetMetaDataString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobexecutioniterator_getcurrentjobexecution", (void**)&(pWrapperTable->m_BuildJobExecutionIterator_GetCurrentJobExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobExecutionIterator_GetCurrentJobExecution == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getuuid", (void**)&(pWrapperTable->m_BuildJob_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getname", (void**)&(pWrapperTable->m_BuildJob_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstatus", (void**)&(pWrapperTable->m_BuildJob_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getlayercount", (void**)&(pWrapperTable->m_BuildJob_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetLayerCount == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_gettimestamp", (void**)&(pWrapperTable->m_BuildJob_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstoragestream", (void**)&(pWrapperTable->m_BuildJob_GetStorageStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStorageStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstoragestreamuuid", (void**)&(pWrapperTable->m_BuildJob_GetStorageStreamUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStorageStreamUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_startvalidating", (void**)&(pWrapperTable->m_BuildJob_StartValidating));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_StartValidating == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_finishvalidating", (void**)&(pWrapperTable->m_BuildJob_FinishValidating));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_FinishValidating == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_archivejob", (void**)&(pWrapperTable->m_BuildJob_ArchiveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ArchiveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_unarchivejob", (void**)&(pWrapperTable->m_BuildJob_UnArchiveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_UnArchiveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_deletejob", (void**)&(pWrapperTable->m_BuildJob_DeleteJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_DeleteJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_jobcanbearchived", (void**)&(pWrapperTable->m_BuildJob_JobCanBeArchived));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_JobCanBeArchived == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_addjobdata", (void**)&(pWrapperTable->m_BuildJob_AddJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_AddJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_listjobdatabytype", (void**)&(pWrapperTable->m_BuildJob_ListJobDataByType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ListJobDataByType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_listjobdata", (void**)&(pWrapperTable->m_BuildJob_ListJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ListJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_retrievejobdata", (void**)&(pWrapperTable->m_BuildJob_RetrieveJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_RetrieveJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_retrievejobdatabyidentifier", (void**)&(pWrapperTable->m_BuildJob_RetrieveJobDataByIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_RetrieveJobDataByIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_hasjobdatauuid", (void**)&(pWrapperTable->m_BuildJob_HasJobDataUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_HasJobDataUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_hasjobdataidentifier", (void**)&(pWrapperTable->m_BuildJob_HasJobDataIdentifier));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_HasJobDataIdentifier == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_storemetadatastring", (void**)&(pWrapperTable->m_BuildJob_StoreMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_StoreMetaDataString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_hasmetadatastring", (void**)&(pWrapperTable->m_BuildJob_HasMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_HasMetaDataString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getmetadatastring", (void**)&(pWrapperTable->m_BuildJob_GetMetaDataString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetMetaDataString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_createbuildjobexecution", (void**)&(pWrapperTable->m_BuildJob_CreateBuildJobExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_CreateBuildJobExecution == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_retrievebuildjobexecution", (void**)&(pWrapperTable->m_BuildJob_RetrieveBuildJobExecution));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_RetrieveBuildJobExecution == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_retrievebuildjobexecutions", (void**)&(pWrapperTable->m_BuildJob_RetrieveBuildJobExecutions));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_RetrieveBuildJobExecutions == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_retrievebuildjobexecutionsbystatus", (void**)&(pWrapperTable->m_BuildJob_RetrieveBuildJobExecutionsByStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_RetrieveBuildJobExecutionsByStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobiterator_getcurrentjob", (void**)&(pWrapperTable->m_BuildJobIterator_GetCurrentJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobIterator_GetCurrentJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_createjob", (void**)&(pWrapperTable->m_BuildJobHandler_CreateJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_CreateJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_retrievejob", (void**)&(pWrapperTable->m_BuildJobHandler_RetrieveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_RetrieveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_findjobofdata", (void**)&(pWrapperTable->m_BuildJobHandler_FindJobOfData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_FindJobOfData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_listjobsbystatus", (void**)&(pWrapperTable->m_BuildJobHandler_ListJobsByStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ListJobsByStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_convertbuildstatustostring", (void**)&(pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_convertstringtobuildstatus", (void**)&(pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_userlist_count", (void**)&(pWrapperTable->m_UserList_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserList_Count == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_userlist_getuserproperties", (void**)&(pWrapperTable->m_UserList_GetUserProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_UserList_GetUserProperties == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_userexists", (void**)&(pWrapperTable->m_LoginHandler_UserExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_UserExists == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_useruuidexists", (void**)&(pWrapperTable->m_LoginHandler_UserUUIDExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_UserUUIDExists == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserdetails", (void**)&(pWrapperTable->m_LoginHandler_GetUserDetails));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserDetails == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserproperties", (void**)&(pWrapperTable->m_LoginHandler_GetUserProperties));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserProperties == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserpropertiesbyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserPropertiesByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getusernamebyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUsernameByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUsernameByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuseruuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserdescription", (void**)&(pWrapperTable->m_LoginHandler_GetUserDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserDescription == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserdescriptionbyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserDescriptionByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserrole", (void**)&(pWrapperTable->m_LoginHandler_GetUserRole));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserRole == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserrolebyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserRoleByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserRoleByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserlanguage", (void**)&(pWrapperTable->m_LoginHandler_GetUserLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserLanguage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserlanguagebyuuid", (void**)&(pWrapperTable->m_LoginHandler_GetUserLanguageByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserLanguageByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_createuser", (void**)&(pWrapperTable->m_LoginHandler_CreateUser));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_CreateUser == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserlanguage", (void**)&(pWrapperTable->m_LoginHandler_SetUserLanguage));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserLanguage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserrole", (void**)&(pWrapperTable->m_LoginHandler_SetUserRole));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserRole == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserdescription", (void**)&(pWrapperTable->m_LoginHandler_SetUserDescription));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserDescription == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserpassword", (void**)&(pWrapperTable->m_LoginHandler_SetUserPassword));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserPassword == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserlanguagebyuuid", (void**)&(pWrapperTable->m_LoginHandler_SetUserLanguageByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserLanguageByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserrolebyuuid", (void**)&(pWrapperTable->m_LoginHandler_SetUserRoleByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserRoleByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserdescriptionbyuuid", (void**)&(pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserDescriptionByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_setuserpasswordbyuuid", (void**)&(pWrapperTable->m_LoginHandler_SetUserPasswordByUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_SetUserPasswordByUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getactiveusers", (void**)&(pWrapperTable->m_LoginHandler_GetActiveUsers));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetActiveUsers == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_haspersistentparameter", (void**)&(pWrapperTable->m_PersistencyHandler_HasPersistentParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_HasPersistentParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_getpersistentparameterdetails", (void**)&(pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_deletepersistentparameter", (void**)&(pWrapperTable->m_PersistencyHandler_DeletePersistentParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_DeletePersistentParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentstringparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentuuidparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentdoubleparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentintegerparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentboolparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentstringparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentuuidparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentdoubleparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentintegerparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentboolparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_installationinformation_getinstallationuuid", (void**)&(pWrapperTable->m_InstallationInformation_GetInstallationUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_InstallationInformation_GetInstallationUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_installationinformation_getinstallationsecret", (void**)&(pWrapperTable->m_InstallationInformation_GetInstallationSecret));
		if ( (eLookupError != 0) || (pWrapperTable->m_InstallationInformation_GetInstallationSecret == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_installationinformation_getbasetempdirectory", (void**)&(pWrapperTable->m_InstallationInformation_GetBaseTempDirectory));
		if ( (eLookupError != 0) || (pWrapperTable->m_InstallationInformation_GetBaseTempDirectory == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_initialisedatabase", (void**)&(pWrapperTable->m_DataModel_InitialiseDatabase));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_InitialiseDatabase == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getdatamodelversion", (void**)&(pWrapperTable->m_DataModel_GetDataModelVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetDataModelVersion == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getinstallationinformation", (void**)&(pWrapperTable->m_DataModel_GetInstallationInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetInstallationInformation == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getinstallationinformationobject", (void**)&(pWrapperTable->m_DataModel_GetInstallationInformationObject));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetInstallationInformationObject == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createstorage", (void**)&(pWrapperTable->m_DataModel_CreateStorage));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateStorage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createbuildjobhandler", (void**)&(pWrapperTable->m_DataModel_CreateBuildJobHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateBuildJobHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createnewlogsession", (void**)&(pWrapperTable->m_DataModel_CreateNewLogSession));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateNewLogSession == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createjournalsession", (void**)&(pWrapperTable->m_DataModel_CreateJournalSession));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateJournalSession == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createalertsession", (void**)&(pWrapperTable->m_DataModel_CreateAlertSession));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateAlertSession == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createloginhandler", (void**)&(pWrapperTable->m_DataModel_CreateLoginHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateLoginHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createpersistencyhandler", (void**)&(pWrapperTable->m_DataModel_CreatePersistencyHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreatePersistencyHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_setbasetempdirectory", (void**)&(pWrapperTable->m_DataModel_SetBaseTempDirectory));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_SetBaseTempDirectory == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getbasetempdirectory", (void**)&(pWrapperTable->m_DataModel_GetBaseTempDirectory));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetBaseTempDirectory == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_setlogcallback", (void**)&(pWrapperTable->m_DataModel_SetLogCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_SetLogCallback == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_clearlogcallback", (void**)&(pWrapperTable->m_DataModel_ClearLogCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_ClearLogCallback == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_haslogcallback", (void**)&(pWrapperTable->m_DataModel_HasLogCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_HasLogCallback == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_triggerlogcallback", (void**)&(pWrapperTable->m_DataModel_TriggerLogCallback));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_TriggerLogCallback == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_createdatamodelinstance", (void**)&(pWrapperTable->m_CreateDataModelInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDataModelInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDATA_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CIterator
	 */
	
	/**
	* CIterator::MoveNext - Iterates to the next resource in the list.
	* @return Iterates to the next resource in the list.
	*/
	bool CIterator::MoveNext()
	{
		bool resultHasNext = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MoveNext(m_pHandle, &resultHasNext));
		
		return resultHasNext;
	}
	
	/**
	* CIterator::MovePrevious - Iterates to the previous resource in the list.
	* @return Iterates to the previous resource in the list.
	*/
	bool CIterator::MovePrevious()
	{
		bool resultHasPrevious = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MovePrevious(m_pHandle, &resultHasPrevious));
		
		return resultHasPrevious;
	}
	
	/**
	* CIterator::GetCurrent - Returns the resource the iterator points at.
	* @return returns the resource instance.
	*/
	PBase CIterator::GetCurrent()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_GetCurrent(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBase>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	* CIterator::Clone - Creates a new resource iterator with the same resource list.
	* @return returns the cloned Iterator instance
	*/
	PIterator CIterator::Clone()
	{
		LibMCDataHandle hOutIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Clone(m_pHandle, &hOutIterator));
		
		if (!hOutIterator) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CIterator>(m_pWrapper, hOutIterator);
	}
	
	/**
	* CIterator::Count - Returns the number of resources the iterator captures.
	* @return returns the number of resources the iterator captures.
	*/
	LibMCData_uint64 CIterator::Count()
	{
		LibMCData_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CLogEntryList
	 */
	
	/**
	* CLogEntryList::Count - Returns the number of log entries in the list.
	* @return returns the number of retrieved log entries.
	*/
	LibMCData_uint32 CLogEntryList::Count()
	{
		LibMCData_uint32 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	* CLogEntryList::GetEntryByIndex - Returns a log entry in the list by its index.
	* @param[in] nIndex - Index of log entry, 0-based.
	* @param[out] nID - ID of log entry.
	* @param[out] sMessage - Log Message
	* @param[out] sSubSystem - Sub System identifier
	* @param[out] eLogLevel - Log Level
	* @param[out] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	void CLogEntryList::GetEntryByIndex(const LibMCData_uint32 nIndex, LibMCData_uint32 & nID, std::string & sMessage, std::string & sSubSystem, eLogLevel & eLogLevel, std::string & sTimestamp)
	{
		LibMCData_uint32 bytesNeededMessage = 0;
		LibMCData_uint32 bytesWrittenMessage = 0;
		LibMCData_uint32 bytesNeededSubSystem = 0;
		LibMCData_uint32 bytesWrittenSubSystem = 0;
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntryByIndex(m_pHandle, nIndex, &nID, 0, &bytesNeededMessage, nullptr, 0, &bytesNeededSubSystem, nullptr, &eLogLevel, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferMessage(bytesNeededMessage);
		std::vector<char> bufferSubSystem(bytesNeededSubSystem);
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntryByIndex(m_pHandle, nIndex, &nID, bytesNeededMessage, &bytesWrittenMessage, &bufferMessage[0], bytesNeededSubSystem, &bytesWrittenSubSystem, &bufferSubSystem[0], &eLogLevel, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		sMessage = std::string(&bufferMessage[0]);
		sSubSystem = std::string(&bufferSubSystem[0]);
		sTimestamp = std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CLogEntryList::GetEntryByID - Returns a log entry in the list by its ID.
	* @param[in] nID - ID of log entry.
	* @param[out] sMessage - Log Message
	* @param[out] sSubSystem - Sub System identifier
	* @param[out] eLogLevel - Log Level
	* @param[out] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	void CLogEntryList::GetEntryByID(const LibMCData_uint32 nID, std::string & sMessage, std::string & sSubSystem, eLogLevel & eLogLevel, std::string & sTimestamp)
	{
		LibMCData_uint32 bytesNeededMessage = 0;
		LibMCData_uint32 bytesWrittenMessage = 0;
		LibMCData_uint32 bytesNeededSubSystem = 0;
		LibMCData_uint32 bytesWrittenSubSystem = 0;
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntryByID(m_pHandle, nID, 0, &bytesNeededMessage, nullptr, 0, &bytesNeededSubSystem, nullptr, &eLogLevel, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferMessage(bytesNeededMessage);
		std::vector<char> bufferSubSystem(bytesNeededSubSystem);
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_GetEntryByID(m_pHandle, nID, bytesNeededMessage, &bytesWrittenMessage, &bufferMessage[0], bytesNeededSubSystem, &bytesWrittenSubSystem, &bufferSubSystem[0], &eLogLevel, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		sMessage = std::string(&bufferMessage[0]);
		sSubSystem = std::string(&bufferSubSystem[0]);
		sTimestamp = std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CLogEntryList::HasEntry - Returns if a log entry in the list exists.
	* @param[in] nID - ID of log entry.
	* @return Returns if a list exists.
	*/
	bool CLogEntryList::HasEntry(const LibMCData_uint32 nID)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogEntryList_HasEntry(m_pHandle, nID, &resultValue));
		
		return resultValue;
	}
	
	/**
	 * Method definitions for class CLogSession
	 */
	
	/**
	* CLogSession::GetSessionUUID - retrieves the session UUID.
	* @return Session UUID
	*/
	std::string CLogSession::GetSessionUUID()
	{
		LibMCData_uint32 bytesNeededSessionUUID = 0;
		LibMCData_uint32 bytesWrittenSessionUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_GetSessionUUID(m_pHandle, 0, &bytesNeededSessionUUID, nullptr));
		std::vector<char> bufferSessionUUID(bytesNeededSessionUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_GetSessionUUID(m_pHandle, bytesNeededSessionUUID, &bytesWrittenSessionUUID, &bufferSessionUUID[0]));
		
		return std::string(&bufferSessionUUID[0]);
	}
	
	/**
	* CLogSession::AddEntry - adds a new log entry.
	* @param[in] sMessage - Log Message
	* @param[in] sSubSystem - Sub System identifier
	* @param[in] eLogLevel - Log Level
	* @param[in] sTimestampUTC - Timestamp in ISO8601 UTC format
	*/
	void CLogSession::AddEntry(const std::string & sMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestampUTC)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_AddEntry(m_pHandle, sMessage.c_str(), sSubSystem.c_str(), eLogLevel, sTimestampUTC.c_str()));
	}
	
	/**
	* CLogSession::GetMaxLogEntryID - retrieves the maximum log entry ID in the log.
	* @return Log entry ID
	*/
	LibMCData_uint32 CLogSession::GetMaxLogEntryID()
	{
		LibMCData_uint32 resultMaxLogID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_GetMaxLogEntryID(m_pHandle, &resultMaxLogID));
		
		return resultMaxLogID;
	}
	
	/**
	* CLogSession::RetrieveLogEntriesByID - retrieves an excerpt of the log.
	* @param[in] nMinLogID - Minimum log entry ID to receive.
	* @param[in] nMaxLogID - Maximum log entry ID to receive. MUST be between (MinLogID + 1) and (MinLogID + 65536).
	* @param[in] eMinLogLevel - Minimum Log Level to return.
	* @return Log Entry List.
	*/
	PLogEntryList CLogSession::RetrieveLogEntriesByID(const LibMCData_uint32 nMinLogID, const LibMCData_uint32 nMaxLogID, const eLogLevel eMinLogLevel)
	{
		LibMCDataHandle hLogEntryList = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_RetrieveLogEntriesByID(m_pHandle, nMinLogID, nMaxLogID, eMinLogLevel, &hLogEntryList));
		
		if (!hLogEntryList) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogEntryList>(m_pWrapper, hLogEntryList);
	}
	
	/**
	 * Method definitions for class CAlert
	 */
	
	/**
	* CAlert::GetUUID - Returns the Alert UUID.
	* @return Value.
	*/
	std::string CAlert::GetUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CAlert::GetIdentifier - Returns the Alert Identifier.
	* @return Value.
	*/
	std::string CAlert::GetIdentifier()
	{
		LibMCData_uint32 bytesNeededIdentifier = 0;
		LibMCData_uint32 bytesWrittenIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetIdentifier(m_pHandle, 0, &bytesNeededIdentifier, nullptr));
		std::vector<char> bufferIdentifier(bytesNeededIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetIdentifier(m_pHandle, bytesNeededIdentifier, &bytesWrittenIdentifier, &bufferIdentifier[0]));
		
		return std::string(&bufferIdentifier[0]);
	}
	
	/**
	* CAlert::IsActive - Returns if the alert is actuve.
	* @return Returns if the alert is active.
	*/
	bool CAlert::IsActive()
	{
		bool resultActive = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_IsActive(m_pHandle, &resultActive));
		
		return resultActive;
	}
	
	/**
	* CAlert::GetLevel - Returns the Alert Level.
	* @return Value.
	*/
	eAlertLevel CAlert::GetLevel()
	{
		eAlertLevel resultLevel = (eAlertLevel) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetLevel(m_pHandle, &resultLevel));
		
		return resultLevel;
	}
	
	/**
	* CAlert::GetLevelString - Returns the Alert Level string.
	* @return Value.
	*/
	std::string CAlert::GetLevelString()
	{
		LibMCData_uint32 bytesNeededLevelString = 0;
		LibMCData_uint32 bytesWrittenLevelString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetLevelString(m_pHandle, 0, &bytesNeededLevelString, nullptr));
		std::vector<char> bufferLevelString(bytesNeededLevelString);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetLevelString(m_pHandle, bytesNeededLevelString, &bytesWrittenLevelString, &bufferLevelString[0]));
		
		return std::string(&bufferLevelString[0]);
	}
	
	/**
	* CAlert::GetDescription - Returns the Alert Description.
	* @return Value.
	*/
	std::string CAlert::GetDescription()
	{
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetDescription(m_pHandle, 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetDescription(m_pHandle, bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CAlert::GetDescriptionIdentifier - Returns the Alert DescriptionIdentifier.
	* @return Value.
	*/
	std::string CAlert::GetDescriptionIdentifier()
	{
		LibMCData_uint32 bytesNeededDescriptionIdentifier = 0;
		LibMCData_uint32 bytesWrittenDescriptionIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetDescriptionIdentifier(m_pHandle, 0, &bytesNeededDescriptionIdentifier, nullptr));
		std::vector<char> bufferDescriptionIdentifier(bytesNeededDescriptionIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetDescriptionIdentifier(m_pHandle, bytesNeededDescriptionIdentifier, &bytesWrittenDescriptionIdentifier, &bufferDescriptionIdentifier[0]));
		
		return std::string(&bufferDescriptionIdentifier[0]);
	}
	
	/**
	* CAlert::GetReadableContextInformation - Returns the Alert ReadableContextInformation.
	* @return Value.
	*/
	std::string CAlert::GetReadableContextInformation()
	{
		LibMCData_uint32 bytesNeededReadableContextInformation = 0;
		LibMCData_uint32 bytesWrittenReadableContextInformation = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetReadableContextInformation(m_pHandle, 0, &bytesNeededReadableContextInformation, nullptr));
		std::vector<char> bufferReadableContextInformation(bytesNeededReadableContextInformation);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetReadableContextInformation(m_pHandle, bytesNeededReadableContextInformation, &bytesWrittenReadableContextInformation, &bufferReadableContextInformation[0]));
		
		return std::string(&bufferReadableContextInformation[0]);
	}
	
	/**
	* CAlert::GetNeedsAcknowledgement - Returns if the Alert needs acknowledgement.
	* @return Value.
	*/
	bool CAlert::GetNeedsAcknowledgement()
	{
		bool resultNeedsAcknowledgement = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetNeedsAcknowledgement(m_pHandle, &resultNeedsAcknowledgement));
		
		return resultNeedsAcknowledgement;
	}
	
	/**
	* CAlert::GetTimestampUTC - Returns the Alert Timestamp in UTC file format.
	* @return Value.
	*/
	std::string CAlert::GetTimestampUTC()
	{
		LibMCData_uint32 bytesNeededTimestampUTC = 0;
		LibMCData_uint32 bytesWrittenTimestampUTC = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetTimestampUTC(m_pHandle, 0, &bytesNeededTimestampUTC, nullptr));
		std::vector<char> bufferTimestampUTC(bytesNeededTimestampUTC);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetTimestampUTC(m_pHandle, bytesNeededTimestampUTC, &bytesWrittenTimestampUTC, &bufferTimestampUTC[0]));
		
		return std::string(&bufferTimestampUTC[0]);
	}
	
	/**
	* CAlert::HasBeenAcknowledged - Checks if the alert has been acknowledged.
	* @return Flag if the alert has been acknowledged.
	*/
	bool CAlert::HasBeenAcknowledged()
	{
		bool resultHasBeenAcknowledged = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_HasBeenAcknowledged(m_pHandle, &resultHasBeenAcknowledged));
		
		return resultHasBeenAcknowledged;
	}
	
	/**
	* CAlert::GetAcknowledgementInformation - Returns details about the acknowledgement. Fails if the alert is not acknowledged.
	* @param[out] sUserUUID - User who acknowledged the alert.
	* @param[out] sUserComment - Comment of the acknowledgement.
	* @param[out] sAckTime - Timestamp in ISO8601 UTC format.
	*/
	void CAlert::GetAcknowledgementInformation(std::string & sUserUUID, std::string & sUserComment, std::string & sAckTime)
	{
		LibMCData_uint32 bytesNeededUserUUID = 0;
		LibMCData_uint32 bytesWrittenUserUUID = 0;
		LibMCData_uint32 bytesNeededUserComment = 0;
		LibMCData_uint32 bytesWrittenUserComment = 0;
		LibMCData_uint32 bytesNeededAckTime = 0;
		LibMCData_uint32 bytesWrittenAckTime = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetAcknowledgementInformation(m_pHandle, 0, &bytesNeededUserUUID, nullptr, 0, &bytesNeededUserComment, nullptr, 0, &bytesNeededAckTime, nullptr));
		std::vector<char> bufferUserUUID(bytesNeededUserUUID);
		std::vector<char> bufferUserComment(bytesNeededUserComment);
		std::vector<char> bufferAckTime(bytesNeededAckTime);
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_GetAcknowledgementInformation(m_pHandle, bytesNeededUserUUID, &bytesWrittenUserUUID, &bufferUserUUID[0], bytesNeededUserComment, &bytesWrittenUserComment, &bufferUserComment[0], bytesNeededAckTime, &bytesWrittenAckTime, &bufferAckTime[0]));
		sUserUUID = std::string(&bufferUserUUID[0]);
		sUserComment = std::string(&bufferUserComment[0]);
		sAckTime = std::string(&bufferAckTime[0]);
	}
	
	/**
	* CAlert::AcknowledgeForUser - Acknowledges an alert for a specific user and sets it inactive. 
	* @param[in] sUserUUID - UUID of the user to acknowledge. Fails if user does not exist.
	* @param[in] sUserComment - User comment to store. May be empty.
	* @param[in] sTimestampUTC - Timestamp in UTC format.
	*/
	void CAlert::AcknowledgeForUser(const std::string & sUserUUID, const std::string & sUserComment, const std::string & sTimestampUTC)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_AcknowledgeForUser(m_pHandle, sUserUUID.c_str(), sUserComment.c_str(), sTimestampUTC.c_str()));
	}
	
	/**
	* CAlert::DeactivateAlert - Sets an alert inactive. It will not be marked as acknowledged by a certain user.
	*/
	void CAlert::DeactivateAlert()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Alert_DeactivateAlert(m_pHandle));
	}
	
	/**
	 * Method definitions for class CAlertIterator
	 */
	
	/**
	* CAlertIterator::GetCurrentAlert - Returns the alert the iterator points at.
	* @return returns the Alert instance.
	*/
	PAlert CAlertIterator::GetCurrentAlert()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_AlertIterator_GetCurrentAlert(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlert>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CAlertSession
	 */
	
	/**
	* CAlertSession::AddAlert - adds a new alert entry.
	* @param[in] sUUID - Alert UUID
	* @param[in] sIdentifier - Alert Identifier
	* @param[in] eLevel - Alert level.
	* @param[in] sDescription - Alert Description in default language
	* @param[in] sDescriptionIdentifier - Alert Description Identifier for internationalization. May be empty.
	* @param[in] sReadableContextInformation - Readable Context Information in default language
	* @param[in] bNeedsAcknowledgement - Flag if acknowledgement is needed
	* @param[in] sTimestampUTC - Timestamp in ISO8601 UTC format
	* @return Alert Instance
	*/
	PAlert CAlertSession::AddAlert(const std::string & sUUID, const std::string & sIdentifier, const eAlertLevel eLevel, const std::string & sDescription, const std::string & sDescriptionIdentifier, const std::string & sReadableContextInformation, const bool bNeedsAcknowledgement, const std::string & sTimestampUTC)
	{
		LibMCDataHandle hAlertInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_AlertSession_AddAlert(m_pHandle, sUUID.c_str(), sIdentifier.c_str(), eLevel, sDescription.c_str(), sDescriptionIdentifier.c_str(), sReadableContextInformation.c_str(), bNeedsAcknowledgement, sTimestampUTC.c_str(), &hAlertInstance));
		
		if (!hAlertInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlert>(m_pWrapper, hAlertInstance);
	}
	
	/**
	* CAlertSession::HasAlert - Checks if an alert with a certain UUID exists.
	* @param[in] sUUID - Alert UUID. Fails if not a valid UUID is given.
	* @return Flag if alert exists
	*/
	bool CAlertSession::HasAlert(const std::string & sUUID)
	{
		bool resultAlertExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_AlertSession_HasAlert(m_pHandle, sUUID.c_str(), &resultAlertExists));
		
		return resultAlertExists;
	}
	
	/**
	* CAlertSession::GetAlertByUUID - Retrieves the alert object. Fails if alert does not exist.
	* @param[in] sUUID - Alert UUID. Fails if not a valid UUID is given.
	* @return Alert Instance
	*/
	PAlert CAlertSession::GetAlertByUUID(const std::string & sUUID)
	{
		LibMCDataHandle hAlertInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_AlertSession_GetAlertByUUID(m_pHandle, sUUID.c_str(), &hAlertInstance));
		
		if (!hAlertInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlert>(m_pWrapper, hAlertInstance);
	}
	
	/**
	* CAlertSession::RetrieveAlerts - Retrieves all or all active alerts.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	PAlertIterator CAlertSession::RetrieveAlerts(const bool bOnlyActive)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_AlertSession_RetrieveAlerts(m_pHandle, bOnlyActive, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlertIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CAlertSession::RetrieveAlertsByType - Retrieves alerts of a certain type identifier.
	* @param[in] sIdentifier - Alert Identifier to look for. Fails if empty.
	* @param[in] bOnlyActive - If true, only active alerts will be returned.
	* @return AlertIterator Instance
	*/
	PAlertIterator CAlertSession::RetrieveAlertsByType(const std::string & sIdentifier, const bool bOnlyActive)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_AlertSession_RetrieveAlertsByType(m_pHandle, sIdentifier.c_str(), bOnlyActive, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlertIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	 * Method definitions for class CJournalSession
	 */
	
	/**
	* CJournalSession::GetSessionUUID - retrieves the session UUID.
	* @return Session UUID
	*/
	std::string CJournalSession::GetSessionUUID()
	{
		LibMCData_uint32 bytesNeededSessionUUID = 0;
		LibMCData_uint32 bytesWrittenSessionUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalSession_GetSessionUUID(m_pHandle, 0, &bytesNeededSessionUUID, nullptr));
		std::vector<char> bufferSessionUUID(bytesNeededSessionUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_JournalSession_GetSessionUUID(m_pHandle, bytesNeededSessionUUID, &bytesWrittenSessionUUID, &bufferSessionUUID[0]));
		
		return std::string(&bufferSessionUUID[0]);
	}
	
	/**
	* CJournalSession::WriteJournalChunkIntegerData - writes detailed journal state data to disk.
	* @param[in] nChunkIndex - Index of the Chunk to write
	* @param[in] nStartTimeStamp - Start Timestamp of the chunk (in microseconds)
	* @param[in] nEndTimeStamp - End Timestamp of the chunk (in microseconds)
	* @param[in] VariableInfoBuffer - Variable information.
	* @param[in] EntryDataBuffer - Entry bulk data.
	*/
	void CJournalSession::WriteJournalChunkIntegerData(const LibMCData_uint32 nChunkIndex, const LibMCData_uint64 nStartTimeStamp, const LibMCData_uint64 nEndTimeStamp, const CInputVector<sJournalChunkVariableInfo> & VariableInfoBuffer, const CInputVector<sJournalChunkIntegerEntry> & EntryDataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_JournalSession_WriteJournalChunkIntegerData(m_pHandle, nChunkIndex, nStartTimeStamp, nEndTimeStamp, (LibMCData_uint64)VariableInfoBuffer.size(), VariableInfoBuffer.data(), (LibMCData_uint64)EntryDataBuffer.size(), EntryDataBuffer.data()));
	}
	
	/**
	* CJournalSession::GetChunkCapacity - Returns the chunk capacity of the session journal.
	* @return Maximum Chunk Capacity in Journal in Bytes
	*/
	LibMCData_uint32 CJournalSession::GetChunkCapacity()
	{
		LibMCData_uint32 resultChunkCapacity = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalSession_GetChunkCapacity(m_pHandle, &resultChunkCapacity));
		
		return resultChunkCapacity;
	}
	
	/**
	* CJournalSession::GetFlushInterval - Returns the flush interval of the session journal.
	* @return The interval determines how often a session journal chunk is written to disk. In Seconds.
	*/
	LibMCData_uint32 CJournalSession::GetFlushInterval()
	{
		LibMCData_uint32 resultFlushInterval = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_JournalSession_GetFlushInterval(m_pHandle, &resultFlushInterval));
		
		return resultFlushInterval;
	}
	
	/**
	 * Method definitions for class CStorageStream
	 */
	
	/**
	* CStorageStream::GetUUID - returns the uuid of a storage stream.
	* @return UUID String
	*/
	std::string CStorageStream::GetUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CStorageStream::GetTimeStamp - returns the timestamp of a storage stream.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CStorageStream::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CStorageStream::GetContextIdentifier - returns the context identifier of a storage stream.
	* @return Context Identifier String
	*/
	std::string CStorageStream::GetContextIdentifier()
	{
		LibMCData_uint32 bytesNeededContextIdentifier = 0;
		LibMCData_uint32 bytesWrittenContextIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContextIdentifier(m_pHandle, 0, &bytesNeededContextIdentifier, nullptr));
		std::vector<char> bufferContextIdentifier(bytesNeededContextIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContextIdentifier(m_pHandle, bytesNeededContextIdentifier, &bytesWrittenContextIdentifier, &bufferContextIdentifier[0]));
		
		return std::string(&bufferContextIdentifier[0]);
	}
	
	/**
	* CStorageStream::GetName - returns the name description of a storage stream.
	* @return Name String
	*/
	std::string CStorageStream::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CStorageStream::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	std::string CStorageStream::GetMIMEType()
	{
		LibMCData_uint32 bytesNeededMimeType = 0;
		LibMCData_uint32 bytesWrittenMimeType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetMIMEType(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetMIMEType(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	* CStorageStream::GetSHA2 - returns the sha256 checksum of a storage stream.
	* @return SHA1 String
	*/
	std::string CStorageStream::GetSHA2()
	{
		LibMCData_uint32 bytesNeededSHA2 = 0;
		LibMCData_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSHA2(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSHA2(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CStorageStream::GetSize - returns the size of a storage stream.
	* @return Size
	*/
	LibMCData_uint64 CStorageStream::GetSize()
	{
		LibMCData_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CStorageStream::GetContent - returns the content of a storage stream.
	* @param[out] ContentBuffer - Byte Content of the stream
	*/
	void CStorageStream::GetContent(std::vector<LibMCData_uint8> & ContentBuffer)
	{
		LibMCData_uint64 elementsNeededContent = 0;
		LibMCData_uint64 elementsWrittenContent = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContent(m_pHandle, 0, &elementsNeededContent, nullptr));
		ContentBuffer.resize((size_t) elementsNeededContent);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContent(m_pHandle, elementsNeededContent, &elementsWrittenContent, ContentBuffer.data()));
	}
	
	/**
	* CStorageStream::GetCallbacks - returns direct read access to the storage stream. The callbacks are only valid throughout the existence of the StorageStream instance.
	* @param[out] pTheReadCallback - Callback to call for reading a data chunk
	* @param[out] pTheSeekCallback - Callback to call for seeking in the stream.
	* @param[out] pStreamHandle - Handle of the stream.
	*/
	void CStorageStream::GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetCallbacks(m_pHandle, &pTheReadCallback, &pTheSeekCallback, &pStreamHandle));
	}
	
	/**
	 * Method definitions for class CStorageZIPWriter
	 */
	
	/**
	* CStorageZIPWriter::StartNewEntry - Starts a new entry in the ZIP Stream. Finishes any unfinished entry. Fails if entry already exists. Fails if more than 1 billion entries exist in the ZIP file.
	* @param[in] sFileName - Filename of the entry. MUST be a valid filename.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	* @return Returns the current entry ID.
	*/
	LibMCData_uint32 CStorageZIPWriter::StartNewEntry(const std::string & sFileName, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		LibMCData_uint32 resultEntryID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageZIPWriter_StartNewEntry(m_pHandle, sFileName.c_str(), nAbsoluteTimeStamp, &resultEntryID));
		
		return resultEntryID;
	}
	
	/**
	* CStorageZIPWriter::FinishCurrentEntry - Finishes the current entry in the ZIP stream. Writing is not possible, after an entry has been finished.
	*/
	void CStorageZIPWriter::FinishCurrentEntry()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StorageZIPWriter_FinishCurrentEntry(m_pHandle));
	}
	
	/**
	* CStorageZIPWriter::GetOpenEntryID - Returns the entry ID of the current open entry. Or 0, if no writing is possible.
	* @return Returns the current entry ID.
	*/
	LibMCData_uint32 CStorageZIPWriter::GetOpenEntryID()
	{
		LibMCData_uint32 resultEntryID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageZIPWriter_GetOpenEntryID(m_pHandle, &resultEntryID));
		
		return resultEntryID;
	}
	
	/**
	* CStorageZIPWriter::WriteData - Writes data into the currently open entry.
	* @param[in] nEntryID - Entry ID to write into. Checks again the current open entry ID and fails if there is a write attempt into any other entry ID.
	* @param[in] DataBuffer - Data block to store in stream.
	*/
	void CStorageZIPWriter::WriteData(const LibMCData_uint32 nEntryID, const CInputVector<LibMCData_uint8> & DataBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StorageZIPWriter_WriteData(m_pHandle, nEntryID, (LibMCData_uint64)DataBuffer.size(), DataBuffer.data()));
	}
	
	/**
	* CStorageZIPWriter::GetEntrySize - Returns the size of an Entry with the corresponding ID. Fails if entry ID does not exist.
	* @param[in] nEntryID - Entry ID to check.
	* @return Returns the current entry size of the ZIP entry in bytes.
	*/
	LibMCData_uint64 CStorageZIPWriter::GetEntrySize(const LibMCData_uint32 nEntryID)
	{
		LibMCData_uint64 resultEntrySize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageZIPWriter_GetEntrySize(m_pHandle, nEntryID, &resultEntrySize));
		
		return resultEntrySize;
	}
	
	/**
	* CStorageZIPWriter::GetZIPStreamSize - Returns the current size of the stream.
	* @return Current size of the stream.
	*/
	LibMCData_uint64 CStorageZIPWriter::GetZIPStreamSize()
	{
		LibMCData_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageZIPWriter_GetZIPStreamSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CStorageZIPWriter::Finish - Finishes the stream writing as a whole, including all open entries. All subsequent write attempts will fail. Starting a new entry will fail. Fails if stream has been finished already.
	*/
	void CStorageZIPWriter::Finish()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StorageZIPWriter_Finish(m_pHandle));
	}
	
	/**
	* CStorageZIPWriter::IsFinished - Returns if the stream writing has already been finished.
	* @return If true, writing into the stream is not possible anymore.
	*/
	bool CStorageZIPWriter::IsFinished()
	{
		bool resultFinished = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageZIPWriter_IsFinished(m_pHandle, &resultFinished));
		
		return resultFinished;
	}
	
	/**
	 * Method definitions for class CStorage
	 */
	
	/**
	* CStorage::StreamIsReady - checks if a stream exists and is written to disk.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream is ready.
	*/
	bool CStorage::StreamIsReady(const std::string & sUUID)
	{
		bool resultIsReady = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StreamIsReady(m_pHandle, sUUID.c_str(), &resultIsReady));
		
		return resultIsReady;
	}
	
	/**
	* CStorage::RetrieveStream - retrieves an existing stream.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream Instance.
	*/
	PStorageStream CStorage::RetrieveStream(const std::string & sUUID)
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_RetrieveStream(m_pHandle, sUUID.c_str(), &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CStorage::StoreNewStream - stores a new stream.
	* @param[in] sUUID - UUID of storage stream. Must be unique and newly generated.
	* @param[in] sName - Name Description of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] ContentBuffer - Data of stream
	* @param[in] sUserID - Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CStorage::StoreNewStream(const std::string & sUUID, const std::string & sName, const std::string & sMimeType, const CInputVector<LibMCData_uint8> & ContentBuffer, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StoreNewStream(m_pHandle, sUUID.c_str(), sName.c_str(), sMimeType.c_str(), (LibMCData_uint64)ContentBuffer.size(), ContentBuffer.data(), sUserID.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CStorage::BeginPartialStream - starts storing a stream with partial uploads.
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] nSize - Final size of the stream. MUST NOT be 0.
	* @param[in] sUserID - Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CStorage::BeginPartialStream(const std::string & sUUID, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_BeginPartialStream(m_pHandle, sUUID.c_str(), sName.c_str(), sMimeType.c_str(), nSize, sUserID.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CStorage::StorePartialStream - stores data in a stream with partial uploads. Uploads should be sequential for optimal performance, but may be in arbitrary order.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] nOffset - Offset in stream to store to. Can be an arbitrary position, but storage MUST NOT override already uploaded data.
	* @param[in] ContentBuffer - Data block to store in stream.
	*/
	void CStorage::StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StorePartialStream(m_pHandle, sUUID.c_str(), nOffset, (LibMCData_uint64)ContentBuffer.size(), ContentBuffer.data()));
	}
	
	/**
	* CStorage::FinishPartialStream - Finishes storing a stream.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sSHA2 - SHA256 of the uploaded data. If given initially, MUST be identical.
	*/
	void CStorage::FinishPartialStream(const std::string & sUUID, const std::string & sSHA2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_FinishPartialStream(m_pHandle, sUUID.c_str(), sSHA2.c_str()));
	}
	
	/**
	* CStorage::FinishPartialStreamBlockwiseSHA256 - Finishes storing a stream with a 64k-Blockwise calculated Checksum.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sBlockwiseSHA2 - 64kB hashlist SHA256 checksum of the uploaded data. If given initially, MUST be identical.
	*/
	void CStorage::FinishPartialStreamBlockwiseSHA256(const std::string & sUUID, const std::string & sBlockwiseSHA2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_FinishPartialStreamBlockwiseSHA256(m_pHandle, sUUID.c_str(), sBlockwiseSHA2.c_str()));
	}
	
	/**
	* CStorage::BeginRandomWriteStream - starts storing a stream with random write access. Checksums are not required.
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] sUserID - Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CStorage::BeginRandomWriteStream(const std::string & sUUID, const std::string & sName, const std::string & sMimeType, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_BeginRandomWriteStream(m_pHandle, sUUID.c_str(), sName.c_str(), sMimeType.c_str(), sUserID.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CStorage::StoreRandomWriteStream - stores data in a stream with random write access. Writing may be in arbitrary order.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginRandomWriteStream first.
	* @param[in] nOffset - Offset in stream to store to. Can be an arbitrary position, but MUST be smaller or equal the current size.
	* @param[in] ContentBuffer - Data block to store in stream.
	*/
	void CStorage::StoreRandomWriteStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StoreRandomWriteStream(m_pHandle, sUUID.c_str(), nOffset, (LibMCData_uint64)ContentBuffer.size(), ContentBuffer.data()));
	}
	
	/**
	* CStorage::GetRandomWriteStreamSize - Returns the size random write stream .
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginRandomWriteStream first.
	* @return Current size in bytes.
	*/
	LibMCData_uint64 CStorage::GetRandomWriteStreamSize(const std::string & sUUID)
	{
		LibMCData_uint64 resultCurrentSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_GetRandomWriteStreamSize(m_pHandle, sUUID.c_str(), &resultCurrentSize));
		
		return resultCurrentSize;
	}
	
	/**
	* CStorage::FinishRandomWriteStream - Finishes storing a random write stream.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	*/
	void CStorage::FinishRandomWriteStream(const std::string & sUUID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_FinishRandomWriteStream(m_pHandle, sUUID.c_str()));
	}
	
	/**
	* CStorage::GetMaxStreamSize - Returns the maximum stream size that the data model allows.
	* @return Maximum Stream Size in Bytes.
	*/
	LibMCData_uint64 CStorage::GetMaxStreamSize()
	{
		LibMCData_uint64 resultMaxStreamSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_GetMaxStreamSize(m_pHandle, &resultMaxStreamSize));
		
		return resultMaxStreamSize;
	}
	
	/**
	* CStorage::CreateZIPStream - starts storing a stream with a streaming ZIP writer. MIME type will be application/zip
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sName - Name of the stream.
	* @param[in] sUserUUID - UUID of Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	* @return ZIP Writer instance
	*/
	PStorageZIPWriter CStorage::CreateZIPStream(const std::string & sUUID, const std::string & sName, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		LibMCDataHandle hZIPWriter = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_CreateZIPStream(m_pHandle, sUUID.c_str(), sName.c_str(), sUserUUID.c_str(), nAbsoluteTimeStamp, &hZIPWriter));
		
		if (!hZIPWriter) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageZIPWriter>(m_pWrapper, hZIPWriter);
	}
	
	/**
	* CStorage::ContentTypeIsAccepted - Returns if the given content type is an acceptable value.
	* @param[in] sContentType - Content type string (is taken case-insensitive)
	* @return Content type is accepted.
	*/
	bool CStorage::ContentTypeIsAccepted(const std::string & sContentType)
	{
		bool resultAccepted = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_ContentTypeIsAccepted(m_pHandle, sContentType.c_str(), &resultAccepted));
		
		return resultAccepted;
	}
	
	/**
	* CStorage::StreamIsImage - checks if a stream is an image.
	* @param[in] sUUID - UUID of storage stream.
	* @return Returns if the stream is an image.
	*/
	bool CStorage::StreamIsImage(const std::string & sUUID)
	{
		bool resultIsImage = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StreamIsImage(m_pHandle, sUUID.c_str(), &resultIsImage));
		
		return resultIsImage;
	}
	
	/**
	* CStorage::CreateDownloadTicket - Creates a new download ticket for a stream and a user.
	* @param[in] sTicketUUID - UUID of download ticket.
	* @param[in] sStreamUUID - UUID of storage stream.
	* @param[in] sClientFileName - ClientFileName of the ticket. MUST NOT be empty.
	* @param[in] sSessionUUID - UUID of user session.
	* @param[in] sUserUUID - UUID of user that created the ticket.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CStorage::CreateDownloadTicket(const std::string & sTicketUUID, const std::string & sStreamUUID, const std::string & sClientFileName, const std::string & sSessionUUID, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_CreateDownloadTicket(m_pHandle, sTicketUUID.c_str(), sStreamUUID.c_str(), sClientFileName.c_str(), sSessionUUID.c_str(), sUserUUID.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CStorage::RequestDownloadTicket - Returns the details of a download ticket and creates an entry in an access log with time stamp.
	* @param[in] sTicketUUID - UUID of download ticket.
	* @param[in] sIPAddress - IP Address where the request came from.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	* @param[out] sStreamUUID - UUID of storage stream.
	* @param[out] sClientFileName - ClientFileName of the ticket.
	* @param[out] sSessionUUID - UUID of user session.
	* @param[out] sUserUUID - UUID of user that created the ticket.
	*/
	void CStorage::RequestDownloadTicket(const std::string & sTicketUUID, const std::string & sIPAddress, const LibMCData_uint64 nAbsoluteTimeStamp, std::string & sStreamUUID, std::string & sClientFileName, std::string & sSessionUUID, std::string & sUserUUID)
	{
		LibMCData_uint32 bytesNeededStreamUUID = 0;
		LibMCData_uint32 bytesWrittenStreamUUID = 0;
		LibMCData_uint32 bytesNeededClientFileName = 0;
		LibMCData_uint32 bytesWrittenClientFileName = 0;
		LibMCData_uint32 bytesNeededSessionUUID = 0;
		LibMCData_uint32 bytesWrittenSessionUUID = 0;
		LibMCData_uint32 bytesNeededUserUUID = 0;
		LibMCData_uint32 bytesWrittenUserUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_RequestDownloadTicket(m_pHandle, sTicketUUID.c_str(), sIPAddress.c_str(), nAbsoluteTimeStamp, 0, &bytesNeededStreamUUID, nullptr, 0, &bytesNeededClientFileName, nullptr, 0, &bytesNeededSessionUUID, nullptr, 0, &bytesNeededUserUUID, nullptr));
		std::vector<char> bufferStreamUUID(bytesNeededStreamUUID);
		std::vector<char> bufferClientFileName(bytesNeededClientFileName);
		std::vector<char> bufferSessionUUID(bytesNeededSessionUUID);
		std::vector<char> bufferUserUUID(bytesNeededUserUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_RequestDownloadTicket(m_pHandle, sTicketUUID.c_str(), sIPAddress.c_str(), nAbsoluteTimeStamp, bytesNeededStreamUUID, &bytesWrittenStreamUUID, &bufferStreamUUID[0], bytesNeededClientFileName, &bytesWrittenClientFileName, &bufferClientFileName[0], bytesNeededSessionUUID, &bytesWrittenSessionUUID, &bufferSessionUUID[0], bytesNeededUserUUID, &bytesWrittenUserUUID, &bufferUserUUID[0]));
		sStreamUUID = std::string(&bufferStreamUUID[0]);
		sClientFileName = std::string(&bufferClientFileName[0]);
		sSessionUUID = std::string(&bufferSessionUUID[0]);
		sUserUUID = std::string(&bufferUserUUID[0]);
	}
	
	/**
	* CStorage::AttachStreamToJournal - Attaches a stream to a journal as temporary stream.
	* @param[in] sStreamUUID - UUID of stream. Call fails if stream does not exist.
	* @param[in] sJournalUUID - UUID of journal. Call fails if journal does not exist.
	*/
	void CStorage::AttachStreamToJournal(const std::string & sStreamUUID, const std::string & sJournalUUID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_AttachStreamToJournal(m_pHandle, sStreamUUID.c_str(), sJournalUUID.c_str()));
	}
	
	/**
	 * Method definitions for class CCustomDataStream
	 */
	
	/**
	* CCustomDataStream::GetDataUUID - returns the uuid of the custom data.
	* @return UUID String
	*/
	std::string CCustomDataStream::GetDataUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetDataUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetDataUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CCustomDataStream::GetIdentifier - returns the identifier of the custom data.
	* @return Name String
	*/
	std::string CCustomDataStream::GetIdentifier()
	{
		LibMCData_uint32 bytesNeededIdentifier = 0;
		LibMCData_uint32 bytesWrittenIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetIdentifier(m_pHandle, 0, &bytesNeededIdentifier, nullptr));
		std::vector<char> bufferIdentifier(bytesNeededIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetIdentifier(m_pHandle, bytesNeededIdentifier, &bytesWrittenIdentifier, &bufferIdentifier[0]));
		
		return std::string(&bufferIdentifier[0]);
	}
	
	/**
	* CCustomDataStream::GetName - returns the name of the custom data.
	* @return Name String
	*/
	std::string CCustomDataStream::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CCustomDataStream::GetTimeStamp - returns the timestamp when the custom data was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CCustomDataStream::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CCustomDataStream::GetStorageStream - returns the storage stream.
	* @return Stream Instance.
	*/
	PStorageStream CCustomDataStream::GetStorageStream()
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetStorageStream(m_pHandle, &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CCustomDataStream::GetStorageStreamUUID - returns the UUID of the storage stream.
	* @return UUID of the storage stream.
	*/
	std::string CCustomDataStream::GetStorageStreamUUID()
	{
		LibMCData_uint32 bytesNeededSHA2 = 0;
		LibMCData_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetStorageStreamUUID(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetStorageStreamUUID(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CCustomDataStream::GetStorageStreamSHA2 - returns the checksum of the storage stream.
	* @return SHA256 of the storage stream.
	*/
	std::string CCustomDataStream::GetStorageStreamSHA2()
	{
		LibMCData_uint32 bytesNeededSHA2 = 0;
		LibMCData_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetStorageStreamSHA2(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetStorageStreamSHA2(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CCustomDataStream::GetStorageStreamSize - returns the size of the storage stream of the build.
	* @return size of the storage stream in bytes.
	*/
	LibMCData_uint64 CCustomDataStream::GetStorageStreamSize()
	{
		LibMCData_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetStorageStreamSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CCustomDataStream::GetUserUUID - returns the UUID of the user who created the stream.
	* @return UUID of the user who create the stream.
	*/
	std::string CCustomDataStream::GetUserUUID()
	{
		LibMCData_uint32 bytesNeededUserUUID = 0;
		LibMCData_uint32 bytesWrittenUserUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetUserUUID(m_pHandle, 0, &bytesNeededUserUUID, nullptr));
		std::vector<char> bufferUserUUID(bytesNeededUserUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetUserUUID(m_pHandle, bytesNeededUserUUID, &bytesWrittenUserUUID, &bufferUserUUID[0]));
		
		return std::string(&bufferUserUUID[0]);
	}
	
	/**
	* CCustomDataStream::GetDataType - returns the data type of the custom data.
	* @return Data type of the custom data
	*/
	eCustomDataType CCustomDataStream::GetDataType()
	{
		eCustomDataType resultDataType = (eCustomDataType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetDataType(m_pHandle, &resultDataType));
		
		return resultDataType;
	}
	
	/**
	* CCustomDataStream::GetDataTypeAsString - returns the data type of the custom data as string.
	* @return Data type of the job data
	*/
	std::string CCustomDataStream::GetDataTypeAsString()
	{
		LibMCData_uint32 bytesNeededDataType = 0;
		LibMCData_uint32 bytesWrittenDataType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetDataTypeAsString(m_pHandle, 0, &bytesNeededDataType, nullptr));
		std::vector<char> bufferDataType(bytesNeededDataType);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetDataTypeAsString(m_pHandle, bytesNeededDataType, &bytesWrittenDataType, &bufferDataType[0]));
		
		return std::string(&bufferDataType[0]);
	}
	
	/**
	* CCustomDataStream::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	std::string CCustomDataStream::GetMIMEType()
	{
		LibMCData_uint32 bytesNeededMimeType = 0;
		LibMCData_uint32 bytesWrittenMimeType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetMIMEType(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(m_pWrapper->m_WrapperTable.m_CustomDataStream_GetMIMEType(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	 * Method definitions for class CBuildJobData
	 */
	
	/**
	* CBuildJobData::GetJobUUID - returns the uuid of the parent build job.
	* @return UUID String
	*/
	std::string CBuildJobData::GetJobUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetJobUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetJobUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	 * Method definitions for class CBuildJobDataIterator
	 */
	
	/**
	* CBuildJobDataIterator::GetCurrentJobData - Returns the build job data the iterator points at.
	* @return returns the build job instance.
	*/
	PBuildJobData CBuildJobDataIterator::GetCurrentJobData()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobDataIterator_GetCurrentJobData(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobData>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJobExecutionData
	 */
	
	/**
	* CBuildJobExecutionData::GetExecutionUUID - returns the uuid of the parent build job execution.
	* @return UUID String
	*/
	std::string CBuildJobExecutionData::GetExecutionUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecutionData_GetExecutionUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecutionData_GetExecutionUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	 * Method definitions for class CBuildJobExecutionDataIterator
	 */
	
	/**
	* CBuildJobExecutionDataIterator::GetCurrentJobExecutionData - Returns the build job execution data the iterator points at.
	* @return returns the build job execution instance.
	*/
	PBuildJobExecutionData CBuildJobExecutionDataIterator::GetCurrentJobExecutionData()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecutionDataIterator_GetCurrentJobExecutionData(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobExecutionData>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJobExecution
	 */
	
	/**
	* CBuildJobExecution::GetExecutionUUID - returns the uuid of a build job execution.
	* @return UUID String
	*/
	std::string CBuildJobExecution::GetExecutionUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetExecutionUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetExecutionUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJobExecution::GetJobUUID - returns the uuid of the parent build job.
	* @return UUID String
	*/
	std::string CBuildJobExecution::GetJobUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetJobUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetJobUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJobExecution::GetStatus - returns the build job execution status.
	* @return Status Value
	*/
	eBuildJobExecutionStatus CBuildJobExecution::GetStatus()
	{
		eBuildJobExecutionStatus resultExecutionStatus = (eBuildJobExecutionStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetStatus(m_pHandle, &resultExecutionStatus));
		
		return resultExecutionStatus;
	}
	
	/**
	* CBuildJobExecution::ChangeStatus - sets the new build job execution status. Will fail if current status is not InProcess.
	* @param[in] eNewExecutionStatus - Status Value
	* @param[in] nAbsoluteEndTimeStampInMicrosecondsSince1970 - New End Time of execution in Microseconds since 1970. MUST be larger or equal than start time stamp.
	*/
	void CBuildJobExecution::ChangeStatus(const eBuildJobExecutionStatus eNewExecutionStatus, const LibMCData_uint64 nAbsoluteEndTimeStampInMicrosecondsSince1970)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_ChangeStatus(m_pHandle, eNewExecutionStatus, nAbsoluteEndTimeStampInMicrosecondsSince1970));
	}
	
	/**
	* CBuildJobExecution::GetDescription - returns the build job description.
	* @return Current Description.
	*/
	std::string CBuildJobExecution::GetDescription()
	{
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetDescription(m_pHandle, 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetDescription(m_pHandle, bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CBuildJobExecution::SetDescription - sets the build job description. Should not be an empty string.
	* @param[in] sNewDescription - New Description.
	*/
	void CBuildJobExecution::SetDescription(const std::string & sNewDescription)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_SetDescription(m_pHandle, sNewDescription.c_str()));
	}
	
	/**
	* CBuildJobExecution::GetJournalUUID - returns the uuid of the execution journal.
	* @return UUID String
	*/
	std::string CBuildJobExecution::GetJournalUUID()
	{
		LibMCData_uint32 bytesNeededJournalUUID = 0;
		LibMCData_uint32 bytesWrittenJournalUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetJournalUUID(m_pHandle, 0, &bytesNeededJournalUUID, nullptr));
		std::vector<char> bufferJournalUUID(bytesNeededJournalUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetJournalUUID(m_pHandle, bytesNeededJournalUUID, &bytesWrittenJournalUUID, &bufferJournalUUID[0]));
		
		return std::string(&bufferJournalUUID[0]);
	}
	
	/**
	* CBuildJobExecution::GetUserUUID - returns the uuid of the user that created the build job.
	* @return UUID String or 00000000-0000-0000-0000-000000000000 if no user is attached.
	*/
	std::string CBuildJobExecution::GetUserUUID()
	{
		LibMCData_uint32 bytesNeededUserUUID = 0;
		LibMCData_uint32 bytesWrittenUserUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetUserUUID(m_pHandle, 0, &bytesNeededUserUUID, nullptr));
		std::vector<char> bufferUserUUID(bytesNeededUserUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetUserUUID(m_pHandle, bytesNeededUserUUID, &bytesWrittenUserUUID, &bufferUserUUID[0]));
		
		return std::string(&bufferUserUUID[0]);
	}
	
	/**
	* CBuildJobExecution::GetStartTimeStampInMicroseconds - Returns the start time stamp of the build execution in the machine journal.
	* @return TimeStamp when the build started in Microseconds.
	*/
	LibMCData_uint64 CBuildJobExecution::GetStartTimeStampInMicroseconds()
	{
		LibMCData_uint64 resultTimeStampInMicroseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetStartTimeStampInMicroseconds(m_pHandle, &resultTimeStampInMicroseconds));
		
		return resultTimeStampInMicroseconds;
	}
	
	/**
	* CBuildJobExecution::GetEndTimeStampInMicroseconds - Returns the end time stamp of the build execution in the machine journal. Status MUST BE in Finished or Failed to retrieve this value.
	* @return TimeStamp when the build ended in Microseconds.
	*/
	LibMCData_uint64 CBuildJobExecution::GetEndTimeStampInMicroseconds()
	{
		LibMCData_uint64 resultTimeStampInMicroseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetEndTimeStampInMicroseconds(m_pHandle, &resultTimeStampInMicroseconds));
		
		return resultTimeStampInMicroseconds;
	}
	
	/**
	* CBuildJobExecution::ComputeElapsedTimeInMicroseconds - Computes the relative time of the build execution. If status is Finished or Failed, the full duration is returned. Fails if the journal UUID does not match the current journaling session.
	* @param[in] nGlobalTimerInMicroseconds - The current session global timer.
	* @return Elapsed time in Microseconds.
	*/
	LibMCData_uint64 CBuildJobExecution::ComputeElapsedTimeInMicroseconds(const LibMCData_uint64 nGlobalTimerInMicroseconds)
	{
		LibMCData_uint64 resultElapsedTimeInMicroseconds = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_ComputeElapsedTimeInMicroseconds(m_pHandle, nGlobalTimerInMicroseconds, &resultElapsedTimeInMicroseconds));
		
		return resultElapsedTimeInMicroseconds;
	}
	
	/**
	* CBuildJobExecution::AddJobExecutionData - Adds additional data to the Job Execution.
	* @param[in] sIdentifier - Unique identifier for the job data.
	* @param[in] sName - Name of the job data
	* @param[in] pStream - Storage Stream Instance
	* @param[in] eDataType - Datatype of Job Execution data
	* @param[in] sUserUUID - UUID of Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CBuildJobExecution::AddJobExecutionData(const std::string & sIdentifier, const std::string & sName, classParam<CStorageStream> pStream, const eCustomDataType eDataType, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		LibMCDataHandle hStream = pStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_AddJobExecutionData(m_pHandle, sIdentifier.c_str(), sName.c_str(), hStream, eDataType, sUserUUID.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CBuildJobExecution::ListJobExecutionDataByType - Retrieves a list of build job execution data objects, filtered by type.
	* @param[in] eDataType - Datatype of Job Execution data.
	* @return Build Job Execution Data Iterator Instance.
	*/
	PBuildJobExecutionDataIterator CBuildJobExecution::ListJobExecutionDataByType(const eCustomDataType eDataType)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_ListJobExecutionDataByType(m_pHandle, eDataType, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobExecutionDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJobExecution::ListJobExecutionData - Retrieves a list of build job execution data objects.
	* @return Build Job Execution Data Iterator Instance.
	*/
	PBuildJobExecutionDataIterator CBuildJobExecution::ListJobExecutionData()
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_ListJobExecutionData(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobExecutionDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJobExecution::RetrieveJobExecutionData - Retrieves a build job execution data instance by its uuid.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job ExecutionData Instance.
	*/
	PBuildJobExecutionData CBuildJobExecution::RetrieveJobExecutionData(const std::string & sDataUUID)
	{
		LibMCDataHandle hBuildJobExecutionData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_RetrieveJobExecutionData(m_pHandle, sDataUUID.c_str(), &hBuildJobExecutionData));
		
		if (!hBuildJobExecutionData) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobExecutionData>(m_pWrapper, hBuildJobExecutionData);
	}
	
	/**
	* CBuildJobExecution::RetrieveJobExecutionDataByIdentifier - Retrieves a build job execution data instance by its identifier.
	* @param[in] sIdentifier - Job Execution Data Identifier. Fails if identifier does not exist.
	* @return Build Job Execution Data Instance.
	*/
	PBuildJobExecutionData CBuildJobExecution::RetrieveJobExecutionDataByIdentifier(const std::string & sIdentifier)
	{
		LibMCDataHandle hBuildJobExecutionData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_RetrieveJobExecutionDataByIdentifier(m_pHandle, sIdentifier.c_str(), &hBuildJobExecutionData));
		
		if (!hBuildJobExecutionData) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobExecutionData>(m_pWrapper, hBuildJobExecutionData);
	}
	
	/**
	* CBuildJobExecution::HasJobExecutionDataUUID - Retrieves if a build job execution data instance with a specific UUID exists in this job execution.
	* @param[in] sUUID - Job Execution Data UUID. Fails if UUID does not exist.
	* @return Returns true, if the job execution data exists.
	*/
	bool CBuildJobExecution::HasJobExecutionDataUUID(const std::string & sUUID)
	{
		bool resultHasJobExecutionData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_HasJobExecutionDataUUID(m_pHandle, sUUID.c_str(), &resultHasJobExecutionData));
		
		return resultHasJobExecutionData;
	}
	
	/**
	* CBuildJobExecution::HasJobExecutionDataIdentifier - Retrieves if a build job execution data instance with a specific identifier exists.
	* @param[in] sIdentifier - Job Execution Data Identifier. Fails if identifier does not exist.
	* @return Returns true, if the job execution data exists.
	*/
	bool CBuildJobExecution::HasJobExecutionDataIdentifier(const std::string & sIdentifier)
	{
		bool resultHasJobExecutionData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_HasJobExecutionDataIdentifier(m_pHandle, sIdentifier.c_str(), &resultHasJobExecutionData));
		
		return resultHasJobExecutionData;
	}
	
	/**
	* CBuildJobExecution::StoreMetaDataString - Adds a Metadata String to the build job.
	* @param[in] sKey - Unique key of value. MUST NOT be empty. MUST consist of alphanumeric characters or hyphen or underscore. Fails if Key already exists.
	* @param[in] sValue - Value to store.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CBuildJobExecution::StoreMetaDataString(const std::string & sKey, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_StoreMetaDataString(m_pHandle, sKey.c_str(), sValue.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CBuildJobExecution::HasMetaDataString - Checks if a metadata string exists.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Returns if metadata string exists.
	*/
	bool CBuildJobExecution::HasMetaDataString(const std::string & sKey)
	{
		bool resultMetaDataStringExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_HasMetaDataString(m_pHandle, sKey.c_str(), &resultMetaDataStringExists));
		
		return resultMetaDataStringExists;
	}
	
	/**
	* CBuildJobExecution::GetMetaDataString - Gets a metadata string of a build execution. Fails if Meta Data does not exist.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Return value.
	*/
	std::string CBuildJobExecution::GetMetaDataString(const std::string & sKey)
	{
		LibMCData_uint32 bytesNeededValue = 0;
		LibMCData_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetMetaDataString(m_pHandle, sKey.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecution_GetMetaDataString(m_pHandle, sKey.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	 * Method definitions for class CBuildJobExecutionIterator
	 */
	
	/**
	* CBuildJobExecutionIterator::GetCurrentJobExecution - Returns the build job execution the iterator points at.
	* @return returns the build job  execution instance.
	*/
	PBuildJobExecution CBuildJobExecutionIterator::GetCurrentJobExecution()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobExecutionIterator_GetCurrentJobExecution(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobExecution>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJob
	 */
	
	/**
	* CBuildJob::GetUUID - returns the uuid of a build job.
	* @return UUID String
	*/
	std::string CBuildJob::GetUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJob::GetName - returns the name of a build job.
	* @return Name String
	*/
	std::string CBuildJob::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBuildJob::GetStatus - returns the status of a build job.
	* @return Status of build job.
	*/
	eBuildJobStatus CBuildJob::GetStatus()
	{
		eBuildJobStatus resultStatus = (eBuildJobStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStatus(m_pHandle, &resultStatus));
		
		return resultStatus;
	}
	
	/**
	* CBuildJob::GetLayerCount - returns the layer count of a build job.
	* @return Layer Count of build job
	*/
	LibMCData_uint32 CBuildJob::GetLayerCount()
	{
		LibMCData_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CBuildJob::GetTimeStamp - returns the timestamp when the job was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CBuildJob::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CBuildJob::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	PStorageStream CBuildJob::GetStorageStream()
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStream(m_pHandle, &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CBuildJob::GetStorageStreamUUID - returns the storage stream uuid of the build.
	* @return Stream UUID.
	*/
	std::string CBuildJob::GetStorageStreamUUID()
	{
		LibMCData_uint32 bytesNeededStreamUUID = 0;
		LibMCData_uint32 bytesWrittenStreamUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStreamUUID(m_pHandle, 0, &bytesNeededStreamUUID, nullptr));
		std::vector<char> bufferStreamUUID(bytesNeededStreamUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStreamUUID(m_pHandle, bytesNeededStreamUUID, &bytesWrittenStreamUUID, &bufferStreamUUID[0]));
		
		return std::string(&bufferStreamUUID[0]);
	}
	
	/**
	* CBuildJob::StartValidating - Starts validation of a build job.
	*/
	void CBuildJob::StartValidating()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_StartValidating(m_pHandle));
	}
	
	/**
	* CBuildJob::FinishValidating - Finishes validation of a build job.
	* @param[in] nLayerCount - Layer count
	*/
	void CBuildJob::FinishValidating(const LibMCData_uint32 nLayerCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_FinishValidating(m_pHandle, nLayerCount));
	}
	
	/**
	* CBuildJob::ArchiveJob - Archives a Job. Job MUST not be opened in the system. Job MUST be of state validated.
	*/
	void CBuildJob::ArchiveJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ArchiveJob(m_pHandle));
	}
	
	/**
	* CBuildJob::UnArchiveJob - Unarchives a Job. Job MUST be of state archived.
	*/
	void CBuildJob::UnArchiveJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_UnArchiveJob(m_pHandle));
	}
	
	/**
	* CBuildJob::DeleteJob - Deletes a Job permanently including all referencing data objects. Job MUST be of state archived to succeed.
	*/
	void CBuildJob::DeleteJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_DeleteJob(m_pHandle));
	}
	
	/**
	* CBuildJob::JobCanBeArchived - Returns if a job is opened.
	* @return returns if the job can be archived.
	*/
	bool CBuildJob::JobCanBeArchived()
	{
		bool resultCanBeArchived = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_JobCanBeArchived(m_pHandle, &resultCanBeArchived));
		
		return resultCanBeArchived;
	}
	
	/**
	* CBuildJob::AddJobData - Adds additional data to the Job. Job MUST be of state validated in order to add job data.
	* @param[in] sIdentifier - Unique identifier for the job data.
	* @param[in] sName - Name of the job data
	* @param[in] pStream - Storage Stream Instance
	* @param[in] eDataType - Datatype of Job data
	* @param[in] sUserID - Currently authenticated user
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970
	*/
	void CBuildJob::AddJobData(const std::string & sIdentifier, const std::string & sName, classParam<CStorageStream> pStream, const eCustomDataType eDataType, const std::string & sUserID, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		LibMCDataHandle hStream = pStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_AddJobData(m_pHandle, sIdentifier.c_str(), sName.c_str(), hStream, eDataType, sUserID.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CBuildJob::ListJobDataByType - Retrieves a list of build job data objects, filtered by type.
	* @param[in] eDataType - Datatype of Job data.
	* @return Build Job Data Iterator Instance.
	*/
	PBuildJobDataIterator CBuildJob::ListJobDataByType(const eCustomDataType eDataType)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ListJobDataByType(m_pHandle, eDataType, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJob::ListJobData - Retrieves a list of build job data objects.
	* @return Build Job Data Iterator Instance.
	*/
	PBuildJobDataIterator CBuildJob::ListJobData()
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ListJobData(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJob::RetrieveJobData - Retrieves a build job data instance by its uuid.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Data Instance.
	*/
	PBuildJobData CBuildJob::RetrieveJobData(const std::string & sDataUUID)
	{
		LibMCDataHandle hBuildJobData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_RetrieveJobData(m_pHandle, sDataUUID.c_str(), &hBuildJobData));
		
		if (!hBuildJobData) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobData>(m_pWrapper, hBuildJobData);
	}
	
	/**
	* CBuildJob::RetrieveJobDataByIdentifier - Retrieves a build job data instance by its identifier.
	* @param[in] sIdentifier - Job Data Identifier. Fails if identifier does not exist.
	* @return Build Job Data Instance.
	*/
	PBuildJobData CBuildJob::RetrieveJobDataByIdentifier(const std::string & sIdentifier)
	{
		LibMCDataHandle hBuildJobData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_RetrieveJobDataByIdentifier(m_pHandle, sIdentifier.c_str(), &hBuildJobData));
		
		if (!hBuildJobData) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobData>(m_pWrapper, hBuildJobData);
	}
	
	/**
	* CBuildJob::HasJobDataUUID - Retrieves if a build job data instance with a specific UUID exists.
	* @param[in] sUUID - Job Data UUID. Fails if UUID does not exist.
	* @return Returns true, if the job data exists.
	*/
	bool CBuildJob::HasJobDataUUID(const std::string & sUUID)
	{
		bool resultHasJobData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_HasJobDataUUID(m_pHandle, sUUID.c_str(), &resultHasJobData));
		
		return resultHasJobData;
	}
	
	/**
	* CBuildJob::HasJobDataIdentifier - Retrieves if a build job data instance with a specific identifier exists.
	* @param[in] sIdentifier - Job Data Identifier. Fails if identifier does not exist.
	* @return Returns true, if the job data exists.
	*/
	bool CBuildJob::HasJobDataIdentifier(const std::string & sIdentifier)
	{
		bool resultHasJobData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_HasJobDataIdentifier(m_pHandle, sIdentifier.c_str(), &resultHasJobData));
		
		return resultHasJobData;
	}
	
	/**
	* CBuildJob::StoreMetaDataString - Adds a Metadata String to the build job.
	* @param[in] sKey - Unique key of value. MUST NOT be empty. MUST consist of alphanumeric characters or hyphen or underscore. Fails if Key already exists.
	* @param[in] sValue - Value to store.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CBuildJob::StoreMetaDataString(const std::string & sKey, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_StoreMetaDataString(m_pHandle, sKey.c_str(), sValue.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CBuildJob::HasMetaDataString - Checks if a metadata string exists.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Returns if metadata string exists.
	*/
	bool CBuildJob::HasMetaDataString(const std::string & sKey)
	{
		bool resultMetaDataStringExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_HasMetaDataString(m_pHandle, sKey.c_str(), &resultMetaDataStringExists));
		
		return resultMetaDataStringExists;
	}
	
	/**
	* CBuildJob::GetMetaDataString - Gets a metadata string of a build execution. Fails if Meta Data does not exist.
	* @param[in] sKey - Unique key of value. Fails if Key already exists.
	* @return Return value.
	*/
	std::string CBuildJob::GetMetaDataString(const std::string & sKey)
	{
		LibMCData_uint32 bytesNeededValue = 0;
		LibMCData_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetMetaDataString(m_pHandle, sKey.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetMetaDataString(m_pHandle, sKey.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CBuildJob::CreateBuildJobExecution - Creates a new build job execution with state InProgress.
	* @param[in] sDescription - Description of the execution.
	* @param[in] sUserUUID - UUID of the user who created it. Use 00000000-0000-0000-0000-000000000000 if no user shall be recorded.
	* @param[in] nAbsoluteStartTimeStampInMicrosecondsSince1970 - Absolute Start Time in Microseconds since 1970.
	* @return Newly created execution instance.
	*/
	PBuildJobExecution CBuildJob::CreateBuildJobExecution(const std::string & sDescription, const std::string & sUserUUID, const LibMCData_uint64 nAbsoluteStartTimeStampInMicrosecondsSince1970)
	{
		LibMCDataHandle hExecutionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_CreateBuildJobExecution(m_pHandle, sDescription.c_str(), sUserUUID.c_str(), nAbsoluteStartTimeStampInMicrosecondsSince1970, &hExecutionInstance));
		
		if (!hExecutionInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobExecution>(m_pWrapper, hExecutionInstance);
	}
	
	/**
	* CBuildJob::RetrieveBuildJobExecution - Retrieves a new build job execution by uuid.
	* @param[in] sExecutionUUID - UUID of the execution to retrieve.
	* @return If UUID exists, returns execution instance. Otherwise, returns null.
	*/
	PBuildJobExecution CBuildJob::RetrieveBuildJobExecution(const std::string & sExecutionUUID)
	{
		LibMCDataHandle hExecutionInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_RetrieveBuildJobExecution(m_pHandle, sExecutionUUID.c_str(), &hExecutionInstance));
		
		if (hExecutionInstance) {
			return std::make_shared<CBuildJobExecution>(m_pWrapper, hExecutionInstance);
		} else {
			return nullptr;
		}
	}
	
	/**
	* CBuildJob::RetrieveBuildJobExecutions - Retrieves multiple executions of the build job.
	* @param[in] sJournalUUIDFilter - UUID of the journal to filter from. Ignored if empty string.
	* @return Returns the list of execution instances that are queried. List may be empty.
	*/
	PBuildJobExecutionIterator CBuildJob::RetrieveBuildJobExecutions(const std::string & sJournalUUIDFilter)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_RetrieveBuildJobExecutions(m_pHandle, sJournalUUIDFilter.c_str(), &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobExecutionIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJob::RetrieveBuildJobExecutionsByStatus - Retrieves multiple executions of the build job.
	* @param[in] eStatusFilter - Status to filter the executions from.
	* @param[in] sJournalUUIDFilter - UUID of the journal to filter from. Ignored if empty string.
	* @return Returns the list of execution instances that are queried. List may be empty.
	*/
	PBuildJobExecutionIterator CBuildJob::RetrieveBuildJobExecutionsByStatus(const eBuildJobExecutionStatus eStatusFilter, const std::string & sJournalUUIDFilter)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_RetrieveBuildJobExecutionsByStatus(m_pHandle, eStatusFilter, sJournalUUIDFilter.c_str(), &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobExecutionIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	 * Method definitions for class CBuildJobIterator
	 */
	
	/**
	* CBuildJobIterator::GetCurrentJob - Returns the build job the iterator points at.
	* @return returns the build job instance.
	*/
	PBuildJob CBuildJobIterator::GetCurrentJob()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobIterator_GetCurrentJob(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJobHandler
	 */
	
	/**
	* CBuildJobHandler::CreateJob - Creates a new build job.
	* @param[in] sJobUUID - UUID String for the build job. Must be unique and newly generated.
	* @param[in] sName - Name String
	* @param[in] sUserID - Currently authenticated user
	* @param[in] sStorageStreamUUID - Storage stream uuid for the job. Needs not exist yet.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		LibMCDataHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_CreateJob(m_pHandle, sJobUUID.c_str(), sName.c_str(), sUserID.c_str(), sStorageStreamUUID.c_str(), nAbsoluteTimeStamp, &hJobInstance));
		
		if (!hJobInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hJobInstance);
	}
	
	/**
	* CBuildJobHandler::RetrieveJob - Retrieves a job with a specific UUID.
	* @param[in] sJobUUID - UUID String for the build job. Must be an existing Job.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::RetrieveJob(const std::string & sJobUUID)
	{
		LibMCDataHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_RetrieveJob(m_pHandle, sJobUUID.c_str(), &hJobInstance));
		
		if (!hJobInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hJobInstance);
	}
	
	/**
	* CBuildJobHandler::FindJobOfData - Finds the parent build job of a given data uuid. Fails if data does not exist.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::FindJobOfData(const std::string & sDataUUID)
	{
		LibMCDataHandle hBuildJobData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_FindJobOfData(m_pHandle, sDataUUID.c_str(), &hBuildJobData));
		
		if (!hBuildJobData) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hBuildJobData);
	}
	
	/**
	* CBuildJobHandler::ListJobsByStatus - Retrieves a list of build jobs, filtered by status.
	* @param[in] eStatus - Job Status to list.
	* @return Build Job Iterator Instance.
	*/
	PBuildJobIterator CBuildJobHandler::ListJobsByStatus(const eBuildJobStatus eStatus)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ListJobsByStatus(m_pHandle, eStatus, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJobHandler::ConvertBuildStatusToString - Converts a status enum to a string identifier.
	* @param[in] eStatus - Status Enum.
	* @return String Identifier.
	*/
	std::string CBuildJobHandler::ConvertBuildStatusToString(const eBuildJobStatus eStatus)
	{
		LibMCData_uint32 bytesNeededString = 0;
		LibMCData_uint32 bytesWrittenString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertBuildStatusToString(m_pHandle, eStatus, 0, &bytesNeededString, nullptr));
		std::vector<char> bufferString(bytesNeededString);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertBuildStatusToString(m_pHandle, eStatus, bytesNeededString, &bytesWrittenString, &bufferString[0]));
		
		return std::string(&bufferString[0]);
	}
	
	/**
	* CBuildJobHandler::ConvertStringToBuildStatus - Converts a string identifier to a status enum. Case sensitive. Fails if invalid.
	* @param[in] sString - String Identifier.
	* @return Status Enum.
	*/
	eBuildJobStatus CBuildJobHandler::ConvertStringToBuildStatus(const std::string & sString)
	{
		eBuildJobStatus resultStatus = (eBuildJobStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertStringToBuildStatus(m_pHandle, sString.c_str(), &resultStatus));
		
		return resultStatus;
	}
	
	/**
	 * Method definitions for class CUserList
	 */
	
	/**
	* CUserList::Count - Result Number of Users in the list.
	* @return Number of users in the list
	*/
	LibMCData_uint32 CUserList::Count()
	{
		LibMCData_uint32 resultUserCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserList_Count(m_pHandle, &resultUserCount));
		
		return resultUserCount;
	}
	
	/**
	* CUserList::GetUserProperties - Retrieves all the data of a user in the list. 
	* @param[in] nUserIndex - Index of users in the list (0-based). Call will fail if invalid index is provided.
	* @param[out] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	void CUserList::GetUserProperties(const LibMCData_uint32 nUserIndex, std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier)
	{
		LibMCData_uint32 bytesNeededUsername = 0;
		LibMCData_uint32 bytesWrittenUsername = 0;
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_UserList_GetUserProperties(m_pHandle, nUserIndex, 0, &bytesNeededUsername, nullptr, 0, &bytesNeededUUID, nullptr, 0, &bytesNeededDescription, nullptr, 0, &bytesNeededRole, nullptr, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		std::vector<char> bufferUUID(bytesNeededUUID);
		std::vector<char> bufferDescription(bytesNeededDescription);
		std::vector<char> bufferRole(bytesNeededRole);
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_UserList_GetUserProperties(m_pHandle, nUserIndex, bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0], bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0], bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], bytesNeededRole, &bytesWrittenRole, &bufferRole[0], bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		sUsername = std::string(&bufferUsername[0]);
		sUUID = std::string(&bufferUUID[0]);
		sDescription = std::string(&bufferDescription[0]);
		sRole = std::string(&bufferRole[0]);
		sLanguageIdentifier = std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	 * Method definitions for class CLoginHandler
	 */
	
	/**
	* CLoginHandler::UserExists - Checks if a user exist.
	* @param[in] sUsername - User name
	* @return Flag if users exists
	*/
	bool CLoginHandler::UserExists(const std::string & sUsername)
	{
		bool resultUserExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_UserExists(m_pHandle, sUsername.c_str(), &resultUserExists));
		
		return resultUserExists;
	}
	
	/**
	* CLoginHandler::UserUUIDExists - Checks if a user UUID exist.
	* @param[in] sUUID - UUID of the user.
	* @return Flag if users exists
	*/
	bool CLoginHandler::UserUUIDExists(const std::string & sUUID)
	{
		bool resultUserExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_UserUUIDExists(m_pHandle, sUUID.c_str(), &resultUserExists));
		
		return resultUserExists;
	}
	
	/**
	* CLoginHandler::GetUserDetails - Retrieves login relevant users data. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sSalt - Salt of the user.
	* @param[out] sHashedPassword - Hashed Password.
	*/
	void CLoginHandler::GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword)
	{
		LibMCData_uint32 bytesNeededSalt = 0;
		LibMCData_uint32 bytesWrittenSalt = 0;
		LibMCData_uint32 bytesNeededHashedPassword = 0;
		LibMCData_uint32 bytesWrittenHashedPassword = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDetails(m_pHandle, sUsername.c_str(), 0, &bytesNeededSalt, nullptr, 0, &bytesNeededHashedPassword, nullptr));
		std::vector<char> bufferSalt(bytesNeededSalt);
		std::vector<char> bufferHashedPassword(bytesNeededHashedPassword);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDetails(m_pHandle, sUsername.c_str(), bytesNeededSalt, &bytesWrittenSalt, &bufferSalt[0], bytesNeededHashedPassword, &bytesWrittenHashedPassword, &bufferHashedPassword[0]));
		sSalt = std::string(&bufferSalt[0]);
		sHashedPassword = std::string(&bufferHashedPassword[0]);
	}
	
	/**
	* CLoginHandler::GetUserProperties - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[out] sUUID - UUID of the user.
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	void CLoginHandler::GetUserProperties(const std::string & sUsername, std::string & sUUID, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier)
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserProperties(m_pHandle, sUsername.c_str(), 0, &bytesNeededUUID, nullptr, 0, &bytesNeededDescription, nullptr, 0, &bytesNeededRole, nullptr, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		std::vector<char> bufferDescription(bytesNeededDescription);
		std::vector<char> bufferRole(bytesNeededRole);
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserProperties(m_pHandle, sUsername.c_str(), bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0], bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], bytesNeededRole, &bytesWrittenRole, &bufferRole[0], bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		sUUID = std::string(&bufferUUID[0]);
		sDescription = std::string(&bufferDescription[0]);
		sRole = std::string(&bufferRole[0]);
		sLanguageIdentifier = std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CLoginHandler::GetUserPropertiesByUUID - Retrieves all users data with one Transaction. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[out] sUsername - User name
	* @param[out] sDescription - Description of the user.
	* @param[out] sRole - Role of the user.
	* @param[out] sLanguageIdentifier - LanguageIdentifier of the user.
	*/
	void CLoginHandler::GetUserPropertiesByUUID(const std::string & sUUID, std::string & sUsername, std::string & sDescription, std::string & sRole, std::string & sLanguageIdentifier)
	{
		LibMCData_uint32 bytesNeededUsername = 0;
		LibMCData_uint32 bytesWrittenUsername = 0;
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserPropertiesByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededUsername, nullptr, 0, &bytesNeededDescription, nullptr, 0, &bytesNeededRole, nullptr, 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		std::vector<char> bufferDescription(bytesNeededDescription);
		std::vector<char> bufferRole(bytesNeededRole);
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserPropertiesByUUID(m_pHandle, sUUID.c_str(), bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0], bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0], bytesNeededRole, &bytesWrittenRole, &bufferRole[0], bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		sUsername = std::string(&bufferUsername[0]);
		sDescription = std::string(&bufferDescription[0]);
		sRole = std::string(&bufferRole[0]);
		sLanguageIdentifier = std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CLoginHandler::GetUsernameByUUID - Retrieves a users name with a given UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return User name
	*/
	std::string CLoginHandler::GetUsernameByUUID(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededUsername = 0;
		LibMCData_uint32 bytesWrittenUsername = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUsernameByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededUsername, nullptr));
		std::vector<char> bufferUsername(bytesNeededUsername);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUsernameByUUID(m_pHandle, sUUID.c_str(), bytesNeededUsername, &bytesWrittenUsername, &bufferUsername[0]));
		
		return std::string(&bufferUsername[0]);
	}
	
	/**
	* CLoginHandler::GetUserUUID - Retrieves a users UUID. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return UUID of the user.
	*/
	std::string CLoginHandler::GetUserUUID(const std::string & sUsername)
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserUUID(m_pHandle, sUsername.c_str(), 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserUUID(m_pHandle, sUsername.c_str(), bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CLoginHandler::GetUserDescription - Retrieves a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Description of the user.
	*/
	std::string CLoginHandler::GetUserDescription(const std::string & sUsername)
	{
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDescription(m_pHandle, sUsername.c_str(), 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDescription(m_pHandle, sUsername.c_str(), bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CLoginHandler::GetUserDescriptionByUUID - Retrieves a users description by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Description of the user.
	*/
	std::string CLoginHandler::GetUserDescriptionByUUID(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededDescription = 0;
		LibMCData_uint32 bytesWrittenDescription = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDescriptionByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededDescription, nullptr));
		std::vector<char> bufferDescription(bytesNeededDescription);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDescriptionByUUID(m_pHandle, sUUID.c_str(), bytesNeededDescription, &bytesWrittenDescription, &bufferDescription[0]));
		
		return std::string(&bufferDescription[0]);
	}
	
	/**
	* CLoginHandler::GetUserRole - Retrieves a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Role of the user.
	*/
	std::string CLoginHandler::GetUserRole(const std::string & sUsername)
	{
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserRole(m_pHandle, sUsername.c_str(), 0, &bytesNeededRole, nullptr));
		std::vector<char> bufferRole(bytesNeededRole);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserRole(m_pHandle, sUsername.c_str(), bytesNeededRole, &bytesWrittenRole, &bufferRole[0]));
		
		return std::string(&bufferRole[0]);
	}
	
	/**
	* CLoginHandler::GetUserRoleByUUID - Retrieves a users role by the user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Role of the user.
	*/
	std::string CLoginHandler::GetUserRoleByUUID(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededRole = 0;
		LibMCData_uint32 bytesWrittenRole = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserRoleByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededRole, nullptr));
		std::vector<char> bufferRole(bytesNeededRole);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserRoleByUUID(m_pHandle, sUUID.c_str(), bytesNeededRole, &bytesWrittenRole, &bufferRole[0]));
		
		return std::string(&bufferRole[0]);
	}
	
	/**
	* CLoginHandler::GetUserLanguage - Retrieves a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @return Language identifier of the user.
	*/
	std::string CLoginHandler::GetUserLanguage(const std::string & sUsername)
	{
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserLanguage(m_pHandle, sUsername.c_str(), 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserLanguage(m_pHandle, sUsername.c_str(), bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		
		return std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CLoginHandler::GetUserLanguageByUUID - Retrieves a users language preference by user UUID. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @return Language identifier of the user.
	*/
	std::string CLoginHandler::GetUserLanguageByUUID(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededLanguageIdentifier = 0;
		LibMCData_uint32 bytesWrittenLanguageIdentifier = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserLanguageByUUID(m_pHandle, sUUID.c_str(), 0, &bytesNeededLanguageIdentifier, nullptr));
		std::vector<char> bufferLanguageIdentifier(bytesNeededLanguageIdentifier);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserLanguageByUUID(m_pHandle, sUUID.c_str(), bytesNeededLanguageIdentifier, &bytesWrittenLanguageIdentifier, &bufferLanguageIdentifier[0]));
		
		return std::string(&bufferLanguageIdentifier[0]);
	}
	
	/**
	* CLoginHandler::CreateUser - Creates a new user. Fails if the user already exists.
	* @param[in] sUsername - User name to create. MUST be alphanumeric and not empty.
	* @param[in] sRole - Role of the new user. MUST NOT be empty.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	* @param[in] sDescription - Description of the new user.
	* @return UUID of the new user.
	*/
	std::string CLoginHandler::CreateUser(const std::string & sUsername, const std::string & sRole, const std::string & sSalt, const std::string & sHashedPassword, const std::string & sDescription)
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_CreateUser(m_pHandle, sUsername.c_str(), sRole.c_str(), sSalt.c_str(), sHashedPassword.c_str(), sDescription.c_str(), 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_CreateUser(m_pHandle, sUsername.c_str(), sRole.c_str(), sSalt.c_str(), sHashedPassword.c_str(), sDescription.c_str(), bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CLoginHandler::SetUserLanguage - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	void CLoginHandler::SetUserLanguage(const std::string & sUsername, const std::string & sLanguageIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserLanguage(m_pHandle, sUsername.c_str(), sLanguageIdentifier.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserRole - Updates a users role. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sRole - New Role identifier of the user.
	*/
	void CLoginHandler::SetUserRole(const std::string & sUsername, const std::string & sRole)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserRole(m_pHandle, sUsername.c_str(), sRole.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserDescription - Updates a users description. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sDescription - New Description of the user.
	*/
	void CLoginHandler::SetUserDescription(const std::string & sUsername, const std::string & sDescription)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserDescription(m_pHandle, sUsername.c_str(), sDescription.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserPassword - Updates a users password. Fails if user does not exist.
	* @param[in] sUsername - User name
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	void CLoginHandler::SetUserPassword(const std::string & sUsername, const std::string & sSalt, const std::string & sHashedPassword)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserPassword(m_pHandle, sUsername.c_str(), sSalt.c_str(), sHashedPassword.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserLanguageByUUID - Updates a users language preference. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sLanguageIdentifier - New Language identifier of the user.
	*/
	void CLoginHandler::SetUserLanguageByUUID(const std::string & sUUID, const std::string & sLanguageIdentifier)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserLanguageByUUID(m_pHandle, sUUID.c_str(), sLanguageIdentifier.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserRoleByUUID - Updates a users role. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sRole - New Role identifier of the user.
	*/
	void CLoginHandler::SetUserRoleByUUID(const std::string & sUUID, const std::string & sRole)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserRoleByUUID(m_pHandle, sUUID.c_str(), sRole.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserDescriptionByUUID - Updates a users description. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sDescription - New Language identifier of the user.
	*/
	void CLoginHandler::SetUserDescriptionByUUID(const std::string & sUUID, const std::string & sDescription)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserDescriptionByUUID(m_pHandle, sUUID.c_str(), sDescription.c_str()));
	}
	
	/**
	* CLoginHandler::SetUserPasswordByUUID - Updates a users password. Fails if user does not exist.
	* @param[in] sUUID - UUID of the user.
	* @param[in] sSalt - Salt of the user. MUST NOT be empty. MUST be an SHA256 string.
	* @param[in] sHashedPassword - Hashed Password. MUST be an SHA256 string. HashedPassword MUST NOT be the hash some of the given salt.
	*/
	void CLoginHandler::SetUserPasswordByUUID(const std::string & sUUID, const std::string & sSalt, const std::string & sHashedPassword)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_SetUserPasswordByUUID(m_pHandle, sUUID.c_str(), sSalt.c_str(), sHashedPassword.c_str()));
	}
	
	/**
	* CLoginHandler::GetActiveUsers - Returns a list of active users.
	* @return New instance of active users.
	*/
	PUserList CLoginHandler::GetActiveUsers()
	{
		LibMCDataHandle hActiveUsers = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetActiveUsers(m_pHandle, &hActiveUsers));
		
		if (!hActiveUsers) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CUserList>(m_pWrapper, hActiveUsers);
	}
	
	/**
	 * Method definitions for class CPersistencyHandler
	 */
	
	/**
	* CPersistencyHandler::HasPersistentParameter - Retrieves if a persistent parameter has been stored.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter exists.
	*/
	bool CPersistencyHandler::HasPersistentParameter(const std::string & sUUID)
	{
		bool resultParameterExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_HasPersistentParameter(m_pHandle, sUUID.c_str(), &resultParameterExists));
		
		return resultParameterExists;
	}
	
	/**
	* CPersistencyHandler::GetPersistentParameterDetails - Retrieves details of a persistent parameter. Fails if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @param[out] sName - Returns name of the parameter
	* @param[out] eDataType - Returns data type of the parameter
	*/
	void CPersistencyHandler::GetPersistentParameterDetails(const std::string & sUUID, std::string & sName, eParameterDataType & eDataType)
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_GetPersistentParameterDetails(m_pHandle, sUUID.c_str(), 0, &bytesNeededName, nullptr, &eDataType));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_GetPersistentParameterDetails(m_pHandle, sUUID.c_str(), bytesNeededName, &bytesWrittenName, &bufferName[0], &eDataType));
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* CPersistencyHandler::DeletePersistentParameter - Removes a persistent parameter from database. Does nothing if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter existed.
	*/
	bool CPersistencyHandler::DeletePersistentParameter(const std::string & sUUID)
	{
		bool resultParameterExisted = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_DeletePersistentParameter(m_pHandle, sUUID.c_str(), &resultParameterExisted));
		
		return resultParameterExisted;
	}
	
	/**
	* CPersistencyHandler::StorePersistentParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] eDataType - Data type of the parameter. If parameter exists, MUST be the same as the stored parameter data type.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CPersistencyHandler::StorePersistentParameter(const std::string & sUUID, const std::string & sName, const eParameterDataType eDataType, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentParameter(m_pHandle, sUUID.c_str(), sName.c_str(), eDataType, sValue.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CPersistencyHandler::StorePersistentStringParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CPersistencyHandler::StorePersistentStringParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentStringParameter(m_pHandle, sUUID.c_str(), sName.c_str(), sValue.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CPersistencyHandler::StorePersistentUUIDParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CPersistencyHandler::StorePersistentUUIDParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentUUIDParameter(m_pHandle, sUUID.c_str(), sName.c_str(), sValue.c_str(), nAbsoluteTimeStamp));
	}
	
	/**
	* CPersistencyHandler::StorePersistentDoubleParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] dValue - Value of the parameter.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CPersistencyHandler::StorePersistentDoubleParameter(const std::string & sUUID, const std::string & sName, const LibMCData_double dValue, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentDoubleParameter(m_pHandle, sUUID.c_str(), sName.c_str(), dValue, nAbsoluteTimeStamp));
	}
	
	/**
	* CPersistencyHandler::StorePersistentIntegerParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] nValue - Value of the parameter.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CPersistencyHandler::StorePersistentIntegerParameter(const std::string & sUUID, const std::string & sName, const LibMCData_int64 nValue, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentIntegerParameter(m_pHandle, sUUID.c_str(), sName.c_str(), nValue, nAbsoluteTimeStamp));
	}
	
	/**
	* CPersistencyHandler::StorePersistentBoolParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] bValue - Value of the parameter.
	* @param[in] nAbsoluteTimeStamp - Absolute Time Stamp in Microseconds since 1970.
	*/
	void CPersistencyHandler::StorePersistentBoolParameter(const std::string & sUUID, const std::string & sName, const bool bValue, const LibMCData_uint64 nAbsoluteTimeStamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentBoolParameter(m_pHandle, sUUID.c_str(), sName.c_str(), bValue, nAbsoluteTimeStamp));
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentStringParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	std::string CPersistencyHandler::RetrievePersistentStringParameter(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededValue = 0;
		LibMCData_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentStringParameter(m_pHandle, sUUID.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentStringParameter(m_pHandle, sUUID.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentUUIDParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	std::string CPersistencyHandler::RetrievePersistentUUIDParameter(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededValue = 0;
		LibMCData_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentUUIDParameter(m_pHandle, sUUID.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentUUIDParameter(m_pHandle, sUUID.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentDoubleParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	LibMCData_double CPersistencyHandler::RetrievePersistentDoubleParameter(const std::string & sUUID)
	{
		LibMCData_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentDoubleParameter(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentIntegerParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	LibMCData_int64 CPersistencyHandler::RetrievePersistentIntegerParameter(const std::string & sUUID)
	{
		LibMCData_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentIntegerParameter(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentBoolParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	bool CPersistencyHandler::RetrievePersistentBoolParameter(const std::string & sUUID)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentBoolParameter(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	 * Method definitions for class CInstallationInformation
	 */
	
	/**
	* CInstallationInformation::GetInstallationUUID - Returns the installation UUID.
	* @return Installation UUID. Public value to document which installation was used for something.
	*/
	std::string CInstallationInformation::GetInstallationUUID()
	{
		LibMCData_uint32 bytesNeededInstallationUUID = 0;
		LibMCData_uint32 bytesWrittenInstallationUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_InstallationInformation_GetInstallationUUID(m_pHandle, 0, &bytesNeededInstallationUUID, nullptr));
		std::vector<char> bufferInstallationUUID(bytesNeededInstallationUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_InstallationInformation_GetInstallationUUID(m_pHandle, bytesNeededInstallationUUID, &bytesWrittenInstallationUUID, &bufferInstallationUUID[0]));
		
		return std::string(&bufferInstallationUUID[0]);
	}
	
	/**
	* CInstallationInformation::GetInstallationSecret - Returns the installation Secret.
	* @return Secret SHA256 key for seeding external-facing pseudo-randomness. MUST NOT be given outside of the application.
	*/
	std::string CInstallationInformation::GetInstallationSecret()
	{
		LibMCData_uint32 bytesNeededInstallationSecret = 0;
		LibMCData_uint32 bytesWrittenInstallationSecret = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_InstallationInformation_GetInstallationSecret(m_pHandle, 0, &bytesNeededInstallationSecret, nullptr));
		std::vector<char> bufferInstallationSecret(bytesNeededInstallationSecret);
		CheckError(m_pWrapper->m_WrapperTable.m_InstallationInformation_GetInstallationSecret(m_pHandle, bytesNeededInstallationSecret, &bytesWrittenInstallationSecret, &bufferInstallationSecret[0]));
		
		return std::string(&bufferInstallationSecret[0]);
	}
	
	/**
	* CInstallationInformation::GetBaseTempDirectory - Returns a custom base temp directory. An empty string defaults to the system temp directory.
	* @return Temp directory path.
	*/
	std::string CInstallationInformation::GetBaseTempDirectory()
	{
		LibMCData_uint32 bytesNeededTempDirectory = 0;
		LibMCData_uint32 bytesWrittenTempDirectory = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_InstallationInformation_GetBaseTempDirectory(m_pHandle, 0, &bytesNeededTempDirectory, nullptr));
		std::vector<char> bufferTempDirectory(bytesNeededTempDirectory);
		CheckError(m_pWrapper->m_WrapperTable.m_InstallationInformation_GetBaseTempDirectory(m_pHandle, bytesNeededTempDirectory, &bytesWrittenTempDirectory, &bufferTempDirectory[0]));
		
		return std::string(&bufferTempDirectory[0]);
	}
	
	/**
	 * Method definitions for class CDataModel
	 */
	
	/**
	* CDataModel::InitialiseDatabase - initializes the database connection.
	* @param[in] sDataDirectory - Directory that stores the data.
	* @param[in] eDataBaseType - Type of database.
	* @param[in] sConnectionString - Connection string.
	*/
	void CDataModel::InitialiseDatabase(const std::string & sDataDirectory, const eDataBaseType eDataBaseType, const std::string & sConnectionString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_InitialiseDatabase(m_pHandle, sDataDirectory.c_str(), eDataBaseType, sConnectionString.c_str()));
	}
	
	/**
	* CDataModel::GetDataModelVersion - returns the linear data model version.
	* @return Data model version.
	*/
	LibMCData_uint32 CDataModel::GetDataModelVersion()
	{
		LibMCData_uint32 resultVersion = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetDataModelVersion(m_pHandle, &resultVersion));
		
		return resultVersion;
	}
	
	/**
	* CDataModel::GetInstallationInformation - DEPRECIATED. Only used for backwards compatibility. NEVER USE because of thread safety issues.. Use GetInstallationInformationObject instead.
	* @param[out] sDEPRECIATEDInstallationUUID - DEPRECIATED Installation UUID. Public value to document which installation was used for something.
	* @param[out] sDEPRECIATEDInstallationSecret - DEPRECIATED Secret SHA256 key for seeding external-facing pseudo-randomness. MUST NOT be given outside of the application.
	*/
	void CDataModel::GetInstallationInformation(std::string & sDEPRECIATEDInstallationUUID, std::string & sDEPRECIATEDInstallationSecret)
	{
		LibMCData_uint32 bytesNeededDEPRECIATEDInstallationUUID = 0;
		LibMCData_uint32 bytesWrittenDEPRECIATEDInstallationUUID = 0;
		LibMCData_uint32 bytesNeededDEPRECIATEDInstallationSecret = 0;
		LibMCData_uint32 bytesWrittenDEPRECIATEDInstallationSecret = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetInstallationInformation(m_pHandle, 0, &bytesNeededDEPRECIATEDInstallationUUID, nullptr, 0, &bytesNeededDEPRECIATEDInstallationSecret, nullptr));
		std::vector<char> bufferDEPRECIATEDInstallationUUID(bytesNeededDEPRECIATEDInstallationUUID);
		std::vector<char> bufferDEPRECIATEDInstallationSecret(bytesNeededDEPRECIATEDInstallationSecret);
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetInstallationInformation(m_pHandle, bytesNeededDEPRECIATEDInstallationUUID, &bytesWrittenDEPRECIATEDInstallationUUID, &bufferDEPRECIATEDInstallationUUID[0], bytesNeededDEPRECIATEDInstallationSecret, &bytesWrittenDEPRECIATEDInstallationSecret, &bufferDEPRECIATEDInstallationSecret[0]));
		sDEPRECIATEDInstallationUUID = std::string(&bufferDEPRECIATEDInstallationUUID[0]);
		sDEPRECIATEDInstallationSecret = std::string(&bufferDEPRECIATEDInstallationSecret[0]);
	}
	
	/**
	* CDataModel::GetInstallationInformationObject - returns unique identifiers for the current installation. MUST be used instead of depreciated functionality.
	* @return Installation information instance.
	*/
	PInstallationInformation CDataModel::GetInstallationInformationObject()
	{
		LibMCDataHandle hInstallationInformation = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetInstallationInformationObject(m_pHandle, &hInstallationInformation));
		
		if (!hInstallationInformation) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CInstallationInformation>(m_pWrapper, hInstallationInformation);
	}
	
	/**
	* CDataModel::CreateStorage - creates a storage access class.
	* @return Storage class instance.
	*/
	PStorage CDataModel::CreateStorage()
	{
		LibMCDataHandle hStorage = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateStorage(m_pHandle, &hStorage));
		
		if (!hStorage) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorage>(m_pWrapper, hStorage);
	}
	
	/**
	* CDataModel::CreateBuildJobHandler - creates a build job access class.
	* @return BuildJobHandler class instance.
	*/
	PBuildJobHandler CDataModel::CreateBuildJobHandler()
	{
		LibMCDataHandle hBuildJobHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateBuildJobHandler(m_pHandle, &hBuildJobHandler));
		
		if (!hBuildJobHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobHandler>(m_pWrapper, hBuildJobHandler);
	}
	
	/**
	* CDataModel::CreateNewLogSession - creates a global log session access class.
	* @return LogSession class instance.
	*/
	PLogSession CDataModel::CreateNewLogSession()
	{
		LibMCDataHandle hLogSession = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateNewLogSession(m_pHandle, &hLogSession));
		
		if (!hLogSession) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogSession>(m_pWrapper, hLogSession);
	}
	
	/**
	* CDataModel::CreateJournalSession - creates a global journal session access class.
	* @return JournalSession class instance.
	*/
	PJournalSession CDataModel::CreateJournalSession()
	{
		LibMCDataHandle hJournalSession = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateJournalSession(m_pHandle, &hJournalSession));
		
		if (!hJournalSession) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CJournalSession>(m_pWrapper, hJournalSession);
	}
	
	/**
	* CDataModel::CreateAlertSession - creates a global alert session access class.
	* @return AlertSession class instance.
	*/
	PAlertSession CDataModel::CreateAlertSession()
	{
		LibMCDataHandle hAlertSession = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateAlertSession(m_pHandle, &hAlertSession));
		
		if (!hAlertSession) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAlertSession>(m_pWrapper, hAlertSession);
	}
	
	/**
	* CDataModel::CreateLoginHandler - creates a login handler instance.
	* @return LoginHandler instance.
	*/
	PLoginHandler CDataModel::CreateLoginHandler()
	{
		LibMCDataHandle hLoginHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateLoginHandler(m_pHandle, &hLoginHandler));
		
		if (!hLoginHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLoginHandler>(m_pWrapper, hLoginHandler);
	}
	
	/**
	* CDataModel::CreatePersistencyHandler - creates a persistency handler instance.
	* @return PersistencyHandler instance.
	*/
	PPersistencyHandler CDataModel::CreatePersistencyHandler()
	{
		LibMCDataHandle hPersistencyHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreatePersistencyHandler(m_pHandle, &hPersistencyHandler));
		
		if (!hPersistencyHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPersistencyHandler>(m_pWrapper, hPersistencyHandler);
	}
	
	/**
	* CDataModel::SetBaseTempDirectory - Sets a custom base temp directory. An empty string defaults to the system temp directory.
	* @param[in] sTempDirectory - Temp directory path to use. SHOULD be an absolute path, if not empty. Directory MUST exist, if not empty.
	*/
	void CDataModel::SetBaseTempDirectory(const std::string & sTempDirectory)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_SetBaseTempDirectory(m_pHandle, sTempDirectory.c_str()));
	}
	
	/**
	* CDataModel::GetBaseTempDirectory - DEPRECIATED. Only used for backwards compatibility. NEVER USE because of thread safety issues.. USE GetInstallationInformationObject instead.
	* @return Temp directory path.
	*/
	std::string CDataModel::GetBaseTempDirectory()
	{
		LibMCData_uint32 bytesNeededTempDirectory = 0;
		LibMCData_uint32 bytesWrittenTempDirectory = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetBaseTempDirectory(m_pHandle, 0, &bytesNeededTempDirectory, nullptr));
		std::vector<char> bufferTempDirectory(bytesNeededTempDirectory);
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetBaseTempDirectory(m_pHandle, bytesNeededTempDirectory, &bytesWrittenTempDirectory, &bufferTempDirectory[0]));
		
		return std::string(&bufferTempDirectory[0]);
	}
	
	/**
	* CDataModel::SetLogCallback - Sets a log callback to be used for the execution.
	* @param[in] pLogCallback - LogCallback.
	* @param[in] pUserData - Userdata that is passed to the callback function
	*/
	void CDataModel::SetLogCallback(const LogCallback pLogCallback, const LibMCData_pvoid pUserData)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_SetLogCallback(m_pHandle, pLogCallback, pUserData));
	}
	
	/**
	* CDataModel::ClearLogCallback - Resets the log callback to be used for the execution.
	*/
	void CDataModel::ClearLogCallback()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_ClearLogCallback(m_pHandle));
	}
	
	/**
	* CDataModel::HasLogCallback - Returns if a log callback has been set.
	* @return Flag if log callback has been set.
	*/
	bool CDataModel::HasLogCallback()
	{
		bool resultHasCallback = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_HasLogCallback(m_pHandle, &resultHasCallback));
		
		return resultHasCallback;
	}
	
	/**
	* CDataModel::TriggerLogCallback - Triggers the log callback. Fails if no log callback has been set.
	* @param[in] sLogMessage - Log message to be logged.
	* @param[in] sSubSystem - SubSystem of Log Message.
	* @param[in] eLogLevel - Log Level to be used.
	* @param[in] sTimestamp - Timestamp of the log message.
	*/
	void CDataModel::TriggerLogCallback(const std::string & sLogMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_TriggerLogCallback(m_pHandle, sLogMessage.c_str(), sSubSystem.c_str(), eLogLevel, sTimestamp.c_str()));
	}

} // namespace LibMCData

#endif // __LIBMCDATA_CPPHEADER_DYNAMIC_CPP

