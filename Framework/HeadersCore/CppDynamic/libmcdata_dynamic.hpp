/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Machine Control data model library

Interface version: 1.0.0

*/

#ifndef __LIBMCDATA_CPPHEADER_DYNAMIC_CPP
#define __LIBMCDATA_CPPHEADER_DYNAMIC_CPP

#include "libmcdata_types.hpp"
#include "libmcdata_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMCData {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CIterator;
class CLogSession;
class CStorageStream;
class CStorage;
class CBuildJobData;
class CBuildJobDataIterator;
class CBuildJob;
class CBuildJobIterator;
class CBuildJobHandler;
class CLoginHandler;
class CPersistencyHandler;
class CDataModel;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCDataWrapper;
typedef CBase CLibMCDataBase;
typedef CIterator CLibMCDataIterator;
typedef CLogSession CLibMCDataLogSession;
typedef CStorageStream CLibMCDataStorageStream;
typedef CStorage CLibMCDataStorage;
typedef CBuildJobData CLibMCDataBuildJobData;
typedef CBuildJobDataIterator CLibMCDataBuildJobDataIterator;
typedef CBuildJob CLibMCDataBuildJob;
typedef CBuildJobIterator CLibMCDataBuildJobIterator;
typedef CBuildJobHandler CLibMCDataBuildJobHandler;
typedef CLoginHandler CLibMCDataLoginHandler;
typedef CPersistencyHandler CLibMCDataPersistencyHandler;
typedef CDataModel CLibMCDataDataModel;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CIterator> PIterator;
typedef std::shared_ptr<CLogSession> PLogSession;
typedef std::shared_ptr<CStorageStream> PStorageStream;
typedef std::shared_ptr<CStorage> PStorage;
typedef std::shared_ptr<CBuildJobData> PBuildJobData;
typedef std::shared_ptr<CBuildJobDataIterator> PBuildJobDataIterator;
typedef std::shared_ptr<CBuildJob> PBuildJob;
typedef std::shared_ptr<CBuildJobIterator> PBuildJobIterator;
typedef std::shared_ptr<CBuildJobHandler> PBuildJobHandler;
typedef std::shared_ptr<CLoginHandler> PLoginHandler;
typedef std::shared_ptr<CPersistencyHandler> PPersistencyHandler;
typedef std::shared_ptr<CDataModel> PDataModel;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCDataWrapper;
typedef PBase PLibMCDataBase;
typedef PIterator PLibMCDataIterator;
typedef PLogSession PLibMCDataLogSession;
typedef PStorageStream PLibMCDataStorageStream;
typedef PStorage PLibMCDataStorage;
typedef PBuildJobData PLibMCDataBuildJobData;
typedef PBuildJobDataIterator PLibMCDataBuildJobDataIterator;
typedef PBuildJob PLibMCDataBuildJob;
typedef PBuildJobIterator PLibMCDataBuildJobIterator;
typedef PBuildJobHandler PLibMCDataBuildJobHandler;
typedef PLoginHandler PLibMCDataLoginHandler;
typedef PPersistencyHandler PLibMCDataPersistencyHandler;
typedef PDataModel PLibMCDataDataModel;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCDataHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCDataException 
**************************************************************************************************************************/
class ELibMCDataException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCDataResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCDataException(LibMCDataResult errorCode, const std::string & sErrorMessage)
		: m_errorMessage("LibMCData Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
	{
		m_errorCode = errorCode;
	}

	/**
	* Returns error code
	*/
	LibMCDataResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector( const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector( const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCDataInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCDataResult nResult);

	inline void GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline LibMCData_pvoid GetSymbolLookupMethod();
	inline PDataModel CreateDataModelInstance();

private:
	sLibMCDataDynamicWrapperTable m_WrapperTable;
	
	LibMCDataResult checkBinaryVersion()
	{
		LibMCData_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != LIBMCDATA_VERSION_MAJOR) || (nMinor < LIBMCDATA_VERSION_MINOR) ) {
			return LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMCDATA_SUCCESS;
	}
	LibMCDataResult initWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable);
	LibMCDataResult releaseWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable);
	LibMCDataResult loadWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCDataResult loadWrapperTableFromSymbolLookupMethod(sLibMCDataDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CIterator;
	friend class CLogSession;
	friend class CStorageStream;
	friend class CStorage;
	friend class CBuildJobData;
	friend class CBuildJobDataIterator;
	friend class CBuildJob;
	friend class CBuildJobIterator;
	friend class CBuildJobHandler;
	friend class CLoginHandler;
	friend class CPersistencyHandler;
	friend class CDataModel;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCDataHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCDataResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCDataHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCDataHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CIterator 
**************************************************************************************************************************/
class CIterator : public CBase {
public:
	
	/**
	* CIterator::CIterator - Constructor for Iterator class.
	*/
	CIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool MoveNext();
	inline bool MovePrevious();
	inline PBase GetCurrent();
	inline PIterator Clone();
	inline LibMCData_uint64 Count();
};
	
/*************************************************************************************************************************
 Class CLogSession 
**************************************************************************************************************************/
class CLogSession : public CBase {
public:
	
	/**
	* CLogSession::CLogSession - Constructor for LogSession class.
	*/
	CLogSession(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void AddEntry(const std::string & sMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp);
};
	
/*************************************************************************************************************************
 Class CStorageStream 
**************************************************************************************************************************/
class CStorageStream : public CBase {
public:
	
	/**
	* CStorageStream::CStorageStream - Constructor for StorageStream class.
	*/
	CStorageStream(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetTimeStamp();
	inline std::string GetName();
	inline std::string GetMIMEType();
	inline std::string GetSHA2();
	inline LibMCData_uint64 GetSize();
	inline void GetContent(std::vector<LibMCData_uint8> & ContentBuffer);
	inline void GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle);
};
	
/*************************************************************************************************************************
 Class CStorage 
**************************************************************************************************************************/
class CStorage : public CBase {
public:
	
	/**
	* CStorage::CStorage - Constructor for Storage class.
	*/
	CStorage(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool StreamIsReady(const std::string & sUUID);
	inline PStorageStream RetrieveStream(const std::string & sUUID);
	inline void StoreNewStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sName, const std::string & sMimeType, const CInputVector<LibMCData_uint8> & ContentBuffer, const std::string & sUserID);
	inline void BeginPartialStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID);
	inline void StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer);
	inline void FinishPartialStream(const std::string & sUUID, const std::string & sSHA2);
	inline void FinishPartialStreamBlockwiseSHA256(const std::string & sUUID, const std::string & sBlockwiseSHA2);
	inline LibMCData_uint64 GetMaxStreamSize();
	inline bool ContentTypeIsAccepted(const std::string & sContentType);
	inline bool StreamIsImage(const std::string & sUUID);
};
	
/*************************************************************************************************************************
 Class CBuildJobData 
**************************************************************************************************************************/
class CBuildJobData : public CBase {
public:
	
	/**
	* CBuildJobData::CBuildJobData - Constructor for BuildJobData class.
	*/
	CBuildJobData(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetDataUUID();
	inline std::string GetJobUUID();
	inline std::string GetName();
	inline std::string GetTimeStamp();
	inline PStorageStream GetStorageStream();
	inline std::string GetStorageStreamSHA2();
	inline LibMCData_uint64 GetStorageStreamSize();
	inline eBuildJobDataType GetDataType();
	inline std::string GetDataTypeAsString();
	inline std::string GetMIMEType();
};
	
/*************************************************************************************************************************
 Class CBuildJobDataIterator 
**************************************************************************************************************************/
class CBuildJobDataIterator : public CIterator {
public:
	
	/**
	* CBuildJobDataIterator::CBuildJobDataIterator - Constructor for BuildJobDataIterator class.
	*/
	CBuildJobDataIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJobData GetCurrentJobData();
};
	
/*************************************************************************************************************************
 Class CBuildJob 
**************************************************************************************************************************/
class CBuildJob : public CBase {
public:
	
	/**
	* CBuildJob::CBuildJob - Constructor for BuildJob class.
	*/
	CBuildJob(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline std::string GetUUID();
	inline std::string GetName();
	inline eBuildJobStatus GetStatus();
	inline LibMCData_uint32 GetLayerCount();
	inline std::string GetTimeStamp();
	inline PStorageStream GetStorageStream();
	inline std::string GetStorageStreamUUID();
	inline PLogSession GetBuildJobLogger();
	inline void StartValidating();
	inline void FinishValidating(const LibMCData_uint32 nLayerCount);
	inline void ArchiveJob();
	inline void UnArchiveJob();
	inline void DeleteJob();
	inline bool JobCanBeArchived();
	inline void AddJobData(const std::string & sName, classParam<CStorageStream> pStream, const eBuildJobDataType eDataType, const std::string & sUserID);
	inline PBuildJobDataIterator ListJobDataByType(const eBuildJobDataType eDataType);
	inline PBuildJobDataIterator ListJobData();
	inline PBuildJobData RetrieveJobData(const std::string & sDataUUID);
};
	
/*************************************************************************************************************************
 Class CBuildJobIterator 
**************************************************************************************************************************/
class CBuildJobIterator : public CIterator {
public:
	
	/**
	* CBuildJobIterator::CBuildJobIterator - Constructor for BuildJobIterator class.
	*/
	CBuildJobIterator(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CIterator(pWrapper, pHandle)
	{
	}
	
	inline PBuildJob GetCurrentJob();
};
	
/*************************************************************************************************************************
 Class CBuildJobHandler 
**************************************************************************************************************************/
class CBuildJobHandler : public CBase {
public:
	
	/**
	* CBuildJobHandler::CBuildJobHandler - Constructor for BuildJobHandler class.
	*/
	CBuildJobHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PBuildJob CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID);
	inline PBuildJob RetrieveJob(const std::string & sJobUUID);
	inline PBuildJob FindJobOfData(const std::string & sDataUUID);
	inline PBuildJobIterator ListJobsByStatus(const eBuildJobStatus eStatus);
	inline std::string ConvertBuildStatusToString(const eBuildJobStatus eStatus);
	inline eBuildJobStatus ConvertStringToBuildStatus(const std::string & sString);
};
	
/*************************************************************************************************************************
 Class CLoginHandler 
**************************************************************************************************************************/
class CLoginHandler : public CBase {
public:
	
	/**
	* CLoginHandler::CLoginHandler - Constructor for LoginHandler class.
	*/
	CLoginHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool UserExists(const std::string & sUsername);
	inline void GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword);
};
	
/*************************************************************************************************************************
 Class CPersistencyHandler 
**************************************************************************************************************************/
class CPersistencyHandler : public CBase {
public:
	
	/**
	* CPersistencyHandler::CPersistencyHandler - Constructor for PersistencyHandler class.
	*/
	CPersistencyHandler(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool HasPersistentParameter(const std::string & sUUID);
	inline void GetPersistentParameterDetails(const std::string & sUUID, std::string & sName, eParameterDataType & eDataType);
	inline bool DeletePersistentParameter(const std::string & sUUID);
	inline void StorePersistentParameter(const std::string & sUUID, const std::string & sName, const eParameterDataType eDataType, const std::string & sValue);
	inline void StorePersistentStringParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue);
	inline void StorePersistentUUIDParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue);
	inline void StorePersistentDoubleParameter(const std::string & sUUID, const std::string & sName, const LibMCData_double dValue);
	inline void StorePersistentIntegerParameter(const std::string & sUUID, const std::string & sName, const LibMCData_int64 nValue);
	inline void StorePersistentBoolParameter(const std::string & sUUID, const std::string & sName, const bool bValue);
	inline std::string RetrievePersistentStringParameter(const std::string & sUUID);
	inline std::string RetrievePersistentUUIDParameter(const std::string & sUUID);
	inline LibMCData_double RetrievePersistentDoubleParameter(const std::string & sUUID);
	inline LibMCData_int64 RetrievePersistentIntegerParameter(const std::string & sUUID);
	inline bool RetrievePersistentBoolParameter(const std::string & sUUID);
};
	
/*************************************************************************************************************************
 Class CDataModel 
**************************************************************************************************************************/
class CDataModel : public CBase {
public:
	
	/**
	* CDataModel::CDataModel - Constructor for DataModel class.
	*/
	CDataModel(CWrapper* pWrapper, LibMCDataHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void InitialiseDatabase(const std::string & sDataDirectory, const eDataBaseType eDataBaseType, const std::string & sConnectionString);
	inline LibMCData_uint32 GetDataModelVersion();
	inline void GetInstallationInformation(std::string & sInstallationUUID, std::string & sInstallationSecret);
	inline PStorage CreateStorage();
	inline PBuildJobHandler CreateBuildJobHandler();
	inline PLogSession CreateNewLogSession();
	inline PLoginHandler CreateLoginHandler();
	inline PPersistencyHandler CreatePersistencyHandler();
	inline void SetBaseTempDirectory(const std::string & sTempDirectory);
	inline std::string GetBaseTempDirectory();
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMCData_uint32 & nMajor, LibMCData_uint32 & nMinor, LibMCData_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		LibMCData_uint32 bytesNeededErrorMessage = 0;
		LibMCData_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCDataHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibMCData_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibMCData_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateDataModelInstance - Creates and initializes new MC DataModel Instance.
	* @return New DataModel instance
	*/
	inline PDataModel CWrapper::CreateDataModelInstance()
	{
		LibMCDataHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateDataModelInstance(&hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CDataModel>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCDataResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCDataException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCDataResult CWrapper::initWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_Iterator_MoveNext = nullptr;
		pWrapperTable->m_Iterator_MovePrevious = nullptr;
		pWrapperTable->m_Iterator_GetCurrent = nullptr;
		pWrapperTable->m_Iterator_Clone = nullptr;
		pWrapperTable->m_Iterator_Count = nullptr;
		pWrapperTable->m_LogSession_AddEntry = nullptr;
		pWrapperTable->m_StorageStream_GetUUID = nullptr;
		pWrapperTable->m_StorageStream_GetTimeStamp = nullptr;
		pWrapperTable->m_StorageStream_GetName = nullptr;
		pWrapperTable->m_StorageStream_GetMIMEType = nullptr;
		pWrapperTable->m_StorageStream_GetSHA2 = nullptr;
		pWrapperTable->m_StorageStream_GetSize = nullptr;
		pWrapperTable->m_StorageStream_GetContent = nullptr;
		pWrapperTable->m_StorageStream_GetCallbacks = nullptr;
		pWrapperTable->m_Storage_StreamIsReady = nullptr;
		pWrapperTable->m_Storage_RetrieveStream = nullptr;
		pWrapperTable->m_Storage_StoreNewStream = nullptr;
		pWrapperTable->m_Storage_BeginPartialStream = nullptr;
		pWrapperTable->m_Storage_StorePartialStream = nullptr;
		pWrapperTable->m_Storage_FinishPartialStream = nullptr;
		pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 = nullptr;
		pWrapperTable->m_Storage_GetMaxStreamSize = nullptr;
		pWrapperTable->m_Storage_ContentTypeIsAccepted = nullptr;
		pWrapperTable->m_Storage_StreamIsImage = nullptr;
		pWrapperTable->m_BuildJobData_GetDataUUID = nullptr;
		pWrapperTable->m_BuildJobData_GetJobUUID = nullptr;
		pWrapperTable->m_BuildJobData_GetName = nullptr;
		pWrapperTable->m_BuildJobData_GetTimeStamp = nullptr;
		pWrapperTable->m_BuildJobData_GetStorageStream = nullptr;
		pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 = nullptr;
		pWrapperTable->m_BuildJobData_GetStorageStreamSize = nullptr;
		pWrapperTable->m_BuildJobData_GetDataType = nullptr;
		pWrapperTable->m_BuildJobData_GetDataTypeAsString = nullptr;
		pWrapperTable->m_BuildJobData_GetMIMEType = nullptr;
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = nullptr;
		pWrapperTable->m_BuildJob_GetUUID = nullptr;
		pWrapperTable->m_BuildJob_GetName = nullptr;
		pWrapperTable->m_BuildJob_GetStatus = nullptr;
		pWrapperTable->m_BuildJob_GetLayerCount = nullptr;
		pWrapperTable->m_BuildJob_GetTimeStamp = nullptr;
		pWrapperTable->m_BuildJob_GetStorageStream = nullptr;
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = nullptr;
		pWrapperTable->m_BuildJob_GetBuildJobLogger = nullptr;
		pWrapperTable->m_BuildJob_StartValidating = nullptr;
		pWrapperTable->m_BuildJob_FinishValidating = nullptr;
		pWrapperTable->m_BuildJob_ArchiveJob = nullptr;
		pWrapperTable->m_BuildJob_UnArchiveJob = nullptr;
		pWrapperTable->m_BuildJob_DeleteJob = nullptr;
		pWrapperTable->m_BuildJob_JobCanBeArchived = nullptr;
		pWrapperTable->m_BuildJob_AddJobData = nullptr;
		pWrapperTable->m_BuildJob_ListJobDataByType = nullptr;
		pWrapperTable->m_BuildJob_ListJobData = nullptr;
		pWrapperTable->m_BuildJob_RetrieveJobData = nullptr;
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = nullptr;
		pWrapperTable->m_BuildJobHandler_CreateJob = nullptr;
		pWrapperTable->m_BuildJobHandler_RetrieveJob = nullptr;
		pWrapperTable->m_BuildJobHandler_FindJobOfData = nullptr;
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = nullptr;
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = nullptr;
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = nullptr;
		pWrapperTable->m_LoginHandler_UserExists = nullptr;
		pWrapperTable->m_LoginHandler_GetUserDetails = nullptr;
		pWrapperTable->m_PersistencyHandler_HasPersistentParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails = nullptr;
		pWrapperTable->m_PersistencyHandler_DeletePersistentParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter = nullptr;
		pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter = nullptr;
		pWrapperTable->m_DataModel_InitialiseDatabase = nullptr;
		pWrapperTable->m_DataModel_GetDataModelVersion = nullptr;
		pWrapperTable->m_DataModel_GetInstallationInformation = nullptr;
		pWrapperTable->m_DataModel_CreateStorage = nullptr;
		pWrapperTable->m_DataModel_CreateBuildJobHandler = nullptr;
		pWrapperTable->m_DataModel_CreateNewLogSession = nullptr;
		pWrapperTable->m_DataModel_CreateLoginHandler = nullptr;
		pWrapperTable->m_DataModel_CreatePersistencyHandler = nullptr;
		pWrapperTable->m_DataModel_SetBaseTempDirectory = nullptr;
		pWrapperTable->m_DataModel_GetBaseTempDirectory = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateDataModelInstance = nullptr;
		
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::releaseWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::loadWrapperTable(sLibMCDataDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = (int)strlen(pLibraryFileName);
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMCDATA_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCDataIterator_MoveNextPtr) GetProcAddress(hLibrary, "libmcdata_iterator_movenext");
		#else // _WIN32
		pWrapperTable->m_Iterator_MoveNext = (PLibMCDataIterator_MoveNextPtr) dlsym(hLibrary, "libmcdata_iterator_movenext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MoveNext == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCDataIterator_MovePreviousPtr) GetProcAddress(hLibrary, "libmcdata_iterator_moveprevious");
		#else // _WIN32
		pWrapperTable->m_Iterator_MovePrevious = (PLibMCDataIterator_MovePreviousPtr) dlsym(hLibrary, "libmcdata_iterator_moveprevious");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_MovePrevious == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCDataIterator_GetCurrentPtr) GetProcAddress(hLibrary, "libmcdata_iterator_getcurrent");
		#else // _WIN32
		pWrapperTable->m_Iterator_GetCurrent = (PLibMCDataIterator_GetCurrentPtr) dlsym(hLibrary, "libmcdata_iterator_getcurrent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_GetCurrent == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCDataIterator_ClonePtr) GetProcAddress(hLibrary, "libmcdata_iterator_clone");
		#else // _WIN32
		pWrapperTable->m_Iterator_Clone = (PLibMCDataIterator_ClonePtr) dlsym(hLibrary, "libmcdata_iterator_clone");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Clone == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCDataIterator_CountPtr) GetProcAddress(hLibrary, "libmcdata_iterator_count");
		#else // _WIN32
		pWrapperTable->m_Iterator_Count = (PLibMCDataIterator_CountPtr) dlsym(hLibrary, "libmcdata_iterator_count");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Iterator_Count == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LogSession_AddEntry = (PLibMCDataLogSession_AddEntryPtr) GetProcAddress(hLibrary, "libmcdata_logsession_addentry");
		#else // _WIN32
		pWrapperTable->m_LogSession_AddEntry = (PLibMCDataLogSession_AddEntryPtr) dlsym(hLibrary, "libmcdata_logsession_addentry");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LogSession_AddEntry == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetUUID = (PLibMCDataStorageStream_GetUUIDPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getuuid");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetUUID = (PLibMCDataStorageStream_GetUUIDPtr) dlsym(hLibrary, "libmcdata_storagestream_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetTimeStamp = (PLibMCDataStorageStream_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetTimeStamp = (PLibMCDataStorageStream_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_storagestream_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetName = (PLibMCDataStorageStream_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getname");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetName = (PLibMCDataStorageStream_GetNamePtr) dlsym(hLibrary, "libmcdata_storagestream_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetMIMEType = (PLibMCDataStorageStream_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getmimetype");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetMIMEType = (PLibMCDataStorageStream_GetMIMETypePtr) dlsym(hLibrary, "libmcdata_storagestream_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetMIMEType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetSHA2 = (PLibMCDataStorageStream_GetSHA2Ptr) GetProcAddress(hLibrary, "libmcdata_storagestream_getsha2");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetSHA2 = (PLibMCDataStorageStream_GetSHA2Ptr) dlsym(hLibrary, "libmcdata_storagestream_getsha2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetSHA2 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetSize = (PLibMCDataStorageStream_GetSizePtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getsize");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetSize = (PLibMCDataStorageStream_GetSizePtr) dlsym(hLibrary, "libmcdata_storagestream_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetContent = (PLibMCDataStorageStream_GetContentPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcontent");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetContent = (PLibMCDataStorageStream_GetContentPtr) dlsym(hLibrary, "libmcdata_storagestream_getcontent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetContent == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_StorageStream_GetCallbacks = (PLibMCDataStorageStream_GetCallbacksPtr) GetProcAddress(hLibrary, "libmcdata_storagestream_getcallbacks");
		#else // _WIN32
		pWrapperTable->m_StorageStream_GetCallbacks = (PLibMCDataStorageStream_GetCallbacksPtr) dlsym(hLibrary, "libmcdata_storagestream_getcallbacks");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_StorageStream_GetCallbacks == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StreamIsReady = (PLibMCDataStorage_StreamIsReadyPtr) GetProcAddress(hLibrary, "libmcdata_storage_streamisready");
		#else // _WIN32
		pWrapperTable->m_Storage_StreamIsReady = (PLibMCDataStorage_StreamIsReadyPtr) dlsym(hLibrary, "libmcdata_storage_streamisready");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StreamIsReady == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_RetrieveStream = (PLibMCDataStorage_RetrieveStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_retrievestream");
		#else // _WIN32
		pWrapperTable->m_Storage_RetrieveStream = (PLibMCDataStorage_RetrieveStreamPtr) dlsym(hLibrary, "libmcdata_storage_retrievestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_RetrieveStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StoreNewStream = (PLibMCDataStorage_StoreNewStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_storenewstream");
		#else // _WIN32
		pWrapperTable->m_Storage_StoreNewStream = (PLibMCDataStorage_StoreNewStreamPtr) dlsym(hLibrary, "libmcdata_storage_storenewstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StoreNewStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_BeginPartialStream = (PLibMCDataStorage_BeginPartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_beginpartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_BeginPartialStream = (PLibMCDataStorage_BeginPartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_beginpartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_BeginPartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StorePartialStream = (PLibMCDataStorage_StorePartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_storepartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_StorePartialStream = (PLibMCDataStorage_StorePartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_storepartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StorePartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_FinishPartialStream = (PLibMCDataStorage_FinishPartialStreamPtr) GetProcAddress(hLibrary, "libmcdata_storage_finishpartialstream");
		#else // _WIN32
		pWrapperTable->m_Storage_FinishPartialStream = (PLibMCDataStorage_FinishPartialStreamPtr) dlsym(hLibrary, "libmcdata_storage_finishpartialstream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_FinishPartialStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 = (PLibMCDataStorage_FinishPartialStreamBlockwiseSHA256Ptr) GetProcAddress(hLibrary, "libmcdata_storage_finishpartialstreamblockwisesha256");
		#else // _WIN32
		pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 = (PLibMCDataStorage_FinishPartialStreamBlockwiseSHA256Ptr) dlsym(hLibrary, "libmcdata_storage_finishpartialstreamblockwisesha256");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_GetMaxStreamSize = (PLibMCDataStorage_GetMaxStreamSizePtr) GetProcAddress(hLibrary, "libmcdata_storage_getmaxstreamsize");
		#else // _WIN32
		pWrapperTable->m_Storage_GetMaxStreamSize = (PLibMCDataStorage_GetMaxStreamSizePtr) dlsym(hLibrary, "libmcdata_storage_getmaxstreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_GetMaxStreamSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_ContentTypeIsAccepted = (PLibMCDataStorage_ContentTypeIsAcceptedPtr) GetProcAddress(hLibrary, "libmcdata_storage_contenttypeisaccepted");
		#else // _WIN32
		pWrapperTable->m_Storage_ContentTypeIsAccepted = (PLibMCDataStorage_ContentTypeIsAcceptedPtr) dlsym(hLibrary, "libmcdata_storage_contenttypeisaccepted");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_ContentTypeIsAccepted == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Storage_StreamIsImage = (PLibMCDataStorage_StreamIsImagePtr) GetProcAddress(hLibrary, "libmcdata_storage_streamisimage");
		#else // _WIN32
		pWrapperTable->m_Storage_StreamIsImage = (PLibMCDataStorage_StreamIsImagePtr) dlsym(hLibrary, "libmcdata_storage_streamisimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Storage_StreamIsImage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetDataUUID = (PLibMCDataBuildJobData_GetDataUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getdatauuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetDataUUID = (PLibMCDataBuildJobData_GetDataUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getdatauuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetDataUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetJobUUID = (PLibMCDataBuildJobData_GetJobUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getjobuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetJobUUID = (PLibMCDataBuildJobData_GetJobUUIDPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getjobuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetJobUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetName = (PLibMCDataBuildJobData_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getname");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetName = (PLibMCDataBuildJobData_GetNamePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetTimeStamp = (PLibMCDataBuildJobData_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetTimeStamp = (PLibMCDataBuildJobData_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_buildjobdata_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStream = (PLibMCDataBuildJobData_GetStorageStreamPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getstoragestream");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStream = (PLibMCDataBuildJobData_GetStorageStreamPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getstoragestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetStorageStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 = (PLibMCDataBuildJobData_GetStorageStreamSHA2Ptr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getstoragestreamsha2");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 = (PLibMCDataBuildJobData_GetStorageStreamSHA2Ptr) dlsym(hLibrary, "libmcdata_buildjobdata_getstoragestreamsha2");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStreamSize = (PLibMCDataBuildJobData_GetStorageStreamSizePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getstoragestreamsize");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetStorageStreamSize = (PLibMCDataBuildJobData_GetStorageStreamSizePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getstoragestreamsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetStorageStreamSize == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetDataType = (PLibMCDataBuildJobData_GetDataTypePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getdatatype");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetDataType = (PLibMCDataBuildJobData_GetDataTypePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getdatatype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetDataType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetDataTypeAsString = (PLibMCDataBuildJobData_GetDataTypeAsStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getdatatypeasstring");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetDataTypeAsString = (PLibMCDataBuildJobData_GetDataTypeAsStringPtr) dlsym(hLibrary, "libmcdata_buildjobdata_getdatatypeasstring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetDataTypeAsString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobData_GetMIMEType = (PLibMCDataBuildJobData_GetMIMETypePtr) GetProcAddress(hLibrary, "libmcdata_buildjobdata_getmimetype");
		#else // _WIN32
		pWrapperTable->m_BuildJobData_GetMIMEType = (PLibMCDataBuildJobData_GetMIMETypePtr) dlsym(hLibrary, "libmcdata_buildjobdata_getmimetype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobData_GetMIMEType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = (PLibMCDataBuildJobDataIterator_GetCurrentJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobdataiterator_getcurrentjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData = (PLibMCDataBuildJobDataIterator_GetCurrentJobDataPtr) dlsym(hLibrary, "libmcdata_buildjobdataiterator_getcurrentjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetUUID = (PLibMCDataBuildJob_GetUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetUUID = (PLibMCDataBuildJob_GetUUIDPtr) dlsym(hLibrary, "libmcdata_buildjob_getuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetName = (PLibMCDataBuildJob_GetNamePtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getname");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetName = (PLibMCDataBuildJob_GetNamePtr) dlsym(hLibrary, "libmcdata_buildjob_getname");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetName == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStatus = (PLibMCDataBuildJob_GetStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstatus");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStatus = (PLibMCDataBuildJob_GetStatusPtr) dlsym(hLibrary, "libmcdata_buildjob_getstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetLayerCount = (PLibMCDataBuildJob_GetLayerCountPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getlayercount");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetLayerCount = (PLibMCDataBuildJob_GetLayerCountPtr) dlsym(hLibrary, "libmcdata_buildjob_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetLayerCount == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetTimeStamp = (PLibMCDataBuildJob_GetTimeStampPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_gettimestamp");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetTimeStamp = (PLibMCDataBuildJob_GetTimeStampPtr) dlsym(hLibrary, "libmcdata_buildjob_gettimestamp");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetTimeStamp == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStorageStream = (PLibMCDataBuildJob_GetStorageStreamPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstoragestream");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStorageStream = (PLibMCDataBuildJob_GetStorageStreamPtr) dlsym(hLibrary, "libmcdata_buildjob_getstoragestream");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStorageStream == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = (PLibMCDataBuildJob_GetStorageStreamUUIDPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getstoragestreamuuid");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetStorageStreamUUID = (PLibMCDataBuildJob_GetStorageStreamUUIDPtr) dlsym(hLibrary, "libmcdata_buildjob_getstoragestreamuuid");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetStorageStreamUUID == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_GetBuildJobLogger = (PLibMCDataBuildJob_GetBuildJobLoggerPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_getbuildjoblogger");
		#else // _WIN32
		pWrapperTable->m_BuildJob_GetBuildJobLogger = (PLibMCDataBuildJob_GetBuildJobLoggerPtr) dlsym(hLibrary, "libmcdata_buildjob_getbuildjoblogger");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_GetBuildJobLogger == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_StartValidating = (PLibMCDataBuildJob_StartValidatingPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_startvalidating");
		#else // _WIN32
		pWrapperTable->m_BuildJob_StartValidating = (PLibMCDataBuildJob_StartValidatingPtr) dlsym(hLibrary, "libmcdata_buildjob_startvalidating");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_StartValidating == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_FinishValidating = (PLibMCDataBuildJob_FinishValidatingPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_finishvalidating");
		#else // _WIN32
		pWrapperTable->m_BuildJob_FinishValidating = (PLibMCDataBuildJob_FinishValidatingPtr) dlsym(hLibrary, "libmcdata_buildjob_finishvalidating");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_FinishValidating == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ArchiveJob = (PLibMCDataBuildJob_ArchiveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_archivejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ArchiveJob = (PLibMCDataBuildJob_ArchiveJobPtr) dlsym(hLibrary, "libmcdata_buildjob_archivejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ArchiveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_UnArchiveJob = (PLibMCDataBuildJob_UnArchiveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_unarchivejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_UnArchiveJob = (PLibMCDataBuildJob_UnArchiveJobPtr) dlsym(hLibrary, "libmcdata_buildjob_unarchivejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_UnArchiveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_DeleteJob = (PLibMCDataBuildJob_DeleteJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_deletejob");
		#else // _WIN32
		pWrapperTable->m_BuildJob_DeleteJob = (PLibMCDataBuildJob_DeleteJobPtr) dlsym(hLibrary, "libmcdata_buildjob_deletejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_DeleteJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_JobCanBeArchived = (PLibMCDataBuildJob_JobCanBeArchivedPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_jobcanbearchived");
		#else // _WIN32
		pWrapperTable->m_BuildJob_JobCanBeArchived = (PLibMCDataBuildJob_JobCanBeArchivedPtr) dlsym(hLibrary, "libmcdata_buildjob_jobcanbearchived");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_JobCanBeArchived == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_AddJobData = (PLibMCDataBuildJob_AddJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_addjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_AddJobData = (PLibMCDataBuildJob_AddJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_addjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_AddJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ListJobDataByType = (PLibMCDataBuildJob_ListJobDataByTypePtr) GetProcAddress(hLibrary, "libmcdata_buildjob_listjobdatabytype");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ListJobDataByType = (PLibMCDataBuildJob_ListJobDataByTypePtr) dlsym(hLibrary, "libmcdata_buildjob_listjobdatabytype");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ListJobDataByType == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_ListJobData = (PLibMCDataBuildJob_ListJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_listjobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_ListJobData = (PLibMCDataBuildJob_ListJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_listjobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_ListJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJob_RetrieveJobData = (PLibMCDataBuildJob_RetrieveJobDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjob_retrievejobdata");
		#else // _WIN32
		pWrapperTable->m_BuildJob_RetrieveJobData = (PLibMCDataBuildJob_RetrieveJobDataPtr) dlsym(hLibrary, "libmcdata_buildjob_retrievejobdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJob_RetrieveJobData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = (PLibMCDataBuildJobIterator_GetCurrentJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobiterator_getcurrentjob");
		#else // _WIN32
		pWrapperTable->m_BuildJobIterator_GetCurrentJob = (PLibMCDataBuildJobIterator_GetCurrentJobPtr) dlsym(hLibrary, "libmcdata_buildjobiterator_getcurrentjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobIterator_GetCurrentJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_CreateJob = (PLibMCDataBuildJobHandler_CreateJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_createjob");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_CreateJob = (PLibMCDataBuildJobHandler_CreateJobPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_createjob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_CreateJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_RetrieveJob = (PLibMCDataBuildJobHandler_RetrieveJobPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_retrievejob");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_RetrieveJob = (PLibMCDataBuildJobHandler_RetrieveJobPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_retrievejob");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_RetrieveJob == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_FindJobOfData = (PLibMCDataBuildJobHandler_FindJobOfDataPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_findjobofdata");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_FindJobOfData = (PLibMCDataBuildJobHandler_FindJobOfDataPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_findjobofdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_FindJobOfData == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = (PLibMCDataBuildJobHandler_ListJobsByStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_listjobsbystatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ListJobsByStatus = (PLibMCDataBuildJobHandler_ListJobsByStatusPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_listjobsbystatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ListJobsByStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = (PLibMCDataBuildJobHandler_ConvertBuildStatusToStringPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_convertbuildstatustostring");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString = (PLibMCDataBuildJobHandler_ConvertBuildStatusToStringPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_convertbuildstatustostring");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = (PLibMCDataBuildJobHandler_ConvertStringToBuildStatusPtr) GetProcAddress(hLibrary, "libmcdata_buildjobhandler_convertstringtobuildstatus");
		#else // _WIN32
		pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus = (PLibMCDataBuildJobHandler_ConvertStringToBuildStatusPtr) dlsym(hLibrary, "libmcdata_buildjobhandler_convertstringtobuildstatus");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_UserExists = (PLibMCDataLoginHandler_UserExistsPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_userexists");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_UserExists = (PLibMCDataLoginHandler_UserExistsPtr) dlsym(hLibrary, "libmcdata_loginhandler_userexists");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_UserExists == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LoginHandler_GetUserDetails = (PLibMCDataLoginHandler_GetUserDetailsPtr) GetProcAddress(hLibrary, "libmcdata_loginhandler_getuserdetails");
		#else // _WIN32
		pWrapperTable->m_LoginHandler_GetUserDetails = (PLibMCDataLoginHandler_GetUserDetailsPtr) dlsym(hLibrary, "libmcdata_loginhandler_getuserdetails");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LoginHandler_GetUserDetails == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_HasPersistentParameter = (PLibMCDataPersistencyHandler_HasPersistentParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_haspersistentparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_HasPersistentParameter = (PLibMCDataPersistencyHandler_HasPersistentParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_haspersistentparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_HasPersistentParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails = (PLibMCDataPersistencyHandler_GetPersistentParameterDetailsPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_getpersistentparameterdetails");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails = (PLibMCDataPersistencyHandler_GetPersistentParameterDetailsPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_getpersistentparameterdetails");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_DeletePersistentParameter = (PLibMCDataPersistencyHandler_DeletePersistentParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_deletepersistentparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_DeletePersistentParameter = (PLibMCDataPersistencyHandler_DeletePersistentParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_deletepersistentparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_DeletePersistentParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentParameter = (PLibMCDataPersistencyHandler_StorePersistentParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentParameter = (PLibMCDataPersistencyHandler_StorePersistentParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter = (PLibMCDataPersistencyHandler_StorePersistentStringParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentstringparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter = (PLibMCDataPersistencyHandler_StorePersistentStringParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter = (PLibMCDataPersistencyHandler_StorePersistentUUIDParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentuuidparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter = (PLibMCDataPersistencyHandler_StorePersistentUUIDParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter = (PLibMCDataPersistencyHandler_StorePersistentDoubleParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter = (PLibMCDataPersistencyHandler_StorePersistentDoubleParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter = (PLibMCDataPersistencyHandler_StorePersistentIntegerParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentintegerparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter = (PLibMCDataPersistencyHandler_StorePersistentIntegerParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter = (PLibMCDataPersistencyHandler_StorePersistentBoolParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_storepersistentboolparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter = (PLibMCDataPersistencyHandler_StorePersistentBoolParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_storepersistentboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter = (PLibMCDataPersistencyHandler_RetrievePersistentStringParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentstringparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter = (PLibMCDataPersistencyHandler_RetrievePersistentStringParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentstringparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter = (PLibMCDataPersistencyHandler_RetrievePersistentUUIDParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentuuidparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter = (PLibMCDataPersistencyHandler_RetrievePersistentUUIDParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentuuidparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter = (PLibMCDataPersistencyHandler_RetrievePersistentDoubleParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentdoubleparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter = (PLibMCDataPersistencyHandler_RetrievePersistentDoubleParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentdoubleparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter = (PLibMCDataPersistencyHandler_RetrievePersistentIntegerParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentintegerparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter = (PLibMCDataPersistencyHandler_RetrievePersistentIntegerParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentintegerparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter = (PLibMCDataPersistencyHandler_RetrievePersistentBoolParameterPtr) GetProcAddress(hLibrary, "libmcdata_persistencyhandler_retrievepersistentboolparameter");
		#else // _WIN32
		pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter = (PLibMCDataPersistencyHandler_RetrievePersistentBoolParameterPtr) dlsym(hLibrary, "libmcdata_persistencyhandler_retrievepersistentboolparameter");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_InitialiseDatabase = (PLibMCDataDataModel_InitialiseDatabasePtr) GetProcAddress(hLibrary, "libmcdata_datamodel_initialisedatabase");
		#else // _WIN32
		pWrapperTable->m_DataModel_InitialiseDatabase = (PLibMCDataDataModel_InitialiseDatabasePtr) dlsym(hLibrary, "libmcdata_datamodel_initialisedatabase");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_InitialiseDatabase == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetDataModelVersion = (PLibMCDataDataModel_GetDataModelVersionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getdatamodelversion");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetDataModelVersion = (PLibMCDataDataModel_GetDataModelVersionPtr) dlsym(hLibrary, "libmcdata_datamodel_getdatamodelversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetDataModelVersion == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformation = (PLibMCDataDataModel_GetInstallationInformationPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getinstallationinformation");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetInstallationInformation = (PLibMCDataDataModel_GetInstallationInformationPtr) dlsym(hLibrary, "libmcdata_datamodel_getinstallationinformation");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetInstallationInformation == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateStorage = (PLibMCDataDataModel_CreateStoragePtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createstorage");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateStorage = (PLibMCDataDataModel_CreateStoragePtr) dlsym(hLibrary, "libmcdata_datamodel_createstorage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateStorage == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateBuildJobHandler = (PLibMCDataDataModel_CreateBuildJobHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createbuildjobhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateBuildJobHandler = (PLibMCDataDataModel_CreateBuildJobHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createbuildjobhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateBuildJobHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateNewLogSession = (PLibMCDataDataModel_CreateNewLogSessionPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createnewlogsession");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateNewLogSession = (PLibMCDataDataModel_CreateNewLogSessionPtr) dlsym(hLibrary, "libmcdata_datamodel_createnewlogsession");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateNewLogSession == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreateLoginHandler = (PLibMCDataDataModel_CreateLoginHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createloginhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreateLoginHandler = (PLibMCDataDataModel_CreateLoginHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createloginhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreateLoginHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_CreatePersistencyHandler = (PLibMCDataDataModel_CreatePersistencyHandlerPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_createpersistencyhandler");
		#else // _WIN32
		pWrapperTable->m_DataModel_CreatePersistencyHandler = (PLibMCDataDataModel_CreatePersistencyHandlerPtr) dlsym(hLibrary, "libmcdata_datamodel_createpersistencyhandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_CreatePersistencyHandler == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_SetBaseTempDirectory = (PLibMCDataDataModel_SetBaseTempDirectoryPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_setbasetempdirectory");
		#else // _WIN32
		pWrapperTable->m_DataModel_SetBaseTempDirectory = (PLibMCDataDataModel_SetBaseTempDirectoryPtr) dlsym(hLibrary, "libmcdata_datamodel_setbasetempdirectory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_SetBaseTempDirectory == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_DataModel_GetBaseTempDirectory = (PLibMCDataDataModel_GetBaseTempDirectoryPtr) GetProcAddress(hLibrary, "libmcdata_datamodel_getbasetempdirectory");
		#else // _WIN32
		pWrapperTable->m_DataModel_GetBaseTempDirectory = (PLibMCDataDataModel_GetBaseTempDirectoryPtr) dlsym(hLibrary, "libmcdata_datamodel_getbasetempdirectory");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_DataModel_GetBaseTempDirectory == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDataGetVersionPtr) GetProcAddress(hLibrary, "libmcdata_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCDataGetVersionPtr) dlsym(hLibrary, "libmcdata_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDataGetLastErrorPtr) GetProcAddress(hLibrary, "libmcdata_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCDataGetLastErrorPtr) dlsym(hLibrary, "libmcdata_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDataReleaseInstancePtr) GetProcAddress(hLibrary, "libmcdata_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCDataReleaseInstancePtr) dlsym(hLibrary, "libmcdata_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDataAcquireInstancePtr) GetProcAddress(hLibrary, "libmcdata_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCDataAcquireInstancePtr) dlsym(hLibrary, "libmcdata_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDataGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "libmcdata_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibMCDataGetSymbolLookupMethodPtr) dlsym(hLibrary, "libmcdata_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateDataModelInstance = (PLibMCDataCreateDataModelInstancePtr) GetProcAddress(hLibrary, "libmcdata_createdatamodelinstance");
		#else // _WIN32
		pWrapperTable->m_CreateDataModelInstance = (PLibMCDataCreateDataModelInstancePtr) dlsym(hLibrary, "libmcdata_createdatamodelinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateDataModelInstance == nullptr)
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMCDATA_SUCCESS;
	}

	inline LibMCDataResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDataDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMCDATA_ERROR_INVALIDPARAM;
		
		typedef LibMCDataResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCDataResult eLookupError = LIBMCDATA_SUCCESS;
		eLookupError = (*pLookup)("libmcdata_iterator_movenext", (void**)&(pWrapperTable->m_Iterator_MoveNext));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MoveNext == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_moveprevious", (void**)&(pWrapperTable->m_Iterator_MovePrevious));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_MovePrevious == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_getcurrent", (void**)&(pWrapperTable->m_Iterator_GetCurrent));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_GetCurrent == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_clone", (void**)&(pWrapperTable->m_Iterator_Clone));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Clone == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_iterator_count", (void**)&(pWrapperTable->m_Iterator_Count));
		if ( (eLookupError != 0) || (pWrapperTable->m_Iterator_Count == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_logsession_addentry", (void**)&(pWrapperTable->m_LogSession_AddEntry));
		if ( (eLookupError != 0) || (pWrapperTable->m_LogSession_AddEntry == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getuuid", (void**)&(pWrapperTable->m_StorageStream_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_gettimestamp", (void**)&(pWrapperTable->m_StorageStream_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getname", (void**)&(pWrapperTable->m_StorageStream_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getmimetype", (void**)&(pWrapperTable->m_StorageStream_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetMIMEType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getsha2", (void**)&(pWrapperTable->m_StorageStream_GetSHA2));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetSHA2 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getsize", (void**)&(pWrapperTable->m_StorageStream_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcontent", (void**)&(pWrapperTable->m_StorageStream_GetContent));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetContent == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storagestream_getcallbacks", (void**)&(pWrapperTable->m_StorageStream_GetCallbacks));
		if ( (eLookupError != 0) || (pWrapperTable->m_StorageStream_GetCallbacks == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_streamisready", (void**)&(pWrapperTable->m_Storage_StreamIsReady));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StreamIsReady == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_retrievestream", (void**)&(pWrapperTable->m_Storage_RetrieveStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_RetrieveStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_storenewstream", (void**)&(pWrapperTable->m_Storage_StoreNewStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StoreNewStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_beginpartialstream", (void**)&(pWrapperTable->m_Storage_BeginPartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_BeginPartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_storepartialstream", (void**)&(pWrapperTable->m_Storage_StorePartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StorePartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_finishpartialstream", (void**)&(pWrapperTable->m_Storage_FinishPartialStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_FinishPartialStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_finishpartialstreamblockwisesha256", (void**)&(pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_FinishPartialStreamBlockwiseSHA256 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_getmaxstreamsize", (void**)&(pWrapperTable->m_Storage_GetMaxStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_GetMaxStreamSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_contenttypeisaccepted", (void**)&(pWrapperTable->m_Storage_ContentTypeIsAccepted));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_ContentTypeIsAccepted == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_storage_streamisimage", (void**)&(pWrapperTable->m_Storage_StreamIsImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Storage_StreamIsImage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getdatauuid", (void**)&(pWrapperTable->m_BuildJobData_GetDataUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetDataUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getjobuuid", (void**)&(pWrapperTable->m_BuildJobData_GetJobUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetJobUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getname", (void**)&(pWrapperTable->m_BuildJobData_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_gettimestamp", (void**)&(pWrapperTable->m_BuildJobData_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getstoragestream", (void**)&(pWrapperTable->m_BuildJobData_GetStorageStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetStorageStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getstoragestreamsha2", (void**)&(pWrapperTable->m_BuildJobData_GetStorageStreamSHA2));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetStorageStreamSHA2 == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getstoragestreamsize", (void**)&(pWrapperTable->m_BuildJobData_GetStorageStreamSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetStorageStreamSize == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getdatatype", (void**)&(pWrapperTable->m_BuildJobData_GetDataType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetDataType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getdatatypeasstring", (void**)&(pWrapperTable->m_BuildJobData_GetDataTypeAsString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetDataTypeAsString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdata_getmimetype", (void**)&(pWrapperTable->m_BuildJobData_GetMIMEType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobData_GetMIMEType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobdataiterator_getcurrentjobdata", (void**)&(pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobDataIterator_GetCurrentJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getuuid", (void**)&(pWrapperTable->m_BuildJob_GetUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getname", (void**)&(pWrapperTable->m_BuildJob_GetName));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetName == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstatus", (void**)&(pWrapperTable->m_BuildJob_GetStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getlayercount", (void**)&(pWrapperTable->m_BuildJob_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetLayerCount == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_gettimestamp", (void**)&(pWrapperTable->m_BuildJob_GetTimeStamp));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetTimeStamp == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstoragestream", (void**)&(pWrapperTable->m_BuildJob_GetStorageStream));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStorageStream == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getstoragestreamuuid", (void**)&(pWrapperTable->m_BuildJob_GetStorageStreamUUID));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetStorageStreamUUID == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_getbuildjoblogger", (void**)&(pWrapperTable->m_BuildJob_GetBuildJobLogger));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_GetBuildJobLogger == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_startvalidating", (void**)&(pWrapperTable->m_BuildJob_StartValidating));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_StartValidating == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_finishvalidating", (void**)&(pWrapperTable->m_BuildJob_FinishValidating));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_FinishValidating == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_archivejob", (void**)&(pWrapperTable->m_BuildJob_ArchiveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ArchiveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_unarchivejob", (void**)&(pWrapperTable->m_BuildJob_UnArchiveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_UnArchiveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_deletejob", (void**)&(pWrapperTable->m_BuildJob_DeleteJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_DeleteJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_jobcanbearchived", (void**)&(pWrapperTable->m_BuildJob_JobCanBeArchived));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_JobCanBeArchived == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_addjobdata", (void**)&(pWrapperTable->m_BuildJob_AddJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_AddJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_listjobdatabytype", (void**)&(pWrapperTable->m_BuildJob_ListJobDataByType));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ListJobDataByType == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_listjobdata", (void**)&(pWrapperTable->m_BuildJob_ListJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_ListJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjob_retrievejobdata", (void**)&(pWrapperTable->m_BuildJob_RetrieveJobData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJob_RetrieveJobData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobiterator_getcurrentjob", (void**)&(pWrapperTable->m_BuildJobIterator_GetCurrentJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobIterator_GetCurrentJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_createjob", (void**)&(pWrapperTable->m_BuildJobHandler_CreateJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_CreateJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_retrievejob", (void**)&(pWrapperTable->m_BuildJobHandler_RetrieveJob));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_RetrieveJob == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_findjobofdata", (void**)&(pWrapperTable->m_BuildJobHandler_FindJobOfData));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_FindJobOfData == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_listjobsbystatus", (void**)&(pWrapperTable->m_BuildJobHandler_ListJobsByStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ListJobsByStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_convertbuildstatustostring", (void**)&(pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ConvertBuildStatusToString == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_buildjobhandler_convertstringtobuildstatus", (void**)&(pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus));
		if ( (eLookupError != 0) || (pWrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_userexists", (void**)&(pWrapperTable->m_LoginHandler_UserExists));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_UserExists == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_loginhandler_getuserdetails", (void**)&(pWrapperTable->m_LoginHandler_GetUserDetails));
		if ( (eLookupError != 0) || (pWrapperTable->m_LoginHandler_GetUserDetails == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_haspersistentparameter", (void**)&(pWrapperTable->m_PersistencyHandler_HasPersistentParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_HasPersistentParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_getpersistentparameterdetails", (void**)&(pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_GetPersistentParameterDetails == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_deletepersistentparameter", (void**)&(pWrapperTable->m_PersistencyHandler_DeletePersistentParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_DeletePersistentParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentstringparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentStringParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentuuidparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentUUIDParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentdoubleparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentDoubleParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentintegerparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentIntegerParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_storepersistentboolparameter", (void**)&(pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_StorePersistentBoolParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentstringparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentStringParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentuuidparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentUUIDParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentdoubleparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentDoubleParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentintegerparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentIntegerParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_persistencyhandler_retrievepersistentboolparameter", (void**)&(pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter));
		if ( (eLookupError != 0) || (pWrapperTable->m_PersistencyHandler_RetrievePersistentBoolParameter == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_initialisedatabase", (void**)&(pWrapperTable->m_DataModel_InitialiseDatabase));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_InitialiseDatabase == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getdatamodelversion", (void**)&(pWrapperTable->m_DataModel_GetDataModelVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetDataModelVersion == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getinstallationinformation", (void**)&(pWrapperTable->m_DataModel_GetInstallationInformation));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetInstallationInformation == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createstorage", (void**)&(pWrapperTable->m_DataModel_CreateStorage));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateStorage == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createbuildjobhandler", (void**)&(pWrapperTable->m_DataModel_CreateBuildJobHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateBuildJobHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createnewlogsession", (void**)&(pWrapperTable->m_DataModel_CreateNewLogSession));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateNewLogSession == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createloginhandler", (void**)&(pWrapperTable->m_DataModel_CreateLoginHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreateLoginHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_createpersistencyhandler", (void**)&(pWrapperTable->m_DataModel_CreatePersistencyHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_CreatePersistencyHandler == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_setbasetempdirectory", (void**)&(pWrapperTable->m_DataModel_SetBaseTempDirectory));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_SetBaseTempDirectory == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_datamodel_getbasetempdirectory", (void**)&(pWrapperTable->m_DataModel_GetBaseTempDirectory));
		if ( (eLookupError != 0) || (pWrapperTable->m_DataModel_GetBaseTempDirectory == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmcdata_createdatamodelinstance", (void**)&(pWrapperTable->m_CreateDataModelInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateDataModelInstance == nullptr) )
			return LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMCDATA_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CIterator
	 */
	
	/**
	* CIterator::MoveNext - Iterates to the next resource in the list.
	* @return Iterates to the next resource in the list.
	*/
	bool CIterator::MoveNext()
	{
		bool resultHasNext = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MoveNext(m_pHandle, &resultHasNext));
		
		return resultHasNext;
	}
	
	/**
	* CIterator::MovePrevious - Iterates to the previous resource in the list.
	* @return Iterates to the previous resource in the list.
	*/
	bool CIterator::MovePrevious()
	{
		bool resultHasPrevious = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_MovePrevious(m_pHandle, &resultHasPrevious));
		
		return resultHasPrevious;
	}
	
	/**
	* CIterator::GetCurrent - Returns the resource the iterator points at.
	* @return returns the resource instance.
	*/
	PBase CIterator::GetCurrent()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_GetCurrent(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBase>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	* CIterator::Clone - Creates a new resource iterator with the same resource list.
	* @return returns the cloned Iterator instance
	*/
	PIterator CIterator::Clone()
	{
		LibMCDataHandle hOutIterator = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Clone(m_pHandle, &hOutIterator));
		
		if (!hOutIterator) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CIterator>(m_pWrapper, hOutIterator);
	}
	
	/**
	* CIterator::Count - Returns the number of resoucres the iterator captures.
	* @return returns the number of resources the iterator captures.
	*/
	LibMCData_uint64 CIterator::Count()
	{
		LibMCData_uint64 resultCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Iterator_Count(m_pHandle, &resultCount));
		
		return resultCount;
	}
	
	/**
	 * Method definitions for class CLogSession
	 */
	
	/**
	* CLogSession::AddEntry - adds a new log entry.
	* @param[in] sMessage - Log Message
	* @param[in] sSubSystem - Sub System identifier
	* @param[in] eLogLevel - Log Level
	* @param[in] sTimestamp - Timestamp in ISO8601 UTC format
	*/
	void CLogSession::AddEntry(const std::string & sMessage, const std::string & sSubSystem, const eLogLevel eLogLevel, const std::string & sTimestamp)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_LogSession_AddEntry(m_pHandle, sMessage.c_str(), sSubSystem.c_str(), eLogLevel, sTimestamp.c_str()));
	}
	
	/**
	 * Method definitions for class CStorageStream
	 */
	
	/**
	* CStorageStream::GetUUID - returns the uuid of a storage stream.
	* @return UUID String
	*/
	std::string CStorageStream::GetUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CStorageStream::GetTimeStamp - returns the timestamp of a storage stream.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CStorageStream::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CStorageStream::GetName - returns the name of a storage stream.
	* @return Name String
	*/
	std::string CStorageStream::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CStorageStream::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	std::string CStorageStream::GetMIMEType()
	{
		LibMCData_uint32 bytesNeededMimeType = 0;
		LibMCData_uint32 bytesWrittenMimeType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetMIMEType(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetMIMEType(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	* CStorageStream::GetSHA2 - returns the sha256 checksum of a storage stream.
	* @return SHA1 String
	*/
	std::string CStorageStream::GetSHA2()
	{
		LibMCData_uint32 bytesNeededSHA2 = 0;
		LibMCData_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSHA2(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSHA2(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CStorageStream::GetSize - returns the size of a storage stream.
	* @return Size
	*/
	LibMCData_uint64 CStorageStream::GetSize()
	{
		LibMCData_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CStorageStream::GetContent - returns the content of a storage stream.
	* @param[out] ContentBuffer - Byte Content of the stream
	*/
	void CStorageStream::GetContent(std::vector<LibMCData_uint8> & ContentBuffer)
	{
		LibMCData_uint64 elementsNeededContent = 0;
		LibMCData_uint64 elementsWrittenContent = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContent(m_pHandle, 0, &elementsNeededContent, nullptr));
		ContentBuffer.resize((size_t) elementsNeededContent);
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetContent(m_pHandle, elementsNeededContent, &elementsWrittenContent, ContentBuffer.data()));
	}
	
	/**
	* CStorageStream::GetCallbacks - returns direct read access to the storage stream. The callbacks are only valid throughout the existence of the StorageStream instance.
	* @param[out] pTheReadCallback - Callback to call for reading a data chunk
	* @param[out] pTheSeekCallback - Callback to call for seeking in the stream.
	* @param[out] pStreamHandle - Handle of the stream.
	*/
	void CStorageStream::GetCallbacks(LibMCData_pvoid & pTheReadCallback, LibMCData_pvoid & pTheSeekCallback, LibMCData_pvoid & pStreamHandle)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_StorageStream_GetCallbacks(m_pHandle, &pTheReadCallback, &pTheSeekCallback, &pStreamHandle));
	}
	
	/**
	 * Method definitions for class CStorage
	 */
	
	/**
	* CStorage::StreamIsReady - checks if a stream exists and is written to disk.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream is ready.
	*/
	bool CStorage::StreamIsReady(const std::string & sUUID)
	{
		bool resultIsReady = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StreamIsReady(m_pHandle, sUUID.c_str(), &resultIsReady));
		
		return resultIsReady;
	}
	
	/**
	* CStorage::RetrieveStream - retrieves an existing stream.
	* @param[in] sUUID - UUID of storage stream.
	* @return Stream Instance.
	*/
	PStorageStream CStorage::RetrieveStream(const std::string & sUUID)
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_RetrieveStream(m_pHandle, sUUID.c_str(), &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CStorage::StoreNewStream - stores a new stream.
	* @param[in] sUUID - UUID of storage stream. Must be unique and newly generated.
	* @param[in] sContextUUID - Context UUID of storage stream. Important for ownership and deletion.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] ContentBuffer - Data of stream
	* @param[in] sUserID - Currently authenticated user
	*/
	void CStorage::StoreNewStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sName, const std::string & sMimeType, const CInputVector<LibMCData_uint8> & ContentBuffer, const std::string & sUserID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StoreNewStream(m_pHandle, sUUID.c_str(), sContextUUID.c_str(), sName.c_str(), sMimeType.c_str(), (LibMCData_uint64)ContentBuffer.size(), ContentBuffer.data(), sUserID.c_str()));
	}
	
	/**
	* CStorage::BeginPartialStream - starts storing a stream with partial uploads.
	* @param[in] sUUID - UUID of storage stream. MUST be unique and newly generated.
	* @param[in] sContextUUID - Context UUID of storage stream. Important for ownership and deletion.
	* @param[in] sName - Name of the stream.
	* @param[in] sMimeType - Mime type of the content. MUST NOT be empty.
	* @param[in] nSize - Final size of the stream. MUST NOT be 0.
	* @param[in] sUserID - Currently authenticated user
	*/
	void CStorage::BeginPartialStream(const std::string & sUUID, const std::string & sContextUUID, const std::string & sName, const std::string & sMimeType, const LibMCData_uint64 nSize, const std::string & sUserID)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_BeginPartialStream(m_pHandle, sUUID.c_str(), sContextUUID.c_str(), sName.c_str(), sMimeType.c_str(), nSize, sUserID.c_str()));
	}
	
	/**
	* CStorage::StorePartialStream - stores data in a stream with partial uploads. Uploads should be sequential for optimal performance, but may be in arbitrary order.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] nOffset - Offset in stream to store to. Can be an arbitrary position, but storage MUST NOT override already uploaded data.
	* @param[in] ContentBuffer - Data block to store in stream.
	*/
	void CStorage::StorePartialStream(const std::string & sUUID, const LibMCData_uint64 nOffset, const CInputVector<LibMCData_uint8> & ContentBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StorePartialStream(m_pHandle, sUUID.c_str(), nOffset, (LibMCData_uint64)ContentBuffer.size(), ContentBuffer.data()));
	}
	
	/**
	* CStorage::FinishPartialStream - Finishes storing a stream.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sSHA2 - SHA256 of the uploaded data. If given initially, MUST be identical.
	*/
	void CStorage::FinishPartialStream(const std::string & sUUID, const std::string & sSHA2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_FinishPartialStream(m_pHandle, sUUID.c_str(), sSHA2.c_str()));
	}
	
	/**
	* CStorage::FinishPartialStreamBlockwiseSHA256 - Finishes storing a stream with a 64k-Blockwise calculated Checksum.
	* @param[in] sUUID - UUID of storage stream. MUST have been created with BeginPartialStream first.
	* @param[in] sBlockwiseSHA2 - 64kB hashlist SHA256 checksum of the uploaded data. If given initially, MUST be identical.
	*/
	void CStorage::FinishPartialStreamBlockwiseSHA256(const std::string & sUUID, const std::string & sBlockwiseSHA2)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_FinishPartialStreamBlockwiseSHA256(m_pHandle, sUUID.c_str(), sBlockwiseSHA2.c_str()));
	}
	
	/**
	* CStorage::GetMaxStreamSize - Returns the maximum stream size that the data model allows.
	* @return Maximum Stream Size in Bytes.
	*/
	LibMCData_uint64 CStorage::GetMaxStreamSize()
	{
		LibMCData_uint64 resultMaxStreamSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_GetMaxStreamSize(m_pHandle, &resultMaxStreamSize));
		
		return resultMaxStreamSize;
	}
	
	/**
	* CStorage::ContentTypeIsAccepted - Returns if the given content type is an acceptable value.
	* @param[in] sContentType - Content type string (is taken case-insensitive)
	* @return Content type is accepted.
	*/
	bool CStorage::ContentTypeIsAccepted(const std::string & sContentType)
	{
		bool resultAccepted = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_ContentTypeIsAccepted(m_pHandle, sContentType.c_str(), &resultAccepted));
		
		return resultAccepted;
	}
	
	/**
	* CStorage::StreamIsImage - checks if a stream is an image.
	* @param[in] sUUID - UUID of storage stream.
	* @return Returns if the stream is an image.
	*/
	bool CStorage::StreamIsImage(const std::string & sUUID)
	{
		bool resultIsImage = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_Storage_StreamIsImage(m_pHandle, sUUID.c_str(), &resultIsImage));
		
		return resultIsImage;
	}
	
	/**
	 * Method definitions for class CBuildJobData
	 */
	
	/**
	* CBuildJobData::GetDataUUID - returns the uuid of a build job data.
	* @return UUID String
	*/
	std::string CBuildJobData::GetDataUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJobData::GetJobUUID - returns the uuid of the parent build job.
	* @return UUID String
	*/
	std::string CBuildJobData::GetJobUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetJobUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetJobUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJobData::GetName - returns the name of a build job uuid.
	* @return Name String
	*/
	std::string CBuildJobData::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBuildJobData::GetTimeStamp - returns the timestamp when the job was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CBuildJobData::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CBuildJobData::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	PStorageStream CBuildJobData::GetStorageStream()
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetStorageStream(m_pHandle, &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CBuildJobData::GetStorageStreamSHA2 - returns the checksum of the storage stream of the build.
	* @return SHA256 of the storage stream.
	*/
	std::string CBuildJobData::GetStorageStreamSHA2()
	{
		LibMCData_uint32 bytesNeededSHA2 = 0;
		LibMCData_uint32 bytesWrittenSHA2 = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetStorageStreamSHA2(m_pHandle, 0, &bytesNeededSHA2, nullptr));
		std::vector<char> bufferSHA2(bytesNeededSHA2);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetStorageStreamSHA2(m_pHandle, bytesNeededSHA2, &bytesWrittenSHA2, &bufferSHA2[0]));
		
		return std::string(&bufferSHA2[0]);
	}
	
	/**
	* CBuildJobData::GetStorageStreamSize - returns the size of the storage stream of the build.
	* @return size of the storage stream in bytes.
	*/
	LibMCData_uint64 CBuildJobData::GetStorageStreamSize()
	{
		LibMCData_uint64 resultSize = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetStorageStreamSize(m_pHandle, &resultSize));
		
		return resultSize;
	}
	
	/**
	* CBuildJobData::GetDataType - returns the data type of the job data.
	* @return Data type of the job data
	*/
	eBuildJobDataType CBuildJobData::GetDataType()
	{
		eBuildJobDataType resultDataType = (eBuildJobDataType) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataType(m_pHandle, &resultDataType));
		
		return resultDataType;
	}
	
	/**
	* CBuildJobData::GetDataTypeAsString - returns the data type of the job data as string.
	* @return Data type of the job data
	*/
	std::string CBuildJobData::GetDataTypeAsString()
	{
		LibMCData_uint32 bytesNeededDataType = 0;
		LibMCData_uint32 bytesWrittenDataType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataTypeAsString(m_pHandle, 0, &bytesNeededDataType, nullptr));
		std::vector<char> bufferDataType(bytesNeededDataType);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetDataTypeAsString(m_pHandle, bytesNeededDataType, &bytesWrittenDataType, &bufferDataType[0]));
		
		return std::string(&bufferDataType[0]);
	}
	
	/**
	* CBuildJobData::GetMIMEType - returns the mime type of a storage stream.
	* @return Mime Type String
	*/
	std::string CBuildJobData::GetMIMEType()
	{
		LibMCData_uint32 bytesNeededMimeType = 0;
		LibMCData_uint32 bytesWrittenMimeType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetMIMEType(m_pHandle, 0, &bytesNeededMimeType, nullptr));
		std::vector<char> bufferMimeType(bytesNeededMimeType);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobData_GetMIMEType(m_pHandle, bytesNeededMimeType, &bytesWrittenMimeType, &bufferMimeType[0]));
		
		return std::string(&bufferMimeType[0]);
	}
	
	/**
	 * Method definitions for class CBuildJobDataIterator
	 */
	
	/**
	* CBuildJobDataIterator::GetCurrentJobData - Returns the build job data the iterator points at.
	* @return returns the build job instance.
	*/
	PBuildJobData CBuildJobDataIterator::GetCurrentJobData()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobDataIterator_GetCurrentJobData(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobData>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJob
	 */
	
	/**
	* CBuildJob::GetUUID - returns the uuid of a build job.
	* @return UUID String
	*/
	std::string CBuildJob::GetUUID()
	{
		LibMCData_uint32 bytesNeededUUID = 0;
		LibMCData_uint32 bytesWrittenUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetUUID(m_pHandle, 0, &bytesNeededUUID, nullptr));
		std::vector<char> bufferUUID(bytesNeededUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetUUID(m_pHandle, bytesNeededUUID, &bytesWrittenUUID, &bufferUUID[0]));
		
		return std::string(&bufferUUID[0]);
	}
	
	/**
	* CBuildJob::GetName - returns the name of a build job.
	* @return Name String
	*/
	std::string CBuildJob::GetName()
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetName(m_pHandle, 0, &bytesNeededName, nullptr));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetName(m_pHandle, bytesNeededName, &bytesWrittenName, &bufferName[0]));
		
		return std::string(&bufferName[0]);
	}
	
	/**
	* CBuildJob::GetStatus - returns the status of a build job.
	* @return Status of build job.
	*/
	eBuildJobStatus CBuildJob::GetStatus()
	{
		eBuildJobStatus resultStatus = (eBuildJobStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStatus(m_pHandle, &resultStatus));
		
		return resultStatus;
	}
	
	/**
	* CBuildJob::GetLayerCount - returns the layer count of a build job.
	* @return Layer Count of build job
	*/
	LibMCData_uint32 CBuildJob::GetLayerCount()
	{
		LibMCData_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CBuildJob::GetTimeStamp - returns the timestamp when the job was created.
	* @return Timestamp in ISO8601 UTC format
	*/
	std::string CBuildJob::GetTimeStamp()
	{
		LibMCData_uint32 bytesNeededTimestamp = 0;
		LibMCData_uint32 bytesWrittenTimestamp = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetTimeStamp(m_pHandle, 0, &bytesNeededTimestamp, nullptr));
		std::vector<char> bufferTimestamp(bytesNeededTimestamp);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetTimeStamp(m_pHandle, bytesNeededTimestamp, &bytesWrittenTimestamp, &bufferTimestamp[0]));
		
		return std::string(&bufferTimestamp[0]);
	}
	
	/**
	* CBuildJob::GetStorageStream - returns the storage stream of the build.
	* @return Stream Instance.
	*/
	PStorageStream CBuildJob::GetStorageStream()
	{
		LibMCDataHandle hStreamInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStream(m_pHandle, &hStreamInstance));
		
		if (!hStreamInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorageStream>(m_pWrapper, hStreamInstance);
	}
	
	/**
	* CBuildJob::GetStorageStreamUUID - returns the storage stream uuid of the build.
	* @return Stream UUID.
	*/
	std::string CBuildJob::GetStorageStreamUUID()
	{
		LibMCData_uint32 bytesNeededStreamUUID = 0;
		LibMCData_uint32 bytesWrittenStreamUUID = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStreamUUID(m_pHandle, 0, &bytesNeededStreamUUID, nullptr));
		std::vector<char> bufferStreamUUID(bytesNeededStreamUUID);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetStorageStreamUUID(m_pHandle, bytesNeededStreamUUID, &bytesWrittenStreamUUID, &bufferStreamUUID[0]));
		
		return std::string(&bufferStreamUUID[0]);
	}
	
	/**
	* CBuildJob::GetBuildJobLogger - creates a build job log session access class.
	* @return LogSession class instance.
	*/
	PLogSession CBuildJob::GetBuildJobLogger()
	{
		LibMCDataHandle hLogSession = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_GetBuildJobLogger(m_pHandle, &hLogSession));
		
		if (!hLogSession) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogSession>(m_pWrapper, hLogSession);
	}
	
	/**
	* CBuildJob::StartValidating - Starts validation of a build job.
	*/
	void CBuildJob::StartValidating()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_StartValidating(m_pHandle));
	}
	
	/**
	* CBuildJob::FinishValidating - Finishes validation of a build job.
	* @param[in] nLayerCount - Layer count
	*/
	void CBuildJob::FinishValidating(const LibMCData_uint32 nLayerCount)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_FinishValidating(m_pHandle, nLayerCount));
	}
	
	/**
	* CBuildJob::ArchiveJob - Archives a Job. Job MUST not be opened in the system. Job MUST be of state validated.
	*/
	void CBuildJob::ArchiveJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ArchiveJob(m_pHandle));
	}
	
	/**
	* CBuildJob::UnArchiveJob - Unarchives a Job. Job MUST be of state archived.
	*/
	void CBuildJob::UnArchiveJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_UnArchiveJob(m_pHandle));
	}
	
	/**
	* CBuildJob::DeleteJob - Deletes a Job permanently including all referencing data objects. Job MUST be of state archived to succeed.
	*/
	void CBuildJob::DeleteJob()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_DeleteJob(m_pHandle));
	}
	
	/**
	* CBuildJob::JobCanBeArchived - Returns if a job is opened.
	* @return returns if the job can be archived.
	*/
	bool CBuildJob::JobCanBeArchived()
	{
		bool resultCanBeArchived = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_JobCanBeArchived(m_pHandle, &resultCanBeArchived));
		
		return resultCanBeArchived;
	}
	
	/**
	* CBuildJob::AddJobData - Adds additional data to the Job. Job MUST be of state validated in order to add job data.
	* @param[in] sName - Name of the job
	* @param[in] pStream - Storage Stream Instance
	* @param[in] eDataType - Datatype of Job data
	* @param[in] sUserID - Currently authenticated user
	*/
	void CBuildJob::AddJobData(const std::string & sName, classParam<CStorageStream> pStream, const eBuildJobDataType eDataType, const std::string & sUserID)
	{
		LibMCDataHandle hStream = pStream.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_AddJobData(m_pHandle, sName.c_str(), hStream, eDataType, sUserID.c_str()));
	}
	
	/**
	* CBuildJob::ListJobDataByType - Retrieves a list of build job data objects, filtered by type.
	* @param[in] eDataType - Datatype of Job data.
	* @return Build Job Data Iterator Instance.
	*/
	PBuildJobDataIterator CBuildJob::ListJobDataByType(const eBuildJobDataType eDataType)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ListJobDataByType(m_pHandle, eDataType, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJob::ListJobData - Retrieves a list of build job data objects.
	* @return Build Job Data Iterator Instance.
	*/
	PBuildJobDataIterator CBuildJob::ListJobData()
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_ListJobData(m_pHandle, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobDataIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJob::RetrieveJobData - Retrieves a build job data instance by its uuid.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Data Instance.
	*/
	PBuildJobData CBuildJob::RetrieveJobData(const std::string & sDataUUID)
	{
		LibMCDataHandle hBuildJobData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJob_RetrieveJobData(m_pHandle, sDataUUID.c_str(), &hBuildJobData));
		
		if (!hBuildJobData) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobData>(m_pWrapper, hBuildJobData);
	}
	
	/**
	 * Method definitions for class CBuildJobIterator
	 */
	
	/**
	* CBuildJobIterator::GetCurrentJob - Returns the build job the iterator points at.
	* @return returns the build job instance.
	*/
	PBuildJob CBuildJobIterator::GetCurrentJob()
	{
		LibMCDataHandle hCurrentInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobIterator_GetCurrentJob(m_pHandle, &hCurrentInstance));
		
		if (!hCurrentInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hCurrentInstance);
	}
	
	/**
	 * Method definitions for class CBuildJobHandler
	 */
	
	/**
	* CBuildJobHandler::CreateJob - Creates a new build job.
	* @param[in] sJobUUID - UUID String for the build job. Must be unique and newly generated.
	* @param[in] sName - Name String
	* @param[in] sUserID - Currently authenticated user
	* @param[in] sStorageStreamUUID - Storage stream uuid for the job. Needs not exist yet.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::CreateJob(const std::string & sJobUUID, const std::string & sName, const std::string & sUserID, const std::string & sStorageStreamUUID)
	{
		LibMCDataHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_CreateJob(m_pHandle, sJobUUID.c_str(), sName.c_str(), sUserID.c_str(), sStorageStreamUUID.c_str(), &hJobInstance));
		
		if (!hJobInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hJobInstance);
	}
	
	/**
	* CBuildJobHandler::RetrieveJob - Retrieves a job with a specific UUID.
	* @param[in] sJobUUID - UUID String for the build job. Must be an existing Job.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::RetrieveJob(const std::string & sJobUUID)
	{
		LibMCDataHandle hJobInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_RetrieveJob(m_pHandle, sJobUUID.c_str(), &hJobInstance));
		
		if (!hJobInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hJobInstance);
	}
	
	/**
	* CBuildJobHandler::FindJobOfData - Finds the parent build job of a given data uuid. Fails if data does not exist.
	* @param[in] sDataUUID - Job Data UUID.
	* @return Build Job Instance.
	*/
	PBuildJob CBuildJobHandler::FindJobOfData(const std::string & sDataUUID)
	{
		LibMCDataHandle hBuildJobData = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_FindJobOfData(m_pHandle, sDataUUID.c_str(), &hBuildJobData));
		
		if (!hBuildJobData) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJob>(m_pWrapper, hBuildJobData);
	}
	
	/**
	* CBuildJobHandler::ListJobsByStatus - Retrieves a list of build jobs, filtered by status.
	* @param[in] eStatus - Job Status to list.
	* @return Build Job Iterator Instance.
	*/
	PBuildJobIterator CBuildJobHandler::ListJobsByStatus(const eBuildJobStatus eStatus)
	{
		LibMCDataHandle hIteratorInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ListJobsByStatus(m_pHandle, eStatus, &hIteratorInstance));
		
		if (!hIteratorInstance) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobIterator>(m_pWrapper, hIteratorInstance);
	}
	
	/**
	* CBuildJobHandler::ConvertBuildStatusToString - Converts a status enum to a string identifier.
	* @param[in] eStatus - Status Enum.
	* @return String Identifier.
	*/
	std::string CBuildJobHandler::ConvertBuildStatusToString(const eBuildJobStatus eStatus)
	{
		LibMCData_uint32 bytesNeededString = 0;
		LibMCData_uint32 bytesWrittenString = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertBuildStatusToString(m_pHandle, eStatus, 0, &bytesNeededString, nullptr));
		std::vector<char> bufferString(bytesNeededString);
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertBuildStatusToString(m_pHandle, eStatus, bytesNeededString, &bytesWrittenString, &bufferString[0]));
		
		return std::string(&bufferString[0]);
	}
	
	/**
	* CBuildJobHandler::ConvertStringToBuildStatus - Converts a string identifier to a status enum. Case sensitive. Fails if invalid.
	* @param[in] sString - String Identifier.
	* @return Status Enum.
	*/
	eBuildJobStatus CBuildJobHandler::ConvertStringToBuildStatus(const std::string & sString)
	{
		eBuildJobStatus resultStatus = (eBuildJobStatus) 0;
		CheckError(m_pWrapper->m_WrapperTable.m_BuildJobHandler_ConvertStringToBuildStatus(m_pHandle, sString.c_str(), &resultStatus));
		
		return resultStatus;
	}
	
	/**
	 * Method definitions for class CLoginHandler
	 */
	
	/**
	* CLoginHandler::UserExists - Checks if a user exist.
	* @param[in] sUsername - User name
	* @return Flag if users exists
	*/
	bool CLoginHandler::UserExists(const std::string & sUsername)
	{
		bool resultUserExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_UserExists(m_pHandle, sUsername.c_str(), &resultUserExists));
		
		return resultUserExists;
	}
	
	/**
	* CLoginHandler::GetUserDetails - Retrieves a users data.
	* @param[in] sUsername - User name
	* @param[out] sSalt - Salt of the user.
	* @param[out] sHashedPassword - Hashed Password.
	*/
	void CLoginHandler::GetUserDetails(const std::string & sUsername, std::string & sSalt, std::string & sHashedPassword)
	{
		LibMCData_uint32 bytesNeededSalt = 0;
		LibMCData_uint32 bytesWrittenSalt = 0;
		LibMCData_uint32 bytesNeededHashedPassword = 0;
		LibMCData_uint32 bytesWrittenHashedPassword = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDetails(m_pHandle, sUsername.c_str(), 0, &bytesNeededSalt, nullptr, 0, &bytesNeededHashedPassword, nullptr));
		std::vector<char> bufferSalt(bytesNeededSalt);
		std::vector<char> bufferHashedPassword(bytesNeededHashedPassword);
		CheckError(m_pWrapper->m_WrapperTable.m_LoginHandler_GetUserDetails(m_pHandle, sUsername.c_str(), bytesNeededSalt, &bytesWrittenSalt, &bufferSalt[0], bytesNeededHashedPassword, &bytesWrittenHashedPassword, &bufferHashedPassword[0]));
		sSalt = std::string(&bufferSalt[0]);
		sHashedPassword = std::string(&bufferHashedPassword[0]);
	}
	
	/**
	 * Method definitions for class CPersistencyHandler
	 */
	
	/**
	* CPersistencyHandler::HasPersistentParameter - Retrieves if a persistent parameter has been stored.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter exists.
	*/
	bool CPersistencyHandler::HasPersistentParameter(const std::string & sUUID)
	{
		bool resultParameterExists = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_HasPersistentParameter(m_pHandle, sUUID.c_str(), &resultParameterExists));
		
		return resultParameterExists;
	}
	
	/**
	* CPersistencyHandler::GetPersistentParameterDetails - Retrieves details of a persistent parameter. Fails if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @param[out] sName - Returns name of the parameter
	* @param[out] eDataType - Returns data type of the parameter
	*/
	void CPersistencyHandler::GetPersistentParameterDetails(const std::string & sUUID, std::string & sName, eParameterDataType & eDataType)
	{
		LibMCData_uint32 bytesNeededName = 0;
		LibMCData_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_GetPersistentParameterDetails(m_pHandle, sUUID.c_str(), 0, &bytesNeededName, nullptr, &eDataType));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_GetPersistentParameterDetails(m_pHandle, sUUID.c_str(), bytesNeededName, &bytesWrittenName, &bufferName[0], &eDataType));
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* CPersistencyHandler::DeletePersistentParameter - Removes a persistent parameter from database. Does nothing if parameter does not exist.
	* @param[in] sUUID - UUID of the parameter
	* @return returns if parameter existed.
	*/
	bool CPersistencyHandler::DeletePersistentParameter(const std::string & sUUID)
	{
		bool resultParameterExisted = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_DeletePersistentParameter(m_pHandle, sUUID.c_str(), &resultParameterExisted));
		
		return resultParameterExisted;
	}
	
	/**
	* CPersistencyHandler::StorePersistentParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] eDataType - Data type of the parameter. If parameter exists, MUST be the same as the stored parameter data type.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	*/
	void CPersistencyHandler::StorePersistentParameter(const std::string & sUUID, const std::string & sName, const eParameterDataType eDataType, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentParameter(m_pHandle, sUUID.c_str(), sName.c_str(), eDataType, sValue.c_str()));
	}
	
	/**
	* CPersistencyHandler::StorePersistentStringParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter.
	*/
	void CPersistencyHandler::StorePersistentStringParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentStringParameter(m_pHandle, sUUID.c_str(), sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CPersistencyHandler::StorePersistentUUIDParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] sValue - Value of the parameter. MUST be of appropriate type.
	*/
	void CPersistencyHandler::StorePersistentUUIDParameter(const std::string & sUUID, const std::string & sName, const std::string & sValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentUUIDParameter(m_pHandle, sUUID.c_str(), sName.c_str(), sValue.c_str()));
	}
	
	/**
	* CPersistencyHandler::StorePersistentDoubleParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] dValue - Value of the parameter.
	*/
	void CPersistencyHandler::StorePersistentDoubleParameter(const std::string & sUUID, const std::string & sName, const LibMCData_double dValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentDoubleParameter(m_pHandle, sUUID.c_str(), sName.c_str(), dValue));
	}
	
	/**
	* CPersistencyHandler::StorePersistentIntegerParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] nValue - Value of the parameter.
	*/
	void CPersistencyHandler::StorePersistentIntegerParameter(const std::string & sUUID, const std::string & sName, const LibMCData_int64 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentIntegerParameter(m_pHandle, sUUID.c_str(), sName.c_str(), nValue));
	}
	
	/**
	* CPersistencyHandler::StorePersistentBoolParameter - Stores a persistent parameter in the database. Creates a new parameter if not existing.
	* @param[in] sUUID - UUID of the parameter
	* @param[in] sName - Name of the parameter. If parameter exists, MUST be the same as the stored parameter name.
	* @param[in] bValue - Value of the parameter.
	*/
	void CPersistencyHandler::StorePersistentBoolParameter(const std::string & sUUID, const std::string & sName, const bool bValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_StorePersistentBoolParameter(m_pHandle, sUUID.c_str(), sName.c_str(), bValue));
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentStringParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	std::string CPersistencyHandler::RetrievePersistentStringParameter(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededValue = 0;
		LibMCData_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentStringParameter(m_pHandle, sUUID.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentStringParameter(m_pHandle, sUUID.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentUUIDParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	std::string CPersistencyHandler::RetrievePersistentUUIDParameter(const std::string & sUUID)
	{
		LibMCData_uint32 bytesNeededValue = 0;
		LibMCData_uint32 bytesWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentUUIDParameter(m_pHandle, sUUID.c_str(), 0, &bytesNeededValue, nullptr));
		std::vector<char> bufferValue(bytesNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentUUIDParameter(m_pHandle, sUUID.c_str(), bytesNeededValue, &bytesWrittenValue, &bufferValue[0]));
		
		return std::string(&bufferValue[0]);
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentDoubleParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	LibMCData_double CPersistencyHandler::RetrievePersistentDoubleParameter(const std::string & sUUID)
	{
		LibMCData_double resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentDoubleParameter(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentIntegerParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	LibMCData_int64 CPersistencyHandler::RetrievePersistentIntegerParameter(const std::string & sUUID)
	{
		LibMCData_int64 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentIntegerParameter(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	* CPersistencyHandler::RetrievePersistentBoolParameter - Retrieves a persistent parameter in the database. Fails if not existing or invalid type.
	* @param[in] sUUID - UUID of the parameter
	* @return Value of the parameter.
	*/
	bool CPersistencyHandler::RetrievePersistentBoolParameter(const std::string & sUUID)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_PersistencyHandler_RetrievePersistentBoolParameter(m_pHandle, sUUID.c_str(), &resultValue));
		
		return resultValue;
	}
	
	/**
	 * Method definitions for class CDataModel
	 */
	
	/**
	* CDataModel::InitialiseDatabase - initializes the database connection.
	* @param[in] sDataDirectory - Directory that stores the data.
	* @param[in] eDataBaseType - Type of database.
	* @param[in] sConnectionString - Connection string.
	*/
	void CDataModel::InitialiseDatabase(const std::string & sDataDirectory, const eDataBaseType eDataBaseType, const std::string & sConnectionString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_InitialiseDatabase(m_pHandle, sDataDirectory.c_str(), eDataBaseType, sConnectionString.c_str()));
	}
	
	/**
	* CDataModel::GetDataModelVersion - returns the linear data model version.
	* @return Data model version.
	*/
	LibMCData_uint32 CDataModel::GetDataModelVersion()
	{
		LibMCData_uint32 resultVersion = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetDataModelVersion(m_pHandle, &resultVersion));
		
		return resultVersion;
	}
	
	/**
	* CDataModel::GetInstallationInformation - returns unique identifiers for the current installation.
	* @param[out] sInstallationUUID - Installation UUID. Public value to document which installation was used for something.
	* @param[out] sInstallationSecret - Secret SHA256 key for seeding external-facing pseudo-randomness. MUST NOT be given outside of the application.
	*/
	void CDataModel::GetInstallationInformation(std::string & sInstallationUUID, std::string & sInstallationSecret)
	{
		LibMCData_uint32 bytesNeededInstallationUUID = 0;
		LibMCData_uint32 bytesWrittenInstallationUUID = 0;
		LibMCData_uint32 bytesNeededInstallationSecret = 0;
		LibMCData_uint32 bytesWrittenInstallationSecret = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetInstallationInformation(m_pHandle, 0, &bytesNeededInstallationUUID, nullptr, 0, &bytesNeededInstallationSecret, nullptr));
		std::vector<char> bufferInstallationUUID(bytesNeededInstallationUUID);
		std::vector<char> bufferInstallationSecret(bytesNeededInstallationSecret);
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetInstallationInformation(m_pHandle, bytesNeededInstallationUUID, &bytesWrittenInstallationUUID, &bufferInstallationUUID[0], bytesNeededInstallationSecret, &bytesWrittenInstallationSecret, &bufferInstallationSecret[0]));
		sInstallationUUID = std::string(&bufferInstallationUUID[0]);
		sInstallationSecret = std::string(&bufferInstallationSecret[0]);
	}
	
	/**
	* CDataModel::CreateStorage - creates a storage access class.
	* @return Storage class instance.
	*/
	PStorage CDataModel::CreateStorage()
	{
		LibMCDataHandle hStorage = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateStorage(m_pHandle, &hStorage));
		
		if (!hStorage) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CStorage>(m_pWrapper, hStorage);
	}
	
	/**
	* CDataModel::CreateBuildJobHandler - creates a build job access class.
	* @return BuildJobHandler class instance.
	*/
	PBuildJobHandler CDataModel::CreateBuildJobHandler()
	{
		LibMCDataHandle hBuildJobHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateBuildJobHandler(m_pHandle, &hBuildJobHandler));
		
		if (!hBuildJobHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CBuildJobHandler>(m_pWrapper, hBuildJobHandler);
	}
	
	/**
	* CDataModel::CreateNewLogSession - creates a global log session access class.
	* @return LogSession class instance.
	*/
	PLogSession CDataModel::CreateNewLogSession()
	{
		LibMCDataHandle hLogSession = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateNewLogSession(m_pHandle, &hLogSession));
		
		if (!hLogSession) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLogSession>(m_pWrapper, hLogSession);
	}
	
	/**
	* CDataModel::CreateLoginHandler - creates a login handler instance.
	* @return LoginHandler instance.
	*/
	PLoginHandler CDataModel::CreateLoginHandler()
	{
		LibMCDataHandle hLoginHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreateLoginHandler(m_pHandle, &hLoginHandler));
		
		if (!hLoginHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLoginHandler>(m_pWrapper, hLoginHandler);
	}
	
	/**
	* CDataModel::CreatePersistencyHandler - creates a persistency handler instance.
	* @return PersistencyHandler instance.
	*/
	PPersistencyHandler CDataModel::CreatePersistencyHandler()
	{
		LibMCDataHandle hPersistencyHandler = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_CreatePersistencyHandler(m_pHandle, &hPersistencyHandler));
		
		if (!hPersistencyHandler) {
			CheckError(LIBMCDATA_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CPersistencyHandler>(m_pWrapper, hPersistencyHandler);
	}
	
	/**
	* CDataModel::SetBaseTempDirectory - Sets a custom base temp directory. An empty string defaults to the system temp directory.
	* @param[in] sTempDirectory - Temp directory path to use. SHOULD be an absolute path, if not empty. Directory MUST exist, if not empty.
	*/
	void CDataModel::SetBaseTempDirectory(const std::string & sTempDirectory)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_SetBaseTempDirectory(m_pHandle, sTempDirectory.c_str()));
	}
	
	/**
	* CDataModel::GetBaseTempDirectory - Returns a custom base temp directory. An empty string defaults to the system temp directory.
	* @return Temp directory path.
	*/
	std::string CDataModel::GetBaseTempDirectory()
	{
		LibMCData_uint32 bytesNeededTempDirectory = 0;
		LibMCData_uint32 bytesWrittenTempDirectory = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetBaseTempDirectory(m_pHandle, 0, &bytesNeededTempDirectory, nullptr));
		std::vector<char> bufferTempDirectory(bytesNeededTempDirectory);
		CheckError(m_pWrapper->m_WrapperTable.m_DataModel_GetBaseTempDirectory(m_pHandle, bytesNeededTempDirectory, &bytesWrittenTempDirectory, &bufferTempDirectory[0]));
		
		return std::string(&bufferTempDirectory[0]);
	}

} // namespace LibMCData

#endif // __LIBMCDATA_CPPHEADER_DYNAMIC_CPP

