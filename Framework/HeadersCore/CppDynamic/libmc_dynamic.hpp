/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.8.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of Machine Control library

Interface version: 1.0.0

*/

#ifndef __LIBMC_CPPHEADER_DYNAMIC_CPP
#define __LIBMC_CPPHEADER_DYNAMIC_CPP

#include "libmc_types.hpp"
#include "libmc_dynamic.h"

#include "libmcdata_dynamic.hpp"

#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibMC {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CAPIRequestHandler;
class CMCContext;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibMCWrapper;
typedef CBase CLibMCBase;
typedef CAPIRequestHandler CLibMCAPIRequestHandler;
typedef CMCContext CLibMCMCContext;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CAPIRequestHandler> PAPIRequestHandler;
typedef std::shared_ptr<CMCContext> PMCContext;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibMCWrapper;
typedef PBase PLibMCBase;
typedef PAPIRequestHandler PLibMCAPIRequestHandler;
typedef PMCContext PLibMCMCContext;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibMCHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibMCException 
**************************************************************************************************************************/
class ELibMCException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibMCResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;
	std::string m_originalErrorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibMCException(LibMCResult errorCode, const std::string & sErrorMessage)
		: m_errorCode(errorCode), m_originalErrorMessage(sErrorMessage)
	{
		m_errorMessage = buildErrorMessage();
	}

	/**
	* Returns error code
	*/
	LibMCResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

	const char* getErrorMessage() const noexcept
	{
		return m_originalErrorMessage.c_str();
	}

	const char* getErrorName() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMC_SUCCESS: return "SUCCESS";
			case LIBMC_ERROR_NOTIMPLEMENTED: return "NOTIMPLEMENTED";
			case LIBMC_ERROR_INVALIDPARAM: return "INVALIDPARAM";
			case LIBMC_ERROR_INVALIDCAST: return "INVALIDCAST";
			case LIBMC_ERROR_BUFFERTOOSMALL: return "BUFFERTOOSMALL";
			case LIBMC_ERROR_GENERICEXCEPTION: return "GENERICEXCEPTION";
			case LIBMC_ERROR_COULDNOTLOADLIBRARY: return "COULDNOTLOADLIBRARY";
			case LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT: return "COULDNOTFINDLIBRARYEXPORT";
			case LIBMC_ERROR_INCOMPATIBLEBINARYVERSION: return "INCOMPATIBLEBINARYVERSION";
			case LIBMC_ERROR_COULDNOTPARSECONFIGURATION: return "COULDNOTPARSECONFIGURATION";
			case LIBMC_ERROR_DUPLICATESTATENAME: return "DUPLICATESTATENAME";
			case LIBMC_ERROR_STATENOTFOUND: return "STATENOTFOUND";
			case LIBMC_ERROR_DUPLICATEOUTSTATE: return "DUPLICATEOUTSTATE";
			case LIBMC_ERROR_MISSINGMACHINEDEFINITION: return "MISSINGMACHINEDEFINITION";
			case LIBMC_ERROR_MISSINGINSTANCENAME: return "MISSINGINSTANCENAME";
			case LIBMC_ERROR_DUPLICATEMACHINEINSTANCE: return "DUPLICATEMACHINEINSTANCE";
			case LIBMC_ERROR_MISSINGXMLSCHEMA: return "MISSINGXMLSCHEMA";
			case LIBMC_ERROR_INVALIDXMLSCHEMA: return "INVALIDXMLSCHEMA";
			case LIBMC_ERROR_MISSINGSTATENAME: return "MISSINGSTATENAME";
			case LIBMC_ERROR_MISSINGOUTSTATETARGET: return "MISSINGOUTSTATETARGET";
			case LIBMC_ERROR_INVALIDOUTSTATETARGET: return "INVALIDOUTSTATETARGET";
			case LIBMC_ERROR_NOINITSTATE: return "NOINITSTATE";
			case LIBMC_ERROR_NOFAILEDSTATE: return "NOFAILEDSTATE";
			case LIBMC_ERROR_INITSTATENOTFOUND: return "INITSTATENOTFOUND";
			case LIBMC_ERROR_FAILEDSTATENOTFOUND: return "FAILEDSTATENOTFOUND";
			case LIBMC_ERROR_MISSINGINITSTATE: return "MISSINGINITSTATE";
			case LIBMC_ERROR_MISSINGFAILEDSTATE: return "MISSINGFAILEDSTATE";
			case LIBMC_ERROR_MISSINGPLUGINNAME: return "MISSINGPLUGINNAME";
			case LIBMC_ERROR_EMPTYINITSTATE: return "EMPTYINITSTATE";
			case LIBMC_ERROR_EMPTYFAILEDSTATE: return "EMPTYFAILEDSTATE";
			case LIBMC_ERROR_EMPTYPLUGINNAME: return "EMPTYPLUGINNAME";
			case LIBMC_ERROR_COULDNOTCREATESTATEFACTORY: return "COULDNOTCREATESTATEFACTORY";
			case LIBMC_ERROR_INVALIDSTATENAME: return "INVALIDSTATENAME";
			case LIBMC_ERROR_COULDNOTCREATESTATE: return "COULDNOTCREATESTATE";
			case LIBMC_ERROR_COULDNOTINITIALIZEFACTORY: return "COULDNOTINITIALIZEFACTORY";
			case LIBMC_ERROR_COULDNOTFINALIZEFACTORY: return "COULDNOTFINALIZEFACTORY";
			case LIBMC_ERROR_COULDNOTLOADPLUGIN: return "COULDNOTLOADPLUGIN";
			case LIBMC_ERROR_NOCURRENTSTATE: return "NOCURRENTSTATE";
			case LIBMC_ERROR_NOPLUGINSTATE: return "NOPLUGINSTATE";
			case LIBMC_ERROR_COULDNOTEXECUTEPLUGIN: return "COULDNOTEXECUTEPLUGIN";
			case LIBMC_ERROR_TOOMANYMACHINEINSTANCES: return "TOOMANYMACHINEINSTANCES";
			case LIBMC_ERROR_INVALIDINDEX: return "INVALIDINDEX";
			case LIBMC_ERROR_NOOUTSTATEGIVEN: return "NOOUTSTATEGIVEN";
			case LIBMC_ERROR_INVALIDOUTSTATEGIVEN: return "INVALIDOUTSTATEGIVEN";
			case LIBMC_ERROR_INVALIDREPEATDELAY: return "INVALIDREPEATDELAY";
			case LIBMC_ERROR_INVALIDEXECUTIONDELAY: return "INVALIDEXECUTIONDELAY";
			case LIBMC_ERROR_MISSINGREPEATDELAY: return "MISSINGREPEATDELAY";
			case LIBMC_ERROR_THREADISRUNNING: return "THREADISRUNNING";
			case LIBMC_ERROR_THREADISNOTRUNNING: return "THREADISNOTRUNNING";
			case LIBMC_ERROR_DUPLICATESIGNAL: return "DUPLICATESIGNAL";
			case LIBMC_ERROR_INVALIDSIGNALNAME: return "INVALIDSIGNALNAME";
			case LIBMC_ERROR_MISSINGSIGNALNAME: return "MISSINGSIGNALNAME";
			case LIBMC_ERROR_MISSINGSERVERNODE: return "MISSINGSERVERNODE";
			case LIBMC_ERROR_MISSINGHOSTNAME: return "MISSINGHOSTNAME";
			case LIBMC_ERROR_MISSINGPORT: return "MISSINGPORT";
			case LIBMC_ERROR_UUIDGENERATIONFAILED: return "UUIDGENERATIONFAILED";
			case LIBMC_ERROR_INVALIDBUFFERSIZE: return "INVALIDBUFFERSIZE";
			case LIBMC_ERROR_COULDNOTCONVERTTOUTF8: return "COULDNOTCONVERTTOUTF8";
			case LIBMC_ERROR_NOCOLUMNAVAILABLE: return "NOCOLUMNAVAILABLE";
			case LIBMC_ERROR_INVALIDTEXTCOLUMN: return "INVALIDTEXTCOLUMN";
			case LIBMC_ERROR_INVALIDCOLUMNTYPE: return "INVALIDCOLUMNTYPE";
			case LIBMC_ERROR_TOOMANYREQUESTEDLOGS: return "TOOMANYREQUESTEDLOGS";
			case LIBMC_ERROR_MISSINGINSTANCEDESCRIPTION: return "MISSINGINSTANCEDESCRIPTION";
			case LIBMC_ERROR_DUPLICATEPARAMETERGROUPNAME: return "DUPLICATEPARAMETERGROUPNAME";
			case LIBMC_ERROR_MISSINGPARAMETERGROUPNAME: return "MISSINGPARAMETERGROUPNAME";
			case LIBMC_ERROR_EMPTYPARAMETERGROUPNAME: return "EMPTYPARAMETERGROUPNAME";
			case LIBMC_ERROR_MISSINGPARAMETERGROUPDESCRIPTION: return "MISSINGPARAMETERGROUPDESCRIPTION";
			case LIBMC_ERROR_EMPTYPARAMETERGROUPDESCRIPTION: return "EMPTYPARAMETERGROUPDESCRIPTION";
			case LIBMC_ERROR_TOOMANYPARAMETERS: return "TOOMANYPARAMETERS";
			case LIBMC_ERROR_TOOMANYPARAMETERGROUPS: return "TOOMANYPARAMETERGROUPS";
			case LIBMC_ERROR_DUPLICATEPARAMETERNAME: return "DUPLICATEPARAMETERNAME";
			case LIBMC_ERROR_MISSINGPARAMETERNAME: return "MISSINGPARAMETERNAME";
			case LIBMC_ERROR_EMPTYPARAMETERNAME: return "EMPTYPARAMETERNAME";
			case LIBMC_ERROR_MISSINGPARAMETERDESCRIPTION: return "MISSINGPARAMETERDESCRIPTION";
			case LIBMC_ERROR_EMPTYPARAMETERDESCRIPTION: return "EMPTYPARAMETERDESCRIPTION";
			case LIBMC_ERROR_PARAMETERNOTFOUND: return "PARAMETERNOTFOUND";
			case LIBMC_ERROR_MISSINGPARAMETERDEFAULTVALUE: return "MISSINGPARAMETERDEFAULTVALUE";
			case LIBMC_ERROR_MISSINGDATACONFIGNODE: return "MISSINGDATACONFIGNODE";
			case LIBMC_ERROR_MISSINGDIRECTORY: return "MISSINGDIRECTORY";
			case LIBMC_ERROR_MISSINGDATABASETYPE: return "MISSINGDATABASETYPE";
			case LIBMC_ERROR_MISSINGSQLITEINFO: return "MISSINGSQLITEINFO";
			case LIBMC_ERROR_UNKNOWNDATABASETYPE: return "UNKNOWNDATABASETYPE";
			case LIBMC_ERROR_STORAGENOTINITIALISED: return "STORAGENOTINITIALISED";
			case LIBMC_ERROR_COULDNOTCONVERTTOUTF16: return "COULDNOTCONVERTTOUTF16";
			case LIBMC_ERROR_COULDNOTCREATEFILE: return "COULDNOTCREATEFILE";
			case LIBMC_ERROR_COULDNOTSEEKSTREAM: return "COULDNOTSEEKSTREAM";
			case LIBMC_ERROR_COULDNOTGETSTREAMPOSITION: return "COULDNOTGETSTREAMPOSITION";
			case LIBMC_ERROR_COULDNOTWRITESTREAM: return "COULDNOTWRITESTREAM";
			case LIBMC_ERROR_INVALIDDATABASEMIGRATION: return "INVALIDDATABASEMIGRATION";
			case LIBMC_ERROR_INTERNALERROR: return "INTERNALERROR";
			case LIBMC_ERROR_COULDNOTSTORECONTENTSTREAM: return "COULDNOTSTORECONTENTSTREAM";
			case LIBMC_ERROR_DATABASENOTINITIALISED: return "DATABASENOTINITIALISED";
			case LIBMC_ERROR_PARAMETERGROUPNOTFOUND: return "PARAMETERGROUPNOTFOUND";
			case LIBMC_ERROR_SIGNALNOTFOUND: return "SIGNALNOTFOUND";
			case LIBMC_ERROR_STATEMACHINENOTFOUND: return "STATEMACHINENOTFOUND";
			case LIBMC_ERROR_MISSINGPARAMETERTYPE: return "MISSINGPARAMETERTYPE";
			case LIBMC_ERROR_INVALIDPARAMETERTYPE: return "INVALIDPARAMETERTYPE";
			case LIBMC_ERROR_COULDNOTPARSEJSON: return "COULDNOTPARSEJSON";
			case LIBMC_ERROR_INVALIDJSONFORMAT: return "INVALIDJSONFORMAT";
			case LIBMC_ERROR_URLNOTFOUND: return "URLNOTFOUND";
			case LIBMC_ERROR_GENERICBADREQUEST: return "GENERICBADREQUEST";
			case LIBMC_ERROR_SQLITE_ERROR: return "SQLITE_ERROR";
			case LIBMC_ERROR_SQLITE_INTERNAL: return "SQLITE_INTERNAL";
			case LIBMC_ERROR_SQLITE_PERM: return "SQLITE_PERM";
			case LIBMC_ERROR_SQLITE_ABORT: return "SQLITE_ABORT";
			case LIBMC_ERROR_SQLITE_BUSY: return "SQLITE_BUSY";
			case LIBMC_ERROR_SQLITE_LOCKED: return "SQLITE_LOCKED";
			case LIBMC_ERROR_SQLITE_NOMEM: return "SQLITE_NOMEM";
			case LIBMC_ERROR_SQLITE_READONLY: return "SQLITE_READONLY";
			case LIBMC_ERROR_SQLITE_INTERRUPT: return "SQLITE_INTERRUPT";
			case LIBMC_ERROR_SQLITE_IOERR: return "SQLITE_IOERR";
			case LIBMC_ERROR_SQLITE_CORRUPT: return "SQLITE_CORRUPT";
			case LIBMC_ERROR_SQLITE_NOTFOUND: return "SQLITE_NOTFOUND";
			case LIBMC_ERROR_SQLITE_FULL: return "SQLITE_FULL";
			case LIBMC_ERROR_SQLITE_CANTOPEN: return "SQLITE_CANTOPEN";
			case LIBMC_ERROR_SQLITE_PROTOCOL: return "SQLITE_PROTOCOL";
			case LIBMC_ERROR_SQLITE_SCHEMA: return "SQLITE_SCHEMA";
			case LIBMC_ERROR_SQLITE_TOOBIG: return "SQLITE_TOOBIG";
			case LIBMC_ERROR_SQLITE_CONSTRAINT: return "SQLITE_CONSTRAINT";
			case LIBMC_ERROR_SQLITE_MISMATCH: return "SQLITE_MISMATCH";
			case LIBMC_ERROR_SQLITE_MISUSE: return "SQLITE_MISUSE";
			case LIBMC_ERROR_SQLITE_NOLFS: return "SQLITE_NOLFS";
			case LIBMC_ERROR_SQLITE_AUTH: return "SQLITE_AUTH";
			case LIBMC_ERROR_SQLITE_RANGE: return "SQLITE_RANGE";
			case LIBMC_ERROR_SQLITE_NOTADB: return "SQLITE_NOTADB";
			case LIBMC_ERROR_SQLITE_NOTICE: return "SQLITE_NOTICE";
			case LIBMC_ERROR_SQLITE_WARNING: return "SQLITE_WARNING";
			case LIBMC_ERROR_SQLITE_OTHER: return "SQLITE_OTHER";
			case LIBMC_ERROR_SQLITE_TOOMANYRESULTROWS: return "SQLITE_TOOMANYRESULTROWS";
			case LIBMC_ERROR_COULDNOTREADZIPFILE: return "COULDNOTREADZIPFILE";
			case LIBMC_ERROR_COULDNOTOPENZIPFILE: return "COULDNOTOPENZIPFILE";
			case LIBMC_ERROR_COULDNOTGETZIPENTRIES: return "COULDNOTGETZIPENTRIES";
			case LIBMC_ERROR_ZIPENTRYNOTFOUND: return "ZIPENTRYNOTFOUND";
			case LIBMC_ERROR_COULDNOTSTATZIPENTRY: return "COULDNOTSTATZIPENTRY";
			case LIBMC_ERROR_COULDNOTOPENZIPENTRY: return "COULDNOTOPENZIPENTRY";
			case LIBMC_ERROR_COULDNOTREADZIPSTREAM: return "COULDNOTREADZIPSTREAM";
			case LIBMC_ERROR_COULDNOTREADFULLZIPDATA: return "COULDNOTREADFULLZIPDATA";
			case LIBMC_ERROR_COULDNOTFINDRESOURCEINDEX: return "COULDNOTFINDRESOURCEINDEX";
			case LIBMC_ERROR_COULDNOTPARSERESOURCEINDEX: return "COULDNOTPARSERESOURCEINDEX";
			case LIBMC_ERROR_EMPTYRESOURCEINDEX: return "EMPTYRESOURCEINDEX";
			case LIBMC_ERROR_MISSINGRESOURCEINDEX: return "MISSINGRESOURCEINDEX";
			case LIBMC_ERROR_MISSINGRESOURCENAME: return "MISSINGRESOURCENAME";
			case LIBMC_ERROR_MISSINGRESOURCEFILENAME: return "MISSINGRESOURCEFILENAME";
			case LIBMC_ERROR_MISSINGRESOURCESIZE: return "MISSINGRESOURCESIZE";
			case LIBMC_ERROR_MISSINGRESOURCECONTENTTYPE: return "MISSINGRESOURCECONTENTTYPE";
			case LIBMC_ERROR_DRIVERALREADYREGISTERED: return "DRIVERALREADYREGISTERED";
			case LIBMC_ERROR_DRIVERNOTFOUND: return "DRIVERNOTFOUND";
			case LIBMC_ERROR_MISSINGDRIVERNAME: return "MISSINGDRIVERNAME";
			case LIBMC_ERROR_MISSINGDRIVERTYPE: return "MISSINGDRIVERTYPE";
			case LIBMC_ERROR_MISSINGDRIVERLIBRARY: return "MISSINGDRIVERLIBRARY";
			case LIBMC_ERROR_DRIVERALREADYRESERVED: return "DRIVERALREADYRESERVED";
			case LIBMC_ERROR_LIBRARYPATHNOTFOUND: return "LIBRARYPATHNOTFOUND";
			case LIBMC_ERROR_TOOLPATHENTITYNOTLOADED: return "TOOLPATHENTITYNOTLOADED";
			case LIBMC_ERROR_TOOLPATHENTITYREFERENCEERROR: return "TOOLPATHENTITYREFERENCEERROR";
			case LIBMC_ERROR_TOOLPATHENTITYINVALIDFILE: return "TOOLPATHENTITYINVALIDFILE";
			case LIBMC_ERROR_NO3MFLIBRARY: return "NO3MFLIBRARY";
			case LIBMC_ERROR_INVALIDPOINTCOUNT: return "INVALIDPOINTCOUNT";
			case LIBMC_ERROR_DUPLICATEJOBUUID: return "DUPLICATEJOBUUID";
			case LIBMC_ERROR_INVALIDJOBSTATUS: return "INVALIDJOBSTATUS";
			case LIBMC_ERROR_INVALIDSTREAMCONTEXT: return "INVALIDSTREAMCONTEXT";
			case LIBMC_ERROR_JOBUUIDNOTFOUND: return "JOBUUIDNOTFOUND";
			case LIBMC_ERROR_INVALIDJOBNAME: return "INVALIDJOBNAME";
			case LIBMC_ERROR_INVALIDJOBTIMESTAMP: return "INVALIDJOBTIMESTAMP";
			case LIBMC_ERROR_INVALIDUSERID: return "INVALIDUSERID";
			case LIBMC_ERROR_INVALIDSTORAGECALLBACKSIGNATURE: return "INVALIDSTORAGECALLBACKSIGNATURE";
			case LIBMC_ERROR_INVALIDSTORAGECALLBACKSTREAM: return "INVALIDSTORAGECALLBACKSTREAM";
			case LIBMC_ERROR_INVALIDSTORAGEPATH: return "INVALIDSTORAGEPATH";
			case LIBMC_ERROR_STORAGESTREAMNOTFOUND: return "STORAGESTREAMNOTFOUND";
			case LIBMC_ERROR_DUPLICATESTORAGESTREAM: return "DUPLICATESTORAGESTREAM";
			case LIBMC_ERROR_INVALIDPARTIALUPLOAD: return "INVALIDPARTIALUPLOAD";
			case LIBMC_ERROR_PARTIALUPLOADNOTFINISHED: return "PARTIALUPLOADNOTFINISHED";
			case LIBMC_ERROR_APIREQUESTNOTHANDLED: return "APIREQUESTNOTHANDLED";
			case LIBMC_ERROR_APIREQUESTALREADYHANDLED: return "APIREQUESTALREADYHANDLED";
			case LIBMC_ERROR_INVALIDAPIREQUESTTYPE: return "INVALIDAPIREQUESTTYPE";
			case LIBMC_ERROR_INVALIDUPLOADSTREAM: return "INVALIDUPLOADSTREAM";
			case LIBMC_ERROR_COULDNOTPARSEJSONREQUEST: return "COULDNOTPARSEJSONREQUEST";
			case LIBMC_ERROR_INVALIDCONTEXTUUID: return "INVALIDCONTEXTUUID";
			case LIBMC_ERROR_INVALIDUPLOADNAME: return "INVALIDUPLOADNAME";
			case LIBMC_ERROR_INVALIDMIMETYPE: return "INVALIDMIMETYPE";
			case LIBMC_ERROR_INVALIDSTREAMSIZE: return "INVALIDSTREAMSIZE";
			case LIBMC_ERROR_INVALIDSHA256SUM: return "INVALIDSHA256SUM";
			case LIBMC_ERROR_INVALIDSTREAMUUID: return "INVALIDSTREAMUUID";
			case LIBMC_ERROR_INVALIDFIELDNAME: return "INVALIDFIELDNAME";
			case LIBMC_ERROR_UPLOADSIZEMISMATCH: return "UPLOADSIZEMISMATCH";
			case LIBMC_ERROR_CONTENTTYPENOTACCEPTED: return "CONTENTTYPENOTACCEPTED";
			case LIBMC_ERROR_NOCURRENTUPLOAD: return "NOCURRENTUPLOAD";
			case LIBMC_ERROR_UPLOADCHECKSUMMISMATCH: return "UPLOADCHECKSUMMISMATCH";
			case LIBMC_ERROR_INVALIDSTORAGESTREAMSTATUS: return "INVALIDSTORAGESTREAMSTATUS";
			case LIBMC_ERROR_CONTEXTUUIDNOTACCEPTED: return "CONTEXTUUIDNOTACCEPTED";
			case LIBMC_ERROR_INVALIDBUILDUUID: return "INVALIDBUILDUUID";
			case LIBMC_ERROR_MISSINGTHREADCOUNT: return "MISSINGTHREADCOUNT";
			case LIBMC_ERROR_INVALIDTHREADCOUNT: return "INVALIDTHREADCOUNT";
			case LIBMC_ERROR_COULDNOTUPDATEBUILDSTATUS: return "COULDNOTUPDATEBUILDSTATUS";
			case LIBMC_ERROR_INVALIDITERATOR: return "INVALIDITERATOR";
			case LIBMC_ERROR_INVALIDDATATYPE: return "INVALIDDATATYPE";
			case LIBMC_ERROR_COULDNOTSENDSIGNAL: return "COULDNOTSENDSIGNAL";
			case LIBMC_ERROR_MISSINGSIGNALPARAMETER: return "MISSINGSIGNALPARAMETER";
			case LIBMC_ERROR_NOUSERINTERFACEDEFINITION: return "NOUSERINTERFACEDEFINITION";
			case LIBMC_ERROR_MISSINGAPPNAME: return "MISSINGAPPNAME";
			case LIBMC_ERROR_MISSINGCOPYRIGHT: return "MISSINGCOPYRIGHT";
			case LIBMC_ERROR_MISSINGMAINPAGE: return "MISSINGMAINPAGE";
			case LIBMC_ERROR_MISSINGMENUITEMID: return "MISSINGMENUITEMID";
			case LIBMC_ERROR_MISSINGMENUITEMICON: return "MISSINGMENUITEMICON";
			case LIBMC_ERROR_MISSINGMENUITEMCAPTION: return "MISSINGMENUITEMCAPTION";
			case LIBMC_ERROR_MISSINGTARGETPAGE: return "MISSINGTARGETPAGE";
			case LIBMC_ERROR_MISSINGMENUNODE: return "MISSINGMENUNODE";
			case LIBMC_ERROR_MISSINGTOOLBARNODE: return "MISSINGTOOLBARNODE";
			case LIBMC_ERROR_MISSINGTOOLBARITEMID: return "MISSINGTOOLBARITEMID";
			case LIBMC_ERROR_MISSINGTOOLBARITEMICON: return "MISSINGTOOLBARITEMICON";
			case LIBMC_ERROR_MISSINGTOOLBARITEMCAPTION: return "MISSINGTOOLBARITEMCAPTION";
			case LIBMC_ERROR_MISSINGSERVICESNODE: return "MISSINGSERVICESNODE";
			case LIBMC_ERROR_INVALIDSESSIONUUID: return "INVALIDSESSIONUUID";
			case LIBMC_ERROR_INVALIDSESSIONKEY: return "INVALIDSESSIONKEY";
			case LIBMC_ERROR_SESSIONNOTAUTHORIZED: return "SESSIONNOTAUTHORIZED";
			case LIBMC_ERROR_INVALIDUSERNAME: return "INVALIDUSERNAME";
			case LIBMC_ERROR_INVALIDPASSWORD: return "INVALIDPASSWORD";
			case LIBMC_ERROR_INVALIDAUTHORIZATION: return "INVALIDAUTHORIZATION";
			case LIBMC_ERROR_USERALREADYAUTHORIZED: return "USERALREADYAUTHORIZED";
			case LIBMC_ERROR_INVALIDSESSIONTOKEN: return "INVALIDSESSIONTOKEN";
			case LIBMC_ERROR_INVALIDCLIENTKEY: return "INVALIDCLIENTKEY";
			case LIBMC_ERROR_INVALIDLOGIN: return "INVALIDLOGIN";
			case LIBMC_ERROR_DUPLICATEPAGE: return "DUPLICATEPAGE";
			case LIBMC_ERROR_PAGENOTFOUND: return "PAGENOTFOUND";
			case LIBMC_ERROR_MISSINGPAGENAME: return "MISSINGPAGENAME";
			case LIBMC_ERROR_INVALIDPAGENAME: return "INVALIDPAGENAME";
			case LIBMC_ERROR_MODULENOTFOUND: return "MODULENOTFOUND";
			case LIBMC_ERROR_DUPLICATEMODULE: return "DUPLICATEMODULE";
			case LIBMC_ERROR_INVALIDMODULENAME: return "INVALIDMODULENAME";
			case LIBMC_ERROR_INVALIDMODULETYPE: return "INVALIDMODULETYPE";
			case LIBMC_ERROR_INVALIDHEADLINE: return "INVALIDHEADLINE";
			case LIBMC_ERROR_USERNOTFOUND: return "USERNOTFOUND";
			case LIBMC_ERROR_STREAMISNOTIMAGE: return "STREAMISNOTIMAGE";
			case LIBMC_ERROR_TOOMANYCONTENTPARAMETERS: return "TOOMANYCONTENTPARAMETERS";
			case LIBMC_ERROR_MISSINGCONTENTSTATEMACHINENAME: return "MISSINGCONTENTSTATEMACHINENAME";
			case LIBMC_ERROR_MISSINGCONTENTGROUPNAME: return "MISSINGCONTENTGROUPNAME";
			case LIBMC_ERROR_INVALIDENTRIESPERPAGE: return "INVALIDENTRIESPERPAGE";
			case LIBMC_ERROR_MODULEITEMNOTFOUND: return "MODULEITEMNOTFOUND";
			case LIBMC_ERROR_DERIVEDPARAMETERSREADONLY: return "DERIVEDPARAMETERSREADONLY";
			case LIBMC_ERROR_TOOMANYJOURNALVARIABLES: return "TOOMANYJOURNALVARIABLES";
			case LIBMC_ERROR_JOURNALISNOTINITIALISING: return "JOURNALISNOTINITIALISING";
			case LIBMC_ERROR_JOURNALISNOTRECORDING: return "JOURNALISNOTRECORDING";
			case LIBMC_ERROR_INVALIDVARIABLETYPE: return "INVALIDVARIABLETYPE";
			case LIBMC_ERROR_INVALIDVARIABLEUNITS: return "INVALIDVARIABLEUNITS";
			case LIBMC_ERROR_UNITSHAVEALREADYBEENSET: return "UNITSHAVEALREADYBEENSET";
			case LIBMC_ERROR_UNITSHAVENOTBEENSET: return "UNITSHAVENOTBEENSET";
			case LIBMC_ERROR_INVALIDTIMESTAMP: return "INVALIDTIMESTAMP";
			case LIBMC_ERROR_NOCURRENTJOURNALCHUNK: return "NOCURRENTJOURNALCHUNK";
			case LIBMC_ERROR_DUPLICATEJOURNALID: return "DUPLICATEJOURNALID";
			case LIBMC_ERROR_RESOURCEENTRYNOTFOUND: return "RESOURCEENTRYNOTFOUND";
			case LIBMC_ERROR_NOCORERESOURCEPACKAGE: return "NOCORERESOURCEPACKAGE";
			case LIBMC_ERROR_INVALIDASPECTRATIO: return "INVALIDASPECTRATIO";
			case LIBMC_ERROR_MISSINGLOGORESOURCE: return "MISSINGLOGORESOURCE";
			case LIBMC_ERROR_NOUSERINTERFACEPLUGIN: return "NOUSERINTERFACEPLUGIN";
			case LIBMC_ERROR_COULDNOTLOADUILIBRARY: return "COULDNOTLOADUILIBRARY";
			case LIBMC_ERROR_EVENTNAMENOTFOUND: return "EVENTNAMENOTFOUND";
			case LIBMC_ERROR_INVALIDEVENTSENDER: return "INVALIDEVENTSENDER";
			case LIBMC_ERROR_INVALIDEVENTCONTEXT: return "INVALIDEVENTCONTEXT";
			case LIBMC_ERROR_INVALIDLAYERINDEX: return "INVALIDLAYERINDEX";
			case LIBMC_ERROR_TEMPBASEPATHEMPTY: return "TEMPBASEPATHEMPTY";
			case LIBMC_ERROR_PROFILENOTFOUND: return "PROFILENOTFOUND";
			case LIBMC_ERROR_INVALIDSERVICEHANDLER: return "INVALIDSERVICEHANDLER";
			case LIBMC_ERROR_INVALIDMAXTHREADCOUNT: return "INVALIDMAXTHREADCOUNT";
			case LIBMC_ERROR_INVALIDTOOLPATHSTREAMUUID: return "INVALIDTOOLPATHSTREAMUUID";
			case LIBMC_ERROR_MISSINGSECTIONHEIGHT: return "MISSINGSECTIONHEIGHT";
			case LIBMC_ERROR_INVALIDSECTIONHEIGHT: return "INVALIDSECTIONHEIGHT";
			case LIBMC_ERROR_MISSINGSECTIONWIDTH: return "MISSINGSECTIONWIDTH";
			case LIBMC_ERROR_INVALIDSECTIONWIDTH: return "INVALIDSECTIONWIDTH";
			case LIBMC_ERROR_TOOLPATHMETADATANOTFOUND: return "TOOLPATHMETADATANOTFOUND";
			case LIBMC_ERROR_BUILDITEMHASNOUUID: return "BUILDITEMHASNOUUID";
			case LIBMC_ERROR_OBJECTHASNOUUID: return "OBJECTHASNOUUID";
			case LIBMC_ERROR_COULDNOTPARSEEVENTPARAMETERS: return "COULDNOTPARSEEVENTPARAMETERS";
			case LIBMC_ERROR_INVALIDEVENTPARAMETERS: return "INVALIDEVENTPARAMETERS";
			case LIBMC_ERROR_INVALIDFORMVALUES: return "INVALIDFORMVALUES";
			case LIBMC_ERROR_FORMNAMEMISSING: return "FORMNAMEMISSING";
			case LIBMC_ERROR_FORMENTITYNAMEMISSING: return "FORMENTITYNAMEMISSING";
			case LIBMC_ERROR_FORMNOTFOUND: return "FORMNOTFOUND";
			case LIBMC_ERROR_FORMENTITYNOTFOUND: return "FORMENTITYNOTFOUND";
			case LIBMC_ERROR_DUPLICATEENTITYNAME: return "DUPLICATEENTITYNAME";
			case LIBMC_ERROR_COULDNOTFINDEVENTSENDERPAGE: return "COULDNOTFINDEVENTSENDERPAGE";
			case LIBMC_ERROR_COULDNOTFINDEVENTSENDER: return "COULDNOTFINDEVENTSENDER";
			case LIBMC_ERROR_DUPLICATEFORMNAME: return "DUPLICATEFORMNAME";
			case LIBMC_ERROR_EVENTNOTFOUND: return "EVENTNOTFOUND";
			case LIBMC_ERROR_MISSINGCOLORNAME: return "MISSINGCOLORNAME";
			case LIBMC_ERROR_MISSINGCOLORREDCHANNEL: return "MISSINGCOLORREDCHANNEL";
			case LIBMC_ERROR_MISSINGCOLORGREENCHANNEL: return "MISSINGCOLORGREENCHANNEL";
			case LIBMC_ERROR_MISSINGCOLORBLUECHANNEL: return "MISSINGCOLORBLUECHANNEL";
			case LIBMC_ERROR_INVALIDCOLORREDCHANNEL: return "INVALIDCOLORREDCHANNEL";
			case LIBMC_ERROR_INVALIDCOLORGREENCHANNEL: return "INVALIDCOLORGREENCHANNEL";
			case LIBMC_ERROR_INVALIDCOLORBLUECHANNEL: return "INVALIDCOLORBLUECHANNEL";
			case LIBMC_ERROR_MISSINGCOLUMNWIDTH: return "MISSINGCOLUMNWIDTH";
			case LIBMC_ERROR_INVALIDCOLUMNWIDTH: return "INVALIDCOLUMNWIDTH";
			case LIBMC_ERROR_MISSINGCOLUMNUNIT: return "MISSINGCOLUMNUNIT";
			case LIBMC_ERROR_MISSINGROWHEIGHT: return "MISSINGROWHEIGHT";
			case LIBMC_ERROR_INVALIDROWHEIGHT: return "INVALIDROWHEIGHT";
			case LIBMC_ERROR_MISSINGROWUNIT: return "MISSINGROWUNIT";
			case LIBMC_ERROR_MISSINGCOLUMNSTARTATTRIB: return "MISSINGCOLUMNSTARTATTRIB";
			case LIBMC_ERROR_MISSINGCOLUMNENDATTRIB: return "MISSINGCOLUMNENDATTRIB";
			case LIBMC_ERROR_MISSINGROWSTARTATTRIB: return "MISSINGROWSTARTATTRIB";
			case LIBMC_ERROR_MISSINGROWENDATTRIB: return "MISSINGROWENDATTRIB";
			case LIBMC_ERROR_INVALIDCOLUMNSTARTATTRIB: return "INVALIDCOLUMNSTARTATTRIB";
			case LIBMC_ERROR_INVALIDCOLUMNENDATTRIB: return "INVALIDCOLUMNENDATTRIB";
			case LIBMC_ERROR_INVALIDROWSTARTATTRIB: return "INVALIDROWSTARTATTRIB";
			case LIBMC_ERROR_INVALIDROWENDATTRIB: return "INVALIDROWENDATTRIB";
			case LIBMC_ERROR_INVALIDPARAMETERPATH: return "INVALIDPARAMETERPATH";
			case LIBMC_ERROR_INVALIDPARAMETERINSTANCE: return "INVALIDPARAMETERINSTANCE";
			case LIBMC_ERROR_INVALIDPARAMETERGROUP: return "INVALIDPARAMETERGROUP";
			case LIBMC_ERROR_INVALIDPARAMETERNAME: return "INVALIDPARAMETERNAME";
			case LIBMC_ERROR_INVALIDSTATEMACHINENAME: return "INVALIDSTATEMACHINENAME";
			case LIBMC_ERROR_INVALIDGRIDPOSITION: return "INVALIDGRIDPOSITION";
			case LIBMC_ERROR_INVALIDDIALOGNAME: return "INVALIDDIALOGNAME";
			case LIBMC_ERROR_DUPLICATEDIALOG: return "DUPLICATEDIALOG";
			case LIBMC_ERROR_DIALOGNOTFOUND: return "DIALOGNOTFOUND";
			case LIBMC_ERROR_COULDNOTHANDLEEVENT: return "COULDNOTHANDLEEVENT";
			case LIBMC_ERROR_INVALIDFORMPATH: return "INVALIDFORMPATH";
			case LIBMC_ERROR_MISSINGITEMNAME: return "MISSINGITEMNAME";
			case LIBMC_ERROR_INVALIDITEMPATH: return "INVALIDITEMPATH";
			case LIBMC_ERROR_INVALIDMODULEPATH: return "INVALIDMODULEPATH";
			case LIBMC_ERROR_BUILDLISTNAMEMISSING: return "BUILDLISTNAMEMISSING";
			case LIBMC_ERROR_EMPTYITEMPREFIX: return "EMPTYITEMPREFIX";
			case LIBMC_ERROR_INVALIDITEMPREFIX: return "INVALIDITEMPREFIX";
			case LIBMC_ERROR_EMPTYITEMNAME: return "EMPTYITEMNAME";
			case LIBMC_ERROR_EXPRESSIONVALUEGIVENTWICE: return "EXPRESSIONVALUEGIVENTWICE";
			case LIBMC_ERROR_INVALIDINTEGEREXPRESSION: return "INVALIDINTEGEREXPRESSION";
			case LIBMC_ERROR_INVALIDNUMBEREXPRESSION: return "INVALIDNUMBEREXPRESSION";
			case LIBMC_ERROR_INVALIDBOOLEANEXPRESSION: return "INVALIDBOOLEANEXPRESSION";
			case LIBMC_ERROR_INVALIDPERSISTENCYNAME: return "INVALIDPERSISTENCYNAME";
			case LIBMC_ERROR_ONLYVALUEDPARAMETERSCANBEPERSISTENT: return "ONLYVALUEDPARAMETERSCANBEPERSISTENT";
			case LIBMC_ERROR_PLATFORMINFORMATIONMISSING: return "PLATFORMINFORMATIONMISSING";
			case LIBMC_ERROR_INVALIDBUTTONDISTRIBUTION: return "INVALIDBUTTONDISTRIBUTION";
			case LIBMC_ERROR_EXPRESSIONVALUEMISSING: return "EXPRESSIONVALUEMISSING";
			case LIBMC_ERROR_INVALIDVIEWPORTCOORD: return "INVALIDVIEWPORTCOORD";
			case LIBMC_ERROR_VIEWPORTCOORDMISSING: return "VIEWPORTCOORDMISSING";
			case LIBMC_ERROR_MACHINEINSTANCENOTFOUND: return "MACHINEINSTANCENOTFOUND";
			case LIBMC_ERROR_COULDNOTGETTEMPPATHFROMWINDOWS: return "COULDNOTGETTEMPPATHFROMWINDOWS";
			case LIBMC_ERROR_DUPLICATEBUTTONNAME: return "DUPLICATEBUTTONNAME";
			case LIBMC_ERROR_SERVERCONFIGURATIONNOTLOADED: return "SERVERCONFIGURATIONNOTLOADED";
			case LIBMC_ERROR_COULDNOTPARSESERVERCONFIGURATION: return "COULDNOTPARSESERVERCONFIGURATION";
			case LIBMC_ERROR_MISSINGSERVERCONFIGURATIONNODE: return "MISSINGSERVERCONFIGURATIONNODE";
			case LIBMC_ERROR_COULDNOTFINDLIBRARYENTRY: return "COULDNOTFINDLIBRARYENTRY";
			case LIBMC_ERROR_INVALIDPORT: return "INVALIDPORT";
			case LIBMC_ERROR_MISSINGDATANODE: return "MISSINGDATANODE";
			case LIBMC_ERROR_MISSINGDATADIRECTORY: return "MISSINGDATADIRECTORY";
			case LIBMC_ERROR_DATADIRECTORYDOESNOTEXISTS: return "DATADIRECTORYDOESNOTEXISTS";
			case LIBMC_ERROR_INVALIDDATADIRECTORY: return "INVALIDDATADIRECTORY";
			case LIBMC_ERROR_INVALIDSQLITEDBPATH: return "INVALIDSQLITEDBPATH";
			case LIBMC_ERROR_INVALIDDATABASETYPE: return "INVALIDDATABASETYPE";
			case LIBMC_ERROR_DEFAULTPACKAGEMISSING: return "DEFAULTPACKAGEMISSING";
			case LIBMC_ERROR_DEFAULTPACKAGENAMEMISSING: return "DEFAULTPACKAGENAMEMISSING";
			case LIBMC_ERROR_COULDNOTPARSEPACKAGEXML: return "COULDNOTPARSEPACKAGEXML";
			case LIBMC_ERROR_MISSINGPACKAGENODE: return "MISSINGPACKAGENODE";
			case LIBMC_ERROR_MISSINGBUILDNODE: return "MISSINGBUILDNODE";
			case LIBMC_ERROR_MISSINGBUILDNAME: return "MISSINGBUILDNAME";
			case LIBMC_ERROR_MISSINGCONFIGURATIONNAME: return "MISSINGCONFIGURATIONNAME";
			case LIBMC_ERROR_MISSINGCORECLIENT: return "MISSINGCORECLIENT";
			case LIBMC_ERROR_MISSINGLIBRARYNAME: return "MISSINGLIBRARYNAME";
			case LIBMC_ERROR_MISSINGLIBRARYIMPORTNAME: return "MISSINGLIBRARYIMPORTNAME";
			case LIBMC_ERROR_DUPLICATELIBRARYNAME: return "DUPLICATELIBRARYNAME";
			case LIBMC_ERROR_INVALIDTRANSFORMINTERVAL: return "INVALIDTRANSFORMINTERVAL";
			case LIBMC_ERROR_INVALIDTRANSFORMCOORDINATE: return "INVALIDTRANSFORMCOORDINATE";
			case LIBMC_ERROR_SUCCESSSTATENOTFOUND: return "SUCCESSSTATENOTFOUND";
			case LIBMC_ERROR_DUPLICATESERVERPRIVATEKEY: return "DUPLICATESERVERPRIVATEKEY";
			case LIBMC_ERROR_DUPLICATESERVERCERTIFICATE: return "DUPLICATESERVERCERTIFICATE";
			case LIBMC_ERROR_INVALIDGITHASH: return "INVALIDGITHASH";
			case LIBMC_ERROR_COULDNOTPARSETESTDEFINITION: return "COULDNOTPARSETESTDEFINITION";
			case LIBMC_ERROR_MISSINGTESTDEFINITIONNODE: return "MISSINGTESTDEFINITIONNODE";
			case LIBMC_ERROR_AMBIGIOUSMAINNODE: return "AMBIGIOUSMAINNODE";
			case LIBMC_ERROR_MISSINGMAINNODE: return "MISSINGMAINNODE";
			case LIBMC_ERROR_MISSINGLIBRARIESNODE: return "MISSINGLIBRARIESNODE";
			case LIBMC_ERROR_MISSINGLIBRARYDLLFILENAME: return "MISSINGLIBRARYDLLFILENAME";
			case LIBMC_ERROR_MISSINGTESTDESCRIPTION: return "MISSINGTESTDESCRIPTION";
			case LIBMC_ERROR_MISSINGTESTINSTANCENAME: return "MISSINGTESTINSTANCENAME";
			case LIBMC_ERROR_TESTDEFINITIONHASNOINSTANCES: return "TESTDEFINITIONHASNOINSTANCES";
			case LIBMC_ERROR_INVALIDPACKAGEENTRYNAME: return "INVALIDPACKAGEENTRYNAME";
			case LIBMC_ERROR_INVALIDPACKAGEENTRYEXTENSION: return "INVALIDPACKAGEENTRYEXTENSION";
			case LIBMC_ERROR_INVALIDPACKAGEENTRYFILENAME: return "INVALIDPACKAGEENTRYFILENAME";
			case LIBMC_ERROR_INVALIDEXPRESSIONVALUE: return "INVALIDEXPRESSIONVALUE";
			case LIBMC_ERROR_INVALIDBUTTONNAME: return "INVALIDBUTTONNAME";
			case LIBMC_ERROR_RESOURCEENTRYISNOUTF8STRING: return "RESOURCEENTRYISNOUTF8STRING";
			case LIBMC_ERROR_AMBIGUOUSDRIVERCONFIGURATION: return "AMBIGUOUSDRIVERCONFIGURATION";
			case LIBMC_ERROR_COULDNOTCREATEDRIVER: return "COULDNOTCREATEDRIVER";
			case LIBMC_ERROR_EMPTYGROUPNAMEBUTPARAMETERGIVEN: return "EMPTYGROUPNAMEBUTPARAMETERGIVEN";
			case LIBMC_ERROR_INVALIDDEFAULTXMLNAMESPACE: return "INVALIDDEFAULTXMLNAMESPACE";
			case LIBMC_ERROR_INVALIDXMLROOTNODENAME: return "INVALIDXMLROOTNODENAME";
			case LIBMC_ERROR_COULDNOTPARSEXMLSTRING: return "COULDNOTPARSEXMLSTRING";
			case LIBMC_ERROR_COULDNOTPARSEXMLDATA: return "COULDNOTPARSEXMLDATA";
			case LIBMC_ERROR_XMLDOESNOTCONTAINROOTNODE: return "XMLDOESNOTCONTAINROOTNODE";
			case LIBMC_ERROR_XMLCONTAINSAMBIGOUSROOTNODES: return "XMLCONTAINSAMBIGOUSROOTNODES";
			case LIBMC_ERROR_XMLDOESNOTCONTAINNAMESPACE: return "XMLDOESNOTCONTAINNAMESPACE";
			case LIBMC_ERROR_INVALIDXMLDATA: return "INVALIDXMLDATA";
			case LIBMC_ERROR_INVALIDXMLROOTNODEINSTANCE: return "INVALIDXMLROOTNODEINSTANCE";
			case LIBMC_ERROR_XMLNAMESPACEPREFIXALREADYREGISTERED: return "XMLNAMESPACEPREFIXALREADYREGISTERED";
			case LIBMC_ERROR_XMLNAMESPACEALREADYREGISTERED: return "XMLNAMESPACEALREADYREGISTERED";
			case LIBMC_ERROR_XMLNAMESPACENOTFOUND: return "XMLNAMESPACENOTFOUND";
			case LIBMC_ERROR_INVALIDNAMESPACENAME: return "INVALIDNAMESPACENAME";
			case LIBMC_ERROR_INVALIDNAMESPACEPREFIX: return "INVALIDNAMESPACEPREFIX";
			case LIBMC_ERROR_INVALIDNAMESPACEINDEX: return "INVALIDNAMESPACEINDEX";
			case LIBMC_ERROR_INVALIDATTRIBUTEINDEX: return "INVALIDATTRIBUTEINDEX";
			case LIBMC_ERROR_PROFILEVALUENOTFOUND: return "PROFILEVALUENOTFOUND";
			case LIBMC_ERROR_INVALIDXMLNODENAME: return "INVALIDXMLNODENAME";
			case LIBMC_ERROR_INVALIDXMLNAMESPACE: return "INVALIDXMLNAMESPACE";
			case LIBMC_ERROR_COULDNOTFINDATTRIBUTE: return "COULDNOTFINDATTRIBUTE";
			case LIBMC_ERROR_DUPLICATEATTRIBUTE: return "DUPLICATEATTRIBUTE";
			case LIBMC_ERROR_INTERNALATTRIBUTEERROR: return "INTERNALATTRIBUTEERROR";
			case LIBMC_ERROR_XMLNODECHILDNOTFOUND: return "XMLNODECHILDNOTFOUND";
			case LIBMC_ERROR_INVALIDXMLNODEINDEX: return "INVALIDXMLNODEINDEX";
			case LIBMC_ERROR_INTERNALNODEERROR: return "INTERNALNODEERROR";
			case LIBMC_ERROR_XMLNODENOTFOUNDINLIST: return "XMLNODENOTFOUNDINLIST";
			case LIBMC_ERROR_COULDNOTFINDXMLNAMESPACE: return "COULDNOTFINDXMLNAMESPACE";
			case LIBMC_ERROR_INVALIDCOMPONENTNAME: return "INVALIDCOMPONENTNAME";
			case LIBMC_ERROR_MISSINGCOMPONENTNAME: return "MISSINGCOMPONENTNAME";
			case LIBMC_ERROR_CUSTOMPAGEPROPERTYNAMEMISSING: return "CUSTOMPAGEPROPERTYNAMEMISSING";
			case LIBMC_ERROR_CUSTOMPAGEPROPERTYTYPEMISSING: return "CUSTOMPAGEPROPERTYTYPEMISSING";
			case LIBMC_ERROR_EMTPYEVENTNAME: return "EMTPYEVENTNAME";
			case LIBMC_ERROR_INVALIDEVENTNAME: return "INVALIDEVENTNAME";
			case LIBMC_ERROR_INVALIDEVENTPATH: return "INVALIDEVENTPATH";
			case LIBMC_ERROR_CUSTOMPAGEVENTNAMEMISSING: return "CUSTOMPAGEVENTNAMEMISSING";
			case LIBMC_ERROR_INVALIDCUSTOMPAGEVENTNAME: return "INVALIDCUSTOMPAGEVENTNAME";
			case LIBMC_ERROR_DUPLICATECUSTOMPAGEVENTNAME: return "DUPLICATECUSTOMPAGEVENTNAME";
			case LIBMC_ERROR_INVALIDEVENTPARAMETERNAME: return "INVALIDEVENTPARAMETERNAME";
			case LIBMC_ERROR_INVALIDMETADATAINDEX: return "INVALIDMETADATAINDEX";
			case LIBMC_ERROR_METADATAISNOTUNIQUE: return "METADATAISNOTUNIQUE";
			case LIBMC_ERROR_METADATANOTFOUND: return "METADATANOTFOUND";
			case LIBMC_ERROR_TIMESTAMPISNOTINCREMENTING: return "TIMESTAMPISNOTINCREMENTING";
			case LIBMC_ERROR_INVALIDTIMESTAMPINTERVAL: return "INVALIDTIMESTAMPINTERVAL";
			case LIBMC_ERROR_TIMESTREAMISEMPTY: return "TIMESTREAMISEMPTY";
			case LIBMC_ERROR_INVALIDTOOLPATHATTRIBUTETYPE: return "INVALIDTOOLPATHATTRIBUTETYPE";
			case LIBMC_ERROR_INVALIDSEGMENTINDEX: return "INVALIDSEGMENTINDEX";
			case LIBMC_ERROR_INVALIDTOOLPATHATTRIBUTEID: return "INVALIDTOOLPATHATTRIBUTEID";
			case LIBMC_ERROR_AMBIGUOUSSEGMENTATTRIBUTETYPE: return "AMBIGUOUSSEGMENTATTRIBUTETYPE";
			case LIBMC_ERROR_XMLNODEHASCHILDREN: return "XMLNODEHASCHILDREN";
			case LIBMC_ERROR_XMLNODEHASTEXTCONTENT: return "XMLNODEHASTEXTCONTENT";
			case LIBMC_ERROR_STRINGHANDLERNOTAVAILABLE: return "STRINGHANDLERNOTAVAILABLE";
			case LIBMC_ERROR_DUPLICATEROLEPERMISSION: return "DUPLICATEROLEPERMISSION";
			case LIBMC_ERROR_EMPTYACCESSROLEIDENTIFIER: return "EMPTYACCESSROLEIDENTIFIER";
			case LIBMC_ERROR_INVALIDACCESSROLEIDENTIFIER: return "INVALIDACCESSROLEIDENTIFIER";
			case LIBMC_ERROR_EMPTYACCESSROLEDISPLAYNAME: return "EMPTYACCESSROLEDISPLAYNAME";
			case LIBMC_ERROR_EMPTYACCESSPERMISSIONIDENTIFIER: return "EMPTYACCESSPERMISSIONIDENTIFIER";
			case LIBMC_ERROR_INVALIDACCESSPERMISSIONIDENTIFIER: return "INVALIDACCESSPERMISSIONIDENTIFIER";
			case LIBMC_ERROR_EMPTYACCESSPERMISSIONDISPLAYNAME: return "EMPTYACCESSPERMISSIONDISPLAYNAME";
			case LIBMC_ERROR_EMPTYSTRINGRESOURCENAME: return "EMPTYSTRINGRESOURCENAME";
			case LIBMC_ERROR_DUPLICATESTRINGRESOURCENAME: return "DUPLICATESTRINGRESOURCENAME";
			case LIBMC_ERROR_INVALIDSTRINGRESOURCENAMEIDENTIFIER: return "INVALIDSTRINGRESOURCENAMEIDENTIFIER";
			case LIBMC_ERROR_STRINGRESOURCENOTFOUND: return "STRINGRESOURCENOTFOUND";
			case LIBMC_ERROR_LANGUAGEIDNOTFOUND: return "LANGUAGEIDNOTFOUND";
			case LIBMC_ERROR_DUPLICATEPERMISSIONIDENTIFIER: return "DUPLICATEPERMISSIONIDENTIFIER";
			case LIBMC_ERROR_DUPLICATEROLEIDENTIFIER: return "DUPLICATEROLEIDENTIFIER";
			case LIBMC_ERROR_PERMISSIONNOTFOUND: return "PERMISSIONNOTFOUND";
			case LIBMC_ERROR_ROLENOTFOUND: return "ROLENOTFOUND";
			case LIBMC_ERROR_MISSINGACCESSCONTROLPERMISSIONS: return "MISSINGACCESSCONTROLPERMISSIONS";
			case LIBMC_ERROR_MISSINGACCESSCONTROLROLES: return "MISSINGACCESSCONTROLROLES";
			case LIBMC_ERROR_MISSINGACCESSCONTROLROLEPERMISSIONS: return "MISSINGACCESSCONTROLROLEPERMISSIONS";
			case LIBMC_ERROR_MISSINGROLEPERMISSIONIDENTIFIER: return "MISSINGROLEPERMISSIONIDENTIFIER";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDBUFFER: return "INVALIDDISCRETEFIELDBUFFER";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDFILESIGN: return "INVALIDDISCRETEFIELDFILESIGN";
			case LIBMC_ERROR_INCOMPATIBLEDISCRETEFIELDFILEVERSION: return "INCOMPATIBLEDISCRETEFIELDFILEVERSION";
			case LIBMC_ERROR_TOONEWDISCRETEFIELDFILEVERSION: return "TOONEWDISCRETEFIELDFILEVERSION";
			case LIBMC_ERROR_TOONEWDISCRETEFIELDSTREAMTYPE: return "TOONEWDISCRETEFIELDSTREAMTYPE";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDDATAOFFSET: return "INVALIDDISCRETEFIELDDATAOFFSET";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDSTREAMSIZE: return "INVALIDDISCRETEFIELDSTREAMSIZE";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDINTERNALDATA: return "INVALIDDISCRETEFIELDINTERNALDATA";
			case LIBMC_ERROR_DEFAULTROLEHASNOTBEENSET: return "DEFAULTROLEHASNOTBEENSET";
			case LIBMC_ERROR_EMPTYROLEIDENTIFIER: return "EMPTYROLEIDENTIFIER";
			case LIBMC_ERROR_EMPTYPERMISSIONIDENTIFIER: return "EMPTYPERMISSIONIDENTIFIER";
			case LIBMC_ERROR_USERHASUNKNOWNROLE: return "USERHASUNKNOWNROLE";
			case LIBMC_ERROR_MISSINGDEFAULTACCESSROLE: return "MISSINGDEFAULTACCESSROLE";
			case LIBMC_ERROR_FIXEDFLOATBUFFEROVERRUN: return "FIXEDFLOATBUFFEROVERRUN";
			case LIBMC_ERROR_MESHENTITYNOTLOADED: return "MESHENTITYNOTLOADED";
			case LIBMC_ERROR_MESHENTITYALREADYLOADED: return "MESHENTITYALREADYLOADED";
			case LIBMC_ERROR_INVALIDMESHFACEID: return "INVALIDMESHFACEID";
			case LIBMC_ERROR_MESH3MFRESOURCEISEMPTY: return "MESH3MFRESOURCEISEMPTY";
			case LIBMC_ERROR_INVALIDMESHEDGEID: return "INVALIDMESHEDGEID";
			case LIBMC_ERROR_INVALIDMESHNODEID: return "INVALIDMESHNODEID";
			case LIBMC_ERROR_INVALIDGLSCENEMODELNAME: return "INVALIDGLSCENEMODELNAME";
			case LIBMC_ERROR_INVALIDGLSCENEINSTANCENAME: return "INVALIDGLSCENEINSTANCENAME";
			case LIBMC_ERROR_EMPTYGLMODELNAME: return "EMPTYGLMODELNAME";
			case LIBMC_ERROR_INVALIDGLMODELNAME: return "INVALIDGLMODELNAME";
			case LIBMC_ERROR_DUPLICATEGLMODELNAME: return "DUPLICATEGLMODELNAME";
			case LIBMC_ERROR_MODELGLRESOURCENOTFOUND: return "MODELGLRESOURCENOTFOUND";
			case LIBMC_ERROR_EMPTYGLINSTANCENAME: return "EMPTYGLINSTANCENAME";
			case LIBMC_ERROR_INVALIDGLINSTANCENAME: return "INVALIDGLINSTANCENAME";
			case LIBMC_ERROR_EMPTYGLINSTANCEMODEL: return "EMPTYGLINSTANCEMODEL";
			case LIBMC_ERROR_INVALIDGLINSTANCEMODEL: return "INVALIDGLINSTANCEMODEL";
			case LIBMC_ERROR_GLINSTANCEMODELNOTFOUND: return "GLINSTANCEMODELNOTFOUND";
			case LIBMC_ERROR_DUPLICATEGLINSTANCENAME: return "DUPLICATEGLINSTANCENAME";
			case LIBMC_ERROR_INVALIDJOURNALSTREAMCAPACITY: return "INVALIDJOURNALSTREAMCAPACITY";
			case LIBMC_ERROR_INVALIDUIFORMAT: return "INVALIDUIFORMAT";
			case LIBMC_ERROR_INVALIDJOURNALTIMESTAMP: return "INVALIDJOURNALTIMESTAMP";
			case LIBMC_ERROR_CHUNKTIMESTREAMNOTCONTINUOUS: return "CHUNKTIMESTREAMNOTCONTINUOUS";
			case LIBMC_ERROR_JOURNALVARIABLENOTFOUND: return "JOURNALVARIABLENOTFOUND";
			case LIBMC_ERROR_INVALIDJOURNALSTREAMQUERY: return "INVALIDJOURNALSTREAMQUERY";
			case LIBMC_ERROR_INVALIDJOURNALCOMPUTEDATA: return "INVALIDJOURNALCOMPUTEDATA";
			case LIBMC_ERROR_INVALIDJOURNALCOMPUTEINTERVAL: return "INVALIDJOURNALCOMPUTEINTERVAL";
			case LIBMC_ERROR_DATASERIESNOTFOUND: return "DATASERIESNOTFOUND";
			case LIBMC_ERROR_DATASERIESISEMPTY: return "DATASERIESISEMPTY";
		}
		return "UNKNOWN";
	}

	const char* getErrorDescription() const noexcept
	{
		switch(getErrorCode()) {
			case LIBMC_SUCCESS: return "success";
			case LIBMC_ERROR_NOTIMPLEMENTED: return "functionality not implemented";
			case LIBMC_ERROR_INVALIDPARAM: return "an invalid parameter was passed";
			case LIBMC_ERROR_INVALIDCAST: return "a type cast failed";
			case LIBMC_ERROR_BUFFERTOOSMALL: return "a provided buffer is too small";
			case LIBMC_ERROR_GENERICEXCEPTION: return "a generic exception occurred";
			case LIBMC_ERROR_COULDNOTLOADLIBRARY: return "the library could not be loaded";
			case LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT: return "a required exported symbol could not be found in the library";
			case LIBMC_ERROR_INCOMPATIBLEBINARYVERSION: return "the version of the binary interface does not match the bindings interface";
			case LIBMC_ERROR_COULDNOTPARSECONFIGURATION: return "could not parse configuration";
			case LIBMC_ERROR_DUPLICATESTATENAME: return "duplicate state name";
			case LIBMC_ERROR_STATENOTFOUND: return "state not found";
			case LIBMC_ERROR_DUPLICATEOUTSTATE: return "duplicate out state";
			case LIBMC_ERROR_MISSINGMACHINEDEFINITION: return "missing machine definition";
			case LIBMC_ERROR_MISSINGINSTANCENAME: return "missing instance name";
			case LIBMC_ERROR_DUPLICATEMACHINEINSTANCE: return "duplicate machine instance";
			case LIBMC_ERROR_MISSINGXMLSCHEMA: return "missing XML schema";
			case LIBMC_ERROR_INVALIDXMLSCHEMA: return "invalid XML schema";
			case LIBMC_ERROR_MISSINGSTATENAME: return "missing state name";
			case LIBMC_ERROR_MISSINGOUTSTATETARGET: return "missing outstate target";
			case LIBMC_ERROR_INVALIDOUTSTATETARGET: return "invalid outstate target";
			case LIBMC_ERROR_NOINITSTATE: return "no init state";
			case LIBMC_ERROR_NOFAILEDSTATE: return "no failed state";
			case LIBMC_ERROR_INITSTATENOTFOUND: return "init state not found";
			case LIBMC_ERROR_FAILEDSTATENOTFOUND: return "failed state not found";
			case LIBMC_ERROR_MISSINGINITSTATE: return "missing init state";
			case LIBMC_ERROR_MISSINGFAILEDSTATE: return "missing failed state";
			case LIBMC_ERROR_MISSINGPLUGINNAME: return "missing plugin name";
			case LIBMC_ERROR_EMPTYINITSTATE: return "empty init state";
			case LIBMC_ERROR_EMPTYFAILEDSTATE: return "empty failed state";
			case LIBMC_ERROR_EMPTYPLUGINNAME: return "empty plugin name";
			case LIBMC_ERROR_COULDNOTCREATESTATEFACTORY: return "could not create state factory";
			case LIBMC_ERROR_INVALIDSTATENAME: return "invalid state name";
			case LIBMC_ERROR_COULDNOTCREATESTATE: return "could not create state";
			case LIBMC_ERROR_COULDNOTINITIALIZEFACTORY: return "could not initialize factory";
			case LIBMC_ERROR_COULDNOTFINALIZEFACTORY: return "could not finalize factory";
			case LIBMC_ERROR_COULDNOTLOADPLUGIN: return "could not load plugin";
			case LIBMC_ERROR_NOCURRENTSTATE: return "no current state";
			case LIBMC_ERROR_NOPLUGINSTATE: return "no plugin state";
			case LIBMC_ERROR_COULDNOTEXECUTEPLUGIN: return "could not execute plugin";
			case LIBMC_ERROR_TOOMANYMACHINEINSTANCES: return "too many machine instances";
			case LIBMC_ERROR_INVALIDINDEX: return "invalid index";
			case LIBMC_ERROR_NOOUTSTATEGIVEN: return "no new outstate has been given";
			case LIBMC_ERROR_INVALIDOUTSTATEGIVEN: return "invalid outstate has been given";
			case LIBMC_ERROR_INVALIDREPEATDELAY: return "invalid repeat delay";
			case LIBMC_ERROR_INVALIDEXECUTIONDELAY: return "invalid execution delay";
			case LIBMC_ERROR_MISSINGREPEATDELAY: return "missing repeat delay";
			case LIBMC_ERROR_THREADISRUNNING: return "thread is running";
			case LIBMC_ERROR_THREADISNOTRUNNING: return "thread is not running";
			case LIBMC_ERROR_DUPLICATESIGNAL: return "duplicate signal";
			case LIBMC_ERROR_INVALIDSIGNALNAME: return "invalid signal name";
			case LIBMC_ERROR_MISSINGSIGNALNAME: return "missing signal name";
			case LIBMC_ERROR_MISSINGSERVERNODE: return "missing server node";
			case LIBMC_ERROR_MISSINGHOSTNAME: return "missing host name";
			case LIBMC_ERROR_MISSINGPORT: return "missing port";
			case LIBMC_ERROR_UUIDGENERATIONFAILED: return "uuid generation failed";
			case LIBMC_ERROR_INVALIDBUFFERSIZE: return "invalid buffer size";
			case LIBMC_ERROR_COULDNOTCONVERTTOUTF8: return "could not convert to utf8";
			case LIBMC_ERROR_NOCOLUMNAVAILABLE: return "no column available";
			case LIBMC_ERROR_INVALIDTEXTCOLUMN: return "invalid text column";
			case LIBMC_ERROR_INVALIDCOLUMNTYPE: return "invalid column type";
			case LIBMC_ERROR_TOOMANYREQUESTEDLOGS: return "too many requested logs";
			case LIBMC_ERROR_MISSINGINSTANCEDESCRIPTION: return "missing instance description";
			case LIBMC_ERROR_DUPLICATEPARAMETERGROUPNAME: return "duplicate parameter group name";
			case LIBMC_ERROR_MISSINGPARAMETERGROUPNAME: return "missing parameter group name";
			case LIBMC_ERROR_EMPTYPARAMETERGROUPNAME: return "empty parameter group name";
			case LIBMC_ERROR_MISSINGPARAMETERGROUPDESCRIPTION: return "missing parameter group description";
			case LIBMC_ERROR_EMPTYPARAMETERGROUPDESCRIPTION: return "empty parameter group description";
			case LIBMC_ERROR_TOOMANYPARAMETERS: return "too many parameters";
			case LIBMC_ERROR_TOOMANYPARAMETERGROUPS: return "too many parameter groups";
			case LIBMC_ERROR_DUPLICATEPARAMETERNAME: return "duplicate parameter name";
			case LIBMC_ERROR_MISSINGPARAMETERNAME: return "missing parameter name";
			case LIBMC_ERROR_EMPTYPARAMETERNAME: return "empty parameter name";
			case LIBMC_ERROR_MISSINGPARAMETERDESCRIPTION: return "missing parameter description";
			case LIBMC_ERROR_EMPTYPARAMETERDESCRIPTION: return "empty parameter description";
			case LIBMC_ERROR_PARAMETERNOTFOUND: return "parameter not found";
			case LIBMC_ERROR_MISSINGPARAMETERDEFAULTVALUE: return "missing parameter default value";
			case LIBMC_ERROR_MISSINGDATACONFIGNODE: return "missing data config node";
			case LIBMC_ERROR_MISSINGDIRECTORY: return "missing directory";
			case LIBMC_ERROR_MISSINGDATABASETYPE: return "missing database type";
			case LIBMC_ERROR_MISSINGSQLITEINFO: return "missing sqlite info";
			case LIBMC_ERROR_UNKNOWNDATABASETYPE: return "unknown database type";
			case LIBMC_ERROR_STORAGENOTINITIALISED: return "storage not initialised";
			case LIBMC_ERROR_COULDNOTCONVERTTOUTF16: return "could not convert to utf 16";
			case LIBMC_ERROR_COULDNOTCREATEFILE: return "could not create file";
			case LIBMC_ERROR_COULDNOTSEEKSTREAM: return "could not seek stream";
			case LIBMC_ERROR_COULDNOTGETSTREAMPOSITION: return "could not get stream position";
			case LIBMC_ERROR_COULDNOTWRITESTREAM: return "could not write stream";
			case LIBMC_ERROR_INVALIDDATABASEMIGRATION: return "invalid database migration";
			case LIBMC_ERROR_INTERNALERROR: return "internal error";
			case LIBMC_ERROR_COULDNOTSTORECONTENTSTREAM: return "could not store content stream";
			case LIBMC_ERROR_DATABASENOTINITIALISED: return "database not initialised";
			case LIBMC_ERROR_PARAMETERGROUPNOTFOUND: return "parameter group not found";
			case LIBMC_ERROR_SIGNALNOTFOUND: return "signal not found";
			case LIBMC_ERROR_STATEMACHINENOTFOUND: return "state machine not found.";
			case LIBMC_ERROR_MISSINGPARAMETERTYPE: return "missing parameter type.";
			case LIBMC_ERROR_INVALIDPARAMETERTYPE: return "invalid parameter type.";
			case LIBMC_ERROR_COULDNOTPARSEJSON: return "could not parse json.";
			case LIBMC_ERROR_INVALIDJSONFORMAT: return "invalid json format.";
			case LIBMC_ERROR_URLNOTFOUND: return "url not found.";
			case LIBMC_ERROR_GENERICBADREQUEST: return "generic bad request.";
			case LIBMC_ERROR_SQLITE_ERROR: return "SQLite: Generic Error";
			case LIBMC_ERROR_SQLITE_INTERNAL: return "SQLite: Internal logic error in SQLite";
			case LIBMC_ERROR_SQLITE_PERM: return "SQLite: Access permission denied";
			case LIBMC_ERROR_SQLITE_ABORT: return "SQLite: Callback routine requested an abort";
			case LIBMC_ERROR_SQLITE_BUSY: return "SQLite: The database file is locked";
			case LIBMC_ERROR_SQLITE_LOCKED: return "SQLite: A table in the database is locked";
			case LIBMC_ERROR_SQLITE_NOMEM: return "SQLite: A malloc failed";
			case LIBMC_ERROR_SQLITE_READONLY: return "SQLite: Attempt to write a readonly database";
			case LIBMC_ERROR_SQLITE_INTERRUPT: return "SQLite: Operation terminated by sqlite3_interrupt";
			case LIBMC_ERROR_SQLITE_IOERR: return "SQLite: Some kind of disk I/O error occurred";
			case LIBMC_ERROR_SQLITE_CORRUPT: return "SQLite: The database disk image is malformed";
			case LIBMC_ERROR_SQLITE_NOTFOUND: return "SQLite: Unknown opcode in sqlite3_file_control";
			case LIBMC_ERROR_SQLITE_FULL: return "SQLite: Insertion failed because database is full";
			case LIBMC_ERROR_SQLITE_CANTOPEN: return "SQLite: Unable to open the database file";
			case LIBMC_ERROR_SQLITE_PROTOCOL: return "SQLite: Database lock protocol error";
			case LIBMC_ERROR_SQLITE_SCHEMA: return "SQLite: The database schema changed";
			case LIBMC_ERROR_SQLITE_TOOBIG: return "SQLite: String or BLOB exceeds size limit";
			case LIBMC_ERROR_SQLITE_CONSTRAINT: return "SQLite: Abort due to constraint violation";
			case LIBMC_ERROR_SQLITE_MISMATCH: return "SQLite: Data type mismatch";
			case LIBMC_ERROR_SQLITE_MISUSE: return "SQLite: Library used incorrectly";
			case LIBMC_ERROR_SQLITE_NOLFS: return "SQLite: Uses OS features not supported on host";
			case LIBMC_ERROR_SQLITE_AUTH: return "SQLite: Authorization denied";
			case LIBMC_ERROR_SQLITE_RANGE: return "SQLite: 2nd parameter to sqlite3_bind out of range";
			case LIBMC_ERROR_SQLITE_NOTADB: return "SQLite: File opened that is not a database file";
			case LIBMC_ERROR_SQLITE_NOTICE: return "SQLite: Notifications from sqlite3_log";
			case LIBMC_ERROR_SQLITE_WARNING: return "SQLite: Warnings from sqlite3_log";
			case LIBMC_ERROR_SQLITE_OTHER: return "SQLite: Other Error";
			case LIBMC_ERROR_SQLITE_TOOMANYRESULTROWS: return "too many result rows";
			case LIBMC_ERROR_COULDNOTREADZIPFILE: return "Could not read ZIP file";
			case LIBMC_ERROR_COULDNOTOPENZIPFILE: return "Could not open ZIP file";
			case LIBMC_ERROR_COULDNOTGETZIPENTRIES: return "Could not get ZIP file entries";
			case LIBMC_ERROR_ZIPENTRYNOTFOUND: return "ZIP Entry not found";
			case LIBMC_ERROR_COULDNOTSTATZIPENTRY: return "Could not stat ZIP entry";
			case LIBMC_ERROR_COULDNOTOPENZIPENTRY: return "Could not open ZIP entry";
			case LIBMC_ERROR_COULDNOTREADZIPSTREAM: return "Could not read ZIP stream";
			case LIBMC_ERROR_COULDNOTREADFULLZIPDATA: return "Could not read full zip data";
			case LIBMC_ERROR_COULDNOTFINDRESOURCEINDEX: return "Could not find resource index.";
			case LIBMC_ERROR_COULDNOTPARSERESOURCEINDEX: return "Could not parse resource index.";
			case LIBMC_ERROR_EMPTYRESOURCEINDEX: return "Empty resource index.";
			case LIBMC_ERROR_MISSINGRESOURCEINDEX: return "Missing resource index.";
			case LIBMC_ERROR_MISSINGRESOURCENAME: return "Missing resource name.";
			case LIBMC_ERROR_MISSINGRESOURCEFILENAME: return "Missing resource filename.";
			case LIBMC_ERROR_MISSINGRESOURCESIZE: return "Missing resource size.";
			case LIBMC_ERROR_MISSINGRESOURCECONTENTTYPE: return "Missing resource content type.";
			case LIBMC_ERROR_DRIVERALREADYREGISTERED: return "Driver already registered.";
			case LIBMC_ERROR_DRIVERNOTFOUND: return "Driver not found.";
			case LIBMC_ERROR_MISSINGDRIVERNAME: return "Missing driver name.";
			case LIBMC_ERROR_MISSINGDRIVERTYPE: return "Missing driver type.";
			case LIBMC_ERROR_MISSINGDRIVERLIBRARY: return "Missing driver library.";
			case LIBMC_ERROR_DRIVERALREADYRESERVED: return "Driver has already been reserved by an instance.";
			case LIBMC_ERROR_LIBRARYPATHNOTFOUND: return "Library path not found.";
			case LIBMC_ERROR_TOOLPATHENTITYNOTLOADED: return "Toolpath entity not loaded";
			case LIBMC_ERROR_TOOLPATHENTITYREFERENCEERROR: return "Toolpath entity reference error";
			case LIBMC_ERROR_TOOLPATHENTITYINVALIDFILE: return "Toolpath entity is invalid";
			case LIBMC_ERROR_NO3MFLIBRARY: return "No 3MF Library specified";
			case LIBMC_ERROR_INVALIDPOINTCOUNT: return "Invalid point count";
			case LIBMC_ERROR_DUPLICATEJOBUUID: return "Duplicate job uuid";
			case LIBMC_ERROR_INVALIDJOBSTATUS: return "Invalid job status";
			case LIBMC_ERROR_INVALIDSTREAMCONTEXT: return "Invalid stream context";
			case LIBMC_ERROR_JOBUUIDNOTFOUND: return "Job uuid not found";
			case LIBMC_ERROR_INVALIDJOBNAME: return "Invalid job name";
			case LIBMC_ERROR_INVALIDJOBTIMESTAMP: return "Invalid job timestamp";
			case LIBMC_ERROR_INVALIDUSERID: return "Invalid job name";
			case LIBMC_ERROR_INVALIDSTORAGECALLBACKSIGNATURE: return "Invalid storage callback signature";
			case LIBMC_ERROR_INVALIDSTORAGECALLBACKSTREAM: return "Invalid storage callback stream";
			case LIBMC_ERROR_INVALIDSTORAGEPATH: return "Invalid storage path";
			case LIBMC_ERROR_STORAGESTREAMNOTFOUND: return "Storage Stream not found";
			case LIBMC_ERROR_DUPLICATESTORAGESTREAM: return "Duplicate Storage Stream";
			case LIBMC_ERROR_INVALIDPARTIALUPLOAD: return "Invalid Partial Upload";
			case LIBMC_ERROR_PARTIALUPLOADNOTFINISHED: return "Partial Upload not finished";
			case LIBMC_ERROR_APIREQUESTNOTHANDLED: return "API Request not handled";
			case LIBMC_ERROR_APIREQUESTALREADYHANDLED: return "API Request already handled";
			case LIBMC_ERROR_INVALIDAPIREQUESTTYPE: return "Invalid API Request type";
			case LIBMC_ERROR_INVALIDUPLOADSTREAM: return "Invalid Upload Stream";
			case LIBMC_ERROR_COULDNOTPARSEJSONREQUEST: return "Could not parse JSON request";
			case LIBMC_ERROR_INVALIDCONTEXTUUID: return "Invalid Context UUID";
			case LIBMC_ERROR_INVALIDUPLOADNAME: return "Invalid Upload Name";
			case LIBMC_ERROR_INVALIDMIMETYPE: return "Invalid Mime Type";
			case LIBMC_ERROR_INVALIDSTREAMSIZE: return "Invalid Stream Size";
			case LIBMC_ERROR_INVALIDSHA256SUM: return "Invalid SHA256 Sum";
			case LIBMC_ERROR_INVALIDSTREAMUUID: return "Invalid Stream UUID";
			case LIBMC_ERROR_INVALIDFIELDNAME: return "Invalid field name";
			case LIBMC_ERROR_UPLOADSIZEMISMATCH: return "Upload size mismatch";
			case LIBMC_ERROR_CONTENTTYPENOTACCEPTED: return "Content type not accepted";
			case LIBMC_ERROR_NOCURRENTUPLOAD: return "No current upload";
			case LIBMC_ERROR_UPLOADCHECKSUMMISMATCH: return "Upload checksum mismatch";
			case LIBMC_ERROR_INVALIDSTORAGESTREAMSTATUS: return "Invalid storage stream status";
			case LIBMC_ERROR_CONTEXTUUIDNOTACCEPTED: return "Context uuid not accepted";
			case LIBMC_ERROR_INVALIDBUILDUUID: return "Invalid build uuid";
			case LIBMC_ERROR_MISSINGTHREADCOUNT: return "Missing thread count";
			case LIBMC_ERROR_INVALIDTHREADCOUNT: return "Invalid thread count";
			case LIBMC_ERROR_COULDNOTUPDATEBUILDSTATUS: return "Could not update build status";
			case LIBMC_ERROR_INVALIDITERATOR: return "Invalid iterator";
			case LIBMC_ERROR_INVALIDDATATYPE: return "Invalid data type";
			case LIBMC_ERROR_COULDNOTSENDSIGNAL: return "Could not send signal";
			case LIBMC_ERROR_MISSINGSIGNALPARAMETER: return "Missing signal parameter";
			case LIBMC_ERROR_NOUSERINTERFACEDEFINITION: return "No user interface definition";
			case LIBMC_ERROR_MISSINGAPPNAME: return "Missing app name";
			case LIBMC_ERROR_MISSINGCOPYRIGHT: return "Missing copyright";
			case LIBMC_ERROR_MISSINGMAINPAGE: return "Missing main page";
			case LIBMC_ERROR_MISSINGMENUITEMID: return "Missing menu item id";
			case LIBMC_ERROR_MISSINGMENUITEMICON: return "Missing menu item icon";
			case LIBMC_ERROR_MISSINGMENUITEMCAPTION: return "Missing menu item caption";
			case LIBMC_ERROR_MISSINGTARGETPAGE: return "Missing menu item target page";
			case LIBMC_ERROR_MISSINGMENUNODE: return "Missing menu node";
			case LIBMC_ERROR_MISSINGTOOLBARNODE: return "Missing toolbar node";
			case LIBMC_ERROR_MISSINGTOOLBARITEMID: return "Missing toolbar item id";
			case LIBMC_ERROR_MISSINGTOOLBARITEMICON: return "Missing toolbar item icon";
			case LIBMC_ERROR_MISSINGTOOLBARITEMCAPTION: return "Missing toolbar item caption";
			case LIBMC_ERROR_MISSINGSERVICESNODE: return "Missing services node";
			case LIBMC_ERROR_INVALIDSESSIONUUID: return "Invalid session UUID";
			case LIBMC_ERROR_INVALIDSESSIONKEY: return "Invalid session Key";
			case LIBMC_ERROR_SESSIONNOTAUTHORIZED: return "Session not authorized";
			case LIBMC_ERROR_INVALIDUSERNAME: return "Invalid user name";
			case LIBMC_ERROR_INVALIDPASSWORD: return "Invalid password";
			case LIBMC_ERROR_INVALIDAUTHORIZATION: return "Invalid Authorization";
			case LIBMC_ERROR_USERALREADYAUTHORIZED: return "User already authorized";
			case LIBMC_ERROR_INVALIDSESSIONTOKEN: return "Invalid session token";
			case LIBMC_ERROR_INVALIDCLIENTKEY: return "Invalid client key";
			case LIBMC_ERROR_INVALIDLOGIN: return "Invalid login credentials";
			case LIBMC_ERROR_DUPLICATEPAGE: return "Duplicate page";
			case LIBMC_ERROR_PAGENOTFOUND: return "Page not found";
			case LIBMC_ERROR_MISSINGPAGENAME: return "Missing page name";
			case LIBMC_ERROR_INVALIDPAGENAME: return "Invalid page name";
			case LIBMC_ERROR_MODULENOTFOUND: return "Module not found";
			case LIBMC_ERROR_DUPLICATEMODULE: return "Duplicate module";
			case LIBMC_ERROR_INVALIDMODULENAME: return "Invalid module name";
			case LIBMC_ERROR_INVALIDMODULETYPE: return "Invalid module type";
			case LIBMC_ERROR_INVALIDHEADLINE: return "Invalid headline";
			case LIBMC_ERROR_USERNOTFOUND: return "User not found";
			case LIBMC_ERROR_STREAMISNOTIMAGE: return "Stream is not image";
			case LIBMC_ERROR_TOOMANYCONTENTPARAMETERS: return "Too many content parameters";
			case LIBMC_ERROR_MISSINGCONTENTSTATEMACHINENAME: return "Missing content state machine name";
			case LIBMC_ERROR_MISSINGCONTENTGROUPNAME: return "Missing content group name";
			case LIBMC_ERROR_INVALIDENTRIESPERPAGE: return "Invalid entries per page";
			case LIBMC_ERROR_MODULEITEMNOTFOUND: return "Module item not found";
			case LIBMC_ERROR_DERIVEDPARAMETERSREADONLY: return "Derived parameters are read only.";
			case LIBMC_ERROR_TOOMANYJOURNALVARIABLES: return "Too many journal variables";
			case LIBMC_ERROR_JOURNALISNOTINITIALISING: return "Too many journal variables";
			case LIBMC_ERROR_JOURNALISNOTRECORDING: return "Journal is not recording.";
			case LIBMC_ERROR_INVALIDVARIABLETYPE: return "Invalid variable type";
			case LIBMC_ERROR_INVALIDVARIABLEUNITS: return "Invalid variable units";
			case LIBMC_ERROR_UNITSHAVEALREADYBEENSET: return "Units have already been set";
			case LIBMC_ERROR_UNITSHAVENOTBEENSET: return "Units have not been set";
			case LIBMC_ERROR_INVALIDTIMESTAMP: return "Invalid time stamp";
			case LIBMC_ERROR_NOCURRENTJOURNALCHUNK: return "No current journal chunk";
			case LIBMC_ERROR_DUPLICATEJOURNALID: return "Duplicate journal id";
			case LIBMC_ERROR_RESOURCEENTRYNOTFOUND: return "Resource entry not found";
			case LIBMC_ERROR_NOCORERESOURCEPACKAGE: return "No core resource package";
			case LIBMC_ERROR_INVALIDASPECTRATIO: return "Invalid aspect ratio";
			case LIBMC_ERROR_MISSINGLOGORESOURCE: return "Missing logo resource";
			case LIBMC_ERROR_NOUSERINTERFACEPLUGIN: return "No user interface plugin";
			case LIBMC_ERROR_COULDNOTLOADUILIBRARY: return "Could not load UI library";
			case LIBMC_ERROR_EVENTNAMENOTFOUND: return "Event name not found";
			case LIBMC_ERROR_INVALIDEVENTSENDER: return "Invalid event context";
			case LIBMC_ERROR_INVALIDEVENTCONTEXT: return "Invalid event sender";
			case LIBMC_ERROR_INVALIDLAYERINDEX: return "Invalid layer index";
			case LIBMC_ERROR_TEMPBASEPATHEMPTY: return "Empty base path for temporary files";
			case LIBMC_ERROR_PROFILENOTFOUND: return "Profile not found.";
			case LIBMC_ERROR_INVALIDSERVICEHANDLER: return "Invalid service handler.";
			case LIBMC_ERROR_INVALIDMAXTHREADCOUNT: return "Invalid max thread count.";
			case LIBMC_ERROR_INVALIDTOOLPATHSTREAMUUID: return "Invalid toolpath stream uuid";
			case LIBMC_ERROR_MISSINGSECTIONHEIGHT: return "Missing section height";
			case LIBMC_ERROR_INVALIDSECTIONHEIGHT: return "Invalid section height";
			case LIBMC_ERROR_MISSINGSECTIONWIDTH: return "Missing section width";
			case LIBMC_ERROR_INVALIDSECTIONWIDTH: return "Invalid section width";
			case LIBMC_ERROR_TOOLPATHMETADATANOTFOUND: return "Toolpath metadata not found";
			case LIBMC_ERROR_BUILDITEMHASNOUUID: return "Build item has no uuid";
			case LIBMC_ERROR_OBJECTHASNOUUID: return "Object has no uuid";
			case LIBMC_ERROR_COULDNOTPARSEEVENTPARAMETERS: return "Could not parse event parameters";
			case LIBMC_ERROR_INVALIDEVENTPARAMETERS: return "Invalid event parameters";
			case LIBMC_ERROR_INVALIDFORMVALUES: return "Invalid form values";
			case LIBMC_ERROR_FORMNAMEMISSING: return "Form name is missing";
			case LIBMC_ERROR_FORMENTITYNAMEMISSING: return "Form entity name is missing";
			case LIBMC_ERROR_FORMNOTFOUND: return "Form not found";
			case LIBMC_ERROR_FORMENTITYNOTFOUND: return "Form entity not found";
			case LIBMC_ERROR_DUPLICATEENTITYNAME: return "Duplicate form entity name";
			case LIBMC_ERROR_COULDNOTFINDEVENTSENDERPAGE: return "Could not find event sender page";
			case LIBMC_ERROR_COULDNOTFINDEVENTSENDER: return "Could not find event sender";
			case LIBMC_ERROR_DUPLICATEFORMNAME: return "Duplicate form name";
			case LIBMC_ERROR_EVENTNOTFOUND: return "Event not found";
			case LIBMC_ERROR_MISSINGCOLORNAME: return "Missing color name";
			case LIBMC_ERROR_MISSINGCOLORREDCHANNEL: return "Missing red color channel";
			case LIBMC_ERROR_MISSINGCOLORGREENCHANNEL: return "Missing green color channel";
			case LIBMC_ERROR_MISSINGCOLORBLUECHANNEL: return "Missing blue color channel";
			case LIBMC_ERROR_INVALIDCOLORREDCHANNEL: return "Invalid red color channel";
			case LIBMC_ERROR_INVALIDCOLORGREENCHANNEL: return "Invalid green color channel";
			case LIBMC_ERROR_INVALIDCOLORBLUECHANNEL: return "Invalid blue color channel";
			case LIBMC_ERROR_MISSINGCOLUMNWIDTH: return "Missing column width";
			case LIBMC_ERROR_INVALIDCOLUMNWIDTH: return "Invalid column width";
			case LIBMC_ERROR_MISSINGCOLUMNUNIT: return "Missing column unit";
			case LIBMC_ERROR_MISSINGROWHEIGHT: return "Missing row height";
			case LIBMC_ERROR_INVALIDROWHEIGHT: return "Invalid row height";
			case LIBMC_ERROR_MISSINGROWUNIT: return "Missing row unit";
			case LIBMC_ERROR_MISSINGCOLUMNSTARTATTRIB: return "Missing column start attrib";
			case LIBMC_ERROR_MISSINGCOLUMNENDATTRIB: return "Missing column end attrib";
			case LIBMC_ERROR_MISSINGROWSTARTATTRIB: return "Missing row start attrib";
			case LIBMC_ERROR_MISSINGROWENDATTRIB: return "Missing row end attrib";
			case LIBMC_ERROR_INVALIDCOLUMNSTARTATTRIB: return "Invalid column start attrib";
			case LIBMC_ERROR_INVALIDCOLUMNENDATTRIB: return "Invalid column end attrib";
			case LIBMC_ERROR_INVALIDROWSTARTATTRIB: return "Invalid row start attrib";
			case LIBMC_ERROR_INVALIDROWENDATTRIB: return "Invalid row end attrib";
			case LIBMC_ERROR_INVALIDPARAMETERPATH: return "Invalid parameter path";
			case LIBMC_ERROR_INVALIDPARAMETERINSTANCE: return "Invalid parameter instance";
			case LIBMC_ERROR_INVALIDPARAMETERGROUP: return "Invalid parameter group";
			case LIBMC_ERROR_INVALIDPARAMETERNAME: return "Invalid parameter name";
			case LIBMC_ERROR_INVALIDSTATEMACHINENAME: return "Invalid state machine name";
			case LIBMC_ERROR_INVALIDGRIDPOSITION: return "Invalid grid position";
			case LIBMC_ERROR_INVALIDDIALOGNAME: return "Invalid dialog name";
			case LIBMC_ERROR_DUPLICATEDIALOG: return "Duplicate dialog";
			case LIBMC_ERROR_DIALOGNOTFOUND: return "Dialog not found";
			case LIBMC_ERROR_COULDNOTHANDLEEVENT: return "Could not handle event";
			case LIBMC_ERROR_INVALIDFORMPATH: return "Invalid form path";
			case LIBMC_ERROR_MISSINGITEMNAME: return "Missing item name";
			case LIBMC_ERROR_INVALIDITEMPATH: return "Invalid item path";
			case LIBMC_ERROR_INVALIDMODULEPATH: return "Invalid module path";
			case LIBMC_ERROR_BUILDLISTNAMEMISSING: return "Build list name missing";
			case LIBMC_ERROR_EMPTYITEMPREFIX: return "Empty item prefix";
			case LIBMC_ERROR_INVALIDITEMPREFIX: return "Invalid item prefix";
			case LIBMC_ERROR_EMPTYITEMNAME: return "Empty item name";
			case LIBMC_ERROR_EXPRESSIONVALUEGIVENTWICE: return "Expression value is given twice";
			case LIBMC_ERROR_INVALIDINTEGEREXPRESSION: return "Invalid integer expression";
			case LIBMC_ERROR_INVALIDNUMBEREXPRESSION: return "Invalid number expression";
			case LIBMC_ERROR_INVALIDBOOLEANEXPRESSION: return "Invalid boolean expression";
			case LIBMC_ERROR_INVALIDPERSISTENCYNAME: return "Invalid persistency name";
			case LIBMC_ERROR_ONLYVALUEDPARAMETERSCANBEPERSISTENT: return "Only valued parameters can be persistent";
			case LIBMC_ERROR_PLATFORMINFORMATIONMISSING: return "Platform information missing";
			case LIBMC_ERROR_INVALIDBUTTONDISTRIBUTION: return "Invalid button distribution";
			case LIBMC_ERROR_EXPRESSIONVALUEMISSING: return "Expression value missing";
			case LIBMC_ERROR_INVALIDVIEWPORTCOORD: return "Invalid viewport coordinate";
			case LIBMC_ERROR_VIEWPORTCOORDMISSING: return "Viewport coordinate missing";
			case LIBMC_ERROR_MACHINEINSTANCENOTFOUND: return "Machine instance not found";
			case LIBMC_ERROR_COULDNOTGETTEMPPATHFROMWINDOWS: return "Could not get temp path from Windows";
			case LIBMC_ERROR_DUPLICATEBUTTONNAME: return "Duplicate button name";
			case LIBMC_ERROR_SERVERCONFIGURATIONNOTLOADED: return "Server configuration not loaded";
			case LIBMC_ERROR_COULDNOTPARSESERVERCONFIGURATION: return "Could not pars server configuration";
			case LIBMC_ERROR_MISSINGSERVERCONFIGURATIONNODE: return "Missing server configuration node";
			case LIBMC_ERROR_COULDNOTFINDLIBRARYENTRY: return "Could not find library entry";
			case LIBMC_ERROR_INVALIDPORT: return "Invalid port";
			case LIBMC_ERROR_MISSINGDATANODE: return "Missing data node";
			case LIBMC_ERROR_MISSINGDATADIRECTORY: return "Missing data directory";
			case LIBMC_ERROR_DATADIRECTORYDOESNOTEXISTS: return "Data directory does not exist:";
			case LIBMC_ERROR_INVALIDDATADIRECTORY: return "Invalid data directory";
			case LIBMC_ERROR_INVALIDSQLITEDBPATH: return "Missing SQLite DB Path";
			case LIBMC_ERROR_INVALIDDATABASETYPE: return "Invalid database type";
			case LIBMC_ERROR_DEFAULTPACKAGEMISSING: return "Default package missing";
			case LIBMC_ERROR_DEFAULTPACKAGENAMEMISSING: return "Default package name missing";
			case LIBMC_ERROR_COULDNOTPARSEPACKAGEXML: return "Could not parse package xml";
			case LIBMC_ERROR_MISSINGPACKAGENODE: return "Missing package node";
			case LIBMC_ERROR_MISSINGBUILDNODE: return "Missing build node";
			case LIBMC_ERROR_MISSINGBUILDNAME: return "Missing build name";
			case LIBMC_ERROR_MISSINGCONFIGURATIONNAME: return "Missing configuration name";
			case LIBMC_ERROR_MISSINGCORECLIENT: return "Missing core client";
			case LIBMC_ERROR_MISSINGLIBRARYNAME: return "Missing library name";
			case LIBMC_ERROR_MISSINGLIBRARYIMPORTNAME: return "Missing library import name";
			case LIBMC_ERROR_DUPLICATELIBRARYNAME: return "Duplicate library name";
			case LIBMC_ERROR_INVALIDTRANSFORMINTERVAL: return "Invalid transform interval";
			case LIBMC_ERROR_INVALIDTRANSFORMCOORDINATE: return "Invalid transform coordinate";
			case LIBMC_ERROR_SUCCESSSTATENOTFOUND: return "success state not found";
			case LIBMC_ERROR_DUPLICATESERVERPRIVATEKEY: return "duplicate server private key";
			case LIBMC_ERROR_DUPLICATESERVERCERTIFICATE: return "duplicate server certificate";
			case LIBMC_ERROR_INVALIDGITHASH: return "Invalid git hash";
			case LIBMC_ERROR_COULDNOTPARSETESTDEFINITION: return "Could not parse test definition.";
			case LIBMC_ERROR_MISSINGTESTDEFINITIONNODE: return "Missing test definition node.";
			case LIBMC_ERROR_AMBIGIOUSMAINNODE: return "Ambigious main node";
			case LIBMC_ERROR_MISSINGMAINNODE: return "Missing main node";
			case LIBMC_ERROR_MISSINGLIBRARIESNODE: return "Missing libraries node";
			case LIBMC_ERROR_MISSINGLIBRARYDLLFILENAME: return "Missing library dll filename";
			case LIBMC_ERROR_MISSINGTESTDESCRIPTION: return "Missing test description";
			case LIBMC_ERROR_MISSINGTESTINSTANCENAME: return "Missing test instance name";
			case LIBMC_ERROR_TESTDEFINITIONHASNOINSTANCES: return "Test definition has no instances";
			case LIBMC_ERROR_INVALIDPACKAGEENTRYNAME: return "Invalid package entry name";
			case LIBMC_ERROR_INVALIDPACKAGEENTRYEXTENSION: return "Invalid package entry name";
			case LIBMC_ERROR_INVALIDPACKAGEENTRYFILENAME: return "Invalid package entry file name";
			case LIBMC_ERROR_INVALIDEXPRESSIONVALUE: return "Invalid expression value";
			case LIBMC_ERROR_INVALIDBUTTONNAME: return "Invalid button name";
			case LIBMC_ERROR_RESOURCEENTRYISNOUTF8STRING: return "Resource entry is no UTF8 string";
			case LIBMC_ERROR_AMBIGUOUSDRIVERCONFIGURATION: return "Ambiguous driver configuration";
			case LIBMC_ERROR_COULDNOTCREATEDRIVER: return "Could not create driver";
			case LIBMC_ERROR_EMPTYGROUPNAMEBUTPARAMETERGIVEN: return "Empty group name but parameter given";
			case LIBMC_ERROR_INVALIDDEFAULTXMLNAMESPACE: return "invalid default xml namespace name.";
			case LIBMC_ERROR_INVALIDXMLROOTNODENAME: return "invalid xml root node name.";
			case LIBMC_ERROR_COULDNOTPARSEXMLSTRING: return "could not parse XML String.";
			case LIBMC_ERROR_COULDNOTPARSEXMLDATA: return "could not parse XML Data.";
			case LIBMC_ERROR_XMLDOESNOTCONTAINROOTNODE: return "XML does not contain root node.";
			case LIBMC_ERROR_XMLCONTAINSAMBIGOUSROOTNODES: return "XML contains ambiguous root nodes.";
			case LIBMC_ERROR_XMLDOESNOTCONTAINNAMESPACE: return "XML does not contain namespace.";
			case LIBMC_ERROR_INVALIDXMLDATA: return "invalid XML Data.";
			case LIBMC_ERROR_INVALIDXMLROOTNODEINSTANCE: return "invalid XML root node instance.";
			case LIBMC_ERROR_XMLNAMESPACEPREFIXALREADYREGISTERED: return "XML namespace prefix already registered.";
			case LIBMC_ERROR_XMLNAMESPACEALREADYREGISTERED: return "XML namespace already registered.";
			case LIBMC_ERROR_XMLNAMESPACENOTFOUND: return "XML namespace not found.";
			case LIBMC_ERROR_INVALIDNAMESPACENAME: return "Invalid namespace name.";
			case LIBMC_ERROR_INVALIDNAMESPACEPREFIX: return "Invalid namespace prefix.";
			case LIBMC_ERROR_INVALIDNAMESPACEINDEX: return "Invalid namespace index.";
			case LIBMC_ERROR_INVALIDATTRIBUTEINDEX: return "Invalid attribute index.";
			case LIBMC_ERROR_PROFILEVALUENOTFOUND: return "Profile value not found.";
			case LIBMC_ERROR_INVALIDXMLNODENAME: return "Invalid xml node name.";
			case LIBMC_ERROR_INVALIDXMLNAMESPACE: return "Invalid xml namespace.";
			case LIBMC_ERROR_COULDNOTFINDATTRIBUTE: return "Could not find attribute.";
			case LIBMC_ERROR_DUPLICATEATTRIBUTE: return "Duplicate attribute.";
			case LIBMC_ERROR_INTERNALATTRIBUTEERROR: return "Internal attribute error.";
			case LIBMC_ERROR_XMLNODECHILDNOTFOUND: return "XML node child not found.";
			case LIBMC_ERROR_INVALIDXMLNODEINDEX: return "Invalid XML Node index.";
			case LIBMC_ERROR_INTERNALNODEERROR: return "Internal node error.";
			case LIBMC_ERROR_XMLNODENOTFOUNDINLIST: return "XML node not found in list.";
			case LIBMC_ERROR_COULDNOTFINDXMLNAMESPACE: return "Could not find XML Namespace";
			case LIBMC_ERROR_INVALIDCOMPONENTNAME: return "invalid component name.";
			case LIBMC_ERROR_MISSINGCOMPONENTNAME: return "missing component name.";
			case LIBMC_ERROR_CUSTOMPAGEPROPERTYNAMEMISSING: return "custom page property name missing.";
			case LIBMC_ERROR_CUSTOMPAGEPROPERTYTYPEMISSING: return "custom page property type missing.";
			case LIBMC_ERROR_EMTPYEVENTNAME: return "empty event name.";
			case LIBMC_ERROR_INVALIDEVENTNAME: return "invalid event name.";
			case LIBMC_ERROR_INVALIDEVENTPATH: return "invalid event path.";
			case LIBMC_ERROR_CUSTOMPAGEVENTNAMEMISSING: return "custom page event name missing.";
			case LIBMC_ERROR_INVALIDCUSTOMPAGEVENTNAME: return "invalid custom page event name.";
			case LIBMC_ERROR_DUPLICATECUSTOMPAGEVENTNAME: return "duplicate custom page event name.";
			case LIBMC_ERROR_INVALIDEVENTPARAMETERNAME: return "invalid event parameter name.";
			case LIBMC_ERROR_INVALIDMETADATAINDEX: return "invalid metadata index.";
			case LIBMC_ERROR_METADATAISNOTUNIQUE: return "metadata is not unique.";
			case LIBMC_ERROR_METADATANOTFOUND: return "metadata not found.";
			case LIBMC_ERROR_TIMESTAMPISNOTINCREMENTING: return "Time stamp is not incrementing.";
			case LIBMC_ERROR_INVALIDTIMESTAMPINTERVAL: return "Invalid time stamp interval.";
			case LIBMC_ERROR_TIMESTREAMISEMPTY: return "Time stream is empty.";
			case LIBMC_ERROR_INVALIDTOOLPATHATTRIBUTETYPE: return "Invalid toolpath attribute type.";
			case LIBMC_ERROR_INVALIDSEGMENTINDEX: return "Invalid segment index.";
			case LIBMC_ERROR_INVALIDTOOLPATHATTRIBUTEID: return "Invalid toolpath attribute ID.";
			case LIBMC_ERROR_AMBIGUOUSSEGMENTATTRIBUTETYPE: return "Ambiguous segment attribute type.";
			case LIBMC_ERROR_XMLNODEHASCHILDREN: return "XML Node has children";
			case LIBMC_ERROR_XMLNODEHASTEXTCONTENT: return "XML Node has text content";
			case LIBMC_ERROR_STRINGHANDLERNOTAVAILABLE: return "String handler not available";
			case LIBMC_ERROR_DUPLICATEROLEPERMISSION: return "Duplicate role permission";
			case LIBMC_ERROR_EMPTYACCESSROLEIDENTIFIER: return "Empty access role identifier";
			case LIBMC_ERROR_INVALIDACCESSROLEIDENTIFIER: return "Invalid access role identifier";
			case LIBMC_ERROR_EMPTYACCESSROLEDISPLAYNAME: return "Empty access role display name";
			case LIBMC_ERROR_EMPTYACCESSPERMISSIONIDENTIFIER: return "Empty access permission identifier";
			case LIBMC_ERROR_INVALIDACCESSPERMISSIONIDENTIFIER: return "Invalid access permission identifier";
			case LIBMC_ERROR_EMPTYACCESSPERMISSIONDISPLAYNAME: return "Empty access permission display name";
			case LIBMC_ERROR_EMPTYSTRINGRESOURCENAME: return "Empty string resource name";
			case LIBMC_ERROR_DUPLICATESTRINGRESOURCENAME: return "Duplicate string resource name";
			case LIBMC_ERROR_INVALIDSTRINGRESOURCENAMEIDENTIFIER: return "Invalid string resource name identifier";
			case LIBMC_ERROR_STRINGRESOURCENOTFOUND: return "String resource not found";
			case LIBMC_ERROR_LANGUAGEIDNOTFOUND: return "Language ID not found";
			case LIBMC_ERROR_DUPLICATEPERMISSIONIDENTIFIER: return "Duplicate Permission Identifier";
			case LIBMC_ERROR_DUPLICATEROLEIDENTIFIER: return "Duplicate Role Identifier";
			case LIBMC_ERROR_PERMISSIONNOTFOUND: return "Permission not found";
			case LIBMC_ERROR_ROLENOTFOUND: return "Role not found";
			case LIBMC_ERROR_MISSINGACCESSCONTROLPERMISSIONS: return "Missing access control permissions";
			case LIBMC_ERROR_MISSINGACCESSCONTROLROLES: return "Missing access control roles";
			case LIBMC_ERROR_MISSINGACCESSCONTROLROLEPERMISSIONS: return "Missing access control role permissions";
			case LIBMC_ERROR_MISSINGROLEPERMISSIONIDENTIFIER: return "Missing role permission identifier";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDBUFFER: return "Invalid discrete field buffer";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDFILESIGN: return "Invalid discrete field file sign";
			case LIBMC_ERROR_INCOMPATIBLEDISCRETEFIELDFILEVERSION: return "Incompatible discrete field file version";
			case LIBMC_ERROR_TOONEWDISCRETEFIELDFILEVERSION: return "Too new discrete field file version";
			case LIBMC_ERROR_TOONEWDISCRETEFIELDSTREAMTYPE: return "Too new discrete field stream type";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDDATAOFFSET: return "Invalid discrete field data offset";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDSTREAMSIZE: return "Invalid discrete field stream size";
			case LIBMC_ERROR_INVALIDDISCRETEFIELDINTERNALDATA: return "Invalid discrete field internal data";
			case LIBMC_ERROR_DEFAULTROLEHASNOTBEENSET: return "Default role has not been set";
			case LIBMC_ERROR_EMPTYROLEIDENTIFIER: return "Empty role identifier";
			case LIBMC_ERROR_EMPTYPERMISSIONIDENTIFIER: return "Empty permission identifier";
			case LIBMC_ERROR_USERHASUNKNOWNROLE: return "User has unknown role";
			case LIBMC_ERROR_MISSINGDEFAULTACCESSROLE: return "Missing default access role";
			case LIBMC_ERROR_FIXEDFLOATBUFFEROVERRUN: return "Fixed float buffer overrun";
			case LIBMC_ERROR_MESHENTITYNOTLOADED: return "Mesh entity not loaded";
			case LIBMC_ERROR_MESHENTITYALREADYLOADED: return "Mesh entity already loaded";
			case LIBMC_ERROR_INVALIDMESHFACEID: return "Invalid face ID";
			case LIBMC_ERROR_MESH3MFRESOURCEISEMPTY: return "Mesh 3MF resource is empty";
			case LIBMC_ERROR_INVALIDMESHEDGEID: return "Invalid edge ID";
			case LIBMC_ERROR_INVALIDMESHNODEID: return "Invalid node ID";
			case LIBMC_ERROR_INVALIDGLSCENEMODELNAME: return "Invalid GL scene model name";
			case LIBMC_ERROR_INVALIDGLSCENEINSTANCENAME: return "Invalid GL scene instance name";
			case LIBMC_ERROR_EMPTYGLMODELNAME: return "Empty GL model name";
			case LIBMC_ERROR_INVALIDGLMODELNAME: return "Invalid GL model name";
			case LIBMC_ERROR_DUPLICATEGLMODELNAME: return "Duplicate GL model name";
			case LIBMC_ERROR_MODELGLRESOURCENOTFOUND: return "Model GL Resource not found";
			case LIBMC_ERROR_EMPTYGLINSTANCENAME: return "Empty GL instance name";
			case LIBMC_ERROR_INVALIDGLINSTANCENAME: return "Invalid GL instance name";
			case LIBMC_ERROR_EMPTYGLINSTANCEMODEL: return "Empty GL instance model";
			case LIBMC_ERROR_INVALIDGLINSTANCEMODEL: return "Invalid GL instance model";
			case LIBMC_ERROR_GLINSTANCEMODELNOTFOUND: return "GL instance model not found";
			case LIBMC_ERROR_DUPLICATEGLINSTANCENAME: return "Duplicate GL instance name";
			case LIBMC_ERROR_INVALIDJOURNALSTREAMCAPACITY: return "Invalid journal stream capacity";
			case LIBMC_ERROR_INVALIDUIFORMAT: return "Invalid UI format";
			case LIBMC_ERROR_INVALIDJOURNALTIMESTAMP: return "Invalid Journal Timestamp";
			case LIBMC_ERROR_CHUNKTIMESTREAMNOTCONTINUOUS: return "Chunk time stream not continuous";
			case LIBMC_ERROR_JOURNALVARIABLENOTFOUND: return "Journal Variable not found";
			case LIBMC_ERROR_INVALIDJOURNALSTREAMQUERY: return "Invalid journal stream query";
			case LIBMC_ERROR_INVALIDJOURNALCOMPUTEDATA: return "Invalid journal compute data";
			case LIBMC_ERROR_INVALIDJOURNALCOMPUTEINTERVAL: return "Invalid journal compute interval";
			case LIBMC_ERROR_DATASERIESNOTFOUND: return "Data series not found";
			case LIBMC_ERROR_DATASERIESISEMPTY: return "Data series is empty";
		}
		return "unknown error";
	}

private:

	std::string buildErrorMessage() const noexcept
	{
		std::string msg = m_originalErrorMessage;
		if (msg.empty()) {
			msg = getErrorDescription();
		}
		return std::string("Error: ") + getErrorName() + ": " + msg;
	}
};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector(const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector(const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibMCInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	explicit CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	explicit CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibMCResult nResult);

	inline void GetVersion(LibMC_uint32 & nMajor, LibMC_uint32 & nMinor, LibMC_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibMC_pvoid pSymbolAddressMethod);
	inline PMCContext CreateMCContext(classParam<LibMCData::CDataModel> pDataModel);

private:
	sLibMCDynamicWrapperTable m_WrapperTable;
	// Injected Components
	LibMCData::PWrapper m_pLibMCDataWrapper;

	
	LibMCResult checkBinaryVersion()
	{
		LibMC_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if (nMajor != LIBMC_VERSION_MAJOR) {
			return LIBMC_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBMC_SUCCESS;
	}
	LibMCResult initWrapperTable(sLibMCDynamicWrapperTable * pWrapperTable);
	LibMCResult releaseWrapperTable(sLibMCDynamicWrapperTable * pWrapperTable);
	LibMCResult loadWrapperTable(sLibMCDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibMCResult loadWrapperTableFromSymbolLookupMethod(sLibMCDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CAPIRequestHandler;
	friend class CMCContext;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibMCHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibMCResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibMCHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibMCHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CAPIRequestHandler 
**************************************************************************************************************************/
class CAPIRequestHandler : public CBase {
public:
	
	/**
	* CAPIRequestHandler::CAPIRequestHandler - Constructor for APIRequestHandler class.
	*/
	CAPIRequestHandler(CWrapper* pWrapper, LibMCHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline bool ExpectsRawBody();
	inline bool ExpectsFormData(LibMC_uint32 & nFieldCount);
	inline void GetFormDataDetails(const LibMC_uint32 nFieldIndex, std::string & sName, bool & bIsFile, bool & bMandatory);
	inline void SetFormDataField(const std::string & sName, const CInputVector<LibMC_uint8> & DataFieldBuffer);
	inline void SetFormStringField(const std::string & sName, const std::string & sString);
	inline void Handle(const CInputVector<LibMC_uint8> & RawBodyBuffer, std::string & sContentType, LibMC_uint32 & nHTTPCode);
	inline void GetResultData(std::vector<LibMC_uint8> & DataBuffer);
};
	
/*************************************************************************************************************************
 Class CMCContext 
**************************************************************************************************************************/
class CMCContext : public CBase {
public:
	
	/**
	* CMCContext::CMCContext - Constructor for MCContext class.
	*/
	CMCContext(CWrapper* pWrapper, LibMCHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void RegisterLibraryPath(const std::string & sLibraryName, const std::string & sLibraryPath, const std::string & sLibraryResource);
	inline void SetTempBasePath(const std::string & sTempBasePath);
	inline void ParseConfiguration(const std::string & sXMLString);
	inline void StartAllThreads();
	inline void TerminateAllThreads();
	inline void StartInstanceThread(const std::string & sInstanceName);
	inline void TerminateInstanceThread(const std::string & sInstanceName);
	inline std::string GetInstanceThreadState(const std::string & sInstanceName);
	inline bool InstanceStateIsSuccessful(const std::string & sInstanceName);
	inline bool InstanceStateHasFailed(const std::string & sInstanceName);
	inline void LoadClientPackage(const std::string & sResourcePath);
	inline void Log(const std::string & sMessage, const eLogSubSystem eSubsystem, const eLogLevel eLogLevel);
	inline PAPIRequestHandler CreateAPIRequestHandler(const std::string & sURI, const std::string & sRequestMethod, const std::string & sAuthorization);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibMC_uint32 & nMajor, LibMC_uint32 & nMinor, LibMC_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibMCHandle hInstance = pInstance.GetHandle();
		LibMC_uint32 bytesNeededErrorMessage = 0;
		LibMC_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibMCHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibMCHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibMC_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (sNameSpace == "LibMCData") {
			if (m_pLibMCDataWrapper != nullptr) {
				throw ELibMCException(LIBMC_ERROR_COULDNOTLOADLIBRARY, "Library with namespace " + sNameSpace + " is already registered.");
			}
			m_pLibMCDataWrapper = LibMCData::CWrapper::loadLibraryFromSymbolLookupMethod(pSymbolAddressMethod);
			bNameSpaceFound = true;
		}
		if (!bNameSpaceFound)
			throw ELibMCException(LIBMC_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::CreateMCContext - Creates and initializes new MC Context.
	* @param[in] pDataModel - DataModel Object
	* @return New Context instance
	*/
	inline PMCContext CWrapper::CreateMCContext(classParam<LibMCData::CDataModel> pDataModel)
	{
		LibMCDataHandle hDataModel = pDataModel.GetHandle();
		LibMCHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateMCContext(hDataModel, &hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBMC_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CMCContext>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibMCResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibMCException(nResult, sErrorMessage);
		}
	}
	

	inline LibMCResult CWrapper::initWrapperTable(sLibMCDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMC_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_APIRequestHandler_ExpectsRawBody = nullptr;
		pWrapperTable->m_APIRequestHandler_ExpectsFormData = nullptr;
		pWrapperTable->m_APIRequestHandler_GetFormDataDetails = nullptr;
		pWrapperTable->m_APIRequestHandler_SetFormDataField = nullptr;
		pWrapperTable->m_APIRequestHandler_SetFormStringField = nullptr;
		pWrapperTable->m_APIRequestHandler_Handle = nullptr;
		pWrapperTable->m_APIRequestHandler_GetResultData = nullptr;
		pWrapperTable->m_MCContext_RegisterLibraryPath = nullptr;
		pWrapperTable->m_MCContext_SetTempBasePath = nullptr;
		pWrapperTable->m_MCContext_ParseConfiguration = nullptr;
		pWrapperTable->m_MCContext_StartAllThreads = nullptr;
		pWrapperTable->m_MCContext_TerminateAllThreads = nullptr;
		pWrapperTable->m_MCContext_StartInstanceThread = nullptr;
		pWrapperTable->m_MCContext_TerminateInstanceThread = nullptr;
		pWrapperTable->m_MCContext_GetInstanceThreadState = nullptr;
		pWrapperTable->m_MCContext_InstanceStateIsSuccessful = nullptr;
		pWrapperTable->m_MCContext_InstanceStateHasFailed = nullptr;
		pWrapperTable->m_MCContext_LoadClientPackage = nullptr;
		pWrapperTable->m_MCContext_Log = nullptr;
		pWrapperTable->m_MCContext_CreateAPIRequestHandler = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_CreateMCContext = nullptr;
		
		return LIBMC_SUCCESS;
	}

	inline LibMCResult CWrapper::releaseWrapperTable(sLibMCDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBMC_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBMC_SUCCESS;
	}

	inline LibMCResult CWrapper::loadWrapperTable(sLibMCDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBMC_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBMC_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = 0;
		while ((pLibraryFileName[nLength] != 0) && (nLength < MAX_PATH))
			nLength++;
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBMC_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBMC_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBMC_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_APIRequestHandler_ExpectsRawBody = (PLibMCAPIRequestHandler_ExpectsRawBodyPtr) GetProcAddress(hLibrary, "libmc_apirequesthandler_expectsrawbody");
		#else // _WIN32
		pWrapperTable->m_APIRequestHandler_ExpectsRawBody = (PLibMCAPIRequestHandler_ExpectsRawBodyPtr) dlsym(hLibrary, "libmc_apirequesthandler_expectsrawbody");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_APIRequestHandler_ExpectsRawBody == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_APIRequestHandler_ExpectsFormData = (PLibMCAPIRequestHandler_ExpectsFormDataPtr) GetProcAddress(hLibrary, "libmc_apirequesthandler_expectsformdata");
		#else // _WIN32
		pWrapperTable->m_APIRequestHandler_ExpectsFormData = (PLibMCAPIRequestHandler_ExpectsFormDataPtr) dlsym(hLibrary, "libmc_apirequesthandler_expectsformdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_APIRequestHandler_ExpectsFormData == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_APIRequestHandler_GetFormDataDetails = (PLibMCAPIRequestHandler_GetFormDataDetailsPtr) GetProcAddress(hLibrary, "libmc_apirequesthandler_getformdatadetails");
		#else // _WIN32
		pWrapperTable->m_APIRequestHandler_GetFormDataDetails = (PLibMCAPIRequestHandler_GetFormDataDetailsPtr) dlsym(hLibrary, "libmc_apirequesthandler_getformdatadetails");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_APIRequestHandler_GetFormDataDetails == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_APIRequestHandler_SetFormDataField = (PLibMCAPIRequestHandler_SetFormDataFieldPtr) GetProcAddress(hLibrary, "libmc_apirequesthandler_setformdatafield");
		#else // _WIN32
		pWrapperTable->m_APIRequestHandler_SetFormDataField = (PLibMCAPIRequestHandler_SetFormDataFieldPtr) dlsym(hLibrary, "libmc_apirequesthandler_setformdatafield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_APIRequestHandler_SetFormDataField == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_APIRequestHandler_SetFormStringField = (PLibMCAPIRequestHandler_SetFormStringFieldPtr) GetProcAddress(hLibrary, "libmc_apirequesthandler_setformstringfield");
		#else // _WIN32
		pWrapperTable->m_APIRequestHandler_SetFormStringField = (PLibMCAPIRequestHandler_SetFormStringFieldPtr) dlsym(hLibrary, "libmc_apirequesthandler_setformstringfield");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_APIRequestHandler_SetFormStringField == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_APIRequestHandler_Handle = (PLibMCAPIRequestHandler_HandlePtr) GetProcAddress(hLibrary, "libmc_apirequesthandler_handle");
		#else // _WIN32
		pWrapperTable->m_APIRequestHandler_Handle = (PLibMCAPIRequestHandler_HandlePtr) dlsym(hLibrary, "libmc_apirequesthandler_handle");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_APIRequestHandler_Handle == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_APIRequestHandler_GetResultData = (PLibMCAPIRequestHandler_GetResultDataPtr) GetProcAddress(hLibrary, "libmc_apirequesthandler_getresultdata");
		#else // _WIN32
		pWrapperTable->m_APIRequestHandler_GetResultData = (PLibMCAPIRequestHandler_GetResultDataPtr) dlsym(hLibrary, "libmc_apirequesthandler_getresultdata");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_APIRequestHandler_GetResultData == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_RegisterLibraryPath = (PLibMCMCContext_RegisterLibraryPathPtr) GetProcAddress(hLibrary, "libmc_mccontext_registerlibrarypath");
		#else // _WIN32
		pWrapperTable->m_MCContext_RegisterLibraryPath = (PLibMCMCContext_RegisterLibraryPathPtr) dlsym(hLibrary, "libmc_mccontext_registerlibrarypath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_RegisterLibraryPath == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_SetTempBasePath = (PLibMCMCContext_SetTempBasePathPtr) GetProcAddress(hLibrary, "libmc_mccontext_settempbasepath");
		#else // _WIN32
		pWrapperTable->m_MCContext_SetTempBasePath = (PLibMCMCContext_SetTempBasePathPtr) dlsym(hLibrary, "libmc_mccontext_settempbasepath");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_SetTempBasePath == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_ParseConfiguration = (PLibMCMCContext_ParseConfigurationPtr) GetProcAddress(hLibrary, "libmc_mccontext_parseconfiguration");
		#else // _WIN32
		pWrapperTable->m_MCContext_ParseConfiguration = (PLibMCMCContext_ParseConfigurationPtr) dlsym(hLibrary, "libmc_mccontext_parseconfiguration");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_ParseConfiguration == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_StartAllThreads = (PLibMCMCContext_StartAllThreadsPtr) GetProcAddress(hLibrary, "libmc_mccontext_startallthreads");
		#else // _WIN32
		pWrapperTable->m_MCContext_StartAllThreads = (PLibMCMCContext_StartAllThreadsPtr) dlsym(hLibrary, "libmc_mccontext_startallthreads");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_StartAllThreads == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_TerminateAllThreads = (PLibMCMCContext_TerminateAllThreadsPtr) GetProcAddress(hLibrary, "libmc_mccontext_terminateallthreads");
		#else // _WIN32
		pWrapperTable->m_MCContext_TerminateAllThreads = (PLibMCMCContext_TerminateAllThreadsPtr) dlsym(hLibrary, "libmc_mccontext_terminateallthreads");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_TerminateAllThreads == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_StartInstanceThread = (PLibMCMCContext_StartInstanceThreadPtr) GetProcAddress(hLibrary, "libmc_mccontext_startinstancethread");
		#else // _WIN32
		pWrapperTable->m_MCContext_StartInstanceThread = (PLibMCMCContext_StartInstanceThreadPtr) dlsym(hLibrary, "libmc_mccontext_startinstancethread");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_StartInstanceThread == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_TerminateInstanceThread = (PLibMCMCContext_TerminateInstanceThreadPtr) GetProcAddress(hLibrary, "libmc_mccontext_terminateinstancethread");
		#else // _WIN32
		pWrapperTable->m_MCContext_TerminateInstanceThread = (PLibMCMCContext_TerminateInstanceThreadPtr) dlsym(hLibrary, "libmc_mccontext_terminateinstancethread");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_TerminateInstanceThread == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_GetInstanceThreadState = (PLibMCMCContext_GetInstanceThreadStatePtr) GetProcAddress(hLibrary, "libmc_mccontext_getinstancethreadstate");
		#else // _WIN32
		pWrapperTable->m_MCContext_GetInstanceThreadState = (PLibMCMCContext_GetInstanceThreadStatePtr) dlsym(hLibrary, "libmc_mccontext_getinstancethreadstate");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_GetInstanceThreadState == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_InstanceStateIsSuccessful = (PLibMCMCContext_InstanceStateIsSuccessfulPtr) GetProcAddress(hLibrary, "libmc_mccontext_instancestateissuccessful");
		#else // _WIN32
		pWrapperTable->m_MCContext_InstanceStateIsSuccessful = (PLibMCMCContext_InstanceStateIsSuccessfulPtr) dlsym(hLibrary, "libmc_mccontext_instancestateissuccessful");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_InstanceStateIsSuccessful == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_InstanceStateHasFailed = (PLibMCMCContext_InstanceStateHasFailedPtr) GetProcAddress(hLibrary, "libmc_mccontext_instancestatehasfailed");
		#else // _WIN32
		pWrapperTable->m_MCContext_InstanceStateHasFailed = (PLibMCMCContext_InstanceStateHasFailedPtr) dlsym(hLibrary, "libmc_mccontext_instancestatehasfailed");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_InstanceStateHasFailed == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_LoadClientPackage = (PLibMCMCContext_LoadClientPackagePtr) GetProcAddress(hLibrary, "libmc_mccontext_loadclientpackage");
		#else // _WIN32
		pWrapperTable->m_MCContext_LoadClientPackage = (PLibMCMCContext_LoadClientPackagePtr) dlsym(hLibrary, "libmc_mccontext_loadclientpackage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_LoadClientPackage == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_Log = (PLibMCMCContext_LogPtr) GetProcAddress(hLibrary, "libmc_mccontext_log");
		#else // _WIN32
		pWrapperTable->m_MCContext_Log = (PLibMCMCContext_LogPtr) dlsym(hLibrary, "libmc_mccontext_log");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_Log == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_MCContext_CreateAPIRequestHandler = (PLibMCMCContext_CreateAPIRequestHandlerPtr) GetProcAddress(hLibrary, "libmc_mccontext_createapirequesthandler");
		#else // _WIN32
		pWrapperTable->m_MCContext_CreateAPIRequestHandler = (PLibMCMCContext_CreateAPIRequestHandlerPtr) dlsym(hLibrary, "libmc_mccontext_createapirequesthandler");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_MCContext_CreateAPIRequestHandler == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibMCGetVersionPtr) GetProcAddress(hLibrary, "libmc_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibMCGetVersionPtr) dlsym(hLibrary, "libmc_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibMCGetLastErrorPtr) GetProcAddress(hLibrary, "libmc_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibMCGetLastErrorPtr) dlsym(hLibrary, "libmc_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCReleaseInstancePtr) GetProcAddress(hLibrary, "libmc_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibMCReleaseInstancePtr) dlsym(hLibrary, "libmc_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCAcquireInstancePtr) GetProcAddress(hLibrary, "libmc_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibMCAcquireInstancePtr) dlsym(hLibrary, "libmc_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCInjectComponentPtr) GetProcAddress(hLibrary, "libmc_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibMCInjectComponentPtr) dlsym(hLibrary, "libmc_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateMCContext = (PLibMCCreateMCContextPtr) GetProcAddress(hLibrary, "libmc_createmccontext");
		#else // _WIN32
		pWrapperTable->m_CreateMCContext = (PLibMCCreateMCContextPtr) dlsym(hLibrary, "libmc_createmccontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateMCContext == nullptr)
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBMC_SUCCESS;
	}

	inline LibMCResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibMCDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBMC_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBMC_ERROR_INVALIDPARAM;
		
		typedef LibMCResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibMCResult eLookupError = LIBMC_SUCCESS;
		eLookupError = (*pLookup)("libmc_apirequesthandler_expectsrawbody", (void**)&(pWrapperTable->m_APIRequestHandler_ExpectsRawBody));
		if ( (eLookupError != 0) || (pWrapperTable->m_APIRequestHandler_ExpectsRawBody == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_apirequesthandler_expectsformdata", (void**)&(pWrapperTable->m_APIRequestHandler_ExpectsFormData));
		if ( (eLookupError != 0) || (pWrapperTable->m_APIRequestHandler_ExpectsFormData == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_apirequesthandler_getformdatadetails", (void**)&(pWrapperTable->m_APIRequestHandler_GetFormDataDetails));
		if ( (eLookupError != 0) || (pWrapperTable->m_APIRequestHandler_GetFormDataDetails == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_apirequesthandler_setformdatafield", (void**)&(pWrapperTable->m_APIRequestHandler_SetFormDataField));
		if ( (eLookupError != 0) || (pWrapperTable->m_APIRequestHandler_SetFormDataField == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_apirequesthandler_setformstringfield", (void**)&(pWrapperTable->m_APIRequestHandler_SetFormStringField));
		if ( (eLookupError != 0) || (pWrapperTable->m_APIRequestHandler_SetFormStringField == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_apirequesthandler_handle", (void**)&(pWrapperTable->m_APIRequestHandler_Handle));
		if ( (eLookupError != 0) || (pWrapperTable->m_APIRequestHandler_Handle == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_apirequesthandler_getresultdata", (void**)&(pWrapperTable->m_APIRequestHandler_GetResultData));
		if ( (eLookupError != 0) || (pWrapperTable->m_APIRequestHandler_GetResultData == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_registerlibrarypath", (void**)&(pWrapperTable->m_MCContext_RegisterLibraryPath));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_RegisterLibraryPath == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_settempbasepath", (void**)&(pWrapperTable->m_MCContext_SetTempBasePath));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_SetTempBasePath == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_parseconfiguration", (void**)&(pWrapperTable->m_MCContext_ParseConfiguration));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_ParseConfiguration == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_startallthreads", (void**)&(pWrapperTable->m_MCContext_StartAllThreads));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_StartAllThreads == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_terminateallthreads", (void**)&(pWrapperTable->m_MCContext_TerminateAllThreads));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_TerminateAllThreads == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_startinstancethread", (void**)&(pWrapperTable->m_MCContext_StartInstanceThread));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_StartInstanceThread == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_terminateinstancethread", (void**)&(pWrapperTable->m_MCContext_TerminateInstanceThread));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_TerminateInstanceThread == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_getinstancethreadstate", (void**)&(pWrapperTable->m_MCContext_GetInstanceThreadState));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_GetInstanceThreadState == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_instancestateissuccessful", (void**)&(pWrapperTable->m_MCContext_InstanceStateIsSuccessful));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_InstanceStateIsSuccessful == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_instancestatehasfailed", (void**)&(pWrapperTable->m_MCContext_InstanceStateHasFailed));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_InstanceStateHasFailed == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_loadclientpackage", (void**)&(pWrapperTable->m_MCContext_LoadClientPackage));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_LoadClientPackage == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_log", (void**)&(pWrapperTable->m_MCContext_Log));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_Log == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_mccontext_createapirequesthandler", (void**)&(pWrapperTable->m_MCContext_CreateAPIRequestHandler));
		if ( (eLookupError != 0) || (pWrapperTable->m_MCContext_CreateAPIRequestHandler == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("libmc_createmccontext", (void**)&(pWrapperTable->m_CreateMCContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateMCContext == nullptr) )
			return LIBMC_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBMC_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CAPIRequestHandler
	 */
	
	/**
	* CAPIRequestHandler::ExpectsRawBody - checks if the raw body is needed to handle the request.
	* @return Flag, if the raw body is needed in the request.
	*/
	bool CAPIRequestHandler::ExpectsRawBody()
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_ExpectsRawBody(m_pHandle, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CAPIRequestHandler::ExpectsFormData - checks if the parsed form data is needed to handle the request.
	* @param[out] nFieldCount - Number of Form Data entries that are expected.
	* @return Flag, if the parsed form data is needed in the request.
	*/
	bool CAPIRequestHandler::ExpectsFormData(LibMC_uint32 & nFieldCount)
	{
		bool resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_ExpectsFormData(m_pHandle, &nFieldCount, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CAPIRequestHandler::GetFormDataDetails - returns details of expected form data.
	* @param[in] nFieldIndex - Index of Form Data Field (0..FieldCount - 1)
	* @param[out] sName - Name of the expected form data field.
	* @param[out] bIsFile - Flag, if the field Is a file field.
	* @param[out] bMandatory - Flag, if the field MUST be present.
	*/
	void CAPIRequestHandler::GetFormDataDetails(const LibMC_uint32 nFieldIndex, std::string & sName, bool & bIsFile, bool & bMandatory)
	{
		LibMC_uint32 bytesNeededName = 0;
		LibMC_uint32 bytesWrittenName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_GetFormDataDetails(m_pHandle, nFieldIndex, 0, &bytesNeededName, nullptr, &bIsFile, &bMandatory));
		std::vector<char> bufferName(bytesNeededName);
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_GetFormDataDetails(m_pHandle, nFieldIndex, bytesNeededName, &bytesWrittenName, &bufferName[0], &bIsFile, &bMandatory));
		sName = std::string(&bufferName[0]);
	}
	
	/**
	* CAPIRequestHandler::SetFormDataField - passes the a form data field to the request handler. Call only, if ExpectsFormData returns true.
	* @param[in] sName - Name of the form data field.
	* @param[in] DataFieldBuffer - DataField that was sent.
	*/
	void CAPIRequestHandler::SetFormDataField(const std::string & sName, const CInputVector<LibMC_uint8> & DataFieldBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_SetFormDataField(m_pHandle, sName.c_str(), (LibMC_uint64)DataFieldBuffer.size(), DataFieldBuffer.data()));
	}
	
	/**
	* CAPIRequestHandler::SetFormStringField - passes the a form string field to the request handler. Call only, if ExpectsFormData returns true.
	* @param[in] sName - Name of the form data field.
	* @param[in] sString - DataString that was sent.
	*/
	void CAPIRequestHandler::SetFormStringField(const std::string & sName, const std::string & sString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_SetFormStringField(m_pHandle, sName.c_str(), sString.c_str()));
	}
	
	/**
	* CAPIRequestHandler::Handle - handles the request.
	* @param[in] RawBodyBuffer - Raw Body that was sent. Only necessary, if ExpectsRawBody returns true.
	* @param[out] sContentType - the resulting Content Type String of the data.
	* @param[out] nHTTPCode - the resulting HTTP Errorcode (200 for success).
	*/
	void CAPIRequestHandler::Handle(const CInputVector<LibMC_uint8> & RawBodyBuffer, std::string & sContentType, LibMC_uint32 & nHTTPCode)
	{
		LibMC_uint32 bytesNeededContentType = 0;
		LibMC_uint32 bytesWrittenContentType = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_Handle(m_pHandle, (LibMC_uint64)RawBodyBuffer.size(), RawBodyBuffer.data(), 0, &bytesNeededContentType, nullptr, &nHTTPCode));
		std::vector<char> bufferContentType(bytesNeededContentType);
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_Handle(m_pHandle, (LibMC_uint64)RawBodyBuffer.size(), RawBodyBuffer.data(), bytesNeededContentType, &bytesWrittenContentType, &bufferContentType[0], &nHTTPCode));
		sContentType = std::string(&bufferContentType[0]);
	}
	
	/**
	* CAPIRequestHandler::GetResultData - returns the cached stream content of the resulting data. Call only after Handle().
	* @param[out] DataBuffer - Binary stream data
	*/
	void CAPIRequestHandler::GetResultData(std::vector<LibMC_uint8> & DataBuffer)
	{
		LibMC_uint64 elementsNeededData = 0;
		LibMC_uint64 elementsWrittenData = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_GetResultData(m_pHandle, 0, &elementsNeededData, nullptr));
		DataBuffer.resize((size_t) elementsNeededData);
		CheckError(m_pWrapper->m_WrapperTable.m_APIRequestHandler_GetResultData(m_pHandle, elementsNeededData, &elementsWrittenData, DataBuffer.data()));
	}
	
	/**
	 * Method definitions for class CMCContext
	 */
	
	/**
	* CMCContext::RegisterLibraryPath - registers a library for a given name.
	* @param[in] sLibraryName - Library Name.
	* @param[in] sLibraryPath - Path to the shared library.
	* @param[in] sLibraryResource - Path to the library resource file.
	*/
	void CMCContext::RegisterLibraryPath(const std::string & sLibraryName, const std::string & sLibraryPath, const std::string & sLibraryResource)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_RegisterLibraryPath(m_pHandle, sLibraryName.c_str(), sLibraryPath.c_str(), sLibraryResource.c_str()));
	}
	
	/**
	* CMCContext::SetTempBasePath - sets the base path for temporary files.
	* @param[in] sTempBasePath - Base path for temporary files.
	*/
	void CMCContext::SetTempBasePath(const std::string & sTempBasePath)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_SetTempBasePath(m_pHandle, sTempBasePath.c_str()));
	}
	
	/**
	* CMCContext::ParseConfiguration - parses and initialises the state machines from a configuration XML.
	* @param[in] sXMLString - XML Configuration String.
	*/
	void CMCContext::ParseConfiguration(const std::string & sXMLString)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_ParseConfiguration(m_pHandle, sXMLString.c_str()));
	}
	
	/**
	* CMCContext::StartAllThreads - starts the threads for all the state machines.
	*/
	void CMCContext::StartAllThreads()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_StartAllThreads(m_pHandle));
	}
	
	/**
	* CMCContext::TerminateAllThreads - terminates the threads for all the state machines.
	*/
	void CMCContext::TerminateAllThreads()
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_TerminateAllThreads(m_pHandle));
	}
	
	/**
	* CMCContext::StartInstanceThread - starts a single instance thread.
	* @param[in] sInstanceName - Instance name of state machine to start.
	*/
	void CMCContext::StartInstanceThread(const std::string & sInstanceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_StartInstanceThread(m_pHandle, sInstanceName.c_str()));
	}
	
	/**
	* CMCContext::TerminateInstanceThread - terminates a single instance thread.
	* @param[in] sInstanceName - Instance name of state machine to terminate.
	*/
	void CMCContext::TerminateInstanceThread(const std::string & sInstanceName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_TerminateInstanceThread(m_pHandle, sInstanceName.c_str()));
	}
	
	/**
	* CMCContext::GetInstanceThreadState - returns current state of a instance thread.
	* @param[in] sInstanceName - Instance name of state machine.
	* @return State of state machine.
	*/
	std::string CMCContext::GetInstanceThreadState(const std::string & sInstanceName)
	{
		LibMC_uint32 bytesNeededStateName = 0;
		LibMC_uint32 bytesWrittenStateName = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_GetInstanceThreadState(m_pHandle, sInstanceName.c_str(), 0, &bytesNeededStateName, nullptr));
		std::vector<char> bufferStateName(bytesNeededStateName);
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_GetInstanceThreadState(m_pHandle, sInstanceName.c_str(), bytesNeededStateName, &bytesWrittenStateName, &bufferStateName[0]));
		
		return std::string(&bufferStateName[0]);
	}
	
	/**
	* CMCContext::InstanceStateIsSuccessful - returns if an instance thread is in success state.
	* @param[in] sInstanceName - Instance name of state machine.
	* @return State of state machine is in success state.
	*/
	bool CMCContext::InstanceStateIsSuccessful(const std::string & sInstanceName)
	{
		bool resultIsSuccessful = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_InstanceStateIsSuccessful(m_pHandle, sInstanceName.c_str(), &resultIsSuccessful));
		
		return resultIsSuccessful;
	}
	
	/**
	* CMCContext::InstanceStateHasFailed - returns if an instance thread is in failure state.
	* @param[in] sInstanceName - Instance name of state machine.
	* @return State of state machine is in failure state.
	*/
	bool CMCContext::InstanceStateHasFailed(const std::string & sInstanceName)
	{
		bool resultIsSuccessful = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_InstanceStateHasFailed(m_pHandle, sInstanceName.c_str(), &resultIsSuccessful));
		
		return resultIsSuccessful;
	}
	
	/**
	* CMCContext::LoadClientPackage - load a client package to serve the client website.
	* @param[in] sResourcePath - Path to the resource package.
	*/
	void CMCContext::LoadClientPackage(const std::string & sResourcePath)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_LoadClientPackage(m_pHandle, sResourcePath.c_str()));
	}
	
	/**
	* CMCContext::Log - log message with a certain log level.
	* @param[in] sMessage - log message
	* @param[in] eSubsystem - log subsystem
	* @param[in] eLogLevel - log level
	*/
	void CMCContext::Log(const std::string & sMessage, const eLogSubSystem eSubsystem, const eLogLevel eLogLevel)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_Log(m_pHandle, sMessage.c_str(), eSubsystem, eLogLevel));
	}
	
	/**
	* CMCContext::CreateAPIRequestHandler - creates an API request handler.
	* @param[in] sURI - URI to serve
	* @param[in] sRequestMethod - Request Method
	* @param[in] sAuthorization - Authorization Header String
	* @return Request Handler instance.
	*/
	PAPIRequestHandler CMCContext::CreateAPIRequestHandler(const std::string & sURI, const std::string & sRequestMethod, const std::string & sAuthorization)
	{
		LibMCHandle hHandlerInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_MCContext_CreateAPIRequestHandler(m_pHandle, sURI.c_str(), sRequestMethod.c_str(), sAuthorization.c_str(), &hHandlerInstance));
		
		if (!hHandlerInstance) {
			CheckError(LIBMC_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CAPIRequestHandler>(m_pWrapper, hHandlerInstance);
	}

} // namespace LibMC

#endif // __LIBMC_CPPHEADER_DYNAMIC_CPP

