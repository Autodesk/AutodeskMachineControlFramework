/*++

Copyright (C) 2021 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++-Header file in order to allow an easy
 use of LibRasterizer

Interface version: 1.0.0

*/

#ifndef __LIBRASTERIZER_CPPHEADER_DYNAMIC_CPP
#define __LIBRASTERIZER_CPPHEADER_DYNAMIC_CPP

#include "librasterizer_types.hpp"
#include "librasterizer_dynamic.h"


#ifdef _WIN32
#include <windows.h>
#else // _WIN32
#include <dlfcn.h>
#endif // _WIN32
#include <string>
#include <memory>
#include <vector>
#include <exception>

namespace LibRasterizer {

/*************************************************************************************************************************
 Forward Declaration of all classes
**************************************************************************************************************************/
class CWrapper;
class CBase;
class CImageObject;
class CLayerObject;
class CRasterizer;
class CSliceStack;
class CContext;

/*************************************************************************************************************************
 Declaration of deprecated class types
**************************************************************************************************************************/
typedef CWrapper CLibRasterizerWrapper;
typedef CBase CLibRasterizerBase;
typedef CImageObject CLibRasterizerImageObject;
typedef CLayerObject CLibRasterizerLayerObject;
typedef CRasterizer CLibRasterizerRasterizer;
typedef CSliceStack CLibRasterizerSliceStack;
typedef CContext CLibRasterizerContext;

/*************************************************************************************************************************
 Declaration of shared pointer types
**************************************************************************************************************************/
typedef std::shared_ptr<CWrapper> PWrapper;
typedef std::shared_ptr<CBase> PBase;
typedef std::shared_ptr<CImageObject> PImageObject;
typedef std::shared_ptr<CLayerObject> PLayerObject;
typedef std::shared_ptr<CRasterizer> PRasterizer;
typedef std::shared_ptr<CSliceStack> PSliceStack;
typedef std::shared_ptr<CContext> PContext;

/*************************************************************************************************************************
 Declaration of deprecated shared pointer types
**************************************************************************************************************************/
typedef PWrapper PLibRasterizerWrapper;
typedef PBase PLibRasterizerBase;
typedef PImageObject PLibRasterizerImageObject;
typedef PLayerObject PLibRasterizerLayerObject;
typedef PRasterizer PLibRasterizerRasterizer;
typedef PSliceStack PLibRasterizerSliceStack;
typedef PContext PLibRasterizerContext;


/*************************************************************************************************************************
 classParam Definition
**************************************************************************************************************************/

template<class T> class classParam {
private:
	const T* m_ptr;

public:
	classParam(const T* ptr)
		: m_ptr (ptr)
	{
	}

	classParam(std::shared_ptr <T> sharedPtr)
		: m_ptr (sharedPtr.get())
	{
	}

	LibRasterizerHandle GetHandle()
	{
		if (m_ptr != nullptr)
			return m_ptr->handle();
		return nullptr;
	}
};

/*************************************************************************************************************************
 Class ELibRasterizerException 
**************************************************************************************************************************/
class ELibRasterizerException : public std::exception {
protected:
	/**
	* Error code for the Exception.
	*/
	LibRasterizerResult m_errorCode;
	/**
	* Error message for the Exception.
	*/
	std::string m_errorMessage;

public:
	/**
	* Exception Constructor.
	*/
	ELibRasterizerException(LibRasterizerResult errorCode, const std::string & sErrorMessage)
		: m_errorMessage("LibRasterizer Error " + std::to_string(errorCode) + " (" + sErrorMessage + ")")
	{
		m_errorCode = errorCode;
	}

	/**
	* Returns error code
	*/
	LibRasterizerResult getErrorCode() const noexcept
	{
		return m_errorCode;
	}

	/**
	* Returns error message
	*/
	const char* what() const noexcept
	{
		return m_errorMessage.c_str();
	}

};

/*************************************************************************************************************************
 Class CInputVector
**************************************************************************************************************************/
template <typename T>
class CInputVector {
private:
	
	const T* m_data;
	size_t m_size;
	
public:
	
	CInputVector( const std::vector<T>& vec)
		: m_data( vec.data() ), m_size( vec.size() )
	{
	}
	
	CInputVector( const T* in_data, size_t in_size)
		: m_data( in_data ), m_size(in_size )
	{
	}
	
	const T* data() const
	{
		return m_data;
	}
	
	size_t size() const
	{
		return m_size;
	}
	
};

// declare deprecated class name
template<typename T>
using CLibRasterizerInputVector = CInputVector<T>;

/*************************************************************************************************************************
 Class CWrapper 
**************************************************************************************************************************/
class CWrapper {
public:
	
	CWrapper(void* pSymbolLookupMethod)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTableFromSymbolLookupMethod(&m_WrapperTable, pSymbolLookupMethod));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	CWrapper(const std::string &sFileName)
	{
		CheckError(nullptr, initWrapperTable(&m_WrapperTable));
		CheckError(nullptr, loadWrapperTable(&m_WrapperTable, sFileName.c_str()));
		
		CheckError(nullptr, checkBinaryVersion());
	}
	
	static PWrapper loadLibrary(const std::string &sFileName)
	{
		return std::make_shared<CWrapper>(sFileName);
	}
	
	static PWrapper loadLibraryFromSymbolLookupMethod(void* pSymbolLookupMethod)
	{
		return std::make_shared<CWrapper>(pSymbolLookupMethod);
	}
	
	~CWrapper()
	{
		releaseWrapperTable(&m_WrapperTable);
	}
	
	inline void CheckError(CBase * pBaseClass, LibRasterizerResult nResult);

	inline void GetVersion(LibRasterizer_uint32 & nMajor, LibRasterizer_uint32 & nMinor, LibRasterizer_uint32 & nMicro);
	inline bool GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage);
	inline void ReleaseInstance(classParam<CBase> pInstance);
	inline void AcquireInstance(classParam<CBase> pInstance);
	inline void InjectComponent(const std::string & sNameSpace, const LibRasterizer_pvoid pSymbolAddressMethod);
	inline LibRasterizer_pvoid GetSymbolLookupMethod();
	inline PContext CreateContext();

private:
	sLibRasterizerDynamicWrapperTable m_WrapperTable;
	
	LibRasterizerResult checkBinaryVersion()
	{
		LibRasterizer_uint32 nMajor, nMinor, nMicro;
		GetVersion(nMajor, nMinor, nMicro);
		if ( (nMajor != LIBRASTERIZER_VERSION_MAJOR) || (nMinor < LIBRASTERIZER_VERSION_MINOR) ) {
			return LIBRASTERIZER_ERROR_INCOMPATIBLEBINARYVERSION;
		}
		return LIBRASTERIZER_SUCCESS;
	}
	LibRasterizerResult initWrapperTable(sLibRasterizerDynamicWrapperTable * pWrapperTable);
	LibRasterizerResult releaseWrapperTable(sLibRasterizerDynamicWrapperTable * pWrapperTable);
	LibRasterizerResult loadWrapperTable(sLibRasterizerDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName);
	LibRasterizerResult loadWrapperTableFromSymbolLookupMethod(sLibRasterizerDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod);

	friend class CBase;
	friend class CImageObject;
	friend class CLayerObject;
	friend class CRasterizer;
	friend class CSliceStack;
	friend class CContext;

};

	
/*************************************************************************************************************************
 Class CBase 
**************************************************************************************************************************/
class CBase {
public:
	
protected:
	/* Wrapper Object that created the class. */
	CWrapper * m_pWrapper;
	/* Handle to Instance in library*/
	LibRasterizerHandle m_pHandle;

	/* Checks for an Error code and raises Exceptions */
	void CheckError(LibRasterizerResult nResult)
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->CheckError(this, nResult);
	}
public:
	/**
	* CBase::CBase - Constructor for Base class.
	*/
	CBase(CWrapper * pWrapper, LibRasterizerHandle pHandle)
		: m_pWrapper(pWrapper), m_pHandle(pHandle)
	{
	}

	/**
	* CBase::~CBase - Destructor for Base class.
	*/
	virtual ~CBase()
	{
		if (m_pWrapper != nullptr)
			m_pWrapper->ReleaseInstance(this);
		m_pWrapper = nullptr;
	}

	/**
	* CBase::handle - Returns handle to instance.
	*/
	LibRasterizerHandle handle() const
	{
		return m_pHandle;
	}

	/**
	* CBase::wrapper - Returns wrapper instance.
	*/
	CWrapper * wrapper() const
	{
		return m_pWrapper;
	}
	
	friend class CWrapper;
};
	
/*************************************************************************************************************************
 Class CImageObject 
**************************************************************************************************************************/
class CImageObject : public CBase {
public:
	
	/**
	* CImageObject::CImageObject - Constructor for ImageObject class.
	*/
	CImageObject(CWrapper* pWrapper, LibRasterizerHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void GetDPI(LibRasterizer_double & dDPIValueX, LibRasterizer_double & dDPIValueY);
	inline void GetSize(LibRasterizer_double & dSizeX, LibRasterizer_double & dSizeY);
	inline void GetPixelSize(LibRasterizer_uint32 & nPixelSizeX, LibRasterizer_uint32 & nPixelSizeY);
	inline void SaveToPNG(const std::string & sFileName);
	inline void Clear(const LibRasterizer_uint8 nValue);
	inline LibRasterizer_uint8 GetPixel(const LibRasterizer_uint32 nX, const LibRasterizer_uint32 nY);
	inline void SetPixel(const LibRasterizer_uint32 nX, const LibRasterizer_uint32 nY, const LibRasterizer_uint8 nValue);
	inline void GetPixelRange(const LibRasterizer_uint32 nXMin, const LibRasterizer_uint32 nYMin, const LibRasterizer_uint32 nXMax, const LibRasterizer_uint32 nYMax, std::vector<LibRasterizer_uint8> & ValueBuffer);
	inline void SetPixelRange(const LibRasterizer_uint32 nXMin, const LibRasterizer_uint32 nYMin, const LibRasterizer_uint32 nXMax, const LibRasterizer_uint32 nYMax, const CInputVector<LibRasterizer_uint8> & ValueBuffer);
};
	
/*************************************************************************************************************************
 Class CLayerObject 
**************************************************************************************************************************/
class CLayerObject : public CBase {
public:
	
	/**
	* CLayerObject::CLayerObject - Constructor for LayerObject class.
	*/
	CLayerObject(CWrapper* pWrapper, LibRasterizerHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibRasterizer_uint32 GetEntityCount();
	inline void GetEntity(const LibRasterizer_uint32 nEntityIndex, eGeometryType & eGeometryType, std::vector<sPosition2D> & PointsBuffer);
	inline LibRasterizer_uint32 AddEntity(const CInputVector<sPosition2D> & PointsBuffer, const eGeometryType eGeometryType);
	inline PLayerObject RemoveSelfIntersections();
	inline void MergeInto(classParam<CLayerObject> pOtherLayerObject);
	inline PLayerObject CalculateOffset(const LibRasterizer_double dOffsetValue);
	inline PLayerObject ThickenPolylines(const LibRasterizer_double dThickness);
	inline PLayerObject ThickenHatches(const LibRasterizer_double dThickness);
	inline PLayerObject DistortLayer(const LibRasterizer_double dRefinementValue, const DistortionCallback pDistortionCallback, const LibRasterizer_pvoid pUserData);
};
	
/*************************************************************************************************************************
 Class CRasterizer 
**************************************************************************************************************************/
class CRasterizer : public CBase {
public:
	
	/**
	* CRasterizer::CRasterizer - Constructor for Rasterizer class.
	*/
	CRasterizer(CWrapper* pWrapper, LibRasterizerHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline void GetDPI(LibRasterizer_double & dDPIValueX, LibRasterizer_double & dDPIValueY);
	inline void GetSize(LibRasterizer_double & dSizeX, LibRasterizer_double & dSizeY);
	inline void GetPixelSize(LibRasterizer_uint32 & nPixelSizeX, LibRasterizer_uint32 & nPixelSizeY);
	inline void GetPosition(LibRasterizer_double & dPositionX, LibRasterizer_double & dPositionY);
	inline void SetPosition(const LibRasterizer_double dPositionX, const LibRasterizer_double dPositionY);
	inline void SetSubsampling(const LibRasterizer_uint32 nSubsamplingX, const LibRasterizer_uint32 nSubsamplingY);
	inline void GetSubsampling(LibRasterizer_uint32 & nSubsamplingX, LibRasterizer_uint32 & nSubsamplingY);
	inline void AddLayer(classParam<CLayerObject> pLayerObject);
	inline PImageObject CalculateImage(const bool bAntialiased);
};
	
/*************************************************************************************************************************
 Class CSliceStack 
**************************************************************************************************************************/
class CSliceStack : public CBase {
public:
	
	/**
	* CSliceStack::CSliceStack - Constructor for SliceStack class.
	*/
	CSliceStack(CWrapper* pWrapper, LibRasterizerHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline LibRasterizer_uint32 GetLayerCount();
	inline LibRasterizer_double GetLayerThickness();
	inline LibRasterizer_double GetBottomZ();
	inline LibRasterizer_double GetTopZ();
	inline PLayerObject GetLayer(const LibRasterizer_uint32 nLayerIndex);
};
	
/*************************************************************************************************************************
 Class CContext 
**************************************************************************************************************************/
class CContext : public CBase {
public:
	
	/**
	* CContext::CContext - Constructor for Context class.
	*/
	CContext(CWrapper* pWrapper, LibRasterizerHandle pHandle)
		: CBase(pWrapper, pHandle)
	{
	}
	
	inline PSliceStack CreateSliceStack(const LibRasterizer_uint32 nLayerCount, const LibRasterizer_double dLayerThickness, const LibRasterizer_double dBottomZ);
	inline PLayerObject CreateEmptyLayer();
	inline PRasterizer CreateRasterizer(const LibRasterizer_uint32 nPixelSizeX, const LibRasterizer_uint32 nPixelSizeY, const LibRasterizer_double dDPIX, const LibRasterizer_double dDPIY);
};
	
	/**
	* CWrapper::GetVersion - retrieves the binary version of this library.
	* @param[out] nMajor - returns the major version of this library
	* @param[out] nMinor - returns the minor version of this library
	* @param[out] nMicro - returns the micro version of this library
	*/
	inline void CWrapper::GetVersion(LibRasterizer_uint32 & nMajor, LibRasterizer_uint32 & nMinor, LibRasterizer_uint32 & nMicro)
	{
		CheckError(nullptr,m_WrapperTable.m_GetVersion(&nMajor, &nMinor, &nMicro));
	}
	
	/**
	* CWrapper::GetLastError - Returns the last error recorded on this object
	* @param[in] pInstance - Instance Handle
	* @param[out] sErrorMessage - Message of the last error
	* @return Is there a last error to query
	*/
	inline bool CWrapper::GetLastError(classParam<CBase> pInstance, std::string & sErrorMessage)
	{
		LibRasterizerHandle hInstance = pInstance.GetHandle();
		LibRasterizer_uint32 bytesNeededErrorMessage = 0;
		LibRasterizer_uint32 bytesWrittenErrorMessage = 0;
		bool resultHasError = 0;
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, 0, &bytesNeededErrorMessage, nullptr, &resultHasError));
		std::vector<char> bufferErrorMessage(bytesNeededErrorMessage);
		CheckError(nullptr,m_WrapperTable.m_GetLastError(hInstance, bytesNeededErrorMessage, &bytesWrittenErrorMessage, &bufferErrorMessage[0], &resultHasError));
		sErrorMessage = std::string(&bufferErrorMessage[0]);
		
		return resultHasError;
	}
	
	/**
	* CWrapper::ReleaseInstance - Releases shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::ReleaseInstance(classParam<CBase> pInstance)
	{
		LibRasterizerHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_ReleaseInstance(hInstance));
	}
	
	/**
	* CWrapper::AcquireInstance - Acquires shared ownership of an Instance
	* @param[in] pInstance - Instance Handle
	*/
	inline void CWrapper::AcquireInstance(classParam<CBase> pInstance)
	{
		LibRasterizerHandle hInstance = pInstance.GetHandle();
		CheckError(nullptr,m_WrapperTable.m_AcquireInstance(hInstance));
	}
	
	/**
	* CWrapper::InjectComponent - Injects an imported component for usage within this component
	* @param[in] sNameSpace - NameSpace of the injected component
	* @param[in] pSymbolAddressMethod - Address of the SymbolAddressMethod of the injected component
	*/
	inline void CWrapper::InjectComponent(const std::string & sNameSpace, const LibRasterizer_pvoid pSymbolAddressMethod)
	{
		CheckError(nullptr,m_WrapperTable.m_InjectComponent(sNameSpace.c_str(), pSymbolAddressMethod));
		
		bool bNameSpaceFound = false;
		if (!bNameSpaceFound)
			throw ELibRasterizerException(LIBRASTERIZER_ERROR_COULDNOTLOADLIBRARY, "Unknown namespace " + sNameSpace);
	}
	
	/**
	* CWrapper::GetSymbolLookupMethod - Returns the address of the SymbolLookupMethod
	* @return Address of the SymbolAddressMethod
	*/
	inline LibRasterizer_pvoid CWrapper::GetSymbolLookupMethod()
	{
		LibRasterizer_pvoid resultSymbolLookupMethod = 0;
		CheckError(nullptr,m_WrapperTable.m_GetSymbolLookupMethod(&resultSymbolLookupMethod));
		
		return resultSymbolLookupMethod;
	}
	
	/**
	* CWrapper::CreateContext - Creates a new context.
	* @return New Context instance
	*/
	inline PContext CWrapper::CreateContext()
	{
		LibRasterizerHandle hInstance = nullptr;
		CheckError(nullptr,m_WrapperTable.m_CreateContext(&hInstance));
		
		if (!hInstance) {
			CheckError(nullptr,LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CContext>(this, hInstance);
	}
	
	inline void CWrapper::CheckError(CBase * pBaseClass, LibRasterizerResult nResult)
	{
		if (nResult != 0) {
			std::string sErrorMessage;
			if (pBaseClass != nullptr) {
				GetLastError(pBaseClass, sErrorMessage);
			}
			throw ELibRasterizerException(nResult, sErrorMessage);
		}
	}
	

	inline LibRasterizerResult CWrapper::initWrapperTable(sLibRasterizerDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBRASTERIZER_ERROR_INVALIDPARAM;
		
		pWrapperTable->m_LibraryHandle = nullptr;
		pWrapperTable->m_ImageObject_GetDPI = nullptr;
		pWrapperTable->m_ImageObject_GetSize = nullptr;
		pWrapperTable->m_ImageObject_GetPixelSize = nullptr;
		pWrapperTable->m_ImageObject_SaveToPNG = nullptr;
		pWrapperTable->m_ImageObject_Clear = nullptr;
		pWrapperTable->m_ImageObject_GetPixel = nullptr;
		pWrapperTable->m_ImageObject_SetPixel = nullptr;
		pWrapperTable->m_ImageObject_GetPixelRange = nullptr;
		pWrapperTable->m_ImageObject_SetPixelRange = nullptr;
		pWrapperTable->m_LayerObject_GetEntityCount = nullptr;
		pWrapperTable->m_LayerObject_GetEntity = nullptr;
		pWrapperTable->m_LayerObject_AddEntity = nullptr;
		pWrapperTable->m_LayerObject_RemoveSelfIntersections = nullptr;
		pWrapperTable->m_LayerObject_MergeInto = nullptr;
		pWrapperTable->m_LayerObject_CalculateOffset = nullptr;
		pWrapperTable->m_LayerObject_ThickenPolylines = nullptr;
		pWrapperTable->m_LayerObject_ThickenHatches = nullptr;
		pWrapperTable->m_LayerObject_DistortLayer = nullptr;
		pWrapperTable->m_Rasterizer_GetDPI = nullptr;
		pWrapperTable->m_Rasterizer_GetSize = nullptr;
		pWrapperTable->m_Rasterizer_GetPixelSize = nullptr;
		pWrapperTable->m_Rasterizer_GetPosition = nullptr;
		pWrapperTable->m_Rasterizer_SetPosition = nullptr;
		pWrapperTable->m_Rasterizer_SetSubsampling = nullptr;
		pWrapperTable->m_Rasterizer_GetSubsampling = nullptr;
		pWrapperTable->m_Rasterizer_AddLayer = nullptr;
		pWrapperTable->m_Rasterizer_CalculateImage = nullptr;
		pWrapperTable->m_SliceStack_GetLayerCount = nullptr;
		pWrapperTable->m_SliceStack_GetLayerThickness = nullptr;
		pWrapperTable->m_SliceStack_GetBottomZ = nullptr;
		pWrapperTable->m_SliceStack_GetTopZ = nullptr;
		pWrapperTable->m_SliceStack_GetLayer = nullptr;
		pWrapperTable->m_Context_CreateSliceStack = nullptr;
		pWrapperTable->m_Context_CreateEmptyLayer = nullptr;
		pWrapperTable->m_Context_CreateRasterizer = nullptr;
		pWrapperTable->m_GetVersion = nullptr;
		pWrapperTable->m_GetLastError = nullptr;
		pWrapperTable->m_ReleaseInstance = nullptr;
		pWrapperTable->m_AcquireInstance = nullptr;
		pWrapperTable->m_InjectComponent = nullptr;
		pWrapperTable->m_GetSymbolLookupMethod = nullptr;
		pWrapperTable->m_CreateContext = nullptr;
		
		return LIBRASTERIZER_SUCCESS;
	}

	inline LibRasterizerResult CWrapper::releaseWrapperTable(sLibRasterizerDynamicWrapperTable * pWrapperTable)
	{
		if (pWrapperTable == nullptr)
			return LIBRASTERIZER_ERROR_INVALIDPARAM;
		
		if (pWrapperTable->m_LibraryHandle != nullptr) {
		#ifdef _WIN32
			HMODULE hModule = (HMODULE) pWrapperTable->m_LibraryHandle;
			FreeLibrary(hModule);
		#else // _WIN32
			dlclose(pWrapperTable->m_LibraryHandle);
		#endif // _WIN32
			return initWrapperTable(pWrapperTable);
		}
		
		return LIBRASTERIZER_SUCCESS;
	}

	inline LibRasterizerResult CWrapper::loadWrapperTable(sLibRasterizerDynamicWrapperTable * pWrapperTable, const char * pLibraryFileName)
	{
		if (pWrapperTable == nullptr)
			return LIBRASTERIZER_ERROR_INVALIDPARAM;
		if (pLibraryFileName == nullptr)
			return LIBRASTERIZER_ERROR_INVALIDPARAM;
		
		#ifdef _WIN32
		// Convert filename to UTF16-string
		int nLength = (int)strlen(pLibraryFileName);
		int nBufferSize = nLength * 2 + 2;
		std::vector<wchar_t> wsLibraryFileName(nBufferSize);
		int nResult = MultiByteToWideChar(CP_UTF8, 0, pLibraryFileName, nLength, &wsLibraryFileName[0], nBufferSize);
		if (nResult == 0)
			return LIBRASTERIZER_ERROR_COULDNOTLOADLIBRARY;
		
		HMODULE hLibrary = LoadLibraryW(wsLibraryFileName.data());
		if (hLibrary == 0) 
			return LIBRASTERIZER_ERROR_COULDNOTLOADLIBRARY;
		#else // _WIN32
		void* hLibrary = dlopen(pLibraryFileName, RTLD_LAZY);
		if (hLibrary == 0) 
			return LIBRASTERIZER_ERROR_COULDNOTLOADLIBRARY;
		dlerror();
		#endif // _WIN32
		
		#ifdef _WIN32
		pWrapperTable->m_ImageObject_GetDPI = (PLibRasterizerImageObject_GetDPIPtr) GetProcAddress(hLibrary, "librasterizer_imageobject_getdpi");
		#else // _WIN32
		pWrapperTable->m_ImageObject_GetDPI = (PLibRasterizerImageObject_GetDPIPtr) dlsym(hLibrary, "librasterizer_imageobject_getdpi");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageObject_GetDPI == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageObject_GetSize = (PLibRasterizerImageObject_GetSizePtr) GetProcAddress(hLibrary, "librasterizer_imageobject_getsize");
		#else // _WIN32
		pWrapperTable->m_ImageObject_GetSize = (PLibRasterizerImageObject_GetSizePtr) dlsym(hLibrary, "librasterizer_imageobject_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageObject_GetSize == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageObject_GetPixelSize = (PLibRasterizerImageObject_GetPixelSizePtr) GetProcAddress(hLibrary, "librasterizer_imageobject_getpixelsize");
		#else // _WIN32
		pWrapperTable->m_ImageObject_GetPixelSize = (PLibRasterizerImageObject_GetPixelSizePtr) dlsym(hLibrary, "librasterizer_imageobject_getpixelsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageObject_GetPixelSize == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageObject_SaveToPNG = (PLibRasterizerImageObject_SaveToPNGPtr) GetProcAddress(hLibrary, "librasterizer_imageobject_savetopng");
		#else // _WIN32
		pWrapperTable->m_ImageObject_SaveToPNG = (PLibRasterizerImageObject_SaveToPNGPtr) dlsym(hLibrary, "librasterizer_imageobject_savetopng");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageObject_SaveToPNG == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageObject_Clear = (PLibRasterizerImageObject_ClearPtr) GetProcAddress(hLibrary, "librasterizer_imageobject_clear");
		#else // _WIN32
		pWrapperTable->m_ImageObject_Clear = (PLibRasterizerImageObject_ClearPtr) dlsym(hLibrary, "librasterizer_imageobject_clear");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageObject_Clear == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageObject_GetPixel = (PLibRasterizerImageObject_GetPixelPtr) GetProcAddress(hLibrary, "librasterizer_imageobject_getpixel");
		#else // _WIN32
		pWrapperTable->m_ImageObject_GetPixel = (PLibRasterizerImageObject_GetPixelPtr) dlsym(hLibrary, "librasterizer_imageobject_getpixel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageObject_GetPixel == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageObject_SetPixel = (PLibRasterizerImageObject_SetPixelPtr) GetProcAddress(hLibrary, "librasterizer_imageobject_setpixel");
		#else // _WIN32
		pWrapperTable->m_ImageObject_SetPixel = (PLibRasterizerImageObject_SetPixelPtr) dlsym(hLibrary, "librasterizer_imageobject_setpixel");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageObject_SetPixel == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageObject_GetPixelRange = (PLibRasterizerImageObject_GetPixelRangePtr) GetProcAddress(hLibrary, "librasterizer_imageobject_getpixelrange");
		#else // _WIN32
		pWrapperTable->m_ImageObject_GetPixelRange = (PLibRasterizerImageObject_GetPixelRangePtr) dlsym(hLibrary, "librasterizer_imageobject_getpixelrange");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageObject_GetPixelRange == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ImageObject_SetPixelRange = (PLibRasterizerImageObject_SetPixelRangePtr) GetProcAddress(hLibrary, "librasterizer_imageobject_setpixelrange");
		#else // _WIN32
		pWrapperTable->m_ImageObject_SetPixelRange = (PLibRasterizerImageObject_SetPixelRangePtr) dlsym(hLibrary, "librasterizer_imageobject_setpixelrange");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ImageObject_SetPixelRange == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_GetEntityCount = (PLibRasterizerLayerObject_GetEntityCountPtr) GetProcAddress(hLibrary, "librasterizer_layerobject_getentitycount");
		#else // _WIN32
		pWrapperTable->m_LayerObject_GetEntityCount = (PLibRasterizerLayerObject_GetEntityCountPtr) dlsym(hLibrary, "librasterizer_layerobject_getentitycount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_GetEntityCount == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_GetEntity = (PLibRasterizerLayerObject_GetEntityPtr) GetProcAddress(hLibrary, "librasterizer_layerobject_getentity");
		#else // _WIN32
		pWrapperTable->m_LayerObject_GetEntity = (PLibRasterizerLayerObject_GetEntityPtr) dlsym(hLibrary, "librasterizer_layerobject_getentity");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_GetEntity == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_AddEntity = (PLibRasterizerLayerObject_AddEntityPtr) GetProcAddress(hLibrary, "librasterizer_layerobject_addentity");
		#else // _WIN32
		pWrapperTable->m_LayerObject_AddEntity = (PLibRasterizerLayerObject_AddEntityPtr) dlsym(hLibrary, "librasterizer_layerobject_addentity");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_AddEntity == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_RemoveSelfIntersections = (PLibRasterizerLayerObject_RemoveSelfIntersectionsPtr) GetProcAddress(hLibrary, "librasterizer_layerobject_removeselfintersections");
		#else // _WIN32
		pWrapperTable->m_LayerObject_RemoveSelfIntersections = (PLibRasterizerLayerObject_RemoveSelfIntersectionsPtr) dlsym(hLibrary, "librasterizer_layerobject_removeselfintersections");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_RemoveSelfIntersections == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_MergeInto = (PLibRasterizerLayerObject_MergeIntoPtr) GetProcAddress(hLibrary, "librasterizer_layerobject_mergeinto");
		#else // _WIN32
		pWrapperTable->m_LayerObject_MergeInto = (PLibRasterizerLayerObject_MergeIntoPtr) dlsym(hLibrary, "librasterizer_layerobject_mergeinto");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_MergeInto == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_CalculateOffset = (PLibRasterizerLayerObject_CalculateOffsetPtr) GetProcAddress(hLibrary, "librasterizer_layerobject_calculateoffset");
		#else // _WIN32
		pWrapperTable->m_LayerObject_CalculateOffset = (PLibRasterizerLayerObject_CalculateOffsetPtr) dlsym(hLibrary, "librasterizer_layerobject_calculateoffset");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_CalculateOffset == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_ThickenPolylines = (PLibRasterizerLayerObject_ThickenPolylinesPtr) GetProcAddress(hLibrary, "librasterizer_layerobject_thickenpolylines");
		#else // _WIN32
		pWrapperTable->m_LayerObject_ThickenPolylines = (PLibRasterizerLayerObject_ThickenPolylinesPtr) dlsym(hLibrary, "librasterizer_layerobject_thickenpolylines");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_ThickenPolylines == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_ThickenHatches = (PLibRasterizerLayerObject_ThickenHatchesPtr) GetProcAddress(hLibrary, "librasterizer_layerobject_thickenhatches");
		#else // _WIN32
		pWrapperTable->m_LayerObject_ThickenHatches = (PLibRasterizerLayerObject_ThickenHatchesPtr) dlsym(hLibrary, "librasterizer_layerobject_thickenhatches");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_ThickenHatches == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_LayerObject_DistortLayer = (PLibRasterizerLayerObject_DistortLayerPtr) GetProcAddress(hLibrary, "librasterizer_layerobject_distortlayer");
		#else // _WIN32
		pWrapperTable->m_LayerObject_DistortLayer = (PLibRasterizerLayerObject_DistortLayerPtr) dlsym(hLibrary, "librasterizer_layerobject_distortlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_LayerObject_DistortLayer == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetDPI = (PLibRasterizerRasterizer_GetDPIPtr) GetProcAddress(hLibrary, "librasterizer_rasterizer_getdpi");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetDPI = (PLibRasterizerRasterizer_GetDPIPtr) dlsym(hLibrary, "librasterizer_rasterizer_getdpi");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetDPI == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetSize = (PLibRasterizerRasterizer_GetSizePtr) GetProcAddress(hLibrary, "librasterizer_rasterizer_getsize");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetSize = (PLibRasterizerRasterizer_GetSizePtr) dlsym(hLibrary, "librasterizer_rasterizer_getsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetSize == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetPixelSize = (PLibRasterizerRasterizer_GetPixelSizePtr) GetProcAddress(hLibrary, "librasterizer_rasterizer_getpixelsize");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetPixelSize = (PLibRasterizerRasterizer_GetPixelSizePtr) dlsym(hLibrary, "librasterizer_rasterizer_getpixelsize");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetPixelSize == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetPosition = (PLibRasterizerRasterizer_GetPositionPtr) GetProcAddress(hLibrary, "librasterizer_rasterizer_getposition");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetPosition = (PLibRasterizerRasterizer_GetPositionPtr) dlsym(hLibrary, "librasterizer_rasterizer_getposition");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetPosition == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_SetPosition = (PLibRasterizerRasterizer_SetPositionPtr) GetProcAddress(hLibrary, "librasterizer_rasterizer_setposition");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_SetPosition = (PLibRasterizerRasterizer_SetPositionPtr) dlsym(hLibrary, "librasterizer_rasterizer_setposition");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_SetPosition == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_SetSubsampling = (PLibRasterizerRasterizer_SetSubsamplingPtr) GetProcAddress(hLibrary, "librasterizer_rasterizer_setsubsampling");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_SetSubsampling = (PLibRasterizerRasterizer_SetSubsamplingPtr) dlsym(hLibrary, "librasterizer_rasterizer_setsubsampling");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_SetSubsampling == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_GetSubsampling = (PLibRasterizerRasterizer_GetSubsamplingPtr) GetProcAddress(hLibrary, "librasterizer_rasterizer_getsubsampling");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_GetSubsampling = (PLibRasterizerRasterizer_GetSubsamplingPtr) dlsym(hLibrary, "librasterizer_rasterizer_getsubsampling");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_GetSubsampling == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_AddLayer = (PLibRasterizerRasterizer_AddLayerPtr) GetProcAddress(hLibrary, "librasterizer_rasterizer_addlayer");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_AddLayer = (PLibRasterizerRasterizer_AddLayerPtr) dlsym(hLibrary, "librasterizer_rasterizer_addlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_AddLayer == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Rasterizer_CalculateImage = (PLibRasterizerRasterizer_CalculateImagePtr) GetProcAddress(hLibrary, "librasterizer_rasterizer_calculateimage");
		#else // _WIN32
		pWrapperTable->m_Rasterizer_CalculateImage = (PLibRasterizerRasterizer_CalculateImagePtr) dlsym(hLibrary, "librasterizer_rasterizer_calculateimage");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Rasterizer_CalculateImage == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetLayerCount = (PLibRasterizerSliceStack_GetLayerCountPtr) GetProcAddress(hLibrary, "librasterizer_slicestack_getlayercount");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetLayerCount = (PLibRasterizerSliceStack_GetLayerCountPtr) dlsym(hLibrary, "librasterizer_slicestack_getlayercount");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetLayerCount == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetLayerThickness = (PLibRasterizerSliceStack_GetLayerThicknessPtr) GetProcAddress(hLibrary, "librasterizer_slicestack_getlayerthickness");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetLayerThickness = (PLibRasterizerSliceStack_GetLayerThicknessPtr) dlsym(hLibrary, "librasterizer_slicestack_getlayerthickness");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetLayerThickness == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetBottomZ = (PLibRasterizerSliceStack_GetBottomZPtr) GetProcAddress(hLibrary, "librasterizer_slicestack_getbottomz");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetBottomZ = (PLibRasterizerSliceStack_GetBottomZPtr) dlsym(hLibrary, "librasterizer_slicestack_getbottomz");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetBottomZ == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetTopZ = (PLibRasterizerSliceStack_GetTopZPtr) GetProcAddress(hLibrary, "librasterizer_slicestack_gettopz");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetTopZ = (PLibRasterizerSliceStack_GetTopZPtr) dlsym(hLibrary, "librasterizer_slicestack_gettopz");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetTopZ == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_SliceStack_GetLayer = (PLibRasterizerSliceStack_GetLayerPtr) GetProcAddress(hLibrary, "librasterizer_slicestack_getlayer");
		#else // _WIN32
		pWrapperTable->m_SliceStack_GetLayer = (PLibRasterizerSliceStack_GetLayerPtr) dlsym(hLibrary, "librasterizer_slicestack_getlayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_SliceStack_GetLayer == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Context_CreateSliceStack = (PLibRasterizerContext_CreateSliceStackPtr) GetProcAddress(hLibrary, "librasterizer_context_createslicestack");
		#else // _WIN32
		pWrapperTable->m_Context_CreateSliceStack = (PLibRasterizerContext_CreateSliceStackPtr) dlsym(hLibrary, "librasterizer_context_createslicestack");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Context_CreateSliceStack == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Context_CreateEmptyLayer = (PLibRasterizerContext_CreateEmptyLayerPtr) GetProcAddress(hLibrary, "librasterizer_context_createemptylayer");
		#else // _WIN32
		pWrapperTable->m_Context_CreateEmptyLayer = (PLibRasterizerContext_CreateEmptyLayerPtr) dlsym(hLibrary, "librasterizer_context_createemptylayer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Context_CreateEmptyLayer == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_Context_CreateRasterizer = (PLibRasterizerContext_CreateRasterizerPtr) GetProcAddress(hLibrary, "librasterizer_context_createrasterizer");
		#else // _WIN32
		pWrapperTable->m_Context_CreateRasterizer = (PLibRasterizerContext_CreateRasterizerPtr) dlsym(hLibrary, "librasterizer_context_createrasterizer");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_Context_CreateRasterizer == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetVersion = (PLibRasterizerGetVersionPtr) GetProcAddress(hLibrary, "librasterizer_getversion");
		#else // _WIN32
		pWrapperTable->m_GetVersion = (PLibRasterizerGetVersionPtr) dlsym(hLibrary, "librasterizer_getversion");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetVersion == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetLastError = (PLibRasterizerGetLastErrorPtr) GetProcAddress(hLibrary, "librasterizer_getlasterror");
		#else // _WIN32
		pWrapperTable->m_GetLastError = (PLibRasterizerGetLastErrorPtr) dlsym(hLibrary, "librasterizer_getlasterror");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetLastError == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibRasterizerReleaseInstancePtr) GetProcAddress(hLibrary, "librasterizer_releaseinstance");
		#else // _WIN32
		pWrapperTable->m_ReleaseInstance = (PLibRasterizerReleaseInstancePtr) dlsym(hLibrary, "librasterizer_releaseinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_ReleaseInstance == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_AcquireInstance = (PLibRasterizerAcquireInstancePtr) GetProcAddress(hLibrary, "librasterizer_acquireinstance");
		#else // _WIN32
		pWrapperTable->m_AcquireInstance = (PLibRasterizerAcquireInstancePtr) dlsym(hLibrary, "librasterizer_acquireinstance");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_AcquireInstance == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_InjectComponent = (PLibRasterizerInjectComponentPtr) GetProcAddress(hLibrary, "librasterizer_injectcomponent");
		#else // _WIN32
		pWrapperTable->m_InjectComponent = (PLibRasterizerInjectComponentPtr) dlsym(hLibrary, "librasterizer_injectcomponent");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_InjectComponent == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibRasterizerGetSymbolLookupMethodPtr) GetProcAddress(hLibrary, "librasterizer_getsymbollookupmethod");
		#else // _WIN32
		pWrapperTable->m_GetSymbolLookupMethod = (PLibRasterizerGetSymbolLookupMethodPtr) dlsym(hLibrary, "librasterizer_getsymbollookupmethod");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_GetSymbolLookupMethod == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		#ifdef _WIN32
		pWrapperTable->m_CreateContext = (PLibRasterizerCreateContextPtr) GetProcAddress(hLibrary, "librasterizer_createcontext");
		#else // _WIN32
		pWrapperTable->m_CreateContext = (PLibRasterizerCreateContextPtr) dlsym(hLibrary, "librasterizer_createcontext");
		dlerror();
		#endif // _WIN32
		if (pWrapperTable->m_CreateContext == nullptr)
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		pWrapperTable->m_LibraryHandle = hLibrary;
		return LIBRASTERIZER_SUCCESS;
	}

	inline LibRasterizerResult CWrapper::loadWrapperTableFromSymbolLookupMethod(sLibRasterizerDynamicWrapperTable * pWrapperTable, void* pSymbolLookupMethod)
{
		if (pWrapperTable == nullptr)
			return LIBRASTERIZER_ERROR_INVALIDPARAM;
		if (pSymbolLookupMethod == nullptr)
			return LIBRASTERIZER_ERROR_INVALIDPARAM;
		
		typedef LibRasterizerResult(*SymbolLookupType)(const char*, void**);
		
		SymbolLookupType pLookup = (SymbolLookupType)pSymbolLookupMethod;
		
		LibRasterizerResult eLookupError = LIBRASTERIZER_SUCCESS;
		eLookupError = (*pLookup)("librasterizer_imageobject_getdpi", (void**)&(pWrapperTable->m_ImageObject_GetDPI));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageObject_GetDPI == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_imageobject_getsize", (void**)&(pWrapperTable->m_ImageObject_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageObject_GetSize == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_imageobject_getpixelsize", (void**)&(pWrapperTable->m_ImageObject_GetPixelSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageObject_GetPixelSize == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_imageobject_savetopng", (void**)&(pWrapperTable->m_ImageObject_SaveToPNG));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageObject_SaveToPNG == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_imageobject_clear", (void**)&(pWrapperTable->m_ImageObject_Clear));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageObject_Clear == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_imageobject_getpixel", (void**)&(pWrapperTable->m_ImageObject_GetPixel));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageObject_GetPixel == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_imageobject_setpixel", (void**)&(pWrapperTable->m_ImageObject_SetPixel));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageObject_SetPixel == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_imageobject_getpixelrange", (void**)&(pWrapperTable->m_ImageObject_GetPixelRange));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageObject_GetPixelRange == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_imageobject_setpixelrange", (void**)&(pWrapperTable->m_ImageObject_SetPixelRange));
		if ( (eLookupError != 0) || (pWrapperTable->m_ImageObject_SetPixelRange == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_layerobject_getentitycount", (void**)&(pWrapperTable->m_LayerObject_GetEntityCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_GetEntityCount == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_layerobject_getentity", (void**)&(pWrapperTable->m_LayerObject_GetEntity));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_GetEntity == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_layerobject_addentity", (void**)&(pWrapperTable->m_LayerObject_AddEntity));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_AddEntity == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_layerobject_removeselfintersections", (void**)&(pWrapperTable->m_LayerObject_RemoveSelfIntersections));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_RemoveSelfIntersections == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_layerobject_mergeinto", (void**)&(pWrapperTable->m_LayerObject_MergeInto));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_MergeInto == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_layerobject_calculateoffset", (void**)&(pWrapperTable->m_LayerObject_CalculateOffset));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_CalculateOffset == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_layerobject_thickenpolylines", (void**)&(pWrapperTable->m_LayerObject_ThickenPolylines));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_ThickenPolylines == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_layerobject_thickenhatches", (void**)&(pWrapperTable->m_LayerObject_ThickenHatches));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_ThickenHatches == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_layerobject_distortlayer", (void**)&(pWrapperTable->m_LayerObject_DistortLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_LayerObject_DistortLayer == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_rasterizer_getdpi", (void**)&(pWrapperTable->m_Rasterizer_GetDPI));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetDPI == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_rasterizer_getsize", (void**)&(pWrapperTable->m_Rasterizer_GetSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetSize == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_rasterizer_getpixelsize", (void**)&(pWrapperTable->m_Rasterizer_GetPixelSize));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetPixelSize == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_rasterizer_getposition", (void**)&(pWrapperTable->m_Rasterizer_GetPosition));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetPosition == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_rasterizer_setposition", (void**)&(pWrapperTable->m_Rasterizer_SetPosition));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_SetPosition == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_rasterizer_setsubsampling", (void**)&(pWrapperTable->m_Rasterizer_SetSubsampling));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_SetSubsampling == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_rasterizer_getsubsampling", (void**)&(pWrapperTable->m_Rasterizer_GetSubsampling));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_GetSubsampling == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_rasterizer_addlayer", (void**)&(pWrapperTable->m_Rasterizer_AddLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_AddLayer == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_rasterizer_calculateimage", (void**)&(pWrapperTable->m_Rasterizer_CalculateImage));
		if ( (eLookupError != 0) || (pWrapperTable->m_Rasterizer_CalculateImage == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_slicestack_getlayercount", (void**)&(pWrapperTable->m_SliceStack_GetLayerCount));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetLayerCount == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_slicestack_getlayerthickness", (void**)&(pWrapperTable->m_SliceStack_GetLayerThickness));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetLayerThickness == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_slicestack_getbottomz", (void**)&(pWrapperTable->m_SliceStack_GetBottomZ));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetBottomZ == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_slicestack_gettopz", (void**)&(pWrapperTable->m_SliceStack_GetTopZ));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetTopZ == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_slicestack_getlayer", (void**)&(pWrapperTable->m_SliceStack_GetLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_SliceStack_GetLayer == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_context_createslicestack", (void**)&(pWrapperTable->m_Context_CreateSliceStack));
		if ( (eLookupError != 0) || (pWrapperTable->m_Context_CreateSliceStack == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_context_createemptylayer", (void**)&(pWrapperTable->m_Context_CreateEmptyLayer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Context_CreateEmptyLayer == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_context_createrasterizer", (void**)&(pWrapperTable->m_Context_CreateRasterizer));
		if ( (eLookupError != 0) || (pWrapperTable->m_Context_CreateRasterizer == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_getversion", (void**)&(pWrapperTable->m_GetVersion));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetVersion == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_getlasterror", (void**)&(pWrapperTable->m_GetLastError));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetLastError == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_releaseinstance", (void**)&(pWrapperTable->m_ReleaseInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_ReleaseInstance == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_acquireinstance", (void**)&(pWrapperTable->m_AcquireInstance));
		if ( (eLookupError != 0) || (pWrapperTable->m_AcquireInstance == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_injectcomponent", (void**)&(pWrapperTable->m_InjectComponent));
		if ( (eLookupError != 0) || (pWrapperTable->m_InjectComponent == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_getsymbollookupmethod", (void**)&(pWrapperTable->m_GetSymbolLookupMethod));
		if ( (eLookupError != 0) || (pWrapperTable->m_GetSymbolLookupMethod == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		eLookupError = (*pLookup)("librasterizer_createcontext", (void**)&(pWrapperTable->m_CreateContext));
		if ( (eLookupError != 0) || (pWrapperTable->m_CreateContext == nullptr) )
			return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
		
		return LIBRASTERIZER_SUCCESS;
}

	
	
	/**
	 * Method definitions for class CBase
	 */
	
	/**
	 * Method definitions for class CImageObject
	 */
	
	/**
	* CImageObject::GetDPI - Returns DPI values in X and Y.
	* @param[out] dDPIValueX - DPI value in X
	* @param[out] dDPIValueY - DPI value in Y
	*/
	void CImageObject::GetDPI(LibRasterizer_double & dDPIValueX, LibRasterizer_double & dDPIValueY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_GetDPI(m_pHandle, &dDPIValueX, &dDPIValueY));
	}
	
	/**
	* CImageObject::GetSize - Returns image sizes.
	* @param[out] dSizeX - Size in X in mm
	* @param[out] dSizeY - Size in Y in mm
	*/
	void CImageObject::GetSize(LibRasterizer_double & dSizeX, LibRasterizer_double & dSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_GetSize(m_pHandle, &dSizeX, &dSizeY));
	}
	
	/**
	* CImageObject::GetPixelSize - Returns image pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	void CImageObject::GetPixelSize(LibRasterizer_uint32 & nPixelSizeX, LibRasterizer_uint32 & nPixelSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_GetPixelSize(m_pHandle, &nPixelSizeX, &nPixelSizeY));
	}
	
	/**
	* CImageObject::SaveToPNG - Saves image in a PNG file.
	* @param[in] sFileName - Filename to save image to.
	*/
	void CImageObject::SaveToPNG(const std::string & sFileName)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_SaveToPNG(m_pHandle, sFileName.c_str()));
	}
	
	/**
	* CImageObject::Clear - Sets all pixels to a single value.
	* @param[in] nValue - Pixel value.
	*/
	void CImageObject::Clear(const LibRasterizer_uint8 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_Clear(m_pHandle, nValue));
	}
	
	/**
	* CImageObject::GetPixel - Returns one pixel of an image.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @return Pixel value at this position
	*/
	LibRasterizer_uint8 CImageObject::GetPixel(const LibRasterizer_uint32 nX, const LibRasterizer_uint32 nY)
	{
		LibRasterizer_uint8 resultValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_GetPixel(m_pHandle, nX, nY, &resultValue));
		
		return resultValue;
	}
	
	/**
	* CImageObject::SetPixel - Sets one pixel of an image.
	* @param[in] nX - Pixel coordinate in X
	* @param[in] nY - Pixel coordinate in Y
	* @param[in] nValue - New Pixel value at this position
	*/
	void CImageObject::SetPixel(const LibRasterizer_uint32 nX, const LibRasterizer_uint32 nY, const LibRasterizer_uint8 nValue)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_SetPixel(m_pHandle, nX, nY, nValue));
	}
	
	/**
	* CImageObject::GetPixelRange - Returns a subset of an image or the whole image data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within image bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within image bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within image bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within image bounds. MUST be larger or equal than MinY
	* @param[out] ValueBuffer - Pixel values of the rectangle, rowwise array. MUST have the exact number of pixels in size.
	*/
	void CImageObject::GetPixelRange(const LibRasterizer_uint32 nXMin, const LibRasterizer_uint32 nYMin, const LibRasterizer_uint32 nXMax, const LibRasterizer_uint32 nYMax, std::vector<LibRasterizer_uint8> & ValueBuffer)
	{
		LibRasterizer_uint64 elementsNeededValue = 0;
		LibRasterizer_uint64 elementsWrittenValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_GetPixelRange(m_pHandle, nXMin, nYMin, nXMax, nYMax, 0, &elementsNeededValue, nullptr));
		ValueBuffer.resize((size_t) elementsNeededValue);
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_GetPixelRange(m_pHandle, nXMin, nYMin, nXMax, nYMax, elementsNeededValue, &elementsWrittenValue, ValueBuffer.data()));
	}
	
	/**
	* CImageObject::SetPixelRange - Exchanges a subset of an image or the whole image data.
	* @param[in] nXMin - Min Pixel coordinate in X. MUST be within image bounds.
	* @param[in] nYMin - Min Pixel coordinate in Y. MUST be within image bounds.
	* @param[in] nXMax - Max Pixel coordinate in X. MUST be within image bounds. MUST be larger or equal than MinX
	* @param[in] nYMax - Max Pixel coordinate in Y. MUST be within image bounds. MUST be larger or equal than MinY
	* @param[in] ValueBuffer - New pixel values of the rectangle, rowwise array. MUST have the exact number of pixels in size.
	*/
	void CImageObject::SetPixelRange(const LibRasterizer_uint32 nXMin, const LibRasterizer_uint32 nYMin, const LibRasterizer_uint32 nXMax, const LibRasterizer_uint32 nYMax, const CInputVector<LibRasterizer_uint8> & ValueBuffer)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_ImageObject_SetPixelRange(m_pHandle, nXMin, nYMin, nXMax, nYMax, (LibRasterizer_uint64)ValueBuffer.size(), ValueBuffer.data()));
	}
	
	/**
	 * Method definitions for class CLayerObject
	 */
	
	/**
	* CLayerObject::GetEntityCount - Returns count of Entity in Layer.
	* @return Number of entity in layer.
	*/
	LibRasterizer_uint32 CLayerObject::GetEntityCount()
	{
		LibRasterizer_uint32 resultEntityCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_GetEntityCount(m_pHandle, &resultEntityCount));
		
		return resultEntityCount;
	}
	
	/**
	* CLayerObject::GetEntity - Returns a entity in a layer.
	* @param[in] nEntityIndex - Index of entity in layer.
	* @param[out] eGeometryType - Geometry type of Entity.
	* @param[out] PointsBuffer - Points of Entity.
	*/
	void CLayerObject::GetEntity(const LibRasterizer_uint32 nEntityIndex, eGeometryType & eGeometryType, std::vector<sPosition2D> & PointsBuffer)
	{
		LibRasterizer_uint64 elementsNeededPoints = 0;
		LibRasterizer_uint64 elementsWrittenPoints = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_GetEntity(m_pHandle, nEntityIndex, &eGeometryType, 0, &elementsNeededPoints, nullptr));
		PointsBuffer.resize((size_t) elementsNeededPoints);
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_GetEntity(m_pHandle, nEntityIndex, &eGeometryType, elementsNeededPoints, &elementsWrittenPoints, PointsBuffer.data()));
	}
	
	/**
	* CLayerObject::AddEntity - Adds a entity to a layer.
	* @param[in] PointsBuffer - Points of Entity.
	* @param[in] eGeometryType - Geometry type of Entity.
	* @return Index of entity in layer.
	*/
	LibRasterizer_uint32 CLayerObject::AddEntity(const CInputVector<sPosition2D> & PointsBuffer, const eGeometryType eGeometryType)
	{
		LibRasterizer_uint32 resultEntityIndex = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_AddEntity(m_pHandle, (LibRasterizer_uint64)PointsBuffer.size(), PointsBuffer.data(), eGeometryType, &resultEntityIndex));
		
		return resultEntityIndex;
	}
	
	/**
	* CLayerObject::RemoveSelfIntersections - Removes self-intersections of a layer.
	* @return New Layer Object Instance
	*/
	PLayerObject CLayerObject::RemoveSelfIntersections()
	{
		LibRasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_RemoveSelfIntersections(m_pHandle, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	* CLayerObject::MergeInto - Merges layer into another layer object.
	* @param[in] pOtherLayerObject - Layer object to modify.
	*/
	void CLayerObject::MergeInto(classParam<CLayerObject> pOtherLayerObject)
	{
		LibRasterizerHandle hOtherLayerObject = pOtherLayerObject.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_MergeInto(m_pHandle, hOtherLayerObject));
	}
	
	/**
	* CLayerObject::CalculateOffset - Calculates an offset to a layer.
	* @param[in] dOffsetValue - Offset in mm
	* @return Offsetted Layer Object Instance
	*/
	PLayerObject CLayerObject::CalculateOffset(const LibRasterizer_double dOffsetValue)
	{
		LibRasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_CalculateOffset(m_pHandle, dOffsetValue, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	* CLayerObject::ThickenPolylines - Thickens up polylines of a layer.
	* @param[in] dThickness - Thickness in mm
	* @return Offsetted Layer Object Instance
	*/
	PLayerObject CLayerObject::ThickenPolylines(const LibRasterizer_double dThickness)
	{
		LibRasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_ThickenPolylines(m_pHandle, dThickness, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	* CLayerObject::ThickenHatches - Thickens up hatches of a layer.
	* @param[in] dThickness - Thickness in mm
	* @return Offsetted Layer Object Instance
	*/
	PLayerObject CLayerObject::ThickenHatches(const LibRasterizer_double dThickness)
	{
		LibRasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_ThickenHatches(m_pHandle, dThickness, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	* CLayerObject::DistortLayer - Distorts a layer with a callback function
	* @param[in] dRefinementValue - Lines longer than this value are split up in smaller segments to not loose distortion information.
	* @param[in] pDistortionCallback - pointer to the callback function.
	* @param[in] pUserData - pointer to arbitrary user data that is passed without modification to the callback.
	* @return Offsetted Layer Object Instance
	*/
	PLayerObject CLayerObject::DistortLayer(const LibRasterizer_double dRefinementValue, const DistortionCallback pDistortionCallback, const LibRasterizer_pvoid pUserData)
	{
		LibRasterizerHandle hLayerObjectInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_LayerObject_DistortLayer(m_pHandle, dRefinementValue, pDistortionCallback, pUserData, &hLayerObjectInstance));
		
		if (!hLayerObjectInstance) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObjectInstance);
	}
	
	/**
	 * Method definitions for class CRasterizer
	 */
	
	/**
	* CRasterizer::GetDPI - Returns DPI values in X and Y.
	* @param[out] dDPIValueX - DPI value in X
	* @param[out] dDPIValueY - DPI value in Y
	*/
	void CRasterizer::GetDPI(LibRasterizer_double & dDPIValueX, LibRasterizer_double & dDPIValueY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetDPI(m_pHandle, &dDPIValueX, &dDPIValueY));
	}
	
	/**
	* CRasterizer::GetSize - Returns image sizes.
	* @param[out] dSizeX - Size in X in mm
	* @param[out] dSizeY - Size in Y in mm
	*/
	void CRasterizer::GetSize(LibRasterizer_double & dSizeX, LibRasterizer_double & dSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetSize(m_pHandle, &dSizeX, &dSizeY));
	}
	
	/**
	* CRasterizer::GetPixelSize - Returns image pixel sizes.
	* @param[out] nPixelSizeX - Number of pixels in X
	* @param[out] nPixelSizeY - Number of pixels in Y
	*/
	void CRasterizer::GetPixelSize(LibRasterizer_uint32 & nPixelSizeX, LibRasterizer_uint32 & nPixelSizeY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetPixelSize(m_pHandle, &nPixelSizeX, &nPixelSizeY));
	}
	
	/**
	* CRasterizer::GetPosition - Returns image position.
	* @param[out] dPositionX - Position in X in mm
	* @param[out] dPositionY - Position in Y in mm
	*/
	void CRasterizer::GetPosition(LibRasterizer_double & dPositionX, LibRasterizer_double & dPositionY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetPosition(m_pHandle, &dPositionX, &dPositionY));
	}
	
	/**
	* CRasterizer::SetPosition - Sets image position.
	* @param[in] dPositionX - Position in X in mm
	* @param[in] dPositionY - Position in Y in mm
	*/
	void CRasterizer::SetPosition(const LibRasterizer_double dPositionX, const LibRasterizer_double dPositionY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_SetPosition(m_pHandle, dPositionX, dPositionY));
	}
	
	/**
	* CRasterizer::SetSubsampling - Set subsampling values in X and Y.
	* @param[in] nSubsamplingX - Subsampling in X
	* @param[in] nSubsamplingY - Subsampling in Y
	*/
	void CRasterizer::SetSubsampling(const LibRasterizer_uint32 nSubsamplingX, const LibRasterizer_uint32 nSubsamplingY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_SetSubsampling(m_pHandle, nSubsamplingX, nSubsamplingY));
	}
	
	/**
	* CRasterizer::GetSubsampling - Returns subsampling values in X and Y.
	* @param[out] nSubsamplingX - Subsampling in X
	* @param[out] nSubsamplingY - Subsampling in Y
	*/
	void CRasterizer::GetSubsampling(LibRasterizer_uint32 & nSubsamplingX, LibRasterizer_uint32 & nSubsamplingY)
	{
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_GetSubsampling(m_pHandle, &nSubsamplingX, &nSubsamplingY));
	}
	
	/**
	* CRasterizer::AddLayer - Adds a layer object to subsample.
	* @param[in] pLayerObject - Layer object instance.
	*/
	void CRasterizer::AddLayer(classParam<CLayerObject> pLayerObject)
	{
		LibRasterizerHandle hLayerObject = pLayerObject.GetHandle();
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_AddLayer(m_pHandle, hLayerObject));
	}
	
	/**
	* CRasterizer::CalculateImage - Calculates the image.
	* @param[in] bAntialiased - Image output is greyscale if true, black and white with 0.5 threshold if false.
	* @return ImageObject Instance
	*/
	PImageObject CRasterizer::CalculateImage(const bool bAntialiased)
	{
		LibRasterizerHandle hImageObject = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Rasterizer_CalculateImage(m_pHandle, bAntialiased, &hImageObject));
		
		if (!hImageObject) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CImageObject>(m_pWrapper, hImageObject);
	}
	
	/**
	 * Method definitions for class CSliceStack
	 */
	
	/**
	* CSliceStack::GetLayerCount - Returns layer count of slice stack.
	* @return Returns number of layers
	*/
	LibRasterizer_uint32 CSliceStack::GetLayerCount()
	{
		LibRasterizer_uint32 resultLayerCount = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetLayerCount(m_pHandle, &resultLayerCount));
		
		return resultLayerCount;
	}
	
	/**
	* CSliceStack::GetLayerThickness - Returns layer thickness of slice stack.
	* @return Returns layer thickness in mm
	*/
	LibRasterizer_double CSliceStack::GetLayerThickness()
	{
		LibRasterizer_double resultLayerThickness = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetLayerThickness(m_pHandle, &resultLayerThickness));
		
		return resultLayerThickness;
	}
	
	/**
	* CSliceStack::GetBottomZ - Returns Z value of bottom of slice stack in mm.
	* @return Z-Value of bottom of slice stack
	*/
	LibRasterizer_double CSliceStack::GetBottomZ()
	{
		LibRasterizer_double resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetBottomZ(m_pHandle, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CSliceStack::GetTopZ - Returns Z value of top of slice stack in mm.
	* @return Z-Value of top of slice stack
	*/
	LibRasterizer_double CSliceStack::GetTopZ()
	{
		LibRasterizer_double resultZValue = 0;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetTopZ(m_pHandle, &resultZValue));
		
		return resultZValue;
	}
	
	/**
	* CSliceStack::GetLayer - Returns layer object for a given Z Value.
	* @param[in] nLayerIndex - Index of layer.
	* @return LayerObject Instance
	*/
	PLayerObject CSliceStack::GetLayer(const LibRasterizer_uint32 nLayerIndex)
	{
		LibRasterizerHandle hLayerObject = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_SliceStack_GetLayer(m_pHandle, nLayerIndex, &hLayerObject));
		
		if (!hLayerObject) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObject);
	}
	
	/**
	 * Method definitions for class CContext
	 */
	
	/**
	* CContext::CreateSliceStack - creates an empty slice stack.
	* @param[in] nLayerCount - Number of layers. MUST be positive.
	* @param[in] dLayerThickness - Layerthickness in mm. MUST be positive.
	* @param[in] dBottomZ - Bottom Z value in mm.
	* @return Instance of Slice Stack
	*/
	PSliceStack CContext::CreateSliceStack(const LibRasterizer_uint32 nLayerCount, const LibRasterizer_double dLayerThickness, const LibRasterizer_double dBottomZ)
	{
		LibRasterizerHandle hSliceStackInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Context_CreateSliceStack(m_pHandle, nLayerCount, dLayerThickness, dBottomZ, &hSliceStackInstance));
		
		if (!hSliceStackInstance) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CSliceStack>(m_pWrapper, hSliceStackInstance);
	}
	
	/**
	* CContext::CreateEmptyLayer - creates an empty layer object.
	* @return Instance of a Layer Object
	*/
	PLayerObject CContext::CreateEmptyLayer()
	{
		LibRasterizerHandle hLayerObject = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Context_CreateEmptyLayer(m_pHandle, &hLayerObject));
		
		if (!hLayerObject) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CLayerObject>(m_pWrapper, hLayerObject);
	}
	
	/**
	* CContext::CreateRasterizer - creates a rasterizer object.
	* @param[in] nPixelSizeX - Pixel size in X. MUST be positive.
	* @param[in] nPixelSizeY - Pixel size in Y. MUST be positive.
	* @param[in] dDPIX - DPI in X. MUST be positive.
	* @param[in] dDPIY - DPI in Y. MUST be positive.
	* @return Instance of Rasterizer
	*/
	PRasterizer CContext::CreateRasterizer(const LibRasterizer_uint32 nPixelSizeX, const LibRasterizer_uint32 nPixelSizeY, const LibRasterizer_double dDPIX, const LibRasterizer_double dDPIY)
	{
		LibRasterizerHandle hRasterizerInstance = nullptr;
		CheckError(m_pWrapper->m_WrapperTable.m_Context_CreateRasterizer(m_pHandle, nPixelSizeX, nPixelSizeY, dDPIX, dDPIY, &hRasterizerInstance));
		
		if (!hRasterizerInstance) {
			CheckError(LIBRASTERIZER_ERROR_INVALIDPARAM);
		}
		return std::make_shared<CRasterizer>(m_pWrapper, hRasterizerInstance);
	}

} // namespace LibRasterizer

#endif // __LIBRASTERIZER_CPPHEADER_DYNAMIC_CPP

