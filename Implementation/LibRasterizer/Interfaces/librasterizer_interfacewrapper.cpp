/*++

Copyright (C) 2021 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated C++ implementation file in order to allow easy
development of LibRasterizer. The functions in this file need to be implemented. It needs to be generated only once.

Interface version: 1.0.0

*/

#include "librasterizer_abi.hpp"
#include "librasterizer_interfaces.hpp"
#include "librasterizer_interfaceexception.hpp"

#include <map>

using namespace LibRasterizer::Impl;

LibRasterizerResult handleLibRasterizerException(IBase * pIBaseClass, ELibRasterizerInterfaceException & Exception)
{
	LibRasterizerResult errorCode = Exception.getErrorCode();

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibRasterizerResult handleStdException(IBase * pIBaseClass, std::exception & Exception)
{
	LibRasterizerResult errorCode = LIBRASTERIZER_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage(Exception.what());

	return errorCode;
}

LibRasterizerResult handleUnhandledException(IBase * pIBaseClass)
{
	LibRasterizerResult errorCode = LIBRASTERIZER_ERROR_GENERICEXCEPTION;

	if (pIBaseClass != nullptr)
		pIBaseClass->RegisterErrorMessage("Unhandled Exception");

	return errorCode;
}



/*************************************************************************************************************************
 Class implementation for Base
**************************************************************************************************************************/

/*************************************************************************************************************************
 Class implementation for ImageObject
**************************************************************************************************************************/
LibRasterizerResult librasterizer_imageobject_getdpi(LibRasterizer_ImageObject pImageObject, LibRasterizer_double * pDPIValueX, LibRasterizer_double * pDPIValueY)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if (!pDPIValueX)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pDPIValueY)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->GetDPI(*pDPIValueX, *pDPIValueY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_imageobject_getsize(LibRasterizer_ImageObject pImageObject, LibRasterizer_double * pSizeX, LibRasterizer_double * pSizeY)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if (!pSizeX)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pSizeY)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->GetSize(*pSizeX, *pSizeY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_imageobject_getpixelsize(LibRasterizer_ImageObject pImageObject, LibRasterizer_uint32 * pPixelSizeX, LibRasterizer_uint32 * pPixelSizeY)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if (!pPixelSizeX)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pPixelSizeY)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->GetPixelSize(*pPixelSizeX, *pPixelSizeY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_imageobject_savetopng(LibRasterizer_ImageObject pImageObject, const char * pFileName)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if (pFileName == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		std::string sFileName(pFileName);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->SaveToPNG(sFileName);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_imageobject_clear(LibRasterizer_ImageObject pImageObject, LibRasterizer_uint8 nValue)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->Clear(nValue);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_imageobject_getpixel(LibRasterizer_ImageObject pImageObject, LibRasterizer_uint32 nX, LibRasterizer_uint32 nY, LibRasterizer_uint8 * pValue)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if (pValue == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		*pValue = pIImageObject->GetPixel(nX, nY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_imageobject_setpixel(LibRasterizer_ImageObject pImageObject, LibRasterizer_uint32 nX, LibRasterizer_uint32 nY, LibRasterizer_uint8 nValue)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->SetPixel(nX, nY, nValue);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_imageobject_getpixelrange(LibRasterizer_ImageObject pImageObject, LibRasterizer_uint32 nXMin, LibRasterizer_uint32 nYMin, LibRasterizer_uint32 nXMax, LibRasterizer_uint32 nYMax, const LibRasterizer_uint64 nValueBufferSize, LibRasterizer_uint64* pValueNeededCount, LibRasterizer_uint8 * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if ((!pValueBuffer) && !(pValueNeededCount))
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->GetPixelRange(nXMin, nYMin, nXMax, nYMax, nValueBufferSize, pValueNeededCount, pValueBuffer);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_imageobject_setpixelrange(LibRasterizer_ImageObject pImageObject, LibRasterizer_uint32 nXMin, LibRasterizer_uint32 nYMin, LibRasterizer_uint32 nXMax, LibRasterizer_uint32 nYMax, LibRasterizer_uint64 nValueBufferSize, const LibRasterizer_uint8 * pValueBuffer)
{
	IBase* pIBaseClass = (IBase *)pImageObject;

	try {
		if ( (!pValueBuffer) && (nValueBufferSize>0))
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IImageObject* pIImageObject = dynamic_cast<IImageObject*>(pIBaseClass);
		if (!pIImageObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIImageObject->SetPixelRange(nXMin, nYMin, nXMax, nYMax, nValueBufferSize, pValueBuffer);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for LayerObject
**************************************************************************************************************************/
LibRasterizerResult librasterizer_layerobject_getentitycount(LibRasterizer_LayerObject pLayerObject, LibRasterizer_uint32 * pEntityCount)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pEntityCount == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		*pEntityCount = pILayerObject->GetEntityCount();

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_layerobject_getentity(LibRasterizer_LayerObject pLayerObject, LibRasterizer_uint32 nEntityIndex, eLibRasterizerGeometryType * pGeometryType, const LibRasterizer_uint64 nPointsBufferSize, LibRasterizer_uint64* pPointsNeededCount, sLibRasterizerPosition2D * pPointsBuffer)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (!pGeometryType)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if ((!pPointsBuffer) && !(pPointsNeededCount))
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pILayerObject->GetEntity(nEntityIndex, *pGeometryType, nPointsBufferSize, pPointsNeededCount, pPointsBuffer);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_layerobject_addentity(LibRasterizer_LayerObject pLayerObject, LibRasterizer_uint64 nPointsBufferSize, const sLibRasterizerPosition2D * pPointsBuffer, eLibRasterizerGeometryType eGeometryType, LibRasterizer_uint32 * pEntityIndex)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if ( (!pPointsBuffer) && (nPointsBufferSize>0))
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (pEntityIndex == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		*pEntityIndex = pILayerObject->AddEntity(nPointsBufferSize, pPointsBuffer, eGeometryType);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_layerobject_removeselfintersections(LibRasterizer_LayerObject pLayerObject, LibRasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->RemoveSelfIntersections();

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_layerobject_mergeinto(LibRasterizer_LayerObject pLayerObject, LibRasterizer_LayerObject pOtherLayerObject)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		IBase* pIBaseClassOtherLayerObject = (IBase *)pOtherLayerObject;
		ILayerObject* pIOtherLayerObject = dynamic_cast<ILayerObject*>(pIBaseClassOtherLayerObject);
		if (!pIOtherLayerObject)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDCAST);
		
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pILayerObject->MergeInto(pIOtherLayerObject);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_layerobject_calculateoffset(LibRasterizer_LayerObject pLayerObject, LibRasterizer_double dOffsetValue, LibRasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->CalculateOffset(dOffsetValue);

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_layerobject_thickenpolylines(LibRasterizer_LayerObject pLayerObject, LibRasterizer_double dThickness, LibRasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->ThickenPolylines(dThickness);

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_layerobject_thickenhatches(LibRasterizer_LayerObject pLayerObject, LibRasterizer_double dThickness, LibRasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->ThickenHatches(dThickness);

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_layerobject_distortlayer(LibRasterizer_LayerObject pLayerObject, LibRasterizer_double dRefinementValue, LibRasterizerDistortionCallback pDistortionCallback, LibRasterizer_pvoid pUserData, LibRasterizer_LayerObject * pLayerObjectInstance)
{
	IBase* pIBaseClass = (IBase *)pLayerObject;

	try {
		if (pLayerObjectInstance == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObjectInstance(nullptr);
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClass);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObjectInstance = pILayerObject->DistortLayer(dRefinementValue, pDistortionCallback, pUserData);

		*pLayerObjectInstance = (IBase*)(pBaseLayerObjectInstance);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Rasterizer
**************************************************************************************************************************/
LibRasterizerResult librasterizer_rasterizer_getdpi(LibRasterizer_Rasterizer pRasterizer, LibRasterizer_double * pDPIValueX, LibRasterizer_double * pDPIValueY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pDPIValueX)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pDPIValueY)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetDPI(*pDPIValueX, *pDPIValueY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_rasterizer_getsize(LibRasterizer_Rasterizer pRasterizer, LibRasterizer_double * pSizeX, LibRasterizer_double * pSizeY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pSizeX)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pSizeY)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetSize(*pSizeX, *pSizeY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_rasterizer_getpixelsize(LibRasterizer_Rasterizer pRasterizer, LibRasterizer_uint32 * pPixelSizeX, LibRasterizer_uint32 * pPixelSizeY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pPixelSizeX)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pPixelSizeY)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetPixelSize(*pPixelSizeX, *pPixelSizeY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_rasterizer_getposition(LibRasterizer_Rasterizer pRasterizer, LibRasterizer_double * pPositionX, LibRasterizer_double * pPositionY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pPositionX)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pPositionY)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetPosition(*pPositionX, *pPositionY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_rasterizer_setposition(LibRasterizer_Rasterizer pRasterizer, LibRasterizer_double dPositionX, LibRasterizer_double dPositionY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->SetPosition(dPositionX, dPositionY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_rasterizer_setsubsampling(LibRasterizer_Rasterizer pRasterizer, LibRasterizer_uint32 nSubsamplingX, LibRasterizer_uint32 nSubsamplingY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->SetSubsampling(nSubsamplingX, nSubsamplingY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_rasterizer_getsubsampling(LibRasterizer_Rasterizer pRasterizer, LibRasterizer_uint32 * pSubsamplingX, LibRasterizer_uint32 * pSubsamplingY)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (!pSubsamplingX)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pSubsamplingY)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->GetSubsampling(*pSubsamplingX, *pSubsamplingY);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_rasterizer_addlayer(LibRasterizer_Rasterizer pRasterizer, LibRasterizer_LayerObject pLayerObject)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		IBase* pIBaseClassLayerObject = (IBase *)pLayerObject;
		ILayerObject* pILayerObject = dynamic_cast<ILayerObject*>(pIBaseClassLayerObject);
		if (!pILayerObject)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDCAST);
		
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pIRasterizer->AddLayer(pILayerObject);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_rasterizer_calculateimage(LibRasterizer_Rasterizer pRasterizer, bool bAntialiased, LibRasterizer_ImageObject * pImageObject)
{
	IBase* pIBaseClass = (IBase *)pRasterizer;

	try {
		if (pImageObject == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseImageObject(nullptr);
		IRasterizer* pIRasterizer = dynamic_cast<IRasterizer*>(pIBaseClass);
		if (!pIRasterizer)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseImageObject = pIRasterizer->CalculateImage(bAntialiased);

		*pImageObject = (IBase*)(pBaseImageObject);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for SliceStack
**************************************************************************************************************************/
LibRasterizerResult librasterizer_slicestack_getlayercount(LibRasterizer_SliceStack pSliceStack, LibRasterizer_uint32 * pLayerCount)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pLayerCount == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		*pLayerCount = pISliceStack->GetLayerCount();

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_slicestack_getlayerthickness(LibRasterizer_SliceStack pSliceStack, LibRasterizer_double * pLayerThickness)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pLayerThickness == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		*pLayerThickness = pISliceStack->GetLayerThickness();

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_slicestack_getbottomz(LibRasterizer_SliceStack pSliceStack, LibRasterizer_double * pZValue)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pZValue == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		*pZValue = pISliceStack->GetBottomZ();

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_slicestack_gettopz(LibRasterizer_SliceStack pSliceStack, LibRasterizer_double * pZValue)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pZValue == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		*pZValue = pISliceStack->GetTopZ();

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_slicestack_getlayer(LibRasterizer_SliceStack pSliceStack, LibRasterizer_uint32 nLayerIndex, LibRasterizer_LayerObject * pLayerObject)
{
	IBase* pIBaseClass = (IBase *)pSliceStack;

	try {
		if (pLayerObject == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObject(nullptr);
		ISliceStack* pISliceStack = dynamic_cast<ISliceStack*>(pIBaseClass);
		if (!pISliceStack)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObject = pISliceStack->GetLayer(nLayerIndex);

		*pLayerObject = (IBase*)(pBaseLayerObject);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


/*************************************************************************************************************************
 Class implementation for Context
**************************************************************************************************************************/
LibRasterizerResult librasterizer_context_createslicestack(LibRasterizer_Context pContext, LibRasterizer_uint32 nLayerCount, LibRasterizer_double dLayerThickness, LibRasterizer_double dBottomZ, LibRasterizer_SliceStack * pSliceStackInstance)
{
	IBase* pIBaseClass = (IBase *)pContext;

	try {
		if (pSliceStackInstance == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseSliceStackInstance(nullptr);
		IContext* pIContext = dynamic_cast<IContext*>(pIBaseClass);
		if (!pIContext)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseSliceStackInstance = pIContext->CreateSliceStack(nLayerCount, dLayerThickness, dBottomZ);

		*pSliceStackInstance = (IBase*)(pBaseSliceStackInstance);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_context_createemptylayer(LibRasterizer_Context pContext, LibRasterizer_LayerObject * pLayerObject)
{
	IBase* pIBaseClass = (IBase *)pContext;

	try {
		if (pLayerObject == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseLayerObject(nullptr);
		IContext* pIContext = dynamic_cast<IContext*>(pIBaseClass);
		if (!pIContext)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseLayerObject = pIContext->CreateEmptyLayer();

		*pLayerObject = (IBase*)(pBaseLayerObject);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_context_createrasterizer(LibRasterizer_Context pContext, LibRasterizer_uint32 nPixelSizeX, LibRasterizer_uint32 nPixelSizeY, LibRasterizer_double dDPIX, LibRasterizer_double dDPIY, LibRasterizer_Rasterizer * pRasterizerInstance)
{
	IBase* pIBaseClass = (IBase *)pContext;

	try {
		if (pRasterizerInstance == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseRasterizerInstance(nullptr);
		IContext* pIContext = dynamic_cast<IContext*>(pIBaseClass);
		if (!pIContext)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_INVALIDCAST);
		
		pBaseRasterizerInstance = pIContext->CreateRasterizer(nPixelSizeX, nPixelSizeY, dDPIX, dDPIY);

		*pRasterizerInstance = (IBase*)(pBaseRasterizerInstance);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}



/*************************************************************************************************************************
 Function table lookup implementation
**************************************************************************************************************************/

LibRasterizerResult LibRasterizer::Impl::LibRasterizer_GetProcAddress (const char * pProcName, void ** ppProcAddress)
{
	if (pProcName == nullptr)
		return LIBRASTERIZER_ERROR_INVALIDPARAM;
	if (ppProcAddress == nullptr)
		return LIBRASTERIZER_ERROR_INVALIDPARAM;
	*ppProcAddress = nullptr;
	std::string sProcName (pProcName);
	
	if (sProcName == "librasterizer_imageobject_getdpi") 
		*ppProcAddress = (void*) &librasterizer_imageobject_getdpi;
	if (sProcName == "librasterizer_imageobject_getsize") 
		*ppProcAddress = (void*) &librasterizer_imageobject_getsize;
	if (sProcName == "librasterizer_imageobject_getpixelsize") 
		*ppProcAddress = (void*) &librasterizer_imageobject_getpixelsize;
	if (sProcName == "librasterizer_imageobject_savetopng") 
		*ppProcAddress = (void*) &librasterizer_imageobject_savetopng;
	if (sProcName == "librasterizer_imageobject_clear") 
		*ppProcAddress = (void*) &librasterizer_imageobject_clear;
	if (sProcName == "librasterizer_imageobject_getpixel") 
		*ppProcAddress = (void*) &librasterizer_imageobject_getpixel;
	if (sProcName == "librasterizer_imageobject_setpixel") 
		*ppProcAddress = (void*) &librasterizer_imageobject_setpixel;
	if (sProcName == "librasterizer_imageobject_getpixelrange") 
		*ppProcAddress = (void*) &librasterizer_imageobject_getpixelrange;
	if (sProcName == "librasterizer_imageobject_setpixelrange") 
		*ppProcAddress = (void*) &librasterizer_imageobject_setpixelrange;
	if (sProcName == "librasterizer_layerobject_getentitycount") 
		*ppProcAddress = (void*) &librasterizer_layerobject_getentitycount;
	if (sProcName == "librasterizer_layerobject_getentity") 
		*ppProcAddress = (void*) &librasterizer_layerobject_getentity;
	if (sProcName == "librasterizer_layerobject_addentity") 
		*ppProcAddress = (void*) &librasterizer_layerobject_addentity;
	if (sProcName == "librasterizer_layerobject_removeselfintersections") 
		*ppProcAddress = (void*) &librasterizer_layerobject_removeselfintersections;
	if (sProcName == "librasterizer_layerobject_mergeinto") 
		*ppProcAddress = (void*) &librasterizer_layerobject_mergeinto;
	if (sProcName == "librasterizer_layerobject_calculateoffset") 
		*ppProcAddress = (void*) &librasterizer_layerobject_calculateoffset;
	if (sProcName == "librasterizer_layerobject_thickenpolylines") 
		*ppProcAddress = (void*) &librasterizer_layerobject_thickenpolylines;
	if (sProcName == "librasterizer_layerobject_thickenhatches") 
		*ppProcAddress = (void*) &librasterizer_layerobject_thickenhatches;
	if (sProcName == "librasterizer_layerobject_distortlayer") 
		*ppProcAddress = (void*) &librasterizer_layerobject_distortlayer;
	if (sProcName == "librasterizer_rasterizer_getdpi") 
		*ppProcAddress = (void*) &librasterizer_rasterizer_getdpi;
	if (sProcName == "librasterizer_rasterizer_getsize") 
		*ppProcAddress = (void*) &librasterizer_rasterizer_getsize;
	if (sProcName == "librasterizer_rasterizer_getpixelsize") 
		*ppProcAddress = (void*) &librasterizer_rasterizer_getpixelsize;
	if (sProcName == "librasterizer_rasterizer_getposition") 
		*ppProcAddress = (void*) &librasterizer_rasterizer_getposition;
	if (sProcName == "librasterizer_rasterizer_setposition") 
		*ppProcAddress = (void*) &librasterizer_rasterizer_setposition;
	if (sProcName == "librasterizer_rasterizer_setsubsampling") 
		*ppProcAddress = (void*) &librasterizer_rasterizer_setsubsampling;
	if (sProcName == "librasterizer_rasterizer_getsubsampling") 
		*ppProcAddress = (void*) &librasterizer_rasterizer_getsubsampling;
	if (sProcName == "librasterizer_rasterizer_addlayer") 
		*ppProcAddress = (void*) &librasterizer_rasterizer_addlayer;
	if (sProcName == "librasterizer_rasterizer_calculateimage") 
		*ppProcAddress = (void*) &librasterizer_rasterizer_calculateimage;
	if (sProcName == "librasterizer_slicestack_getlayercount") 
		*ppProcAddress = (void*) &librasterizer_slicestack_getlayercount;
	if (sProcName == "librasterizer_slicestack_getlayerthickness") 
		*ppProcAddress = (void*) &librasterizer_slicestack_getlayerthickness;
	if (sProcName == "librasterizer_slicestack_getbottomz") 
		*ppProcAddress = (void*) &librasterizer_slicestack_getbottomz;
	if (sProcName == "librasterizer_slicestack_gettopz") 
		*ppProcAddress = (void*) &librasterizer_slicestack_gettopz;
	if (sProcName == "librasterizer_slicestack_getlayer") 
		*ppProcAddress = (void*) &librasterizer_slicestack_getlayer;
	if (sProcName == "librasterizer_context_createslicestack") 
		*ppProcAddress = (void*) &librasterizer_context_createslicestack;
	if (sProcName == "librasterizer_context_createemptylayer") 
		*ppProcAddress = (void*) &librasterizer_context_createemptylayer;
	if (sProcName == "librasterizer_context_createrasterizer") 
		*ppProcAddress = (void*) &librasterizer_context_createrasterizer;
	if (sProcName == "librasterizer_getversion") 
		*ppProcAddress = (void*) &librasterizer_getversion;
	if (sProcName == "librasterizer_getlasterror") 
		*ppProcAddress = (void*) &librasterizer_getlasterror;
	if (sProcName == "librasterizer_releaseinstance") 
		*ppProcAddress = (void*) &librasterizer_releaseinstance;
	if (sProcName == "librasterizer_acquireinstance") 
		*ppProcAddress = (void*) &librasterizer_acquireinstance;
	if (sProcName == "librasterizer_injectcomponent") 
		*ppProcAddress = (void*) &librasterizer_injectcomponent;
	if (sProcName == "librasterizer_getsymbollookupmethod") 
		*ppProcAddress = (void*) &librasterizer_getsymbollookupmethod;
	if (sProcName == "librasterizer_createcontext") 
		*ppProcAddress = (void*) &librasterizer_createcontext;
	
	if (*ppProcAddress == nullptr) 
		return LIBRASTERIZER_ERROR_COULDNOTFINDLIBRARYEXPORT;
	return LIBRASTERIZER_SUCCESS;
}

/*************************************************************************************************************************
 Global functions implementation
**************************************************************************************************************************/
LibRasterizerResult librasterizer_getversion(LibRasterizer_uint32 * pMajor, LibRasterizer_uint32 * pMinor, LibRasterizer_uint32 * pMicro)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (!pMajor)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pMinor)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (!pMicro)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		CWrapper::GetVersion(*pMajor, *pMinor, *pMicro);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_getlasterror(LibRasterizer_Base pInstance, const LibRasterizer_uint32 nErrorMessageBufferSize, LibRasterizer_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	IBase* pIBaseClass = nullptr;

	try {
		if ( (!pErrorMessageBuffer) && !(pErrorMessageNeededChars) )
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		if (pHasError == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDCAST);
		
		std::string sErrorMessage("");
		*pHasError = CWrapper::GetLastError(pIInstance, sErrorMessage);

		if (pErrorMessageNeededChars)
			*pErrorMessageNeededChars = (LibRasterizer_uint32) (sErrorMessage.size()+1);
		if (pErrorMessageBuffer) {
			if (sErrorMessage.size() >= nErrorMessageBufferSize)
				throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_BUFFERTOOSMALL);
			for (size_t iErrorMessage = 0; iErrorMessage < sErrorMessage.size(); iErrorMessage++)
				pErrorMessageBuffer[iErrorMessage] = sErrorMessage[iErrorMessage];
			pErrorMessageBuffer[sErrorMessage.size()] = 0;
		}
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_releaseinstance(LibRasterizer_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDCAST);
		
		CWrapper::ReleaseInstance(pIInstance);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_acquireinstance(LibRasterizer_Base pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		IBase* pIBaseClassInstance = (IBase *)pInstance;
		IBase* pIInstance = dynamic_cast<IBase*>(pIBaseClassInstance);
		if (!pIInstance)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDCAST);
		
		CWrapper::AcquireInstance(pIInstance);

		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_injectcomponent(const char * pNameSpace, LibRasterizer_pvoid pSymbolAddressMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pNameSpace == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		std::string sNameSpace(pNameSpace);
		
		bool bNameSpaceFound = false;
		
		
		if (!bNameSpaceFound)
			throw ELibRasterizerInterfaceException(LIBRASTERIZER_ERROR_COULDNOTLOADLIBRARY);
		
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_getsymbollookupmethod(LibRasterizer_pvoid * pSymbolLookupMethod)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pSymbolLookupMethod == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		*pSymbolLookupMethod = (void*)&LibRasterizer::Impl::LibRasterizer_GetProcAddress;
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}

LibRasterizerResult librasterizer_createcontext(LibRasterizer_Context * pInstance)
{
	IBase* pIBaseClass = nullptr;

	try {
		if (pInstance == nullptr)
			throw ELibRasterizerInterfaceException (LIBRASTERIZER_ERROR_INVALIDPARAM);
		IBase* pBaseInstance(nullptr);
		pBaseInstance = CWrapper::CreateContext();

		*pInstance = (IBase*)(pBaseInstance);
		return LIBRASTERIZER_SUCCESS;
	}
	catch (ELibRasterizerInterfaceException & Exception) {
		return handleLibRasterizerException(pIBaseClass, Exception);
	}
	catch (std::exception & StdException) {
		return handleStdException(pIBaseClass, StdException);
	}
	catch (...) {
		return handleUnhandledException(pIBaseClass);
	}
}


