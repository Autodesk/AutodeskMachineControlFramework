/*++

Copyright (C) 2020 Autodesk Inc.

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the Autodesk Inc. nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL AUTODESK INC. BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


This file has been generated by the Automatic Component Toolkit (ACT) version 1.7.0-develop.

Abstract: This is an autogenerated Go wrapper file in order to allow an easy
use of Machine Control data model library.

Interface version: 1.0.0

*/

// Code generated by Automatic Component Toolkit (ACT); DO NOT EDIT.

package libmcdata

/*
#include "libmcdata_dynamic.cc"

LibMCDataHandle loadLibMCDataLibrary (const char * pFileName)
{
	LibMCDataResult nResult;
	sLibMCDataDynamicWrapperTable * pWrapperTable = (sLibMCDataDynamicWrapperTable *) malloc (sizeof (sLibMCDataDynamicWrapperTable));
	if (pWrapperTable != NULL) {
		nResult = InitLibMCDataWrapperTable (pWrapperTable);
		if (nResult != LIBMCDATA_SUCCESS) {
			free (pWrapperTable);
			return 0;
		}

		nResult = LoadLibMCDataWrapperTable (pWrapperTable, pFileName);
		if (nResult != LIBMCDATA_SUCCESS) {
			free (pWrapperTable);
			return 0;
		}

		return (LibMCDataHandle) pWrapperTable;
	}
}

void unloadLibMCDataLibrary (LibMCDataHandle nLibraryHandle)
{
	sLibMCDataDynamicWrapperTable * pWrapperTable = (sLibMCDataDynamicWrapperTable *) malloc (sizeof (sLibMCDataDynamicWrapperTable));
	if (pWrapperTable != NULL) {
		ReleaseLibMCDataWrapperTable (pWrapperTable);
		free (pWrapperTable);
	}
}


LibMCDataResult CCall_libmcdata_iterator_movenext(LibMCDataHandle libraryHandle, LibMCData_Iterator pIterator, bool * pHasNext)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Iterator_MoveNext (pIterator, pHasNext);	
}


LibMCDataResult CCall_libmcdata_iterator_moveprevious(LibMCDataHandle libraryHandle, LibMCData_Iterator pIterator, bool * pHasPrevious)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Iterator_MovePrevious (pIterator, pHasPrevious);	
}


LibMCDataResult CCall_libmcdata_iterator_getcurrent(LibMCDataHandle libraryHandle, LibMCData_Iterator pIterator, LibMCData_Base * pCurrentInstance)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Iterator_GetCurrent (pIterator, pCurrentInstance);	
}


LibMCDataResult CCall_libmcdata_iterator_clone(LibMCDataHandle libraryHandle, LibMCData_Iterator pIterator, LibMCData_Iterator * pOutIterator)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Iterator_Clone (pIterator, pOutIterator);	
}


LibMCDataResult CCall_libmcdata_iterator_count(LibMCDataHandle libraryHandle, LibMCData_Iterator pIterator, LibMCData_uint64 * pCount)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_Iterator_Count (pIterator, pCount);	
}


LibMCDataResult CCall_libmcdata_logsession_addentry(LibMCDataHandle libraryHandle, LibMCData_LogSession pLogSession, const char * pMessage, const char * pSubSystem, eLibMCDataLogLevel eLogLevel, const char * pTimestamp)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_LogSession_AddEntry (pLogSession, pMessage, pSubSystem, eLogLevel, pTimestamp);	
}


LibMCDataResult CCall_libmcdata_storagestream_getuuid(LibMCDataHandle libraryHandle, LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StorageStream_GetUUID (pStorageStream, nUUIDBufferSize, pUUIDNeededChars, pUUIDBuffer);	
}




LibMCDataResult CCall_libmcdata_storagestream_gettimestamp(LibMCDataHandle libraryHandle, LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StorageStream_GetTimeStamp (pStorageStream, nTimestampBufferSize, pTimestampNeededChars, pTimestampBuffer);	
}


LibMCDataResult CCall_libmcdata_storagestream_getname(LibMCDataHandle libraryHandle, LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StorageStream_GetName (pStorageStream, nNameBufferSize, pNameNeededChars, pNameBuffer);	
}


LibMCDataResult CCall_libmcdata_storagestream_getmimetype(LibMCDataHandle libraryHandle, LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nMimeTypeBufferSize, LibMCData_uint32* pMimeTypeNeededChars, char * pMimeTypeBuffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StorageStream_GetMIMEType (pStorageStream, nMimeTypeBufferSize, pMimeTypeNeededChars, pMimeTypeBuffer);	
}


LibMCDataResult CCall_libmcdata_storagestream_getsha2(LibMCDataHandle libraryHandle, LibMCData_StorageStream pStorageStream, const LibMCData_uint32 nSHA2BufferSize, LibMCData_uint32* pSHA2NeededChars, char * pSHA2Buffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StorageStream_GetSHA2 (pStorageStream, nSHA2BufferSize, pSHA2NeededChars, pSHA2Buffer);	
}


LibMCDataResult CCall_libmcdata_storagestream_getsize(LibMCDataHandle libraryHandle, LibMCData_StorageStream pStorageStream, LibMCData_uint64 * pSize)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StorageStream_GetSize (pStorageStream, pSize);	
}


LibMCDataResult CCall_libmcdata_storagestream_getcontent(LibMCDataHandle libraryHandle, LibMCData_StorageStream pStorageStream, const LibMCData_uint64 nContentBufferSize, LibMCData_uint64* pContentNeededCount, LibMCData_uint8 * pContentBuffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StorageStream_GetContent (pStorageStream, nContentBufferSize, pContentNeededCount, pContentBuffer);	
}


LibMCDataResult CCall_libmcdata_storagestream_getcallbacks(LibMCDataHandle libraryHandle, LibMCData_StorageStream pStorageStream, uint64_t * pTheReadCallback, uint64_t * pTheSeekCallback, uint64_t * pStreamHandle)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_StorageStream_GetCallbacks ((void **)pStorageStream, (void **)pTheReadCallback, (void **)pTheSeekCallback, (void**)pStreamHandle);	
}



LibMCDataResult CCall_libmcdata_buildjob_getuuid(LibMCDataHandle libraryHandle, LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nUUIDBufferSize, LibMCData_uint32* pUUIDNeededChars, char * pUUIDBuffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJob_GetUUID (pBuildJob, nUUIDBufferSize, pUUIDNeededChars, pUUIDBuffer);	
}


LibMCDataResult CCall_libmcdata_buildjob_getname(LibMCDataHandle libraryHandle, LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nNameBufferSize, LibMCData_uint32* pNameNeededChars, char * pNameBuffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJob_GetName (pBuildJob, nNameBufferSize, pNameNeededChars, pNameBuffer);	
}


LibMCDataResult CCall_libmcdata_buildjob_getstatus(LibMCDataHandle libraryHandle, LibMCData_BuildJob pBuildJob, eLibMCDataBuildJobStatus * pStatus)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJob_GetStatus (pBuildJob, pStatus);	
}


LibMCDataResult CCall_libmcdata_buildjob_gettimestamp(LibMCDataHandle libraryHandle, LibMCData_BuildJob pBuildJob, const LibMCData_uint32 nTimestampBufferSize, LibMCData_uint32* pTimestampNeededChars, char * pTimestampBuffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJob_GetTimeStamp (pBuildJob, nTimestampBufferSize, pTimestampNeededChars, pTimestampBuffer);	
}


LibMCDataResult CCall_libmcdata_buildjob_getstoragestream(LibMCDataHandle libraryHandle, LibMCData_BuildJob pBuildJob, LibMCData_StorageStream * pStreamInstance)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJob_GetStorageStream (pBuildJob, pStreamInstance);	
}


LibMCDataResult CCall_libmcdata_buildjob_getbuildjoblogger(LibMCDataHandle libraryHandle, LibMCData_BuildJob pBuildJob, LibMCData_LogSession * pLogSession)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJob_GetBuildJobLogger (pBuildJob, pLogSession);	
}


LibMCDataResult CCall_libmcdata_buildjobiterator_getcurrentjob(LibMCDataHandle libraryHandle, LibMCData_BuildJobIterator pBuildJobIterator, LibMCData_BuildJob * pCurrentInstance)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJobIterator_GetCurrentJob (pBuildJobIterator, pCurrentInstance);	
}


LibMCDataResult CCall_libmcdata_buildjobhandler_createjob(LibMCDataHandle libraryHandle, LibMCData_BuildJobHandler pBuildJobHandler, const char * pJobUUID, const char * pName, const char * pUserID, LibMCData_StorageStream pStreamInstance, LibMCData_BuildJob * pJobInstance)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJobHandler_CreateJob (pBuildJobHandler, pJobUUID, pName, pUserID, pStreamInstance, pJobInstance);	
}


LibMCDataResult CCall_libmcdata_buildjobhandler_retrievejob(LibMCDataHandle libraryHandle, LibMCData_BuildJobHandler pBuildJobHandler, const char * pJobUUID, LibMCData_BuildJob * pJobInstance)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJobHandler_RetrieveJob (pBuildJobHandler, pJobUUID, pJobInstance);	
}


LibMCDataResult CCall_libmcdata_buildjobhandler_listjobsbystatus(LibMCDataHandle libraryHandle, LibMCData_BuildJobHandler pBuildJobHandler, eLibMCDataBuildJobStatus eStatus, LibMCData_BuildJobIterator * pIteratorInstance)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJobHandler_ListJobsByStatus (pBuildJobHandler, eStatus, pIteratorInstance);	
}


LibMCDataResult CCall_libmcdata_buildjobhandler_convertbuildstatustostring(LibMCDataHandle libraryHandle, LibMCData_BuildJobHandler pBuildJobHandler, eLibMCDataBuildJobStatus eStatus, const LibMCData_uint32 nStringBufferSize, LibMCData_uint32* pStringNeededChars, char * pStringBuffer)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJobHandler_ConvertBuildStatusToString (pBuildJobHandler, eStatus, nStringBufferSize, pStringNeededChars, pStringBuffer);	
}


LibMCDataResult CCall_libmcdata_buildjobhandler_convertstringtobuildstatus(LibMCDataHandle libraryHandle, LibMCData_BuildJobHandler pBuildJobHandler, const char * pString, eLibMCDataBuildJobStatus * pStatus)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_BuildJobHandler_ConvertStringToBuildStatus (pBuildJobHandler, pString, pStatus);	
}


LibMCDataResult CCall_libmcdata_datamodel_initialisedatabase(LibMCDataHandle libraryHandle, LibMCData_DataModel pDataModel, const char * pDataDirectory, eLibMCDataDataBaseType eDataBaseType, const char * pConnectionString)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataModel_InitialiseDatabase (pDataModel, pDataDirectory, eDataBaseType, pConnectionString);	
}


LibMCDataResult CCall_libmcdata_datamodel_getdatamodelversion(LibMCDataHandle libraryHandle, LibMCData_DataModel pDataModel, LibMCData_uint32 * pVersion)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataModel_GetDataModelVersion (pDataModel, pVersion);	
}


LibMCDataResult CCall_libmcdata_datamodel_createstorage(LibMCDataHandle libraryHandle, LibMCData_DataModel pDataModel, LibMCData_Storage * pStorage)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataModel_CreateStorage (pDataModel, pStorage);	
}


LibMCDataResult CCall_libmcdata_datamodel_createbuildjobhandler(LibMCDataHandle libraryHandle, LibMCData_DataModel pDataModel, LibMCData_BuildJobHandler * pBuildJobHandler)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataModel_CreateBuildJobHandler (pDataModel, pBuildJobHandler);	
}


LibMCDataResult CCall_libmcdata_datamodel_createnewlogsession(LibMCDataHandle libraryHandle, LibMCData_DataModel pDataModel, LibMCData_LogSession * pLogSession)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_DataModel_CreateNewLogSession (pDataModel, pLogSession);	
}


LibMCDataResult CCall_libmcdata_getversion(LibMCDataHandle libraryHandle, LibMCData_uint32 * pMajor, LibMCData_uint32 * pMinor, LibMCData_uint32 * pMicro)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_GetVersion (pMajor, pMinor, pMicro);	
}


LibMCDataResult CCall_libmcdata_getlasterror(LibMCDataHandle libraryHandle, LibMCData_Base pInstance, const LibMCData_uint32 nErrorMessageBufferSize, LibMCData_uint32* pErrorMessageNeededChars, char * pErrorMessageBuffer, bool * pHasError)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_GetLastError (pInstance, nErrorMessageBufferSize, pErrorMessageNeededChars, pErrorMessageBuffer, pHasError);	
}


LibMCDataResult CCall_libmcdata_releaseinstance(LibMCDataHandle libraryHandle, LibMCData_Base pInstance)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_ReleaseInstance (pInstance);	
}


LibMCDataResult CCall_libmcdata_acquireinstance(LibMCDataHandle libraryHandle, LibMCData_Base pInstance)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_AcquireInstance (pInstance);	
}


LibMCDataResult CCall_libmcdata_getsymbollookupmethod(LibMCDataHandle libraryHandle, uint64_t * pSymbolLookupMethod)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_GetSymbolLookupMethod ((LibMCData_pvoid *) pSymbolLookupMethod);	
}


LibMCDataResult CCall_libmcdata_createdatamodelinstance(LibMCDataHandle libraryHandle, LibMCData_DataModel * pInstance)
{
	if (libraryHandle == 0) 
		return LIBMCDATA_ERROR_INVALIDCAST;
	sLibMCDataDynamicWrapperTable * wrapperTable = (sLibMCDataDynamicWrapperTable *) libraryHandle;
	return wrapperTable->m_CreateDataModelInstance (pInstance);	
}

*/
import "C"

import (
	"fmt"
	"unsafe"
	"runtime"
)

type ref = C.LibMCDataHandle


// LogLevel represents a LibMCData enum.
type LogLevel int

const (
	LogLevel_FatalError = 1
	LogLevel_CriticalError = 2
	LogLevel_Warning = 3
	LogLevel_Message = 4
	LogLevel_Info = 5
	LogLevel_Debug = 6
	LogLevel_Unknown = 7
)

// DataBaseType represents a LibMCData enum.
type DataBaseType int

const (
	DataBaseType_Unknown = 0
	DataBaseType_SqLite = 1
)

// BuildJobStatus represents a LibMCData enum.
type BuildJobStatus int

const (
	BuildJobStatus_Created = 0
	BuildJobStatus_Validating = 100
	BuildJobStatus_Validated = 200
	BuildJobStatus_Archived = 300
)

// Error constants for LibMCData.
const LIBMCDATA_ERROR_NOTIMPLEMENTED = 1;
const LIBMCDATA_ERROR_INVALIDPARAM = 2;
const LIBMCDATA_ERROR_INVALIDCAST = 3;
const LIBMCDATA_ERROR_BUFFERTOOSMALL = 4;
const LIBMCDATA_ERROR_GENERICEXCEPTION = 5;
const LIBMCDATA_ERROR_COULDNOTLOADLIBRARY = 6;
const LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT = 7;
const LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION = 8;
const LIBMCDATA_ERROR_COULDNOTPARSECONFIGURATION = 9;
const LIBMCDATA_ERROR_DUPLICATESTATENAME = 10;
const LIBMCDATA_ERROR_STATENOTFOUND = 11;
const LIBMCDATA_ERROR_DUPLICATEOUTSTATE = 12;
const LIBMCDATA_ERROR_MISSINGMACHINEDEFINITION = 13;
const LIBMCDATA_ERROR_MISSINGINSTANCENAME = 14;
const LIBMCDATA_ERROR_DUPLICATEMACHINEINSTANCE = 15;
const LIBMCDATA_ERROR_MISSINGXMLSCHEMA = 16;
const LIBMCDATA_ERROR_INVALIDXMLSCHEMA = 17;
const LIBMCDATA_ERROR_MISSINGSTATENAME = 18;
const LIBMCDATA_ERROR_MISSINGOUTSTATETARGET = 19;
const LIBMCDATA_ERROR_INVALIDOUTSTATETARGET = 20;
const LIBMCDATA_ERROR_NOINITSTATE = 21;
const LIBMCDATA_ERROR_NOFAILEDSTATE = 22;
const LIBMCDATA_ERROR_INITSTATENOTFOUND = 23;
const LIBMCDATA_ERROR_FAILEDSTATENOTFOUND = 24;
const LIBMCDATA_ERROR_MISSINGINITSTATE = 25;
const LIBMCDATA_ERROR_MISSINGFAILEDSTATE = 26;
const LIBMCDATA_ERROR_MISSINGPLUGINNAME = 27;
const LIBMCDATA_ERROR_EMPTYINITSTATE = 28;
const LIBMCDATA_ERROR_EMPTYFAILEDSTATE = 29;
const LIBMCDATA_ERROR_EMPTYPLUGINNAME = 30;
const LIBMCDATA_ERROR_COULDNOTCREATESTATEFACTORY = 31;
const LIBMCDATA_ERROR_INVALIDSTATENAME = 32;
const LIBMCDATA_ERROR_COULDNOTCREATESTATE = 33;
const LIBMCDATA_ERROR_COULDNOTINITIALIZEFACTORY = 34;
const LIBMCDATA_ERROR_COULDNOTFINALIZEFACTORY = 35;
const LIBMCDATA_ERROR_COULDNOTLOADPLUGIN = 36;
const LIBMCDATA_ERROR_NOCURRENTSTATE = 37;
const LIBMCDATA_ERROR_NOPLUGINSTATE = 38;
const LIBMCDATA_ERROR_COULDNOTEXECUTEPLUGIN = 39;
const LIBMCDATA_ERROR_TOOMANYMACHINEINSTANCES = 40;
const LIBMCDATA_ERROR_INVALIDINDEX = 41;
const LIBMCDATA_ERROR_NOOUTSTATEGIVEN = 42;
const LIBMCDATA_ERROR_INVALIDOUTSTATEGIVEN = 43;
const LIBMCDATA_ERROR_INVALIDREPEATDELAY = 44;
const LIBMCDATA_ERROR_INVALIDEXECUTIONDELAY = 45;
const LIBMCDATA_ERROR_MISSINGREPEATDELAY = 46;
const LIBMCDATA_ERROR_THREADISRUNNING = 47;
const LIBMCDATA_ERROR_THREADISNOTRUNNING = 48;
const LIBMCDATA_ERROR_DUPLICATESIGNAL = 49;
const LIBMCDATA_ERROR_INVALIDSIGNALNAME = 50;
const LIBMCDATA_ERROR_MISSINGSIGNALNAME = 51;
const LIBMCDATA_ERROR_MISSINGSERVERNODE = 52;
const LIBMCDATA_ERROR_MISSINGHOSTNAME = 53;
const LIBMCDATA_ERROR_MISSINGPORT = 54;
const LIBMCDATA_ERROR_UUIDGENERATIONFAILED = 55;
const LIBMCDATA_ERROR_INVALIDBUFFERSIZE = 56;
const LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF8 = 57;
const LIBMCDATA_ERROR_NOCOLUMNAVAILABLE = 58;
const LIBMCDATA_ERROR_INVALIDTEXTCOLUMN = 59;
const LIBMCDATA_ERROR_INVALIDCOLUMNTYPE = 60;
const LIBMCDATA_ERROR_TOOMANYREQUESTEDLOGS = 61;
const LIBMCDATA_ERROR_MISSINGINSTANCEDESCRIPTION = 62;
const LIBMCDATA_ERROR_DUPLICATEPARAMETERGROUPNAME = 63;
const LIBMCDATA_ERROR_MISSINGPARAMETERGROUPNAME = 64;
const LIBMCDATA_ERROR_EMPTYPARAMETERGROUPNAME = 65;
const LIBMCDATA_ERROR_MISSINGPARAMETERGROUPDESCRIPTION = 66;
const LIBMCDATA_ERROR_EMPTYPARAMETERGROUPDESCRIPTION = 67;
const LIBMCDATA_ERROR_TOOMANYPARAMETERS = 68;
const LIBMCDATA_ERROR_TOOMANYPARAMETERGROUPS = 69;
const LIBMCDATA_ERROR_DUPLICATEPARAMETERNAME = 70;
const LIBMCDATA_ERROR_MISSINGPARAMETERNAME = 71;
const LIBMCDATA_ERROR_EMPTYPARAMETERNAME = 72;
const LIBMCDATA_ERROR_MISSINGPARAMETERDESCRIPTION = 73;
const LIBMCDATA_ERROR_EMPTYPARAMETERDESCRIPTION = 74;
const LIBMCDATA_ERROR_PARAMETERNOTFOUND = 75;
const LIBMCDATA_ERROR_MISSINGPARAMETERDEFAULTVALUE = 76;
const LIBMCDATA_ERROR_MISSINGDATACONFIGNODE = 77;
const LIBMCDATA_ERROR_MISSINGDIRECTORY = 78;
const LIBMCDATA_ERROR_MISSINGDATABASETYPE = 79;
const LIBMCDATA_ERROR_MISSINGSQLITEINFO = 80;
const LIBMCDATA_ERROR_UNKNOWNDATABASETYPE = 81;
const LIBMCDATA_ERROR_STORAGENOTINITIALISED = 82;
const LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF16 = 83;
const LIBMCDATA_ERROR_COULDNOTCREATEFILE = 84;
const LIBMCDATA_ERROR_COULDNOTSEEKSTREAM = 85;
const LIBMCDATA_ERROR_COULDNOTGETSTREAMPOSITION = 86;
const LIBMCDATA_ERROR_COULDNOTWRITESTREAM = 87;
const LIBMCDATA_ERROR_INVALIDDATABASEMIGRATION = 88;
const LIBMCDATA_ERROR_INTERNALERROR = 89;
const LIBMCDATA_ERROR_COULDNOTSTORECONTENTSTREAM = 90;
const LIBMCDATA_ERROR_DATABASENOTINITIALISED = 91;
const LIBMCDATA_ERROR_PARAMETERGROUPNOTFOUND = 92;
const LIBMCDATA_ERROR_SIGNALNOTFOUND = 93;
const LIBMCDATA_ERROR_STATEMACHINENOTFOUND = 94;
const LIBMCDATA_ERROR_MISSINGPARAMETERTYPE = 95;
const LIBMCDATA_ERROR_INVALIDPARAMETERTYPE = 96;
const LIBMCDATA_ERROR_COULDNOTPARSEJSON = 97;
const LIBMCDATA_ERROR_INVALIDJSONFORMAT = 98;
const LIBMCDATA_ERROR_URLNOTFOUND = 99;
const LIBMCDATA_ERROR_GENERICBADREQUEST = 100;
const LIBMCDATA_ERROR_SQLITE_ERROR = 101;
const LIBMCDATA_ERROR_SQLITE_INTERNAL = 102;
const LIBMCDATA_ERROR_SQLITE_PERM = 103;
const LIBMCDATA_ERROR_SQLITE_ABORT = 104;
const LIBMCDATA_ERROR_SQLITE_BUSY = 105;
const LIBMCDATA_ERROR_SQLITE_LOCKED = 106;
const LIBMCDATA_ERROR_SQLITE_NOMEM = 107;
const LIBMCDATA_ERROR_SQLITE_READONLY = 108;
const LIBMCDATA_ERROR_SQLITE_INTERRUPT = 109;
const LIBMCDATA_ERROR_SQLITE_IOERR = 110;
const LIBMCDATA_ERROR_SQLITE_CORRUPT = 111;
const LIBMCDATA_ERROR_SQLITE_NOTFOUND = 112;
const LIBMCDATA_ERROR_SQLITE_FULL = 113;
const LIBMCDATA_ERROR_SQLITE_CANTOPEN = 114;
const LIBMCDATA_ERROR_SQLITE_PROTOCOL = 115;
const LIBMCDATA_ERROR_SQLITE_SCHEMA = 117;
const LIBMCDATA_ERROR_SQLITE_TOOBIG = 118;
const LIBMCDATA_ERROR_SQLITE_CONSTRAINT = 119;
const LIBMCDATA_ERROR_SQLITE_MISMATCH = 120;
const LIBMCDATA_ERROR_SQLITE_MISUSE = 121;
const LIBMCDATA_ERROR_SQLITE_NOLFS = 122;
const LIBMCDATA_ERROR_SQLITE_AUTH = 123;
const LIBMCDATA_ERROR_SQLITE_RANGE = 125;
const LIBMCDATA_ERROR_SQLITE_NOTADB = 126;
const LIBMCDATA_ERROR_SQLITE_NOTICE = 127;
const LIBMCDATA_ERROR_SQLITE_WARNING = 128;
const LIBMCDATA_ERROR_SQLITE_OTHER = 130;
const LIBMCDATA_ERROR_SQLITE_TOOMANYRESULTROWS = 131;
const LIBMCDATA_ERROR_COULDNOTREADZIPFILE = 200;
const LIBMCDATA_ERROR_COULDNOTOPENZIPFILE = 201;
const LIBMCDATA_ERROR_COULDNOTGETZIPENTRIES = 202;
const LIBMCDATA_ERROR_ZIPENTRYNOTFOUND = 203;
const LIBMCDATA_ERROR_COULDNOTSTATZIPENTRY = 204;
const LIBMCDATA_ERROR_COULDNOTOPENZIPENTRY = 205;
const LIBMCDATA_ERROR_COULDNOTREADZIPSTREAM = 206;
const LIBMCDATA_ERROR_COULDNOTREADFULLZIPDATA = 207;
const LIBMCDATA_ERROR_COULDNOTFINDDISTRIBUTIONINDEX = 208;
const LIBMCDATA_ERROR_COULDNOTPARSEDISTRIBUTIONINDEX = 209;
const LIBMCDATA_ERROR_EMPTYDISTRIBUTIONINDEX = 210;
const LIBMCDATA_ERROR_MISSINGDISTRIBUTIONINDEX = 211;
const LIBMCDATA_ERROR_MISSINGDISTRIBUTIONURL = 212;
const LIBMCDATA_ERROR_MISSINGDISTRIBUTIONFILENAME = 213;
const LIBMCDATA_ERROR_MISSINGDISTRIBUTIONSIZE = 214;
const LIBMCDATA_ERROR_MISSINGDISTRIBUTIONCONTENTTYPE = 215;
const LIBMCDATA_ERROR_DRIVERALREADYREGISTERED = 216;
const LIBMCDATA_ERROR_DRIVERNOTFOUND = 217;
const LIBMCDATA_ERROR_MISSINGDRIVERNAME = 218;
const LIBMCDATA_ERROR_MISSINGDRIVERTYPE = 219;
const LIBMCDATA_ERROR_MISSINGDRIVERLIBRARY = 220;
const LIBMCDATA_ERROR_DRIVERALREADYRESERVED = 221;
const LIBMCDATA_ERROR_LIBRARYPATHNOTFOUND = 222;
const LIBMCDATA_ERROR_TOOLPATHENTITYNOTLOADED = 223;
const LIBMCDATA_ERROR_TOOLPATHENTITYREFERENCEERROR = 224;
const LIBMCDATA_ERROR_TOOLPATHENTITYINVALIDFILE = 225;
const LIBMCDATA_ERROR_NO3MFLIBRARY = 226;
const LIBMCDATA_ERROR_INVALIDPOINTCOUNT = 227;
const LIBMCDATA_ERROR_DUPLICATEJOBUUID = 228;
const LIBMCDATA_ERROR_INVALIDJOBSTATUS = 229;
const LIBMCDATA_ERROR_INVALIDSTREAMCONTEXT = 230;
const LIBMCDATA_ERROR_JOBUUIDNOTFOUND = 231;
const LIBMCDATA_ERROR_INVALIDJOBNAME = 232;
const LIBMCDATA_ERROR_INVALIDJOBTIMESTAMP = 233;
const LIBMCDATA_ERROR_INVALIDUSERID = 234;
const LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSIGNATURE = 235;
const LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSTREAM = 236;
const LIBMCDATA_ERROR_INVALIDSTORAGEPATH = 237;
const LIBMCDATA_ERROR_STORAGESTREAMNOTFOUND = 238;

// WrappedError is an error that wraps a LibMCData error.
type WrappedError struct {
	Code uint32
	Message string
}

func (e *WrappedError) Error() string {
	return fmt.Sprintf("libmcdata: %s (%d)", e.Message, e.Code)
}

func errorMessage(errorcode uint32) string {
	switch (errorcode) {
	case LIBMCDATA_ERROR_NOTIMPLEMENTED:
		return "functionality not implemented";
	case LIBMCDATA_ERROR_INVALIDPARAM:
		return "an invalid parameter was passed";
	case LIBMCDATA_ERROR_INVALIDCAST:
		return "a type cast failed";
	case LIBMCDATA_ERROR_BUFFERTOOSMALL:
		return "a provided buffer is too small";
	case LIBMCDATA_ERROR_GENERICEXCEPTION:
		return "a generic exception occurred";
	case LIBMCDATA_ERROR_COULDNOTLOADLIBRARY:
		return "the library could not be loaded";
	case LIBMCDATA_ERROR_COULDNOTFINDLIBRARYEXPORT:
		return "a required exported symbol could not be found in the library";
	case LIBMCDATA_ERROR_INCOMPATIBLEBINARYVERSION:
		return "the version of the binary interface does not match the bindings interface";
	case LIBMCDATA_ERROR_COULDNOTPARSECONFIGURATION:
		return "could not parse configuration";
	case LIBMCDATA_ERROR_DUPLICATESTATENAME:
		return "duplicate state name";
	case LIBMCDATA_ERROR_STATENOTFOUND:
		return "state not found";
	case LIBMCDATA_ERROR_DUPLICATEOUTSTATE:
		return "duplicate out state";
	case LIBMCDATA_ERROR_MISSINGMACHINEDEFINITION:
		return "missing machine definition";
	case LIBMCDATA_ERROR_MISSINGINSTANCENAME:
		return "missing instance name";
	case LIBMCDATA_ERROR_DUPLICATEMACHINEINSTANCE:
		return "duplicate machine instance";
	case LIBMCDATA_ERROR_MISSINGXMLSCHEMA:
		return "missing XML schema";
	case LIBMCDATA_ERROR_INVALIDXMLSCHEMA:
		return "invalid XML schema";
	case LIBMCDATA_ERROR_MISSINGSTATENAME:
		return "missing state name";
	case LIBMCDATA_ERROR_MISSINGOUTSTATETARGET:
		return "missing outstate target";
	case LIBMCDATA_ERROR_INVALIDOUTSTATETARGET:
		return "invalid outstate target";
	case LIBMCDATA_ERROR_NOINITSTATE:
		return "no init state";
	case LIBMCDATA_ERROR_NOFAILEDSTATE:
		return "no failed state";
	case LIBMCDATA_ERROR_INITSTATENOTFOUND:
		return "init state not found";
	case LIBMCDATA_ERROR_FAILEDSTATENOTFOUND:
		return "failed state not found";
	case LIBMCDATA_ERROR_MISSINGINITSTATE:
		return "missing init state";
	case LIBMCDATA_ERROR_MISSINGFAILEDSTATE:
		return "missing failed state";
	case LIBMCDATA_ERROR_MISSINGPLUGINNAME:
		return "missing plugin name";
	case LIBMCDATA_ERROR_EMPTYINITSTATE:
		return "empty init state";
	case LIBMCDATA_ERROR_EMPTYFAILEDSTATE:
		return "empty failed state";
	case LIBMCDATA_ERROR_EMPTYPLUGINNAME:
		return "empty plugin name";
	case LIBMCDATA_ERROR_COULDNOTCREATESTATEFACTORY:
		return "could not create state factory";
	case LIBMCDATA_ERROR_INVALIDSTATENAME:
		return "invalid state name";
	case LIBMCDATA_ERROR_COULDNOTCREATESTATE:
		return "could not create state";
	case LIBMCDATA_ERROR_COULDNOTINITIALIZEFACTORY:
		return "could not initialize factory";
	case LIBMCDATA_ERROR_COULDNOTFINALIZEFACTORY:
		return "could not finalize factory";
	case LIBMCDATA_ERROR_COULDNOTLOADPLUGIN:
		return "could not load plugin";
	case LIBMCDATA_ERROR_NOCURRENTSTATE:
		return "no current state";
	case LIBMCDATA_ERROR_NOPLUGINSTATE:
		return "no plugin state";
	case LIBMCDATA_ERROR_COULDNOTEXECUTEPLUGIN:
		return "could not execute plugin";
	case LIBMCDATA_ERROR_TOOMANYMACHINEINSTANCES:
		return "too many machine instances";
	case LIBMCDATA_ERROR_INVALIDINDEX:
		return "invalid index";
	case LIBMCDATA_ERROR_NOOUTSTATEGIVEN:
		return "no new outstate has been given";
	case LIBMCDATA_ERROR_INVALIDOUTSTATEGIVEN:
		return "invalid outstate has been given";
	case LIBMCDATA_ERROR_INVALIDREPEATDELAY:
		return "invalid repeat delay";
	case LIBMCDATA_ERROR_INVALIDEXECUTIONDELAY:
		return "invalid execution delay";
	case LIBMCDATA_ERROR_MISSINGREPEATDELAY:
		return "missing repeat delay";
	case LIBMCDATA_ERROR_THREADISRUNNING:
		return "thread is running";
	case LIBMCDATA_ERROR_THREADISNOTRUNNING:
		return "thread is not running";
	case LIBMCDATA_ERROR_DUPLICATESIGNAL:
		return "duplicate signal";
	case LIBMCDATA_ERROR_INVALIDSIGNALNAME:
		return "invalid signal name";
	case LIBMCDATA_ERROR_MISSINGSIGNALNAME:
		return "missing signal name";
	case LIBMCDATA_ERROR_MISSINGSERVERNODE:
		return "missing server node";
	case LIBMCDATA_ERROR_MISSINGHOSTNAME:
		return "missing host name";
	case LIBMCDATA_ERROR_MISSINGPORT:
		return "missing port";
	case LIBMCDATA_ERROR_UUIDGENERATIONFAILED:
		return "uuid generation failed";
	case LIBMCDATA_ERROR_INVALIDBUFFERSIZE:
		return "invalid buffer size";
	case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF8:
		return "could not convert to utf8";
	case LIBMCDATA_ERROR_NOCOLUMNAVAILABLE:
		return "no column available";
	case LIBMCDATA_ERROR_INVALIDTEXTCOLUMN:
		return "invalid text column";
	case LIBMCDATA_ERROR_INVALIDCOLUMNTYPE:
		return "invalid column type";
	case LIBMCDATA_ERROR_TOOMANYREQUESTEDLOGS:
		return "too many requested logs";
	case LIBMCDATA_ERROR_MISSINGINSTANCEDESCRIPTION:
		return "missing instance description";
	case LIBMCDATA_ERROR_DUPLICATEPARAMETERGROUPNAME:
		return "duplicate parameter group name";
	case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPNAME:
		return "missing parameter group name";
	case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPNAME:
		return "empty parameter group name";
	case LIBMCDATA_ERROR_MISSINGPARAMETERGROUPDESCRIPTION:
		return "missing parameter group description";
	case LIBMCDATA_ERROR_EMPTYPARAMETERGROUPDESCRIPTION:
		return "empty parameter group description";
	case LIBMCDATA_ERROR_TOOMANYPARAMETERS:
		return "too many parameters";
	case LIBMCDATA_ERROR_TOOMANYPARAMETERGROUPS:
		return "too many parameter groups";
	case LIBMCDATA_ERROR_DUPLICATEPARAMETERNAME:
		return "duplicate parameter name";
	case LIBMCDATA_ERROR_MISSINGPARAMETERNAME:
		return "missing parameter name";
	case LIBMCDATA_ERROR_EMPTYPARAMETERNAME:
		return "empty parameter name";
	case LIBMCDATA_ERROR_MISSINGPARAMETERDESCRIPTION:
		return "missing parameter description";
	case LIBMCDATA_ERROR_EMPTYPARAMETERDESCRIPTION:
		return "empty parameter description";
	case LIBMCDATA_ERROR_PARAMETERNOTFOUND:
		return "parameter not found";
	case LIBMCDATA_ERROR_MISSINGPARAMETERDEFAULTVALUE:
		return "missing parameter default value";
	case LIBMCDATA_ERROR_MISSINGDATACONFIGNODE:
		return "missing data config node";
	case LIBMCDATA_ERROR_MISSINGDIRECTORY:
		return "missing directory";
	case LIBMCDATA_ERROR_MISSINGDATABASETYPE:
		return "missing database type";
	case LIBMCDATA_ERROR_MISSINGSQLITEINFO:
		return "missing sqlite info";
	case LIBMCDATA_ERROR_UNKNOWNDATABASETYPE:
		return "unknown database type";
	case LIBMCDATA_ERROR_STORAGENOTINITIALISED:
		return "storage not initialised";
	case LIBMCDATA_ERROR_COULDNOTCONVERTTOUTF16:
		return "could not convert to utf 16";
	case LIBMCDATA_ERROR_COULDNOTCREATEFILE:
		return "could not create file";
	case LIBMCDATA_ERROR_COULDNOTSEEKSTREAM:
		return "could not seek stream";
	case LIBMCDATA_ERROR_COULDNOTGETSTREAMPOSITION:
		return "could not get stream position";
	case LIBMCDATA_ERROR_COULDNOTWRITESTREAM:
		return "could not write stream";
	case LIBMCDATA_ERROR_INVALIDDATABASEMIGRATION:
		return "invalid database migration";
	case LIBMCDATA_ERROR_INTERNALERROR:
		return "internal error";
	case LIBMCDATA_ERROR_COULDNOTSTORECONTENTSTREAM:
		return "could not store content stream";
	case LIBMCDATA_ERROR_DATABASENOTINITIALISED:
		return "database not initialised";
	case LIBMCDATA_ERROR_PARAMETERGROUPNOTFOUND:
		return "parameter group not found";
	case LIBMCDATA_ERROR_SIGNALNOTFOUND:
		return "signal not found";
	case LIBMCDATA_ERROR_STATEMACHINENOTFOUND:
		return "state machine not found.";
	case LIBMCDATA_ERROR_MISSINGPARAMETERTYPE:
		return "missing parameter type.";
	case LIBMCDATA_ERROR_INVALIDPARAMETERTYPE:
		return "invalid parameter type.";
	case LIBMCDATA_ERROR_COULDNOTPARSEJSON:
		return "could not parse json.";
	case LIBMCDATA_ERROR_INVALIDJSONFORMAT:
		return "invalid json format.";
	case LIBMCDATA_ERROR_URLNOTFOUND:
		return "url not found.";
	case LIBMCDATA_ERROR_GENERICBADREQUEST:
		return "generic bad request.";
	case LIBMCDATA_ERROR_SQLITE_ERROR:
		return "SQLite: Generic Error";
	case LIBMCDATA_ERROR_SQLITE_INTERNAL:
		return "SQLite: Internal logic error in SQLite";
	case LIBMCDATA_ERROR_SQLITE_PERM:
		return "SQLite: Access permission denied";
	case LIBMCDATA_ERROR_SQLITE_ABORT:
		return "SQLite: Callback routine requested an abort";
	case LIBMCDATA_ERROR_SQLITE_BUSY:
		return "SQLite: The database file is locked";
	case LIBMCDATA_ERROR_SQLITE_LOCKED:
		return "SQLite: A table in the database is locked";
	case LIBMCDATA_ERROR_SQLITE_NOMEM:
		return "SQLite: A malloc failed";
	case LIBMCDATA_ERROR_SQLITE_READONLY:
		return "SQLite: Attempt to write a readonly database";
	case LIBMCDATA_ERROR_SQLITE_INTERRUPT:
		return "SQLite: Operation terminated by sqlite3_interrupt";
	case LIBMCDATA_ERROR_SQLITE_IOERR:
		return "SQLite: Some kind of disk I/O error occurred";
	case LIBMCDATA_ERROR_SQLITE_CORRUPT:
		return "SQLite: The database disk image is malformed";
	case LIBMCDATA_ERROR_SQLITE_NOTFOUND:
		return "SQLite: Unknown opcode in sqlite3_file_control";
	case LIBMCDATA_ERROR_SQLITE_FULL:
		return "SQLite: Insertion failed because database is full";
	case LIBMCDATA_ERROR_SQLITE_CANTOPEN:
		return "SQLite: Unable to open the database file";
	case LIBMCDATA_ERROR_SQLITE_PROTOCOL:
		return "SQLite: Database lock protocol error";
	case LIBMCDATA_ERROR_SQLITE_SCHEMA:
		return "SQLite: The database schema changed";
	case LIBMCDATA_ERROR_SQLITE_TOOBIG:
		return "SQLite: String or BLOB exceeds size limit";
	case LIBMCDATA_ERROR_SQLITE_CONSTRAINT:
		return "SQLite: Abort due to constraint violation";
	case LIBMCDATA_ERROR_SQLITE_MISMATCH:
		return "SQLite: Data type mismatch";
	case LIBMCDATA_ERROR_SQLITE_MISUSE:
		return "SQLite: Library used incorrectly";
	case LIBMCDATA_ERROR_SQLITE_NOLFS:
		return "SQLite: Uses OS features not supported on host";
	case LIBMCDATA_ERROR_SQLITE_AUTH:
		return "SQLite: Authorization denied";
	case LIBMCDATA_ERROR_SQLITE_RANGE:
		return "SQLite: 2nd parameter to sqlite3_bind out of range";
	case LIBMCDATA_ERROR_SQLITE_NOTADB:
		return "SQLite: File opened that is not a database file";
	case LIBMCDATA_ERROR_SQLITE_NOTICE:
		return "SQLite: Notifications from sqlite3_log";
	case LIBMCDATA_ERROR_SQLITE_WARNING:
		return "SQLite: Warnings from sqlite3_log";
	case LIBMCDATA_ERROR_SQLITE_OTHER:
		return "SQLite: Other Error";
	case LIBMCDATA_ERROR_SQLITE_TOOMANYRESULTROWS:
		return "too many result rows";
	case LIBMCDATA_ERROR_COULDNOTREADZIPFILE:
		return "Could not read ZIP file";
	case LIBMCDATA_ERROR_COULDNOTOPENZIPFILE:
		return "Could not open ZIP file";
	case LIBMCDATA_ERROR_COULDNOTGETZIPENTRIES:
		return "Could not get ZIP file entries";
	case LIBMCDATA_ERROR_ZIPENTRYNOTFOUND:
		return "ZIP Entry not found";
	case LIBMCDATA_ERROR_COULDNOTSTATZIPENTRY:
		return "Could not stat ZIP entry";
	case LIBMCDATA_ERROR_COULDNOTOPENZIPENTRY:
		return "Could not open ZIP entry";
	case LIBMCDATA_ERROR_COULDNOTREADZIPSTREAM:
		return "Could not read ZIP stream";
	case LIBMCDATA_ERROR_COULDNOTREADFULLZIPDATA:
		return "Could not read full zip data";
	case LIBMCDATA_ERROR_COULDNOTFINDDISTRIBUTIONINDEX:
		return "Could not find distribution index.";
	case LIBMCDATA_ERROR_COULDNOTPARSEDISTRIBUTIONINDEX:
		return "Could not parse distribution index.";
	case LIBMCDATA_ERROR_EMPTYDISTRIBUTIONINDEX:
		return "Empty distribution index.";
	case LIBMCDATA_ERROR_MISSINGDISTRIBUTIONINDEX:
		return "Missing distribution index.";
	case LIBMCDATA_ERROR_MISSINGDISTRIBUTIONURL:
		return "Missing distribution url.";
	case LIBMCDATA_ERROR_MISSINGDISTRIBUTIONFILENAME:
		return "Missing distribution filename.";
	case LIBMCDATA_ERROR_MISSINGDISTRIBUTIONSIZE:
		return "Missing distribution size.";
	case LIBMCDATA_ERROR_MISSINGDISTRIBUTIONCONTENTTYPE:
		return "Missing distribution content type.";
	case LIBMCDATA_ERROR_DRIVERALREADYREGISTERED:
		return "Driver already registered.";
	case LIBMCDATA_ERROR_DRIVERNOTFOUND:
		return "Driver not found.";
	case LIBMCDATA_ERROR_MISSINGDRIVERNAME:
		return "Missing driver name.";
	case LIBMCDATA_ERROR_MISSINGDRIVERTYPE:
		return "Missing driver type.";
	case LIBMCDATA_ERROR_MISSINGDRIVERLIBRARY:
		return "Missing driver library.";
	case LIBMCDATA_ERROR_DRIVERALREADYRESERVED:
		return "Driver has already been reserved by an instance.";
	case LIBMCDATA_ERROR_LIBRARYPATHNOTFOUND:
		return "Library path not found.";
	case LIBMCDATA_ERROR_TOOLPATHENTITYNOTLOADED:
		return "Toolpath entity not loaded";
	case LIBMCDATA_ERROR_TOOLPATHENTITYREFERENCEERROR:
		return "Toolpath entity reference error";
	case LIBMCDATA_ERROR_TOOLPATHENTITYINVALIDFILE:
		return "Toolpath entity is invalid";
	case LIBMCDATA_ERROR_NO3MFLIBRARY:
		return "No 3MF Library specified";
	case LIBMCDATA_ERROR_INVALIDPOINTCOUNT:
		return "Invalid point count";
	case LIBMCDATA_ERROR_DUPLICATEJOBUUID:
		return "Duplicate job uuid";
	case LIBMCDATA_ERROR_INVALIDJOBSTATUS:
		return "Invalid job status";
	case LIBMCDATA_ERROR_INVALIDSTREAMCONTEXT:
		return "Invalid stream context";
	case LIBMCDATA_ERROR_JOBUUIDNOTFOUND:
		return "Job uuid not found";
	case LIBMCDATA_ERROR_INVALIDJOBNAME:
		return "Invalid job name";
	case LIBMCDATA_ERROR_INVALIDJOBTIMESTAMP:
		return "Invalid job timestamp";
	case LIBMCDATA_ERROR_INVALIDUSERID:
		return "Invalid job name";
	case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSIGNATURE:
		return "Invalid storage callback signature";
	case LIBMCDATA_ERROR_INVALIDSTORAGECALLBACKSTREAM:
		return "Invalid storage callback stream";
	case LIBMCDATA_ERROR_INVALIDSTORAGEPATH:
		return "Invalid storage path";
	case LIBMCDATA_ERROR_STORAGESTREAMNOTFOUND:
		return "Storage Stream not found";
	default:
		return "unknown";
	}
}

func makeError(errorcode uint32) error {
	return &WrappedError{errorcode, errorMessage(uint32(errorcode))}
}
// Wrapper represents the number wrapper
type Wrapper struct {
	_ [0]func() // uncomparable; to make == not compile
	LibraryHandle C.LibMCDataHandle
}


// Base represents a LibMCData class.
type Base struct {
	_     [0]func() // uncomparable; to make == not compile
	Ref   ref       // identifies a C value, see ref type
	wrapperRef *Wrapper
	gcPtr *ref      // used to trigger the finalizer when the Value is not referenced any more
}

// NewBase creates a new Base.
// The wrapped C pointer will be freed when the Go pointer is finalized,
// but one can release it manually calling Release.
func (wrapper * Wrapper) NewBase(r ref) Base {
	gcPtr := new(ref)
	*gcPtr = r
	runtime.SetFinalizer(gcPtr, wrapper.releaseC)
	return Base{Ref: r, gcPtr: gcPtr, wrapperRef: wrapper}
}

// Release releases the C pointer.
func (inst Base) Release() error {
	if (inst.wrapperRef != nil) {
		err := inst.wrapperRef.ReleaseInstance(inst)
		*inst.gcPtr = nil
		return err
	} else {
		*inst.gcPtr = nil
		return nil;
	}
}

// Equal reports whether inst and w refer to the same C pointer.
func (inst Base) Equal(w Base) bool {
	return inst.Ref == w.Ref
}

// Iterator represents a LibMCData class.
type Iterator struct {
	Base
}

func (wrapper * Wrapper) NewIterator(r ref) Iterator {
	return Iterator{wrapper.NewBase(r)}
}
// MoveNext iterates to the next resource in the list.
func (inst Iterator) MoveNext() (bool, error) {
	var hasNext C.bool
	ret := C.CCall_libmcdata_iterator_movenext(inst.wrapperRef.LibraryHandle, inst.Ref, &hasNext)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasNext), nil
}

// MovePrevious iterates to the previous resource in the list.
func (inst Iterator) MovePrevious() (bool, error) {
	var hasPrevious C.bool
	ret := C.CCall_libmcdata_iterator_moveprevious(inst.wrapperRef.LibraryHandle, inst.Ref, &hasPrevious)
	if ret != 0 {
		return false, makeError(uint32(ret))
	}
	return bool(hasPrevious), nil
}

// GetCurrent returns the resource the iterator points at.
func (inst Iterator) GetCurrent() (Base, error) {
	var currentInstance ref
	ret := C.CCall_libmcdata_iterator_getcurrent(inst.wrapperRef.LibraryHandle, inst.Ref, &currentInstance)
	if ret != 0 {
		return Base{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewBase(currentInstance), nil
}

// Clone creates a new resource iterator with the same resource list.
func (inst Iterator) Clone() (Iterator, error) {
	var outIterator ref
	ret := C.CCall_libmcdata_iterator_clone(inst.wrapperRef.LibraryHandle, inst.Ref, &outIterator)
	if ret != 0 {
		return Iterator{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewIterator(outIterator), nil
}

// Count returns the number of resoucres the iterator captures.
func (inst Iterator) Count() (uint64, error) {
	var count C.uint64_t
	ret := C.CCall_libmcdata_iterator_count(inst.wrapperRef.LibraryHandle, inst.Ref, &count)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(count), nil
}


// LogSession represents a LibMCData class.
type LogSession struct {
	Base
}

func (wrapper * Wrapper) NewLogSession(r ref) LogSession {
	return LogSession{wrapper.NewBase(r)}
}
// AddEntry adds a new log entry.
func (inst LogSession) AddEntry(message string, subSystem string, logLevel LogLevel, timestamp string) error {
	ret := C.CCall_libmcdata_logsession_addentry(inst.wrapperRef.LibraryHandle, inst.Ref, (*C.char)(unsafe.Pointer(&[]byte(message)[0])), (*C.char)(unsafe.Pointer(&[]byte(subSystem)[0])), C.eLibMCDataLogLevel(logLevel), (*C.char)(unsafe.Pointer(&[]byte(timestamp)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}


// StorageStream represents a LibMCData class.
type StorageStream struct {
	Base
}

func (wrapper * Wrapper) NewStorageStream(r ref) StorageStream {
	return StorageStream{wrapper.NewBase(r)}
}
// GetUUID returns the uuid of a storage stream.
func (inst StorageStream) GetUUID() (string, error) {
	var neededforuUID C.uint32_t
	var filledinuUID C.uint32_t
	ret := C.CCall_libmcdata_storagestream_getuuid(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforuUID, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizeuUID := neededforuUID
	bufferuUID := make([]byte, bufferSizeuUID)
	ret = C.CCall_libmcdata_storagestream_getuuid(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizeuUID, &filledinuUID, (*C.char)(unsafe.Pointer(&bufferuUID[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferuUID[:(filledinuUID-1)]), nil
}


// GetTimeStamp returns the timestamp of a storage stream.
func (inst StorageStream) GetTimeStamp() (string, error) {
	var neededfortimestamp C.uint32_t
	var filledintimestamp C.uint32_t
	ret := C.CCall_libmcdata_storagestream_gettimestamp(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededfortimestamp, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizetimestamp := neededfortimestamp
	buffertimestamp := make([]byte, bufferSizetimestamp)
	ret = C.CCall_libmcdata_storagestream_gettimestamp(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizetimestamp, &filledintimestamp, (*C.char)(unsafe.Pointer(&buffertimestamp[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffertimestamp[:(filledintimestamp-1)]), nil
}

// GetName returns the name of a storage stream.
func (inst StorageStream) GetName() (string, error) {
	var neededforname C.uint32_t
	var filledinname C.uint32_t
	ret := C.CCall_libmcdata_storagestream_getname(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforname, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizename := neededforname
	buffername := make([]byte, bufferSizename)
	ret = C.CCall_libmcdata_storagestream_getname(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizename, &filledinname, (*C.char)(unsafe.Pointer(&buffername[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffername[:(filledinname-1)]), nil
}

// GetMIMEType returns the mime type of a storage stream.
func (inst StorageStream) GetMIMEType() (string, error) {
	var neededformimeType C.uint32_t
	var filledinmimeType C.uint32_t
	ret := C.CCall_libmcdata_storagestream_getmimetype(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededformimeType, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizemimeType := neededformimeType
	buffermimeType := make([]byte, bufferSizemimeType)
	ret = C.CCall_libmcdata_storagestream_getmimetype(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizemimeType, &filledinmimeType, (*C.char)(unsafe.Pointer(&buffermimeType[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffermimeType[:(filledinmimeType-1)]), nil
}

// GetSHA2 returns the sha256 checksum of a storage stream.
func (inst StorageStream) GetSHA2() (string, error) {
	var neededforsHA2 C.uint32_t
	var filledinsHA2 C.uint32_t
	ret := C.CCall_libmcdata_storagestream_getsha2(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforsHA2, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizesHA2 := neededforsHA2
	buffersHA2 := make([]byte, bufferSizesHA2)
	ret = C.CCall_libmcdata_storagestream_getsha2(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizesHA2, &filledinsHA2, (*C.char)(unsafe.Pointer(&buffersHA2[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffersHA2[:(filledinsHA2-1)]), nil
}

// GetSize returns the size of a storage stream.
func (inst StorageStream) GetSize() (uint64, error) {
	var size C.uint64_t
	ret := C.CCall_libmcdata_storagestream_getsize(inst.wrapperRef.LibraryHandle, inst.Ref, &size)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(size), nil
}

// GetContent returns the content of a storage stream.
func (inst StorageStream) GetContent(content []uint8) ([]uint8, error) {
	var neededforcontent C.uint64_t
	ret := C.CCall_libmcdata_storagestream_getcontent(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforcontent, nil)
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	if len(content) < int(neededforcontent) {
	 content = append(content, make([]uint8, int(neededforcontent)-len(content))...)
	}
	ret = C.CCall_libmcdata_storagestream_getcontent(inst.wrapperRef.LibraryHandle, inst.Ref, neededforcontent, nil, (*C.uint8_t)(unsafe.Pointer(&content[0])))
	if ret != 0 {
		return nil, makeError(uint32(ret))
	}
	return content[:int(neededforcontent)], nil
}

// GetCallbacks returns direct read access to the storage stream. The callbacks are only valid throughout the existence of the StorageStream instance.
func (inst StorageStream) GetCallbacks() (uint64, uint64, uint64, error) {
	var theReadCallback C.uint64_t
	var theSeekCallback C.uint64_t
	var streamHandle C.uint64_t
	ret := C.CCall_libmcdata_storagestream_getcallbacks(inst.wrapperRef.LibraryHandle, inst.Ref, &theReadCallback, &theSeekCallback, &streamHandle)
	if ret != 0 {
		return 0, 0, 0, makeError(uint32(ret))
	}
	return uint64(theReadCallback), uint64(theSeekCallback), uint64(streamHandle), nil
}


// Storage represents a LibMCData class.
type Storage struct {
	Base
}

func (wrapper * Wrapper) NewStorage(r ref) Storage {
	return Storage{wrapper.NewBase(r)}
}

// BuildJob represents a LibMCData class.
type BuildJob struct {
	Base
}

func (wrapper * Wrapper) NewBuildJob(r ref) BuildJob {
	return BuildJob{wrapper.NewBase(r)}
}
// GetUUID returns the uuid of a build job.
func (inst BuildJob) GetUUID() (string, error) {
	var neededforuUID C.uint32_t
	var filledinuUID C.uint32_t
	ret := C.CCall_libmcdata_buildjob_getuuid(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforuUID, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizeuUID := neededforuUID
	bufferuUID := make([]byte, bufferSizeuUID)
	ret = C.CCall_libmcdata_buildjob_getuuid(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizeuUID, &filledinuUID, (*C.char)(unsafe.Pointer(&bufferuUID[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferuUID[:(filledinuUID-1)]), nil
}

// GetName returns the name of a build job.
func (inst BuildJob) GetName() (string, error) {
	var neededforname C.uint32_t
	var filledinname C.uint32_t
	ret := C.CCall_libmcdata_buildjob_getname(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededforname, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizename := neededforname
	buffername := make([]byte, bufferSizename)
	ret = C.CCall_libmcdata_buildjob_getname(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizename, &filledinname, (*C.char)(unsafe.Pointer(&buffername[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffername[:(filledinname-1)]), nil
}

// GetStatus returns the status of a build job.
func (inst BuildJob) GetStatus() (BuildJobStatus, error) {
	var status C.eLibMCDataBuildJobStatus
	ret := C.CCall_libmcdata_buildjob_getstatus(inst.wrapperRef.LibraryHandle, inst.Ref, &status)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return BuildJobStatus(status), nil
}

// GetTimeStamp returns the timestamp when the job was created.
func (inst BuildJob) GetTimeStamp() (string, error) {
	var neededfortimestamp C.uint32_t
	var filledintimestamp C.uint32_t
	ret := C.CCall_libmcdata_buildjob_gettimestamp(inst.wrapperRef.LibraryHandle, inst.Ref, 0, &neededfortimestamp, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizetimestamp := neededfortimestamp
	buffertimestamp := make([]byte, bufferSizetimestamp)
	ret = C.CCall_libmcdata_buildjob_gettimestamp(inst.wrapperRef.LibraryHandle, inst.Ref, bufferSizetimestamp, &filledintimestamp, (*C.char)(unsafe.Pointer(&buffertimestamp[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(buffertimestamp[:(filledintimestamp-1)]), nil
}

// GetStorageStream returns the storage stream of the build.
func (inst BuildJob) GetStorageStream() (StorageStream, error) {
	var streamInstance ref
	ret := C.CCall_libmcdata_buildjob_getstoragestream(inst.wrapperRef.LibraryHandle, inst.Ref, &streamInstance)
	if ret != 0 {
		return StorageStream{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewStorageStream(streamInstance), nil
}

// GetBuildJobLogger creates a build job log session access class.
func (inst BuildJob) GetBuildJobLogger() (LogSession, error) {
	var logSession ref
	ret := C.CCall_libmcdata_buildjob_getbuildjoblogger(inst.wrapperRef.LibraryHandle, inst.Ref, &logSession)
	if ret != 0 {
		return LogSession{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewLogSession(logSession), nil
}


// BuildJobIterator represents a LibMCData class.
type BuildJobIterator struct {
	Iterator
}

func (wrapper * Wrapper) NewBuildJobIterator(r ref) BuildJobIterator {
	return BuildJobIterator{wrapper.NewIterator(r)}
}
// GetCurrentJob returns the build job the iterator points at.
func (inst BuildJobIterator) GetCurrentJob() (BuildJob, error) {
	var currentInstance ref
	ret := C.CCall_libmcdata_buildjobiterator_getcurrentjob(inst.wrapperRef.LibraryHandle, inst.Ref, &currentInstance)
	if ret != 0 {
		return BuildJob{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewBuildJob(currentInstance), nil
}


// BuildJobHandler represents a LibMCData class.
type BuildJobHandler struct {
	Base
}

func (wrapper * Wrapper) NewBuildJobHandler(r ref) BuildJobHandler {
	return BuildJobHandler{wrapper.NewBase(r)}
}
// CreateJob creates a new build job.
func (inst BuildJobHandler) CreateJob(jobUUID string, name string, userID string, streamInstance StorageStream) (BuildJob, error) {
	var jobInstance ref
	ret := C.CCall_libmcdata_buildjobhandler_createjob(inst.wrapperRef.LibraryHandle, inst.Ref, (*C.char)(unsafe.Pointer(&[]byte(jobUUID)[0])), (*C.char)(unsafe.Pointer(&[]byte(name)[0])), (*C.char)(unsafe.Pointer(&[]byte(userID)[0])), streamInstance.Ref, &jobInstance)
	if ret != 0 {
		return BuildJob{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewBuildJob(jobInstance), nil
}

// RetrieveJob retrieves a job with a specific UUID.
func (inst BuildJobHandler) RetrieveJob(jobUUID string) (BuildJob, error) {
	var jobInstance ref
	ret := C.CCall_libmcdata_buildjobhandler_retrievejob(inst.wrapperRef.LibraryHandle, inst.Ref, (*C.char)(unsafe.Pointer(&[]byte(jobUUID)[0])), &jobInstance)
	if ret != 0 {
		return BuildJob{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewBuildJob(jobInstance), nil
}

// ListJobsByStatus retrieves a list of build jobs, filtered by status.
func (inst BuildJobHandler) ListJobsByStatus(status BuildJobStatus) (BuildJobIterator, error) {
	var iteratorInstance ref
	ret := C.CCall_libmcdata_buildjobhandler_listjobsbystatus(inst.wrapperRef.LibraryHandle, inst.Ref, C.eLibMCDataBuildJobStatus(status), &iteratorInstance)
	if ret != 0 {
		return BuildJobIterator{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewBuildJobIterator(iteratorInstance), nil
}

// ConvertBuildStatusToString converts a status enum to a string identifier.
func (inst BuildJobHandler) ConvertBuildStatusToString(status BuildJobStatus) (string, error) {
	var neededforstring C.uint32_t
	var filledinstring C.uint32_t
	ret := C.CCall_libmcdata_buildjobhandler_convertbuildstatustostring(inst.wrapperRef.LibraryHandle, inst.Ref, C.eLibMCDataBuildJobStatus(status), 0, &neededforstring, nil)
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	bufferSizestring := neededforstring
	bufferstring := make([]byte, bufferSizestring)
	ret = C.CCall_libmcdata_buildjobhandler_convertbuildstatustostring(inst.wrapperRef.LibraryHandle, inst.Ref, C.eLibMCDataBuildJobStatus(status), bufferSizestring, &filledinstring, (*C.char)(unsafe.Pointer(&bufferstring[0])))
	if ret != 0 {
		return "", makeError(uint32(ret))
	}
	return string(bufferstring[:(filledinstring-1)]), nil
}

// ConvertStringToBuildStatus converts a string identifier to a status enum. Case sensitive. Fails if invalid.
func (inst BuildJobHandler) ConvertStringToBuildStatus(string string) (BuildJobStatus, error) {
	var status C.eLibMCDataBuildJobStatus
	ret := C.CCall_libmcdata_buildjobhandler_convertstringtobuildstatus(inst.wrapperRef.LibraryHandle, inst.Ref, (*C.char)(unsafe.Pointer(&[]byte(string)[0])), &status)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return BuildJobStatus(status), nil
}


// DataModel represents a LibMCData class.
type DataModel struct {
	Base
}

func (wrapper * Wrapper) NewDataModel(r ref) DataModel {
	return DataModel{wrapper.NewBase(r)}
}
// InitialiseDatabase initializes the database connection.
func (inst DataModel) InitialiseDatabase(dataDirectory string, dataBaseType DataBaseType, connectionString string) error {
	ret := C.CCall_libmcdata_datamodel_initialisedatabase(inst.wrapperRef.LibraryHandle, inst.Ref, (*C.char)(unsafe.Pointer(&[]byte(dataDirectory)[0])), C.eLibMCDataDataBaseType(dataBaseType), (*C.char)(unsafe.Pointer(&[]byte(connectionString)[0])))
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetDataModelVersion returns the linear data model version.
func (inst DataModel) GetDataModelVersion() (uint32, error) {
	var version C.uint32_t
	ret := C.CCall_libmcdata_datamodel_getdatamodelversion(inst.wrapperRef.LibraryHandle, inst.Ref, &version)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint32(version), nil
}

// CreateStorage creates a storage access class.
func (inst DataModel) CreateStorage() (Storage, error) {
	var storage ref
	ret := C.CCall_libmcdata_datamodel_createstorage(inst.wrapperRef.LibraryHandle, inst.Ref, &storage)
	if ret != 0 {
		return Storage{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewStorage(storage), nil
}

// CreateBuildJobHandler creates a build job access class.
func (inst DataModel) CreateBuildJobHandler() (BuildJobHandler, error) {
	var buildJobHandler ref
	ret := C.CCall_libmcdata_datamodel_createbuildjobhandler(inst.wrapperRef.LibraryHandle, inst.Ref, &buildJobHandler)
	if ret != 0 {
		return BuildJobHandler{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewBuildJobHandler(buildJobHandler), nil
}

// CreateNewLogSession creates a global log session access class.
func (inst DataModel) CreateNewLogSession() (LogSession, error) {
	var logSession ref
	ret := C.CCall_libmcdata_datamodel_createnewlogsession(inst.wrapperRef.LibraryHandle, inst.Ref, &logSession)
	if ret != 0 {
		return LogSession{}, makeError(uint32(ret))
	}
	return inst.wrapperRef.NewLogSession(logSession), nil
}


// GetVersion retrieves the binary version of this library.
func (wrapper Wrapper) GetVersion() (uint32, uint32, uint32, error) {
	var major C.uint32_t
	var minor C.uint32_t
	var micro C.uint32_t
	ret := C.CCall_libmcdata_getversion(wrapper.LibraryHandle, &major, &minor, &micro)
	if ret != 0 {
		return 0, 0, 0, makeError(uint32(ret))
	}
	return uint32(major), uint32(minor), uint32(micro), nil
}

// GetLastError returns the last error recorded on this object.
func (wrapper Wrapper) GetLastError(instance Base) (string, bool, error) {
	var neededforerrorMessage C.uint32_t
	var filledinerrorMessage C.uint32_t
	var hasError C.bool
	ret := C.CCall_libmcdata_getlasterror(wrapper.LibraryHandle, instance.Ref, 0, &neededforerrorMessage, nil, &hasError)
	if ret != 0 {
		return "", false, makeError(uint32(ret))
	}
	bufferSizeerrorMessage := neededforerrorMessage
	buffererrorMessage := make([]byte, bufferSizeerrorMessage)
	ret = C.CCall_libmcdata_getlasterror(wrapper.LibraryHandle, instance.Ref, bufferSizeerrorMessage, &filledinerrorMessage, (*C.char)(unsafe.Pointer(&buffererrorMessage[0])), &hasError)
	if ret != 0 {
		return "", false, makeError(uint32(ret))
	}
	return string(buffererrorMessage[:(filledinerrorMessage-1)]), bool(hasError), nil
}

// ReleaseInstance releases shared ownership of an Instance.
func (wrapper Wrapper) ReleaseInstance(instance Base) error {
	ret := C.CCall_libmcdata_releaseinstance(wrapper.LibraryHandle, instance.Ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// AcquireInstance acquires shared ownership of an Instance.
func (wrapper Wrapper) AcquireInstance(instance Base) error {
	ret := C.CCall_libmcdata_acquireinstance(wrapper.LibraryHandle, instance.Ref)
	if ret != 0 {
		return makeError(uint32(ret))
	}
	return nil
}

// GetSymbolLookupMethod returns the address of the SymbolLookupMethod.
func (wrapper Wrapper) GetSymbolLookupMethod() (uint64, error) {
	var symbolLookupMethod C.uint64_t
	ret := C.CCall_libmcdata_getsymbollookupmethod(wrapper.LibraryHandle, &symbolLookupMethod)
	if ret != 0 {
		return 0, makeError(uint32(ret))
	}
	return uint64(symbolLookupMethod), nil
}

// CreateDataModelInstance creates and initializes new MC DataModel Instance.
func (wrapper Wrapper) CreateDataModelInstance() (DataModel, error) {
	var instance ref
	ret := C.CCall_libmcdata_createdatamodelinstance(wrapper.LibraryHandle, &instance)
	if ret != 0 {
		return DataModel{}, makeError(uint32(ret))
	}
	return wrapper.NewDataModel(instance), nil
}

func (wrapper * Wrapper) releaseC(r *ref) error {
	if r == nil || *r == nil {
		return nil
	}
	return wrapper.ReleaseInstance(Base{Ref: *r})
}

func (wrapper * Wrapper) CheckBinaryVersion() error {
	var nBindingMajor uint32 = 1;
	var nBindingMinor uint32 = 0;
	nMajor, nMinor, _, err := wrapper.GetVersion()
	if err != nil {
		return err;
	}
	if (nMajor != nBindingMajor) || (nMinor < nBindingMinor) {
		return makeError(0)
	}
	return nil
}

func LoadLibrary (libraryPath string) (Wrapper, error) {
	var wrapper Wrapper;
	wrapper.LibraryHandle = C.loadLibMCDataLibrary (C.CString (libraryPath));
	if (wrapper.LibraryHandle == nil) {
		return wrapper, makeError (LIBMCDATA_ERROR_COULDNOTLOADLIBRARY)
	}
	
	return wrapper, nil
	
}
